var KL = Object.defineProperty;
var ZL = (t, e, n) => e in t ? KL(t, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : t[e] = n;
var ye = (t, e, n) => (ZL(t, typeof e != "symbol" ? e + "" : e, n), n);
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s);
    new MutationObserver(s => {
        for (const i of s)
            if (i.type === "childList")
                for (const o of i.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function n(s) {
        const i = {};
        return s.integrity && (i.integrity = s.integrity), s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i
    }

    function r(s) {
        if (s.ep) return;
        s.ep = !0;
        const i = n(s);
        fetch(s.href, i)
    }
})();

function Qv(t, e) {
    const n = Object.create(null),
        r = t.split(",");
    for (let s = 0; s < r.length; s++) n[r[s]] = !0;
    return e ? s => !!n[s.toLowerCase()] : s => !!n[s]
}
const rn = {},
    Sl = [],
    zs = () => {},
    XL = () => !1,
    QL = /^on[^a-z]/,
    Cm = t => QL.test(t),
    Jv = t => t.startsWith("onUpdate:"),
    Rn = Object.assign,
    e2 = (t, e) => {
        const n = t.indexOf(e);
        n > -1 && t.splice(n, 1)
    },
    JL = Object.prototype.hasOwnProperty,
    Rt = (t, e) => JL.call(t, e),
    Ke = Array.isArray,
    wl = t => Pf(t) === "[object Map]",
    km = t => Pf(t) === "[object Set]",
    DE = t => Pf(t) === "[object Date]",
    gt = t => typeof t == "function",
    En = t => typeof t == "string",
    qh = t => typeof t == "symbol",
    Kt = t => t !== null && typeof t == "object",
    R8 = t => Kt(t) && gt(t.then) && gt(t.catch),
    M8 = Object.prototype.toString,
    Pf = t => M8.call(t),
    eF = t => Pf(t).slice(8, -1),
    D8 = t => Pf(t) === "[object Object]",
    t2 = t => En(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t,
    Rp = Qv(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    Im = t => {
        const e = Object.create(null);
        return n => e[n] || (e[n] = t(n))
    },
    tF = /-(\w)/g,
    Ai = Im(t => t.replace(tF, (e, n) => n ? n.toUpperCase() : "")),
    nF = /\B([A-Z])/g,
    xc = Im(t => t.replace(nF, "-$1").toLowerCase()),
    Nm = Im(t => t.charAt(0).toUpperCase() + t.slice(1)),
    Q_ = Im(t => t ? `on${Nm(t)}` : ""),
    Gh = (t, e) => !Object.is(t, e),
    Mp = (t, e) => {
        for (let n = 0; n < t.length; n++) t[n](e)
    },
    zp = (t, e, n) => {
        Object.defineProperty(t, e, {
            configurable: !0,
            enumerable: !1,
            value: n
        })
    },
    l0 = t => {
        const e = parseFloat(t);
        return isNaN(e) ? t : e
    },
    rF = t => {
        const e = En(t) ? Number(t) : NaN;
        return isNaN(e) ? t : e
    };
let $E;
const u0 = () => $E || ($E = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function sn(t) {
    if (Ke(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const r = t[n],
                s = En(r) ? aF(r) : sn(r);
            if (s)
                for (const i in s) e[i] = s[i]
        }
        return e
    } else {
        if (En(t)) return t;
        if (Kt(t)) return t
    }
}
const sF = /;(?![^(]*\))/g,
    iF = /:([^]+)/,
    oF = /\/\*[^]*?\*\//g;

function aF(t) {
    const e = {};
    return t.replace(oF, "").split(sF).forEach(n => {
        if (n) {
            const r = n.split(iF);
            r.length > 1 && (e[r[0].trim()] = r[1].trim())
        }
    }), e
}

function nt(t) {
    let e = "";
    if (En(t)) e = t;
    else if (Ke(t))
        for (let n = 0; n < t.length; n++) {
            const r = nt(t[n]);
            r && (e += r + " ")
        } else if (Kt(t))
            for (const n in t) t[n] && (e += n + " ");
    return e.trim()
}

function cF(t) {
    if (!t) return null;
    let {
        class: e,
        style: n
    } = t;
    return e && !En(e) && (t.class = nt(e)), n && (t.style = sn(n)), t
}
const lF = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    uF = Qv(lF);

function $8(t) {
    return !!t || t === ""
}

function hF(t, e) {
    if (t.length !== e.length) return !1;
    let n = !0;
    for (let r = 0; n && r < t.length; r++) n = xm(t[r], e[r]);
    return n
}

function xm(t, e) {
    if (t === e) return !0;
    let n = DE(t),
        r = DE(e);
    if (n || r) return n && r ? t.getTime() === e.getTime() : !1;
    if (n = qh(t), r = qh(e), n || r) return t === e;
    if (n = Ke(t), r = Ke(e), n || r) return n && r ? hF(t, e) : !1;
    if (n = Kt(t), r = Kt(e), n || r) {
        if (!n || !r) return !1;
        const s = Object.keys(t).length,
            i = Object.keys(e).length;
        if (s !== i) return !1;
        for (const o in t) {
            const a = t.hasOwnProperty(o),
                l = e.hasOwnProperty(o);
            if (a && !l || !a && l || !xm(t[o], e[o])) return !1
        }
    }
    return String(t) === String(e)
}

function L8(t, e) {
    return t.findIndex(n => xm(n, e))
}
const rt = t => En(t) ? t : t == null ? "" : Ke(t) || Kt(t) && (t.toString === M8 || !gt(t.toString)) ? JSON.stringify(t, F8, 2) : String(t),
    F8 = (t, e) => e && e.__v_isRef ? F8(t, e.value) : wl(e) ? {
        [`Map(${e.size})`]: [...e.entries()].reduce((n, [r, s]) => (n[`${r} =>`] = s, n), {})
    } : km(e) ? {
        [`Set(${e.size})`]: [...e.values()]
    } : Kt(e) && !Ke(e) && !D8(e) ? String(e) : e;
let Us;
class U8 {
    constructor(e = !1) {
        this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Us, !e && Us && (this.index = (Us.scopes || (Us.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(e) {
        if (this._active) {
            const n = Us;
            try {
                return Us = this, e()
            } finally {
                Us = n
            }
        }
    }
    on() {
        Us = this
    }
    off() {
        Us = this.parent
    }
    stop(e) {
        if (this._active) {
            let n, r;
            for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop();
            for (n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]();
            if (this.scopes)
                for (n = 0, r = this.scopes.length; n < r; n++) this.scopes[n].stop(!0);
            if (!this.detached && this.parent && !e) {
                const s = this.parent.scopes.pop();
                s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index)
            }
            this.parent = void 0, this._active = !1
        }
    }
}

function fF(t) {
    return new U8(t)
}

function dF(t, e = Us) {
    e && e.active && e.effects.push(t)
}

function pF() {
    return Us
}
const n2 = t => {
        const e = new Set(t);
        return e.w = 0, e.n = 0, e
    },
    B8 = t => (t.w & la) > 0,
    q8 = t => (t.n & la) > 0,
    mF = ({
        deps: t
    }) => {
        if (t.length)
            for (let e = 0; e < t.length; e++) t[e].w |= la
    },
    gF = t => {
        const {
            deps: e
        } = t;
        if (e.length) {
            let n = 0;
            for (let r = 0; r < e.length; r++) {
                const s = e[r];
                B8(s) && !q8(s) ? s.delete(t) : e[n++] = s, s.w &= ~la, s.n &= ~la
            }
            e.length = n
        }
    },
    h0 = new WeakMap;
let hh = 0,
    la = 1;
const f0 = 30;
let Vs;
const dc = Symbol(""),
    d0 = Symbol("");
class r2 {
    constructor(e, n = null, r) {
        this.fn = e, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, dF(this, r)
    }
    run() {
        if (!this.active) return this.fn();
        let e = Vs,
            n = ea;
        for (; e;) {
            if (e === this) return;
            e = e.parent
        }
        try {
            return this.parent = Vs, Vs = this, ea = !0, la = 1 << ++hh, hh <= f0 ? mF(this) : LE(this), this.fn()
        } finally {
            hh <= f0 && gF(this), la = 1 << --hh, Vs = this.parent, ea = n, this.parent = void 0, this.deferStop && this.stop()
        }
    }
    stop() {
        Vs === this ? this.deferStop = !0 : this.active && (LE(this), this.onStop && this.onStop(), this.active = !1)
    }
}

function LE(t) {
    const {
        deps: e
    } = t;
    if (e.length) {
        for (let n = 0; n < e.length; n++) e[n].delete(t);
        e.length = 0
    }
}
let ea = !0;
const G8 = [];

function vu() {
    G8.push(ea), ea = !1
}

function bu() {
    const t = G8.pop();
    ea = t === void 0 ? !0 : t
}

function Br(t, e, n) {
    if (ea && Vs) {
        let r = h0.get(t);
        r || h0.set(t, r = new Map);
        let s = r.get(n);
        s || r.set(n, s = n2()), V8(s)
    }
}

function V8(t, e) {
    let n = !1;
    hh <= f0 ? q8(t) || (t.n |= la, n = !B8(t)) : n = !t.has(Vs), n && (t.add(Vs), Vs.deps.push(t))
}

function fo(t, e, n, r, s, i) {
    const o = h0.get(t);
    if (!o) return;
    let a = [];
    if (e === "clear") a = [...o.values()];
    else if (n === "length" && Ke(t)) {
        const l = Number(r);
        o.forEach((u, f) => {
            (f === "length" || f >= l) && a.push(u)
        })
    } else switch (n !== void 0 && a.push(o.get(n)), e) {
        case "add":
            Ke(t) ? t2(n) && a.push(o.get("length")) : (a.push(o.get(dc)), wl(t) && a.push(o.get(d0)));
            break;
        case "delete":
            Ke(t) || (a.push(o.get(dc)), wl(t) && a.push(o.get(d0)));
            break;
        case "set":
            wl(t) && a.push(o.get(dc));
            break
    }
    if (a.length === 1) a[0] && p0(a[0]);
    else {
        const l = [];
        for (const u of a) u && l.push(...u);
        p0(n2(l))
    }
}

function p0(t, e) {
    const n = Ke(t) ? t : [...t];
    for (const r of n) r.computed && FE(r);
    for (const r of n) r.computed || FE(r)
}

function FE(t, e) {
    (t !== Vs || t.allowRecurse) && (t.scheduler ? t.scheduler() : t.run())
}
const _F = Qv("__proto__,__v_isRef,__isVue"),
    j8 = new Set(Object.getOwnPropertyNames(Symbol).filter(t => t !== "arguments" && t !== "caller").map(t => Symbol[t]).filter(qh)),
    yF = s2(),
    vF = s2(!1, !0),
    bF = s2(!0),
    UE = EF();

function EF() {
    const t = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
        t[e] = function(...n) {
            const r = Dt(this);
            for (let i = 0, o = this.length; i < o; i++) Br(r, "get", i + "");
            const s = r[e](...n);
            return s === -1 || s === !1 ? r[e](...n.map(Dt)) : s
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
        t[e] = function(...n) {
            vu();
            const r = Dt(this)[e].apply(this, n);
            return bu(), r
        }
    }), t
}

function TF(t) {
    const e = Dt(this);
    return Br(e, "has", t), e.hasOwnProperty(t)
}

function s2(t = !1, e = !1) {
    return function(r, s, i) {
        if (s === "__v_isReactive") return !t;
        if (s === "__v_isReadonly") return t;
        if (s === "__v_isShallow") return e;
        if (s === "__v_raw" && i === (t ? e ? FF : K8 : e ? z8 : Y8).get(r)) return r;
        const o = Ke(r);
        if (!t) {
            if (o && Rt(UE, s)) return Reflect.get(UE, s, i);
            if (s === "hasOwnProperty") return TF
        }
        const a = Reflect.get(r, s, i);
        return (qh(s) ? j8.has(s) : _F(s)) || (t || Br(r, "get", s), e) ? a : Xn(a) ? o && t2(s) ? a : a.value : Kt(a) ? t ? Z8(a) : Ec(a) : a
    }
}
const SF = W8(),
    wF = W8(!0);

function W8(t = !1) {
    return function(n, r, s, i) {
        let o = n[r];
        if (jl(o) && Xn(o) && !Xn(s)) return !1;
        if (!t && (!Kp(s) && !jl(s) && (o = Dt(o), s = Dt(s)), !Ke(n) && Xn(o) && !Xn(s))) return o.value = s, !0;
        const a = Ke(n) && t2(r) ? Number(r) < n.length : Rt(n, r),
            l = Reflect.set(n, r, s, i);
        return n === Dt(i) && (a ? Gh(s, o) && fo(n, "set", r, s) : fo(n, "add", r, s)), l
    }
}

function AF(t, e) {
    const n = Rt(t, e);
    t[e];
    const r = Reflect.deleteProperty(t, e);
    return r && n && fo(t, "delete", e, void 0), r
}

function OF(t, e) {
    const n = Reflect.has(t, e);
    return (!qh(e) || !j8.has(e)) && Br(t, "has", e), n
}

function CF(t) {
    return Br(t, "iterate", Ke(t) ? "length" : dc), Reflect.ownKeys(t)
}
const H8 = {
        get: yF,
        set: SF,
        deleteProperty: AF,
        has: OF,
        ownKeys: CF
    },
    kF = {
        get: bF,
        set(t, e) {
            return !0
        },
        deleteProperty(t, e) {
            return !0
        }
    },
    IF = Rn({}, H8, {
        get: vF,
        set: wF
    }),
    i2 = t => t,
    Pm = t => Reflect.getPrototypeOf(t);

function Jd(t, e, n = !1, r = !1) {
    t = t.__v_raw;
    const s = Dt(t),
        i = Dt(e);
    n || (e !== i && Br(s, "get", e), Br(s, "get", i));
    const {
        has: o
    } = Pm(s), a = r ? i2 : n ? l2 : Vh;
    if (o.call(s, e)) return a(t.get(e));
    if (o.call(s, i)) return a(t.get(i));
    t !== s && t.get(e)
}

function ep(t, e = !1) {
    const n = this.__v_raw,
        r = Dt(n),
        s = Dt(t);
    return e || (t !== s && Br(r, "has", t), Br(r, "has", s)), t === s ? n.has(t) : n.has(t) || n.has(s)
}

function tp(t, e = !1) {
    return t = t.__v_raw, !e && Br(Dt(t), "iterate", dc), Reflect.get(t, "size", t)
}

function BE(t) {
    t = Dt(t);
    const e = Dt(this);
    return Pm(e).has.call(e, t) || (e.add(t), fo(e, "add", t, t)), this
}

function qE(t, e) {
    e = Dt(e);
    const n = Dt(this),
        {
            has: r,
            get: s
        } = Pm(n);
    let i = r.call(n, t);
    i || (t = Dt(t), i = r.call(n, t));
    const o = s.call(n, t);
    return n.set(t, e), i ? Gh(e, o) && fo(n, "set", t, e) : fo(n, "add", t, e), this
}

function GE(t) {
    const e = Dt(this),
        {
            has: n,
            get: r
        } = Pm(e);
    let s = n.call(e, t);
    s || (t = Dt(t), s = n.call(e, t)), r && r.call(e, t);
    const i = e.delete(t);
    return s && fo(e, "delete", t, void 0), i
}

function VE() {
    const t = Dt(this),
        e = t.size !== 0,
        n = t.clear();
    return e && fo(t, "clear", void 0, void 0), n
}

function np(t, e) {
    return function(r, s) {
        const i = this,
            o = i.__v_raw,
            a = Dt(o),
            l = e ? i2 : t ? l2 : Vh;
        return !t && Br(a, "iterate", dc), o.forEach((u, f) => r.call(s, l(u), l(f), i))
    }
}

function rp(t, e, n) {
    return function(...r) {
        const s = this.__v_raw,
            i = Dt(s),
            o = wl(i),
            a = t === "entries" || t === Symbol.iterator && o,
            l = t === "keys" && o,
            u = s[t](...r),
            f = n ? i2 : e ? l2 : Vh;
        return !e && Br(i, "iterate", l ? d0 : dc), {
            next() {
                const {
                    value: d,
                    done: p
                } = u.next();
                return p ? {
                    value: d,
                    done: p
                } : {
                    value: a ? [f(d[0]), f(d[1])] : f(d),
                    done: p
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function Ro(t) {
    return function(...e) {
        return t === "delete" ? !1 : this
    }
}

function NF() {
    const t = {
            get(i) {
                return Jd(this, i)
            },
            get size() {
                return tp(this)
            },
            has: ep,
            add: BE,
            set: qE,
            delete: GE,
            clear: VE,
            forEach: np(!1, !1)
        },
        e = {
            get(i) {
                return Jd(this, i, !1, !0)
            },
            get size() {
                return tp(this)
            },
            has: ep,
            add: BE,
            set: qE,
            delete: GE,
            clear: VE,
            forEach: np(!1, !0)
        },
        n = {
            get(i) {
                return Jd(this, i, !0)
            },
            get size() {
                return tp(this, !0)
            },
            has(i) {
                return ep.call(this, i, !0)
            },
            add: Ro("add"),
            set: Ro("set"),
            delete: Ro("delete"),
            clear: Ro("clear"),
            forEach: np(!0, !1)
        },
        r = {
            get(i) {
                return Jd(this, i, !0, !0)
            },
            get size() {
                return tp(this, !0)
            },
            has(i) {
                return ep.call(this, i, !0)
            },
            add: Ro("add"),
            set: Ro("set"),
            delete: Ro("delete"),
            clear: Ro("clear"),
            forEach: np(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(i => {
        t[i] = rp(i, !1, !1), n[i] = rp(i, !0, !1), e[i] = rp(i, !1, !0), r[i] = rp(i, !0, !0)
    }), [t, n, e, r]
}
const [xF, PF, RF, MF] = NF();

function o2(t, e) {
    const n = e ? t ? MF : RF : t ? PF : xF;
    return (r, s, i) => s === "__v_isReactive" ? !t : s === "__v_isReadonly" ? t : s === "__v_raw" ? r : Reflect.get(Rt(n, s) && s in r ? n : r, s, i)
}
const DF = {
        get: o2(!1, !1)
    },
    $F = {
        get: o2(!1, !0)
    },
    LF = {
        get: o2(!0, !1)
    },
    Y8 = new WeakMap,
    z8 = new WeakMap,
    K8 = new WeakMap,
    FF = new WeakMap;

function UF(t) {
    switch (t) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}

function BF(t) {
    return t.__v_skip || !Object.isExtensible(t) ? 0 : UF(eF(t))
}

function Ec(t) {
    return jl(t) ? t : a2(t, !1, H8, DF, Y8)
}

function qF(t) {
    return a2(t, !1, IF, $F, z8)
}

function Z8(t) {
    return a2(t, !0, kF, LF, K8)
}

function a2(t, e, n, r, s) {
    if (!Kt(t) || t.__v_raw && !(e && t.__v_isReactive)) return t;
    const i = s.get(t);
    if (i) return i;
    const o = BF(t);
    if (o === 0) return t;
    const a = new Proxy(t, o === 2 ? r : n);
    return s.set(t, a), a
}

function Al(t) {
    return jl(t) ? Al(t.__v_raw) : !!(t && t.__v_isReactive)
}

function jl(t) {
    return !!(t && t.__v_isReadonly)
}

function Kp(t) {
    return !!(t && t.__v_isShallow)
}

function X8(t) {
    return Al(t) || jl(t)
}

function Dt(t) {
    const e = t && t.__v_raw;
    return e ? Dt(e) : t
}

function c2(t) {
    return zp(t, "__v_skip", !0), t
}
const Vh = t => Kt(t) ? Ec(t) : t,
    l2 = t => Kt(t) ? Z8(t) : t;

function Q8(t) {
    ea && Vs && (t = Dt(t), V8(t.dep || (t.dep = n2())))
}

function J8(t, e) {
    t = Dt(t);
    const n = t.dep;
    n && p0(n)
}

function Xn(t) {
    return !!(t && t.__v_isRef === !0)
}

function ts(t) {
    return e7(t, !1)
}

function GF(t) {
    return e7(t, !0)
}

function e7(t, e) {
    return Xn(t) ? t : new VF(t, e)
}
class VF {
    constructor(e, n) {
        this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : Dt(e), this._value = n ? e : Vh(e)
    }
    get value() {
        return Q8(this), this._value
    }
    set value(e) {
        const n = this.__v_isShallow || Kp(e) || jl(e);
        e = n ? e : Dt(e), Gh(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : Vh(e), J8(this))
    }
}

function jF(t) {
    return Xn(t) ? t.value : t
}
const WF = {
    get: (t, e, n) => jF(Reflect.get(t, e, n)),
    set: (t, e, n, r) => {
        const s = t[e];
        return Xn(s) && !Xn(n) ? (s.value = n, !0) : Reflect.set(t, e, n, r)
    }
};

function t7(t) {
    return Al(t) ? t : new Proxy(t, WF)
}
class HF {
    constructor(e, n, r, s) {
        this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new r2(e, () => {
            this._dirty || (this._dirty = !0, J8(this))
        }), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = r
    }
    get value() {
        const e = Dt(this);
        return Q8(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value
    }
    set value(e) {
        this._setter(e)
    }
}

function YF(t, e, n = !1) {
    let r, s;
    const i = gt(t);
    return i ? (r = t, s = zs) : (r = t.get, s = t.set), new HF(r, s, i || !s, n)
}

function ta(t, e, n, r) {
    let s;
    try {
        s = r ? t(...r) : t()
    } catch (i) {
        Rm(i, e, n)
    }
    return s
}

function Os(t, e, n, r) {
    if (gt(t)) {
        const i = ta(t, e, n, r);
        return i && R8(i) && i.catch(o => {
            Rm(o, e, n)
        }), i
    }
    const s = [];
    for (let i = 0; i < t.length; i++) s.push(Os(t[i], e, n, r));
    return s
}

function Rm(t, e, n, r = !0) {
    const s = e ? e.vnode : null;
    if (e) {
        let i = e.parent;
        const o = e.proxy,
            a = n;
        for (; i;) {
            const u = i.ec;
            if (u) {
                for (let f = 0; f < u.length; f++)
                    if (u[f](t, o, a) === !1) return
            }
            i = i.parent
        }
        const l = e.appContext.config.errorHandler;
        if (l) {
            ta(l, null, 10, [t, o, a]);
            return
        }
    }
    zF(t, n, s, r)
}

function zF(t, e, n, r = !0) {
    console.error(t)
}
let jh = !1,
    m0 = !1;
const lr = [];
let Ei = 0;
const Ol = [];
let Ji = null,
    tc = 0;
const n7 = Promise.resolve();
let u2 = null;

function KF(t) {
    const e = u2 || n7;
    return t ? e.then(this ? t.bind(this) : t) : e
}

function ZF(t) {
    let e = Ei + 1,
        n = lr.length;
    for (; e < n;) {
        const r = e + n >>> 1;
        Wh(lr[r]) < t ? e = r + 1 : n = r
    }
    return e
}

function h2(t) {
    (!lr.length || !lr.includes(t, jh && t.allowRecurse ? Ei + 1 : Ei)) && (t.id == null ? lr.push(t) : lr.splice(ZF(t.id), 0, t), r7())
}

function r7() {
    !jh && !m0 && (m0 = !0, u2 = n7.then(i7))
}

function XF(t) {
    const e = lr.indexOf(t);
    e > Ei && lr.splice(e, 1)
}

function QF(t) {
    Ke(t) ? Ol.push(...t) : (!Ji || !Ji.includes(t, t.allowRecurse ? tc + 1 : tc)) && Ol.push(t), r7()
}

function jE(t, e = jh ? Ei + 1 : 0) {
    for (; e < lr.length; e++) {
        const n = lr[e];
        n && n.pre && (lr.splice(e, 1), e--, n())
    }
}

function s7(t) {
    if (Ol.length) {
        const e = [...new Set(Ol)];
        if (Ol.length = 0, Ji) {
            Ji.push(...e);
            return
        }
        for (Ji = e, Ji.sort((n, r) => Wh(n) - Wh(r)), tc = 0; tc < Ji.length; tc++) Ji[tc]();
        Ji = null, tc = 0
    }
}
const Wh = t => t.id == null ? 1 / 0 : t.id,
    JF = (t, e) => {
        const n = Wh(t) - Wh(e);
        if (n === 0) {
            if (t.pre && !e.pre) return -1;
            if (e.pre && !t.pre) return 1
        }
        return n
    };

function i7(t) {
    m0 = !1, jh = !0, lr.sort(JF);
    const e = zs;
    try {
        for (Ei = 0; Ei < lr.length; Ei++) {
            const n = lr[Ei];
            n && n.active !== !1 && ta(n, null, 14)
        }
    } finally {
        Ei = 0, lr.length = 0, s7(), jh = !1, u2 = null, (lr.length || Ol.length) && i7()
    }
}

function eU(t, e, ...n) {
    if (t.isUnmounted) return;
    const r = t.vnode.props || rn;
    let s = n;
    const i = e.startsWith("update:"),
        o = i && e.slice(7);
    if (o && o in r) {
        const f = `${o==="modelValue"?"model":o}Modifiers`,
            {
                number: d,
                trim: p
            } = r[f] || rn;
        p && (s = n.map(_ => En(_) ? _.trim() : _)), d && (s = n.map(l0))
    }
    let a, l = r[a = Q_(e)] || r[a = Q_(Ai(e))];
    !l && i && (l = r[a = Q_(xc(e))]), l && Os(l, t, 6, s);
    const u = r[a + "Once"];
    if (u) {
        if (!t.emitted) t.emitted = {};
        else if (t.emitted[a]) return;
        t.emitted[a] = !0, Os(u, t, 6, s)
    }
}

function o7(t, e, n = !1) {
    const r = e.emitsCache,
        s = r.get(t);
    if (s !== void 0) return s;
    const i = t.emits;
    let o = {},
        a = !1;
    if (!gt(t)) {
        const l = u => {
            const f = o7(u, e, !0);
            f && (a = !0, Rn(o, f))
        };
        !n && e.mixins.length && e.mixins.forEach(l), t.extends && l(t.extends), t.mixins && t.mixins.forEach(l)
    }
    return !i && !a ? (Kt(t) && r.set(t, null), null) : (Ke(i) ? i.forEach(l => o[l] = null) : Rn(o, i), Kt(t) && r.set(t, o), o)
}

function Mm(t, e) {
    return !t || !Cm(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Rt(t, e[0].toLowerCase() + e.slice(1)) || Rt(t, xc(e)) || Rt(t, e))
}
let Qn = null,
    Dm = null;

function Zp(t) {
    const e = Qn;
    return Qn = t, Dm = t && t.type.__scopeId || null, e
}

function Gr(t) {
    Dm = t
}

function Vr() {
    Dm = null
}

function $i(t, e = Qn, n) {
    if (!e || t._n) return t;
    const r = (...s) => {
        r._d && nT(-1);
        const i = Zp(e);
        let o;
        try {
            o = t(...s)
        } finally {
            Zp(i), r._d && nT(1)
        }
        return o
    };
    return r._n = !0, r._c = !0, r._d = !0, r
}

function J_(t) {
    const {
        type: e,
        vnode: n,
        proxy: r,
        withProxy: s,
        props: i,
        propsOptions: [o],
        slots: a,
        attrs: l,
        emit: u,
        render: f,
        renderCache: d,
        data: p,
        setupState: _,
        ctx: v,
        inheritAttrs: y
    } = t;
    let g, b;
    const O = Zp(t);
    try {
        if (n.shapeFlag & 4) {
            const k = s || r;
            g = yi(f.call(k, k, d, i, _, p, v)), b = l
        } else {
            const k = e;
            g = yi(k.length > 1 ? k(i, {
                attrs: l,
                slots: a,
                emit: u
            }) : k(i, null)), b = e.props ? l : tU(l)
        }
    } catch (k) {
        Th.length = 0, Rm(k, t, 1), g = Ve(Cs)
    }
    let N = g;
    if (b && y !== !1) {
        const k = Object.keys(b),
            {
                shapeFlag: A
            } = N;
        k.length && A & 7 && (o && k.some(Jv) && (b = nU(b, o)), N = ua(N, b))
    }
    return n.dirs && (N = ua(N), N.dirs = N.dirs ? N.dirs.concat(n.dirs) : n.dirs), n.transition && (N.transition = n.transition), g = N, Zp(O), g
}
const tU = t => {
        let e;
        for (const n in t)(n === "class" || n === "style" || Cm(n)) && ((e || (e = {}))[n] = t[n]);
        return e
    },
    nU = (t, e) => {
        const n = {};
        for (const r in t)(!Jv(r) || !(r.slice(9) in e)) && (n[r] = t[r]);
        return n
    };

function rU(t, e, n) {
    const {
        props: r,
        children: s,
        component: i
    } = t, {
        props: o,
        children: a,
        patchFlag: l
    } = e, u = i.emitsOptions;
    if (e.dirs || e.transition) return !0;
    if (n && l >= 0) {
        if (l & 1024) return !0;
        if (l & 16) return r ? WE(r, o, u) : !!o;
        if (l & 8) {
            const f = e.dynamicProps;
            for (let d = 0; d < f.length; d++) {
                const p = f[d];
                if (o[p] !== r[p] && !Mm(u, p)) return !0
            }
        }
    } else return (s || a) && (!a || !a.$stable) ? !0 : r === o ? !1 : r ? o ? WE(r, o, u) : !0 : !!o;
    return !1
}

function WE(t, e, n) {
    const r = Object.keys(e);
    if (r.length !== Object.keys(t).length) return !0;
    for (let s = 0; s < r.length; s++) {
        const i = r[s];
        if (e[i] !== t[i] && !Mm(n, i)) return !0
    }
    return !1
}

function sU({
    vnode: t,
    parent: e
}, n) {
    for (; e && e.subTree === t;)(t = e.vnode).el = n, e = e.parent
}
const iU = t => t.__isSuspense;

function oU(t, e) {
    e && e.pendingBranch ? Ke(t) ? e.effects.push(...t) : e.effects.push(t) : QF(t)
}
const sp = {};

function na(t, e, n) {
    return a7(t, e, n)
}

function a7(t, e, {
    immediate: n,
    deep: r,
    flush: s,
    onTrack: i,
    onTrigger: o
} = rn) {
    var a;
    const l = pF() === ((a = jn) == null ? void 0 : a.scope) ? jn : null;
    let u, f = !1,
        d = !1;
    if (Xn(t) ? (u = () => t.value, f = Kp(t)) : Al(t) ? (u = () => t, r = !0) : Ke(t) ? (d = !0, f = t.some(k => Al(k) || Kp(k)), u = () => t.map(k => {
            if (Xn(k)) return k.value;
            if (Al(k)) return cc(k);
            if (gt(k)) return ta(k, l, 2)
        })) : gt(t) ? e ? u = () => ta(t, l, 2) : u = () => {
            if (!(l && l.isUnmounted)) return p && p(), Os(t, l, 3, [_])
        } : u = zs, e && r) {
        const k = u;
        u = () => cc(k())
    }
    let p, _ = k => {
            p = O.onStop = () => {
                ta(k, l, 4)
            }
        },
        v;
    if (zh)
        if (_ = zs, e ? n && Os(e, l, 3, [u(), d ? [] : void 0, _]) : u(), s === "sync") {
            const k = QU();
            v = k.__watcherHandles || (k.__watcherHandles = [])
        } else return zs;
    let y = d ? new Array(t.length).fill(sp) : sp;
    const g = () => {
        if (O.active)
            if (e) {
                const k = O.run();
                (r || f || (d ? k.some((A, x) => Gh(A, y[x])) : Gh(k, y))) && (p && p(), Os(e, l, 3, [k, y === sp ? void 0 : d && y[0] === sp ? [] : y, _]), y = k)
            } else O.run()
    };
    g.allowRecurse = !!e;
    let b;
    s === "sync" ? b = g : s === "post" ? b = () => xr(g, l && l.suspense) : (g.pre = !0, l && (g.id = l.uid), b = () => h2(g));
    const O = new r2(u, b);
    e ? n ? g() : y = O.run() : s === "post" ? xr(O.run.bind(O), l && l.suspense) : O.run();
    const N = () => {
        O.stop(), l && l.scope && e2(l.scope.effects, O)
    };
    return v && v.push(N), N
}

function aU(t, e, n) {
    const r = this.proxy,
        s = En(t) ? t.includes(".") ? c7(r, t) : () => r[t] : t.bind(r, r);
    let i;
    gt(e) ? i = e : (i = e.handler, n = e);
    const o = jn;
    Wl(this);
    const a = a7(s, i.bind(r), n);
    return o ? Wl(o) : pc(), a
}

function c7(t, e) {
    const n = e.split(".");
    return () => {
        let r = t;
        for (let s = 0; s < n.length && r; s++) r = r[n[s]];
        return r
    }
}

function cc(t, e) {
    if (!Kt(t) || t.__v_skip || (e = e || new Set, e.has(t))) return t;
    if (e.add(t), Xn(t)) cc(t.value, e);
    else if (Ke(t))
        for (let n = 0; n < t.length; n++) cc(t[n], e);
    else if (km(t) || wl(t)) t.forEach(n => {
        cc(n, e)
    });
    else if (D8(t))
        for (const n in t) cc(t[n], e);
    return t
}

function $e(t, e) {
    const n = Qn;
    if (n === null) return t;
    const r = Bm(n) || n.proxy,
        s = t.dirs || (t.dirs = []);
    for (let i = 0; i < e.length; i++) {
        let [o, a, l, u = rn] = e[i];
        o && (gt(o) && (o = {
            mounted: o,
            updated: o
        }), o.deep && cc(a), s.push({
            dir: o,
            instance: r,
            value: a,
            oldValue: void 0,
            arg: l,
            modifiers: u
        }))
    }
    return t
}

function Ha(t, e, n, r) {
    const s = t.dirs,
        i = e && e.dirs;
    for (let o = 0; o < s.length; o++) {
        const a = s[o];
        i && (a.oldValue = i[o].value);
        let l = a.dir[r];
        l && (vu(), Os(l, n, 8, [t.el, a, t, e]), bu())
    }
}

function cU() {
    const t = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return f2(() => {
        t.isMounted = !0
    }), p7(() => {
        t.isUnmounting = !0
    }), t
}
const bs = [Function, Array],
    l7 = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: bs,
        onEnter: bs,
        onAfterEnter: bs,
        onEnterCancelled: bs,
        onBeforeLeave: bs,
        onLeave: bs,
        onAfterLeave: bs,
        onLeaveCancelled: bs,
        onBeforeAppear: bs,
        onAppear: bs,
        onAfterAppear: bs,
        onAppearCancelled: bs
    },
    lU = {
        name: "BaseTransition",
        props: l7,
        setup(t, {
            slots: e
        }) {
            const n = Yh(),
                r = cU();
            let s;
            return () => {
                const i = e.default && h7(e.default(), !0);
                if (!i || !i.length) return;
                let o = i[0];
                if (i.length > 1) {
                    for (const y of i)
                        if (y.type !== Cs) {
                            o = y;
                            break
                        }
                }
                const a = Dt(t),
                    {
                        mode: l
                    } = a;
                if (r.isLeaving) return ey(o);
                const u = HE(o);
                if (!u) return ey(o);
                const f = g0(u, a, r, n);
                _0(u, f);
                const d = n.subTree,
                    p = d && HE(d);
                let _ = !1;
                const {
                    getTransitionKey: v
                } = u.type;
                if (v) {
                    const y = v();
                    s === void 0 ? s = y : y !== s && (s = y, _ = !0)
                }
                if (p && p.type !== Cs && (!nc(u, p) || _)) {
                    const y = g0(p, a, r, n);
                    if (_0(p, y), l === "out-in") return r.isLeaving = !0, y.afterLeave = () => {
                        r.isLeaving = !1, n.update.active !== !1 && n.update()
                    }, ey(o);
                    l === "in-out" && u.type !== Cs && (y.delayLeave = (g, b, O) => {
                        const N = u7(r, p);
                        N[String(p.key)] = p, g._leaveCb = () => {
                            b(), g._leaveCb = void 0, delete f.delayedLeave
                        }, f.delayedLeave = O
                    })
                }
                return o
            }
        }
    },
    uU = lU;

function u7(t, e) {
    const {
        leavingVNodes: n
    } = t;
    let r = n.get(e.type);
    return r || (r = Object.create(null), n.set(e.type, r)), r
}

function g0(t, e, n, r) {
    const {
        appear: s,
        mode: i,
        persisted: o = !1,
        onBeforeEnter: a,
        onEnter: l,
        onAfterEnter: u,
        onEnterCancelled: f,
        onBeforeLeave: d,
        onLeave: p,
        onAfterLeave: _,
        onLeaveCancelled: v,
        onBeforeAppear: y,
        onAppear: g,
        onAfterAppear: b,
        onAppearCancelled: O
    } = e, N = String(t.key), k = u7(n, t), A = (L, q) => {
        L && Os(L, r, 9, q)
    }, x = (L, q) => {
        const ee = q[1];
        A(L, q), Ke(L) ? L.every(ae => ae.length <= 1) && ee() : L.length <= 1 && ee()
    }, D = {
        mode: i,
        persisted: o,
        beforeEnter(L) {
            let q = a;
            if (!n.isMounted)
                if (s) q = y || a;
                else return;
            L._leaveCb && L._leaveCb(!0);
            const ee = k[N];
            ee && nc(t, ee) && ee.el._leaveCb && ee.el._leaveCb(), A(q, [L])
        },
        enter(L) {
            let q = l,
                ee = u,
                ae = f;
            if (!n.isMounted)
                if (s) q = g || l, ee = b || u, ae = O || f;
                else return;
            let Z = !1;
            const fe = L._enterCb = ge => {
                Z || (Z = !0, ge ? A(ae, [L]) : A(ee, [L]), D.delayedLeave && D.delayedLeave(), L._enterCb = void 0)
            };
            q ? x(q, [L, fe]) : fe()
        },
        leave(L, q) {
            const ee = String(t.key);
            if (L._enterCb && L._enterCb(!0), n.isUnmounting) return q();
            A(d, [L]);
            let ae = !1;
            const Z = L._leaveCb = fe => {
                ae || (ae = !0, q(), fe ? A(v, [L]) : A(_, [L]), L._leaveCb = void 0, k[ee] === t && delete k[ee])
            };
            k[ee] = t, p ? x(p, [L, Z]) : Z()
        },
        clone(L) {
            return g0(L, e, n, r)
        }
    };
    return D
}

function ey(t) {
    if ($m(t)) return t = ua(t), t.children = null, t
}

function HE(t) {
    return $m(t) ? t.children ? t.children[0] : void 0 : t
}

function _0(t, e) {
    t.shapeFlag & 6 && t.component ? _0(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e
}

function h7(t, e = !1, n) {
    let r = [],
        s = 0;
    for (let i = 0; i < t.length; i++) {
        let o = t[i];
        const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : i);
        o.type === lt ? (o.patchFlag & 128 && s++, r = r.concat(h7(o.children, e, a))) : (e || o.type !== Cs) && r.push(a != null ? ua(o, {
            key: a
        }) : o)
    }
    if (s > 1)
        for (let i = 0; i < r.length; i++) r[i].patchFlag = -2;
    return r
}

function st(t, e) {
    return gt(t) ? (() => Rn({
        name: t.name
    }, e, {
        setup: t
    }))() : t
}
const bh = t => !!t.type.__asyncLoader,
    $m = t => t.type.__isKeepAlive;

function hU(t, e) {
    f7(t, "a", e)
}

function fU(t, e) {
    f7(t, "da", e)
}

function f7(t, e, n = jn) {
    const r = t.__wdc || (t.__wdc = () => {
        let s = n;
        for (; s;) {
            if (s.isDeactivated) return;
            s = s.parent
        }
        return t()
    });
    if (Lm(e, r, n), n) {
        let s = n.parent;
        for (; s && s.parent;) $m(s.parent.vnode) && dU(r, e, n, s), s = s.parent
    }
}

function dU(t, e, n, r) {
    const s = Lm(e, t, r, !0);
    d2(() => {
        e2(r[e], s)
    }, n)
}

function Lm(t, e, n = jn, r = !1) {
    if (n) {
        const s = n[t] || (n[t] = []),
            i = e.__weh || (e.__weh = (...o) => {
                if (n.isUnmounted) return;
                vu(), Wl(n);
                const a = Os(e, n, t, o);
                return pc(), bu(), a
            });
        return r ? s.unshift(i) : s.push(i), i
    }
}
const yo = t => (e, n = jn) => (!zh || t === "sp") && Lm(t, (...r) => e(...r), n),
    d7 = yo("bm"),
    f2 = yo("m"),
    pU = yo("bu"),
    mU = yo("u"),
    p7 = yo("bum"),
    d2 = yo("um"),
    gU = yo("sp"),
    _U = yo("rtg"),
    yU = yo("rtc");

function vU(t, e = jn) {
    Lm("ec", t, e)
}
const p2 = "components",
    bU = "directives";

function Ge(t, e) {
    return m2(p2, t, !0, e) || t
}
const m7 = Symbol.for("v-ndc");

function Fm(t) {
    return En(t) ? m2(p2, t, !1) || t : t || m7
}

function Gt(t) {
    return m2(bU, t)
}

function m2(t, e, n = !0, r = !1) {
    const s = Qn || jn;
    if (s) {
        const i = s.type;
        if (t === p2) {
            const a = KU(i, !1);
            if (a && (a === e || a === Ai(e) || a === Nm(Ai(e)))) return i
        }
        const o = YE(s[t] || i[t], e) || YE(s.appContext[t], e);
        return !o && r ? i : o
    }
}

function YE(t, e) {
    return t && (t[e] || t[Ai(e)] || t[Nm(Ai(e))])
}

function gn(t, e, n, r) {
    let s;
    const i = n && n[r];
    if (Ke(t) || En(t)) {
        s = new Array(t.length);
        for (let o = 0, a = t.length; o < a; o++) s[o] = e(t[o], o, void 0, i && i[o])
    } else if (typeof t == "number") {
        s = new Array(t);
        for (let o = 0; o < t; o++) s[o] = e(o + 1, o, void 0, i && i[o])
    } else if (Kt(t))
        if (t[Symbol.iterator]) s = Array.from(t, (o, a) => e(o, a, void 0, i && i[a]));
        else {
            const o = Object.keys(t);
            s = new Array(o.length);
            for (let a = 0, l = o.length; a < l; a++) {
                const u = o[a];
                s[a] = e(t[u], u, a, i && i[a])
            }
        }
    else s = [];
    return n && (n[r] = s), s
}

function g7(t, e, n = {}, r, s) {
    if (Qn.isCE || Qn.parent && bh(Qn.parent) && Qn.parent.isCE) return e !== "default" && (n.name = e), Ve("slot", n, r && r());
    let i = t[e];
    i && i._c && (i._d = !1), B();
    const o = i && _7(i(n)),
        a = At(lt, {
            key: n.key || o && o.key || `_${e}`
        }, o || (r ? r() : []), o && t._ === 1 ? 64 : -2);
    return !s && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), i && i._c && (i._d = !0), a
}

function _7(t) {
    return t.some(e => Jp(e) ? !(e.type === Cs || e.type === lt && !_7(e.children)) : !0) ? t : null
}
const y0 = t => t ? k7(t) ? Bm(t) || t.proxy : y0(t.parent) : null,
    Eh = Rn(Object.create(null), {
        $: t => t,
        $el: t => t.vnode.el,
        $data: t => t.data,
        $props: t => t.props,
        $attrs: t => t.attrs,
        $slots: t => t.slots,
        $refs: t => t.refs,
        $parent: t => y0(t.parent),
        $root: t => y0(t.root),
        $emit: t => t.emit,
        $options: t => g2(t),
        $forceUpdate: t => t.f || (t.f = () => h2(t.update)),
        $nextTick: t => t.n || (t.n = KF.bind(t.proxy)),
        $watch: t => aU.bind(t)
    }),
    ty = (t, e) => t !== rn && !t.__isScriptSetup && Rt(t, e),
    EU = {
        get({
            _: t
        }, e) {
            const {
                ctx: n,
                setupState: r,
                data: s,
                props: i,
                accessCache: o,
                type: a,
                appContext: l
            } = t;
            let u;
            if (e[0] !== "$") {
                const _ = o[e];
                if (_ !== void 0) switch (_) {
                    case 1:
                        return r[e];
                    case 2:
                        return s[e];
                    case 4:
                        return n[e];
                    case 3:
                        return i[e]
                } else {
                    if (ty(r, e)) return o[e] = 1, r[e];
                    if (s !== rn && Rt(s, e)) return o[e] = 2, s[e];
                    if ((u = t.propsOptions[0]) && Rt(u, e)) return o[e] = 3, i[e];
                    if (n !== rn && Rt(n, e)) return o[e] = 4, n[e];
                    v0 && (o[e] = 0)
                }
            }
            const f = Eh[e];
            let d, p;
            if (f) return e === "$attrs" && Br(t, "get", e), f(t);
            if ((d = a.__cssModules) && (d = d[e])) return d;
            if (n !== rn && Rt(n, e)) return o[e] = 4, n[e];
            if (p = l.config.globalProperties, Rt(p, e)) return p[e]
        },
        set({
            _: t
        }, e, n) {
            const {
                data: r,
                setupState: s,
                ctx: i
            } = t;
            return ty(s, e) ? (s[e] = n, !0) : r !== rn && Rt(r, e) ? (r[e] = n, !0) : Rt(t.props, e) || e[0] === "$" && e.slice(1) in t ? !1 : (i[e] = n, !0)
        },
        has({
            _: {
                data: t,
                setupState: e,
                accessCache: n,
                ctx: r,
                appContext: s,
                propsOptions: i
            }
        }, o) {
            let a;
            return !!n[o] || t !== rn && Rt(t, o) || ty(e, o) || (a = i[0]) && Rt(a, o) || Rt(r, o) || Rt(Eh, o) || Rt(s.config.globalProperties, o)
        },
        defineProperty(t, e, n) {
            return n.get != null ? t._.accessCache[e] = 0 : Rt(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n)
        }
    };

function zE(t) {
    return Ke(t) ? t.reduce((e, n) => (e[n] = null, e), {}) : t
}
let v0 = !0;

function TU(t) {
    const e = g2(t),
        n = t.proxy,
        r = t.ctx;
    v0 = !1, e.beforeCreate && KE(e.beforeCreate, t, "bc");
    const {
        data: s,
        computed: i,
        methods: o,
        watch: a,
        provide: l,
        inject: u,
        created: f,
        beforeMount: d,
        mounted: p,
        beforeUpdate: _,
        updated: v,
        activated: y,
        deactivated: g,
        beforeDestroy: b,
        beforeUnmount: O,
        destroyed: N,
        unmounted: k,
        render: A,
        renderTracked: x,
        renderTriggered: D,
        errorCaptured: L,
        serverPrefetch: q,
        expose: ee,
        inheritAttrs: ae,
        components: Z,
        directives: fe,
        filters: ge
    } = e;
    if (u && SU(u, r, null), o)
        for (const ue in o) {
            const _e = o[ue];
            gt(_e) && (r[ue] = _e.bind(n))
        }
    if (s) {
        const ue = s.call(n, n);
        Kt(ue) && (t.data = Ec(ue))
    }
    if (v0 = !0, i)
        for (const ue in i) {
            const _e = i[ue],
                Oe = gt(_e) ? _e.bind(n, n) : gt(_e.get) ? _e.get.bind(n, n) : zs,
                Ee = !gt(_e) && gt(_e.set) ? _e.set.bind(n) : zs,
                Ce = ns({
                    get: Oe,
                    set: Ee
                });
            Object.defineProperty(r, ue, {
                enumerable: !0,
                configurable: !0,
                get: () => Ce.value,
                set: De => Ce.value = De
            })
        }
    if (a)
        for (const ue in a) y7(a[ue], r, n, ue);
    if (l) {
        const ue = gt(l) ? l.call(n) : l;
        Reflect.ownKeys(ue).forEach(_e => {
            IU(_e, ue[_e])
        })
    }
    f && KE(f, t, "c");

    function Q(ue, _e) {
        Ke(_e) ? _e.forEach(Oe => ue(Oe.bind(n))) : _e && ue(_e.bind(n))
    }
    if (Q(d7, d), Q(f2, p), Q(pU, _), Q(mU, v), Q(hU, y), Q(fU, g), Q(vU, L), Q(yU, x), Q(_U, D), Q(p7, O), Q(d2, k), Q(gU, q), Ke(ee))
        if (ee.length) {
            const ue = t.exposed || (t.exposed = {});
            ee.forEach(_e => {
                Object.defineProperty(ue, _e, {
                    get: () => n[_e],
                    set: Oe => n[_e] = Oe
                })
            })
        } else t.exposed || (t.exposed = {});
    A && t.render === zs && (t.render = A), ae != null && (t.inheritAttrs = ae), Z && (t.components = Z), fe && (t.directives = fe)
}

function SU(t, e, n = zs) {
    Ke(t) && (t = b0(t));
    for (const r in t) {
        const s = t[r];
        let i;
        Kt(s) ? "default" in s ? i = ao(s.from || r, s.default, !0) : i = ao(s.from || r) : i = ao(s), Xn(i) ? Object.defineProperty(e, r, {
            enumerable: !0,
            configurable: !0,
            get: () => i.value,
            set: o => i.value = o
        }) : e[r] = i
    }
}

function KE(t, e, n) {
    Os(Ke(t) ? t.map(r => r.bind(e.proxy)) : t.bind(e.proxy), e, n)
}

function y7(t, e, n, r) {
    const s = r.includes(".") ? c7(n, r) : () => n[r];
    if (En(t)) {
        const i = e[t];
        gt(i) && na(s, i)
    } else if (gt(t)) na(s, t.bind(n));
    else if (Kt(t))
        if (Ke(t)) t.forEach(i => y7(i, e, n, r));
        else {
            const i = gt(t.handler) ? t.handler.bind(n) : e[t.handler];
            gt(i) && na(s, i, t)
        }
}

function g2(t) {
    const e = t.type,
        {
            mixins: n,
            extends: r
        } = e,
        {
            mixins: s,
            optionsCache: i,
            config: {
                optionMergeStrategies: o
            }
        } = t.appContext,
        a = i.get(e);
    let l;
    return a ? l = a : !s.length && !n && !r ? l = e : (l = {}, s.length && s.forEach(u => Xp(l, u, o, !0)), Xp(l, e, o)), Kt(e) && i.set(e, l), l
}

function Xp(t, e, n, r = !1) {
    const {
        mixins: s,
        extends: i
    } = e;
    i && Xp(t, i, n, !0), s && s.forEach(o => Xp(t, o, n, !0));
    for (const o in e)
        if (!(r && o === "expose")) {
            const a = wU[o] || n && n[o];
            t[o] = a ? a(t[o], e[o]) : e[o]
        } return t
}
const wU = {
    data: ZE,
    props: XE,
    emits: XE,
    methods: fh,
    computed: fh,
    beforeCreate: vr,
    created: vr,
    beforeMount: vr,
    mounted: vr,
    beforeUpdate: vr,
    updated: vr,
    beforeDestroy: vr,
    beforeUnmount: vr,
    destroyed: vr,
    unmounted: vr,
    activated: vr,
    deactivated: vr,
    errorCaptured: vr,
    serverPrefetch: vr,
    components: fh,
    directives: fh,
    watch: OU,
    provide: ZE,
    inject: AU
};

function ZE(t, e) {
    return e ? t ? function() {
        return Rn(gt(t) ? t.call(this, this) : t, gt(e) ? e.call(this, this) : e)
    } : e : t
}

function AU(t, e) {
    return fh(b0(t), b0(e))
}

function b0(t) {
    if (Ke(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) e[t[n]] = t[n];
        return e
    }
    return t
}

function vr(t, e) {
    return t ? [...new Set([].concat(t, e))] : e
}

function fh(t, e) {
    return t ? Rn(Object.create(null), t, e) : e
}

function XE(t, e) {
    return t ? Ke(t) && Ke(e) ? [...new Set([...t, ...e])] : Rn(Object.create(null), zE(t), zE(e ?? {})) : e
}

function OU(t, e) {
    if (!t) return e;
    if (!e) return t;
    const n = Rn(Object.create(null), t);
    for (const r in e) n[r] = vr(t[r], e[r]);
    return n
}

function v7() {
    return {
        app: null,
        config: {
            isNativeTag: XL,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let CU = 0;

function kU(t, e) {
    return function(r, s = null) {
        gt(r) || (r = Rn({}, r)), s != null && !Kt(s) && (s = null);
        const i = v7(),
            o = new Set;
        let a = !1;
        const l = i.app = {
            _uid: CU++,
            _component: r,
            _props: s,
            _container: null,
            _context: i,
            _instance: null,
            version: JU,
            get config() {
                return i.config
            },
            set config(u) {},
            use(u, ...f) {
                return o.has(u) || (u && gt(u.install) ? (o.add(u), u.install(l, ...f)) : gt(u) && (o.add(u), u(l, ...f))), l
            },
            mixin(u) {
                return i.mixins.includes(u) || i.mixins.push(u), l
            },
            component(u, f) {
                return f ? (i.components[u] = f, l) : i.components[u]
            },
            directive(u, f) {
                return f ? (i.directives[u] = f, l) : i.directives[u]
            },
            mount(u, f, d) {
                if (!a) {
                    const p = Ve(r, s);
                    return p.appContext = i, f && e ? e(p, u) : t(p, u, d), a = !0, l._container = u, u.__vue_app__ = l, Bm(p.component) || p.component.proxy
                }
            },
            unmount() {
                a && (t(null, l._container), delete l._container.__vue_app__)
            },
            provide(u, f) {
                return i.provides[u] = f, l
            },
            runWithContext(u) {
                Qp = l;
                try {
                    return u()
                } finally {
                    Qp = null
                }
            }
        };
        return l
    }
}
let Qp = null;

function IU(t, e) {
    if (jn) {
        let n = jn.provides;
        const r = jn.parent && jn.parent.provides;
        r === n && (n = jn.provides = Object.create(r)), n[t] = e
    }
}

function ao(t, e, n = !1) {
    const r = jn || Qn;
    if (r || Qp) {
        const s = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : Qp._context.provides;
        if (s && t in s) return s[t];
        if (arguments.length > 1) return n && gt(e) ? e.call(r && r.proxy) : e
    }
}

function NU(t, e, n, r = !1) {
    const s = {},
        i = {};
    zp(i, Um, 1), t.propsDefaults = Object.create(null), b7(t, e, s, i);
    for (const o in t.propsOptions[0]) o in s || (s[o] = void 0);
    n ? t.props = r ? s : qF(s) : t.type.props ? t.props = s : t.props = i, t.attrs = i
}

function xU(t, e, n, r) {
    const {
        props: s,
        attrs: i,
        vnode: {
            patchFlag: o
        }
    } = t, a = Dt(s), [l] = t.propsOptions;
    let u = !1;
    if ((r || o > 0) && !(o & 16)) {
        if (o & 8) {
            const f = t.vnode.dynamicProps;
            for (let d = 0; d < f.length; d++) {
                let p = f[d];
                if (Mm(t.emitsOptions, p)) continue;
                const _ = e[p];
                if (l)
                    if (Rt(i, p)) _ !== i[p] && (i[p] = _, u = !0);
                    else {
                        const v = Ai(p);
                        s[v] = E0(l, a, v, _, t, !1)
                    }
                else _ !== i[p] && (i[p] = _, u = !0)
            }
        }
    } else {
        b7(t, e, s, i) && (u = !0);
        let f;
        for (const d in a)(!e || !Rt(e, d) && ((f = xc(d)) === d || !Rt(e, f))) && (l ? n && (n[d] !== void 0 || n[f] !== void 0) && (s[d] = E0(l, a, d, void 0, t, !0)) : delete s[d]);
        if (i !== a)
            for (const d in i)(!e || !Rt(e, d)) && (delete i[d], u = !0)
    }
    u && fo(t, "set", "$attrs")
}

function b7(t, e, n, r) {
    const [s, i] = t.propsOptions;
    let o = !1,
        a;
    if (e)
        for (let l in e) {
            if (Rp(l)) continue;
            const u = e[l];
            let f;
            s && Rt(s, f = Ai(l)) ? !i || !i.includes(f) ? n[f] = u : (a || (a = {}))[f] = u : Mm(t.emitsOptions, l) || (!(l in r) || u !== r[l]) && (r[l] = u, o = !0)
        }
    if (i) {
        const l = Dt(n),
            u = a || rn;
        for (let f = 0; f < i.length; f++) {
            const d = i[f];
            n[d] = E0(s, l, d, u[d], t, !Rt(u, d))
        }
    }
    return o
}

function E0(t, e, n, r, s, i) {
    const o = t[n];
    if (o != null) {
        const a = Rt(o, "default");
        if (a && r === void 0) {
            const l = o.default;
            if (o.type !== Function && !o.skipFactory && gt(l)) {
                const {
                    propsDefaults: u
                } = s;
                n in u ? r = u[n] : (Wl(s), r = u[n] = l.call(null, e), pc())
            } else r = l
        }
        o[0] && (i && !a ? r = !1 : o[1] && (r === "" || r === xc(n)) && (r = !0))
    }
    return r
}

function E7(t, e, n = !1) {
    const r = e.propsCache,
        s = r.get(t);
    if (s) return s;
    const i = t.props,
        o = {},
        a = [];
    let l = !1;
    if (!gt(t)) {
        const f = d => {
            l = !0;
            const [p, _] = E7(d, e, !0);
            Rn(o, p), _ && a.push(..._)
        };
        !n && e.mixins.length && e.mixins.forEach(f), t.extends && f(t.extends), t.mixins && t.mixins.forEach(f)
    }
    if (!i && !l) return Kt(t) && r.set(t, Sl), Sl;
    if (Ke(i))
        for (let f = 0; f < i.length; f++) {
            const d = Ai(i[f]);
            QE(d) && (o[d] = rn)
        } else if (i)
            for (const f in i) {
                const d = Ai(f);
                if (QE(d)) {
                    const p = i[f],
                        _ = o[d] = Ke(p) || gt(p) ? {
                            type: p
                        } : Rn({}, p);
                    if (_) {
                        const v = tT(Boolean, _.type),
                            y = tT(String, _.type);
                        _[0] = v > -1, _[1] = y < 0 || v < y, (v > -1 || Rt(_, "default")) && a.push(d)
                    }
                }
            }
    const u = [o, a];
    return Kt(t) && r.set(t, u), u
}

function QE(t) {
    return t[0] !== "$"
}

function JE(t) {
    const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
    return e ? e[2] : t === null ? "null" : ""
}

function eT(t, e) {
    return JE(t) === JE(e)
}

function tT(t, e) {
    return Ke(e) ? e.findIndex(n => eT(n, t)) : gt(e) && eT(e, t) ? 0 : -1
}
const T7 = t => t[0] === "_" || t === "$stable",
    _2 = t => Ke(t) ? t.map(yi) : [yi(t)],
    PU = (t, e, n) => {
        if (e._n) return e;
        const r = $i((...s) => _2(e(...s)), n);
        return r._c = !1, r
    },
    S7 = (t, e, n) => {
        const r = t._ctx;
        for (const s in t) {
            if (T7(s)) continue;
            const i = t[s];
            if (gt(i)) e[s] = PU(s, i, r);
            else if (i != null) {
                const o = _2(i);
                e[s] = () => o
            }
        }
    },
    w7 = (t, e) => {
        const n = _2(e);
        t.slots.default = () => n
    },
    RU = (t, e) => {
        if (t.vnode.shapeFlag & 32) {
            const n = e._;
            n ? (t.slots = Dt(e), zp(e, "_", n)) : S7(e, t.slots = {})
        } else t.slots = {}, e && w7(t, e);
        zp(t.slots, Um, 1)
    },
    MU = (t, e, n) => {
        const {
            vnode: r,
            slots: s
        } = t;
        let i = !0,
            o = rn;
        if (r.shapeFlag & 32) {
            const a = e._;
            a ? n && a === 1 ? i = !1 : (Rn(s, e), !n && a === 1 && delete s._) : (i = !e.$stable, S7(e, s)), o = e
        } else e && (w7(t, e), o = {
            default: 1
        });
        if (i)
            for (const a in s) !T7(a) && !(a in o) && delete s[a]
    };

function T0(t, e, n, r, s = !1) {
    if (Ke(t)) {
        t.forEach((p, _) => T0(p, e && (Ke(e) ? e[_] : e), n, r, s));
        return
    }
    if (bh(r) && !s) return;
    const i = r.shapeFlag & 4 ? Bm(r.component) || r.component.proxy : r.el,
        o = s ? null : i,
        {
            i: a,
            r: l
        } = t,
        u = e && e.r,
        f = a.refs === rn ? a.refs = {} : a.refs,
        d = a.setupState;
    if (u != null && u !== l && (En(u) ? (f[u] = null, Rt(d, u) && (d[u] = null)) : Xn(u) && (u.value = null)), gt(l)) ta(l, a, 12, [o, f]);
    else {
        const p = En(l),
            _ = Xn(l);
        if (p || _) {
            const v = () => {
                if (t.f) {
                    const y = p ? Rt(d, l) ? d[l] : f[l] : l.value;
                    s ? Ke(y) && e2(y, i) : Ke(y) ? y.includes(i) || y.push(i) : p ? (f[l] = [i], Rt(d, l) && (d[l] = f[l])) : (l.value = [i], t.k && (f[t.k] = l.value))
                } else p ? (f[l] = o, Rt(d, l) && (d[l] = o)) : _ && (l.value = o, t.k && (f[t.k] = o))
            };
            o ? (v.id = -1, xr(v, n)) : v()
        }
    }
}
const xr = oU;

function DU(t) {
    return $U(t)
}

function $U(t, e) {
    const n = u0();
    n.__VUE__ = !0;
    const {
        insert: r,
        remove: s,
        patchProp: i,
        createElement: o,
        createText: a,
        createComment: l,
        setText: u,
        setElementText: f,
        parentNode: d,
        nextSibling: p,
        setScopeId: _ = zs,
        insertStaticContent: v
    } = t, y = (I, T, S, P = null, G = null, te = null, le = !1, me = null, ve = !!T.dynamicChildren) => {
        if (I === T) return;
        I && !nc(I, T) && (P = it(I), De(I, G, te, !0), I = null), T.patchFlag === -2 && (ve = !1, T.dynamicChildren = null);
        const {
            type: de,
            ref: oe,
            shapeFlag: he
        } = T;
        switch (de) {
            case Rf:
                g(I, T, S, P);
                break;
            case Cs:
                b(I, T, S, P);
                break;
            case Dp:
                I == null && O(T, S, P, le);
                break;
            case lt:
                Z(I, T, S, P, G, te, le, me, ve);
                break;
            default:
                he & 1 ? A(I, T, S, P, G, te, le, me, ve) : he & 6 ? fe(I, T, S, P, G, te, le, me, ve) : (he & 64 || he & 128) && de.process(I, T, S, P, G, te, le, me, ve, M)
        }
        oe != null && G && T0(oe, I && I.ref, te, T || I, !T)
    }, g = (I, T, S, P) => {
        if (I == null) r(T.el = a(T.children), S, P);
        else {
            const G = T.el = I.el;
            T.children !== I.children && u(G, T.children)
        }
    }, b = (I, T, S, P) => {
        I == null ? r(T.el = l(T.children || ""), S, P) : T.el = I.el
    }, O = (I, T, S, P) => {
        [I.el, I.anchor] = v(I.children, T, S, P, I.el, I.anchor)
    }, N = ({
        el: I,
        anchor: T
    }, S, P) => {
        let G;
        for (; I && I !== T;) G = p(I), r(I, S, P), I = G;
        r(T, S, P)
    }, k = ({
        el: I,
        anchor: T
    }) => {
        let S;
        for (; I && I !== T;) S = p(I), s(I), I = S;
        s(T)
    }, A = (I, T, S, P, G, te, le, me, ve) => {
        le = le || T.type === "svg", I == null ? x(T, S, P, G, te, le, me, ve) : q(I, T, G, te, le, me, ve)
    }, x = (I, T, S, P, G, te, le, me) => {
        let ve, de;
        const {
            type: oe,
            props: he,
            shapeFlag: Me,
            transition: Fe,
            dirs: at
        } = I;
        if (ve = I.el = o(I.type, te, he && he.is, he), Me & 8 ? f(ve, I.children) : Me & 16 && L(I.children, ve, null, P, G, te && oe !== "foreignObject", le, me), at && Ha(I, null, P, "created"), D(ve, I, I.scopeId, le, P), he) {
            for (const W in he) W !== "value" && !Rp(W) && i(ve, W, null, he[W], te, I.children, P, G, Ze);
            "value" in he && i(ve, "value", null, he.value), (de = he.onVnodeBeforeMount) && hi(de, P, I)
        }
        at && Ha(I, null, P, "beforeMount");
        const vt = (!G || G && !G.pendingBranch) && Fe && !Fe.persisted;
        vt && Fe.beforeEnter(ve), r(ve, T, S), ((de = he && he.onVnodeMounted) || vt || at) && xr(() => {
            de && hi(de, P, I), vt && Fe.enter(ve), at && Ha(I, null, P, "mounted")
        }, G)
    }, D = (I, T, S, P, G) => {
        if (S && _(I, S), P)
            for (let te = 0; te < P.length; te++) _(I, P[te]);
        if (G) {
            let te = G.subTree;
            if (T === te) {
                const le = G.vnode;
                D(I, le, le.scopeId, le.slotScopeIds, G.parent)
            }
        }
    }, L = (I, T, S, P, G, te, le, me, ve = 0) => {
        for (let de = ve; de < I.length; de++) {
            const oe = I[de] = me ? Bo(I[de]) : yi(I[de]);
            y(null, oe, T, S, P, G, te, le, me)
        }
    }, q = (I, T, S, P, G, te, le) => {
        const me = T.el = I.el;
        let {
            patchFlag: ve,
            dynamicChildren: de,
            dirs: oe
        } = T;
        ve |= I.patchFlag & 16;
        const he = I.props || rn,
            Me = T.props || rn;
        let Fe;
        S && Ya(S, !1), (Fe = Me.onVnodeBeforeUpdate) && hi(Fe, S, T, I), oe && Ha(T, I, S, "beforeUpdate"), S && Ya(S, !0);
        const at = G && T.type !== "foreignObject";
        if (de ? ee(I.dynamicChildren, de, me, S, P, at, te) : le || _e(I, T, me, null, S, P, at, te, !1), ve > 0) {
            if (ve & 16) ae(me, T, he, Me, S, P, G);
            else if (ve & 2 && he.class !== Me.class && i(me, "class", null, Me.class, G), ve & 4 && i(me, "style", he.style, Me.style, G), ve & 8) {
                const vt = T.dynamicProps;
                for (let W = 0; W < vt.length; W++) {
                    const V = vt[W],
                        se = he[V],
                        j = Me[V];
                    (j !== se || V === "value") && i(me, V, se, j, G, I.children, S, P, Ze)
                }
            }
            ve & 1 && I.children !== T.children && f(me, T.children)
        } else !le && de == null && ae(me, T, he, Me, S, P, G);
        ((Fe = Me.onVnodeUpdated) || oe) && xr(() => {
            Fe && hi(Fe, S, T, I), oe && Ha(T, I, S, "updated")
        }, P)
    }, ee = (I, T, S, P, G, te, le) => {
        for (let me = 0; me < T.length; me++) {
            const ve = I[me],
                de = T[me],
                oe = ve.el && (ve.type === lt || !nc(ve, de) || ve.shapeFlag & 70) ? d(ve.el) : S;
            y(ve, de, oe, null, P, G, te, le, !0)
        }
    }, ae = (I, T, S, P, G, te, le) => {
        if (S !== P) {
            if (S !== rn)
                for (const me in S) !Rp(me) && !(me in P) && i(I, me, S[me], null, le, T.children, G, te, Ze);
            for (const me in P) {
                if (Rp(me)) continue;
                const ve = P[me],
                    de = S[me];
                ve !== de && me !== "value" && i(I, me, de, ve, le, T.children, G, te, Ze)
            }
            "value" in P && i(I, "value", S.value, P.value)
        }
    }, Z = (I, T, S, P, G, te, le, me, ve) => {
        const de = T.el = I ? I.el : a(""),
            oe = T.anchor = I ? I.anchor : a("");
        let {
            patchFlag: he,
            dynamicChildren: Me,
            slotScopeIds: Fe
        } = T;
        Fe && (me = me ? me.concat(Fe) : Fe), I == null ? (r(de, S, P), r(oe, S, P), L(T.children, S, oe, G, te, le, me, ve)) : he > 0 && he & 64 && Me && I.dynamicChildren ? (ee(I.dynamicChildren, Me, S, G, te, le, me), (T.key != null || G && T === G.subTree) && A7(I, T, !0)) : _e(I, T, S, oe, G, te, le, me, ve)
    }, fe = (I, T, S, P, G, te, le, me, ve) => {
        T.slotScopeIds = me, I == null ? T.shapeFlag & 512 ? G.ctx.activate(T, S, P, le, ve) : ge(T, S, P, G, te, le, ve) : K(I, T, ve)
    }, ge = (I, T, S, P, G, te, le) => {
        const me = I.component = jU(I, P, G);
        if ($m(I) && (me.ctx.renderer = M), WU(me), me.asyncDep) {
            if (G && G.registerDep(me, Q), !I.el) {
                const ve = me.subTree = Ve(Cs);
                b(null, ve, T, S)
            }
            return
        }
        Q(me, I, T, S, G, te, le)
    }, K = (I, T, S) => {
        const P = T.component = I.component;
        if (rU(I, T, S))
            if (P.asyncDep && !P.asyncResolved) {
                ue(P, T, S);
                return
            } else P.next = T, XF(P.update), P.update();
        else T.el = I.el, P.vnode = T
    }, Q = (I, T, S, P, G, te, le) => {
        const me = () => {
                if (I.isMounted) {
                    let {
                        next: oe,
                        bu: he,
                        u: Me,
                        parent: Fe,
                        vnode: at
                    } = I, vt = oe, W;
                    Ya(I, !1), oe ? (oe.el = at.el, ue(I, oe, le)) : oe = at, he && Mp(he), (W = oe.props && oe.props.onVnodeBeforeUpdate) && hi(W, Fe, oe, at), Ya(I, !0);
                    const V = J_(I),
                        se = I.subTree;
                    I.subTree = V, y(se, V, d(se.el), it(se), I, G, te), oe.el = V.el, vt === null && sU(I, V.el), Me && xr(Me, G), (W = oe.props && oe.props.onVnodeUpdated) && xr(() => hi(W, Fe, oe, at), G)
                } else {
                    let oe;
                    const {
                        el: he,
                        props: Me
                    } = T, {
                        bm: Fe,
                        m: at,
                        parent: vt
                    } = I, W = bh(T);
                    if (Ya(I, !1), Fe && Mp(Fe), !W && (oe = Me && Me.onVnodeBeforeMount) && hi(oe, vt, T), Ya(I, !0), he && X) {
                        const V = () => {
                            I.subTree = J_(I), X(he, I.subTree, I, G, null)
                        };
                        W ? T.type.__asyncLoader().then(() => !I.isUnmounted && V()) : V()
                    } else {
                        const V = I.subTree = J_(I);
                        y(null, V, S, P, I, G, te), T.el = V.el
                    }
                    if (at && xr(at, G), !W && (oe = Me && Me.onVnodeMounted)) {
                        const V = T;
                        xr(() => hi(oe, vt, V), G)
                    }(T.shapeFlag & 256 || vt && bh(vt.vnode) && vt.vnode.shapeFlag & 256) && I.a && xr(I.a, G), I.isMounted = !0, T = S = P = null
                }
            },
            ve = I.effect = new r2(me, () => h2(de), I.scope),
            de = I.update = () => ve.run();
        de.id = I.uid, Ya(I, !0), de()
    }, ue = (I, T, S) => {
        T.component = I;
        const P = I.vnode.props;
        I.vnode = T, I.next = null, xU(I, T.props, P, S), MU(I, T.children, S), vu(), jE(), bu()
    }, _e = (I, T, S, P, G, te, le, me, ve = !1) => {
        const de = I && I.children,
            oe = I ? I.shapeFlag : 0,
            he = T.children,
            {
                patchFlag: Me,
                shapeFlag: Fe
            } = T;
        if (Me > 0) {
            if (Me & 128) {
                Ee(de, he, S, P, G, te, le, me, ve);
                return
            } else if (Me & 256) {
                Oe(de, he, S, P, G, te, le, me, ve);
                return
            }
        }
        Fe & 8 ? (oe & 16 && Ze(de, G, te), he !== de && f(S, he)) : oe & 16 ? Fe & 16 ? Ee(de, he, S, P, G, te, le, me, ve) : Ze(de, G, te, !0) : (oe & 8 && f(S, ""), Fe & 16 && L(he, S, P, G, te, le, me, ve))
    }, Oe = (I, T, S, P, G, te, le, me, ve) => {
        I = I || Sl, T = T || Sl;
        const de = I.length,
            oe = T.length,
            he = Math.min(de, oe);
        let Me;
        for (Me = 0; Me < he; Me++) {
            const Fe = T[Me] = ve ? Bo(T[Me]) : yi(T[Me]);
            y(I[Me], Fe, S, null, G, te, le, me, ve)
        }
        de > oe ? Ze(I, G, te, !0, !1, he) : L(T, S, P, G, te, le, me, ve, he)
    }, Ee = (I, T, S, P, G, te, le, me, ve) => {
        let de = 0;
        const oe = T.length;
        let he = I.length - 1,
            Me = oe - 1;
        for (; de <= he && de <= Me;) {
            const Fe = I[de],
                at = T[de] = ve ? Bo(T[de]) : yi(T[de]);
            if (nc(Fe, at)) y(Fe, at, S, null, G, te, le, me, ve);
            else break;
            de++
        }
        for (; de <= he && de <= Me;) {
            const Fe = I[he],
                at = T[Me] = ve ? Bo(T[Me]) : yi(T[Me]);
            if (nc(Fe, at)) y(Fe, at, S, null, G, te, le, me, ve);
            else break;
            he--, Me--
        }
        if (de > he) {
            if (de <= Me) {
                const Fe = Me + 1,
                    at = Fe < oe ? T[Fe].el : P;
                for (; de <= Me;) y(null, T[de] = ve ? Bo(T[de]) : yi(T[de]), S, at, G, te, le, me, ve), de++
            }
        } else if (de > Me)
            for (; de <= he;) De(I[de], G, te, !0), de++;
        else {
            const Fe = de,
                at = de,
                vt = new Map;
            for (de = at; de <= Me; de++) {
                const xe = T[de] = ve ? Bo(T[de]) : yi(T[de]);
                xe.key != null && vt.set(xe.key, de)
            }
            let W, V = 0;
            const se = Me - at + 1;
            let j = !1,
                ne = 0;
            const Te = new Array(se);
            for (de = 0; de < se; de++) Te[de] = 0;
            for (de = Fe; de <= he; de++) {
                const xe = I[de];
                if (V >= se) {
                    De(xe, G, te, !0);
                    continue
                }
                let qe;
                if (xe.key != null) qe = vt.get(xe.key);
                else
                    for (W = at; W <= Me; W++)
                        if (Te[W - at] === 0 && nc(xe, T[W])) {
                            qe = W;
                            break
                        } qe === void 0 ? De(xe, G, te, !0) : (Te[qe - at] = de + 1, qe >= ne ? ne = qe : j = !0, y(xe, T[qe], S, null, G, te, le, me, ve), V++)
            }
            const ke = j ? LU(Te) : Sl;
            for (W = ke.length - 1, de = se - 1; de >= 0; de--) {
                const xe = at + de,
                    qe = T[xe],
                    Tn = xe + 1 < oe ? T[xe + 1].el : P;
                Te[de] === 0 ? y(null, qe, S, Tn, G, te, le, me, ve) : j && (W < 0 || de !== ke[W] ? Ce(qe, S, Tn, 2) : W--)
            }
        }
    }, Ce = (I, T, S, P, G = null) => {
        const {
            el: te,
            type: le,
            transition: me,
            children: ve,
            shapeFlag: de
        } = I;
        if (de & 6) {
            Ce(I.component.subTree, T, S, P);
            return
        }
        if (de & 128) {
            I.suspense.move(T, S, P);
            return
        }
        if (de & 64) {
            le.move(I, T, S, M);
            return
        }
        if (le === lt) {
            r(te, T, S);
            for (let he = 0; he < ve.length; he++) Ce(ve[he], T, S, P);
            r(I.anchor, T, S);
            return
        }
        if (le === Dp) {
            N(I, T, S);
            return
        }
        if (P !== 2 && de & 1 && me)
            if (P === 0) me.beforeEnter(te), r(te, T, S), xr(() => me.enter(te), G);
            else {
                const {
                    leave: he,
                    delayLeave: Me,
                    afterLeave: Fe
                } = me, at = () => r(te, T, S), vt = () => {
                    he(te, () => {
                        at(), Fe && Fe()
                    })
                };
                Me ? Me(te, at, vt) : vt()
            }
        else r(te, T, S)
    }, De = (I, T, S, P = !1, G = !1) => {
        const {
            type: te,
            props: le,
            ref: me,
            children: ve,
            dynamicChildren: de,
            shapeFlag: oe,
            patchFlag: he,
            dirs: Me
        } = I;
        if (me != null && T0(me, null, S, I, !0), oe & 256) {
            T.ctx.deactivate(I);
            return
        }
        const Fe = oe & 1 && Me,
            at = !bh(I);
        let vt;
        if (at && (vt = le && le.onVnodeBeforeUnmount) && hi(vt, T, I), oe & 6) je(I.component, S, P);
        else {
            if (oe & 128) {
                I.suspense.unmount(S, P);
                return
            }
            Fe && Ha(I, null, T, "beforeUnmount"), oe & 64 ? I.type.remove(I, T, S, G, M, P) : de && (te !== lt || he > 0 && he & 64) ? Ze(de, T, S, !1, !0) : (te === lt && he & 384 || !G && oe & 16) && Ze(ve, T, S), P && Ue(I)
        }(at && (vt = le && le.onVnodeUnmounted) || Fe) && xr(() => {
            vt && hi(vt, T, I), Fe && Ha(I, null, T, "unmounted")
        }, S)
    }, Ue = I => {
        const {
            type: T,
            el: S,
            anchor: P,
            transition: G
        } = I;
        if (T === lt) {
            ot(S, P);
            return
        }
        if (T === Dp) {
            k(I);
            return
        }
        const te = () => {
            s(S), G && !G.persisted && G.afterLeave && G.afterLeave()
        };
        if (I.shapeFlag & 1 && G && !G.persisted) {
            const {
                leave: le,
                delayLeave: me
            } = G, ve = () => le(S, te);
            me ? me(I.el, te, ve) : ve()
        } else te()
    }, ot = (I, T) => {
        let S;
        for (; I !== T;) S = p(I), s(I), I = S;
        s(T)
    }, je = (I, T, S) => {
        const {
            bum: P,
            scope: G,
            update: te,
            subTree: le,
            um: me
        } = I;
        P && Mp(P), G.stop(), te && (te.active = !1, De(le, I, T, S)), me && xr(me, T), xr(() => {
            I.isUnmounted = !0
        }, T), T && T.pendingBranch && !T.isUnmounted && I.asyncDep && !I.asyncResolved && I.suspenseId === T.pendingId && (T.deps--, T.deps === 0 && T.resolve())
    }, Ze = (I, T, S, P = !1, G = !1, te = 0) => {
        for (let le = te; le < I.length; le++) De(I[le], T, S, P, G)
    }, it = I => I.shapeFlag & 6 ? it(I.component.subTree) : I.shapeFlag & 128 ? I.suspense.next() : p(I.anchor || I.el), w = (I, T, S) => {
        I == null ? T._vnode && De(T._vnode, null, null, !0) : y(T._vnode || null, I, T, null, null, null, S), jE(), s7(), T._vnode = I
    }, M = {
        p: y,
        um: De,
        m: Ce,
        r: Ue,
        mt: ge,
        mc: L,
        pc: _e,
        pbc: ee,
        n: it,
        o: t
    };
    let Y, X;
    return e && ([Y, X] = e(M)), {
        render: w,
        hydrate: Y,
        createApp: kU(w, Y)
    }
}

function Ya({
    effect: t,
    update: e
}, n) {
    t.allowRecurse = e.allowRecurse = n
}

function A7(t, e, n = !1) {
    const r = t.children,
        s = e.children;
    if (Ke(r) && Ke(s))
        for (let i = 0; i < r.length; i++) {
            const o = r[i];
            let a = s[i];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = s[i] = Bo(s[i]), a.el = o.el), n || A7(o, a)), a.type === Rf && (a.el = o.el)
        }
}

function LU(t) {
    const e = t.slice(),
        n = [0];
    let r, s, i, o, a;
    const l = t.length;
    for (r = 0; r < l; r++) {
        const u = t[r];
        if (u !== 0) {
            if (s = n[n.length - 1], t[s] < u) {
                e[r] = s, n.push(r);
                continue
            }
            for (i = 0, o = n.length - 1; i < o;) a = i + o >> 1, t[n[a]] < u ? i = a + 1 : o = a;
            u < t[n[i]] && (i > 0 && (e[r] = n[i - 1]), n[i] = r)
        }
    }
    for (i = n.length, o = n[i - 1]; i-- > 0;) n[i] = o, o = e[o];
    return n
}
const FU = t => t.__isTeleport,
    lt = Symbol.for("v-fgt"),
    Rf = Symbol.for("v-txt"),
    Cs = Symbol.for("v-cmt"),
    Dp = Symbol.for("v-stc"),
    Th = [];
let Hs = null;

function B(t = !1) {
    Th.push(Hs = t ? null : [])
}

function UU() {
    Th.pop(), Hs = Th[Th.length - 1] || null
}
let Hh = 1;

function nT(t) {
    Hh += t
}

function O7(t) {
    return t.dynamicChildren = Hh > 0 ? Hs || Sl : null, UU(), Hh > 0 && Hs && Hs.push(t), t
}

function H(t, e, n, r, s, i) {
    return O7(U(t, e, n, r, s, i, !0))
}

function At(t, e, n, r, s) {
    return O7(Ve(t, e, n, r, s, !0))
}

function Jp(t) {
    return t ? t.__v_isVNode === !0 : !1
}

function nc(t, e) {
    return t.type === e.type && t.key === e.key
}
const Um = "__vInternal",
    C7 = ({
        key: t
    }) => t ?? null,
    $p = ({
        ref: t,
        ref_key: e,
        ref_for: n
    }) => (typeof t == "number" && (t = "" + t), t != null ? En(t) || Xn(t) || gt(t) ? {
        i: Qn,
        r: t,
        k: e,
        f: !!n
    } : t : null);

function U(t, e = null, n = null, r = 0, s = null, i = t === lt ? 0 : 1, o = !1, a = !1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t,
        props: e,
        key: e && C7(e),
        ref: e && $p(e),
        scopeId: Dm,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: i,
        patchFlag: r,
        dynamicProps: s,
        dynamicChildren: null,
        appContext: null,
        ctx: Qn
    };
    return a ? (y2(l, n), i & 128 && t.normalize(l)) : n && (l.shapeFlag |= En(n) ? 8 : 16), Hh > 0 && !o && Hs && (l.patchFlag > 0 || i & 6) && l.patchFlag !== 32 && Hs.push(l), l
}
const Ve = BU;

function BU(t, e = null, n = null, r = 0, s = null, i = !1) {
    if ((!t || t === m7) && (t = Cs), Jp(t)) {
        const a = ua(t, e, !0);
        return n && y2(a, n), Hh > 0 && !i && Hs && (a.shapeFlag & 6 ? Hs[Hs.indexOf(t)] = a : Hs.push(a)), a.patchFlag |= -2, a
    }
    if (ZU(t) && (t = t.__vccOpts), e) {
        e = qU(e);
        let {
            class: a,
            style: l
        } = e;
        a && !En(a) && (e.class = nt(a)), Kt(l) && (X8(l) && !Ke(l) && (l = Rn({}, l)), e.style = sn(l))
    }
    const o = En(t) ? 1 : iU(t) ? 128 : FU(t) ? 64 : Kt(t) ? 4 : gt(t) ? 2 : 0;
    return U(t, e, n, r, s, o, i, !0)
}

function qU(t) {
    return t ? X8(t) || Um in t ? Rn({}, t) : t : null
}

function ua(t, e, n = !1) {
    const {
        props: r,
        ref: s,
        patchFlag: i,
        children: o
    } = t, a = e ? Mf(r || {}, e) : r;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t.type,
        props: a,
        key: a && C7(a),
        ref: e && e.ref ? n && s ? Ke(s) ? s.concat($p(e)) : [s, $p(e)] : $p(e) : s,
        scopeId: t.scopeId,
        slotScopeIds: t.slotScopeIds,
        children: o,
        target: t.target,
        targetAnchor: t.targetAnchor,
        staticCount: t.staticCount,
        shapeFlag: t.shapeFlag,
        patchFlag: e && t.type !== lt ? i === -1 ? 16 : i | 16 : i,
        dynamicProps: t.dynamicProps,
        dynamicChildren: t.dynamicChildren,
        appContext: t.appContext,
        dirs: t.dirs,
        transition: t.transition,
        component: t.component,
        suspense: t.suspense,
        ssContent: t.ssContent && ua(t.ssContent),
        ssFallback: t.ssFallback && ua(t.ssFallback),
        el: t.el,
        anchor: t.anchor,
        ctx: t.ctx,
        ce: t.ce
    }
}

function mn(t = " ", e = 0) {
    return Ve(Rf, null, t, e)
}

function Pc(t, e) {
    const n = Ve(Dp, null, t);
    return n.staticCount = e, n
}

function Pe(t = "", e = !1) {
    return e ? (B(), At(Cs, null, t)) : Ve(Cs, null, t)
}

function yi(t) {
    return t == null || typeof t == "boolean" ? Ve(Cs) : Ke(t) ? Ve(lt, null, t.slice()) : typeof t == "object" ? Bo(t) : Ve(Rf, null, String(t))
}

function Bo(t) {
    return t.el === null && t.patchFlag !== -1 || t.memo ? t : ua(t)
}

function y2(t, e) {
    let n = 0;
    const {
        shapeFlag: r
    } = t;
    if (e == null) e = null;
    else if (Ke(e)) n = 16;
    else if (typeof e == "object")
        if (r & 65) {
            const s = e.default;
            s && (s._c && (s._d = !1), y2(t, s()), s._c && (s._d = !0));
            return
        } else {
            n = 32;
            const s = e._;
            !s && !(Um in e) ? e._ctx = Qn : s === 3 && Qn && (Qn.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024))
        }
    else gt(e) ? (e = {
        default: e,
        _ctx: Qn
    }, n = 32) : (e = String(e), r & 64 ? (n = 16, e = [mn(e)]) : n = 8);
    t.children = e, t.shapeFlag |= n
}

function Mf(...t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        for (const s in r)
            if (s === "class") e.class !== r.class && (e.class = nt([e.class, r.class]));
            else if (s === "style") e.style = sn([e.style, r.style]);
        else if (Cm(s)) {
            const i = e[s],
                o = r[s];
            o && i !== o && !(Ke(i) && i.includes(o)) && (e[s] = i ? [].concat(i, o) : o)
        } else s !== "" && (e[s] = r[s])
    }
    return e
}

function hi(t, e, n, r = null) {
    Os(t, e, 7, [n, r])
}
const GU = v7();
let VU = 0;

function jU(t, e, n) {
    const r = t.type,
        s = (e ? e.appContext : t.appContext) || GU,
        i = {
            uid: VU++,
            vnode: t,
            type: r,
            parent: e,
            appContext: s,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new U8(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: e ? e.provides : Object.create(s.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: E7(r, s),
            emitsOptions: o7(r, s),
            emit: null,
            emitted: null,
            propsDefaults: rn,
            inheritAttrs: r.inheritAttrs,
            ctx: rn,
            data: rn,
            props: rn,
            attrs: rn,
            slots: rn,
            refs: rn,
            setupState: rn,
            setupContext: null,
            attrsProxy: null,
            slotsProxy: null,
            suspense: n,
            suspenseId: n ? n.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return i.ctx = {
        _: i
    }, i.root = e ? e.root : i, i.emit = eU.bind(null, i), t.ce && t.ce(i), i
}
let jn = null;
const Yh = () => jn || Qn;
let v2, rl, rT = "__VUE_INSTANCE_SETTERS__";
(rl = u0()[rT]) || (rl = u0()[rT] = []), rl.push(t => jn = t), v2 = t => {
    rl.length > 1 ? rl.forEach(e => e(t)) : rl[0](t)
};
const Wl = t => {
        v2(t), t.scope.on()
    },
    pc = () => {
        jn && jn.scope.off(), v2(null)
    };

function k7(t) {
    return t.vnode.shapeFlag & 4
}
let zh = !1;

function WU(t, e = !1) {
    zh = e;
    const {
        props: n,
        children: r
    } = t.vnode, s = k7(t);
    NU(t, n, s, e), RU(t, r);
    const i = s ? HU(t, e) : void 0;
    return zh = !1, i
}

function HU(t, e) {
    const n = t.type;
    t.accessCache = Object.create(null), t.proxy = c2(new Proxy(t.ctx, EU));
    const {
        setup: r
    } = n;
    if (r) {
        const s = t.setupContext = r.length > 1 ? zU(t) : null;
        Wl(t), vu();
        const i = ta(r, t, 0, [t.props, s]);
        if (bu(), pc(), R8(i)) {
            if (i.then(pc, pc), e) return i.then(o => {
                sT(t, o, e)
            }).catch(o => {
                Rm(o, t, 0)
            });
            t.asyncDep = i
        } else sT(t, i, e)
    } else I7(t, e)
}

function sT(t, e, n) {
    gt(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : Kt(e) && (t.setupState = t7(e)), I7(t, n)
}
let iT;

function I7(t, e, n) {
    const r = t.type;
    if (!t.render) {
        if (!e && iT && !r.render) {
            const s = r.template || g2(t).template;
            if (s) {
                const {
                    isCustomElement: i,
                    compilerOptions: o
                } = t.appContext.config, {
                    delimiters: a,
                    compilerOptions: l
                } = r, u = Rn(Rn({
                    isCustomElement: i,
                    delimiters: a
                }, o), l);
                r.render = iT(s, u)
            }
        }
        t.render = r.render || zs
    }
    Wl(t), vu(), TU(t), bu(), pc()
}

function YU(t) {
    return t.attrsProxy || (t.attrsProxy = new Proxy(t.attrs, {
        get(e, n) {
            return Br(t, "get", "$attrs"), e[n]
        }
    }))
}

function zU(t) {
    const e = n => {
        t.exposed = n || {}
    };
    return {
        get attrs() {
            return YU(t)
        },
        slots: t.slots,
        emit: t.emit,
        expose: e
    }
}

function Bm(t) {
    if (t.exposed) return t.exposeProxy || (t.exposeProxy = new Proxy(t7(c2(t.exposed)), {
        get(e, n) {
            if (n in e) return e[n];
            if (n in Eh) return Eh[n](t)
        },
        has(e, n) {
            return n in e || n in Eh
        }
    }))
}

function KU(t, e = !0) {
    return gt(t) ? t.displayName || t.name : t.name || e && t.__name
}

function ZU(t) {
    return gt(t) && "__vccOpts" in t
}
const ns = (t, e) => YF(t, e, zh);

function b2(t, e, n) {
    const r = arguments.length;
    return r === 2 ? Kt(e) && !Ke(e) ? Jp(e) ? Ve(t, null, [e]) : Ve(t, e) : Ve(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && Jp(n) && (n = [n]), Ve(t, e, n))
}
const XU = Symbol.for("v-scx"),
    QU = () => ao(XU),
    JU = "3.3.4",
    eB = "http://www.w3.org/2000/svg",
    rc = typeof document < "u" ? document : null,
    oT = rc && rc.createElement("template"),
    tB = {
        insert: (t, e, n) => {
            e.insertBefore(t, n || null)
        },
        remove: t => {
            const e = t.parentNode;
            e && e.removeChild(t)
        },
        createElement: (t, e, n, r) => {
            const s = e ? rc.createElementNS(eB, t) : rc.createElement(t, n ? {
                is: n
            } : void 0);
            return t === "select" && r && r.multiple != null && s.setAttribute("multiple", r.multiple), s
        },
        createText: t => rc.createTextNode(t),
        createComment: t => rc.createComment(t),
        setText: (t, e) => {
            t.nodeValue = e
        },
        setElementText: (t, e) => {
            t.textContent = e
        },
        parentNode: t => t.parentNode,
        nextSibling: t => t.nextSibling,
        querySelector: t => rc.querySelector(t),
        setScopeId(t, e) {
            t.setAttribute(e, "")
        },
        insertStaticContent(t, e, n, r, s, i) {
            const o = n ? n.previousSibling : e.lastChild;
            if (s && (s === i || s.nextSibling))
                for (; e.insertBefore(s.cloneNode(!0), n), !(s === i || !(s = s.nextSibling)););
            else {
                oT.innerHTML = r ? `<svg>${t}</svg>` : t;
                const a = oT.content;
                if (r) {
                    const l = a.firstChild;
                    for (; l.firstChild;) a.appendChild(l.firstChild);
                    a.removeChild(l)
                }
                e.insertBefore(a, n)
            }
            return [o ? o.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
        }
    };

function nB(t, e, n) {
    const r = t._vtc;
    r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e
}

function rB(t, e, n) {
    const r = t.style,
        s = En(n);
    if (n && !s) {
        if (e && !En(e))
            for (const i in e) n[i] == null && S0(r, i, "");
        for (const i in n) S0(r, i, n[i])
    } else {
        const i = r.display;
        s ? e !== n && (r.cssText = n) : e && t.removeAttribute("style"), "_vod" in t && (r.display = i)
    }
}
const aT = /\s*!important$/;

function S0(t, e, n) {
    if (Ke(n)) n.forEach(r => S0(t, e, r));
    else if (n == null && (n = ""), e.startsWith("--")) t.setProperty(e, n);
    else {
        const r = sB(t, e);
        aT.test(n) ? t.setProperty(xc(r), n.replace(aT, ""), "important") : t[r] = n
    }
}
const cT = ["Webkit", "Moz", "ms"],
    ny = {};

function sB(t, e) {
    const n = ny[e];
    if (n) return n;
    let r = Ai(e);
    if (r !== "filter" && r in t) return ny[e] = r;
    r = Nm(r);
    for (let s = 0; s < cT.length; s++) {
        const i = cT[s] + r;
        if (i in t) return ny[e] = i
    }
    return e
}
const lT = "http://www.w3.org/1999/xlink";

function iB(t, e, n, r, s) {
    if (r && e.startsWith("xlink:")) n == null ? t.removeAttributeNS(lT, e.slice(6, e.length)) : t.setAttributeNS(lT, e, n);
    else {
        const i = uF(e);
        n == null || i && !$8(n) ? t.removeAttribute(e) : t.setAttribute(e, i ? "" : n)
    }
}

function oB(t, e, n, r, s, i, o) {
    if (e === "innerHTML" || e === "textContent") {
        r && o(r, s, i), t[e] = n ?? "";
        return
    }
    const a = t.tagName;
    if (e === "value" && a !== "PROGRESS" && !a.includes("-")) {
        t._value = n;
        const u = a === "OPTION" ? t.getAttribute("value") : t.value,
            f = n ?? "";
        u !== f && (t.value = f), n == null && t.removeAttribute(e);
        return
    }
    let l = !1;
    if (n === "" || n == null) {
        const u = typeof t[e];
        u === "boolean" ? n = $8(n) : n == null && u === "string" ? (n = "", l = !0) : u === "number" && (n = 0, l = !0)
    }
    try {
        t[e] = n
    } catch {}
    l && t.removeAttribute(e)
}

function sc(t, e, n, r) {
    t.addEventListener(e, n, r)
}

function aB(t, e, n, r) {
    t.removeEventListener(e, n, r)
}

function cB(t, e, n, r, s = null) {
    const i = t._vei || (t._vei = {}),
        o = i[e];
    if (r && o) o.value = r;
    else {
        const [a, l] = lB(e);
        if (r) {
            const u = i[e] = fB(r, s);
            sc(t, a, u, l)
        } else o && (aB(t, a, o, l), i[e] = void 0)
    }
}
const uT = /(?:Once|Passive|Capture)$/;

function lB(t) {
    let e;
    if (uT.test(t)) {
        e = {};
        let r;
        for (; r = t.match(uT);) t = t.slice(0, t.length - r[0].length), e[r[0].toLowerCase()] = !0
    }
    return [t[2] === ":" ? t.slice(3) : xc(t.slice(2)), e]
}
let ry = 0;
const uB = Promise.resolve(),
    hB = () => ry || (uB.then(() => ry = 0), ry = Date.now());

function fB(t, e) {
    const n = r => {
        if (!r._vts) r._vts = Date.now();
        else if (r._vts <= n.attached) return;
        Os(dB(r, n.value), e, 5, [r])
    };
    return n.value = t, n.attached = hB(), n
}

function dB(t, e) {
    if (Ke(e)) {
        const n = t.stopImmediatePropagation;
        return t.stopImmediatePropagation = () => {
            n.call(t), t._stopped = !0
        }, e.map(r => s => !s._stopped && r && r(s))
    } else return e
}
const hT = /^on[a-z]/,
    pB = (t, e, n, r, s = !1, i, o, a, l) => {
        e === "class" ? nB(t, r, s) : e === "style" ? rB(t, n, r) : Cm(e) ? Jv(e) || cB(t, e, n, r, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : mB(t, e, r, s)) ? oB(t, e, r, i, o, a, l) : (e === "true-value" ? t._trueValue = r : e === "false-value" && (t._falseValue = r), iB(t, e, r, s))
    };

function mB(t, e, n, r) {
    return r ? !!(e === "innerHTML" || e === "textContent" || e in t && hT.test(e) && gt(n)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || hT.test(e) && En(n) ? !1 : e in t
}
const Mo = "transition",
    rh = "animation",
    Ta = (t, {
        slots: e
    }) => b2(uU, gB(t), e);
Ta.displayName = "Transition";
const N7 = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
Ta.props = Rn({}, l7, N7);
const za = (t, e = []) => {
        Ke(t) ? t.forEach(n => n(...e)) : t && t(...e)
    },
    fT = t => t ? Ke(t) ? t.some(e => e.length > 1) : t.length > 1 : !1;

function gB(t) {
    const e = {};
    for (const Z in t) Z in N7 || (e[Z] = t[Z]);
    if (t.css === !1) return e;
    const {
        name: n = "v",
        type: r,
        duration: s,
        enterFromClass: i = `${n}-enter-from`,
        enterActiveClass: o = `${n}-enter-active`,
        enterToClass: a = `${n}-enter-to`,
        appearFromClass: l = i,
        appearActiveClass: u = o,
        appearToClass: f = a,
        leaveFromClass: d = `${n}-leave-from`,
        leaveActiveClass: p = `${n}-leave-active`,
        leaveToClass: _ = `${n}-leave-to`
    } = t, v = _B(s), y = v && v[0], g = v && v[1], {
        onBeforeEnter: b,
        onEnter: O,
        onEnterCancelled: N,
        onLeave: k,
        onLeaveCancelled: A,
        onBeforeAppear: x = b,
        onAppear: D = O,
        onAppearCancelled: L = N
    } = e, q = (Z, fe, ge) => {
        Ka(Z, fe ? f : a), Ka(Z, fe ? u : o), ge && ge()
    }, ee = (Z, fe) => {
        Z._isLeaving = !1, Ka(Z, d), Ka(Z, _), Ka(Z, p), fe && fe()
    }, ae = Z => (fe, ge) => {
        const K = Z ? D : O,
            Q = () => q(fe, Z, ge);
        za(K, [fe, Q]), dT(() => {
            Ka(fe, Z ? l : i), Do(fe, Z ? f : a), fT(K) || pT(fe, r, y, Q)
        })
    };
    return Rn(e, {
        onBeforeEnter(Z) {
            za(b, [Z]), Do(Z, i), Do(Z, o)
        },
        onBeforeAppear(Z) {
            za(x, [Z]), Do(Z, l), Do(Z, u)
        },
        onEnter: ae(!1),
        onAppear: ae(!0),
        onLeave(Z, fe) {
            Z._isLeaving = !0;
            const ge = () => ee(Z, fe);
            Do(Z, d), bB(), Do(Z, p), dT(() => {
                Z._isLeaving && (Ka(Z, d), Do(Z, _), fT(k) || pT(Z, r, g, ge))
            }), za(k, [Z, ge])
        },
        onEnterCancelled(Z) {
            q(Z, !1), za(N, [Z])
        },
        onAppearCancelled(Z) {
            q(Z, !0), za(L, [Z])
        },
        onLeaveCancelled(Z) {
            ee(Z), za(A, [Z])
        }
    })
}

function _B(t) {
    if (t == null) return null;
    if (Kt(t)) return [sy(t.enter), sy(t.leave)]; {
        const e = sy(t);
        return [e, e]
    }
}

function sy(t) {
    return rF(t)
}

function Do(t, e) {
    e.split(/\s+/).forEach(n => n && t.classList.add(n)), (t._vtc || (t._vtc = new Set)).add(e)
}

function Ka(t, e) {
    e.split(/\s+/).forEach(r => r && t.classList.remove(r));
    const {
        _vtc: n
    } = t;
    n && (n.delete(e), n.size || (t._vtc = void 0))
}

function dT(t) {
    requestAnimationFrame(() => {
        requestAnimationFrame(t)
    })
}
let yB = 0;

function pT(t, e, n, r) {
    const s = t._endId = ++yB,
        i = () => {
            s === t._endId && r()
        };
    if (n) return setTimeout(i, n);
    const {
        type: o,
        timeout: a,
        propCount: l
    } = vB(t, e);
    if (!o) return r();
    const u = o + "end";
    let f = 0;
    const d = () => {
            t.removeEventListener(u, p), i()
        },
        p = _ => {
            _.target === t && ++f >= l && d()
        };
    setTimeout(() => {
        f < l && d()
    }, a + 1), t.addEventListener(u, p)
}

function vB(t, e) {
    const n = window.getComputedStyle(t),
        r = v => (n[v] || "").split(", "),
        s = r(`${Mo}Delay`),
        i = r(`${Mo}Duration`),
        o = mT(s, i),
        a = r(`${rh}Delay`),
        l = r(`${rh}Duration`),
        u = mT(a, l);
    let f = null,
        d = 0,
        p = 0;
    e === Mo ? o > 0 && (f = Mo, d = o, p = i.length) : e === rh ? u > 0 && (f = rh, d = u, p = l.length) : (d = Math.max(o, u), f = d > 0 ? o > u ? Mo : rh : null, p = f ? f === Mo ? i.length : l.length : 0);
    const _ = f === Mo && /\b(transform|all)(,|$)/.test(r(`${Mo}Property`).toString());
    return {
        type: f,
        timeout: d,
        propCount: p,
        hasTransform: _
    }
}

function mT(t, e) {
    for (; t.length < e.length;) t = t.concat(t);
    return Math.max(...e.map((n, r) => gT(n) + gT(t[r])))
}

function gT(t) {
    return Number(t.slice(0, -1).replace(",", ".")) * 1e3
}

function bB() {
    return document.body.offsetHeight
}
const e1 = t => {
    const e = t.props["onUpdate:modelValue"] || !1;
    return Ke(e) ? n => Mp(e, n) : e
};

function EB(t) {
    t.target.composing = !0
}

function _T(t) {
    const e = t.target;
    e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")))
}
const yT = {
        created(t, {
            modifiers: {
                lazy: e,
                trim: n,
                number: r
            }
        }, s) {
            t._assign = e1(s);
            const i = r || s.props && s.props.type === "number";
            sc(t, e ? "change" : "input", o => {
                if (o.target.composing) return;
                let a = t.value;
                n && (a = a.trim()), i && (a = l0(a)), t._assign(a)
            }), n && sc(t, "change", () => {
                t.value = t.value.trim()
            }), e || (sc(t, "compositionstart", EB), sc(t, "compositionend", _T), sc(t, "change", _T))
        },
        mounted(t, {
            value: e
        }) {
            t.value = e ?? ""
        },
        beforeUpdate(t, {
            value: e,
            modifiers: {
                lazy: n,
                trim: r,
                number: s
            }
        }, i) {
            if (t._assign = e1(i), t.composing || document.activeElement === t && t.type !== "range" && (n || r && t.value.trim() === e || (s || t.type === "number") && l0(t.value) === e)) return;
            const o = e ?? "";
            t.value !== o && (t.value = o)
        }
    },
    TB = {
        deep: !0,
        created(t, e, n) {
            t._assign = e1(n), sc(t, "change", () => {
                const r = t._modelValue,
                    s = SB(t),
                    i = t.checked,
                    o = t._assign;
                if (Ke(r)) {
                    const a = L8(r, s),
                        l = a !== -1;
                    if (i && !l) o(r.concat(s));
                    else if (!i && l) {
                        const u = [...r];
                        u.splice(a, 1), o(u)
                    }
                } else if (km(r)) {
                    const a = new Set(r);
                    i ? a.add(s) : a.delete(s), o(a)
                } else o(x7(t, i))
            })
        },
        mounted: vT,
        beforeUpdate(t, e, n) {
            t._assign = e1(n), vT(t, e, n)
        }
    };

function vT(t, {
    value: e,
    oldValue: n
}, r) {
    t._modelValue = e, Ke(e) ? t.checked = L8(e, r.props.value) > -1 : km(e) ? t.checked = e.has(r.props.value) : e !== n && (t.checked = xm(e, x7(t, !0)))
}

function SB(t) {
    return "_value" in t ? t._value : t.value
}

function x7(t, e) {
    const n = e ? "_trueValue" : "_falseValue";
    return n in t ? t[n] : e
}
const wB = ["ctrl", "shift", "alt", "meta"],
    AB = {
        stop: t => t.stopPropagation(),
        prevent: t => t.preventDefault(),
        self: t => t.target !== t.currentTarget,
        ctrl: t => !t.ctrlKey,
        shift: t => !t.shiftKey,
        alt: t => !t.altKey,
        meta: t => !t.metaKey,
        left: t => "button" in t && t.button !== 0,
        middle: t => "button" in t && t.button !== 1,
        right: t => "button" in t && t.button !== 2,
        exact: (t, e) => wB.some(n => t[`${n}Key`] && !e.includes(n))
    },
    Oi = (t, e) => (n, ...r) => {
        for (let s = 0; s < e.length; s++) {
            const i = AB[e[s]];
            if (i && i(n, e)) return
        }
        return t(n, ...r)
    },
    OB = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
    },
    E2 = (t, e) => n => {
        if (!("key" in n)) return;
        const r = xc(n.key);
        if (e.some(s => s === r || OB[s] === r)) return t(n)
    },
    CB = Rn({
        patchProp: pB
    }, tB);
let bT;

function kB() {
    return bT || (bT = DU(CB))
}
const P7 = (...t) => {
    const e = kB().createApp(...t),
        {
            mount: n
        } = e;
    return e.mount = r => {
        const s = IB(r);
        if (!s) return;
        const i = e._component;
        !gt(i) && !i.render && !i.template && (i.template = s.innerHTML), s.innerHTML = "";
        const o = n(s, !1, s instanceof SVGElement);
        return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), o
    }, e
};

function IB(t) {
    return En(t) ? document.querySelector(t) : t
}
const He = (t, e) => {
    const n = t.__vccOpts || t;
    for (const [r, s] of e) n[r] = s;
    return n
};
var _n = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function Rc(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}

function NB(t) {
    if (t.__esModule) return t;
    var e = t.default;
    if (typeof e == "function") {
        var n = function r() {
            return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        n.prototype = e.prototype
    } else n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }), Object.keys(t).forEach(function(r) {
        var s = Object.getOwnPropertyDescriptor(t, r);
        Object.defineProperty(n, r, s.get ? s : {
            enumerable: !0,
            get: function() {
                return t[r]
            }
        })
    }), n
}
var xB = {
    exports: {}
};
(function(t) {
    (function() {
        function e(a, l) {
            var u = a.x - l.x,
                f = a.y - l.y;
            return u * u + f * f
        }

        function n(a, l, u) {
            var f = l.x,
                d = l.y,
                p = u.x - f,
                _ = u.y - d;
            if (p !== 0 || _ !== 0) {
                var v = ((a.x - f) * p + (a.y - d) * _) / (p * p + _ * _);
                v > 1 ? (f = u.x, d = u.y) : v > 0 && (f += p * v, d += _ * v)
            }
            return p = a.x - f, _ = a.y - d, p * p + _ * _
        }

        function r(a, l) {
            for (var u = a[0], f = [u], d, p = 1, _ = a.length; p < _; p++) d = a[p], e(d, u) > l && (f.push(d), u = d);
            return u !== d && f.push(d), f
        }

        function s(a, l, u, f, d) {
            for (var p = f, _, v = l + 1; v < u; v++) {
                var y = n(a[v], a[l], a[u]);
                y > p && (_ = v, p = y)
            }
            p > f && (_ - l > 1 && s(a, l, _, f, d), d.push(a[_]), u - _ > 1 && s(a, _, u, f, d))
        }

        function i(a, l) {
            var u = a.length - 1,
                f = [a[0]];
            return s(a, 0, u, l, f), f.push(a[u]), f
        }

        function o(a, l, u) {
            if (a.length <= 2) return a;
            var f = l !== void 0 ? l * l : 1;
            return a = u ? a : r(a, f), a = i(a, f), a
        }
        t.exports = o, t.exports.default = o
    })()
})(xB);
var co = {
        DEBUG: !1,
        LIB_VERSION: "2.48.1"
    },
    yn;
if (typeof window > "u") {
    var ET = {
        hostname: ""
    };
    yn = {
        navigator: {
            userAgent: ""
        },
        document: {
            location: ET,
            referrer: ""
        },
        screen: {
            width: 0,
            height: 0
        },
        location: ET
    }
} else yn = window;
var qm = Array.prototype,
    PB = Function.prototype,
    R7 = Object.prototype,
    Ho = qm.slice,
    Df = R7.toString,
    Gm = R7.hasOwnProperty,
    Nn = yn.console,
    Yo = yn.navigator,
    Yt = yn.document,
    ip = yn.opera,
    t1 = yn.screen,
    vi = Yo.userAgent,
    iy = PB.bind,
    TT = qm.forEach,
    ST = qm.indexOf,
    wT = qm.map,
    RB = Array.isArray,
    w0 = {},
    R = {
        trim: function(t) {
            return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
        }
    },
    qt = {
        log: function() {
            if (co.DEBUG && !R.isUndefined(Nn) && Nn) try {
                Nn.log.apply(Nn, arguments)
            } catch {
                R.each(arguments, function(e) {
                    Nn.log(e)
                })
            }
        },
        warn: function() {
            if (co.DEBUG && !R.isUndefined(Nn) && Nn) {
                var t = ["Mixpanel warning:"].concat(R.toArray(arguments));
                try {
                    Nn.warn.apply(Nn, t)
                } catch {
                    R.each(t, function(n) {
                        Nn.warn(n)
                    })
                }
            }
        },
        error: function() {
            if (co.DEBUG && !R.isUndefined(Nn) && Nn) {
                var t = ["Mixpanel error:"].concat(R.toArray(arguments));
                try {
                    Nn.error.apply(Nn, t)
                } catch {
                    R.each(t, function(n) {
                        Nn.error(n)
                    })
                }
            }
        },
        critical: function() {
            if (!R.isUndefined(Nn) && Nn) {
                var t = ["Mixpanel error:"].concat(R.toArray(arguments));
                try {
                    Nn.error.apply(Nn, t)
                } catch {
                    R.each(t, function(n) {
                        Nn.error(n)
                    })
                }
            }
        }
    },
    oy = function(t, e) {
        return function() {
            return arguments[0] = "[" + e + "] " + arguments[0], t.apply(qt, arguments)
        }
    },
    T2 = function(t) {
        return {
            log: oy(qt.log, t),
            error: oy(qt.error, t),
            critical: oy(qt.critical, t)
        }
    };
R.bind = function(t, e) {
    var n, r;
    if (iy && t.bind === iy) return iy.apply(t, Ho.call(arguments, 1));
    if (!R.isFunction(t)) throw new TypeError;
    return n = Ho.call(arguments, 2), r = function() {
        if (!(this instanceof r)) return t.apply(e, n.concat(Ho.call(arguments)));
        var s = {};
        s.prototype = t.prototype;
        var i = new s;
        s.prototype = null;
        var o = t.apply(i, n.concat(Ho.call(arguments)));
        return Object(o) === o ? o : i
    }, r
};
R.each = function(t, e, n) {
    if (t != null) {
        if (TT && t.forEach === TT) t.forEach(e, n);
        else if (t.length === +t.length) {
            for (var r = 0, s = t.length; r < s; r++)
                if (r in t && e.call(n, t[r], r, t) === w0) return
        } else
            for (var i in t)
                if (Gm.call(t, i) && e.call(n, t[i], i, t) === w0) return
    }
};
R.extend = function(t) {
    return R.each(Ho.call(arguments, 1), function(e) {
        for (var n in e) e[n] !== void 0 && (t[n] = e[n])
    }), t
};
R.isArray = RB || function(t) {
    return Df.call(t) === "[object Array]"
};
R.isFunction = function(t) {
    try {
        return /^\s*\bfunction\b/.test(t)
    } catch {
        return !1
    }
};
R.isArguments = function(t) {
    return !!(t && Gm.call(t, "callee"))
};
R.toArray = function(t) {
    return t ? t.toArray ? t.toArray() : R.isArray(t) || R.isArguments(t) ? Ho.call(t) : R.values(t) : []
};
R.map = function(t, e, n) {
    if (wT && t.map === wT) return t.map(e, n);
    var r = [];
    return R.each(t, function(s) {
        r.push(e.call(n, s))
    }), r
};
R.keys = function(t) {
    var e = [];
    return t === null || R.each(t, function(n, r) {
        e[e.length] = r
    }), e
};
R.values = function(t) {
    var e = [];
    return t === null || R.each(t, function(n) {
        e[e.length] = n
    }), e
};
R.include = function(t, e) {
    var n = !1;
    return t === null ? n : ST && t.indexOf === ST ? t.indexOf(e) != -1 : (R.each(t, function(r) {
        if (n || (n = r === e)) return w0
    }), n)
};
R.includes = function(t, e) {
    return t.indexOf(e) !== -1
};
R.inherit = function(t, e) {
    return t.prototype = new e, t.prototype.constructor = t, t.superclass = e.prototype, t
};
R.isObject = function(t) {
    return t === Object(t) && !R.isArray(t)
};
R.isEmptyObject = function(t) {
    if (R.isObject(t)) {
        for (var e in t)
            if (Gm.call(t, e)) return !1;
        return !0
    }
    return !1
};
R.isUndefined = function(t) {
    return t === void 0
};
R.isString = function(t) {
    return Df.call(t) == "[object String]"
};
R.isDate = function(t) {
    return Df.call(t) == "[object Date]"
};
R.isNumber = function(t) {
    return Df.call(t) == "[object Number]"
};
R.isElement = function(t) {
    return !!(t && t.nodeType === 1)
};
R.encodeDates = function(t) {
    return R.each(t, function(e, n) {
        R.isDate(e) ? t[n] = R.formatDate(e) : R.isObject(e) && (t[n] = R.encodeDates(e))
    }), t
};
R.timestamp = function() {
    return Date.now = Date.now || function() {
        return +new Date
    }, Date.now()
};
R.formatDate = function(t) {
    function e(n) {
        return n < 10 ? "0" + n : n
    }
    return t.getUTCFullYear() + "-" + e(t.getUTCMonth() + 1) + "-" + e(t.getUTCDate()) + "T" + e(t.getUTCHours()) + ":" + e(t.getUTCMinutes()) + ":" + e(t.getUTCSeconds())
};
R.strip_empty_properties = function(t) {
    var e = {};
    return R.each(t, function(n, r) {
        R.isString(n) && n.length > 0 && (e[r] = n)
    }), e
};
R.truncate = function(t, e) {
    var n;
    return typeof t == "string" ? n = t.slice(0, e) : R.isArray(t) ? (n = [], R.each(t, function(r) {
        n.push(R.truncate(r, e))
    })) : R.isObject(t) ? (n = {}, R.each(t, function(r, s) {
        n[s] = R.truncate(r, e)
    })) : n = t, n
};
R.JSONEncode = function() {
    return function(t) {
        var e = t,
            n = function(s) {
                var i = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                    o = {
                        "\b": "\\b",
                        "	": "\\t",
                        "\n": "\\n",
                        "\f": "\\f",
                        "\r": "\\r",
                        '"': '\\"',
                        "\\": "\\\\"
                    };
                return i.lastIndex = 0, i.test(s) ? '"' + s.replace(i, function(a) {
                    var l = o[a];
                    return typeof l == "string" ? l : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
                }) + '"' : '"' + s + '"'
            },
            r = function(s, i) {
                var o = "",
                    a = "    ",
                    l = 0,
                    u = "",
                    f = "",
                    d = 0,
                    p = o,
                    _ = [],
                    v = i[s];
                switch (v && typeof v == "object" && typeof v.toJSON == "function" && (v = v.toJSON(s)), typeof v) {
                    case "string":
                        return n(v);
                    case "number":
                        return isFinite(v) ? String(v) : "null";
                    case "boolean":
                    case "null":
                        return String(v);
                    case "object":
                        if (!v) return "null";
                        if (o += a, _ = [], Df.apply(v) === "[object Array]") {
                            for (d = v.length, l = 0; l < d; l += 1) _[l] = r(l, v) || "null";
                            return f = _.length === 0 ? "[]" : o ? `[
` + o + _.join(`,
` + o) + `
` + p + "]" : "[" + _.join(",") + "]", o = p, f
                        }
                        for (u in v) Gm.call(v, u) && (f = r(u, v), f && _.push(n(u) + (o ? ": " : ":") + f));
                        return f = _.length === 0 ? "{}" : o ? "{" + _.join(",") + p + "}" : "{" + _.join(",") + "}", o = p, f
                }
            };
        return r("", {
            "": e
        })
    }
}();
R.JSONDecode = function() {
    var t, e, n = {
            '"': '"',
            "\\": "\\",
            "/": "/",
            b: "\b",
            f: "\f",
            n: `
`,
            r: "\r",
            t: "	"
        },
        r, s = function(_) {
            var v = new SyntaxError(_);
            throw v.at = t, v.text = r, v
        },
        i = function(_) {
            return _ && _ !== e && s("Expected '" + _ + "' instead of '" + e + "'"), e = r.charAt(t), t += 1, e
        },
        o = function() {
            var _, v = "";
            for (e === "-" && (v = "-", i("-")); e >= "0" && e <= "9";) v += e, i();
            if (e === ".")
                for (v += "."; i() && e >= "0" && e <= "9";) v += e;
            if (e === "e" || e === "E")
                for (v += e, i(), (e === "-" || e === "+") && (v += e, i()); e >= "0" && e <= "9";) v += e, i();
            if (_ = +v, !isFinite(_)) s("Bad number");
            else return _
        },
        a = function() {
            var _, v, y = "",
                g;
            if (e === '"')
                for (; i();) {
                    if (e === '"') return i(), y;
                    if (e === "\\")
                        if (i(), e === "u") {
                            for (g = 0, v = 0; v < 4 && (_ = parseInt(i(), 16), !!isFinite(_)); v += 1) g = g * 16 + _;
                            y += String.fromCharCode(g)
                        } else if (typeof n[e] == "string") y += n[e];
                    else break;
                    else y += e
                }
            s("Bad string")
        },
        l = function() {
            for (; e && e <= " ";) i()
        },
        u = function() {
            switch (e) {
                case "t":
                    return i("t"), i("r"), i("u"), i("e"), !0;
                case "f":
                    return i("f"), i("a"), i("l"), i("s"), i("e"), !1;
                case "n":
                    return i("n"), i("u"), i("l"), i("l"), null
            }
            s('Unexpected "' + e + '"')
        },
        f, d = function() {
            var _ = [];
            if (e === "[") {
                if (i("["), l(), e === "]") return i("]"), _;
                for (; e;) {
                    if (_.push(f()), l(), e === "]") return i("]"), _;
                    i(","), l()
                }
            }
            s("Bad array")
        },
        p = function() {
            var _, v = {};
            if (e === "{") {
                if (i("{"), l(), e === "}") return i("}"), v;
                for (; e;) {
                    if (_ = a(), l(), i(":"), Object.hasOwnProperty.call(v, _) && s('Duplicate key "' + _ + '"'), v[_] = f(), l(), e === "}") return i("}"), v;
                    i(","), l()
                }
            }
            s("Bad object")
        };
    return f = function() {
            switch (l(), e) {
                case "{":
                    return p();
                case "[":
                    return d();
                case '"':
                    return a();
                case "-":
                    return o();
                default:
                    return e >= "0" && e <= "9" ? o() : u()
            }
        },
        function(_) {
            var v;
            return r = _, t = 0, e = " ", v = f(), l(), e && s("Syntax error"), v
        }
}();
R.base64Encode = function(t) {
    var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        n, r, s, i, o, a, l, u, f = 0,
        d = 0,
        p = "",
        _ = [];
    if (!t) return t;
    t = R.utf8Encode(t);
    do n = t.charCodeAt(f++), r = t.charCodeAt(f++), s = t.charCodeAt(f++), u = n << 16 | r << 8 | s, i = u >> 18 & 63, o = u >> 12 & 63, a = u >> 6 & 63, l = u & 63, _[d++] = e.charAt(i) + e.charAt(o) + e.charAt(a) + e.charAt(l); while (f < t.length);
    switch (p = _.join(""), t.length % 3) {
        case 1:
            p = p.slice(0, -2) + "==";
            break;
        case 2:
            p = p.slice(0, -1) + "=";
            break
    }
    return p
};
R.utf8Encode = function(t) {
    t = (t + "").replace(/\r\n/g, `
`).replace(/\r/g, `
`);
    var e = "",
        n, r, s = 0,
        i;
    for (n = r = 0, s = t.length, i = 0; i < s; i++) {
        var o = t.charCodeAt(i),
            a = null;
        o < 128 ? r++ : o > 127 && o < 2048 ? a = String.fromCharCode(o >> 6 | 192, o & 63 | 128) : a = String.fromCharCode(o >> 12 | 224, o >> 6 & 63 | 128, o & 63 | 128), a !== null && (r > n && (e += t.substring(n, r)), e += a, n = r = i + 1)
    }
    return r > n && (e += t.substring(n, t.length)), e
};
R.UUID = function() {
    var t = function() {
            var r = 1 * new Date,
                s;
            if (yn.performance && yn.performance.now) s = yn.performance.now();
            else
                for (s = 0; r == 1 * new Date;) s++;
            return r.toString(16) + Math.floor(s).toString(16)
        },
        e = function() {
            return Math.random().toString(16).replace(".", "")
        },
        n = function() {
            var r = vi,
                s, i, o = [],
                a = 0;

            function l(u, f) {
                var d, p = 0;
                for (d = 0; d < f.length; d++) p |= o[d] << d * 8;
                return u ^ p
            }
            for (s = 0; s < r.length; s++) i = r.charCodeAt(s), o.unshift(i & 255), o.length >= 4 && (a = l(a, o), o = []);
            return o.length > 0 && (a = l(a, o)), a.toString(16)
        };
    return function() {
        var r = (t1.height * t1.width).toString(16);
        return t() + "-" + e() + "-" + n() + "-" + r + "-" + t()
    }
}();
var AT = ["ahrefsbot", "baiduspider", "bingbot", "bingpreview", "chrome-lighthouse", "facebookexternal", "petalbot", "pinterest", "screaming frog", "yahoo! slurp", "yandexbot", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google"];
R.isBlockedUA = function(t) {
    var e;
    for (t = t.toLowerCase(), e = 0; e < AT.length; e++)
        if (t.indexOf(AT[e]) !== -1) return !0;
    return !1
};
R.HTTPBuildQuery = function(t, e) {
    var n, r, s = [];
    return R.isUndefined(e) && (e = "&"), R.each(t, function(i, o) {
        n = encodeURIComponent(i.toString()), r = encodeURIComponent(o), s[s.length] = r + "=" + n
    }), s.join(e)
};
R.getQueryParam = function(t, e) {
    e = e.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
    var n = "[\\?&]" + e + "=([^&#]*)",
        r = new RegExp(n),
        s = r.exec(t);
    if (s === null || s && typeof s[1] != "string" && s[1].length) return "";
    var i = s[1];
    try {
        i = decodeURIComponent(i)
    } catch {
        qt.error("Skipping decoding for malformed query param: " + i)
    }
    return i.replace(/\+/g, " ")
};
R.cookie = {
    get: function(t) {
        for (var e = t + "=", n = Yt.cookie.split(";"), r = 0; r < n.length; r++) {
            for (var s = n[r]; s.charAt(0) == " ";) s = s.substring(1, s.length);
            if (s.indexOf(e) === 0) return decodeURIComponent(s.substring(e.length, s.length))
        }
        return null
    },
    parse: function(t) {
        var e;
        try {
            e = R.JSONDecode(R.cookie.get(t)) || {}
        } catch {}
        return e
    },
    set_seconds: function(t, e, n, r, s, i, o) {
        var a = "",
            l = "",
            u = "";
        if (o) a = "; domain=" + o;
        else if (r) {
            var f = OT(Yt.location.hostname);
            a = f ? "; domain=." + f : ""
        }
        if (n) {
            var d = new Date;
            d.setTime(d.getTime() + n * 1e3), l = "; expires=" + d.toGMTString()
        }
        i && (s = !0, u = "; SameSite=None"), s && (u += "; secure"), Yt.cookie = t + "=" + encodeURIComponent(e) + l + "; path=/" + a + u
    },
    set: function(t, e, n, r, s, i, o) {
        var a = "",
            l = "",
            u = "";
        if (o) a = "; domain=" + o;
        else if (r) {
            var f = OT(Yt.location.hostname);
            a = f ? "; domain=." + f : ""
        }
        if (n) {
            var d = new Date;
            d.setTime(d.getTime() + n * 24 * 60 * 60 * 1e3), l = "; expires=" + d.toGMTString()
        }
        i && (s = !0, u = "; SameSite=None"), s && (u += "; secure");
        var p = t + "=" + encodeURIComponent(e) + l + "; path=/" + a + u;
        return Yt.cookie = p, p
    },
    remove: function(t, e, n) {
        R.cookie.set(t, "", -1, e, !1, !1, n)
    }
};
var ay = null,
    n1 = function(t, e) {
        if (ay !== null && !e) return ay;
        var n = !0;
        try {
            t = t || window.localStorage;
            var r = "__mplss_" + S2(8),
                s = "xyz";
            t.setItem(r, s), t.getItem(r) !== s && (n = !1), t.removeItem(r)
        } catch {
            n = !1
        }
        return ay = n, n
    };
R.localStorage = {
    is_supported: function(t) {
        var e = n1(null, t);
        return e || qt.error("localStorage unsupported; falling back to cookie store"), e
    },
    error: function(t) {
        qt.error("localStorage error: " + t)
    },
    get: function(t) {
        try {
            return window.localStorage.getItem(t)
        } catch (e) {
            R.localStorage.error(e)
        }
        return null
    },
    parse: function(t) {
        try {
            return R.JSONDecode(R.localStorage.get(t)) || {}
        } catch {}
        return null
    },
    set: function(t, e) {
        try {
            window.localStorage.setItem(t, e)
        } catch (n) {
            R.localStorage.error(n)
        }
    },
    remove: function(t) {
        try {
            window.localStorage.removeItem(t)
        } catch (e) {
            R.localStorage.error(e)
        }
    }
};
R.register_event = function() {
    var t = function(r, s, i, o, a) {
        if (!r) {
            qt.error("No valid element provided to register_event");
            return
        }
        if (r.addEventListener && !o) r.addEventListener(s, i, !!a);
        else {
            var l = "on" + s,
                u = r[l];
            r[l] = e(r, i, u)
        }
    };

    function e(r, s, i) {
        var o = function(a) {
            if (a = a || n(window.event), !!a) {
                var l = !0,
                    u, f;
                return R.isFunction(i) && (u = i(a)), f = s.call(r, a), (u === !1 || f === !1) && (l = !1), l
            }
        };
        return o
    }

    function n(r) {
        return r && (r.preventDefault = n.preventDefault, r.stopPropagation = n.stopPropagation), r
    }
    return n.preventDefault = function() {
        this.returnValue = !1
    }, n.stopPropagation = function() {
        this.cancelBubble = !0
    }, t
}();
var MB = new RegExp('^(\\w*)\\[(\\w+)([=~\\|\\^\\$\\*]?)=?"?([^\\]"]*)"?\\]$');
R.dom_query = function() {
    function t(s) {
        return s.all ? s.all : s.getElementsByTagName("*")
    }
    var e = /[\t\r\n]/g;

    function n(s, i) {
        var o = " " + i + " ";
        return (" " + s.className + " ").replace(e, " ").indexOf(o) >= 0
    }

    function r(s) {
        if (!Yt.getElementsByTagName) return [];
        var i = s.split(" "),
            o, a, l, u, f, d, p, _, v, y, g = [Yt];
        for (d = 0; d < i.length; d++) {
            if (o = i[d].replace(/^\s+/, "").replace(/\s+$/, ""), o.indexOf("#") > -1) {
                a = o.split("#"), l = a[0];
                var b = a[1],
                    O = Yt.getElementById(b);
                if (!O || l && O.nodeName.toLowerCase() != l) return [];
                g = [O];
                continue
            }
            if (o.indexOf(".") > -1) {
                a = o.split("."), l = a[0];
                var N = a[1];
                for (l || (l = "*"), u = [], f = 0, p = 0; p < g.length; p++)
                    for (l == "*" ? v = t(g[p]) : v = g[p].getElementsByTagName(l), _ = 0; _ < v.length; _++) u[f++] = v[_];
                for (g = [], y = 0, p = 0; p < u.length; p++) u[p].className && R.isString(u[p].className) && n(u[p], N) && (g[y++] = u[p]);
                continue
            }
            var k = o.match(MB);
            if (k) {
                l = k[1];
                var A = k[2],
                    x = k[3],
                    D = k[4];
                for (l || (l = "*"), u = [], f = 0, p = 0; p < g.length; p++)
                    for (l == "*" ? v = t(g[p]) : v = g[p].getElementsByTagName(l), _ = 0; _ < v.length; _++) u[f++] = v[_];
                g = [], y = 0;
                var L;
                switch (x) {
                    case "=":
                        L = function(q) {
                            return q.getAttribute(A) == D
                        };
                        break;
                    case "~":
                        L = function(q) {
                            return q.getAttribute(A).match(new RegExp("\\b" + D + "\\b"))
                        };
                        break;
                    case "|":
                        L = function(q) {
                            return q.getAttribute(A).match(new RegExp("^" + D + "-?"))
                        };
                        break;
                    case "^":
                        L = function(q) {
                            return q.getAttribute(A).indexOf(D) === 0
                        };
                        break;
                    case "$":
                        L = function(q) {
                            return q.getAttribute(A).lastIndexOf(D) == q.getAttribute(A).length - D.length
                        };
                        break;
                    case "*":
                        L = function(q) {
                            return q.getAttribute(A).indexOf(D) > -1
                        };
                        break;
                    default:
                        L = function(q) {
                            return q.getAttribute(A)
                        }
                }
                for (g = [], y = 0, p = 0; p < u.length; p++) L(u[p]) && (g[y++] = u[p]);
                continue
            }
            for (l = o, u = [], f = 0, p = 0; p < g.length; p++)
                for (v = g[p].getElementsByTagName(l), _ = 0; _ < v.length; _++) u[f++] = v[_];
            g = u
        }
        return g
    }
    return function(s) {
        return R.isElement(s) ? [s] : R.isObject(s) && !R.isUndefined(s.length) ? s : r.call(this, s)
    }
}();
var DB = ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term"],
    $B = ["dclid", "fbclid", "gclid", "ko_click_id", "li_fat_id", "msclkid", "ttclid", "twclid", "wbraid"];
R.info = {
    campaignParams: function(t) {
        var e = "",
            n = {};
        return R.each(DB, function(r) {
            e = R.getQueryParam(Yt.URL, r), e.length ? n[r] = e : t !== void 0 && (n[r] = t)
        }), n
    },
    clickParams: function() {
        var t = "",
            e = {};
        return R.each($B, function(n) {
            t = R.getQueryParam(Yt.URL, n), t.length && (e[n] = t)
        }), e
    },
    marketingParams: function() {
        return R.extend(R.info.campaignParams(), R.info.clickParams())
    },
    searchEngine: function(t) {
        return t.search("https?://(.*)google.([^/?]*)") === 0 ? "google" : t.search("https?://(.*)bing.com") === 0 ? "bing" : t.search("https?://(.*)yahoo.com") === 0 ? "yahoo" : t.search("https?://(.*)duckduckgo.com") === 0 ? "duckduckgo" : null
    },
    searchInfo: function(t) {
        var e = R.info.searchEngine(t),
            n = e != "yahoo" ? "q" : "p",
            r = {};
        if (e !== null) {
            r.$search_engine = e;
            var s = R.getQueryParam(t, n);
            s.length && (r.mp_keyword = s)
        }
        return r
    },
    browser: function(t, e, n) {
        return e = e || "", n || R.includes(t, " OPR/") ? R.includes(t, "Mini") ? "Opera Mini" : "Opera" : /(BlackBerry|PlayBook|BB10)/i.test(t) ? "BlackBerry" : R.includes(t, "IEMobile") || R.includes(t, "WPDesktop") ? "Internet Explorer Mobile" : R.includes(t, "SamsungBrowser/") ? "Samsung Internet" : R.includes(t, "Edge") || R.includes(t, "Edg/") ? "Microsoft Edge" : R.includes(t, "FBIOS") ? "Facebook Mobile" : R.includes(t, "Chrome") ? "Chrome" : R.includes(t, "CriOS") ? "Chrome iOS" : R.includes(t, "UCWEB") || R.includes(t, "UCBrowser") ? "UC Browser" : R.includes(t, "FxiOS") ? "Firefox iOS" : R.includes(e, "Apple") ? R.includes(t, "Mobile") ? "Mobile Safari" : "Safari" : R.includes(t, "Android") ? "Android Mobile" : R.includes(t, "Konqueror") ? "Konqueror" : R.includes(t, "Firefox") ? "Firefox" : R.includes(t, "MSIE") || R.includes(t, "Trident/") ? "Internet Explorer" : R.includes(t, "Gecko") ? "Mozilla" : ""
    },
    browserVersion: function(t, e, n) {
        var r = R.info.browser(t, e, n),
            s = {
                "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
                "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/,
                Chrome: /Chrome\/(\d+(\.\d+)?)/,
                "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
                "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
                Safari: /Version\/(\d+(\.\d+)?)/,
                "Mobile Safari": /Version\/(\d+(\.\d+)?)/,
                Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/,
                Firefox: /Firefox\/(\d+(\.\d+)?)/,
                "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
                Konqueror: /Konqueror:(\d+(\.\d+)?)/,
                BlackBerry: /BlackBerry (\d+(\.\d+)?)/,
                "Android Mobile": /android\s(\d+(\.\d+)?)/,
                "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/,
                "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
                Mozilla: /rv:(\d+(\.\d+)?)/
            },
            i = s[r];
        if (i === void 0) return null;
        var o = t.match(i);
        return o ? parseFloat(o[o.length - 2]) : null
    },
    os: function() {
        var t = vi;
        return /Windows/i.test(t) ? /Phone/.test(t) || /WPDesktop/.test(t) ? "Windows Phone" : "Windows" : /(iPhone|iPad|iPod)/.test(t) ? "iOS" : /Android/.test(t) ? "Android" : /(BlackBerry|PlayBook|BB10)/i.test(t) ? "BlackBerry" : /Mac/i.test(t) ? "Mac OS X" : /Linux/.test(t) ? "Linux" : /CrOS/.test(t) ? "Chrome OS" : ""
    },
    device: function(t) {
        return /Windows Phone/i.test(t) || /WPDesktop/.test(t) ? "Windows Phone" : /iPad/.test(t) ? "iPad" : /iPod/.test(t) ? "iPod Touch" : /iPhone/.test(t) ? "iPhone" : /(BlackBerry|PlayBook|BB10)/i.test(t) ? "BlackBerry" : /Android/.test(t) ? "Android" : ""
    },
    referringDomain: function(t) {
        var e = t.split("/");
        return e.length >= 3 ? e[2] : ""
    },
    properties: function() {
        return R.extend(R.strip_empty_properties({
            $os: R.info.os(),
            $browser: R.info.browser(vi, Yo.vendor, ip),
            $referrer: Yt.referrer,
            $referring_domain: R.info.referringDomain(Yt.referrer),
            $device: R.info.device(vi)
        }), {
            $current_url: yn.location.href,
            $browser_version: R.info.browserVersion(vi, Yo.vendor, ip),
            $screen_height: t1.height,
            $screen_width: t1.width,
            mp_lib: "web",
            $lib_version: co.LIB_VERSION,
            $insert_id: S2(),
            time: R.timestamp() / 1e3
        })
    },
    people_properties: function() {
        return R.extend(R.strip_empty_properties({
            $os: R.info.os(),
            $browser: R.info.browser(vi, Yo.vendor, ip)
        }), {
            $browser_version: R.info.browserVersion(vi, Yo.vendor, ip)
        })
    },
    mpPageViewProperties: function() {
        return R.strip_empty_properties({
            current_page_title: Yt.title,
            current_domain: yn.location.hostname,
            current_url_path: yn.location.pathname,
            current_url_protocol: yn.location.protocol,
            current_url_search: yn.location.search
        })
    }
};
var S2 = function(t) {
        var e = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);
        return t ? e.substring(0, t) : e
    },
    LB = /[a-z0-9][a-z0-9-]*\.[a-z]+$/i,
    FB = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i,
    OT = function(t) {
        var e = FB,
            n = t.split("."),
            r = n[n.length - 1];
        (r.length > 4 || r === "com" || r === "org") && (e = LB);
        var s = t.match(e);
        return s ? s[0] : ""
    },
    r1 = null,
    s1 = null;
typeof JSON < "u" && (r1 = JSON.stringify, s1 = JSON.parse);
r1 = r1 || R.JSONEncode;
s1 = s1 || R.JSONDecode;
R.toArray = R.toArray;
R.isObject = R.isObject;
R.JSONEncode = R.JSONEncode;
R.JSONDecode = R.JSONDecode;
R.isBlockedUA = R.isBlockedUA;
R.isEmptyObject = R.isEmptyObject;
R.info = R.info;
R.info.device = R.info.device;
R.info.browser = R.info.browser;
R.info.browserVersion = R.info.browserVersion;
R.info.properties = R.info.properties;
var vo = function() {};
vo.prototype.create_properties = function() {};
vo.prototype.event_handler = function() {};
vo.prototype.after_track_handler = function() {};
vo.prototype.init = function(t) {
    return this.mp = t, this
};
vo.prototype.track = function(t, e, n, r) {
    var s = this,
        i = R.dom_query(t);
    if (i.length === 0) {
        qt.error("The DOM query (" + t + ") returned 0 elements");
        return
    }
    return R.each(i, function(o) {
        R.register_event(o, this.override_event, function(a) {
            var l = {},
                u = s.create_properties(n, this),
                f = s.mp.get_config("track_links_timeout");
            s.event_handler(a, this, l), window.setTimeout(s.track_callback(r, u, l, !0), f), s.mp.track(e, u, s.track_callback(r, u, l))
        })
    }, this), !0
};
vo.prototype.track_callback = function(t, e, n, r) {
    r = r || !1;
    var s = this;
    return function() {
        n.callback_fired || (n.callback_fired = !0, !(t && t(r, e) === !1) && s.after_track_handler(e, n, r))
    }
};
vo.prototype.create_properties = function(t, e) {
    var n;
    return typeof t == "function" ? n = t(e) : n = R.extend({}, t), n
};
var Hl = function() {
    this.override_event = "click"
};
R.inherit(Hl, vo);
Hl.prototype.create_properties = function(t, e) {
    var n = Hl.superclass.create_properties.apply(this, arguments);
    return e.href && (n.url = e.href), n
};
Hl.prototype.event_handler = function(t, e, n) {
    n.new_tab = t.which === 2 || t.metaKey || t.ctrlKey || e.target === "_blank", n.href = e.href, n.new_tab || t.preventDefault()
};
Hl.prototype.after_track_handler = function(t, e) {
    e.new_tab || setTimeout(function() {
        window.location = e.href
    }, 0)
};
var Vm = function() {
    this.override_event = "submit"
};
R.inherit(Vm, vo);
Vm.prototype.event_handler = function(t, e, n) {
    n.element = e, t.preventDefault()
};
Vm.prototype.after_track_handler = function(t, e) {
    setTimeout(function() {
        e.element.submit()
    }, 0)
};
var UB = T2("lock"),
    M7 = function(t, e) {
        e = e || {}, this.storageKey = t, this.storage = e.storage || window.localStorage, this.pollIntervalMS = e.pollIntervalMS || 100, this.timeoutMS = e.timeoutMS || 2e3
    };
M7.prototype.withLock = function(t, e, n) {
    !n && typeof e != "function" && (n = e, e = null);
    var r = n || new Date().getTime() + "|" + Math.random(),
        s = new Date().getTime(),
        i = this.storageKey,
        o = this.pollIntervalMS,
        a = this.timeoutMS,
        l = this.storage,
        u = i + ":X",
        f = i + ":Y",
        d = i + ":Z",
        p = function(O) {
            e && e(O)
        },
        _ = function(O) {
            if (new Date().getTime() - s > a) {
                UB.error("Timeout waiting for mutex on " + i + "; clearing lock. [" + r + "]"), l.removeItem(d), l.removeItem(f), g();
                return
            }
            setTimeout(function() {
                try {
                    O()
                } catch (N) {
                    p(N)
                }
            }, o * (Math.random() + .1))
        },
        v = function(O, N) {
            O() ? N() : _(function() {
                v(O, N)
            })
        },
        y = function() {
            var O = l.getItem(f);
            if (O && O !== r) return !1;
            if (l.setItem(f, r), l.getItem(f) === r) return !0;
            if (!n1(l, !0)) throw new Error("localStorage support dropped while acquiring lock");
            return !1
        },
        g = function() {
            l.setItem(u, r), v(y, function() {
                if (l.getItem(u) === r) {
                    b();
                    return
                }
                _(function() {
                    if (l.getItem(f) !== r) {
                        g();
                        return
                    }
                    v(function() {
                        return !l.getItem(d)
                    }, b)
                })
            })
        },
        b = function() {
            l.setItem(d, "1");
            try {
                t()
            } finally {
                l.removeItem(d), l.getItem(f) === r && l.removeItem(f), l.getItem(u) === r && l.removeItem(u)
            }
        };
    try {
        if (n1(l, !0)) g();
        else throw new Error("localStorage support check failed")
    } catch (O) {
        p(O)
    }
};
var CT = T2("batch"),
    Sa = function(t, e) {
        e = e || {}, this.storageKey = t, this.storage = e.storage || window.localStorage, this.reportError = e.errorReporter || R.bind(CT.error, CT), this.lock = new M7(t, {
            storage: this.storage
        }), this.pid = e.pid || null, this.memQueue = []
    };
Sa.prototype.enqueue = function(t, e, n) {
    var r = {
        id: S2(),
        flushAfter: new Date().getTime() + e * 2,
        payload: t
    };
    this.lock.withLock(R.bind(function() {
        var i;
        try {
            var o = this.readFromStorage();
            o.push(r), i = this.saveToStorage(o), i && this.memQueue.push(r)
        } catch {
            this.reportError("Error enqueueing item", t), i = !1
        }
        n && n(i)
    }, this), R.bind(function(i) {
        this.reportError("Error acquiring storage lock", i), n && n(!1)
    }, this), this.pid)
};
Sa.prototype.fillBatch = function(t) {
    var e = this.memQueue.slice(0, t);
    if (e.length < t) {
        var n = this.readFromStorage();
        if (n.length) {
            var r = {};
            R.each(e, function(o) {
                r[o.id] = !0
            });
            for (var s = 0; s < n.length; s++) {
                var i = n[s];
                if (new Date().getTime() > i.flushAfter && !r[i.id] && (i.orphaned = !0, e.push(i), e.length >= t)) break
            }
        }
    }
    return e
};
var kT = function(t, e) {
    var n = [];
    return R.each(t, function(r) {
        r.id && !e[r.id] && n.push(r)
    }), n
};
Sa.prototype.removeItemsByID = function(t, e) {
    var n = {};
    R.each(t, function(s) {
        n[s] = !0
    }), this.memQueue = kT(this.memQueue, n);
    var r = R.bind(function() {
        var s;
        try {
            var i = this.readFromStorage();
            if (i = kT(i, n), s = this.saveToStorage(i), s) {
                i = this.readFromStorage();
                for (var o = 0; o < i.length; o++) {
                    var a = i[o];
                    if (a.id && n[a.id]) return this.reportError("Item not removed from storage"), !1
                }
            }
        } catch {
            this.reportError("Error removing items", t), s = !1
        }
        return s
    }, this);
    this.lock.withLock(function() {
        var i = r();
        e && e(i)
    }, R.bind(function(i) {
        var o = !1;
        if (this.reportError("Error acquiring storage lock", i), !n1(this.storage, !0) && (o = r(), !o)) try {
            this.storage.removeItem(this.storageKey)
        } catch (a) {
            this.reportError("Error clearing queue", a)
        }
        e && e(o)
    }, this), this.pid)
};
var IT = function(t, e) {
    var n = [];
    return R.each(t, function(r) {
        var s = r.id;
        if (s in e) {
            var i = e[s];
            i !== null && (r.payload = i, n.push(r))
        } else n.push(r)
    }), n
};
Sa.prototype.updatePayloads = function(t, e) {
    this.memQueue = IT(this.memQueue, t), this.lock.withLock(R.bind(function() {
        var r;
        try {
            var s = this.readFromStorage();
            s = IT(s, t), r = this.saveToStorage(s)
        } catch {
            this.reportError("Error updating items", t), r = !1
        }
        e && e(r)
    }, this), R.bind(function(r) {
        this.reportError("Error acquiring storage lock", r), e && e(!1)
    }, this), this.pid)
};
Sa.prototype.readFromStorage = function() {
    var t;
    try {
        t = this.storage.getItem(this.storageKey), t && (t = s1(t), R.isArray(t) || (this.reportError("Invalid storage entry:", t), t = null))
    } catch (e) {
        this.reportError("Error retrieving queue", e), t = null
    }
    return t || []
};
Sa.prototype.saveToStorage = function(t) {
    try {
        return this.storage.setItem(this.storageKey, r1(t)), !0
    } catch (e) {
        return this.reportError("Error saving queue", e), !1
    }
};
Sa.prototype.clear = function() {
    this.memQueue = [], this.storage.removeItem(this.storageKey)
};
var BB = 10 * 60 * 1e3,
    Sh = T2("batch"),
    Li = function(t, e) {
        this.errorReporter = e.errorReporter, this.queue = new Sa(t, {
            errorReporter: R.bind(this.reportError, this),
            storage: e.storage
        }), this.libConfig = e.libConfig, this.sendRequest = e.sendRequestFunc, this.beforeSendHook = e.beforeSendHook, this.stopAllBatching = e.stopAllBatchingFunc, this.batchSize = this.libConfig.batch_size, this.flushInterval = this.libConfig.batch_flush_interval_ms, this.stopped = !this.libConfig.batch_autostart, this.consecutiveRemovalFailures = 0, this.itemIdsSentSuccessfully = {}
    };
Li.prototype.enqueue = function(t, e) {
    this.queue.enqueue(t, this.flushInterval, e)
};
Li.prototype.start = function() {
    this.stopped = !1, this.consecutiveRemovalFailures = 0, this.flush()
};
Li.prototype.stop = function() {
    this.stopped = !0, this.timeoutID && (clearTimeout(this.timeoutID), this.timeoutID = null)
};
Li.prototype.clear = function() {
    this.queue.clear()
};
Li.prototype.resetBatchSize = function() {
    this.batchSize = this.libConfig.batch_size
};
Li.prototype.resetFlush = function() {
    this.scheduleFlush(this.libConfig.batch_flush_interval_ms)
};
Li.prototype.scheduleFlush = function(t) {
    this.flushInterval = t, this.stopped || (this.timeoutID = setTimeout(R.bind(this.flush, this), this.flushInterval))
};
Li.prototype.flush = function(t) {
    try {
        if (this.requestInProgress) {
            Sh.log("Flush: Request already in progress");
            return
        }
        t = t || {};
        var e = this.libConfig.batch_request_timeout_ms,
            n = new Date().getTime(),
            r = this.batchSize,
            s = this.queue.fillBatch(r),
            i = [],
            o = {};
        if (R.each(s, function(u) {
                var f = u.payload;
                if (this.beforeSendHook && !u.orphaned && (f = this.beforeSendHook(f)), f) {
                    f.event && f.properties && (f.properties = R.extend({}, f.properties, {
                        mp_sent_by_lib_version: co.LIB_VERSION
                    }));
                    var d = !0,
                        p = u.id;
                    p ? (this.itemIdsSentSuccessfully[p] || 0) > 5 && (this.reportError("[dupe] item ID sent too many times, not sending", {
                        item: u,
                        batchSize: s.length,
                        timesSent: this.itemIdsSentSuccessfully[p]
                    }), d = !1) : this.reportError("[dupe] found item with no ID", {
                        item: u
                    }), d && i.push(f)
                }
                o[u.id] = f
            }, this), i.length < 1) {
            this.resetFlush();
            return
        }
        this.requestInProgress = !0;
        var a = R.bind(function(u) {
                this.requestInProgress = !1;
                try {
                    var f = !1;
                    if (t.unloading) this.queue.updatePayloads(o);
                    else if (R.isObject(u) && u.error === "timeout" && new Date().getTime() - n >= e) this.reportError("Network timeout; retrying"), this.flush();
                    else if (R.isObject(u) && u.xhr_req && (u.xhr_req.status >= 500 || u.xhr_req.status === 429 || u.error === "timeout")) {
                        var d = this.flushInterval * 2,
                            p = u.xhr_req.responseHeaders;
                        if (p) {
                            var _ = p["Retry-After"];
                            _ && (d = parseInt(_, 10) * 1e3 || d)
                        }
                        d = Math.min(BB, d), this.reportError("Error; retry in " + d + " ms"), this.scheduleFlush(d)
                    } else if (R.isObject(u) && u.xhr_req && u.xhr_req.status === 413)
                        if (s.length > 1) {
                            var v = Math.max(1, Math.floor(r / 2));
                            this.batchSize = Math.min(this.batchSize, v, s.length - 1), this.reportError("413 response; reducing batch size to " + this.batchSize), this.resetFlush()
                        } else this.reportError("Single-event request too large; dropping", s), this.resetBatchSize(), f = !0;
                    else f = !0;
                    f && (this.queue.removeItemsByID(R.map(s, function(y) {
                        return y.id
                    }), R.bind(function(y) {
                        y ? (this.consecutiveRemovalFailures = 0, this.flush()) : (this.reportError("Failed to remove items from queue"), ++this.consecutiveRemovalFailures > 5 ? (this.reportError("Too many queue failures; disabling batching system."), this.stopAllBatching()) : this.resetFlush())
                    }, this)), R.each(s, R.bind(function(y) {
                        var g = y.id;
                        g ? (this.itemIdsSentSuccessfully[g] = this.itemIdsSentSuccessfully[g] || 0, this.itemIdsSentSuccessfully[g]++, this.itemIdsSentSuccessfully[g] > 5 && this.reportError("[dupe] item ID sent too many times", {
                            item: y,
                            batchSize: s.length,
                            timesSent: this.itemIdsSentSuccessfully[g]
                        })) : this.reportError("[dupe] found item with no ID while removing", {
                            item: y
                        })
                    }, this)))
                } catch (y) {
                    this.reportError("Error handling API response", y), this.resetFlush()
                }
            }, this),
            l = {
                method: "POST",
                verbose: !0,
                ignore_json_errors: !0,
                timeout_ms: e
            };
        t.unloading && (l.transport = "sendBeacon"), Sh.log("MIXPANEL REQUEST:", i), this.sendRequest(i, l, a)
    } catch (u) {
        this.reportError("Error flushing request queue", u), this.resetFlush()
    }
};
Li.prototype.reportError = function(t, e) {
    if (Sh.error.apply(Sh.error, arguments), this.errorReporter) try {
        e instanceof Error || (e = new Error(t)), this.errorReporter(t, e)
    } catch (n) {
        Sh.error(n)
    }
};
var qB = "__mp_opt_in_out_";

function GB(t, e) {
    L7(!0, t, e)
}

function VB(t, e) {
    L7(!1, t, e)
}

function jB(t, e) {
    return $7(t, e) === "1"
}

function D7(t, e) {
    if (HB(e)) return qt.warn('This browser has "Do Not Track" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the "Do Not Track" browser setting, initialize the Mixpanel instance with the config "ignore_dnt: true"'), !0;
    var n = $7(t, e) === "0";
    return n && qt.warn("You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data."), n
}

function Eu(t) {
    return O2(t, function(e) {
        return this.get_config(e)
    })
}

function wa(t) {
    return O2(t, function(e) {
        return this._get_config(e)
    })
}

function Tu(t) {
    return O2(t, function(e) {
        return this._get_config(e)
    })
}

function WB(t, e) {
    e = e || {}, w2(e).remove(A2(t, e), !!e.crossSubdomainCookie, e.cookieDomain)
}

function w2(t) {
    return t = t || {}, t.persistenceType === "localStorage" ? R.localStorage : R.cookie
}

function A2(t, e) {
    return e = e || {}, (e.persistencePrefix || qB) + t
}

function $7(t, e) {
    return w2(e).get(A2(t, e))
}

function HB(t) {
    if (t && t.ignoreDnt) return !1;
    var e = t && t.window || yn,
        n = e.navigator || {},
        r = !1;
    return R.each([n.doNotTrack, n.msDoNotTrack, e.doNotTrack], function(s) {
        R.includes([!0, 1, "1", "yes"], s) && (r = !0)
    }), r
}

function L7(t, e, n) {
    if (!R.isString(e) || !e.length) {
        qt.error("gdpr." + (t ? "optIn" : "optOut") + " called with an invalid token");
        return
    }
    n = n || {}, w2(n).set(A2(e, n), t ? 1 : 0, R.isNumber(n.cookieExpiration) ? n.cookieExpiration : null, !!n.crossSubdomainCookie, !!n.secureCookie, !!n.crossSiteCookie, n.cookieDomain), n.track && t && n.track(n.trackEventName || "$opt_in", n.trackProperties, {
        send_immediately: !0
    })
}

function O2(t, e) {
    return function() {
        var n = !1;
        try {
            var r = e.call(this, "token"),
                s = e.call(this, "ignore_dnt"),
                i = e.call(this, "opt_out_tracking_persistence_type"),
                o = e.call(this, "opt_out_tracking_cookie_prefix"),
                a = e.call(this, "window");
            r && (n = D7(r, {
                ignoreDnt: s,
                persistenceType: i,
                persistencePrefix: o,
                window: a
            }))
        } catch (u) {
            qt.error("Unexpected error when checking tracking opt-out status: " + u)
        }
        if (!n) return t.apply(this, arguments);
        var l = arguments[arguments.length - 1];
        typeof l == "function" && l(0)
    }
}
var ha = "$set",
    Yl = "$set_once",
    Bs = "$unset",
    Tc = "$add",
    Si = "$append",
    Sc = "$union",
    lo = "$remove",
    YB = "$delete",
    F7 = {
        set_action: function(t, e) {
            var n = {},
                r = {};
            return R.isObject(t) ? R.each(t, function(s, i) {
                this._is_reserved_property(i) || (r[i] = s)
            }, this) : r[t] = e, n[ha] = r, n
        },
        unset_action: function(t) {
            var e = {},
                n = [];
            return R.isArray(t) || (t = [t]), R.each(t, function(r) {
                this._is_reserved_property(r) || n.push(r)
            }, this), e[Bs] = n, e
        },
        set_once_action: function(t, e) {
            var n = {},
                r = {};
            return R.isObject(t) ? R.each(t, function(s, i) {
                this._is_reserved_property(i) || (r[i] = s)
            }, this) : r[t] = e, n[Yl] = r, n
        },
        union_action: function(t, e) {
            var n = {},
                r = {};
            return R.isObject(t) ? R.each(t, function(s, i) {
                this._is_reserved_property(i) || (r[i] = R.isArray(s) ? s : [s])
            }, this) : r[t] = R.isArray(e) ? e : [e], n[Sc] = r, n
        },
        append_action: function(t, e) {
            var n = {},
                r = {};
            return R.isObject(t) ? R.each(t, function(s, i) {
                this._is_reserved_property(i) || (r[i] = s)
            }, this) : r[t] = e, n[Si] = r, n
        },
        remove_action: function(t, e) {
            var n = {},
                r = {};
            return R.isObject(t) ? R.each(t, function(s, i) {
                this._is_reserved_property(i) || (r[i] = s)
            }, this) : r[t] = e, n[lo] = r, n
        },
        delete_action: function() {
            var t = {};
            return t[YB] = "", t
        }
    },
    an = function() {};
R.extend(an.prototype, F7);
an.prototype._init = function(t, e, n) {
    this._mixpanel = t, this._group_key = e, this._group_id = n
};
an.prototype.set = Tu(function(t, e, n) {
    var r = this.set_action(t, e);
    return R.isObject(t) && (n = e), this._send_request(r, n)
});
an.prototype.set_once = Tu(function(t, e, n) {
    var r = this.set_once_action(t, e);
    return R.isObject(t) && (n = e), this._send_request(r, n)
});
an.prototype.unset = Tu(function(t, e) {
    var n = this.unset_action(t);
    return this._send_request(n, e)
});
an.prototype.union = Tu(function(t, e, n) {
    R.isObject(t) && (n = e);
    var r = this.union_action(t, e);
    return this._send_request(r, n)
});
an.prototype.delete = Tu(function(t) {
    var e = this.delete_action();
    return this._send_request(e, t)
});
an.prototype.remove = Tu(function(t, e, n) {
    var r = this.remove_action(t, e);
    return this._send_request(r, n)
});
an.prototype._send_request = function(t, e) {
    t.$group_key = this._group_key, t.$group_id = this._group_id, t.$token = this._get_config("token");
    var n = R.encodeDates(t);
    return this._mixpanel._track_or_batch({
        type: "groups",
        data: n,
        endpoint: this._get_config("api_host") + "/" + this._get_config("api_routes").groups,
        batcher: this._mixpanel.request_batchers.groups
    }, e)
};
an.prototype._is_reserved_property = function(t) {
    return t === "$group_key" || t === "$group_id"
};
an.prototype._get_config = function(t) {
    return this._mixpanel.get_config(t)
};
an.prototype.toString = function() {
    return this._mixpanel.toString() + ".group." + this._group_key + "." + this._group_id
};
an.prototype.remove = an.prototype.remove;
an.prototype.set = an.prototype.set;
an.prototype.set_once = an.prototype.set_once;
an.prototype.union = an.prototype.union;
an.prototype.unset = an.prototype.unset;
an.prototype.toString = an.prototype.toString;
var dt = function() {};
R.extend(dt.prototype, F7);
dt.prototype._init = function(t) {
    this._mixpanel = t
};
dt.prototype.set = wa(function(t, e, n) {
    var r = this.set_action(t, e);
    return R.isObject(t) && (n = e), this._get_config("save_referrer") && this._mixpanel.persistence.update_referrer_info(document.referrer), r[ha] = R.extend({}, R.info.people_properties(), this._mixpanel.persistence.get_referrer_info(), r[ha]), this._send_request(r, n)
});
dt.prototype.set_once = wa(function(t, e, n) {
    var r = this.set_once_action(t, e);
    return R.isObject(t) && (n = e), this._send_request(r, n)
});
dt.prototype.unset = wa(function(t, e) {
    var n = this.unset_action(t);
    return this._send_request(n, e)
});
dt.prototype.increment = wa(function(t, e, n) {
    var r = {},
        s = {};
    return R.isObject(t) ? (R.each(t, function(i, o) {
        if (!this._is_reserved_property(o))
            if (isNaN(parseFloat(i))) {
                qt.error("Invalid increment value passed to mixpanel.people.increment - must be a number");
                return
            } else s[o] = i
    }, this), n = e) : (R.isUndefined(e) && (e = 1), s[t] = e), r[Tc] = s, this._send_request(r, n)
});
dt.prototype.append = wa(function(t, e, n) {
    R.isObject(t) && (n = e);
    var r = this.append_action(t, e);
    return this._send_request(r, n)
});
dt.prototype.remove = wa(function(t, e, n) {
    R.isObject(t) && (n = e);
    var r = this.remove_action(t, e);
    return this._send_request(r, n)
});
dt.prototype.union = wa(function(t, e, n) {
    R.isObject(t) && (n = e);
    var r = this.union_action(t, e);
    return this._send_request(r, n)
});
dt.prototype.track_charge = wa(function(t, e, n) {
    if (!R.isNumber(t) && (t = parseFloat(t), isNaN(t))) {
        qt.error("Invalid value passed to mixpanel.people.track_charge - must be a number");
        return
    }
    return this.append("$transactions", R.extend({
        $amount: t
    }, e), n)
});
dt.prototype.clear_charges = function(t) {
    return this.set("$transactions", [], t)
};
dt.prototype.delete_user = function() {
    if (!this._identify_called()) {
        qt.error("mixpanel.people.delete_user() requires you to call identify() first");
        return
    }
    var t = {
        $delete: this._mixpanel.get_distinct_id()
    };
    return this._send_request(t)
};
dt.prototype.toString = function() {
    return this._mixpanel.toString() + ".people"
};
dt.prototype._send_request = function(t, e) {
    t.$token = this._get_config("token"), t.$distinct_id = this._mixpanel.get_distinct_id();
    var n = this._mixpanel.get_property("$device_id"),
        r = this._mixpanel.get_property("$user_id"),
        s = this._mixpanel.get_property("$had_persisted_distinct_id");
    n && (t.$device_id = n), r && (t.$user_id = r), s && (t.$had_persisted_distinct_id = s);
    var i = R.encodeDates(t);
    return this._identify_called() ? this._mixpanel._track_or_batch({
        type: "people",
        data: i,
        endpoint: this._get_config("api_host") + "/" + this._get_config("api_routes").engage,
        batcher: this._mixpanel.request_batchers.people
    }, e) : (this._enqueue(t), R.isUndefined(e) || (this._get_config("verbose") ? e({
        status: -1,
        error: null
    }) : e(-1)), R.truncate(i, 255))
};
dt.prototype._get_config = function(t) {
    return this._mixpanel.get_config(t)
};
dt.prototype._identify_called = function() {
    return this._mixpanel._flags.identify_called === !0
};
dt.prototype._enqueue = function(t) {
    ha in t ? this._mixpanel.persistence._add_to_people_queue(ha, t) : Yl in t ? this._mixpanel.persistence._add_to_people_queue(Yl, t) : Bs in t ? this._mixpanel.persistence._add_to_people_queue(Bs, t) : Tc in t ? this._mixpanel.persistence._add_to_people_queue(Tc, t) : Si in t ? this._mixpanel.persistence._add_to_people_queue(Si, t) : lo in t ? this._mixpanel.persistence._add_to_people_queue(lo, t) : Sc in t ? this._mixpanel.persistence._add_to_people_queue(Sc, t) : qt.error("Invalid call to _enqueue():", t)
};
dt.prototype._flush_one_queue = function(t, e, n, r) {
    var s = this,
        i = R.extend({}, this._mixpanel.persistence.load_queue(t)),
        o = i;
    !R.isUndefined(i) && R.isObject(i) && !R.isEmptyObject(i) && (s._mixpanel.persistence._pop_from_people_queue(t, i), s._mixpanel.persistence.save(), r && (o = r(i)), e.call(s, o, function(a, l) {
        a === 0 && s._mixpanel.persistence._add_to_people_queue(t, i), R.isUndefined(n) || n(a, l)
    }))
};
dt.prototype._flush = function(t, e, n, r, s, i, o) {
    var a = this;
    this._flush_one_queue(ha, this.set, t), this._flush_one_queue(Yl, this.set_once, r), this._flush_one_queue(Bs, this.unset, i, function(g) {
        return R.keys(g)
    }), this._flush_one_queue(Tc, this.increment, e), this._flush_one_queue(Sc, this.union, s);
    var l = this._mixpanel.persistence.load_queue(Si);
    if (!R.isUndefined(l) && R.isArray(l) && l.length)
        for (var u, f = function(g, b) {
                g === 0 && a._mixpanel.persistence._add_to_people_queue(Si, u), R.isUndefined(n) || n(g, b)
            }, d = l.length - 1; d >= 0; d--) l = this._mixpanel.persistence.load_queue(Si), u = l.pop(), a._mixpanel.persistence.save(), R.isEmptyObject(u) || a.append(u, f);
    var p = this._mixpanel.persistence.load_queue(lo);
    if (!R.isUndefined(p) && R.isArray(p) && p.length)
        for (var _, v = function(g, b) {
                g === 0 && a._mixpanel.persistence._add_to_people_queue(lo, _), R.isUndefined(o) || o(g, b)
            }, y = p.length - 1; y >= 0; y--) p = this._mixpanel.persistence.load_queue(lo), _ = p.pop(), a._mixpanel.persistence.save(), R.isEmptyObject(_) || a.remove(_, v)
};
dt.prototype._is_reserved_property = function(t) {
    return t === "$distinct_id" || t === "$token" || t === "$device_id" || t === "$user_id" || t === "$had_persisted_distinct_id"
};
dt.prototype.set = dt.prototype.set;
dt.prototype.set_once = dt.prototype.set_once;
dt.prototype.unset = dt.prototype.unset;
dt.prototype.increment = dt.prototype.increment;
dt.prototype.append = dt.prototype.append;
dt.prototype.remove = dt.prototype.remove;
dt.prototype.union = dt.prototype.union;
dt.prototype.track_charge = dt.prototype.track_charge;
dt.prototype.clear_charges = dt.prototype.clear_charges;
dt.prototype.delete_user = dt.prototype.delete_user;
dt.prototype.toString = dt.prototype.toString;
var C2 = "__mps",
    k2 = "__mpso",
    I2 = "__mpus",
    N2 = "__mpa",
    x2 = "__mpap",
    P2 = "__mpr",
    R2 = "__mpu",
    U7 = "$people_distinct_id",
    i1 = "__alias",
    Kh = "__timers",
    zB = [C2, k2, I2, N2, x2, P2, R2, U7, i1, Kh],
    Et = function(t) {
        this.props = {}, this.campaign_params_saved = !1, t.persistence_name ? this.name = "mp_" + t.persistence_name : this.name = "mp_" + t.token + "_mixpanel";
        var e = t.persistence;
        e !== "cookie" && e !== "localStorage" && (qt.critical("Unknown persistence type " + e + "; falling back to cookie"), e = t.persistence = "cookie"), e === "localStorage" && R.localStorage.is_supported() ? this.storage = R.localStorage : this.storage = R.cookie, this.load(), this.update_config(t), this.upgrade(t), this.save()
    };
Et.prototype.properties = function() {
    var t = {};
    return this.load(), R.each(this.props, function(e, n) {
        R.include(zB, n) || (t[n] = e)
    }), t
};
Et.prototype.load = function() {
    if (!this.disabled) {
        var t = this.storage.parse(this.name);
        t && (this.props = R.extend({}, t))
    }
};
Et.prototype.upgrade = function(t) {
    var e = t.upgrade,
        n, r;
    e && (n = "mp_super_properties", typeof e == "string" && (n = e), r = this.storage.parse(n), this.storage.remove(n), this.storage.remove(n, !0), r && (this.props = R.extend(this.props, r.all, r.events))), !t.cookie_name && t.name !== "mixpanel" && (n = "mp_" + t.token + "_" + t.name, r = this.storage.parse(n), r && (this.storage.remove(n), this.storage.remove(n, !0), this.register_once(r))), this.storage === R.localStorage && (r = R.cookie.parse(this.name), R.cookie.remove(this.name), R.cookie.remove(this.name, !0), r && this.register_once(r))
};
Et.prototype.save = function() {
    this.disabled || this.storage.set(this.name, R.JSONEncode(this.props), this.expire_days, this.cross_subdomain, this.secure, this.cross_site, this.cookie_domain)
};
Et.prototype.load_prop = function(t) {
    return this.load(), this.props[t]
};
Et.prototype.remove = function() {
    this.storage.remove(this.name, !1, this.cookie_domain), this.storage.remove(this.name, !0, this.cookie_domain)
};
Et.prototype.clear = function() {
    this.remove(), this.props = {}
};
Et.prototype.register_once = function(t, e, n) {
    return R.isObject(t) ? (typeof e > "u" && (e = "None"), this.expire_days = typeof n > "u" ? this.default_expiry : n, this.load(), R.each(t, function(r, s) {
        (!this.props.hasOwnProperty(s) || this.props[s] === e) && (this.props[s] = r)
    }, this), this.save(), !0) : !1
};
Et.prototype.register = function(t, e) {
    return R.isObject(t) ? (this.expire_days = typeof e > "u" ? this.default_expiry : e, this.load(), R.extend(this.props, t), this.save(), !0) : !1
};
Et.prototype.unregister = function(t) {
    this.load(), t in this.props && (delete this.props[t], this.save())
};
Et.prototype.update_search_keyword = function(t) {
    this.register(R.info.searchInfo(t))
};
Et.prototype.update_referrer_info = function(t) {
    this.register_once({
        $initial_referrer: t || "$direct",
        $initial_referring_domain: R.info.referringDomain(t) || "$direct"
    }, "")
};
Et.prototype.get_referrer_info = function() {
    return R.strip_empty_properties({
        $initial_referrer: this.props.$initial_referrer,
        $initial_referring_domain: this.props.$initial_referring_domain
    })
};
Et.prototype.update_config = function(t) {
    this.default_expiry = this.expire_days = t.cookie_expiration, this.set_disabled(t.disable_persistence), this.set_cookie_domain(t.cookie_domain), this.set_cross_site(t.cross_site_cookie), this.set_cross_subdomain(t.cross_subdomain_cookie), this.set_secure(t.secure_cookie)
};
Et.prototype.set_disabled = function(t) {
    this.disabled = t, this.disabled ? this.remove() : this.save()
};
Et.prototype.set_cookie_domain = function(t) {
    t !== this.cookie_domain && (this.remove(), this.cookie_domain = t, this.save())
};
Et.prototype.set_cross_site = function(t) {
    t !== this.cross_site && (this.cross_site = t, this.remove(), this.save())
};
Et.prototype.set_cross_subdomain = function(t) {
    t !== this.cross_subdomain && (this.cross_subdomain = t, this.remove(), this.save())
};
Et.prototype.get_cross_subdomain = function() {
    return this.cross_subdomain
};
Et.prototype.set_secure = function(t) {
    t !== this.secure && (this.secure = !!t, this.remove(), this.save())
};
Et.prototype._add_to_people_queue = function(t, e) {
    var n = this._get_queue_key(t),
        r = e[t],
        s = this._get_or_create_queue(ha),
        i = this._get_or_create_queue(Yl),
        o = this._get_or_create_queue(Bs),
        a = this._get_or_create_queue(Tc),
        l = this._get_or_create_queue(Sc),
        u = this._get_or_create_queue(lo, []),
        f = this._get_or_create_queue(Si, []);
    n === C2 ? (R.extend(s, r), this._pop_from_people_queue(Tc, r), this._pop_from_people_queue(Sc, r), this._pop_from_people_queue(Bs, r)) : n === k2 ? (R.each(r, function(d, p) {
        p in i || (i[p] = d)
    }), this._pop_from_people_queue(Bs, r)) : n === I2 ? R.each(r, function(d) {
        R.each([s, i, a, l], function(p) {
            d in p && delete p[d]
        }), R.each(f, function(p) {
            d in p && delete p[d]
        }), o[d] = !0
    }) : n === N2 ? (R.each(r, function(d, p) {
        p in s ? s[p] += d : (p in a || (a[p] = 0), a[p] += d)
    }, this), this._pop_from_people_queue(Bs, r)) : n === R2 ? (R.each(r, function(d, p) {
        R.isArray(d) && (p in l || (l[p] = []), l[p] = l[p].concat(d))
    }), this._pop_from_people_queue(Bs, r)) : n === P2 ? (u.push(r), this._pop_from_people_queue(Si, r)) : n === x2 && (f.push(r), this._pop_from_people_queue(Bs, r)), qt.log("MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):"), qt.log(e), this.save()
};
Et.prototype._pop_from_people_queue = function(t, e) {
    var n = this.props[this._get_queue_key(t)];
    R.isUndefined(n) || R.each(e, function(r, s) {
        t === Si || t === lo ? R.each(n, function(i) {
            i[s] === r && delete i[s]
        }) : delete n[s]
    }, this)
};
Et.prototype.load_queue = function(t) {
    return this.load_prop(this._get_queue_key(t))
};
Et.prototype._get_queue_key = function(t) {
    if (t === ha) return C2;
    if (t === Yl) return k2;
    if (t === Bs) return I2;
    if (t === Tc) return N2;
    if (t === Si) return x2;
    if (t === lo) return P2;
    if (t === Sc) return R2;
    qt.error("Invalid queue:", t)
};
Et.prototype._get_or_create_queue = function(t, e) {
    var n = this._get_queue_key(t);
    return e = R.isUndefined(e) ? {} : e, this.props[n] || (this.props[n] = e)
};
Et.prototype.set_event_timer = function(t, e) {
    var n = this.load_prop(Kh) || {};
    n[t] = e, this.props[Kh] = n, this.save()
};
Et.prototype.remove_event_timer = function(t) {
    var e = this.load_prop(Kh) || {},
        n = e[t];
    return R.isUndefined(n) || (delete this.props[Kh][t], this.save()), n
};
var M2, cr, B7 = 0,
    KB = 1,
    ZB = function(t) {
        return t
    },
    Zh = function() {},
    Ts = "mixpanel",
    q7 = "base64",
    XB = "json",
    D2 = "$device:",
    Cl = yn.XMLHttpRequest && "withCredentials" in new XMLHttpRequest,
    G7 = !Cl && vi.indexOf("MSIE") === -1 && vi.indexOf("Mozilla") === -1,
    o1 = null;
Yo.sendBeacon && (o1 = function() {
    return Yo.sendBeacon.apply(Yo, arguments)
});
var V7 = {
        track: "track/",
        engage: "engage/",
        groups: "groups/"
    },
    NT = {
        api_host: "https://api-js.mixpanel.com",
        api_routes: V7,
        api_method: "POST",
        api_transport: "XHR",
        api_payload_format: q7,
        app_host: "https://mixpanel.com",
        cdn: "https://cdn.mxpnl.com",
        cross_site_cookie: !1,
        cross_subdomain_cookie: !0,
        error_reporter: Zh,
        persistence: "cookie",
        persistence_name: "",
        cookie_domain: "",
        cookie_name: "",
        loaded: Zh,
        track_marketing: !0,
        track_pageview: !1,
        skip_first_touch_marketing: !1,
        store_google: !0,
        save_referrer: !0,
        test: !1,
        verbose: !1,
        img: !1,
        debug: !1,
        track_links_timeout: 300,
        cookie_expiration: 365,
        upgrade: !1,
        disable_persistence: !1,
        disable_cookie: !1,
        secure_cookie: !1,
        ip: !0,
        opt_out_tracking_by_default: !1,
        opt_out_persistence_by_default: !1,
        opt_out_tracking_persistence_type: "localStorage",
        opt_out_tracking_cookie_prefix: null,
        property_blacklist: [],
        xhr_headers: {},
        ignore_dnt: !1,
        batch_requests: !0,
        batch_size: 50,
        batch_flush_interval_ms: 5e3,
        batch_request_timeout_ms: 9e4,
        batch_autostart: !0,
        hooks: {}
    },
    j7 = !1,
    Se = function() {},
    A0 = function(t, e, n) {
        var r, s = n === Ts ? cr : cr[n];
        if (s && M2 === B7) r = s;
        else {
            if (s && !R.isArray(s)) {
                qt.error("You have already initialized " + n);
                return
            }
            r = new Se
        }
        if (r._cached_groups = {}, r._init(t, e, n), r.people = new dt, r.people._init(r), !r.get_config("skip_first_touch_marketing")) {
            var i = R.info.campaignParams(null),
                o = {},
                a = !1;
            R.each(i, function(l, u) {
                o["initial_" + u] = l, l && (a = !0)
            }), a && r.people.set_once(o)
        }
        return co.DEBUG = co.DEBUG || r.get_config("debug"), !R.isUndefined(s) && R.isArray(s) && (r._execute_array.call(r.people, s.people), r._execute_array(s)), r
    };
Se.prototype.init = function(t, e, n) {
    if (R.isUndefined(n)) {
        this.report_error("You must name your new library: init(token, config, name)");
        return
    }
    if (n === Ts) {
        this.report_error("You must initialize the main mixpanel object right after you include the Mixpanel js snippet");
        return
    }
    var r = A0(t, e, n);
    return cr[n] = r, r._loaded(), r
};
Se.prototype._init = function(t, e, n) {
    e = e || {}, this.__loaded = !0, this.config = {};
    var r = {};
    if (!("api_payload_format" in e)) {
        var s = e.api_host || NT.api_host;
        s.match(/\.mixpanel\.com/) && (r.api_payload_format = XB)
    }
    if (this.set_config(R.extend({}, NT, r, e, {
            name: n,
            token: t,
            callback_fn: (n === Ts ? n : Ts + "." + n) + "._jsc"
        })), this._jsc = Zh, this.__dom_loaded_queue = [], this.__request_queue = [], this.__disabled_events = [], this._flags = {
            disable_all_events: !1,
            identify_called: !1
        }, this.request_batchers = {}, this._batch_requests = this.get_config("batch_requests"), this._batch_requests) {
        if (!R.localStorage.is_supported(!0) || !Cl) this._batch_requests = !1, qt.log("Turning off Mixpanel request-queueing; needs XHR and localStorage support"), R.each(this.get_batcher_configs(), function(a) {
            qt.log("Clearing batch queue " + a.queue_key), R.localStorage.remove(a.queue_key)
        });
        else if (this.init_batchers(), o1 && yn.addEventListener) {
            var i = R.bind(function() {
                this.request_batchers.events.stopped || this.request_batchers.events.flush({
                    unloading: !0
                })
            }, this);
            yn.addEventListener("pagehide", function(a) {
                a.persisted && i()
            }), yn.addEventListener("visibilitychange", function() {
                Yt.visibilityState === "hidden" && i()
            })
        }
    }
    this.persistence = this.cookie = new Et(this.config), this.unpersisted_superprops = {}, this._gdpr_init();
    var o = R.UUID();
    this.get_distinct_id() || this.register_once({
        distinct_id: D2 + o,
        $device_id: o
    }, ""), this.get_config("track_pageview") && this.track_pageview()
};
Se.prototype._loaded = function() {
    this.get_config("loaded")(this), this._set_default_superprops()
};
Se.prototype._set_default_superprops = function() {
    this.persistence.update_search_keyword(Yt.referrer), this.get_config("store_google") && this.register(R.info.campaignParams()), this.get_config("save_referrer") && this.persistence.update_referrer_info(Yt.referrer)
};
Se.prototype._dom_loaded = function() {
    R.each(this.__dom_loaded_queue, function(t) {
        this._track_dom.apply(this, t)
    }, this), this.has_opted_out_tracking() || R.each(this.__request_queue, function(t) {
        this._send_request.apply(this, t)
    }, this), delete this.__dom_loaded_queue, delete this.__request_queue
};
Se.prototype._track_dom = function(t, e) {
    if (this.get_config("img")) return this.report_error("You can't use DOM tracking functions with img = true."), !1;
    if (!j7) return this.__dom_loaded_queue.push([t, e]), !1;
    var n = new t().init(this);
    return n.track.apply(n, e)
};
Se.prototype._prepare_callback = function(t, e) {
    if (R.isUndefined(t)) return null;
    if (Cl) {
        var n = function(o) {
            t(o, e)
        };
        return n
    } else {
        var r = this._jsc,
            s = "" + Math.floor(Math.random() * 1e8),
            i = this.get_config("callback_fn") + "[" + s + "]";
        return r[s] = function(o) {
            delete r[s], t(o, e)
        }, i
    }
};
Se.prototype._send_request = function(t, e, n, r) {
    var s = !0;
    if (G7) return this.__request_queue.push(arguments), s;
    var i = {
            method: this.get_config("api_method"),
            transport: this.get_config("api_transport"),
            verbose: this.get_config("verbose")
        },
        o = null;
    !r && (R.isFunction(n) || typeof n == "string") && (r = n, n = null), n = R.extend(i, n || {}), Cl || (n.method = "GET");
    var a = n.method === "POST",
        l = o1 && a && n.transport.toLowerCase() === "sendbeacon",
        u = n.verbose;
    e.verbose && (u = !0), this.get_config("test") && (e.test = 1), u && (e.verbose = 1), this.get_config("img") && (e.img = 1), Cl || (r ? e.callback = r : (u || this.get_config("test")) && (e.callback = "(function(){})")), e.ip = this.get_config("ip") ? 1 : 0, e._ = new Date().getTime().toString(), a && (o = "data=" + encodeURIComponent(e.data), delete e.data), t += "?" + R.HTTPBuildQuery(e);
    var f = this;
    if ("img" in e) {
        var d = Yt.createElement("img");
        d.src = t, Yt.body.appendChild(d)
    } else if (l) {
        try {
            s = o1(t, o)
        } catch (b) {
            f.report_error(b), s = !1
        }
        try {
            r && r(s ? 1 : 0)
        } catch (b) {
            f.report_error(b)
        }
    } else if (Cl) try {
        var p = new XMLHttpRequest;
        p.open(n.method, t, !0);
        var _ = this.get_config("xhr_headers");
        if (a && (_["Content-Type"] = "application/x-www-form-urlencoded"), R.each(_, function(b, O) {
                p.setRequestHeader(O, b)
            }), n.timeout_ms && typeof p.timeout < "u") {
            p.timeout = n.timeout_ms;
            var v = new Date().getTime()
        }
        p.withCredentials = !0, p.onreadystatechange = function() {
            if (p.readyState === 4)
                if (p.status === 200) {
                    if (r)
                        if (u) {
                            var b;
                            try {
                                b = R.JSONDecode(p.responseText)
                            } catch (N) {
                                if (f.report_error(N), n.ignore_json_errors) b = p.responseText;
                                else return
                            }
                            r(b)
                        } else r(Number(p.responseText))
                } else {
                    var O;
                    p.timeout && !p.status && new Date().getTime() - v >= p.timeout ? O = "timeout" : O = "Bad HTTP status: " + p.status + " " + p.statusText, f.report_error(O), r && r(u ? {
                        status: 0,
                        error: O,
                        xhr_req: p
                    } : 0)
                }
        }, p.send(o)
    } catch (b) {
        f.report_error(b), s = !1
    } else {
        var y = Yt.createElement("script");
        y.type = "text/javascript", y.async = !0, y.defer = !0, y.src = t;
        var g = Yt.getElementsByTagName("script")[0];
        g.parentNode.insertBefore(y, g)
    }
    return s
};
Se.prototype._execute_array = function(t) {
    var e, n = [],
        r = [],
        s = [];
    R.each(t, function(o) {
        o && (e = o[0], R.isArray(e) ? s.push(o) : typeof o == "function" ? o.call(this) : R.isArray(o) && e === "alias" ? n.push(o) : R.isArray(o) && e.indexOf("track") !== -1 && typeof this[e] == "function" ? s.push(o) : r.push(o))
    }, this);
    var i = function(o, a) {
        R.each(o, function(l) {
            if (R.isArray(l[0])) {
                var u = a;
                R.each(l, function(f) {
                    u = u[f[0]].apply(u, f.slice(1))
                })
            } else this[l[0]].apply(this, l.slice(1))
        }, a)
    };
    i(n, this), i(r, this), i(s, this)
};
Se.prototype.are_batchers_initialized = function() {
    return !!this.request_batchers.events
};
Se.prototype.get_batcher_configs = function() {
    var t = "__mpq_" + this.get_config("token"),
        e = this.get_config("api_routes");
    return this._batcher_configs = this._batcher_configs || {
        events: {
            type: "events",
            endpoint: "/" + e.track,
            queue_key: t + "_ev"
        },
        people: {
            type: "people",
            endpoint: "/" + e.engage,
            queue_key: t + "_pp"
        },
        groups: {
            type: "groups",
            endpoint: "/" + e.groups,
            queue_key: t + "_gr"
        }
    }, this._batcher_configs
};
Se.prototype.init_batchers = function() {
    if (!this.are_batchers_initialized()) {
        var t = R.bind(function(n) {
                return new Li(n.queue_key, {
                    libConfig: this.config,
                    sendRequestFunc: R.bind(function(r, s, i) {
                        this._send_request(this.get_config("api_host") + n.endpoint, this._encode_data_for_request(r), s, this._prepare_callback(i, r))
                    }, this),
                    beforeSendHook: R.bind(function(r) {
                        return this._run_hook("before_send_" + n.type, r)
                    }, this),
                    errorReporter: this.get_config("error_reporter"),
                    stopAllBatchingFunc: R.bind(this.stop_batch_senders, this)
                })
            }, this),
            e = this.get_batcher_configs();
        this.request_batchers = {
            events: t(e.events),
            people: t(e.people),
            groups: t(e.groups)
        }
    }
    this.get_config("batch_autostart") && this.start_batch_senders()
};
Se.prototype.start_batch_senders = function() {
    this._batchers_were_started = !0, this.are_batchers_initialized() && (this._batch_requests = !0, R.each(this.request_batchers, function(t) {
        t.start()
    }))
};
Se.prototype.stop_batch_senders = function() {
    this._batch_requests = !1, R.each(this.request_batchers, function(t) {
        t.stop(), t.clear()
    })
};
Se.prototype.push = function(t) {
    this._execute_array([t])
};
Se.prototype.disable = function(t) {
    typeof t > "u" ? this._flags.disable_all_events = !0 : this.__disabled_events = this.__disabled_events.concat(t)
};
Se.prototype._encode_data_for_request = function(t) {
    var e = R.JSONEncode(t);
    return this.get_config("api_payload_format") === q7 && (e = R.base64Encode(e)), {
        data: e
    }
};
Se.prototype._track_or_batch = function(t, e) {
    var n = R.truncate(t.data, 255),
        r = t.endpoint,
        s = t.batcher,
        i = t.should_send_immediately,
        o = t.send_request_options || {};
    e = e || Zh;
    var a = !0,
        l = R.bind(function() {
            return o.skip_hooks || (n = this._run_hook("before_send_" + t.type, n)), n ? (qt.log("MIXPANEL REQUEST:"), qt.log(n), this._send_request(r, this._encode_data_for_request(n), o, this._prepare_callback(e, n))) : null
        }, this);
    return this._batch_requests && !i ? s.enqueue(n, function(u) {
        u ? e(1, n) : l()
    }) : a = l(), a && n
};
Se.prototype.track = Eu(function(t, e, n, r) {
    !r && typeof n == "function" && (r = n, n = null), n = n || {};
    var s = n.transport;
    s && (n.transport = s);
    var i = n.send_immediately;
    if (typeof r != "function" && (r = Zh), R.isUndefined(t)) {
        this.report_error("No event name provided to mixpanel.track");
        return
    }
    if (this._event_is_disabled(t)) {
        r(0);
        return
    }
    e = R.extend({}, e), e.token = this.get_config("token");
    var o = this.persistence.remove_event_timer(t);
    if (!R.isUndefined(o)) {
        var a = new Date().getTime() - o;
        e.$duration = parseFloat((a / 1e3).toFixed(3))
    }
    this._set_default_superprops();
    var l = this.get_config("track_marketing") ? R.info.marketingParams() : {};
    e = R.extend({}, R.info.properties(), l, this.persistence.properties(), this.unpersisted_superprops, e);
    var u = this.get_config("property_blacklist");
    R.isArray(u) ? R.each(u, function(p) {
        delete e[p]
    }) : this.report_error("Invalid value for property_blacklist config: " + u);
    var f = {
            event: t,
            properties: e
        },
        d = this._track_or_batch({
            type: "events",
            data: f,
            endpoint: this.get_config("api_host") + "/" + this.get_config("api_routes").track,
            batcher: this.request_batchers.events,
            should_send_immediately: i,
            send_request_options: n
        }, r);
    return d
});
Se.prototype.set_group = Eu(function(t, e, n) {
    R.isArray(e) || (e = [e]);
    var r = {};
    return r[t] = e, this.register(r), this.people.set(t, e, n)
});
Se.prototype.add_group = Eu(function(t, e, n) {
    var r = this.get_property(t),
        s = {};
    return r === void 0 ? (s[t] = [e], this.register(s)) : r.indexOf(e) === -1 && (r.push(e), s[t] = r, this.register(s)), this.people.union(t, e, n)
});
Se.prototype.remove_group = Eu(function(t, e, n) {
    var r = this.get_property(t);
    if (r !== void 0) {
        var s = r.indexOf(e);
        s > -1 && (r.splice(s, 1), this.register({
            group_key: r
        })), r.length === 0 && this.unregister(t)
    }
    return this.people.remove(t, e, n)
});
Se.prototype.track_with_groups = Eu(function(t, e, n, r) {
    var s = R.extend({}, e || {});
    return R.each(n, function(i, o) {
        i != null && (s[o] = i)
    }), this.track(t, s, r)
});
Se.prototype._create_map_key = function(t, e) {
    return t + "_" + JSON.stringify(e)
};
Se.prototype._remove_group_from_cache = function(t, e) {
    delete this._cached_groups[this._create_map_key(t, e)]
};
Se.prototype.get_group = function(t, e) {
    var n = this._create_map_key(t, e),
        r = this._cached_groups[n];
    return (r === void 0 || r._group_key !== t || r._group_id !== e) && (r = new an, r._init(this, t, e), this._cached_groups[n] = r), r
};
Se.prototype.track_pageview = Eu(function(t, e) {
    typeof t != "object" && (t = {}), e = e || {};
    var n = e.event_name || "$mp_web_page_view",
        r = R.extend(R.info.mpPageViewProperties(), R.info.campaignParams(), R.info.clickParams()),
        s = R.extend({}, r, t);
    return this.track(n, s)
});
Se.prototype.track_links = function() {
    return this._track_dom.call(this, Hl, arguments)
};
Se.prototype.track_forms = function() {
    return this._track_dom.call(this, Vm, arguments)
};
Se.prototype.time_event = function(t) {
    if (R.isUndefined(t)) {
        this.report_error("No event name provided to mixpanel.time_event");
        return
    }
    this._event_is_disabled(t) || this.persistence.set_event_timer(t, new Date().getTime())
};
var QB = {
        persistent: !0
    },
    $2 = function(t) {
        var e;
        return R.isObject(t) ? e = t : R.isUndefined(t) ? e = {} : e = {
            days: t
        }, R.extend({}, QB, e)
    };
Se.prototype.register = function(t, e) {
    var n = $2(e);
    n.persistent ? this.persistence.register(t, n.days) : R.extend(this.unpersisted_superprops, t)
};
Se.prototype.register_once = function(t, e, n) {
    var r = $2(n);
    r.persistent ? this.persistence.register_once(t, e, r.days) : (typeof e > "u" && (e = "None"), R.each(t, function(s, i) {
        (!this.unpersisted_superprops.hasOwnProperty(i) || this.unpersisted_superprops[i] === e) && (this.unpersisted_superprops[i] = s)
    }, this))
};
Se.prototype.unregister = function(t, e) {
    e = $2(e), e.persistent ? this.persistence.unregister(t) : delete this.unpersisted_superprops[t]
};
Se.prototype._register_single = function(t, e) {
    var n = {};
    n[t] = e, this.register(n)
};
Se.prototype.identify = function(t, e, n, r, s, i, o, a) {
    var l = this.get_distinct_id();
    if (t && l !== t) {
        if (typeof t == "string" && t.indexOf(D2) === 0) return this.report_error("distinct_id cannot have $device: prefix"), -1;
        this.register({
            $user_id: t
        })
    }
    if (!this.get_property("$device_id")) {
        var u = l;
        this.register_once({
            $had_persisted_distinct_id: !0,
            $device_id: u
        }, "")
    }
    t !== l && t !== this.get_property(i1) && (this.unregister(i1), this.register({
        distinct_id: t
    })), this._flags.identify_called = !0, this.people._flush(e, n, r, s, i, o, a), t !== l && this.track("$identify", {
        distinct_id: t,
        $anon_distinct_id: l
    }, {
        skip_hooks: !0
    })
};
Se.prototype.reset = function() {
    this.persistence.clear(), this._flags.identify_called = !1;
    var t = R.UUID();
    this.register_once({
        distinct_id: D2 + t,
        $device_id: t
    }, "")
};
Se.prototype.get_distinct_id = function() {
    return this.get_property("distinct_id")
};
Se.prototype.alias = function(t, e) {
    if (t === this.get_property(U7)) return this.report_error("Attempting to create alias for existing People user - aborting."), -2;
    var n = this;
    return R.isUndefined(e) && (e = this.get_distinct_id()), t !== e ? (this._register_single(i1, t), this.track("$create_alias", {
        alias: t,
        distinct_id: e
    }, {
        skip_hooks: !0
    }, function() {
        n.identify(t)
    })) : (this.report_error("alias matches current distinct_id - skipping api call."), this.identify(t), -1)
};
Se.prototype.name_tag = function(t) {
    this._register_single("mp_name_tag", t)
};
Se.prototype.set_config = function(t) {
    if (R.isObject(t)) {
        R.extend(this.config, t);
        var e = t.batch_size;
        e && R.each(this.request_batchers, function(n) {
            n.resetBatchSize()
        }), this.get_config("persistence_name") || (this.config.persistence_name = this.config.cookie_name), this.get_config("disable_persistence") || (this.config.disable_persistence = this.config.disable_cookie), this.persistence && this.persistence.update_config(this.config), co.DEBUG = co.DEBUG || this.get_config("debug")
    }
};
Se.prototype.get_config = function(t) {
    return this.config[t]
};
Se.prototype._run_hook = function(t) {
    var e = (this.config.hooks[t] || ZB).apply(this, Ho.call(arguments, 1));
    return typeof e > "u" && (this.report_error(t + " hook did not return a value"), e = null), e
};
Se.prototype.get_property = function(t) {
    return this.persistence.load_prop([t])
};
Se.prototype.toString = function() {
    var t = this.get_config("name");
    return t !== Ts && (t = Ts + "." + t), t
};
Se.prototype._event_is_disabled = function(t) {
    return R.isBlockedUA(vi) || this._flags.disable_all_events || R.include(this.__disabled_events, t)
};
Se.prototype._gdpr_init = function() {
    var t = this.get_config("opt_out_tracking_persistence_type") === "localStorage";
    t && R.localStorage.is_supported() && (!this.has_opted_in_tracking() && this.has_opted_in_tracking({
        persistence_type: "cookie"
    }) && this.opt_in_tracking({
        enable_persistence: !1
    }), !this.has_opted_out_tracking() && this.has_opted_out_tracking({
        persistence_type: "cookie"
    }) && this.opt_out_tracking({
        clear_persistence: !1
    }), this.clear_opt_in_out_tracking({
        persistence_type: "cookie",
        enable_persistence: !1
    })), this.has_opted_out_tracking() ? this._gdpr_update_persistence({
        clear_persistence: !0
    }) : !this.has_opted_in_tracking() && (this.get_config("opt_out_tracking_by_default") || R.cookie.get("mp_optout")) && (R.cookie.remove("mp_optout"), this.opt_out_tracking({
        clear_persistence: this.get_config("opt_out_persistence_by_default")
    }))
};
Se.prototype._gdpr_update_persistence = function(t) {
    var e;
    if (t && t.clear_persistence) e = !0;
    else if (t && t.enable_persistence) e = !1;
    else return;
    !this.get_config("disable_persistence") && this.persistence.disabled !== e && this.persistence.set_disabled(e), e ? this.stop_batch_senders() : this._batchers_were_started && this.start_batch_senders()
};
Se.prototype._gdpr_call_func = function(t, e) {
    return e = R.extend({
        track: R.bind(this.track, this),
        persistence_type: this.get_config("opt_out_tracking_persistence_type"),
        cookie_prefix: this.get_config("opt_out_tracking_cookie_prefix"),
        cookie_expiration: this.get_config("cookie_expiration"),
        cross_site_cookie: this.get_config("cross_site_cookie"),
        cross_subdomain_cookie: this.get_config("cross_subdomain_cookie"),
        cookie_domain: this.get_config("cookie_domain"),
        secure_cookie: this.get_config("secure_cookie"),
        ignore_dnt: this.get_config("ignore_dnt")
    }, e), R.localStorage.is_supported() || (e.persistence_type = "cookie"), t(this.get_config("token"), {
        track: e.track,
        trackEventName: e.track_event_name,
        trackProperties: e.track_properties,
        persistenceType: e.persistence_type,
        persistencePrefix: e.cookie_prefix,
        cookieDomain: e.cookie_domain,
        cookieExpiration: e.cookie_expiration,
        crossSiteCookie: e.cross_site_cookie,
        crossSubdomainCookie: e.cross_subdomain_cookie,
        secureCookie: e.secure_cookie,
        ignoreDnt: e.ignore_dnt
    })
};
Se.prototype.opt_in_tracking = function(t) {
    t = R.extend({
        enable_persistence: !0
    }, t), this._gdpr_call_func(GB, t), this._gdpr_update_persistence(t)
};
Se.prototype.opt_out_tracking = function(t) {
    t = R.extend({
        clear_persistence: !0,
        delete_user: !0
    }, t), t.delete_user && this.people && this.people._identify_called() && (this.people.delete_user(), this.people.clear_charges()), this._gdpr_call_func(VB, t), this._gdpr_update_persistence(t)
};
Se.prototype.has_opted_in_tracking = function(t) {
    return this._gdpr_call_func(jB, t)
};
Se.prototype.has_opted_out_tracking = function(t) {
    return this._gdpr_call_func(D7, t)
};
Se.prototype.clear_opt_in_out_tracking = function(t) {
    t = R.extend({
        enable_persistence: !0
    }, t), this._gdpr_call_func(WB, t), this._gdpr_update_persistence(t)
};
Se.prototype.report_error = function(t, e) {
    qt.error.apply(qt.error, arguments);
    try {
        !e && !(t instanceof Error) && (t = new Error(t)), this.get_config("error_reporter")(t, e)
    } catch (n) {
        qt.error(n)
    }
};
Se.prototype.init = Se.prototype.init;
Se.prototype.reset = Se.prototype.reset;
Se.prototype.disable = Se.prototype.disable;
Se.prototype.time_event = Se.prototype.time_event;
Se.prototype.track = Se.prototype.track;
Se.prototype.track_links = Se.prototype.track_links;
Se.prototype.track_forms = Se.prototype.track_forms;
Se.prototype.track_pageview = Se.prototype.track_pageview;
Se.prototype.register = Se.prototype.register;
Se.prototype.register_once = Se.prototype.register_once;
Se.prototype.unregister = Se.prototype.unregister;
Se.prototype.identify = Se.prototype.identify;
Se.prototype.alias = Se.prototype.alias;
Se.prototype.name_tag = Se.prototype.name_tag;
Se.prototype.set_config = Se.prototype.set_config;
Se.prototype.get_config = Se.prototype.get_config;
Se.prototype.get_property = Se.prototype.get_property;
Se.prototype.get_distinct_id = Se.prototype.get_distinct_id;
Se.prototype.toString = Se.prototype.toString;
Se.prototype.opt_out_tracking = Se.prototype.opt_out_tracking;
Se.prototype.opt_in_tracking = Se.prototype.opt_in_tracking;
Se.prototype.has_opted_out_tracking = Se.prototype.has_opted_out_tracking;
Se.prototype.has_opted_in_tracking = Se.prototype.has_opted_in_tracking;
Se.prototype.clear_opt_in_out_tracking = Se.prototype.clear_opt_in_out_tracking;
Se.prototype.get_group = Se.prototype.get_group;
Se.prototype.set_group = Se.prototype.set_group;
Se.prototype.add_group = Se.prototype.add_group;
Se.prototype.remove_group = Se.prototype.remove_group;
Se.prototype.track_with_groups = Se.prototype.track_with_groups;
Se.prototype.start_batch_senders = Se.prototype.start_batch_senders;
Se.prototype.stop_batch_senders = Se.prototype.stop_batch_senders;
Se.prototype.DEFAULT_API_ROUTES = V7;
Et.prototype.properties = Et.prototype.properties;
Et.prototype.update_search_keyword = Et.prototype.update_search_keyword;
Et.prototype.update_referrer_info = Et.prototype.update_referrer_info;
Et.prototype.get_cross_subdomain = Et.prototype.get_cross_subdomain;
Et.prototype.clear = Et.prototype.clear;
var dl = {},
    JB = function() {
        R.each(dl, function(t, e) {
            e !== Ts && (cr[e] = t)
        }), cr._ = R
    },
    eq = function() {
        cr.init = function(t, e, n) {
            if (n) return cr[n] || (cr[n] = dl[n] = A0(t, e, n), cr[n]._loaded()), cr[n];
            var r = cr;
            dl[Ts] ? r = dl[Ts] : t && (r = A0(t, e, Ts), r._loaded(), dl[Ts] = r), cr = r, M2 === KB && (yn[Ts] = cr), JB()
        }
    },
    tq = function() {
        function t() {
            t.done || (t.done = !0, j7 = !0, G7 = !1, R.each(dl, function(r) {
                r._dom_loaded()
            }))
        }

        function e() {
            try {
                Yt.documentElement.doScroll("left")
            } catch {
                setTimeout(e, 1);
                return
            }
            t()
        }
        if (Yt.addEventListener) Yt.readyState === "complete" ? t() : Yt.addEventListener("DOMContentLoaded", t, !1);
        else if (Yt.attachEvent) {
            Yt.attachEvent("onreadystatechange", t);
            var n = !1;
            try {
                n = yn.frameElement === null
            } catch {}
            Yt.documentElement.doScroll && n && e()
        }
        R.register_event(yn, "load", t, !0)
    };

function nq() {
    return M2 = B7, cr = new Se, eq(), cr.init(), tq(), cr
}
var rq = nq(),
    sq = rq;
const xT = Rc(sq);
class zl {
    static setup() {
        this.isSetup = !0, gtag("config", "G-V1QJVQMYF1", {
            send_page_view: !1
        }), xT.init("2e284873b7269f13b850ac994abfd848", {
            debug: "false"
        })
    }
    static ga(e, n) {
        this.isSetup || this.setup(), gtag("event", e, n)
    }
    static mp(e, n) {
        this.isSetup || this.setup(), xT.track(e, n)
    }
    static pageView(e) {
        this.ga("page_view", {
            page_title: e,
            page_location: `https://jackbox.tv/${e}`
        })
    }
    static gameStarted(e, n) {
        const r = {
            tag: e
        };
        n.isUGC !== void 0 && (r.is_ugc = n.isUGC), n.isSequel !== void 0 && (r.is_sequel = n.isSequel), n.locale !== void 0 && (r.locale = n.locale), n.mode !== void 0 && (r.mode = n.mode), n.numberOfPlayer !== void 0 && (r.number_of_players = n.numberOfPlayer), this.ga("game_start", r)
    }
    static gameJoined(e, n) {
        this.mp("Game Joined", {
            tag: e,
            ...n
        })
    }
    static bannerClick(e, n) {
        this.ga("banner_click", {
            url: e,
            location: n
        })
    }
    static externalLinkClick(e, n) {
        this.ga("external_link_click", {
            url: e,
            location: n
        })
    }
    static moderatorConnected(e) {
        this.ga("moderator_connected", {
            tag: e
        }), this.mp("Moderator Connected", {
            tag: e
        })
    }
    static itemModerated(e, n) {
        this.ga("item_moderated", {
            tag: e,
            was_rejected: n
        }), this.mp("Moderator Item", {
            tag: e,
            wasRejected: n
        })
    }
    static playerKicked(e, n) {
        this.ga("player_kicked", {
            tag: e,
            is_lobby: n
        }), this.mp("Moderator Kick", {
            tag: e,
            isLobby: n
        })
    }
    static galleryImpression(e, n) {
        this.ga("gallery_impression", {
            category_id: e,
            location: n
        })
    }
    static galleryClick(e, n) {
        this.ga("gallery_click", {
            category_id: e,
            location: n
        }), this.mp("Gallery Click", {
            categoryId: e,
            location: n
        })
    }
    static galleryAddToCart(e, n) {
        this.mp("Gallery Add To Cart", {
            categoryId: e,
            ...n
        })
    }
    static galleryCheckout(e, n) {
        this.mp("Gallery Checkout", {
            categoryId: e,
            ...n
        })
    }
    static galleryShare(e, n) {
        this.mp("Gallery Share", {
            categoryId: e,
            ...n
        })
    }
    static galleryWatch(e, n) {
        this.mp("Gallery Watch", {
            categoryId: e,
            ...n
        })
    }
    static galleryDownload(e, n) {
        this.mp("Gallery Download", {
            categoryId: e,
            ...n
        })
    }
}
ye(zl, "isSetup", !1);
const iq = [{
        name: "Prototype",
        tag: "prototype",
        wrapper: "vue",
        isPublic: !0,
        directory: "internal/prototype"
    }, {
        name: "EcastTestClient",
        tag: "ecast-test-client",
        wrapper: "marionette",
        isPublic: !0,
        directory: "internal/ecast-test-client"
    }, {
        name: "Quiplash 2 InterLASHional",
        tag: "quiplash2-international",
        wrapper: "marionette",
        isPublic: !0,
        directory: "standalone/quiplash2-international",
        categoryId: "quiplash2-internationalGame"
    }, {
        name: "Guesspionage Crowdplay",
        tag: "guesspionage-crowdplay",
        wrapper: "marionette",
        isPublic: !0,
        directory: "standalone/guesspionage-crowdplay"
    }, {
        name: "Drawful 2",
        tag: "drawful2",
        wrapper: "marionette",
        isPublic: !0,
        directory: "standalone/drawful2",
        categoryId: "DrawfulGame",
        shopItems: ["shirts"]
    }, {
        name: "Drawful 2",
        tag: "drawful2international",
        wrapper: "marionette",
        isPublic: !0,
        directory: "standalone/drawful2-international",
        features: ["moderation"]
    }, {
        name: "Acquisitions, Inc.",
        tag: "acquisitions-inc",
        wrapper: "marionette",
        isPublic: !0,
        directory: "standalone/acquisitions-inc"
    }, {
        name: "You Don't Know Jack 2015",
        tag: "ydkj2015",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp1/ydkj2015"
    }, {
        name: "Drawful",
        tag: "drawful",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp1/drawful"
    }, {
        name: "Word Spud",
        tag: "wordspud",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp1/wordspud"
    }, {
        name: "Lie Swatter",
        tag: "lieswatter",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp1/lieswatter"
    }, {
        name: "Fibbage",
        tag: "fibbage",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp1/fibbage"
    }, {
        name: "Fibbage 2",
        tag: "fibbage2",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp2/fibbage2"
    }, {
        name: "Earwax",
        tag: "earwax",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp2/earwax"
    }, {
        name: "Bidiots",
        tag: "auction",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp2/auction"
    }, {
        name: "Bomb Corp",
        tag: "bombintern",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp2/bombintern"
    }, {
        name: "Quiplash",
        tag: "quiplash",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp2/quiplash"
    }, {
        name: "Fakin' It",
        tag: "fakinit",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp3/fakinit"
    }, {
        name: "Tee K.O.",
        tag: "awshirt",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp3/awshirt",
        categoryId: "TeeKOGame",
        shopItems: ["shirts"]
    }, {
        name: "Quiplash 2",
        tag: "quiplash2",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp3/quiplash2",
        categoryId: "Quiplash2Game"
    }, {
        name: "Trivia Murder Party",
        tag: "triviadeath",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp3/triviadeath",
        categoryId: "TriviaDeathResults"
    }, {
        name: "Guesspionage",
        tag: "pollposition",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp3/pollposition"
    }, {
        name: "Fibbage 3",
        tag: "fibbage3",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp4/fibbage3"
    }, {
        name: "Survive the Internet",
        tag: "survivetheinternet",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp4/survivetheinternet",
        categoryId: "STIGame"
    }, {
        name: "Monster Seeking Monster",
        tag: "monstermingle",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp4/monstermingle",
        categoryId: "MonsterMingleGame"
    }, {
        name: "Bracketeering",
        tag: "bracketeering",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp4/bracketeering",
        categoryId: "BRKGame"
    }, {
        name: "Civic Doodle",
        tag: "overdrawn",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp4/overdrawn",
        categoryId: "OverdrawnGame",
        shopItems: ["shirts"]
    }, {
        name: "You Don't Know Jack: Full Stream",
        tag: "ydkj2018",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp5/ydkj2018",
        categoryId: "YDKJ2018Game"
    }, {
        name: "Split the Room",
        tag: "splittheroom",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp5/splittheroom",
        categoryId: "SplitTheRoomGame"
    }, {
        name: "Mad Verse City",
        tag: "rapbattle",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp5/rapbattle",
        categoryId: "RapBattleGame"
    }, {
        name: "Zeeple Dome",
        tag: "slingshoot",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp5/slingshoot",
        categoryId: "SlingShootGame"
    }, {
        name: "Patently Stupid",
        tag: "patentlystupid",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp5/patentlystupid",
        categoryId: "PatentlyStupidGame",
        shopItems: ["mugs"]
    }, {
        name: "Trivia Murder Party 2",
        tag: "triviadeath2",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp6/triviadeath2",
        categoryId: "TriviaDeath2Game"
    }, {
        name: "Role Models",
        tag: "rolemodels",
        wrapper: "marionette",
        isPublic: !0,
        features: ["camera"],
        directory: "pp6/rolemodels",
        categoryId: "RoleModelsGame",
        shopItems: ["shirts"]
    }, {
        name: "Joke Boat",
        tag: "jokeboat",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp6/jokeboat",
        categoryId: "JokeboatGame"
    }, {
        name: "Dictionarium",
        tag: "ridictionary",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp6/ridictionary",
        categoryId: "RidictionaryGame"
    }, {
        name: "Push the Button",
        tag: "pushthebutton",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp6/pushthebutton",
        categoryId: "PushTheButtonGame"
    }, {
        name: "Talking Points",
        tag: "jackbox-talks",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp7/jackboxtalks",
        features: ["camera", "moderation"],
        categoryId: "JackboxTalksGame"
    }, {
        name: "Quiplash 3",
        tag: "quiplash3",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp7/quiplash3",
        features: ["moderation"],
        categoryId: "quiplash3Game"
    }, {
        name: "The Devils and the Details",
        tag: "everyday",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp7/everyday",
        categoryId: "EverydayGame",
        shopItems: ["mugs"]
    }, {
        name: "Champ'd Up",
        tag: "worldchamps",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp7/worldchamps",
        features: ["moderation"],
        categoryId: "WorldChampionsGame",
        shopItems: ["cards"]
    }, {
        name: "Blather 'Round",
        tag: "blanky-blank",
        wrapper: "marionette",
        isPublic: !0,
        directory: "pp7/blanky-blank",
        categoryId: "BlankyBlankGame"
    }, {
        name: "Job Job",
        tag: "apply-yourself",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp8/apply-yourself",
        categoryId: "JobGameGame",
        features: ["moderation", "previews"]
    }, {
        name: "Drawful Animate",
        tag: "drawful-animate",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp8/drawful-animate",
        categoryId: "DrawfulAnimateGame",
        features: ["moderation"]
    }, {
        name: "The Wheel of Enormous Proportions",
        tag: "the-wheel",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp8/the-wheel",
        categoryId: "TheWheelGame"
    }, {
        name: "The Poll Mine",
        tag: "survey-bomb",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp8/survey-bomb",
        categoryId: "SurveyBombGame"
    }, {
        name: "Weapons Drawn",
        tag: "murder-detectives",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp8/murder-detectives",
        categoryId: "MurderDetectivesGame",
        features: ["moderation"]
    }, {
        name: "Quiplash 3",
        tag: "quiplash3-tjsp",
        wrapper: "vue",
        isPublic: !0,
        directory: "tjsp/quiplash3",
        features: ["moderation"],
        categoryId: "quiplash3Game"
    }, {
        name: "Tee K.O.",
        tag: "awshirt-tjsp",
        wrapper: "vue",
        isPublic: !0,
        directory: "tjsp/awshirt",
        features: ["moderation"],
        shopItems: ["shirts"],
        categoryId: "TeeKOGame"
    }, {
        name: "Trivia Murder Party 2",
        tag: "triviadeath2-tjsp",
        wrapper: "vue",
        isPublic: !0,
        directory: "tjsp/triviadeath2",
        categoryId: "TriviaMurderParty2Game"
    }, {
        name: "Fibbage 4",
        tag: "fourbage",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp9/fourbage",
        features: ["moderation", "kicking"],
        categoryId: "Fibbage4Game"
    }, {
        name: "Roomerang",
        tag: "htmf",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp9/htmf",
        features: ["moderation", "kicking"],
        categoryId: "MakeFriendsGame"
    }, {
        name: "Junktopia",
        tag: "antique-freak",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp9/antique-freak",
        features: ["moderation", "kicking"],
        categoryId: "AntiqueGameGame"
    }, {
        name: "Nonsensory",
        tag: "range-game",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp9/range-game",
        features: ["moderation", "kicking"],
        categoryId: "RangeGameGame"
    }, {
        name: "Quixort",
        tag: "lineup",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp9/lineup",
        features: ["kicking", "previews"],
        categoryId: "LineupGame"
    }, {
        name: "Tee K.O. 2",
        tag: "awshirt2",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp10/awshirt2",
        features: ["moderation", "kicking"],
        shopItems: ["shirts"],
        categoryId: "TeeKO2Game",
        galleryId: "teeko2"
    }, {
        name: "Dodo Re Mi",
        tag: "nopus-opus",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp10/nopus-opus",
        features: ["dropInDropOut", "kicking"],
        categoryId: "NopusOpusGame",
        galleryId: "dodo-re-mi"
    }, {
        name: "FixyText",
        tag: "risky-text",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp10/risky-text",
        features: ["moderation", "kicking"],
        categoryId: "FixyTextGame",
        galleryId: "fixytext"
    }, {
        name: "Timejinx",
        tag: "time-trivia",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp10/time-trivia",
        features: ["kicking"],
        categoryId: "TimeTriviaGame",
        galleryId: "timejinx"
    }, {
        name: "Hypnotorious",
        tag: "us-them",
        wrapper: "vue",
        isPublic: !0,
        directory: "pp10/us-them",
        features: ["moderation", "kicking"],
        categoryId: "StrangersGame",
        galleryId: "hypnotorious"
    }, {
        name: "Fakin' It After Dark",
        tag: "fakinit2",
        wrapper: "vue",
        isPublic: !1,
        directory: "ppad/fakinit2",
        categoryId: "FakinIt2Game",
        features: ["moderation", "kicking"]
    }, {
        name: "Drawful After Dark",
        tag: "drawful3",
        wrapper: "vue",
        isPublic: !1,
        directory: "ppad/drawful3",
        categoryId: "Drawful3Game",
        features: ["moderation", "kicking"]
    }],
    a1 = t => iq.find(e => e.tag === t || e.galleryId === t || e.categoryId === t);

function oq() {
    this.__data__ = [], this.size = 0
}
var aq = oq;

function cq(t, e) {
    return t === e || t !== t && e !== e
}
var jm = cq,
    lq = jm;

function uq(t, e) {
    for (var n = t.length; n--;)
        if (lq(t[n][0], e)) return n;
    return -1
}
var Wm = uq,
    hq = Wm,
    fq = Array.prototype,
    dq = fq.splice;

function pq(t) {
    var e = this.__data__,
        n = hq(e, t);
    if (n < 0) return !1;
    var r = e.length - 1;
    return n == r ? e.pop() : dq.call(e, n, 1), --this.size, !0
}
var mq = pq,
    gq = Wm;

function _q(t) {
    var e = this.__data__,
        n = gq(e, t);
    return n < 0 ? void 0 : e[n][1]
}
var yq = _q,
    vq = Wm;

function bq(t) {
    return vq(this.__data__, t) > -1
}
var Eq = bq,
    Tq = Wm;

function Sq(t, e) {
    var n = this.__data__,
        r = Tq(n, t);
    return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
}
var wq = Sq,
    Aq = aq,
    Oq = mq,
    Cq = yq,
    kq = Eq,
    Iq = wq;

function Su(t) {
    var e = -1,
        n = t == null ? 0 : t.length;
    for (this.clear(); ++e < n;) {
        var r = t[e];
        this.set(r[0], r[1])
    }
}
Su.prototype.clear = Aq;
Su.prototype.delete = Oq;
Su.prototype.get = Cq;
Su.prototype.has = kq;
Su.prototype.set = Iq;
var Hm = Su,
    Nq = Hm;

function xq() {
    this.__data__ = new Nq, this.size = 0
}
var Pq = xq;

function Rq(t) {
    var e = this.__data__,
        n = e.delete(t);
    return this.size = e.size, n
}
var Mq = Rq;

function Dq(t) {
    return this.__data__.get(t)
}
var $q = Dq;

function Lq(t) {
    return this.__data__.has(t)
}
var Fq = Lq,
    Uq = typeof _n == "object" && _n && _n.Object === Object && _n,
    W7 = Uq,
    Bq = W7,
    qq = typeof self == "object" && self && self.Object === Object && self,
    Gq = Bq || qq || Function("return this")(),
    ni = Gq,
    Vq = ni,
    jq = Vq.Symbol,
    Ym = jq,
    PT = Ym,
    H7 = Object.prototype,
    Wq = H7.hasOwnProperty,
    Hq = H7.toString,
    sh = PT ? PT.toStringTag : void 0;

function Yq(t) {
    var e = Wq.call(t, sh),
        n = t[sh];
    try {
        t[sh] = void 0;
        var r = !0
    } catch {}
    var s = Hq.call(t);
    return r && (e ? t[sh] = n : delete t[sh]), s
}
var zq = Yq,
    Kq = Object.prototype,
    Zq = Kq.toString;

function Xq(t) {
    return Zq.call(t)
}
var Qq = Xq,
    RT = Ym,
    Jq = zq,
    eG = Qq,
    tG = "[object Null]",
    nG = "[object Undefined]",
    MT = RT ? RT.toStringTag : void 0;

function rG(t) {
    return t == null ? t === void 0 ? nG : tG : MT && MT in Object(t) ? Jq(t) : eG(t)
}
var wu = rG;

function sG(t) {
    var e = typeof t;
    return t != null && (e == "object" || e == "function")
}
var ri = sG,
    iG = wu,
    oG = ri,
    aG = "[object AsyncFunction]",
    cG = "[object Function]",
    lG = "[object GeneratorFunction]",
    uG = "[object Proxy]";

function hG(t) {
    if (!oG(t)) return !1;
    var e = iG(t);
    return e == cG || e == lG || e == aG || e == uG
}
var L2 = hG,
    fG = ni,
    dG = fG["__core-js_shared__"],
    pG = dG,
    cy = pG,
    DT = function() {
        var t = /[^.]+$/.exec(cy && cy.keys && cy.keys.IE_PROTO || "");
        return t ? "Symbol(src)_1." + t : ""
    }();

function mG(t) {
    return !!DT && DT in t
}
var gG = mG,
    _G = Function.prototype,
    yG = _G.toString;

function vG(t) {
    if (t != null) {
        try {
            return yG.call(t)
        } catch {}
        try {
            return t + ""
        } catch {}
    }
    return ""
}
var Y7 = vG,
    bG = L2,
    EG = gG,
    TG = ri,
    SG = Y7,
    wG = /[\\^$.*+?()[\]{}|]/g,
    AG = /^\[object .+?Constructor\]$/,
    OG = Function.prototype,
    CG = Object.prototype,
    kG = OG.toString,
    IG = CG.hasOwnProperty,
    NG = RegExp("^" + kG.call(IG).replace(wG, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

function xG(t) {
    if (!TG(t) || EG(t)) return !1;
    var e = bG(t) ? NG : AG;
    return e.test(SG(t))
}
var PG = xG;

function RG(t, e) {
    return t == null ? void 0 : t[e]
}
var MG = RG,
    DG = PG,
    $G = MG;

function LG(t, e) {
    var n = $G(t, e);
    return DG(n) ? n : void 0
}
var Mc = LG,
    FG = Mc,
    UG = ni,
    BG = FG(UG, "Map"),
    F2 = BG,
    qG = Mc,
    GG = qG(Object, "create"),
    zm = GG,
    $T = zm;

function VG() {
    this.__data__ = $T ? $T(null) : {}, this.size = 0
}
var jG = VG;

function WG(t) {
    var e = this.has(t) && delete this.__data__[t];
    return this.size -= e ? 1 : 0, e
}
var HG = WG,
    YG = zm,
    zG = "__lodash_hash_undefined__",
    KG = Object.prototype,
    ZG = KG.hasOwnProperty;

function XG(t) {
    var e = this.__data__;
    if (YG) {
        var n = e[t];
        return n === zG ? void 0 : n
    }
    return ZG.call(e, t) ? e[t] : void 0
}
var QG = XG,
    JG = zm,
    eV = Object.prototype,
    tV = eV.hasOwnProperty;

function nV(t) {
    var e = this.__data__;
    return JG ? e[t] !== void 0 : tV.call(e, t)
}
var rV = nV,
    sV = zm,
    iV = "__lodash_hash_undefined__";

function oV(t, e) {
    var n = this.__data__;
    return this.size += this.has(t) ? 0 : 1, n[t] = sV && e === void 0 ? iV : e, this
}
var aV = oV,
    cV = jG,
    lV = HG,
    uV = QG,
    hV = rV,
    fV = aV;

function Au(t) {
    var e = -1,
        n = t == null ? 0 : t.length;
    for (this.clear(); ++e < n;) {
        var r = t[e];
        this.set(r[0], r[1])
    }
}
Au.prototype.clear = cV;
Au.prototype.delete = lV;
Au.prototype.get = uV;
Au.prototype.has = hV;
Au.prototype.set = fV;
var dV = Au,
    LT = dV,
    pV = Hm,
    mV = F2;

function gV() {
    this.size = 0, this.__data__ = {
        hash: new LT,
        map: new(mV || pV),
        string: new LT
    }
}
var _V = gV;

function yV(t) {
    var e = typeof t;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
}
var vV = yV,
    bV = vV;

function EV(t, e) {
    var n = t.__data__;
    return bV(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
}
var Km = EV,
    TV = Km;

function SV(t) {
    var e = TV(this, t).delete(t);
    return this.size -= e ? 1 : 0, e
}
var wV = SV,
    AV = Km;

function OV(t) {
    return AV(this, t).get(t)
}
var CV = OV,
    kV = Km;

function IV(t) {
    return kV(this, t).has(t)
}
var NV = IV,
    xV = Km;

function PV(t, e) {
    var n = xV(this, t),
        r = n.size;
    return n.set(t, e), this.size += n.size == r ? 0 : 1, this
}
var RV = PV,
    MV = _V,
    DV = wV,
    $V = CV,
    LV = NV,
    FV = RV;

function Ou(t) {
    var e = -1,
        n = t == null ? 0 : t.length;
    for (this.clear(); ++e < n;) {
        var r = t[e];
        this.set(r[0], r[1])
    }
}
Ou.prototype.clear = MV;
Ou.prototype.delete = DV;
Ou.prototype.get = $V;
Ou.prototype.has = LV;
Ou.prototype.set = FV;
var z7 = Ou,
    UV = Hm,
    BV = F2,
    qV = z7,
    GV = 200;

function VV(t, e) {
    var n = this.__data__;
    if (n instanceof UV) {
        var r = n.__data__;
        if (!BV || r.length < GV - 1) return r.push([t, e]), this.size = ++n.size, this;
        n = this.__data__ = new qV(r)
    }
    return n.set(t, e), this.size = n.size, this
}
var jV = VV,
    WV = Hm,
    HV = Pq,
    YV = Mq,
    zV = $q,
    KV = Fq,
    ZV = jV;

function Cu(t) {
    var e = this.__data__ = new WV(t);
    this.size = e.size
}
Cu.prototype.clear = HV;
Cu.prototype.delete = YV;
Cu.prototype.get = zV;
Cu.prototype.has = KV;
Cu.prototype.set = ZV;
var K7 = Cu,
    XV = Mc,
    QV = function() {
        try {
            var t = XV(Object, "defineProperty");
            return t({}, "", {}), t
        } catch {}
    }(),
    Z7 = QV,
    FT = Z7;

function JV(t, e, n) {
    e == "__proto__" && FT ? FT(t, e, {
        configurable: !0,
        enumerable: !0,
        value: n,
        writable: !0
    }) : t[e] = n
}
var U2 = JV,
    ej = U2,
    tj = jm;

function nj(t, e, n) {
    (n !== void 0 && !tj(t[e], n) || n === void 0 && !(e in t)) && ej(t, e, n)
}
var X7 = nj;

function rj(t) {
    return function(e, n, r) {
        for (var s = -1, i = Object(e), o = r(e), a = o.length; a--;) {
            var l = o[t ? a : ++s];
            if (n(i[l], l, i) === !1) break
        }
        return e
    }
}
var sj = rj,
    ij = sj,
    oj = ij(),
    aj = oj,
    c1 = {
        exports: {}
    };
c1.exports;
(function(t, e) {
    var n = ni,
        r = e && !e.nodeType && e,
        s = r && !0 && t && !t.nodeType && t,
        i = s && s.exports === r,
        o = i ? n.Buffer : void 0,
        a = o ? o.allocUnsafe : void 0;

    function l(u, f) {
        if (f) return u.slice();
        var d = u.length,
            p = a ? a(d) : new u.constructor(d);
        return u.copy(p), p
    }
    t.exports = l
})(c1, c1.exports);
var Q7 = c1.exports,
    cj = ni,
    lj = cj.Uint8Array,
    uj = lj,
    UT = uj;

function hj(t) {
    var e = new t.constructor(t.byteLength);
    return new UT(e).set(new UT(t)), e
}
var B2 = hj,
    fj = B2;

function dj(t, e) {
    var n = e ? fj(t.buffer) : t.buffer;
    return new t.constructor(n, t.byteOffset, t.length)
}
var J7 = dj;

function pj(t, e) {
    var n = -1,
        r = t.length;
    for (e || (e = Array(r)); ++n < r;) e[n] = t[n];
    return e
}
var e9 = pj,
    mj = ri,
    BT = Object.create,
    gj = function() {
        function t() {}
        return function(e) {
            if (!mj(e)) return {};
            if (BT) return BT(e);
            t.prototype = e;
            var n = new t;
            return t.prototype = void 0, n
        }
    }(),
    _j = gj;

function yj(t, e) {
    return function(n) {
        return t(e(n))
    }
}
var t9 = yj,
    vj = t9,
    bj = vj(Object.getPrototypeOf, Object),
    q2 = bj,
    Ej = Object.prototype;

function Tj(t) {
    var e = t && t.constructor,
        n = typeof e == "function" && e.prototype || Ej;
    return t === n
}
var G2 = Tj,
    Sj = _j,
    wj = q2,
    Aj = G2;

function Oj(t) {
    return typeof t.constructor == "function" && !Aj(t) ? Sj(wj(t)) : {}
}
var n9 = Oj;

function Cj(t) {
    return t != null && typeof t == "object"
}
var Aa = Cj,
    kj = wu,
    Ij = Aa,
    Nj = "[object Arguments]";

function xj(t) {
    return Ij(t) && kj(t) == Nj
}
var Pj = xj,
    qT = Pj,
    Rj = Aa,
    r9 = Object.prototype,
    Mj = r9.hasOwnProperty,
    Dj = r9.propertyIsEnumerable,
    $j = qT(function() {
        return arguments
    }()) ? qT : function(t) {
        return Rj(t) && Mj.call(t, "callee") && !Dj.call(t, "callee")
    },
    s9 = $j,
    Lj = Array.isArray,
    Oa = Lj,
    Fj = 9007199254740991;

function Uj(t) {
    return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Fj
}
var i9 = Uj,
    Bj = L2,
    qj = i9;

function Gj(t) {
    return t != null && qj(t.length) && !Bj(t)
}
var Zm = Gj,
    Vj = Zm,
    jj = Aa;

function Wj(t) {
    return jj(t) && Vj(t)
}
var Hj = Wj,
    l1 = {
        exports: {}
    };

function Yj() {
    return !1
}
var zj = Yj;
l1.exports;
(function(t, e) {
    var n = ni,
        r = zj,
        s = e && !e.nodeType && e,
        i = s && !0 && t && !t.nodeType && t,
        o = i && i.exports === s,
        a = o ? n.Buffer : void 0,
        l = a ? a.isBuffer : void 0,
        u = l || r;
    t.exports = u
})(l1, l1.exports);
var V2 = l1.exports,
    Kj = wu,
    Zj = q2,
    Xj = Aa,
    Qj = "[object Object]",
    Jj = Function.prototype,
    eW = Object.prototype,
    o9 = Jj.toString,
    tW = eW.hasOwnProperty,
    nW = o9.call(Object);

function rW(t) {
    if (!Xj(t) || Kj(t) != Qj) return !1;
    var e = Zj(t);
    if (e === null) return !0;
    var n = tW.call(e, "constructor") && e.constructor;
    return typeof n == "function" && n instanceof n && o9.call(n) == nW
}
var sW = rW,
    iW = wu,
    oW = i9,
    aW = Aa,
    cW = "[object Arguments]",
    lW = "[object Array]",
    uW = "[object Boolean]",
    hW = "[object Date]",
    fW = "[object Error]",
    dW = "[object Function]",
    pW = "[object Map]",
    mW = "[object Number]",
    gW = "[object Object]",
    _W = "[object RegExp]",
    yW = "[object Set]",
    vW = "[object String]",
    bW = "[object WeakMap]",
    EW = "[object ArrayBuffer]",
    TW = "[object DataView]",
    SW = "[object Float32Array]",
    wW = "[object Float64Array]",
    AW = "[object Int8Array]",
    OW = "[object Int16Array]",
    CW = "[object Int32Array]",
    kW = "[object Uint8Array]",
    IW = "[object Uint8ClampedArray]",
    NW = "[object Uint16Array]",
    xW = "[object Uint32Array]",
    nn = {};
nn[SW] = nn[wW] = nn[AW] = nn[OW] = nn[CW] = nn[kW] = nn[IW] = nn[NW] = nn[xW] = !0;
nn[cW] = nn[lW] = nn[EW] = nn[uW] = nn[TW] = nn[hW] = nn[fW] = nn[dW] = nn[pW] = nn[mW] = nn[gW] = nn[_W] = nn[yW] = nn[vW] = nn[bW] = !1;

function PW(t) {
    return aW(t) && oW(t.length) && !!nn[iW(t)]
}
var RW = PW;

function MW(t) {
    return function(e) {
        return t(e)
    }
}
var j2 = MW,
    u1 = {
        exports: {}
    };
u1.exports;
(function(t, e) {
    var n = W7,
        r = e && !e.nodeType && e,
        s = r && !0 && t && !t.nodeType && t,
        i = s && s.exports === r,
        o = i && n.process,
        a = function() {
            try {
                var l = s && s.require && s.require("util").types;
                return l || o && o.binding && o.binding("util")
            } catch {}
        }();
    t.exports = a
})(u1, u1.exports);
var W2 = u1.exports,
    DW = RW,
    $W = j2,
    GT = W2,
    VT = GT && GT.isTypedArray,
    LW = VT ? $W(VT) : DW,
    a9 = LW;

function FW(t, e) {
    if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__") return t[e]
}
var c9 = FW,
    UW = U2,
    BW = jm,
    qW = Object.prototype,
    GW = qW.hasOwnProperty;

function VW(t, e, n) {
    var r = t[e];
    (!(GW.call(t, e) && BW(r, n)) || n === void 0 && !(e in t)) && UW(t, e, n)
}
var H2 = VW,
    jW = H2,
    WW = U2;

function HW(t, e, n, r) {
    var s = !n;
    n || (n = {});
    for (var i = -1, o = e.length; ++i < o;) {
        var a = e[i],
            l = r ? r(n[a], t[a], a, n, t) : void 0;
        l === void 0 && (l = t[a]), s ? WW(n, a, l) : jW(n, a, l)
    }
    return n
}
var $f = HW;

function YW(t, e) {
    for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
    return r
}
var zW = YW,
    KW = 9007199254740991,
    ZW = /^(?:0|[1-9]\d*)$/;

function XW(t, e) {
    var n = typeof t;
    return e = e ?? KW, !!e && (n == "number" || n != "symbol" && ZW.test(t)) && t > -1 && t % 1 == 0 && t < e
}
var Y2 = XW,
    QW = zW,
    JW = s9,
    eH = Oa,
    tH = V2,
    nH = Y2,
    rH = a9,
    sH = Object.prototype,
    iH = sH.hasOwnProperty;

function oH(t, e) {
    var n = eH(t),
        r = !n && JW(t),
        s = !n && !r && tH(t),
        i = !n && !r && !s && rH(t),
        o = n || r || s || i,
        a = o ? QW(t.length, String) : [],
        l = a.length;
    for (var u in t)(e || iH.call(t, u)) && !(o && (u == "length" || s && (u == "offset" || u == "parent") || i && (u == "buffer" || u == "byteLength" || u == "byteOffset") || nH(u, l))) && a.push(u);
    return a
}
var l9 = oH;

function aH(t) {
    var e = [];
    if (t != null)
        for (var n in Object(t)) e.push(n);
    return e
}
var cH = aH,
    lH = ri,
    uH = G2,
    hH = cH,
    fH = Object.prototype,
    dH = fH.hasOwnProperty;

function pH(t) {
    if (!lH(t)) return hH(t);
    var e = uH(t),
        n = [];
    for (var r in t) r == "constructor" && (e || !dH.call(t, r)) || n.push(r);
    return n
}
var mH = pH,
    gH = l9,
    _H = mH,
    yH = Zm;

function vH(t) {
    return yH(t) ? gH(t, !0) : _H(t)
}
var Lf = vH,
    bH = $f,
    EH = Lf;

function TH(t) {
    return bH(t, EH(t))
}
var SH = TH,
    jT = X7,
    wH = Q7,
    AH = J7,
    OH = e9,
    CH = n9,
    WT = s9,
    HT = Oa,
    kH = Hj,
    IH = V2,
    NH = L2,
    xH = ri,
    PH = sW,
    RH = a9,
    YT = c9,
    MH = SH;

function DH(t, e, n, r, s, i, o) {
    var a = YT(t, n),
        l = YT(e, n),
        u = o.get(l);
    if (u) {
        jT(t, n, u);
        return
    }
    var f = i ? i(a, l, n + "", t, e, o) : void 0,
        d = f === void 0;
    if (d) {
        var p = HT(l),
            _ = !p && IH(l),
            v = !p && !_ && RH(l);
        f = l, p || _ || v ? HT(a) ? f = a : kH(a) ? f = OH(a) : _ ? (d = !1, f = wH(l, !0)) : v ? (d = !1, f = AH(l, !0)) : f = [] : PH(l) || WT(l) ? (f = a, WT(a) ? f = MH(a) : (!xH(a) || NH(a)) && (f = CH(l))) : d = !1
    }
    d && (o.set(l, f), s(f, l, r, i, o), o.delete(l)), jT(t, n, f)
}
var $H = DH,
    LH = K7,
    FH = X7,
    UH = aj,
    BH = $H,
    qH = ri,
    GH = Lf,
    VH = c9;

function u9(t, e, n, r, s) {
    t !== e && UH(e, function(i, o) {
        if (s || (s = new LH), qH(i)) BH(t, e, o, n, u9, r, s);
        else {
            var a = r ? r(VH(t, o), i, o + "", t, e, s) : void 0;
            a === void 0 && (a = i), FH(t, o, a)
        }
    }, GH)
}
var jH = u9;

function WH(t) {
    return t
}
var h9 = WH;

function HH(t, e, n) {
    switch (n.length) {
        case 0:
            return t.call(e);
        case 1:
            return t.call(e, n[0]);
        case 2:
            return t.call(e, n[0], n[1]);
        case 3:
            return t.call(e, n[0], n[1], n[2])
    }
    return t.apply(e, n)
}
var YH = HH,
    zH = YH,
    zT = Math.max;

function KH(t, e, n) {
    return e = zT(e === void 0 ? t.length - 1 : e, 0),
        function() {
            for (var r = arguments, s = -1, i = zT(r.length - e, 0), o = Array(i); ++s < i;) o[s] = r[e + s];
            s = -1;
            for (var a = Array(e + 1); ++s < e;) a[s] = r[s];
            return a[e] = n(o), zH(t, this, a)
        }
}
var ZH = KH;

function XH(t) {
    return function() {
        return t
    }
}
var QH = XH,
    JH = QH,
    KT = Z7,
    eY = h9,
    tY = KT ? function(t, e) {
        return KT(t, "toString", {
            configurable: !0,
            enumerable: !1,
            value: JH(e),
            writable: !0
        })
    } : eY,
    nY = tY,
    rY = 800,
    sY = 16,
    iY = Date.now;

function oY(t) {
    var e = 0,
        n = 0;
    return function() {
        var r = iY(),
            s = sY - (r - n);
        if (n = r, s > 0) {
            if (++e >= rY) return arguments[0]
        } else e = 0;
        return t.apply(void 0, arguments)
    }
}
var aY = oY,
    cY = nY,
    lY = aY,
    uY = lY(cY),
    hY = uY,
    fY = h9,
    dY = ZH,
    pY = hY;

function mY(t, e) {
    return pY(dY(t, e, fY), t + "")
}
var gY = mY,
    _Y = jm,
    yY = Zm,
    vY = Y2,
    bY = ri;

function EY(t, e, n) {
    if (!bY(n)) return !1;
    var r = typeof e;
    return (r == "number" ? yY(n) && vY(e, n.length) : r == "string" && e in n) ? _Y(n[e], t) : !1
}
var TY = EY,
    SY = gY,
    wY = TY;

function AY(t) {
    return SY(function(e, n) {
        var r = -1,
            s = n.length,
            i = s > 1 ? n[s - 1] : void 0,
            o = s > 2 ? n[2] : void 0;
        for (i = t.length > 3 && typeof i == "function" ? (s--, i) : void 0, o && wY(n[0], n[1], o) && (i = s < 3 ? void 0 : i, s = 1), e = Object(e); ++r < s;) {
            var a = n[r];
            a && t(e, a, r, i)
        }
        return e
    })
}
var OY = AY,
    CY = jH,
    kY = OY,
    IY = kY(function(t, e, n) {
        CY(t, e, n)
    }),
    NY = IY;
const xY = Rc(NY);
class kl {
    static set(e) {
        if (e && this.isSupported(e)) {
            this.locale = e;
            return
        }
        this.locale = this.getPreferredDeviceLocale()
    }
    static getPreferredDeviceLocale() {
        const e = navigator.languages;
        for (let n = 0; n < e.length; n++)
            if (this.isSupported(e[n])) return e[n];
        return this.supported[0]
    }
    static isSupported(e) {
        return Object.values(this.supported).includes(e)
    }
    static mergeMessages(...e) {
        return xY(e[0], ...e)
    }
}
ye(kl, "locale"), ye(kl, "supported", ["en", "fr", "it", "de", "es", "es-XL", "pt-BR"]);
var Wo;
let js = (Wo = class {
    static get serverUrl() {
        const e = this.getQueryParam("server") ?? this.getQueryParam("s");
        return !e || e === "live" ? "ecast.jackboxgames.com" : e === "local" ? "https://localhost" : e.includes("localhost") ? e : `${e}.jackboxgames.com`
    }
    static isDevelopment() {
        return window.location.hostname === "dev.jackbox.tv" || window.location.hostname === "localhost"
    }
    static isProduction() {
        return window.location.hostname === "jackbox.tv"
    }
    static get isCanvasSupported() {
        const e = document.createElement("canvas");
        return !!(e.getContext && e.getContext("2d"))
    }
    static htmlUnescape(e) {
        return String(e).replace(/&quot;/gi, '"').replace(/&#39;/gi, "'").replace(/&lt;/gi, "<").replace(/&gt;/gi, ">").replace(/&amp;/gi, "&")
    }
    static htmlEscape(e) {
        return String(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
    }
    static sanitize(e) {
        const n = this.sanitizeInput(e).replace(/'/g, "");
        return this.htmlEscape(n).trim()
    }
    static sanitizeName(e) {
        return e.replace(/[^A-Z0-9\u00A1\u0020-\u002F\u00BF-\u00FF\u2026!?*$+\-'_ .,]/gi, "").replace(/'/g, "")
    }
    static sanitizeInput(e) {
        return e = e.replace("", "..."), e.replace(/[^\u00A1\u0020-\u007E\u00BF-\u00FF]/gi, "")
    }
    static sanitizeEmoji(e) {
        return e.replace(/(\u00a9|\u00ae|[\u2000-\u2017]|[\u2020-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/, "")
    }
    static safeText(e) {
        const n = document.createElement("div");
        return n.textContent = e, n.innerHTML
    }
    static htmlTagsToBBCode(e, n) {
        if (!n.length) throw new Error("[Utils.htmlTagsToBBCode] No tag pairs were passed in");
        return n.reduce((r, s) => (r.replaceAll(`<${s[0]}>`, `[${s[1]}]`), r.replaceAll(`</${s[0]}>`, `</${s[1]}>`), r), e)
    }
    static hexToRgb(e) {
        const n = new ArrayBuffer(4);
        new DataView(n).setUint32(0, parseInt(e.replace("#", ""), 16), !1);
        const s = new Uint8Array(n);
        return `${s[1]},${s[2]},${s[3]}`
    }
    static adjustColor(e, n) {
        let r = !1,
            s = e;
        s[0] === "#" && (s = s.slice(1), r = !0);
        const i = parseInt(s, 16),
            o = Math.min(Math.max(0, (i >> 16) * n), 255),
            a = Math.min(Math.max(0, (i >> 8 & 255) * n), 255);
        let u = (Math.min(Math.max(0, (i & 255) * n), 255) | a << 8 | o << 16).toString(16);
        for (; u.length < s.length;) u = `0${u}`;
        return (r ? "#" : "") + u
    }
    static isInTolerance(e, n, r) {
        return !(Math.abs(e.x - n.x) < r || Math.abs(e.y - n.y) > r)
    }
    static getDistanceBetweenPoints(e, n) {
        const r = [e.x - n.x, e.y - n.y],
            s = Math.hypot(...r);
        return Math.round(s * 100) / 100
    }
    static getMidpoint(e, n) {
        return {
            x: (e.x + n.x) / 2,
            y: (e.y + n.y) / 2
        }
    }
    static getAngleBetweenPoints(e, n) {
        let s = Math.atan2(n.y - e.y, n.x - e.x) * (180 / Math.PI);
        return s < 0 && (s += 360), 360 - s
    }
    static getAngularDistance(e, n) {
        let r = (n - e) % 360;
        const s = r < 0 ? 1 : -1;
        return r = Math.abs(r), r > 180 ? s * (360 - r) : s * r
    }
    static getVelocity(e, n, r, s) {
        return this.getDistanceBetweenPoints(e, r) / (s - n)
    }
    static isInsideElement(e, n) {
        const r = n.getBoundingClientRect();
        return !(e.x < r.left || e.x > r.left + r.width || e.y < r.top || e.y > r.top + r.height)
    }
    static cyrb128(e) {
        let n = 1779033703,
            r = 3144134277,
            s = 1013904242,
            i = 2773480762;
        for (let o = 0, a; o < e.length; o++) a = e.charCodeAt(o), n = r ^ Math.imul(n ^ a, 597399067), r = s ^ Math.imul(r ^ a, 2869860233), s = i ^ Math.imul(s ^ a, 951274213), i = n ^ Math.imul(i ^ a, 2716044179);
        return n = Math.imul(s ^ n >>> 18, 597399067), r = Math.imul(i ^ r >>> 22, 2869860233), s = Math.imul(n ^ s >>> 17, 951274213), i = Math.imul(r ^ i >>> 19, 2716044179), [(n ^ r ^ s ^ i) >>> 0, (r ^ n) >>> 0, (s ^ n) >>> 0, (i ^ n) >>> 0]
    }
    static sfc32(e, n, r, s) {
        return function() {
            e >>>= 0, n >>>= 0, r >>>= 0, s >>>= 0;
            let o = e + n | 0;
            return e = n ^ n >>> 9, n = r + (r << 3) | 0, r = r << 21 | r >>> 11, s = s + 1 | 0, o = o + s | 0, r = r + o | 0, (o >>> 0) / 4294967296
        }
    }
}, ye(Wo, "queryParams", new URLSearchParams(window.location.search)), ye(Wo, "getQueryParam", e => Wo.queryParams.get(e)), ye(Wo, "sleep", e => new Promise(n => {
    window.setTimeout(n, e)
})), Wo);
class xn {
    static get namespace() {
        var e;
        return ((e = window.tv.storage) == null ? void 0 : e.namespace) ?? this.defaultNamespace
    }
    static get isDisabled() {
        var e;
        return ((e = window.tv.storage) == null ? void 0 : e.isDisabled) ?? !1
    }
    static get tag() {
        var e;
        return (e = window.tv.storage) == null ? void 0 : e.tag
    }
    static get code() {
        var e;
        return (e = window.tv.storage) == null ? void 0 : e.code
    }
    static get isSupported() {
        if (this.isDisabled) return !1;
        try {
            return window.localStorage ? (window.localStorage.setItem("support-check", "1"), window.localStorage.removeItem("support-check"), !0) : !1
        } catch {
            return !1
        }
    }
    static setup(e, n) {
        delete window.tv.storage, window.tv.storage = {
            namespace: js.getQueryParam("namespace") ?? js.getQueryParam("ns") ?? this.defaultNamespace,
            isDisabled: js.queryParams.has("incognito") || js.queryParams.has("nc")
        }, e && (window.tv.storage.tag = e), n && (window.tv.storage.code = n.toLowerCase(), this.clearCodeScopedKeys(window.tv.storage.code))
    }
    static get(e, n) {
        return this.isSupported ? window.localStorage.getItem(this.getScopedKey(e, n)) : null
    }
    static set(e, n, r = "none") {
        if (this.isSupported) return window.localStorage.setItem(this.getScopedSetKey(e, r), n)
    }
    static remove(e, n) {
        if (this.isSupported) return window.localStorage.removeItem(this.getScopedKey(e, n))
    }
    static setTag(e) {
        const n = e.toLowerCase(),
            r = this.get("tags") ?? "[]",
            s = n.split("-")[0];
        let i = JSON.parse(r);
        i = i.filter(o => {
            const a = o.split("-")[0];
            return s !== a
        }), i.push(n), this.set("tags", JSON.stringify(i))
    }
    static getScopedKey(e, n) {
        const r = `${this.namespace}:${e}`,
            s = this.tag ? `${this.namespace}:${e}:tag:${this.tag}` : null,
            i = this.code ? `${this.namespace}:${e}:code:${this.code}` : null;
        if (n === "none") return r;
        if (n === "tag") {
            if (!s) throw new Error('[Storage] requested "tag" scope but tv.storage.tag is undefined');
            return s
        }
        if (n === "code") {
            if (!i) throw new Error('[Storage] requested "code" scope but tv.storage.code is undefined');
            return i
        }
        return i && window.localStorage.getItem(i) !== null ? i : s && window.localStorage.getItem(s) !== null ? s : r
    }
    static getScopedSetKey(e, n = "none") {
        if (n === "tag") {
            if (!this.tag) throw new Error('[Storage] requested "room" scope but tv.storage.tag is undefined');
            return `${this.namespace}:${e}:tag:${this.tag}`
        }
        if (n === "code") {
            if (!this.code) throw new Error('[Storage] requested "code" scope but tv.storage.code is undefined');
            return `${this.namespace}:${e}:code:${this.code}`
        }
        return `${this.namespace}:${e}`
    }
    static clearCodeScopedKeys(e) {
        this.isSupported && Object.keys(window.localStorage).forEach(n => {
            const r = n.split(":code:");
            r.length <= 1 || r[1] !== e && window.localStorage.removeItem(n)
        })
    }
}
ye(xn, "defaultNamespace", "tv");
class wh {
    constructor() {
        ye(this, "artifacts");
        this.migrate(), this.artifacts = this.list()
    }
    get hasUnviewed() {
        return this.artifacts.some(e => !e.isViewed)
    }
    getUrl(e, n) {
        return n.galleryId ? `/gallery/${n.galleryId}/${e.artifactId}` : e.isTest ? `http://games-test.jackbox.tv/artifact/${e.categoryId}/${e.artifactId}/` : `https://games.jackbox.tv/artifact/${e.categoryId}/${e.artifactId}/`
    }
    getLocalArtifact(e) {
        const n = new Intl.DateTimeFormat(kl.locale, {
                year: "numeric",
                month: "short",
                day: "numeric"
            }),
            r = a1(e.categoryId);
        if (!r) throw new Error(`[Artifacts] Unknown game with categoryId ${e.categoryId}`);
        const s = new Date(e.time),
            i = n.format(s),
            o = this.getUrl(e, r);
        return {
            ...e,
            gameName: r.name ?? "",
            date: i,
            url: o
        }
    }
    list() {
        if (!xn.isSupported) return [];
        const e = Date.now(),
            n = xn.get("artifacts");
        if (!n) return [];
        try {
            return JSON.parse(n).filter(s => e - s.time < 525600 * 60 * 1e3).map(s => this.getLocalArtifact(s))
        } catch {
            return console.warn("[Artifacts] Unable to parse artifacts array"), []
        }
    }
    persist() {
        const e = this.artifacts.map(n => ({
            artifactId: n.artifactId,
            categoryId: n.categoryId,
            isTest: n.isTest,
            isViewed: n.isViewed,
            time: n.time
        }));
        xn.set("artifacts", JSON.stringify(e))
    }
    setAsViewed(e) {
        if (xn.isSupported && this.artifacts[e]) try {
            this.artifacts[e].isViewed = !0, this.persist()
        } catch {
            console.warn(`[Artifacts] Unable to mark artifact ${e} as viewed`)
        }
    }
    add(e) {
        var r;
        if (!xn.isSupported) return;
        const n = {
            categoryId: e.categoryId,
            artifactId: e.artifactId,
            isTest: ((r = e.rootId) == null ? void 0 : r.includes("test")) ?? !1,
            time: new Date().getTime(),
            isViewed: !1
        };
        this.artifacts.unshift(this.getLocalArtifact(n)), this.persist()
    }
    remove(e) {
        if (xn.isSupported) try {
            this.artifacts.splice(e, 1), this.persist()
        } catch {
            console.warn("[Artifacts] Unable to remove artifact")
        }
    }
    static setAsViewed(e) {
        new wh().setAsViewed(e)
    }
    static add(e) {
        new wh().add(e)
    }
    static remove(e) {
        new wh().remove(e)
    }
    migrate() {
        const e = xn.get("galleries");
        if (!e) return;
        const r = JSON.parse(e).map(i => {
                const o = i.url.split("/"),
                    a = o[o.length - 2],
                    l = i.url.includes("games-test");
                return {
                    categoryId: i.categoryId,
                    artifactId: a,
                    isTest: l,
                    time: i.time,
                    isViewed: i.viewed
                }
            }),
            s = JSON.parse(xn.get("artifacts") ?? "[]");
        xn.set("artifacts", JSON.stringify([...r, ...s])), xn.remove("galleries")
    }
}
class f9 {
    static isObject(e) {
        return e === null ? !1 : typeof e == "object"
    }
    static isRef(e) {
        return e === null ? !1 : e.$ref !== void 0
    }
    static isObjAndRef(e) {
        return e === null ? !1 : this.isObject(e) && Object.keys(e).length > 1 && this.isRef(e)
    }
    static isArtifactWithRefs(e) {
        return "refs" in e.blob
    }
    static makeRefObj(e, n) {
        if (!this.isObject(n)) return;
        const r = {
                ...e[n.$ref]
            },
            s = Object.keys(n);
        for (let i = 0; i < s.length; i++) {
            const o = s[i];
            o !== "$ref" && (r[o] = n[o])
        }
        return r
    }
    static recurse(e, n) {
        if (this.isObjAndRef(n)) return this.makeRefObj(e, n);
        if (this.isRef(n)) return e[n.$ref];
        if (Array.isArray(n))
            for (let r = 0; r < n.length; r++) {
                const s = this.recurse(e, n[r]);
                s && (n[r] = s)
            }
        if (this.isObject(n)) {
            const r = Object.keys(n);
            for (let s = 0; s < r.length; s++) {
                const i = this.recurse(e, n[r[s]]);
                i && (n[r[s]] = i)
            }
        }
    }
    static hydrate(e) {
        return this.isArtifactWithRefs(e) && (this.recurse(e.blob.refs, e.blob), delete e.blob.refs), e
    }
}
var O0 = {
    exports: {}
};
(function(t, e) {
    var n = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof _n < "u" && _n,
        r = function() {
            function i() {
                this.fetch = !1, this.DOMException = n.DOMException
            }
            return i.prototype = n, new i
        }();
    (function(i) {
        (function(o) {
            var a = typeof i < "u" && i || typeof self < "u" && self || typeof a < "u" && a,
                l = {
                    searchParams: "URLSearchParams" in a,
                    iterable: "Symbol" in a && "iterator" in Symbol,
                    blob: "FileReader" in a && "Blob" in a && function() {
                        try {
                            return new Blob, !0
                        } catch {
                            return !1
                        }
                    }(),
                    formData: "FormData" in a,
                    arrayBuffer: "ArrayBuffer" in a
                };

            function u(K) {
                return K && DataView.prototype.isPrototypeOf(K)
            }
            if (l.arrayBuffer) var f = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                d = ArrayBuffer.isView || function(K) {
                    return K && f.indexOf(Object.prototype.toString.call(K)) > -1
                };

            function p(K) {
                if (typeof K != "string" && (K = String(K)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(K) || K === "") throw new TypeError('Invalid character in header field name: "' + K + '"');
                return K.toLowerCase()
            }

            function _(K) {
                return typeof K != "string" && (K = String(K)), K
            }

            function v(K) {
                var Q = {
                    next: function() {
                        var ue = K.shift();
                        return {
                            done: ue === void 0,
                            value: ue
                        }
                    }
                };
                return l.iterable && (Q[Symbol.iterator] = function() {
                    return Q
                }), Q
            }

            function y(K) {
                this.map = {}, K instanceof y ? K.forEach(function(Q, ue) {
                    this.append(ue, Q)
                }, this) : Array.isArray(K) ? K.forEach(function(Q) {
                    this.append(Q[0], Q[1])
                }, this) : K && Object.getOwnPropertyNames(K).forEach(function(Q) {
                    this.append(Q, K[Q])
                }, this)
            }
            y.prototype.append = function(K, Q) {
                K = p(K), Q = _(Q);
                var ue = this.map[K];
                this.map[K] = ue ? ue + ", " + Q : Q
            }, y.prototype.delete = function(K) {
                delete this.map[p(K)]
            }, y.prototype.get = function(K) {
                return K = p(K), this.has(K) ? this.map[K] : null
            }, y.prototype.has = function(K) {
                return this.map.hasOwnProperty(p(K))
            }, y.prototype.set = function(K, Q) {
                this.map[p(K)] = _(Q)
            }, y.prototype.forEach = function(K, Q) {
                for (var ue in this.map) this.map.hasOwnProperty(ue) && K.call(Q, this.map[ue], ue, this)
            }, y.prototype.keys = function() {
                var K = [];
                return this.forEach(function(Q, ue) {
                    K.push(ue)
                }), v(K)
            }, y.prototype.values = function() {
                var K = [];
                return this.forEach(function(Q) {
                    K.push(Q)
                }), v(K)
            }, y.prototype.entries = function() {
                var K = [];
                return this.forEach(function(Q, ue) {
                    K.push([ue, Q])
                }), v(K)
            }, l.iterable && (y.prototype[Symbol.iterator] = y.prototype.entries);

            function g(K) {
                if (K.bodyUsed) return Promise.reject(new TypeError("Already read"));
                K.bodyUsed = !0
            }

            function b(K) {
                return new Promise(function(Q, ue) {
                    K.onload = function() {
                        Q(K.result)
                    }, K.onerror = function() {
                        ue(K.error)
                    }
                })
            }

            function O(K) {
                var Q = new FileReader,
                    ue = b(Q);
                return Q.readAsArrayBuffer(K), ue
            }

            function N(K) {
                var Q = new FileReader,
                    ue = b(Q);
                return Q.readAsText(K), ue
            }

            function k(K) {
                for (var Q = new Uint8Array(K), ue = new Array(Q.length), _e = 0; _e < Q.length; _e++) ue[_e] = String.fromCharCode(Q[_e]);
                return ue.join("")
            }

            function A(K) {
                if (K.slice) return K.slice(0);
                var Q = new Uint8Array(K.byteLength);
                return Q.set(new Uint8Array(K)), Q.buffer
            }

            function x() {
                return this.bodyUsed = !1, this._initBody = function(K) {
                    this.bodyUsed = this.bodyUsed, this._bodyInit = K, K ? typeof K == "string" ? this._bodyText = K : l.blob && Blob.prototype.isPrototypeOf(K) ? this._bodyBlob = K : l.formData && FormData.prototype.isPrototypeOf(K) ? this._bodyFormData = K : l.searchParams && URLSearchParams.prototype.isPrototypeOf(K) ? this._bodyText = K.toString() : l.arrayBuffer && l.blob && u(K) ? (this._bodyArrayBuffer = A(K.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : l.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(K) || d(K)) ? this._bodyArrayBuffer = A(K) : this._bodyText = K = Object.prototype.toString.call(K) : this._bodyText = "", this.headers.get("content-type") || (typeof K == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : l.searchParams && URLSearchParams.prototype.isPrototypeOf(K) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                }, l.blob && (this.blob = function() {
                    var K = g(this);
                    if (K) return K;
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]))
                }, this.arrayBuffer = function() {
                    if (this._bodyArrayBuffer) {
                        var K = g(this);
                        return K || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
                    } else return this.blob().then(O)
                }), this.text = function() {
                    var K = g(this);
                    if (K) return K;
                    if (this._bodyBlob) return N(this._bodyBlob);
                    if (this._bodyArrayBuffer) return Promise.resolve(k(this._bodyArrayBuffer));
                    if (this._bodyFormData) throw new Error("could not read FormData body as text");
                    return Promise.resolve(this._bodyText)
                }, l.formData && (this.formData = function() {
                    return this.text().then(ee)
                }), this.json = function() {
                    return this.text().then(JSON.parse)
                }, this
            }
            var D = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

            function L(K) {
                var Q = K.toUpperCase();
                return D.indexOf(Q) > -1 ? Q : K
            }

            function q(K, Q) {
                if (!(this instanceof q)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                Q = Q || {};
                var ue = Q.body;
                if (K instanceof q) {
                    if (K.bodyUsed) throw new TypeError("Already read");
                    this.url = K.url, this.credentials = K.credentials, Q.headers || (this.headers = new y(K.headers)), this.method = K.method, this.mode = K.mode, this.signal = K.signal, !ue && K._bodyInit != null && (ue = K._bodyInit, K.bodyUsed = !0)
                } else this.url = String(K);
                if (this.credentials = Q.credentials || this.credentials || "same-origin", (Q.headers || !this.headers) && (this.headers = new y(Q.headers)), this.method = L(Q.method || this.method || "GET"), this.mode = Q.mode || this.mode || null, this.signal = Q.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && ue) throw new TypeError("Body not allowed for GET or HEAD requests");
                if (this._initBody(ue), (this.method === "GET" || this.method === "HEAD") && (Q.cache === "no-store" || Q.cache === "no-cache")) {
                    var _e = /([?&])_=[^&]*/;
                    if (_e.test(this.url)) this.url = this.url.replace(_e, "$1_=" + new Date().getTime());
                    else {
                        var Oe = /\?/;
                        this.url += (Oe.test(this.url) ? "&" : "?") + "_=" + new Date().getTime()
                    }
                }
            }
            q.prototype.clone = function() {
                return new q(this, {
                    body: this._bodyInit
                })
            };

            function ee(K) {
                var Q = new FormData;
                return K.trim().split("&").forEach(function(ue) {
                    if (ue) {
                        var _e = ue.split("="),
                            Oe = _e.shift().replace(/\+/g, " "),
                            Ee = _e.join("=").replace(/\+/g, " ");
                        Q.append(decodeURIComponent(Oe), decodeURIComponent(Ee))
                    }
                }), Q
            }

            function ae(K) {
                var Q = new y,
                    ue = K.replace(/\r?\n[\t ]+/g, " ");
                return ue.split("\r").map(function(_e) {
                    return _e.indexOf(`
`) === 0 ? _e.substr(1, _e.length) : _e
                }).forEach(function(_e) {
                    var Oe = _e.split(":"),
                        Ee = Oe.shift().trim();
                    if (Ee) {
                        var Ce = Oe.join(":").trim();
                        Q.append(Ee, Ce)
                    }
                }), Q
            }
            x.call(q.prototype);

            function Z(K, Q) {
                if (!(this instanceof Z)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                Q || (Q = {}), this.type = "default", this.status = Q.status === void 0 ? 200 : Q.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = Q.statusText === void 0 ? "" : "" + Q.statusText, this.headers = new y(Q.headers), this.url = Q.url || "", this._initBody(K)
            }
            x.call(Z.prototype), Z.prototype.clone = function() {
                return new Z(this._bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new y(this.headers),
                    url: this.url
                })
            }, Z.error = function() {
                var K = new Z(null, {
                    status: 0,
                    statusText: ""
                });
                return K.type = "error", K
            };
            var fe = [301, 302, 303, 307, 308];
            Z.redirect = function(K, Q) {
                if (fe.indexOf(Q) === -1) throw new RangeError("Invalid status code");
                return new Z(null, {
                    status: Q,
                    headers: {
                        location: K
                    }
                })
            }, o.DOMException = a.DOMException;
            try {
                new o.DOMException
            } catch {
                o.DOMException = function(Q, ue) {
                    this.message = Q, this.name = ue;
                    var _e = Error(Q);
                    this.stack = _e.stack
                }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException
            }

            function ge(K, Q) {
                return new Promise(function(ue, _e) {
                    var Oe = new q(K, Q);
                    if (Oe.signal && Oe.signal.aborted) return _e(new o.DOMException("Aborted", "AbortError"));
                    var Ee = new XMLHttpRequest;

                    function Ce() {
                        Ee.abort()
                    }
                    Ee.onload = function() {
                        var Ue = {
                            status: Ee.status,
                            statusText: Ee.statusText,
                            headers: ae(Ee.getAllResponseHeaders() || "")
                        };
                        Ue.url = "responseURL" in Ee ? Ee.responseURL : Ue.headers.get("X-Request-URL");
                        var ot = "response" in Ee ? Ee.response : Ee.responseText;
                        setTimeout(function() {
                            ue(new Z(ot, Ue))
                        }, 0)
                    }, Ee.onerror = function() {
                        setTimeout(function() {
                            _e(new TypeError("Network request failed"))
                        }, 0)
                    }, Ee.ontimeout = function() {
                        setTimeout(function() {
                            _e(new TypeError("Network request failed"))
                        }, 0)
                    }, Ee.onabort = function() {
                        setTimeout(function() {
                            _e(new o.DOMException("Aborted", "AbortError"))
                        }, 0)
                    };

                    function De(Ue) {
                        try {
                            return Ue === "" && a.location.href ? a.location.href : Ue
                        } catch {
                            return Ue
                        }
                    }
                    Ee.open(Oe.method, De(Oe.url), !0), Oe.credentials === "include" ? Ee.withCredentials = !0 : Oe.credentials === "omit" && (Ee.withCredentials = !1), "responseType" in Ee && (l.blob ? Ee.responseType = "blob" : l.arrayBuffer && Oe.headers.get("Content-Type") && Oe.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (Ee.responseType = "arraybuffer")), Q && typeof Q.headers == "object" && !(Q.headers instanceof y) ? Object.getOwnPropertyNames(Q.headers).forEach(function(Ue) {
                        Ee.setRequestHeader(Ue, _(Q.headers[Ue]))
                    }) : Oe.headers.forEach(function(Ue, ot) {
                        Ee.setRequestHeader(ot, Ue)
                    }), Oe.signal && (Oe.signal.addEventListener("abort", Ce), Ee.onreadystatechange = function() {
                        Ee.readyState === 4 && Oe.signal.removeEventListener("abort", Ce)
                    }), Ee.send(typeof Oe._bodyInit > "u" ? null : Oe._bodyInit)
                })
            }
            return ge.polyfill = !0, a.fetch || (a.fetch = ge, a.Headers = y, a.Request = q, a.Response = Z), o.Headers = y, o.Request = q, o.Response = Z, o.fetch = ge, o
        })({})
    })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
    var s = n.fetch ? n : r;
    e = s.fetch, e.default = s.fetch, e.fetch = s.fetch, e.Headers = s.Headers, e.Request = s.Request, e.Response = s.Response, t.exports = e
})(O0, O0.exports);
var PY = O0.exports,
    RY = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var e = {},
            n = Symbol("test"),
            r = Object(n);
        if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]") return !1;
        var s = 42;
        e[n] = s;
        for (n in e) return !1;
        if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
        var i = Object.getOwnPropertySymbols(e);
        if (i.length !== 1 || i[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var o = Object.getOwnPropertyDescriptor(e, n);
            if (o.value !== s || o.enumerable !== !0) return !1
        }
        return !0
    },
    ZT = typeof Symbol < "u" && Symbol,
    MY = RY,
    DY = function() {
        return typeof ZT != "function" || typeof Symbol != "function" || typeof ZT("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : MY()
    },
    $Y = "Function.prototype.bind called on incompatible ",
    ly = Array.prototype.slice,
    LY = Object.prototype.toString,
    FY = "[object Function]",
    UY = function(e) {
        var n = this;
        if (typeof n != "function" || LY.call(n) !== FY) throw new TypeError($Y + n);
        for (var r = ly.call(arguments, 1), s, i = function() {
                if (this instanceof s) {
                    var f = n.apply(this, r.concat(ly.call(arguments)));
                    return Object(f) === f ? f : this
                } else return n.apply(e, r.concat(ly.call(arguments)))
            }, o = Math.max(0, n.length - r.length), a = [], l = 0; l < o; l++) a.push("$" + l);
        if (s = Function("binder", "return function (" + a.join(",") + "){ return binder.apply(this,arguments); }")(i), n.prototype) {
            var u = function() {};
            u.prototype = n.prototype, s.prototype = new u, u.prototype = null
        }
        return s
    },
    BY = UY,
    z2 = Function.prototype.bind || BY,
    qY = z2,
    GY = qY.call(Function.call, Object.prototype.hasOwnProperty),
    Nt, Kl = SyntaxError,
    d9 = Function,
    Il = TypeError,
    uy = function(t) {
        try {
            return d9('"use strict"; return (' + t + ").constructor;")()
        } catch {}
    },
    mc = Object.getOwnPropertyDescriptor;
if (mc) try {
    mc({}, "")
} catch {
    mc = null
}
var hy = function() {
        throw new Il
    },
    VY = mc ? function() {
        try {
            return arguments.callee, hy
        } catch {
            try {
                return mc(arguments, "callee").get
            } catch {
                return hy
            }
        }
    }() : hy,
    sl = DY(),
    qo = Object.getPrototypeOf || function(t) {
        return t.__proto__
    },
    ll = {},
    jY = typeof Uint8Array > "u" ? Nt : qo(Uint8Array),
    Nl = {
        "%AggregateError%": typeof AggregateError > "u" ? Nt : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Nt : ArrayBuffer,
        "%ArrayIteratorPrototype%": sl ? qo([][Symbol.iterator]()) : Nt,
        "%AsyncFromSyncIteratorPrototype%": Nt,
        "%AsyncFunction%": ll,
        "%AsyncGenerator%": ll,
        "%AsyncGeneratorFunction%": ll,
        "%AsyncIteratorPrototype%": ll,
        "%Atomics%": typeof Atomics > "u" ? Nt : Atomics,
        "%BigInt%": typeof BigInt > "u" ? Nt : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? Nt : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array > "u" ? Nt : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? Nt : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Nt : FinalizationRegistry,
        "%Function%": d9,
        "%GeneratorFunction%": ll,
        "%Int8Array%": typeof Int8Array > "u" ? Nt : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? Nt : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? Nt : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": sl ? qo(qo([][Symbol.iterator]())) : Nt,
        "%JSON%": typeof JSON == "object" ? JSON : Nt,
        "%Map%": typeof Map > "u" ? Nt : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !sl ? Nt : qo(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? Nt : Promise,
        "%Proxy%": typeof Proxy > "u" ? Nt : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect > "u" ? Nt : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? Nt : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !sl ? Nt : qo(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Nt : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": sl ? qo("" [Symbol.iterator]()) : Nt,
        "%Symbol%": sl ? Symbol : Nt,
        "%SyntaxError%": Kl,
        "%ThrowTypeError%": VY,
        "%TypedArray%": jY,
        "%TypeError%": Il,
        "%Uint8Array%": typeof Uint8Array > "u" ? Nt : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Nt : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? Nt : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? Nt : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap > "u" ? Nt : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? Nt : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? Nt : WeakSet
    },
    WY = function t(e) {
        var n;
        if (e === "%AsyncFunction%") n = uy("async function () {}");
        else if (e === "%GeneratorFunction%") n = uy("function* () {}");
        else if (e === "%AsyncGeneratorFunction%") n = uy("async function* () {}");
        else if (e === "%AsyncGenerator%") {
            var r = t("%AsyncGeneratorFunction%");
            r && (n = r.prototype)
        } else if (e === "%AsyncIteratorPrototype%") {
            var s = t("%AsyncGenerator%");
            s && (n = qo(s.prototype))
        }
        return Nl[e] = n, n
    },
    XT = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    },
    Ff = z2,
    h1 = GY,
    HY = Ff.call(Function.call, Array.prototype.concat),
    YY = Ff.call(Function.apply, Array.prototype.splice),
    QT = Ff.call(Function.call, String.prototype.replace),
    f1 = Ff.call(Function.call, String.prototype.slice),
    zY = Ff.call(Function.call, RegExp.prototype.exec),
    KY = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    ZY = /\\(\\)?/g,
    XY = function(e) {
        var n = f1(e, 0, 1),
            r = f1(e, -1);
        if (n === "%" && r !== "%") throw new Kl("invalid intrinsic syntax, expected closing `%`");
        if (r === "%" && n !== "%") throw new Kl("invalid intrinsic syntax, expected opening `%`");
        var s = [];
        return QT(e, KY, function(i, o, a, l) {
            s[s.length] = a ? QT(l, ZY, "$1") : o || i
        }), s
    },
    QY = function(e, n) {
        var r = e,
            s;
        if (h1(XT, r) && (s = XT[r], r = "%" + s[0] + "%"), h1(Nl, r)) {
            var i = Nl[r];
            if (i === ll && (i = WY(r)), typeof i > "u" && !n) throw new Il("intrinsic " + e + " exists, but is not available. Please file an issue!");
            return {
                alias: s,
                name: r,
                value: i
            }
        }
        throw new Kl("intrinsic " + e + " does not exist!")
    },
    K2 = function(e, n) {
        if (typeof e != "string" || e.length === 0) throw new Il("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof n != "boolean") throw new Il('"allowMissing" argument must be a boolean');
        if (zY(/^%?[^%]*%?$/g, e) === null) throw new Kl("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var r = XY(e),
            s = r.length > 0 ? r[0] : "",
            i = QY("%" + s + "%", n),
            o = i.name,
            a = i.value,
            l = !1,
            u = i.alias;
        u && (s = u[0], YY(r, HY([0, 1], u)));
        for (var f = 1, d = !0; f < r.length; f += 1) {
            var p = r[f],
                _ = f1(p, 0, 1),
                v = f1(p, -1);
            if ((_ === '"' || _ === "'" || _ === "`" || v === '"' || v === "'" || v === "`") && _ !== v) throw new Kl("property names with quotes must have matching quotes");
            if ((p === "constructor" || !d) && (l = !0), s += "." + p, o = "%" + s + "%", h1(Nl, o)) a = Nl[o];
            else if (a != null) {
                if (!(p in a)) {
                    if (!n) throw new Il("base intrinsic for " + e + " exists, but the property is not available.");
                    return
                }
                if (mc && f + 1 >= r.length) {
                    var y = mc(a, p);
                    d = !!y, d && "get" in y && !("originalValue" in y.get) ? a = y.get : a = a[p]
                } else d = h1(a, p), a = a[p];
                d && !l && (Nl[o] = a)
            }
        }
        return a
    },
    p9 = {
        exports: {}
    };
(function(t) {
    var e = z2,
        n = K2,
        r = n("%Function.prototype.apply%"),
        s = n("%Function.prototype.call%"),
        i = n("%Reflect.apply%", !0) || e.call(s, r),
        o = n("%Object.getOwnPropertyDescriptor%", !0),
        a = n("%Object.defineProperty%", !0),
        l = n("%Math.max%");
    if (a) try {
        a({}, "a", {
            value: 1
        })
    } catch {
        a = null
    }
    t.exports = function(d) {
        var p = i(e, s, arguments);
        if (o && a) {
            var _ = o(p, "length");
            _.configurable && a(p, "length", {
                value: 1 + l(0, d.length - (arguments.length - 1))
            })
        }
        return p
    };
    var u = function() {
        return i(e, r, arguments)
    };
    a ? a(t.exports, "apply", {
        value: u
    }) : t.exports.apply = u
})(p9);
var JY = p9.exports,
    m9 = K2,
    g9 = JY,
    ez = g9(m9("String.prototype.indexOf")),
    tz = function(e, n) {
        var r = m9(e, !!n);
        return typeof r == "function" && ez(e, ".prototype.") > -1 ? g9(r) : r
    };
const nz = {},
    rz = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: nz
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    sz = NB(rz);
var Z2 = typeof Map == "function" && Map.prototype,
    fy = Object.getOwnPropertyDescriptor && Z2 ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
    d1 = Z2 && fy && typeof fy.get == "function" ? fy.get : null,
    iz = Z2 && Map.prototype.forEach,
    X2 = typeof Set == "function" && Set.prototype,
    dy = Object.getOwnPropertyDescriptor && X2 ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
    p1 = X2 && dy && typeof dy.get == "function" ? dy.get : null,
    oz = X2 && Set.prototype.forEach,
    az = typeof WeakMap == "function" && WeakMap.prototype,
    Ah = az ? WeakMap.prototype.has : null,
    cz = typeof WeakSet == "function" && WeakSet.prototype,
    Oh = cz ? WeakSet.prototype.has : null,
    lz = typeof WeakRef == "function" && WeakRef.prototype,
    JT = lz ? WeakRef.prototype.deref : null,
    uz = Boolean.prototype.valueOf,
    hz = Object.prototype.toString,
    fz = Function.prototype.toString,
    dz = String.prototype.match,
    Q2 = String.prototype.slice,
    zo = String.prototype.replace,
    pz = String.prototype.toUpperCase,
    eS = String.prototype.toLowerCase,
    _9 = RegExp.prototype.test,
    tS = Array.prototype.concat,
    bi = Array.prototype.join,
    mz = Array.prototype.slice,
    nS = Math.floor,
    C0 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
    py = Object.getOwnPropertySymbols,
    k0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null,
    Zl = typeof Symbol == "function" && typeof Symbol.iterator == "object",
    fr = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === Zl || "symbol") ? Symbol.toStringTag : null,
    y9 = Object.prototype.propertyIsEnumerable,
    rS = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
        return t.__proto__
    } : null);

function sS(t, e) {
    if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || _9.call(/e/, e)) return e;
    var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof t == "number") {
        var r = t < 0 ? -nS(-t) : nS(t);
        if (r !== t) {
            var s = String(r),
                i = Q2.call(e, s.length + 1);
            return zo.call(s, n, "$&_") + "." + zo.call(zo.call(i, /([0-9]{3})/g, "$&_"), /_$/, "")
        }
    }
    return zo.call(e, n, "$&_")
}
var I0 = sz,
    iS = I0.custom,
    oS = b9(iS) ? iS : null,
    gz = function t(e, n, r, s) {
        var i = n || {};
        if (Go(i, "quoteStyle") && i.quoteStyle !== "single" && i.quoteStyle !== "double") throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (Go(i, "maxStringLength") && (typeof i.maxStringLength == "number" ? i.maxStringLength < 0 && i.maxStringLength !== 1 / 0 : i.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var o = Go(i, "customInspect") ? i.customInspect : !0;
        if (typeof o != "boolean" && o !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (Go(i, "indent") && i.indent !== null && i.indent !== "	" && !(parseInt(i.indent, 10) === i.indent && i.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (Go(i, "numericSeparator") && typeof i.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var a = i.numericSeparator;
        if (typeof e > "u") return "undefined";
        if (e === null) return "null";
        if (typeof e == "boolean") return e ? "true" : "false";
        if (typeof e == "string") return T9(e, i);
        if (typeof e == "number") {
            if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
            var l = String(e);
            return a ? sS(e, l) : l
        }
        if (typeof e == "bigint") {
            var u = String(e) + "n";
            return a ? sS(e, u) : u
        }
        var f = typeof i.depth > "u" ? 5 : i.depth;
        if (typeof r > "u" && (r = 0), r >= f && f > 0 && typeof e == "object") return N0(e) ? "[Array]" : "[Object]";
        var d = Mz(i, r);
        if (typeof s > "u") s = [];
        else if (E9(s, e) >= 0) return "[Circular]";

        function p(fe, ge, K) {
            if (ge && (s = mz.call(s), s.push(ge)), K) {
                var Q = {
                    depth: i.depth
                };
                return Go(i, "quoteStyle") && (Q.quoteStyle = i.quoteStyle), t(fe, Q, r + 1, s)
            }
            return t(fe, i, r + 1, s)
        }
        if (typeof e == "function" && !aS(e)) {
            var _ = Az(e),
                v = op(e, p);
            return "[Function" + (_ ? ": " + _ : " (anonymous)") + "]" + (v.length > 0 ? " { " + bi.call(v, ", ") + " }" : "")
        }
        if (b9(e)) {
            var y = Zl ? zo.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : k0.call(e);
            return typeof e == "object" && !Zl ? ih(y) : y
        }
        if (xz(e)) {
            for (var g = "<" + eS.call(String(e.nodeName)), b = e.attributes || [], O = 0; O < b.length; O++) g += " " + b[O].name + "=" + v9(_z(b[O].value), "double", i);
            return g += ">", e.childNodes && e.childNodes.length && (g += "..."), g += "</" + eS.call(String(e.nodeName)) + ">", g
        }
        if (N0(e)) {
            if (e.length === 0) return "[]";
            var N = op(e, p);
            return d && !Rz(N) ? "[" + x0(N, d) + "]" : "[ " + bi.call(N, ", ") + " ]"
        }
        if (vz(e)) {
            var k = op(e, p);
            return !("cause" in Error.prototype) && "cause" in e && !y9.call(e, "cause") ? "{ [" + String(e) + "] " + bi.call(tS.call("[cause]: " + p(e.cause), k), ", ") + " }" : k.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + bi.call(k, ", ") + " }"
        }
        if (typeof e == "object" && o) {
            if (oS && typeof e[oS] == "function" && I0) return I0(e, {
                depth: f - r
            });
            if (o !== "symbol" && typeof e.inspect == "function") return e.inspect()
        }
        if (Oz(e)) {
            var A = [];
            return iz.call(e, function(fe, ge) {
                A.push(p(ge, e, !0) + " => " + p(fe, e))
            }), cS("Map", d1.call(e), A, d)
        }
        if (Iz(e)) {
            var x = [];
            return oz.call(e, function(fe) {
                x.push(p(fe, e))
            }), cS("Set", p1.call(e), x, d)
        }
        if (Cz(e)) return my("WeakMap");
        if (Nz(e)) return my("WeakSet");
        if (kz(e)) return my("WeakRef");
        if (Ez(e)) return ih(p(Number(e)));
        if (Sz(e)) return ih(p(C0.call(e)));
        if (Tz(e)) return ih(uz.call(e));
        if (bz(e)) return ih(p(String(e)));
        if (!yz(e) && !aS(e)) {
            var D = op(e, p),
                L = rS ? rS(e) === Object.prototype : e instanceof Object || e.constructor === Object,
                q = e instanceof Object ? "" : "null prototype",
                ee = !L && fr && Object(e) === e && fr in e ? Q2.call(Ca(e), 8, -1) : q ? "Object" : "",
                ae = L || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "",
                Z = ae + (ee || q ? "[" + bi.call(tS.call([], ee || [], q || []), ": ") + "] " : "");
            return D.length === 0 ? Z + "{}" : d ? Z + "{" + x0(D, d) + "}" : Z + "{ " + bi.call(D, ", ") + " }"
        }
        return String(e)
    };

function v9(t, e, n) {
    var r = (n.quoteStyle || e) === "double" ? '"' : "'";
    return r + t + r
}

function _z(t) {
    return zo.call(String(t), /"/g, "&quot;")
}

function N0(t) {
    return Ca(t) === "[object Array]" && (!fr || !(typeof t == "object" && fr in t))
}

function yz(t) {
    return Ca(t) === "[object Date]" && (!fr || !(typeof t == "object" && fr in t))
}

function aS(t) {
    return Ca(t) === "[object RegExp]" && (!fr || !(typeof t == "object" && fr in t))
}

function vz(t) {
    return Ca(t) === "[object Error]" && (!fr || !(typeof t == "object" && fr in t))
}

function bz(t) {
    return Ca(t) === "[object String]" && (!fr || !(typeof t == "object" && fr in t))
}

function Ez(t) {
    return Ca(t) === "[object Number]" && (!fr || !(typeof t == "object" && fr in t))
}

function Tz(t) {
    return Ca(t) === "[object Boolean]" && (!fr || !(typeof t == "object" && fr in t))
}

function b9(t) {
    if (Zl) return t && typeof t == "object" && t instanceof Symbol;
    if (typeof t == "symbol") return !0;
    if (!t || typeof t != "object" || !k0) return !1;
    try {
        return k0.call(t), !0
    } catch {}
    return !1
}

function Sz(t) {
    if (!t || typeof t != "object" || !C0) return !1;
    try {
        return C0.call(t), !0
    } catch {}
    return !1
}
var wz = Object.prototype.hasOwnProperty || function(t) {
    return t in this
};

function Go(t, e) {
    return wz.call(t, e)
}

function Ca(t) {
    return hz.call(t)
}

function Az(t) {
    if (t.name) return t.name;
    var e = dz.call(fz.call(t), /^function\s*([\w$]+)/);
    return e ? e[1] : null
}

function E9(t, e) {
    if (t.indexOf) return t.indexOf(e);
    for (var n = 0, r = t.length; n < r; n++)
        if (t[n] === e) return n;
    return -1
}

function Oz(t) {
    if (!d1 || !t || typeof t != "object") return !1;
    try {
        d1.call(t);
        try {
            p1.call(t)
        } catch {
            return !0
        }
        return t instanceof Map
    } catch {}
    return !1
}

function Cz(t) {
    if (!Ah || !t || typeof t != "object") return !1;
    try {
        Ah.call(t, Ah);
        try {
            Oh.call(t, Oh)
        } catch {
            return !0
        }
        return t instanceof WeakMap
    } catch {}
    return !1
}

function kz(t) {
    if (!JT || !t || typeof t != "object") return !1;
    try {
        return JT.call(t), !0
    } catch {}
    return !1
}

function Iz(t) {
    if (!p1 || !t || typeof t != "object") return !1;
    try {
        p1.call(t);
        try {
            d1.call(t)
        } catch {
            return !0
        }
        return t instanceof Set
    } catch {}
    return !1
}

function Nz(t) {
    if (!Oh || !t || typeof t != "object") return !1;
    try {
        Oh.call(t, Oh);
        try {
            Ah.call(t, Ah)
        } catch {
            return !0
        }
        return t instanceof WeakSet
    } catch {}
    return !1
}

function xz(t) {
    return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function"
}

function T9(t, e) {
    if (t.length > e.maxStringLength) {
        var n = t.length - e.maxStringLength,
            r = "... " + n + " more character" + (n > 1 ? "s" : "");
        return T9(Q2.call(t, 0, e.maxStringLength), e) + r
    }
    var s = zo.call(zo.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Pz);
    return v9(s, "single", e)
}

function Pz(t) {
    var e = t.charCodeAt(0),
        n = {
            8: "b",
            9: "t",
            10: "n",
            12: "f",
            13: "r"
        } [e];
    return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + pz.call(e.toString(16))
}

function ih(t) {
    return "Object(" + t + ")"
}

function my(t) {
    return t + " { ? }"
}

function cS(t, e, n, r) {
    var s = r ? x0(n, r) : bi.call(n, ", ");
    return t + " (" + e + ") {" + s + "}"
}

function Rz(t) {
    for (var e = 0; e < t.length; e++)
        if (E9(t[e], `
`) >= 0) return !1;
    return !0
}

function Mz(t, e) {
    var n;
    if (t.indent === "	") n = "	";
    else if (typeof t.indent == "number" && t.indent > 0) n = bi.call(Array(t.indent + 1), " ");
    else return null;
    return {
        base: n,
        prev: bi.call(Array(e + 1), n)
    }
}

function x0(t, e) {
    if (t.length === 0) return "";
    var n = `
` + e.prev + e.base;
    return n + bi.call(t, "," + n) + `
` + e.prev
}

function op(t, e) {
    var n = N0(t),
        r = [];
    if (n) {
        r.length = t.length;
        for (var s = 0; s < t.length; s++) r[s] = Go(t, s) ? e(t[s], t) : ""
    }
    var i = typeof py == "function" ? py(t) : [],
        o;
    if (Zl) {
        o = {};
        for (var a = 0; a < i.length; a++) o["$" + i[a]] = i[a]
    }
    for (var l in t) Go(t, l) && (n && String(Number(l)) === l && l < t.length || Zl && o["$" + l] instanceof Symbol || (_9.call(/[^\w$]/, l) ? r.push(e(l, t) + ": " + e(t[l], t)) : r.push(l + ": " + e(t[l], t))));
    if (typeof py == "function")
        for (var u = 0; u < i.length; u++) y9.call(t, i[u]) && r.push("[" + e(i[u]) + "]: " + e(t[i[u]], t));
    return r
}
var J2 = K2,
    ku = tz,
    Dz = gz,
    $z = J2("%TypeError%"),
    ap = J2("%WeakMap%", !0),
    cp = J2("%Map%", !0),
    Lz = ku("WeakMap.prototype.get", !0),
    Fz = ku("WeakMap.prototype.set", !0),
    Uz = ku("WeakMap.prototype.has", !0),
    Bz = ku("Map.prototype.get", !0),
    qz = ku("Map.prototype.set", !0),
    Gz = ku("Map.prototype.has", !0),
    e3 = function(t, e) {
        for (var n = t, r;
            (r = n.next) !== null; n = r)
            if (r.key === e) return n.next = r.next, r.next = t.next, t.next = r, r
    },
    Vz = function(t, e) {
        var n = e3(t, e);
        return n && n.value
    },
    jz = function(t, e, n) {
        var r = e3(t, e);
        r ? r.value = n : t.next = {
            key: e,
            next: t.next,
            value: n
        }
    },
    Wz = function(t, e) {
        return !!e3(t, e)
    },
    Hz = function() {
        var e, n, r, s = {
            assert: function(i) {
                if (!s.has(i)) throw new $z("Side channel does not contain " + Dz(i))
            },
            get: function(i) {
                if (ap && i && (typeof i == "object" || typeof i == "function")) {
                    if (e) return Lz(e, i)
                } else if (cp) {
                    if (n) return Bz(n, i)
                } else if (r) return Vz(r, i)
            },
            has: function(i) {
                if (ap && i && (typeof i == "object" || typeof i == "function")) {
                    if (e) return Uz(e, i)
                } else if (cp) {
                    if (n) return Gz(n, i)
                } else if (r) return Wz(r, i);
                return !1
            },
            set: function(i, o) {
                ap && i && (typeof i == "object" || typeof i == "function") ? (e || (e = new ap), Fz(e, i, o)) : cp ? (n || (n = new cp), qz(n, i, o)) : (r || (r = {
                    key: {},
                    next: null
                }), jz(r, i, o))
            }
        };
        return s
    },
    Yz = String.prototype.replace,
    zz = /%20/g,
    gy = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
    },
    t3 = {
        default: gy.RFC3986,
        formatters: {
            RFC1738: function(t) {
                return Yz.call(t, zz, "+")
            },
            RFC3986: function(t) {
                return String(t)
            }
        },
        RFC1738: gy.RFC1738,
        RFC3986: gy.RFC3986
    },
    Kz = t3,
    _y = Object.prototype.hasOwnProperty,
    ic = Array.isArray,
    fi = function() {
        for (var t = [], e = 0; e < 256; ++e) t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
        return t
    }(),
    Zz = function(e) {
        for (; e.length > 1;) {
            var n = e.pop(),
                r = n.obj[n.prop];
            if (ic(r)) {
                for (var s = [], i = 0; i < r.length; ++i) typeof r[i] < "u" && s.push(r[i]);
                n.obj[n.prop] = s
            }
        }
    },
    S9 = function(e, n) {
        for (var r = n && n.plainObjects ? Object.create(null) : {}, s = 0; s < e.length; ++s) typeof e[s] < "u" && (r[s] = e[s]);
        return r
    },
    Xz = function t(e, n, r) {
        if (!n) return e;
        if (typeof n != "object") {
            if (ic(e)) e.push(n);
            else if (e && typeof e == "object")(r && (r.plainObjects || r.allowPrototypes) || !_y.call(Object.prototype, n)) && (e[n] = !0);
            else return [e, n];
            return e
        }
        if (!e || typeof e != "object") return [e].concat(n);
        var s = e;
        return ic(e) && !ic(n) && (s = S9(e, r)), ic(e) && ic(n) ? (n.forEach(function(i, o) {
            if (_y.call(e, o)) {
                var a = e[o];
                a && typeof a == "object" && i && typeof i == "object" ? e[o] = t(a, i, r) : e.push(i)
            } else e[o] = i
        }), e) : Object.keys(n).reduce(function(i, o) {
            var a = n[o];
            return _y.call(i, o) ? i[o] = t(i[o], a, r) : i[o] = a, i
        }, s)
    },
    Qz = function(e, n) {
        return Object.keys(n).reduce(function(r, s) {
            return r[s] = n[s], r
        }, e)
    },
    Jz = function(t, e, n) {
        var r = t.replace(/\+/g, " ");
        if (n === "iso-8859-1") return r.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
            return decodeURIComponent(r)
        } catch {
            return r
        }
    },
    eK = function(e, n, r, s, i) {
        if (e.length === 0) return e;
        var o = e;
        if (typeof e == "symbol" ? o = Symbol.prototype.toString.call(e) : typeof e != "string" && (o = String(e)), r === "iso-8859-1") return escape(o).replace(/%u[0-9a-f]{4}/gi, function(f) {
            return "%26%23" + parseInt(f.slice(2), 16) + "%3B"
        });
        for (var a = "", l = 0; l < o.length; ++l) {
            var u = o.charCodeAt(l);
            if (u === 45 || u === 46 || u === 95 || u === 126 || u >= 48 && u <= 57 || u >= 65 && u <= 90 || u >= 97 && u <= 122 || i === Kz.RFC1738 && (u === 40 || u === 41)) {
                a += o.charAt(l);
                continue
            }
            if (u < 128) {
                a = a + fi[u];
                continue
            }
            if (u < 2048) {
                a = a + (fi[192 | u >> 6] + fi[128 | u & 63]);
                continue
            }
            if (u < 55296 || u >= 57344) {
                a = a + (fi[224 | u >> 12] + fi[128 | u >> 6 & 63] + fi[128 | u & 63]);
                continue
            }
            l += 1, u = 65536 + ((u & 1023) << 10 | o.charCodeAt(l) & 1023), a += fi[240 | u >> 18] + fi[128 | u >> 12 & 63] + fi[128 | u >> 6 & 63] + fi[128 | u & 63]
        }
        return a
    },
    tK = function(e) {
        for (var n = [{
                obj: {
                    o: e
                },
                prop: "o"
            }], r = [], s = 0; s < n.length; ++s)
            for (var i = n[s], o = i.obj[i.prop], a = Object.keys(o), l = 0; l < a.length; ++l) {
                var u = a[l],
                    f = o[u];
                typeof f == "object" && f !== null && r.indexOf(f) === -1 && (n.push({
                    obj: o,
                    prop: u
                }), r.push(f))
            }
        return Zz(n), e
    },
    nK = function(e) {
        return Object.prototype.toString.call(e) === "[object RegExp]"
    },
    rK = function(e) {
        return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
    },
    sK = function(e, n) {
        return [].concat(e, n)
    },
    iK = function(e, n) {
        if (ic(e)) {
            for (var r = [], s = 0; s < e.length; s += 1) r.push(n(e[s]));
            return r
        }
        return n(e)
    },
    w9 = {
        arrayToObject: S9,
        assign: Qz,
        combine: sK,
        compact: tK,
        decode: Jz,
        encode: eK,
        isBuffer: rK,
        isRegExp: nK,
        maybeMap: iK,
        merge: Xz
    },
    A9 = Hz,
    Lp = w9,
    Ch = t3,
    oK = Object.prototype.hasOwnProperty,
    lS = {
        brackets: function(e) {
            return e + "[]"
        },
        comma: "comma",
        indices: function(e, n) {
            return e + "[" + n + "]"
        },
        repeat: function(e) {
            return e
        }
    },
    ro = Array.isArray,
    aK = Array.prototype.push,
    O9 = function(t, e) {
        aK.apply(t, ro(e) ? e : [e])
    },
    cK = Date.prototype.toISOString,
    uS = Ch.default,
    ar = {
        addQueryPrefix: !1,
        allowDots: !1,
        charset: "utf-8",
        charsetSentinel: !1,
        delimiter: "&",
        encode: !0,
        encoder: Lp.encode,
        encodeValuesOnly: !1,
        format: uS,
        formatter: Ch.formatters[uS],
        indices: !1,
        serializeDate: function(e) {
            return cK.call(e)
        },
        skipNulls: !1,
        strictNullHandling: !1
    },
    lK = function(e) {
        return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint"
    },
    yy = {},
    uK = function t(e, n, r, s, i, o, a, l, u, f, d, p, _, v, y, g) {
        for (var b = e, O = g, N = 0, k = !1;
            (O = O.get(yy)) !== void 0 && !k;) {
            var A = O.get(e);
            if (N += 1, typeof A < "u") {
                if (A === N) throw new RangeError("Cyclic object value");
                k = !0
            }
            typeof O.get(yy) > "u" && (N = 0)
        }
        if (typeof l == "function" ? b = l(n, b) : b instanceof Date ? b = d(b) : r === "comma" && ro(b) && (b = Lp.maybeMap(b, function(Q) {
                return Q instanceof Date ? d(Q) : Q
            })), b === null) {
            if (i) return a && !v ? a(n, ar.encoder, y, "key", p) : n;
            b = ""
        }
        if (lK(b) || Lp.isBuffer(b)) {
            if (a) {
                var x = v ? n : a(n, ar.encoder, y, "key", p);
                return [_(x) + "=" + _(a(b, ar.encoder, y, "value", p))]
            }
            return [_(n) + "=" + _(String(b))]
        }
        var D = [];
        if (typeof b > "u") return D;
        var L;
        if (r === "comma" && ro(b)) v && a && (b = Lp.maybeMap(b, a)), L = [{
            value: b.length > 0 ? b.join(",") || null : void 0
        }];
        else if (ro(l)) L = l;
        else {
            var q = Object.keys(b);
            L = u ? q.sort(u) : q
        }
        for (var ee = s && ro(b) && b.length === 1 ? n + "[]" : n, ae = 0; ae < L.length; ++ae) {
            var Z = L[ae],
                fe = typeof Z == "object" && typeof Z.value < "u" ? Z.value : b[Z];
            if (!(o && fe === null)) {
                var ge = ro(b) ? typeof r == "function" ? r(ee, Z) : ee : ee + (f ? "." + Z : "[" + Z + "]");
                g.set(e, N);
                var K = A9();
                K.set(yy, g), O9(D, t(fe, ge, r, s, i, o, r === "comma" && v && ro(b) ? null : a, l, u, f, d, p, _, v, y, K))
            }
        }
        return D
    },
    hK = function(e) {
        if (!e) return ar;
        if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function") throw new TypeError("Encoder has to be a function.");
        var n = e.charset || ar.charset;
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var r = Ch.default;
        if (typeof e.format < "u") {
            if (!oK.call(Ch.formatters, e.format)) throw new TypeError("Unknown format option provided.");
            r = e.format
        }
        var s = Ch.formatters[r],
            i = ar.filter;
        return (typeof e.filter == "function" || ro(e.filter)) && (i = e.filter), {
            addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : ar.addQueryPrefix,
            allowDots: typeof e.allowDots > "u" ? ar.allowDots : !!e.allowDots,
            charset: n,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : ar.charsetSentinel,
            delimiter: typeof e.delimiter > "u" ? ar.delimiter : e.delimiter,
            encode: typeof e.encode == "boolean" ? e.encode : ar.encode,
            encoder: typeof e.encoder == "function" ? e.encoder : ar.encoder,
            encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : ar.encodeValuesOnly,
            filter: i,
            format: r,
            formatter: s,
            serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : ar.serializeDate,
            skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : ar.skipNulls,
            sort: typeof e.sort == "function" ? e.sort : null,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : ar.strictNullHandling
        }
    },
    fK = function(t, e) {
        var n = t,
            r = hK(e),
            s, i;
        typeof r.filter == "function" ? (i = r.filter, n = i("", n)) : ro(r.filter) && (i = r.filter, s = i);
        var o = [];
        if (typeof n != "object" || n === null) return "";
        var a;
        e && e.arrayFormat in lS ? a = e.arrayFormat : e && "indices" in e ? a = e.indices ? "indices" : "repeat" : a = "indices";
        var l = lS[a];
        if (e && "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var u = l === "comma" && e && e.commaRoundTrip;
        s || (s = Object.keys(n)), r.sort && s.sort(r.sort);
        for (var f = A9(), d = 0; d < s.length; ++d) {
            var p = s[d];
            r.skipNulls && n[p] === null || O9(o, uK(n[p], p, l, u, r.strictNullHandling, r.skipNulls, r.encode ? r.encoder : null, r.filter, r.sort, r.allowDots, r.serializeDate, r.format, r.formatter, r.encodeValuesOnly, r.charset, f))
        }
        var _ = o.join(r.delimiter),
            v = r.addQueryPrefix === !0 ? "?" : "";
        return r.charsetSentinel && (r.charset === "iso-8859-1" ? v += "utf8=%26%2310003%3B&" : v += "utf8=%E2%9C%93&"), _.length > 0 ? v + _ : ""
    },
    Xl = w9,
    P0 = Object.prototype.hasOwnProperty,
    dK = Array.isArray,
    Gn = {
        allowDots: !1,
        allowPrototypes: !1,
        allowSparse: !1,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: !1,
        comma: !1,
        decoder: Xl.decode,
        delimiter: "&",
        depth: 5,
        ignoreQueryPrefix: !1,
        interpretNumericEntities: !1,
        parameterLimit: 1e3,
        parseArrays: !0,
        plainObjects: !1,
        strictNullHandling: !1
    },
    pK = function(t) {
        return t.replace(/&#(\d+);/g, function(e, n) {
            return String.fromCharCode(parseInt(n, 10))
        })
    },
    C9 = function(t, e) {
        return t && typeof t == "string" && e.comma && t.indexOf(",") > -1 ? t.split(",") : t
    },
    mK = "utf8=%26%2310003%3B",
    gK = "utf8=%E2%9C%93",
    _K = function(e, n) {
        var r = {
                __proto__: null
            },
            s = n.ignoreQueryPrefix ? e.replace(/^\?/, "") : e,
            i = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit,
            o = s.split(n.delimiter, i),
            a = -1,
            l, u = n.charset;
        if (n.charsetSentinel)
            for (l = 0; l < o.length; ++l) o[l].indexOf("utf8=") === 0 && (o[l] === gK ? u = "utf-8" : o[l] === mK && (u = "iso-8859-1"), a = l, l = o.length);
        for (l = 0; l < o.length; ++l)
            if (l !== a) {
                var f = o[l],
                    d = f.indexOf("]="),
                    p = d === -1 ? f.indexOf("=") : d + 1,
                    _, v;
                p === -1 ? (_ = n.decoder(f, Gn.decoder, u, "key"), v = n.strictNullHandling ? null : "") : (_ = n.decoder(f.slice(0, p), Gn.decoder, u, "key"), v = Xl.maybeMap(C9(f.slice(p + 1), n), function(y) {
                    return n.decoder(y, Gn.decoder, u, "value")
                })), v && n.interpretNumericEntities && u === "iso-8859-1" && (v = pK(v)), f.indexOf("[]=") > -1 && (v = dK(v) ? [v] : v), P0.call(r, _) ? r[_] = Xl.combine(r[_], v) : r[_] = v
            } return r
    },
    yK = function(t, e, n, r) {
        for (var s = r ? e : C9(e, n), i = t.length - 1; i >= 0; --i) {
            var o, a = t[i];
            if (a === "[]" && n.parseArrays) o = [].concat(s);
            else {
                o = n.plainObjects ? Object.create(null) : {};
                var l = a.charAt(0) === "[" && a.charAt(a.length - 1) === "]" ? a.slice(1, -1) : a,
                    u = parseInt(l, 10);
                !n.parseArrays && l === "" ? o = {
                    0: s
                } : !isNaN(u) && a !== l && String(u) === l && u >= 0 && n.parseArrays && u <= n.arrayLimit ? (o = [], o[u] = s) : l !== "__proto__" && (o[l] = s)
            }
            s = o
        }
        return s
    },
    vK = function(e, n, r, s) {
        if (e) {
            var i = r.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
                o = /(\[[^[\]]*])/,
                a = /(\[[^[\]]*])/g,
                l = r.depth > 0 && o.exec(i),
                u = l ? i.slice(0, l.index) : i,
                f = [];
            if (u) {
                if (!r.plainObjects && P0.call(Object.prototype, u) && !r.allowPrototypes) return;
                f.push(u)
            }
            for (var d = 0; r.depth > 0 && (l = a.exec(i)) !== null && d < r.depth;) {
                if (d += 1, !r.plainObjects && P0.call(Object.prototype, l[1].slice(1, -1)) && !r.allowPrototypes) return;
                f.push(l[1])
            }
            return l && f.push("[" + i.slice(l.index) + "]"), yK(f, n, r, s)
        }
    },
    bK = function(e) {
        if (!e) return Gn;
        if (e.decoder !== null && e.decoder !== void 0 && typeof e.decoder != "function") throw new TypeError("Decoder has to be a function.");
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var n = typeof e.charset > "u" ? Gn.charset : e.charset;
        return {
            allowDots: typeof e.allowDots > "u" ? Gn.allowDots : !!e.allowDots,
            allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : Gn.allowPrototypes,
            allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : Gn.allowSparse,
            arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : Gn.arrayLimit,
            charset: n,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Gn.charsetSentinel,
            comma: typeof e.comma == "boolean" ? e.comma : Gn.comma,
            decoder: typeof e.decoder == "function" ? e.decoder : Gn.decoder,
            delimiter: typeof e.delimiter == "string" || Xl.isRegExp(e.delimiter) ? e.delimiter : Gn.delimiter,
            depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : Gn.depth,
            ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
            interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : Gn.interpretNumericEntities,
            parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : Gn.parameterLimit,
            parseArrays: e.parseArrays !== !1,
            plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : Gn.plainObjects,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Gn.strictNullHandling
        }
    },
    EK = function(t, e) {
        var n = bK(e);
        if (t === "" || t === null || typeof t > "u") return n.plainObjects ? Object.create(null) : {};
        for (var r = typeof t == "string" ? _K(t, n) : t, s = n.plainObjects ? Object.create(null) : {}, i = Object.keys(r), o = 0; o < i.length; ++o) {
            var a = i[o],
                l = vK(a, r[a], n, typeof t == "string");
            s = Xl.merge(s, l, n)
        }
        return n.allowSparse === !0 ? s : Xl.compact(s)
    },
    TK = fK,
    SK = EK,
    wK = t3,
    k9 = {
        formats: wK,
        parse: SK,
        stringify: TK
    };
let AK = class {
        constructor(e) {
            this.code = e.code, this.token = e.token, this.host = e.host
        }
    },
    OK = class {
        constructor(e) {
            this.appId = e.appId, this.appTag = e.appTag, this.audienceEnabled = e.audienceEnabled, this.code = e.code, this.host = e.host, this.audienceHost = e.audienceHost, this.locked = e.locked, this.full = e.full, this.maxPlayers = e.maxPlayers, this.minPlayers = e.minPlayers, this.moderationEnabled = e.moderationEnabled, this.passwordRequired = e.passwordRequired, this.twitchLocked = e.twitchLocked, this.locale = e.locale, this.keepalive = e.keepalive, this.controllerBranch = e.controllerBranch
        }
    },
    CK = class {
        constructor(e) {
            this.connections = e.connections
        }
    },
    kK = class {
        constructor(e) {
            this.cause = e.cause
        }
        whenReceived(e) {
            e.disconnect()
        }
    },
    IK = class {};
var Xm = {
    CreateRoomReply: AK,
    GetRoomReply: OK,
    GetAudienceReply: CK,
    RoomExit: kK,
    RoomLock: IK
};
const hS = PY,
    NK = k9,
    {
        CreateRoomReply: xK,
        GetRoomReply: PK
    } = Xm;
let RK = class {
    constructor(e) {
        if (!e.host) throw new Error("unable to create ecast APIClient: no host provided");
        if (this.host = e.host, !e.scheme) throw new Error("unable to create ecast APIClient: no scheme provided");
        this.scheme = e.scheme
    }
    url(e, n) {
        if (n) {
            let r = NK.stringify(n);
            return `${this.scheme}://${this.host}/api/v2${e}?${r}`
        }
        return `${this.scheme}://${this.host}/api/v2${e}`
    }
    async createRoom(e) {
        let n = {
                appTag: "test",
                userId: "fart",
                ...e
            },
            r = this.url("/rooms", n),
            i = await hS(r, {
                method: "POST"
            });
        const {
            body: o,
            error: a,
            ok: l
        } = await i.json();
        if (!l) throw new Error(`failed to create room: ${a}`);
        return new xK({
            code: o.code,
            token: o.token,
            host: o.host
        })
    }
    async getRoom(e) {
        let n = this.url(`/rooms/${e.code}`),
            s = await (await hS(n)).json();
        if (!s.ok) throw new Error(`unable to get room with options ${JSON.stringify(e)}: ${s.error}`);
        let i = s.body;
        return new PK({
            appId: i.appId,
            appTag: i.appTag,
            audienceEnabled: i.audienceEnabled,
            code: i.code,
            host: i.host,
            audienceHost: i.audienceHost,
            locked: i.locked,
            full: i.full,
            maxPlayers: i.maxPlayers,
            minPlayers: i.minPlayers,
            moderationEnabled: i.moderationEnabled,
            passwordRequired: i.passwordRequired,
            twitchLocked: i.twitchLocked,
            locale: i.locale,
            keepalive: i.keepalive,
            controllerBranch: i.controllerBranch
        })
    }
};
var MK = {
        APIClient: RK
    },
    ul = null;
typeof WebSocket < "u" ? ul = WebSocket : typeof MozWebSocket < "u" ? ul = MozWebSocket : typeof _n < "u" ? ul = _n.WebSocket || _n.MozWebSocket : typeof window < "u" ? ul = window.WebSocket || window.MozWebSocket : typeof self < "u" && (ul = self.WebSocket || self.MozWebSocket);
var DK = ul,
    n3 = {
        exports: {}
    },
    xl = typeof Reflect == "object" ? Reflect : null,
    fS = xl && typeof xl.apply == "function" ? xl.apply : function(e, n, r) {
        return Function.prototype.apply.call(e, n, r)
    },
    Fp;
xl && typeof xl.ownKeys == "function" ? Fp = xl.ownKeys : Object.getOwnPropertySymbols ? Fp = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
} : Fp = function(e) {
    return Object.getOwnPropertyNames(e)
};

function $K(t) {
    console && console.warn && console.warn(t)
}
var I9 = Number.isNaN || function(e) {
    return e !== e
};

function Vt() {
    Vt.init.call(this)
}
n3.exports = Vt;
n3.exports.once = BK;
Vt.EventEmitter = Vt;
Vt.prototype._events = void 0;
Vt.prototype._eventsCount = 0;
Vt.prototype._maxListeners = void 0;
var dS = 10;

function Qm(t) {
    if (typeof t != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
}
Object.defineProperty(Vt, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
        return dS
    },
    set: function(t) {
        if (typeof t != "number" || t < 0 || I9(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
        dS = t
    }
});
Vt.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
};
Vt.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || I9(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this
};

function N9(t) {
    return t._maxListeners === void 0 ? Vt.defaultMaxListeners : t._maxListeners
}
Vt.prototype.getMaxListeners = function() {
    return N9(this)
};
Vt.prototype.emit = function(e) {
    for (var n = [], r = 1; r < arguments.length; r++) n.push(arguments[r]);
    var s = e === "error",
        i = this._events;
    if (i !== void 0) s = s && i.error === void 0;
    else if (!s) return !1;
    if (s) {
        var o;
        if (n.length > 0 && (o = n[0]), o instanceof Error) throw o;
        var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
        throw a.context = o, a
    }
    var l = i[e];
    if (l === void 0) return !1;
    if (typeof l == "function") fS(l, this, n);
    else
        for (var u = l.length, f = D9(l, u), r = 0; r < u; ++r) fS(f[r], this, n);
    return !0
};

function x9(t, e, n, r) {
    var s, i, o;
    if (Qm(n), i = t._events, i === void 0 ? (i = t._events = Object.create(null), t._eventsCount = 0) : (i.newListener !== void 0 && (t.emit("newListener", e, n.listener ? n.listener : n), i = t._events), o = i[e]), o === void 0) o = i[e] = n, ++t._eventsCount;
    else if (typeof o == "function" ? o = i[e] = r ? [n, o] : [o, n] : r ? o.unshift(n) : o.push(n), s = N9(t), s > 0 && o.length > s && !o.warned) {
        o.warned = !0;
        var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        a.name = "MaxListenersExceededWarning", a.emitter = t, a.type = e, a.count = o.length, $K(a)
    }
    return t
}
Vt.prototype.addListener = function(e, n) {
    return x9(this, e, n, !1)
};
Vt.prototype.on = Vt.prototype.addListener;
Vt.prototype.prependListener = function(e, n) {
    return x9(this, e, n, !0)
};

function LK() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
}

function P9(t, e, n) {
    var r = {
            fired: !1,
            wrapFn: void 0,
            target: t,
            type: e,
            listener: n
        },
        s = LK.bind(r);
    return s.listener = n, r.wrapFn = s, s
}
Vt.prototype.once = function(e, n) {
    return Qm(n), this.on(e, P9(this, e, n)), this
};
Vt.prototype.prependOnceListener = function(e, n) {
    return Qm(n), this.prependListener(e, P9(this, e, n)), this
};
Vt.prototype.removeListener = function(e, n) {
    var r, s, i, o, a;
    if (Qm(n), s = this._events, s === void 0) return this;
    if (r = s[e], r === void 0) return this;
    if (r === n || r.listener === n) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete s[e], s.removeListener && this.emit("removeListener", e, r.listener || n));
    else if (typeof r != "function") {
        for (i = -1, o = r.length - 1; o >= 0; o--)
            if (r[o] === n || r[o].listener === n) {
                a = r[o].listener, i = o;
                break
            } if (i < 0) return this;
        i === 0 ? r.shift() : FK(r, i), r.length === 1 && (s[e] = r[0]), s.removeListener !== void 0 && this.emit("removeListener", e, a || n)
    }
    return this
};
Vt.prototype.off = Vt.prototype.removeListener;
Vt.prototype.removeAllListeners = function(e) {
    var n, r, s;
    if (r = this._events, r === void 0) return this;
    if (r.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r[e]), this;
    if (arguments.length === 0) {
        var i = Object.keys(r),
            o;
        for (s = 0; s < i.length; ++s) o = i[s], o !== "removeListener" && this.removeAllListeners(o);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
    }
    if (n = r[e], typeof n == "function") this.removeListener(e, n);
    else if (n !== void 0)
        for (s = n.length - 1; s >= 0; s--) this.removeListener(e, n[s]);
    return this
};

function R9(t, e, n) {
    var r = t._events;
    if (r === void 0) return [];
    var s = r[e];
    return s === void 0 ? [] : typeof s == "function" ? n ? [s.listener || s] : [s] : n ? UK(s) : D9(s, s.length)
}
Vt.prototype.listeners = function(e) {
    return R9(this, e, !0)
};
Vt.prototype.rawListeners = function(e) {
    return R9(this, e, !1)
};
Vt.listenerCount = function(t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : M9.call(t, e)
};
Vt.prototype.listenerCount = M9;

function M9(t) {
    var e = this._events;
    if (e !== void 0) {
        var n = e[t];
        if (typeof n == "function") return 1;
        if (n !== void 0) return n.length
    }
    return 0
}
Vt.prototype.eventNames = function() {
    return this._eventsCount > 0 ? Fp(this._events) : []
};

function D9(t, e) {
    for (var n = new Array(e), r = 0; r < e; ++r) n[r] = t[r];
    return n
}

function FK(t, e) {
    for (; e + 1 < t.length; e++) t[e] = t[e + 1];
    t.pop()
}

function UK(t) {
    for (var e = new Array(t.length), n = 0; n < e.length; ++n) e[n] = t[n].listener || t[n];
    return e
}

function BK(t, e) {
    return new Promise(function(n, r) {
        function s(o) {
            t.removeListener(e, i), r(o)
        }

        function i() {
            typeof t.removeListener == "function" && t.removeListener("error", s), n([].slice.call(arguments))
        }
        $9(t, e, i, {
            once: !0
        }), e !== "error" && qK(t, s, {
            once: !0
        })
    })
}

function qK(t, e, n) {
    typeof t.on == "function" && $9(t, "error", e, n)
}

function $9(t, e, n, r) {
    if (typeof t.on == "function") r.once ? t.once(e, n) : t.on(e, n);
    else if (typeof t.addEventListener == "function") t.addEventListener(e, function s(i) {
        r.once && t.removeEventListener(e, s), n(i)
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t)
}
var GK = n3.exports;
let VK = class {
        constructor(e) {
            e && (this.error = e.error, this.to = e.to, this.opcode = e.opcode)
        }
        toString() {
            return `ObservedError{
	to:${this.to}
	error:${this.error}
	opcode:${this.opcode}
}`
        }
    },
    Jm = class extends Error {
        constructor(e) {
            super(e), e && (this.code = e.code, this.message = e.message)
        }
    };
class Uf extends Jm {
    constructor(e) {
        super(e), this.code = 1e3, this.message = e && e.message ? e.message : "ecast server error"
    }
}
class L9 extends Uf {
    constructor(e) {
        super(e), this.code = 1001, this.message = e && e.message ? e.message : "create room failed"
    }
}
class F9 extends Uf {
    constructor(e) {
        super(e), this.code = 1002, this.message = e && e.message ? e.message : "unable to connect to room"
    }
}
class U9 extends Uf {
    constructor(e) {
        super(e), this.code = 1003, this.message = e && e.message ? e.message : "server is shutting down"
    }
}
class Ft extends Jm {
    constructor(e) {
        super(e), this.code = 2e3, this.message = e && e.message ? e.message : "ecast client error"
    }
}
class B9 extends Ft {
    constructor(e) {
        super(e), this.code = 2001, this.message = e && e.message ? e.message : "parse error in ecast protocol"
    }
}
class q9 extends Ft {
    constructor(e) {
        super(e), this.code = 2002, this.message = e && e.message ? e.message : "missing opcode"
    }
}
class G9 extends Ft {
    constructor(e) {
        super(e), this.code = 2003, this.message = e && e.message ? e.message : "invalid opcode"
    }
}
class V9 extends Ft {
    constructor(e) {
        super(e), this.code = 2004, this.message = e && e.message ? e.message : "invalid arguments"
    }
}
class j9 extends Ft {
    constructor(e) {
        super(e), this.code = 2005, this.message = e && e.message ? e.message : "entity not found"
    }
}
class W9 extends Ft {
    constructor(e) {
        super(e), this.code = 2006, this.message = e && e.message ? e.message : "an entity already exists with that key"
    }
}
class H9 extends Ft {
    constructor(e) {
        super(e), this.code = 2007, this.message = e && e.message ? e.message : "the entity is not of the expected type"
    }
}
class Y9 extends Ft {
    constructor(e) {
        super(e), this.code = 2008, this.message = e && e.message ? e.message : "no such client"
    }
}
class z9 extends Ft {
    constructor(e) {
        super(e), this.code = 2009, this.message = e && e.message ? e.message : "room is locked"
    }
}
class K9 extends Ft {
    constructor(e) {
        super(e), this.code = 2010, this.message = e && e.message ? e.message : "room is full"
    }
}
class Z9 extends Ft {
    constructor(e) {
        super(e), this.code = 2011, this.message = e && e.message ? e.message : "no such license"
    }
}
class X9 extends Ft {
    constructor(e) {
        super(e), this.code = 2012, this.message = e && e.message ? e.message : "invalid license"
    }
}
class Q9 extends Ft {
    constructor(e) {
        super(e), this.code = 2013, this.message = e && e.message ? e.message : "room not found"
    }
}
class J9 extends Ft {
    constructor(e) {
        super(e), this.code = 2014, this.message = e && e.message ? e.message : "requested role does not exist"
    }
}
class eA extends Ft {
    constructor(e) {
        super(e), this.code = 2015, this.message = e && e.message ? e.message : "twitch login required"
    }
}
class tA extends Ft {
    constructor(e) {
        super(e), this.code = 2016, this.message = e && e.message ? e.message : "no such option"
    }
}
class nA extends Ft {
    constructor(e) {
        super(e), this.code = 2017, this.message = e && e.message ? e.message : "password required"
    }
}
class rA extends Ft {
    constructor(e) {
        super(e), this.code = 2018, this.message = e && e.message ? e.message : "invalid room password"
    }
}
class sA extends Ft {
    constructor(e) {
        super(e), this.code = 2019, this.message = e && e.message ? e.message : "missing name"
    }
}
class iA extends Ft {
    constructor(e) {
        super(e), this.code = 2021, this.message = e && e.message ? e.message : "text did not pass text filters"
    }
}
class oA extends Ft {
    constructor(e) {
        super(e), this.code = 2022, this.message = e && e.message ? e.message : "no such filter"
    }
}
class aA extends Ft {
    constructor(e) {
        super(e), this.code = 2023, this.message = e && e.message ? e.message : "permission denied"
    }
}
class cA extends Ft {
    constructor(e) {
        super(e), this.code = 2024, this.message = e && e.message ? e.message : "not connected to a room"
    }
}
class lA extends Ft {
    constructor(e) {
        super(e), this.code = 2025, this.message = e && e.message ? e.message : "illegal operation"
    }
}
class uA extends Ft {
    constructor(e) {
        super(e), this.code = 2026, this.message = e && e.message ? e.message : "invalid ACL change"
    }
}
class hA extends Ft {
    constructor(e) {
        super(e), this.code = 2027, this.message = e && e.message ? e.message : "room has already ended"
    }
}
class fA extends Ft {
    constructor(e) {
        super(e), this.code = 2028, this.message = e && e.message ? e.message : "the entity is locked"
    }
}
class dA extends Ft {
    constructor(e) {
        super(e), this.code = 2420, this.message = e && e.message ? e.message : "rate limit exceeded"
    }
}

function jK({
    code: t,
    message: e
}) {
    const n = WK[t];
    return n ? new n({
        message: e
    }) : new Jm({
        message: e
    })
}
var kh = {
    createError: jK,
    CallError: Jm,
    EcastServerError: Uf,
    EcastCreateRoomFailed: L9,
    EcastDialRoomFailed: F9,
    EcastServerIsShuttingDown: U9,
    EcastClientError: Ft,
    EcastParseError: B9,
    EcastRequestIsMissingOpcode: q9,
    EcastRequestHasInvalidOpcode: G9,
    EcastRequestHasInvalidArguments: V9,
    EcastEntityNotFound: j9,
    EcastEntityAlreadyExists: W9,
    EcastEntityTypeError: H9,
    EcastNoSuchClient: Y9,
    EcastRoomIsLocked: z9,
    EcastRoomIsFull: K9,
    EcastLicenseNotFound: Z9,
    EcastLicenseCheckFailed: X9,
    EcastRoomNotFound: Q9,
    EcastInvalidRole: J9,
    EcastTwitchLoginRequired: eA,
    EcastInvalidOption: tA,
    EcastPasswordRequired: nA,
    EcastInvalidPassword: rA,
    EcastNameRequired: sA,
    EcastFilterError: iA,
    EcastNoSuchFilter: oA,
    EcastPermissionDenied: aA,
    EcastNotConnected: cA,
    EcastIllegalOperation: lA,
    EcastACLChangeDenied: uA,
    EcastRoomHasEnded: hA,
    EcastEntityLocked: fA,
    EcastRateLimitExceeded: dA,
    ObservedError: VK
};
const WK = {
    1e3: Uf,
    1001: L9,
    1002: F9,
    1003: U9,
    2e3: Ft,
    2001: B9,
    2002: q9,
    2003: G9,
    2004: V9,
    2005: j9,
    2006: W9,
    2007: H9,
    2008: Y9,
    2009: z9,
    2010: K9,
    2011: Z9,
    2012: X9,
    2013: Q9,
    2014: J9,
    2015: eA,
    2016: tA,
    2017: nA,
    2018: rA,
    2019: sA,
    2021: iA,
    2022: oA,
    2023: aA,
    2024: cA,
    2025: lA,
    2026: uA,
    2027: hA,
    2028: fA,
    2420: dA
};
let HK = class {
        constructor(e) {
            this.id = e.id, this.deviceId = e.deviceId, this.name = e.name, this.secret = e.secret, this.reconnect = e.reconnect, this.entities = e.entities, this.here = e.here, this.profile = e.profile, this.replayEnd = e.replayEnd
        }
    },
    YK = class {
        constructor(e) {
            this.id = e.id, this.userId = e.userId, this.name = e.name, this.role = e.role, this.reconnect = e.reconnect
        }
    },
    zK = class {
        constructor(e) {
            this.id = e.id, this.role = e.role
        }
    },
    KK = class {
        constructor(e) {
            this.to = e.to, this.from = e.from, this.body = e.body, this.userId = e.userId
        }
    },
    ZK = class {
        constructor(e) {
            this.id = e.id, this.banned = e.banned, this.reason = e.reason
        }
    };
var r3 = {
    ClientConnected: YK,
    ClientDisconnected: zK,
    ClientKicked: ZK,
    ClientSend: KK,
    ClientWelcome: HK
};
let XK = class {
    constructor(e) {
        this.choices = e.choices, this.key = e.key, this.meta = e.meta || {}
    }
    whenReceived(e) {
        e.entities[this.key] = this
    }
    toString() {
        return `CountGroup{
	choices: ${this.choices}
	meta:${JSON.stringify(this.meta)}
}`
    }
};
var s3 = {
    CountGroup: XK
};
let QK = class {
        constructor(e) {
            this.key = e.key, this.colors = e.colors, this.lines = e.lines, this.live = e.live, this.maxLayer = e.maxLayer, this.maxPoints = e.maxPoints, this.size = e.size, this.weights = e.weights, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `Doodle{
	key:${this.key}
	colors:${this.colors}
	lines:${this.lines}
	live:${this.live}
	maxLayer:${this.maxLayer}
	maxPoints:${this.maxPoints}
	size:${this.size}
	weights:${this.weights}
	meta:${JSON.stringify(this.meta)}
}`
        }
    },
    JK = class {
        constructor(e) {
            this.key = e.key, this.line = e.line
        }
        whenReceived(e) {
            e.entities[this.key].lines.push(this.line)
        }
        toString() {
            return `DoodleLine{
	val:${this.line}
}`
        }
    },
    eZ = class {
        constructor(e) {
            this.key = e.key, this.index = e.index
        }
        whenReceived(e) {
            e.entities[this.key].lines.splice(this.index, 1)
        }
        toString() {
            return `DoodleLineRemoved{
	index:${this.index}
}`
        }
    };
var i3 = {
    DoodleEntity: QK,
    DoodleLine: JK,
    DoodleLineRemoved: eZ
};
let tZ = class {
    constructor(e) {
        this.key = e.key, this.count = e.count, this.meta = e.meta || {}
    }
    whenReceived(e) {
        e.entities[this.key] = this
    }
    toString() {
        return `GCounter{
	count:${this.count}
	meta:${this.meta}
}`
    }
};
var o3 = {
    GCounter: tZ
};
let nZ = class {
    constructor(e) {
        this.pc = e.pc, this.opcode = e.opcode, this.result = e.result
    }
};
var pA = {
    Notification: nZ
};
let rZ = class mA {
    constructor(e) {
        this.from = e.from, this.key = e.key, this.val = e.val, this.restrictions = e.restrictions, this.version = e.version, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
    }
    whenReceived(e) {
        if (e.entities[this.key] && e.entities[this.key] instanceof mA && !this.restrictions) {
            e.entities[this.key].val = this.val, e.entities[this.key].meta = this.meta, e.entities[this.key].version = this.version, e.entities[this.key].from = this.from;
            return
        }
        e.entities[this.key] = this
    }
    toString() {
        return `NumberEntity{
	key:${this.key}
	val: ${this.val}
	restrictions: ${JSON.stringify(this.restrictions)}
	meta: ${JSON.stringify(this.meta)}
}`
    }
};
var a3 = {
    NumberEntity: rZ
};
let sZ = class {
        constructor(e) {
            this.from = e.from, this.key = e.key, this.val = e.val, this.version = e.version, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `ObjectEntity{
	key:${this.key}
	value: ${JSON.stringify(this.val)}
	meta:${JSON.stringify(this.meta)}
}`
        }
        toBlob() {
            return this.val
        }
    },
    iZ = class {
        constructor(e) {
            this.message = e.message
        }
        toString() {
            return `ObjectEcho{message: ${this.message}}`
        }
    };
var c3 = {
    ObjectEntity: sZ,
    ObjectEcho: iZ
};
let oZ = class {
    constructor(e) {
        this.key = e.key, this.count = e.count, this.meta = e.meta || {}
    }
    whenReceived(e) {
        e.entities[this.key] = this
    }
    toString() {
        return `PNCounter{
	count:${this.count}
	meta:${JSON.stringify(this.meta)}
}`
    }
};
var l3 = {
    PNCounter: oZ
};
let aZ = class {
    constructor(e) {
        this.pc = e.pc, this.re = e.re, this.opcode = e.opcode, this.result = e.result
    }
};
var gA = {
    Reply: aZ
};
let cZ = class {
    constructor(e) {
        this.seq = e.seq, this.opcode = e.opcode, this.params = e.params
    }
};
var lZ = {
    Request: cZ
};
let uZ = class {
        constructor(e) {
            this.key = e.key, this.size = e.size, this.version = e.version, this.from = e.from, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
        }
        whenRecived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `Stack{
	key:${this.key}
	size:${this.size}
	version:${this.version}
	from:${this.from}
	meta:${this.meta}
}`
        }
    },
    hZ = class {
        constructor(e) {
            this.key = e.key, this.val = e.val
        }
        toString() {
            return `StackElement{
	key:${this.key}
	value: ${JSON.stringify(this.val)}
}`
        }
    },
    fZ = class {
        constructor(e) {
            this.key = e.key, this.vals = e.vals
        }
        toString() {
            return `StackElements{
	key:${this.key}
	values: ${JSON.stringify(this.vals)}
}`
        }
    };
var _A = {
    StackEntity: uZ,
    StackElement: hZ,
    StackElements: fZ
};
let dZ = class {
        constructor(e) {
            this.from = e.from, this.key = e.key, this.text = e.text, this.version = e.version, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
        }
        whenReceived(e) {
            e.entities[this.key] = this, e.emit("text " + this.key, this)
        }
        toString() {
            return `TextEntity{
	key: ${this.key}
	text: ${this.text}
	meta:${JSON.stringify(this.meta)}
}`
        }
        toBlob() {
            return JSON.parse(this.text)
        }
    },
    pZ = class {
        constructor(e) {
            this.message = e.message
        }
        toString() {
            return `TextEcho{
	key: ${this.key}
	message: ${this.message}
}`
        }
    };
var u3 = {
    TextEntity: dZ,
    TextEcho: pZ
};
let mZ = class {
        constructor(e) {
            this.from = e.from, this.key = e.key, this.meta = e.meta || {}, this.root = e.root, e.acl && (this.acl = e.acl)
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `TextMap{
	key:${this.key}
	meta:${JSON.stringify(this.meta)}
}`
        }
    },
    gZ = class {
        constructor(e) {
            this.from = e.from, this.key = e.key, this.msg = e.msg
        }
        toString() {
            const e = this.msg ? this.msg.join(", ") : this.msg;
            return `TextMapSynced{
	key:${this.key}
	from:${this.from}
	msg:${e}
}`
        }
    },
    _Z = class {
        constructor(e) {
            this.from = e.from, this.key = e.key, this.text = e.text, this.attributions = e.attributions
        }
        toString() {
            return `TextMapState{
	key: ${this.key}
	from:${this.from}
	text:${this.text}
	attributions:${this.attributions}
}`
        }
    };
var h3 = {
    TextMapEntity: mZ,
    TextMapSynced: gZ,
    TextMapState: _Z
};
let yZ = class {
    constructor(e) {
        this.key = e.key, this.elements = e.elements, this.limit = e.limit, this.meta = e.meta || {}
    }
    whenReceived(e) {
        e.entities[this.key] = this
    }
    toString() {
        return `TextRing{
	elements: ${this.elements}
	meta:${JSON.stringify(this.meta)}
}`
    }
};
var f3 = {
    TextRing: yZ
};
let vZ = class {
    constructor(e) {
        this.key = e.key, this.artifactId = e.artifactId, this.categoryId = e.categoryId, this.rootId = e.rootId, this.meta = e.meta || {}
    }
    whenReceived(e) {
        e.entities[this.key] = this
    }
    toString() {
        return `ArtifactEntity${JSON.stringify(this)}
`
    }
};
var yA = {
    ArtifactEntity: vZ
};
let bZ = class {
    constructor(e) {
        this.key = e.key
    }
    whenReceived(e) {
        delete e.entities[this.key]
    }
    toString() {
        return `DropEntity{
	key:${this.key}
}`
    }
};
var vA = {
    DropEntity: bZ
};
let EZ = class {
    constructor(e) {
        this.message = e.message
    }
    toString() {
        return `Echo{message: ${this.message}
}`
    }
};
var TZ = {
    Echo: EZ
};
let SZ = class {
    constructor(e) {
        this.key = e.key, this.from = e.from
    }
    whenReceived(e) {
        e.entities[this.key] && (e.entities[this.key].meta.locked = !0)
    }
    toString() {
        return `LockEntity{
	key:${this.key}
}`
    }
};
var wZ = {
    LockEntity: SZ
};
let AZ = class {
    constructor() {}
    toString() {
        return "OK"
    }
};
var bA = {
    OK: AZ
};
const {
    ArtifactEntity: OZ
} = yA, {
    ClientWelcome: CZ,
    ClientConnected: kZ,
    ClientDisconnected: IZ,
    ClientKicked: NZ,
    ClientSend: xZ
} = r3, {
    CountGroup: PZ
} = s3, {
    DoodleEntity: RZ,
    DoodleLine: MZ,
    DoodleLineRemoved: DZ
} = i3, {
    StackEntity: $Z,
    StackElement: LZ,
    StackElements: FZ
} = _A, {
    DropEntity: UZ
} = vA, {
    Echo: BZ
} = TZ, {
    LockEntity: qZ
} = wZ, {
    GCounter: GZ
} = o3, {
    GetAudienceReply: VZ,
    RoomExit: jZ,
    RoomLock: WZ
} = Xm, {
    Notification: HZ
} = pA, {
    OK: YZ
} = bA, {
    NumberEntity: zZ
} = a3, {
    ObjectEcho: KZ,
    ObjectEntity: ZZ
} = c3, {
    PNCounter: pS
} = l3, {
    Reply: XZ
} = gA, {
    TextEcho: QZ,
    TextEntity: JZ
} = u3, {
    TextRing: eX
} = f3, {
    createError: mS,
    ObservedError: tX
} = kh, {
    TextMapEntity: nX,
    TextMapSynced: rX,
    TextMapState: sX
} = h3;

function R0(t, e, n) {
    switch (t) {
        case "ok":
            return new YZ;
        case "echo":
            return new BZ({
                message: e.message
            });
        case "lock":
            return new qZ({
                key: e.key,
                from: e.from
            });
        case "error":
            return mS({
                code: e.code,
                message: e.msg
            });
        case "error/observed":
            return new tX({
                to: e.to,
                opcode: e.opcode,
                error: mS({
                    code: e.error.code,
                    message: e.error.msg
                })
            });
        case "string":
            return e;
        case "text":
            return new JZ({
                from: e.from,
                key: e.key,
                text: e.val,
                version: e.version,
                meta: n,
                acl: e.acl
            });
        case "text/echo":
            return new QZ({
                message: e.message
            });
        case "object":
            return new ZZ({
                from: e.from,
                key: e.key,
                val: e.val,
                meta: n,
                acl: e.acl
            });
        case "object/echo":
            return new KZ({
                message: e.message
            });
        case "drop":
            return new UZ({
                key: e.key
            });
        case "artifact":
            return new OZ({
                key: e.key,
                artifactId: e.artifactId,
                categoryId: e.categoryId,
                rootId: e.rootId,
                meta: n
            });
        case "client/connected":
            return new kZ({
                id: e.id,
                userId: e.userId,
                name: e.name,
                role: e.role,
                reconnect: e.reconnect
            });
        case "client/disconnected":
            return new IZ({
                id: e.id,
                role: e.role
            });
        case "client/kicked":
            return new NZ({
                id: e.id,
                banned: e.banned,
                reason: e.reason
            });
        case "client/send":
            return new xZ({
                to: e.to,
                from: e.from,
                body: e.body,
                userId: e.userID
            });
        case "client/welcome": {
            let r = new CZ({
                id: e.id,
                name: e.name,
                secret: e.secret,
                reconnect: e.reconnect,
                here: e.here,
                profile: e.profile,
                replayEnd: e.replayEnd
            });
            if (e.entities) {
                let s = {};
                Object.entries(e.entities).forEach(([i, o]) => {
                    s[i] = R0(o[0], o[1], o[2])
                }), r.entities = s
            }
            return r
        }
        case "doodle":
            return new RZ({
                key: e.key,
                colors: e.val.colors,
                lines: e.val.lines,
                live: e.val.live,
                maxLayer: e.val.maxLayer,
                maxPoints: e.val.maxPoints,
                size: e.val.size,
                weights: e.val.weights,
                meta: n,
                acl: e.acl
            });
        case "doodle/line":
            return new MZ({
                key: e.key,
                line: e.val
            });
        case "doodle/line/removed":
            return new DZ({
                key: e.key,
                index: e.index
            });
        case "stack":
            return new $Z({
                key: e.key,
                size: e.size,
                from: e.from,
                version: e.version,
                meta: e.meta,
                acl: e.acl
            });
        case "stack/element":
            return new LZ({
                key: e.key,
                val: e.val
            });
        case "stack/elements":
            return new FZ({
                key: e.key,
                vals: e.vals
            });
        case "number":
            return new zZ({
                key: e.key,
                val: e.val,
                restrictions: e.restrictions,
                from: e.from,
                version: e.version,
                meta: n,
                acl: e.acl
            });
        case "text-map":
            return new nX({
                key: e.key,
                from: e.from,
                root: e.root,
                meta: n,
                acl: e.acl
            });
        case "text-map/state":
            return new sX({
                key: e.key,
                from: e.from,
                attributions: e.attributions,
                text: e.text
            });
        case "text-map/synced":
            return new rX({
                key: e.key,
                from: e.from,
                msg: e.msg
            });
        case "room/exit":
            return new jZ({
                cause: e.cause
            });
        case "room/lock":
            return new WZ;
        case "room/get-audience":
            return new VZ({
                connections: e.connections
            });
        case "audience":
            return new pS({
                key: t,
                count: e[1]
            });
        case "audience/count-group":
            return new PZ({
                key: e.key,
                choices: e.choices,
                meta: n
            });
        case "audience/text-ring":
            return new eX({
                key: e.key,
                elements: e.elements,
                meta: n
            });
        case "audience/g-counter":
            return new GZ({
                key: e.key,
                count: e.count,
                meta: n
            });
        case "audience/pn-counter":
            return new pS({
                key: e.key,
                count: e.count,
                meta: n
            });
        default:
            return console.error(`failed to parse result of type ${t}: ${JSON.stringify(e,null,2)}`), e
    }
}

function iX(t) {
    let e = JSON.parse(t.data),
        n = e.opcode || e.type;
    return e.re ? new XZ({
        pc: e.pc,
        re: e.re,
        opcode: n,
        result: R0(n, e.result)
    }) : new HZ({
        pc: e.pc,
        opcode: n,
        result: R0(n, e.result)
    })
}
var oX = {
    parseResponseMessage: iX
};
const gS = DK,
    aX = k9,
    cX = GK,
    {
        CallError: lX
    } = kh,
    {
        ClientWelcome: uX
    } = r3,
    {
        CountGroup: hX
    } = s3,
    {
        DoodleEntity: fX
    } = i3,
    {
        GCounter: dX
    } = o3,
    {
        Notification: _S
    } = pA,
    {
        NumberEntity: pX
    } = a3,
    {
        ObjectEntity: vy
    } = c3,
    {
        PNCounter: mX
    } = l3,
    {
        Reply: gX
    } = gA,
    {
        Request: _X
    } = lZ,
    {
        StackEntity: yX
    } = _A,
    {
        TextEntity: by
    } = u3,
    {
        TextMapEntity: vX
    } = h3,
    {
        TextRing: bX
    } = f3,
    {
        parseResponseMessage: EX
    } = oX,
    TX = 1e3 + Math.floor(Math.random() * 500),
    yS = 13e3;
let SX = class extends cX {
    constructor(e) {
        if (super(), this.debug = e.debug || !1, !e.host) throw new Error("unable to create ecast WSClient: no host provided");
        if (this.host = e.host, !e.code) throw new Error("unable to create ecast WSClient: no room code provided");
        if (this.code = e.code, e.scheme ? this.scheme = e.scheme : this.scheme = "wss", e.secret && e.id) this.id = e.id, this.secret = e.secret;
        else {
            switch (e.role) {
                case "player":
                    if (!e.name) throw new Error("unable to create ecast WSClient: no name provided");
                    break;
                case "host":
                    if (!e.token) throw new Error("unable to create ecast WSClient: tried to connect with host role but without host token");
                    this.token = e.token;
                    break;
                case "moderator":
                    if (!e.password) throw new Error("unable to create ecast WSClient: tried to connect with moderator role but without password");
                    break
            }
            e.password && (this.password = e.password), e.twitchToken && (this.twitchToken = e.twitchToken)
        }
        this.name = e.name, this.role = e.role, this.deviceId = e.deviceId, this.userId = e.userId, this.conn = null, this.seq = 0, this.pending = {}, this.entities = {}, e.role == "host" && (this.replaySince = e.replaySince || 0, this.syncEntities = e.syncEntities || !1)
    }
    connect() {
        const e = {
            id: this.id,
            role: this.role,
            name: this.name,
            format: "json",
            "user-id": this.userId,
            password: this.password
        };
        this.deviceId && (e["device-id"] = this.deviceId), this.twitchToken && (e["twitch-token"] = this.twitchToken), this.secret && (e.secret = this.secret), this.role === "host" && (e["host-token"] = this.token, this.replaySince > 0 && (e["replay-since"] = this.replaySince), this.syncEntities && (e["sync-entities"] = this.syncEntities));
        const n = aX.stringify(e),
            r = this.role === "audience" || this.id > 1e7 ? `${this.scheme}://${this.host}/api/v2/audience/${this.code}/play?${n}` : `${this.scheme}://${this.host}/api/v2/rooms/${this.code}/play?${n}`;
        return new Promise((s, i) => {
            let o = !1,
                a = !1,
                l = f => {
                    s(f), o = !0
                },
                u = f => {
                    i(f), o = !0
                };
            this.conn = new gS(r, "ecast-v0"), this.conn.onmessage = f => {
                this.debugLog(`recv <- ${JSON.stringify(JSON.parse(f.data),null,2)}`);
                const d = EX(f);
                if (d instanceof gX) this.onReply(d);
                else if (d instanceof _S) {
                    if (d.result instanceof uX) a = !0, this.id = d.result.id, this.deviceId = d.result.deviceId, this.entities = d.result.entities, this.secret = d.result.secret, d.result.name && (this.name = d.result.name), l(d.result);
                    else if (!o) {
                        u(d.result);
                        return
                    }
                    this.onNotification(d)
                } else console.error(`failed to parse response messsage: ${d}`)
            }, this.conn.onerror = f => {
                o ? this.emit("socketError", f) : u(f)
            }, this.conn.onclose = f => {
                this.debugLog("onclose", f.code), a && f.code === 1006 ? this.reconnect() : this.emit("socketClose", f)
            }, this.conn.onopen = f => {
                this.emit("socketOpen", f)
            }
        })
    }
    sleep(e) {
        return new Promise(n => setTimeout(n, e))
    }
    debugLog(...e) {
        this.debug && console.log(`%c[WSClient:${this.name}]`, "background-color:blue;color:white;", ...e)
    }
    async reconnect() {
        this.disconnect(), this.debugLog("Attempting to reconnect");
        let e = 1,
            n = TX;
        for (;;) try {
            this.emit("connection", {
                status: "connecting",
                attempt: e
            }), await this.connect(), this.debugLog("reconnected"), this.emit("connection", {
                status: "connected"
            });
            return
        } catch (r) {
            if (this.debugLog("reconnect error", r), r.code === 1005 || r.code === 1e3) {
                this.debugLog("unable to reconnect!", r), this.emit("socketClose", r);
                return
            }
            if (n >= yS) {
                this.debugLog("reconnect failed!", r), this.emit("socketClose", r);
                return
            }
            e += 1, this.debugLog("waiting", n), this.emit("connection", {
                status: "waiting",
                attempt: e
            }), await this.sleep(n), n = Math.min(yS, n * 2)
        }
    }
    disconnect() {
        this.conn && (this.conn.close(), this.conn.onmessage = null, this.conn.onerror = null, this.conn.onopen = null, this.conn.onclose = null, this.conn = null)
    }
    onReply(e) {
        const n = e.re,
            r = this.pending[n];
        if (!r) {
            const s = new _S(e);
            s.re = n, this.emit("notification", s);
            return
        }
        delete this.pending[n], e.result instanceof lX ? r.reject(e.result) : r.resolve(e.result)
    }
    onNotification(e) {
        typeof e.result.whenReceived == "function" && e.result.whenReceived(this), this.emit("notification", e), this.emit(e.opcode, e.result)
    }
    send(e, n = {}) {
        if (!this.conn) throw new Error("No connection available");
        if (this.conn.readyState !== gS.OPEN) throw new Error(`Socket not ready to send, readyState is ${this.conn.readyState}`);
        const r = ++this.seq,
            s = new _X({
                seq: r,
                opcode: e,
                params: n
            }),
            i = new Promise((a, l) => {
                this.pending[r] = {
                    resolve: a,
                    reject: l,
                    request: s
                }
            }),
            o = JSON.stringify(s);
        return this.debugLog(`send -> ${o}`), this.conn.send(o), i
    }
    lockRoom() {
        return this.send("room/lock")
    }
    startAudience() {
        return this.send("room/start-audience")
    }
    getAudience() {
        return this.send("room/get-audience")
    }
    mail(e, n) {
        return this.send("client/send", {
            from: this.id,
            to: e,
            body: n
        })
    }
    kick(e, n = !1, r) {
        return this.send("client/kick", {
            id: e,
            ban: n,
            reason: r
        })
    }
    async drop(e) {
        const n = await this.send("drop", {
            key: e
        });
        return delete this.entities[e], n
    }
    echo(e) {
        return this.send("echo", {
            message: e
        })
    }
    async lock(e) {
        const n = await this.send("lock", {
            key: e
        });
        return this.entities[e].meta.locked = !0, n
    }
    async createNumber(e, n = {}) {
        let r = {
            key: e
        };
        const {
            val: s = 0,
            acl: i,
            min: o,
            max: a,
            increment: l,
            type: u
        } = n;
        r.val = s, i && (r.acl = i), o != null && (r.min = o), a != null && (r.max = a), l && (r.increment = l), u && (r.type = u);
        const f = await this.send("number/create", r);
        return this.entities[e] = new pX({
            key: e,
            val: s,
            restrictions: {
                min: o,
                max: a,
                increment: l,
                type: u
            },
            meta: {
                locked: !1
            }
        }), f
    }
    async decrementNumber(e) {
        const n = await this.send("number/decrement", {
            key: e
        });
        return this.entities[e].val = n.val, n
    }
    async getNumber(e) {
        const n = await this.send("number/get", {
            key: e
        });
        return this.entities[e] ? (this.entities[e].val = n.val, this.entities[e].restrictions = n.restrictions) : this.entities[e] = n, n
    }
    async incrementNumber(e) {
        const n = await this.send("number/increment", {
            key: e
        });
        return this.entities[e].val = n.val, n
    }
    async updateNumber(e, n) {
        const r = await this.send("number/update", {
            key: e,
            val: n
        });
        return this.entities[e].val = n, r
    }
    async createObject(e, n, r) {
        const s = {
            key: e,
            val: n
        };
        r && (s.acl = r);
        const i = await this.send("object/create", s);
        return this.entities[e] = new vy({
            key: e,
            val: n,
            meta: {
                locked: !1
            }
        }), i
    }
    echoObject(e) {
        return this.send("object/echo", {
            message: e
        })
    }
    async getObject(e) {
        const n = await this.send("object/get", {
            key: e
        });
        return this.entities[e] ? (this.entities[e].val = n.val, this.entities[e].version = n.version, this.entities[e].from = n.from) : this.entities[e] = n, n
    }
    async setObject(e, n, r) {
        const s = {
            key: e,
            val: n
        };
        r && (s.acl = r);
        const i = await this.send("object/set", s);
        return this.entities[e] = new vy({
            key: e,
            val: n,
            meta: {
                locked: !1
            }
        }), i
    }
    async updateObject(e, n) {
        const r = await this.send("object/update", {
            key: e,
            val: n
        });
        return this.entities[e] = new vy({
            key: e,
            val: n,
            meta: {
                locked: !1
            }
        }), r
    }
    echoText(e) {
        return this.send("text/echo", {
            message: e
        })
    }
    getText(e) {
        return this.send("text/get", {
            key: e
        })
    }
    async createText(e, n, r) {
        const s = {
                key: e,
                val: n
            },
            {
                acl: i,
                accept: o,
                reject: a
            } = r;
        i && (s.acl = i), o && (s.accept = o), a && (s.reject = a);
        const l = await this.send("text/create", s);
        return this.entities[e] = new by({
            key: e,
            text: n,
            meta: {
                locked: !1
            }
        }), l
    }
    async setText(e, n, r) {
        const s = {
            key: e,
            val: n
        };
        r && (s.acl = r);
        const i = await this.send("text/set", s);
        return this.entities[e] = new by({
            key: e,
            text: n,
            meta: {
                locked: !1
            }
        }), i
    }
    async updateText(e, n) {
        const r = await this.send("text/update", {
            key: e,
            val: n
        });
        return this.entities[e] = new by({
            key: e,
            text: n,
            meta: {
                locked: !1
            }
        }), r
    }
    async createTextMap(e, n = {}) {
        const {
            val: r,
            notifyHost: s,
            acl: i,
            accept: o,
            reject: a
        } = n;
        let l = {
            key: e
        };
        r && (l.val = n.val), s && (l.notifyHost = n.notifyHost), i && (l.acl = i), o && (l.accept = o), a && (l.reject = a);
        const u = await this.send("text-map/create", l);
        return this.entities[e] = new vX({
            key: e,
            acl: i,
            meta: {
                locked: !1
            }
        }), u
    }
    async syncTextMap(e, n) {
        return await this.send("text-map/sync", {
            key: e,
            msg: n
        })
    }
    async getTextMap(e, n) {
        const {
            includeNodes: r
        } = n;
        return await this.send("text-map/get", {
            key: e,
            includeNodes: r
        })
    }
    async createDoodle(e, n) {
        let r = {
            key: e
        };
        const {
            acl: s,
            colors: i,
            live: o,
            maxLayer: a,
            maxPoints: l,
            size: u,
            weights: f
        } = n;
        s && (r.acl = s), i && (r.colors = i), r.live = o, a != null && (r.maxLayer = a), l != null && (r.maxPoints = l), u && (r.size = u), f && (r.weights = f);
        const d = await this.send("doodle/create", r);
        return this.entities[e] = new fX({
            key: e,
            colors: i,
            lines: [],
            live: o,
            maxLayer: r.maxLayer || 0,
            maxPoints: r.maxPoints || 0,
            size: u,
            weights: f,
            meta: {
                locked: !1
            }
        }), d
    }
    async getDoodle(e) {
        const n = await this.send("doodle/get", {
            key: e
        });
        return this.entities[e] ? this.entities[e].lines = n.lines : this.entities[e] = n, n
    }
    async strokeDoodle(e, n) {
        const {
            color: r,
            weight: s,
            layer: i,
            points: o,
            brush: a
        } = n, l = {
            color: r,
            weight: s,
            layer: i,
            points: o
        };
        a && (l.brush = a);
        const u = await this.send("doodle/stroke", {
            key: e,
            ...l
        });
        return this.entities[e].lines.push(l), u
    }
    async undoDoodle(e) {
        const n = await this.send("doodle/undo", {
            key: e
        });
        return this.entities[e].lines.pop(), n
    }
    async createStack(e, n) {
        const r = {
            key: e
        };
        n && (r.acl = n);
        const s = await this.send("stack/create", r);
        return this.entities[e] = new yX({
            key: e,
            size: 0,
            meta: {
                locked: !1
            }
        }), s
    }
    pushStack(e, n) {
        return this.send("stack/push", {
            key: e,
            val: n
        })
    }
    bulkPushStack(e, n) {
        return this.send("stack/bulkpush", {
            key: e,
            vals: n
        })
    }
    peekStack(e, n) {
        return this.send("stack/peek", {
            key: e,
            size: n
        })
    }
    popStack(e) {
        return this.send("stack/pop", {
            key: e
        })
    }
    async createCountGroup(e, n) {
        const r = await this.send("audience/count-group/create", {
            name: e,
            options: n
        });
        return this.entities[e] = new hX({
            key: e,
            choices: n,
            meta: {
                locked: !1
            }
        }), r
    }
    incrementCountGroupCounter(e, n, r = 1) {
        return this.send("audience/count-group/increment", {
            name: e,
            vote: n,
            times: r
        })
    }
    getCountGroup(e) {
        return this.send("audience/count-group/get", {
            name: e
        })
    }
    async createGCounter(e, n) {
        const r = await this.send("audience/g-counter/create", {
            key: e,
            count: n
        });
        return this.entities[e] = new dX({
            key: e,
            count: n,
            meta: {
                locked: !1
            }
        }), r
    }
    incrementGCounter(e, n) {
        return this.send("audience/g-counter/increment", {
            key: e,
            times: n
        })
    }
    getGCounter(e) {
        return this.send("audience/g-counter/get", {
            key: e
        })
    }
    async createPNCounter(e, n) {
        const r = await this.send("audience/pn-counter/create", {
            key: e,
            count: n
        });
        return this.entities[e] = new mX({
            key: e,
            count: n,
            meta: {
                locked: !1
            }
        }), r
    }
    incrementPNCounter(e, n) {
        return this.send("audience/pn-counter/increment", {
            key: e,
            times: n
        })
    }
    decrementPNCounter(e, n) {
        return this.send("audience/pn-counter/decrement", {
            key: e,
            times: n
        })
    }
    getPNCounter(e) {
        return this.send("audience/pn-counter/get", {
            key: e
        })
    }
    async createTextRing(e, n) {
        const r = {
                key: e
            },
            {
                limit: s,
                accept: i,
                reject: o
            } = n;
        s && (r.limit = s), i && (r.accept = i), o && (r.reject = o);
        const a = await this.send("audience/text-ring/create", r);
        return this.entities[e] = new bX({
            key: e,
            elements: [],
            limit: s,
            meta: {
                locked: !1
            }
        }), a
    }
    getTextRing(e) {
        return this.send("audience/text-ring/get", {
            name: e
        })
    }
    pushTextRing(e, n) {
        return this.send("audience/text-ring/push", {
            name: e,
            text: n
        })
    }
};
var wX = {
    WSClient: SX
};
const {
    APIClient: AX
} = MK, {
    WSClient: OX
} = wX, {
    CreateRoomReply: CX,
    GetRoomReply: kX
} = Xm, {
    ClientWelcome: IX,
    ClientDisconnected: NX
} = r3, {
    ArtifactEntity: xX
} = yA, {
    GCounter: PX
} = o3, {
    NumberEntity: RX
} = a3, {
    TextEntity: MX
} = u3, {
    DoodleEntity: DX
} = i3, {
    ObjectEntity: $X
} = c3, {
    CountGroup: LX
} = s3, {
    DropEntity: FX
} = vA, {
    OK: UX
} = bA, {
    RoomExit: BX
} = Xm, {
    TextRing: qX
} = f3, {
    TextMapEntity: GX
} = h3, {
    PNCounter: VX
} = l3;
var Pr = {
    APIClient: AX,
    WSClient: OX,
    ClientWelcome: IX,
    CreateRoomReply: CX,
    DropEntity: FX,
    GetRoomReply: kX,
    ClientDisconnected: NX,
    RoomExit: BX,
    OK: UX,
    ArtifactEntity: xX,
    DoodleEntity: DX,
    NumberEntity: RX,
    CountGroup: LX,
    GCounter: PX,
    ObjectEntity: $X,
    PNCounter: VX,
    TextEntity: MX,
    TextRing: qX,
    TextMapEntity: GX
};

function M0(...t) {
    console.log(...t)
}
class jX {
    constructor(e, n) {
        ye(this, "client");
        ye(this, "room");
        ye(this, "items", []);
        ye(this, "autoMarkWindow", 150);
        ye(this, "autoMarkTimeout");
        ye(this, "autoMarkerCount", 0);
        ye(this, "automarkIgnoredKeys", []);
        ye(this, "automarkPendingLabel");
        window.tv.debug = this.expose(), this.client = e, this.room = n, Object.keys(this.client.entities).forEach(r => {
            this.pushEntity(this.client.entities[r])
        }), this.items.length && this.setMarker("welcome"), e.on("artifact", r => this.pushEntity(r)), e.on("doodle", r => this.pushEntity(r)), e.on("drop", r => this.pushEntity(r)), e.on("number", r => this.pushEntity(r)), e.on("object", r => this.pushEntity(r)), e.on("text", r => this.pushEntity(r)), this.hijackConsole(), this.hijackSend()
    }
    get markerCount() {
        return this.items.reduce((e, n) => "marker" in n ? e + 1 : e, 0)
    }
    reset() {
        this.items = []
    }
    setAutomarkIgnoredKeys(e) {
        this.automarkIgnoredKeys = e
    }
    hijackConsole() {
        const e = console.error.bind(console);
        console.error = (...n) => {
            this.pushError(n), e.apply(console, n)
        }
    }
    hijackSend() {
        window.Proxy && (this.client.send = new Proxy(this.client.send, {
            apply: (e, n, r) => (this.pushSend(r), e.apply(n, r))
        }))
    }
    pushEntity(e) {
        M0("[Debug] pushEntity", e), e instanceof Pr.ArtifactEntity ? this.items.push({
            type: "artifact",
            ...e
        }) : e instanceof Pr.DoodleEntity ? this.items.push({
            type: "doodle",
            ...e
        }) : e instanceof Pr.DropEntity ? this.items.push({
            key: e.key,
            type: "drop"
        }) : e instanceof Pr.NumberEntity ? this.items.push({
            key: e.key,
            type: "number",
            value: e.val,
            meta: e.meta,
            restrictions: e.restrictions
        }) : e instanceof Pr.ObjectEntity ? (e.val.kind && (this.automarkPendingLabel = e.val.kind), this.items.push({
            key: e.key,
            type: "object",
            value: e.val,
            meta: e.meta
        })) : e instanceof Pr.TextEntity && this.items.push({
            key: e.key,
            type: "text",
            value: e.text,
            meta: e.meta
        }), !this.automarkIgnoredKeys.includes(e.key) && this.startAutoMarkTimeout()
    }
    pushError(...e) {
        this.items.push({
            error: e
        })
    }
    pushSend(e) {
        this.items.push({
            opcode: e[0],
            arguments: e[1]
        })
    }
    setMarker(e) {
        const n = this.items.filter(s => s.marker === e).length,
            r = n ? `label-${n}` : e;
        this.items.push({
            marker: r
        }), this.clearAutoMarkTimeout()
    }
    setAutoMarker() {
        const e = this.automarkPendingLabel ?? "marker";
        this.items.push({
            marker: `${this.autoMarkerCount}-${e}`
        }), this.autoMarkerCount += 1, delete this.automarkPendingLabel, this.clearAutoMarkTimeout()
    }
    startAutoMarkTimeout() {
        this.clearAutoMarkTimeout(), this.autoMarkTimeout = window.setTimeout(() => {
            this.setAutoMarker()
        }, this.autoMarkWindow)
    }
    clearAutoMarkTimeout() {
        this.autoMarkTimeout && (window.clearTimeout(this.autoMarkTimeout), delete this.autoMarkTimeout)
    }
    async send(e) {
        if (!this.client) return;
        const n = await this.sendToEcast();
        n && await this.sendToSlack(n, e)
    }
    getSendData() {
        return {
            appTag: this.room.appTag,
            state: {
                version: 3,
                room: {
                    code: this.room.code,
                    appTag: this.room.appTag
                },
                client: {
                    id: this.client.id,
                    name: this.client.name,
                    role: this.client.role
                },
                items: this.items
            }
        }
    }
    async sendToEcast() {
        const e = this.getSendData();
        try {
            const r = await (await fetch("https://ecast.jackboxgames.com/api/v2/controller/state", {
                method: "POST",
                body: JSON.stringify(e)
            })).json();
            if (!r.body || !r.body.url) return console.warn(r), null;
            const s = r.body.url.split("/"),
                i = s[s.length - 1].replace(".json", ""),
                o = s[s.length - 2];
            return {
                json: r.body.url,
                dev: `https://dev.jackbox.tv/debug/cloud/${o}/${i}/`,
                local: `http://localhost:9090/debug/cloud/${o}/${i}/`
            }
        } catch (n) {
            return console.error("[Debug] sendToEcast", n), null
        }
    }
    async sendToSlack(e, n) {
        if (!this.room || !this.client) return;
        const r = a1(this.room.appTag),
            s = this.items.length - this.markerCount,
            i = `${this.markerCount} ${this.markerCount===1?"marker":"markers"}`,
            o = `${s} ${s===1?"entity":"entities"}`,
            a = [{
                type: "mrkdwn",
                text: `${this.client.role}:${this.client.id}`
            }, {
                type: "mrkdwn",
                text: `*Version:* ${window.tv.manifest.loader.version}`
            }, {
                type: "mrkdwn",
                text: `*Domain:* ${window.location.hostname}`
            }];
        try {
            const l = "https://hooks.slack.com/services/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",
                p = {
                    unfurl_links: !1,
                    blocks: [{
                        type: "section",
                        text: {
                            type: "mrkdwn",
                            text: `*${(r==null?void 0:r.name)??this.room.appTag} :${this.room.appTag}:* (${i}, ${o}) 

 From: ${this.client.name},
${n}`
                        }
                    }, {
                        type: "context",
                        elements: a
                    }, {
                        type: "actions",
                        elements: [{
                            type: "button",
                            action_id: "actionId-0",
                            url: e.json,
                            text: {
                                type: "plain_text",
                                text: "JSON",
                                emoji: !0
                            }
                        }, {
                            type: "button",
                            action_id: "actionId-3",
                            url: e.local,
                            text: {
                                type: "plain_text",
                                text: "localhost:9090",
                                emoji: !0
                            }
                        }, {
                            type: "button",
                            action_id: "actionId-1",
                            url: e.dev,
                            text: {
                                type: "plain_text",
                                text: "dev.jackbox.tv",
                                emoji: !0
                            }
                        }]
                    }]
                };
            if (this.room) {
                p.icon_emoji = this.room.appTag;
                const y = a1(this.room.appTag);
                p.username = `DebugRecorder ${y?y.name:this.room.appTag}`
            }
            const v = await (await fetch(l, {
                method: "POST",
                body: JSON.stringify(p)
            })).text();
            M0("[Debug] sendToSlack", v)
        } catch (l) {
            console.error("[Debug] sendToSlack", l)
        }
    }
    download(e) {
        var o;
        const n = e ?? `${((o=this.room)==null?void 0:o.appTag)??"unknown"}-debug`,
            r = this.getSendData().state,
            s = JSON.stringify(r, null, 4),
            i = document.createElement("a");
        i.setAttribute("href", `data:text/json;charset=utf-8,${encodeURIComponent(s)}`), i.setAttribute("download", `${n}.json`), i.style.display = "none", document.body.appendChild(i), i.click(), document.body.removeChild(i)
    }
    open() {
        var s;
        const e = this.getSendData().state,
            n = JSON.stringify(e, null, 4),
            r = window.open();
        r.document.write(`
            <iframe src="data:text/json;charset=utf-8,${encodeURIComponent(n)}" frameborder="0" style="border:0;
                top:0px; left:0px; bottom:0px; right:0px; width:100%; height:100%;" allowfullscreen>
            </iframe>
        `), r.document.title = `${(s=this.room)==null?void 0:s.appTag} debug JSON`, r.document.close(), r.focus()
    }
    expose() {
        return {
            print: () => this.items,
            reset: () => this.reset(),
            setMarker: e => this.setMarker(e),
            download: e => this.download(e),
            open: () => this.open(),
            send: e => void this.send(e)
        }
    }
}

function WX(t) {
    throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var vS = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        r(e)
    })(_n, function(n) {
        var r = typeof window < "u" ? window : typeof _n < "u" ? _n : typeof self < "u" ? self : {},
            s = function(V, se) {
                if (se = se.split(":")[0], V = +V, !V) return !1;
                switch (se) {
                    case "http":
                    case "ws":
                        return V !== 80;
                    case "https":
                    case "wss":
                        return V !== 443;
                    case "ftp":
                        return V !== 21;
                    case "gopher":
                        return V !== 70;
                    case "file":
                        return !1
                }
                return V !== 0
            },
            i = Object.prototype.hasOwnProperty,
            o;

        function a(W) {
            try {
                return decodeURIComponent(W.replace(/\+/g, " "))
            } catch {
                return null
            }
        }

        function l(W) {
            try {
                return encodeURIComponent(W)
            } catch {
                return null
            }
        }

        function u(W) {
            for (var V = /([^=?#&]+)=?([^&]*)/g, se = {}, j; j = V.exec(W);) {
                var ne = a(j[1]),
                    Te = a(j[2]);
                ne === null || Te === null || ne in se || (se[ne] = Te)
            }
            return se
        }

        function f(W, V) {
            V = V || "";
            var se = [],
                j, ne;
            typeof V != "string" && (V = "?");
            for (ne in W)
                if (i.call(W, ne)) {
                    if (j = W[ne], !j && (j === null || j === o || isNaN(j)) && (j = ""), ne = l(ne), j = l(j), ne === null || j === null) continue;
                    se.push(ne + "=" + j)
                } return se.length ? V + se.join("&") : ""
        }
        var d = f,
            p = u,
            _ = {
                stringify: d,
                parse: p
            },
            v = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//,
            y = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i,
            g = "[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]",
            b = new RegExp("^" + g + "+");

        function O(W) {
            return (W || "").toString().replace(b, "")
        }
        var N = [
                ["#", "hash"],
                ["?", "query"],
                function(V, se) {
                    return x(se.protocol) ? V.replace(/\\/g, "/") : V
                },
                ["/", "pathname"],
                ["@", "auth", 1],
                [NaN, "host", void 0, 1, 1],
                [/:(\d+)$/, "port", void 0, 1],
                [NaN, "hostname", void 0, 1, 1]
            ],
            k = {
                hash: 1,
                query: 1
            };

        function A(W) {
            var V;
            typeof window < "u" ? V = window : typeof r < "u" ? V = r : typeof self < "u" ? V = self : V = {};
            var se = V.location || {};
            W = W || se;
            var j = {},
                ne = typeof W,
                Te;
            if (W.protocol === "blob:") j = new q(unescape(W.pathname), {});
            else if (ne === "string") {
                j = new q(W, {});
                for (Te in k) delete j[Te]
            } else if (ne === "object") {
                for (Te in W) Te in k || (j[Te] = W[Te]);
                j.slashes === void 0 && (j.slashes = v.test(W.href))
            }
            return j
        }

        function x(W) {
            return W === "file:" || W === "ftp:" || W === "http:" || W === "https:" || W === "ws:" || W === "wss:"
        }

        function D(W, V) {
            W = O(W), V = V || {};
            var se = y.exec(W),
                j = se[1] ? se[1].toLowerCase() : "",
                ne = !!se[2],
                Te = !!se[3],
                ke = 0,
                xe;
            return ne ? Te ? (xe = se[2] + se[3] + se[4], ke = se[2].length + se[3].length) : (xe = se[2] + se[4], ke = se[2].length) : Te ? (xe = se[3] + se[4], ke = se[3].length) : xe = se[4], j === "file:" ? ke >= 2 && (xe = xe.slice(2)) : x(j) ? xe = se[4] : j ? ne && (xe = xe.slice(2)) : ke >= 2 && x(V.protocol) && (xe = se[4]), {
                protocol: j,
                slashes: ne || x(j),
                slashesCount: ke,
                rest: xe
            }
        }

        function L(W, V) {
            if (W === "") return V;
            for (var se = (V || "/").split("/").slice(0, -1).concat(W.split("/")), j = se.length, ne = se[j - 1], Te = !1, ke = 0; j--;) se[j] === "." ? se.splice(j, 1) : se[j] === ".." ? (se.splice(j, 1), ke++) : ke && (j === 0 && (Te = !0), se.splice(j, 1), ke--);
            return Te && se.unshift(""), (ne === "." || ne === "..") && se.push(""), se.join("/")
        }

        function q(W, V, se) {
            if (W = O(W), !(this instanceof q)) return new q(W, V, se);
            var j, ne, Te, ke, xe, qe, Tn = N.slice(),
                Hr = typeof V,
                ct = this,
                qu = 0;
            for (Hr !== "object" && Hr !== "string" && (se = V, V = null), se && typeof se != "function" && (se = _.parse), V = A(V), ne = D(W || "", V), j = !ne.protocol && !ne.slashes, ct.slashes = ne.slashes || j && V.slashes, ct.protocol = ne.protocol || V.protocol || "", W = ne.rest, (ct.protocol === "file:" || !ne.slashes && (ne.protocol || ne.slashesCount < 2 || !x(ct.protocol))) && (Tn[3] = [/(.*)/, "pathname"]); qu < Tn.length; qu++) {
                if (ke = Tn[qu], typeof ke == "function") {
                    W = ke(W, ct);
                    continue
                }
                Te = ke[0], qe = ke[1], Te !== Te ? ct[qe] = W : typeof Te == "string" ? ~(xe = W.indexOf(Te)) && (typeof ke[2] == "number" ? (ct[qe] = W.slice(0, xe), W = W.slice(xe + ke[2])) : (ct[qe] = W.slice(xe), W = W.slice(0, xe))) : (xe = Te.exec(W)) && (ct[qe] = xe[1], W = W.slice(0, xe.index)), ct[qe] = ct[qe] || j && ke[3] && V[qe] || "", ke[4] && (ct[qe] = ct[qe].toLowerCase())
            }
            se && (ct.query = se(ct.query)), j && V.slashes && ct.pathname.charAt(0) !== "/" && (ct.pathname !== "" || V.pathname !== "") && (ct.pathname = L(ct.pathname, V.pathname)), ct.pathname.charAt(0) !== "/" && x(ct.protocol) && (ct.pathname = "/" + ct.pathname), s(ct.port, ct.protocol) || (ct.host = ct.hostname, ct.port = ""), ct.username = ct.password = "", ct.auth && (ke = ct.auth.split(":"), ct.username = ke[0] || "", ct.password = ke[1] || ""), ct.origin = ct.protocol !== "file:" && x(ct.protocol) && ct.host ? ct.protocol + "//" + ct.host : "null", ct.href = ct.toString()
        }

        function ee(W, V, se) {
            var j = this;
            switch (W) {
                case "query":
                    typeof V == "string" && V.length && (V = (se || _.parse)(V)), j[W] = V;
                    break;
                case "port":
                    j[W] = V, s(V, j.protocol) ? V && (j.host = j.hostname + ":" + V) : (j.host = j.hostname, j[W] = "");
                    break;
                case "hostname":
                    j[W] = V, j.port && (V += ":" + j.port), j.host = V;
                    break;
                case "host":
                    j[W] = V, /:\d+$/.test(V) ? (V = V.split(":"), j.port = V.pop(), j.hostname = V.join(":")) : (j.hostname = V, j.port = "");
                    break;
                case "protocol":
                    j.protocol = V.toLowerCase(), j.slashes = !se;
                    break;
                case "pathname":
                case "hash":
                    if (V) {
                        var ne = W === "pathname" ? "/" : "#";
                        j[W] = V.charAt(0) !== ne ? ne + V : V
                    } else j[W] = V;
                    break;
                default:
                    j[W] = V
            }
            for (var Te = 0; Te < N.length; Te++) {
                var ke = N[Te];
                ke[4] && (j[ke[1]] = j[ke[1]].toLowerCase())
            }
            return j.origin = j.protocol !== "file:" && x(j.protocol) && j.host ? j.protocol + "//" + j.host : "null", j.href = j.toString(), j
        }

        function ae(W) {
            (!W || typeof W != "function") && (W = _.stringify);
            var V, se = this,
                j = se.protocol;
            j && j.charAt(j.length - 1) !== ":" && (j += ":");
            var ne = j + (se.slashes || x(se.protocol) ? "//" : "");
            return se.username && (ne += se.username, se.password && (ne += ":" + se.password), ne += "@"), ne += se.host + se.pathname, V = typeof se.query == "object" ? W(se.query) : se.query, V && (ne += V.charAt(0) !== "?" ? "?" + V : V), se.hash && (ne += se.hash), ne
        }
        q.prototype = {
            set: ee,
            toString: ae
        }, q.extractProtocol = D, q.location = A, q.trimLeft = O, q.qs = _;
        var Z = q;

        function fe(W, V) {
            setTimeout(function(se) {
                return W.call(se)
            }, 4, V)
        }

        function ge(W, V) {
            typeof process < "u" && console[W].call(null, V)
        }

        function K(W, V) {
            W === void 0 && (W = []);
            var se = [];
            return W.forEach(function(j) {
                V(j) || se.push(j)
            }), se
        }

        function Q(W, V) {
            W === void 0 && (W = []);
            var se = [];
            return W.forEach(function(j) {
                V(j) && se.push(j)
            }), se
        }
        var ue = function() {
            this.listeners = {}
        };
        ue.prototype.addEventListener = function(V, se) {
            typeof se == "function" && (Array.isArray(this.listeners[V]) || (this.listeners[V] = []), Q(this.listeners[V], function(j) {
                return j === se
            }).length === 0 && this.listeners[V].push(se))
        }, ue.prototype.removeEventListener = function(V, se) {
            var j = this.listeners[V];
            this.listeners[V] = K(j, function(ne) {
                return ne === se
            })
        }, ue.prototype.dispatchEvent = function(V) {
            for (var se = this, j = [], ne = arguments.length - 1; ne-- > 0;) j[ne] = arguments[ne + 1];
            var Te = V.type,
                ke = this.listeners[Te];
            return Array.isArray(ke) ? (ke.forEach(function(xe) {
                j.length > 0 ? xe.apply(se, j) : xe.call(se, V)
            }), !0) : !1
        };

        function _e(W) {
            var V = W.indexOf("?");
            return V >= 0 ? W.slice(0, V) : W
        }
        var Oe = function() {
            this.urlMap = {}
        };
        Oe.prototype.attachWebSocket = function(V, se) {
            var j = _e(se),
                ne = this.urlMap[j];
            if (ne && ne.server && ne.websockets.indexOf(V) === -1) return ne.websockets.push(V), ne.server
        }, Oe.prototype.addMembershipToRoom = function(V, se) {
            var j = this.urlMap[_e(V.url)];
            j && j.server && j.websockets.indexOf(V) !== -1 && (j.roomMemberships[se] || (j.roomMemberships[se] = []), j.roomMemberships[se].push(V))
        }, Oe.prototype.attachServer = function(V, se) {
            var j = _e(se),
                ne = this.urlMap[j];
            if (!ne) return this.urlMap[j] = {
                server: V,
                websockets: [],
                roomMemberships: {}
            }, V
        }, Oe.prototype.serverLookup = function(V) {
            var se = _e(V),
                j = this.urlMap[se];
            if (j) return j.server
        }, Oe.prototype.websocketsLookup = function(V, se, j) {
            var ne = _e(V),
                Te, ke = this.urlMap[ne];
            if (Te = ke ? ke.websockets : [], se) {
                var xe = ke.roomMemberships[se];
                Te = xe || []
            }
            return j ? Te.filter(function(qe) {
                return qe !== j
            }) : Te
        }, Oe.prototype.removeServer = function(V) {
            delete this.urlMap[_e(V)]
        }, Oe.prototype.removeWebSocket = function(V, se) {
            var j = _e(se),
                ne = this.urlMap[j];
            ne && (ne.websockets = K(ne.websockets, function(Te) {
                return Te === V
            }))
        }, Oe.prototype.removeMembershipFromRoom = function(V, se) {
            var j = this.urlMap[_e(V.url)],
                ne = j.roomMemberships[se];
            j && ne !== null && (j.roomMemberships[se] = K(ne, function(Te) {
                return Te === V
            }))
        };
        var Ee = new Oe,
            Ce = {
                CLOSE_NORMAL: 1e3,
                CLOSE_GOING_AWAY: 1001,
                CLOSE_PROTOCOL_ERROR: 1002,
                CLOSE_UNSUPPORTED: 1003,
                CLOSE_NO_STATUS: 1005,
                CLOSE_ABNORMAL: 1006,
                UNSUPPORTED_DATA: 1007,
                POLICY_VIOLATION: 1008,
                CLOSE_TOO_LARGE: 1009,
                MISSING_EXTENSION: 1010,
                INTERNAL_ERROR: 1011,
                SERVICE_RESTART: 1012,
                TRY_AGAIN_LATER: 1013,
                TLS_HANDSHAKE: 1015
            },
            De = {
                CONSTRUCTOR_ERROR: "Failed to construct 'WebSocket':",
                CLOSE_ERROR: "Failed to execute 'close' on 'WebSocket':",
                EVENT: {
                    CONSTRUCT: "Failed to construct 'Event':",
                    MESSAGE: "Failed to construct 'MessageEvent':",
                    CLOSE: "Failed to construct 'CloseEvent':"
                }
            },
            Ue = function() {};
        Ue.prototype.stopPropagation = function() {}, Ue.prototype.stopImmediatePropagation = function() {}, Ue.prototype.initEvent = function(V, se, j) {
            V === void 0 && (V = "undefined"), se === void 0 && (se = !1), j === void 0 && (j = !1), this.type = "" + V, this.bubbles = !!se, this.cancelable = !!j
        };
        var ot = function(W) {
                function V(se, j) {
                    if (j === void 0 && (j = {}), W.call(this), !se) throw new TypeError(De.EVENT_ERROR + " 1 argument required, but only 0 present.");
                    if (typeof j != "object") throw new TypeError(De.EVENT_ERROR + " parameter 2 ('eventInitDict') is not an object.");
                    var ne = j.bubbles,
                        Te = j.cancelable;
                    this.type = "" + se, this.timeStamp = Date.now(), this.target = null, this.srcElement = null, this.returnValue = !0, this.isTrusted = !1, this.eventPhase = 0, this.defaultPrevented = !1, this.currentTarget = null, this.cancelable = Te ? !!Te : !1, this.cancelBubble = !1, this.bubbles = ne ? !!ne : !1
                }
                return W && (V.__proto__ = W), V.prototype = Object.create(W && W.prototype), V.prototype.constructor = V, V
            }(Ue),
            je = function(W) {
                function V(se, j) {
                    if (j === void 0 && (j = {}), W.call(this), !se) throw new TypeError(De.EVENT.MESSAGE + " 1 argument required, but only 0 present.");
                    if (typeof j != "object") throw new TypeError(De.EVENT.MESSAGE + " parameter 2 ('eventInitDict') is not an object");
                    var ne = j.bubbles,
                        Te = j.cancelable,
                        ke = j.data,
                        xe = j.origin,
                        qe = j.lastEventId,
                        Tn = j.ports;
                    this.type = "" + se, this.timeStamp = Date.now(), this.target = null, this.srcElement = null, this.returnValue = !0, this.isTrusted = !1, this.eventPhase = 0, this.defaultPrevented = !1, this.currentTarget = null, this.cancelable = Te ? !!Te : !1, this.canncelBubble = !1, this.bubbles = ne ? !!ne : !1, this.origin = "" + xe, this.ports = typeof Tn > "u" ? null : Tn, this.data = typeof ke > "u" ? null : ke, this.lastEventId = "" + (qe || "")
                }
                return W && (V.__proto__ = W), V.prototype = Object.create(W && W.prototype), V.prototype.constructor = V, V
            }(Ue),
            Ze = function(W) {
                function V(se, j) {
                    if (j === void 0 && (j = {}), W.call(this), !se) throw new TypeError(De.EVENT.CLOSE + " 1 argument required, but only 0 present.");
                    if (typeof j != "object") throw new TypeError(De.EVENT.CLOSE + " parameter 2 ('eventInitDict') is not an object");
                    var ne = j.bubbles,
                        Te = j.cancelable,
                        ke = j.code,
                        xe = j.reason,
                        qe = j.wasClean;
                    this.type = "" + se, this.timeStamp = Date.now(), this.target = null, this.srcElement = null, this.returnValue = !0, this.isTrusted = !1, this.eventPhase = 0, this.defaultPrevented = !1, this.currentTarget = null, this.cancelable = Te ? !!Te : !1, this.cancelBubble = !1, this.bubbles = ne ? !!ne : !1, this.code = typeof ke == "number" ? parseInt(ke, 10) : 0, this.reason = "" + (xe || ""), this.wasClean = qe ? !!qe : !1
                }
                return W && (V.__proto__ = W), V.prototype = Object.create(W && W.prototype), V.prototype.constructor = V, V
            }(Ue);

        function it(W) {
            var V = W.type,
                se = W.target,
                j = new ot(V);
            return se && (j.target = se, j.srcElement = se, j.currentTarget = se), j
        }

        function w(W) {
            var V = W.type,
                se = W.origin,
                j = W.data,
                ne = W.target,
                Te = new je(V, {
                    data: j,
                    origin: se
                });
            return ne && (Te.target = ne, Te.srcElement = ne, Te.currentTarget = ne), Te
        }

        function M(W) {
            var V = W.code,
                se = W.reason,
                j = W.type,
                ne = W.target,
                Te = W.wasClean;
            Te || (Te = V === Ce.CLOSE_NORMAL || V === Ce.CLOSE_NO_STATUS);
            var ke = new Ze(j, {
                code: V,
                reason: se,
                wasClean: Te
            });
            return ne && (ke.target = ne, ke.srcElement = ne, ke.currentTarget = ne), ke
        }

        function Y(W, V, se) {
            W.readyState = le.CLOSING;
            var j = Ee.serverLookup(W.url),
                ne = M({
                    type: "close",
                    target: W.target,
                    code: V,
                    reason: se
                }),
                Te = M({
                    type: "server::close",
                    target: W,
                    code: V,
                    reason: se
                });
            fe(function() {
                Ee.removeWebSocket(W, W.url), W.readyState = le.CLOSED, W.dispatchEvent(ne), W.dispatchEvent(Te), j && j.dispatchEvent(ne, j)
            }, W)
        }

        function X(W, V, se) {
            W.readyState = le.CLOSING;
            var j = Ee.serverLookup(W.url),
                ne = M({
                    type: "close",
                    target: W.target,
                    code: V,
                    reason: se,
                    wasClean: !1
                }),
                Te = M({
                    type: "server::close",
                    target: W,
                    code: V,
                    reason: se,
                    wasClean: !1
                }),
                ke = it({
                    type: "error",
                    target: W.target
                });
            fe(function() {
                Ee.removeWebSocket(W, W.url), W.readyState = le.CLOSED, W.dispatchEvent(ke), W.dispatchEvent(ne), W.dispatchEvent(Te), j && j.dispatchEvent(ne, j)
            }, W)
        }

        function I(W) {
            return Object.prototype.toString.call(W) !== "[object Blob]" && !(W instanceof ArrayBuffer) && (W = String(W)), W
        }
        var T = new WeakMap;

        function S(W) {
            if (T.has(W)) return T.get(W);
            var V = new Proxy(W, {
                get: function(j, ne) {
                    return ne === "close" ? function(ke) {
                        ke === void 0 && (ke = {});
                        var xe = ke.code || Ce.CLOSE_NORMAL,
                            qe = ke.reason || "";
                        Y(V, xe, qe)
                    } : ne === "send" ? function(ke) {
                        ke = I(ke), W.dispatchEvent(w({
                            type: "message",
                            data: ke,
                            origin: this.url,
                            target: W
                        }))
                    } : ne === "on" ? function(ke, xe) {
                        W.addEventListener("server::" + ke, xe)
                    } : ne === "target" ? W : j[ne]
                }
            });
            return T.set(W, V), V
        }

        function P(W) {
            var V = encodeURIComponent(W).match(/%[89ABab]/g);
            return W.length + (V ? V.length : 0)
        }

        function G(W) {
            var V = new Z(W),
                se = V.pathname,
                j = V.protocol,
                ne = V.hash;
            if (!W) throw new TypeError(De.CONSTRUCTOR_ERROR + " 1 argument required, but only 0 present.");
            if (se || (V.pathname = "/"), j === "") throw new SyntaxError(De.CONSTRUCTOR_ERROR + " The URL '" + V.toString() + "' is invalid.");
            if (j !== "ws:" && j !== "wss:") throw new SyntaxError(De.CONSTRUCTOR_ERROR + " The URL's scheme must be either 'ws' or 'wss'. '" + j + "' is not allowed.");
            if (ne !== "") throw new SyntaxError(De.CONSTRUCTOR_ERROR + " The URL contains a fragment identifier ('" + ne + "'). Fragment identifiers are not allowed in WebSocket URLs.");
            return V.toString()
        }

        function te(W) {
            if (W === void 0 && (W = []), !Array.isArray(W) && typeof W != "string") throw new SyntaxError(De.CONSTRUCTOR_ERROR + " The subprotocol '" + W.toString() + "' is invalid.");
            typeof W == "string" && (W = [W]);
            var V = W.map(function(j) {
                    return {
                        count: 1,
                        protocol: j
                    }
                }).reduce(function(j, ne) {
                    return j[ne.protocol] = (j[ne.protocol] || 0) + ne.count, j
                }, {}),
                se = Object.keys(V).filter(function(j) {
                    return V[j] > 1
                });
            if (se.length > 0) throw new SyntaxError(De.CONSTRUCTOR_ERROR + " The subprotocol '" + se[0] + "' is duplicated.");
            return W
        }
        var le = function(W) {
            function V(j, ne) {
                W.call(this), this._onopen = null, this._onmessage = null, this._onerror = null, this._onclose = null, this.url = G(j), ne = te(ne), this.protocol = ne[0] || "", this.binaryType = "blob", this.readyState = V.CONNECTING;
                var Te = S(this),
                    ke = Ee.attachWebSocket(Te, this.url);
                fe(function() {
                    if (ke)
                        if (ke.options.verifyClient && typeof ke.options.verifyClient == "function" && !ke.options.verifyClient()) this.readyState = V.CLOSED, ge("error", "WebSocket connection to '" + this.url + "' failed: HTTP Authentication failed; no valid credentials available"), Ee.removeWebSocket(Te, this.url), this.dispatchEvent(it({
                            type: "error",
                            target: this
                        })), this.dispatchEvent(M({
                            type: "close",
                            target: this,
                            code: Ce.CLOSE_NORMAL
                        }));
                        else {
                            if (ke.options.selectProtocol && typeof ke.options.selectProtocol == "function") {
                                var qe = ke.options.selectProtocol(ne),
                                    Tn = qe !== "",
                                    Hr = ne.indexOf(qe) !== -1;
                                if (Tn && !Hr) {
                                    this.readyState = V.CLOSED, ge("error", "WebSocket connection to '" + this.url + "' failed: Invalid Sub-Protocol"), Ee.removeWebSocket(Te, this.url), this.dispatchEvent(it({
                                        type: "error",
                                        target: this
                                    })), this.dispatchEvent(M({
                                        type: "close",
                                        target: this,
                                        code: Ce.CLOSE_NORMAL
                                    }));
                                    return
                                }
                                this.protocol = qe
                            }
                            this.readyState = V.OPEN, this.dispatchEvent(it({
                                type: "open",
                                target: this
                            })), ke.dispatchEvent(it({
                                type: "connection"
                            }), Te)
                        }
                    else this.readyState = V.CLOSED, this.dispatchEvent(it({
                        type: "error",
                        target: this
                    })), this.dispatchEvent(M({
                        type: "close",
                        target: this,
                        code: Ce.CLOSE_NORMAL
                    })), ge("error", "WebSocket connection to '" + this.url + "' failed")
                }, this)
            }
            W && (V.__proto__ = W), V.prototype = Object.create(W && W.prototype), V.prototype.constructor = V;
            var se = {
                onopen: {},
                onmessage: {},
                onclose: {},
                onerror: {}
            };
            return se.onopen.get = function() {
                return this._onopen
            }, se.onmessage.get = function() {
                return this._onmessage
            }, se.onclose.get = function() {
                return this._onclose
            }, se.onerror.get = function() {
                return this._onerror
            }, se.onopen.set = function(j) {
                this.removeEventListener("open", this._onopen), this._onopen = j, this.addEventListener("open", j)
            }, se.onmessage.set = function(j) {
                this.removeEventListener("message", this._onmessage), this._onmessage = j, this.addEventListener("message", j)
            }, se.onclose.set = function(j) {
                this.removeEventListener("close", this._onclose), this._onclose = j, this.addEventListener("close", j)
            }, se.onerror.set = function(j) {
                this.removeEventListener("error", this._onerror), this._onerror = j, this.addEventListener("error", j)
            }, V.prototype.send = function(ne) {
                var Te = this;
                if (this.readyState === V.CLOSING || this.readyState === V.CLOSED) throw new Error("WebSocket is already in CLOSING or CLOSED state");
                var ke = w({
                        type: "server::message",
                        origin: this.url,
                        data: I(ne)
                    }),
                    xe = Ee.serverLookup(this.url);
                xe && fe(function() {
                    Te.dispatchEvent(ke, ne)
                }, xe)
            }, V.prototype.close = function(ne, Te) {
                if (ne !== void 0 && (typeof ne != "number" || ne !== 1e3 && (ne < 3e3 || ne > 4999))) throw new TypeError(De.CLOSE_ERROR + " The code must be either 1000, or between 3000 and 4999. " + ne + " is neither.");
                if (Te !== void 0) {
                    var ke = P(Te);
                    if (ke > 123) throw new SyntaxError(De.CLOSE_ERROR + " The message must not be greater than 123 bytes.")
                }
                if (!(this.readyState === V.CLOSING || this.readyState === V.CLOSED)) {
                    var xe = S(this);
                    this.readyState === V.CONNECTING ? X(xe, ne || Ce.CLOSE_ABNORMAL, Te) : Y(xe, ne || Ce.CLOSE_NO_STATUS, Te)
                }
            }, Object.defineProperties(V.prototype, se), V
        }(ue);
        le.CONNECTING = 0, le.prototype.CONNECTING = le.CONNECTING, le.OPEN = 1, le.prototype.OPEN = le.OPEN, le.CLOSING = 2, le.prototype.CLOSING = le.CLOSING, le.CLOSED = 3, le.prototype.CLOSED = le.CLOSED;
        var me = function(W) {
            return W.reduce(function(V, se) {
                return V.indexOf(se) > -1 ? V : V.concat(se)
            }, [])
        };

        function ve() {
            return typeof window < "u" ? window : typeof process == "object" && typeof WX == "function" && typeof _n == "object" ? _n : this
        }
        var de = {
                mock: !0,
                verifyClient: null,
                selectProtocol: null
            },
            oe = function(W) {
                function V(se, j) {
                    j === void 0 && (j = de), W.call(this);
                    var ne = new Z(se);
                    ne.pathname || (ne.pathname = "/"), this.url = ne.toString(), this.originalWebSocket = null;
                    var Te = Ee.attachServer(this, this.url);
                    if (!Te) throw this.dispatchEvent(it({
                        type: "error"
                    })), new Error("A mock server is already listening on this url");
                    this.options = Object.assign({}, de, j), this.options.mock && this.mockWebsocket()
                }
                return W && (V.__proto__ = W), V.prototype = Object.create(W && W.prototype), V.prototype.constructor = V, V.prototype.mockWebsocket = function() {
                    var j = ve();
                    this.originalWebSocket = j.WebSocket, j.WebSocket = le
                }, V.prototype.restoreWebsocket = function() {
                    var j = ve();
                    this.originalWebSocket !== null && (j.WebSocket = this.originalWebSocket), this.originalWebSocket = null
                }, V.prototype.stop = function(j) {
                    j === void 0 && (j = function() {}), this.options.mock && this.restoreWebsocket(), Ee.removeServer(this.url), typeof j == "function" && j()
                }, V.prototype.on = function(j, ne) {
                    this.addEventListener(j, ne)
                }, V.prototype.close = function(j) {
                    j === void 0 && (j = {});
                    var ne = j.code,
                        Te = j.reason,
                        ke = j.wasClean,
                        xe = Ee.websocketsLookup(this.url);
                    Ee.removeServer(this.url), xe.forEach(function(qe) {
                        qe.readyState = le.CLOSED, qe.dispatchEvent(M({
                            type: "close",
                            target: qe.target,
                            code: ne || Ce.CLOSE_NORMAL,
                            reason: Te || "",
                            wasClean: ke
                        }))
                    }), this.dispatchEvent(M({
                        type: "close"
                    }), this)
                }, V.prototype.emit = function(j, ne, Te) {
                    var ke = this;
                    Te === void 0 && (Te = {});
                    var xe = Te.websockets;
                    xe || (xe = Ee.websocketsLookup(this.url)), typeof Te != "object" || arguments.length > 3 ? (ne = Array.prototype.slice.call(arguments, 1, arguments.length), ne = ne.map(function(qe) {
                        return I(qe)
                    })) : ne = I(ne), xe.forEach(function(qe) {
                        Array.isArray(ne) ? qe.dispatchEvent.apply(qe, [w({
                            type: j,
                            data: ne,
                            origin: ke.url,
                            target: qe.target
                        })].concat(ne)) : qe.dispatchEvent(w({
                            type: j,
                            data: ne,
                            origin: ke.url,
                            target: qe.target
                        }))
                    })
                }, V.prototype.clients = function() {
                    return Ee.websocketsLookup(this.url)
                }, V.prototype.to = function(j, ne, Te) {
                    var ke = this;
                    Te === void 0 && (Te = []);
                    var xe = this,
                        qe = me(Te.concat(Ee.websocketsLookup(this.url, j, ne)));
                    return {
                        to: function(Tn, Hr) {
                            return ke.to.call(ke, Tn, Hr, qe)
                        },
                        emit: function(Hr, ct) {
                            xe.emit(Hr, ct, {
                                websockets: qe
                            })
                        }
                    }
                }, V.prototype.in = function() {
                    for (var j = [], ne = arguments.length; ne--;) j[ne] = arguments[ne];
                    return this.to.apply(null, j)
                }, V.prototype.simulate = function(j) {
                    var ne = Ee.websocketsLookup(this.url);
                    j === "error" && ne.forEach(function(Te) {
                        Te.readyState = le.CLOSED, Te.dispatchEvent(it({
                            type: "error"
                        }))
                    })
                }, V
            }(ue);
        oe.of = function(V) {
            return new oe(V)
        };
        var he = function(W) {
            function V(j, ne) {
                var Te = this;
                j === void 0 && (j = "socket.io"), ne === void 0 && (ne = ""), W.call(this), this.binaryType = "blob";
                var ke = new Z(j);
                ke.pathname || (ke.pathname = "/"), this.url = ke.toString(), this.readyState = V.CONNECTING, this.protocol = "", this.target = this, typeof ne == "string" || typeof ne == "object" && ne !== null ? this.protocol = ne : Array.isArray(ne) && ne.length > 0 && (this.protocol = ne[0]);
                var xe = Ee.attachWebSocket(this, this.url);
                fe(function() {
                    xe ? (this.readyState = V.OPEN, xe.dispatchEvent(it({
                        type: "connection"
                    }), xe, this), xe.dispatchEvent(it({
                        type: "connect"
                    }), xe, this), this.dispatchEvent(it({
                        type: "connect",
                        target: this
                    }))) : (this.readyState = V.CLOSED, this.dispatchEvent(it({
                        type: "error",
                        target: this
                    })), this.dispatchEvent(M({
                        type: "close",
                        target: this,
                        code: Ce.CLOSE_NORMAL
                    })), ge("error", "Socket.io connection to '" + this.url + "' failed"))
                }, this), this.addEventListener("close", function(qe) {
                    Te.dispatchEvent(M({
                        type: "disconnect",
                        target: qe.target,
                        code: qe.code
                    }))
                })
            }
            W && (V.__proto__ = W), V.prototype = Object.create(W && W.prototype), V.prototype.constructor = V;
            var se = {
                broadcast: {}
            };
            return V.prototype.close = function() {
                if (this.readyState === V.OPEN) {
                    var ne = Ee.serverLookup(this.url);
                    return Ee.removeWebSocket(this, this.url), this.readyState = V.CLOSED, this.dispatchEvent(M({
                        type: "close",
                        target: this,
                        code: Ce.CLOSE_NORMAL
                    })), ne && ne.dispatchEvent(M({
                        type: "disconnect",
                        target: this,
                        code: Ce.CLOSE_NORMAL
                    }), ne), this
                }
            }, V.prototype.disconnect = function() {
                return this.close()
            }, V.prototype.emit = function(ne) {
                for (var Te = [], ke = arguments.length - 1; ke-- > 0;) Te[ke] = arguments[ke + 1];
                if (this.readyState !== V.OPEN) throw new Error("SocketIO is already in CLOSING or CLOSED state");
                var xe = w({
                        type: ne,
                        origin: this.url,
                        data: Te
                    }),
                    qe = Ee.serverLookup(this.url);
                return qe && qe.dispatchEvent.apply(qe, [xe].concat(Te)), this
            }, V.prototype.send = function(ne) {
                return this.emit("message", ne), this
            }, se.broadcast.get = function() {
                if (this.readyState !== V.OPEN) throw new Error("SocketIO is already in CLOSING or CLOSED state");
                var j = this,
                    ne = Ee.serverLookup(this.url);
                if (!ne) throw new Error("SocketIO can not find a server at the specified URL (" + this.url + ")");
                return {
                    emit: function(ke, xe) {
                        return ne.emit(ke, xe, {
                            websockets: Ee.websocketsLookup(j.url, null, j)
                        }), j
                    },
                    to: function(ke) {
                        return ne.to(ke, j)
                    },
                    in: function(ke) {
                        return ne.in(ke, j)
                    }
                }
            }, V.prototype.on = function(ne, Te) {
                return this.addEventListener(ne, Te), this
            }, V.prototype.off = function(ne, Te) {
                this.removeEventListener(ne, Te)
            }, V.prototype.hasListeners = function(ne) {
                var Te = this.listeners[ne];
                return Array.isArray(Te) ? !!Te.length : !1
            }, V.prototype.join = function(ne) {
                Ee.addMembershipToRoom(this, ne)
            }, V.prototype.leave = function(ne) {
                Ee.removeMembershipFromRoom(this, ne)
            }, V.prototype.to = function(ne) {
                return this.broadcast.to(ne)
            }, V.prototype.in = function() {
                return this.to.apply(null, arguments)
            }, V.prototype.dispatchEvent = function(ne) {
                for (var Te = this, ke = [], xe = arguments.length - 1; xe-- > 0;) ke[xe] = arguments[xe + 1];
                var qe = ne.type,
                    Tn = this.listeners[qe];
                if (!Array.isArray(Tn)) return !1;
                Tn.forEach(function(Hr) {
                    ke.length > 0 ? Hr.apply(Te, ke) : Hr.call(Te, ne.data ? ne.data : ne)
                })
            }, Object.defineProperties(V.prototype, se), V
        }(ue);
        he.CONNECTING = 0, he.OPEN = 1, he.CLOSING = 2, he.CLOSED = 3;
        var Me = function(V, se) {
            return new he(V, se)
        };
        Me.connect = function(V, se) {
            return Me(V, se)
        };
        var Fe = oe,
            at = le,
            vt = Me;
        n.Server = Fe, n.WebSocket = at, n.SocketIO = vt, Object.defineProperty(n, "__esModule", {
            value: !0
        })
    })
})(vS, vS.exports);
class bS {
    static getPromptGuess(e, n) {
        var r, s, i;
        if ((r = e.player) != null && r.prompt) return e.player.prompt;
        if ((s = e.audience) != null && s.prompt) return e.audience.prompt;
        if ((i = e.audiencePlayer) != null && i.prompt) return e.audiencePlayer.prompt;
        if (e.prompt) return e.prompt;
        if (n === "range-game") return this.getRangeGameGuess(e)
    }
    static getRangeGameGuess(e) {
        var n, r, s, i, o, a, l, u;
        if ((r = (n = e.player) == null ? void 0 : n.content) != null && r.text) return (i = (s = e.player) == null ? void 0 : s.content) == null ? void 0 : i.text;
        if ((a = (o = e.content) == null ? void 0 : o.content) != null && a.text) return (u = (l = e.content) == null ? void 0 : l.content) == null ? void 0 : u.text
    }
    static async send(e) {
        const n = {
            appTag: e.room.appTag,
            state: {
                appTag: e.room.appTag,
                name: e.name,
                role: e.role,
                code: e.room.code,
                message: e.message,
                vibe: e.vibe,
                state: e.values
            }
        };
        try {
            const r = await this.sendToEcast(n);
            await this.sendToSlack(r, e)
        } catch (r) {
            console.error(r)
        }
    }
    static async sendToEcast(e) {
        return (await (await fetch("https://ecast.jackboxgames.com/api/v2/controller/state", {
            method: "POST",
            body: JSON.stringify(e)
        })).json()).body.url
    }
    static async sendToSlack(e, n) {
        const r = a1(n.room.appTag),
            s = "https://hooks.slack.com/services/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",
            i = {
                good: ":large_green_circle:",
                meh: ":large_yellow_circle:",
                bad: ":red_circle:"
            },
            a = `${(r==null?void 0:r.name)??n.room.appTag} :${n.room.appTag}: 

 From: ${n.name},
${n.message}`,
            l = [];
        n.vibe && n.vibe !== "none" && l.push({
            type: "plain_text",
            text: `${i[n.vibe]} ${n.vibe.toUpperCase()} Vibes`,
            emoji: !0
        }), n.content && l.push({
            type: "plain_text",
            text: `Content: ${n.content}`,
            emoji: !0
        });
        const f = {
            blocks: [{
                type: "section",
                text: {
                    type: "mrkdwn",
                    text: a
                }
            }, {
                type: "context",
                elements: l
            }, {
                type: "actions",
                elements: [{
                    type: "button",
                    action_id: "actionId-0",
                    url: e,
                    text: {
                        type: "plain_text",
                        text: "View Game State JSON",
                        emoji: !0
                    }
                }]
            }]
        };
        try {
            const p = await (await fetch(s, {
                method: "POST",
                body: JSON.stringify(f)
            })).text();
            M0("[Feedback] sendToSlack", p)
        } catch (d) {
            console.error("[Feedback] sendToSlack", d)
        }
    }
}
const Tl = class Tl {
    constructor(e, n) {
        ye(this, "activePointers", new Map);
        ye(this, "element");
        ye(this, "documentElement");
        ye(this, "usePointerEvents");
        ye(this, "isCanceled", !1);
        ye(this, "cachedElementRect");
        ye(this, "cachedDocumentRect");
        ye(this, "cachedTranslations");
        ye(this, "isMultitouch");
        ye(this, "isRestrictedToBox");
        ye(this, "swipeVelocity");
        ye(this, "swipeDistance");
        ye(this, "boundOnClick", this.onClick.bind(this));
        ye(this, "boundOnStart", this.onStart.bind(this));
        ye(this, "boundOnMove", this.onMove.bind(this));
        ye(this, "boundOnEnd", this.onEnd.bind(this));
        this.applyPolyfill(), this.element = e, this.documentElement = document.documentElement, this.usePointerEvents = window.PointerEvent !== void 0, this.isRestrictedToBox = n.restrictToBox, this.isMultitouch = n.isMultitouch ?? !1, this.swipeDistance = n.swipeDistance ?? 30, this.swipeVelocity = n.swipeVelocity ?? .5, this.bindStaticEvents()
    }
    destroy() {
        this.unbindStaticEvents(), this.unbindStartedEvents()
    }
    cancel() {
        this.isCanceled = !0, this.unbindStartedEvents()
    }
    isPointerEvent(e) {
        return window.PointerEvent === void 0 ? !1 : e instanceof PointerEvent
    }
    isTouchEvent(e) {
        return "ontouchstart" in window ? e instanceof TouchEvent : !1
    }
    isMouseEvent(e) {
        return e instanceof MouseEvent
    }
    getTouchById(e, n) {
        return Array.from(e).find(r => r.identifier === n)
    }
    bindStaticEvents() {
        if (this.element.addEventListener("click", this.boundOnClick), this.usePointerEvents) {
            this.element.addEventListener("pointerdown", this.boundOnStart);
            return
        }
        this.element.addEventListener("touchstart", this.boundOnStart), this.element.addEventListener("mousedown", this.boundOnStart)
    }
    unbindStaticEvents() {
        if (this.element.removeEventListener("click", this.boundOnClick), this.usePointerEvents) {
            this.element.removeEventListener("pointerdown", this.boundOnStart);
            return
        }
        this.element.removeEventListener("touchstart", this.boundOnStart), this.element.removeEventListener("mousedown", this.boundOnStart)
    }
    bindStartedEvents() {
        if (this.usePointerEvents) {
            this.element.addEventListener("pointermove", this.boundOnMove), this.element.addEventListener("pointerup", this.boundOnEnd), this.isRestrictedToBox && this.element.addEventListener("pointerleave", this.boundOnEnd), this.element.addEventListener("lostpointercapture", this.boundOnEnd), this.disableChildPointerEvents();
            return
        }
        this.element.addEventListener("touchmove", this.boundOnMove), this.element.addEventListener("mousemove", this.boundOnMove), this.element.addEventListener("touchend", this.boundOnEnd), this.element.addEventListener("mouseleave", this.boundOnEnd), this.element.addEventListener("mouseup", this.boundOnEnd)
    }
    unbindStartedEvents() {
        if (this.usePointerEvents) {
            this.element.removeEventListener("pointermove", this.boundOnMove), this.element.removeEventListener("pointerup", this.boundOnEnd), this.isRestrictedToBox && this.element.removeEventListener("pointerleave", this.boundOnEnd), this.element.removeEventListener("lostpointercapture", this.boundOnEnd), this.enableChildPointerEvents();
            return
        }
        this.element.removeEventListener("touchmove", this.boundOnMove), this.element.removeEventListener("mousemove", this.boundOnMove), this.element.removeEventListener("touchend", this.boundOnEnd), this.element.removeEventListener("mouseleave", this.boundOnEnd), this.element.removeEventListener("mouseup", this.boundOnEnd)
    }
    onClick(e) {
        const n = this.getStartDetail(e, {
                id: 0,
                type: "click"
            }),
            r = new CustomEvent("pointerbox:click", {
                detail: n
            });
        this.element.dispatchEvent(r)
    }
    onStart(e) {
        if (e.preventDefault(), this.isCanceled = !1, !this.isMultitouch && this.activePointers.size) return !1;
        if (this.isPointerEvent(e)) return this.processStartEvent(e, {
            id: e.pointerId,
            type: e.pointerType
        }), !1;
        if (this.isTouchEvent(e)) {
            for (let n = 0; n < e.targetTouches.length; n++) {
                const r = e.targetTouches.item(n);
                this.processStartEvent(e, {
                    id: r.identifier,
                    type: "touch"
                }, r)
            }
            return !1
        }
        return this.processStartEvent(e, {
            id: 0,
            type: "mouse"
        }), !1
    }
    processStartEvent(e, n, r) {
        if (this.activePointers.get(n.id)) return;
        const s = this.getStartDetail(e, n, r),
            i = {
                id: n.id,
                type: n.type,
                distanceAccumulator: 0,
                velocityValues: [0],
                children: document.elementsFromPoint(s.clientX, s.clientY),
                previousEventTimestamp: Date.now(),
                initial: s,
                previous: s
            };
        this.activePointers.set(n.id, i);
        const o = new CustomEvent("pointerbox:start", {
            detail: s
        });
        this.element.dispatchEvent(o);
        const a = new CustomEvent("pointerbox:childdown", {
            detail: s
        });
        i.children.forEach(l => l.dispatchEvent(a)), this.bindStartedEvents()
    }
    onMove(e) {
        if (e.preventDefault(), !this.isCanceled) {
            if (this.isPointerEvent(e)) return this.processMoveEvent(e, {
                id: e.pointerId,
                type: e.pointerType
            }), !1;
            if (this.isTouchEvent(e)) {
                for (let n = 0; n < e.changedTouches.length; n++) {
                    const r = e.targetTouches.item(n);
                    this.processMoveEvent(e, {
                        id: r.identifier,
                        type: "touch"
                    }, r)
                }
                return !1
            }
            return this.processMoveEvent(e, {
                id: 0,
                type: "mouse"
            }), !1
        }
    }
    processMoveEvent(e, n, r) {
        const s = this.activePointers.get(n.id);
        if (!s) return !1;
        const i = this.getMoveDetail(e, s, r);
        s.previous = i, s.previousEventTimestamp = Date.now();
        const o = new CustomEvent("pointerbox:move", {
            detail: i
        });
        return this.element.dispatchEvent(o), !1
    }
    onEnd(e) {
        if (e.preventDefault(), !this.isCanceled) return this.isPointerEvent(e) ? (this.processEndEvent(e, {
            id: e.pointerId,
            type: e.pointerType
        }), !1) : this.isTouchEvent(e) ? (this.activePointers.forEach((n, r) => {
            if (this.getTouchById(e.touches, r)) return;
            const s = this.getTouchById(n.previous.originalEvent.touches, r);
            if (!s) throw new Error("[PointerBox] No previous details stored");
            this.processEndEvent(e, {
                id: r,
                type: n.type
            }, s)
        }), !1) : (this.processEndEvent(e, {
            id: 0,
            type: "mouse"
        }), !1)
    }
    processEndEvent(e, n, r) {
        const s = this.activePointers.get(n.id);
        if (!s) return !1;
        const i = this.getMoveDetail(e, s, r),
            o = new CustomEvent("pointerbox:end", {
                detail: i
            });
        this.element.dispatchEvent(o), this.checkForSwipe(o), this.activePointers.delete(s.id), this.activePointers.size || (delete this.cachedElementRect, delete this.cachedDocumentRect, delete this.cachedTranslations, this.unbindStartedEvents());
        const a = new CustomEvent("pointerbox:childup", {
            detail: i
        });
        return document.elementsFromPoint(i.clientX, i.clientY).forEach(u => {
            if (u.dispatchEvent(a), !s.children.includes(u)) return;
            const f = new CustomEvent("pointerbox:childclick", {
                detail: i
            });
            u.dispatchEvent(f)
        }), !1
    }
    checkForSwipe(e) {
        const n = e.detail;
        if (n.distanceFromInitial < this.swipeDistance || n.previous.normalizedVelocity < this.swipeVelocity) return;
        const r = n.degreesFromInitial;
        r > 45 && r < 135 ? n.direction = "up" : r > 135 && r < 225 ? n.direction = "left" : r > 225 && r < 315 ? n.direction = "down" : n.direction = "right";
        const s = new CustomEvent("pointerbox:swipe", {
                detail: n
            }),
            i = new CustomEvent(`pointerbox:swipe${n.direction}`, {
                detail: n
            });
        this.element.dispatchEvent(s), this.element.dispatchEvent(i)
    }
    getStartDetail(e, n, r) {
        let s, i, o, a;
        this.cachedElementRect || (this.cachedElementRect = this.element.getBoundingClientRect()), this.cachedDocumentRect || (this.cachedDocumentRect = this.documentElement.getBoundingClientRect());
        const l = this.cachedDocumentRect.top;
        this.cachedTranslations || (this.cachedTranslations = this.getTranslations()), r ? (s = r.pageX, i = r.pageY + l, o = r.clientX, a = r.clientY) : (s = e.pageX, i = e.pageY + l, o = e.clientX, a = e.clientY);
        const u = s - this.cachedElementRect.left,
            f = i - this.cachedElementRect.top,
            d = u / this.cachedElementRect.width,
            p = f / this.cachedElementRect.height,
            _ = d < 0 || d > 1 || p < 0 || p > 1,
            v = {};
        return this.cachedTranslations.forEach(y => {
            v[y.id] && console.warn(`[PointerBox] duplicate translation key ${y.id}`), v[y.id] = {
                x: u * y.x - y.left,
                y: f * y.y - y.top
            }
        }), {
            id: n.id,
            type: n.type,
            boxX: u,
            boxY: f,
            pageX: s,
            pageY: i,
            clientX: o,
            clientY: a,
            percentX: d,
            percentY: p,
            translations: v,
            isOutsideBox: _,
            originalEvent: e,
            cancel: () => this.cancel()
        }
    }
    getMoveDetail(e, n, r) {
        if (!n.initial) throw new Error("[PointerBox] No initial details stored");
        if (!n.previous) throw new Error("[PointerBox] No previous details stored");
        const s = this.getStartDetail(e, {
                id: n.id,
                type: n.type
            }, r),
            i = js.getAngleBetweenPoints({
                x: n.initial.boxX,
                y: n.initial.boxY
            }, {
                x: s.boxX,
                y: s.boxY
            }),
            o = js.getDistanceBetweenPoints({
                x: n.initial.boxX,
                y: n.initial.boxY
            }, {
                x: s.boxX,
                y: s.boxY
            }),
            a = js.getAngleBetweenPoints({
                x: n.previous.boxX,
                y: n.previous.boxY
            }, {
                x: s.boxX,
                y: s.boxY
            }),
            l = js.getDistanceBetweenPoints({
                x: n.previous.boxX,
                y: n.previous.boxY
            }, {
                x: s.boxX,
                y: s.boxY
            });
        n.distanceAccumulator += l;
        let u = 0;
        return n.previousEventTimestamp && (u = js.getVelocity({
            x: n.previous.boxX,
            y: n.previous.boxY
        }, n.previousEventTimestamp, {
            x: s.boxX,
            y: s.boxY
        }, Date.now())), u && (n.velocityValues.unshift(u), n.velocityValues.length = Math.min(n.velocityValues.length, 5)), {
            id: s.id,
            type: s.type,
            boxX: s.boxX,
            boxY: s.boxY,
            pageX: s.pageX,
            pageY: s.pageY,
            clientX: s.clientX,
            clientY: s.clientY,
            percentX: s.percentX,
            percentY: s.percentY,
            translations: s.translations,
            isOutsideBox: s.isOutsideBox,
            degreesFromInitial: i,
            distanceFromInitial: o,
            changeXFromInitial: s.boxX - n.initial.boxX,
            changeYFromInitial: s.boxY - n.initial.boxY,
            degreesFromPrevious: a,
            distancefromPrevious: l,
            changeXFromPrevious: s.boxX - n.previous.boxX,
            changeYFromPrevious: s.boxY - n.previous.boxY,
            totalDistance: n.distanceAccumulator,
            velocity: u,
            normalizedVelocity: n.velocityValues.reduce((f, d) => f + d) / n.velocityValues.length,
            originalEvent: s.originalEvent,
            initial: n.initial,
            previous: n.previous,
            cancel: s.cancel
        }
    }
    getTranslations() {
        if (!this.cachedElementRect) throw Error("[PointerBox] Element rect is undefined");
        const e = [],
            n = this.element.children;
        for (let r = 0; r < n.length; r++) {
            const s = n[r].attributes.getNamedItem("data-pointerboxtranslateid");
            if (!s) continue;
            const i = s.value;
            if (!i) continue;
            const o = n[r].attributes.getNamedItem("data-pointerboxtranslatewidth"),
                a = n[r].attributes.getNamedItem("data-pointerboxtranslateheight"),
                l = o != null && o.value ? parseInt(o.value, 10) : this.cachedElementRect.width,
                u = a != null && a.value ? parseInt(a.value, 10) : this.cachedElementRect.height,
                f = n[r].getBoundingClientRect();
            e.push({
                id: i,
                left: f.left - this.cachedElementRect.left,
                top: f.top - this.cachedElementRect.top,
                x: l / f.width,
                y: u / f.height
            })
        }
        return e
    }
    disableChildPointerEvents() {
        this.element.style.touchAction = "none";
        for (let e = 0; e < this.element.children.length; e++) {
            const n = this.element.children[e];
            n.style.pointerEvents = "none", n.style.touchAction = "none"
        }
    }
    enableChildPointerEvents() {
        this.element.style.touchAction = "";
        for (let e = 0; e < this.element.children.length; e++) {
            const n = this.element.children[e];
            n.style.pointerEvents = "", n.style.touchAction = ""
        }
    }
    applyPolyfill() {
        Tl.isPolyfilled || (Tl.isPolyfilled = !0, window && window.document && (window.document.elementsFromPoint || (window.document.elementsFromPoint = Tl.elementsFromPoint)))
    }
    static elementsFromPoint(e, n) {
        const r = [],
            s = [];
        let i = null;
        do {
            const o = window.document.elementFromPoint(e, n);
            i !== o ? (i = o, r.push(i), s.push(i.style.pointerEvents), i.style.pointerEvents = "none") : i = null
        } while (i);
        return r.forEach((o, a) => {
            o.style.pointerEvents = s[a]
        }), r
    }
};
ye(Tl, "isPolyfilled", !1);
let D0 = Tl;
class Ey {
    static get canShare() {
        return !!navigator.canShare
    }
    static async share(e, n, r) {
        if (!navigator.share) return;
        const s = {
            files: [e]
        };
        n.title && (s.title = n.title), n.text && (s.text = n.text), n.url && (s.url = n.url), await navigator.share(s), r && zl.galleryShare(r.categoryId, r.options)
    }
    static async copyToClipboard(e, n) {
        if (!navigator.clipboard) return;
        const r = new ClipboardItem({
            [e.type]: e
        });
        await navigator.clipboard.write([r]), n && zl.galleryShare(n.categoryId, n.options)
    }
}
const HX = {
        BACK: "Back",
        CANCEL: "Cancel",
        CLOSE: "Close",
        CONFIRM: "Confirm",
        CREATE: "Create",
        DELETE: "Delete",
        DONE: "Done",
        EDIT: "Edit",
        OK: "OK",
        NEXT: "Next",
        NO: "No",
        PLAY: "Play",
        PUBLISH: "Publish",
        REMOVE: "Remove",
        RESET: "Reset",
        SUBMIT: "Submit",
        TRY_AGAIN: "Try Again",
        UNDO: "Undo",
        YES: "Yes"
    },
    YX = {
        UGC: {
            VISIBILITY_CONTROLLER_OFF: "prompts hidden on players devices",
            VISIBILITY_CONTROLLER_ON: "prompts shown on players devices",
            VISIBILITY_SCREEN_OFF: "prompts hidden on game screen",
            VISIBILITY_SCREEN_ON: "prompts shown on game screen"
        }
    },
    zX = {
        DISCONNECTED: "You have been disconnected.",
        DRAWING_NOTHING: "You have to draw something!",
        PLAYER_KICKED: "You have been kicked from the game by a moderator.",
        ROOM_DESTROYED: "Thanks for playing!",
        ROOM_DISCONNECTED: "Disconnected",
        TEXT_NAUGHTY: "Im afraid you cant write that. Please be respectful of other players.",
        TEXT_NOTHING: "You cant enter nothing!",
        TITLE: "Error"
    },
    KX = "LOADING",
    ZX = {
        JOINED_COUNT: "{count} of {maxPlayers} players joined",
        PLAYERS_NEEDED: "1 player needed to start | {count} players needed to start",
        WAITING_FOR_VIP: "Waiting for {name} to start the game",
        WAITING_FOR_GAMEPAD: "Waiting for the game to start",
        WAITING_FOR_NEW_GAME: "Waiting for a new game to start",
        GAME_STARTING: "Game is starting",
        BUTTON_START: "Press to Start",
        BUTTON_CANCEL: "Press to Cancel"
    },
    XX = {
        GALLERY_LINK: "Visit the Gallery",
        NEW_GAME_STARTED: "A new game has started",
        PLAY_AGAIN: "Play again?",
        THANKS_FOR_PLAYING: "Thanks for playing!",
        BUTTON_GO_TO_GAME: "Go to game",
        BUTTON_GO_TO_JACKBOX: "Back to jackbox.tv",
        BUTTON_SAME_PLAYERS: "Same players",
        BUTTON_NEW_PLAYERS: "New players"
    },
    QX = {
        AND: "AND",
        OR: "OR"
    },
    JX = {
        BUTTON_SKIP: "Skip",
        BUTTON_NEXT: "Next",
        BUTTON_DONE: "Lets Go!"
    },
    eQ = {
        NAME: "AUDIENCE"
    },
    tQ = {
        CART: {
            CHECK_OUT: "Check out",
            EMPTY: "Your cart is empty",
            TITLE: "Shopping Cart",
            TOTAL: "Total"
        }
    },
    nQ = {
        EPISODE_REPORT: "Report Episode",
        EPISODE_UNLOAD: "Unload Episode",
        EPISODE_VIEW_AUTHOR: "View Author",
        EPISODES_LOAD: "Load an episode by id:",
        EPISODES_MENU: "Episodes Menu",
        EPISODES_SELECT: "Or select an epsiode:",
        EPISODES_WARNING: "Warning: user generated content is not rated",
        INSTRUCTION: {
            CREATE_TITLE: "first things first, enter a name for the episode that will contain all your prompts and hit create.",
            LOAD: "create or load?",
            PUBLISH: "publish your episode",
            TITLE: "name your episode",
            TOGGLE_VISIBILITY: "tap to show/hide prompts",
            WRITE: "write your prompts"
        },
        WARNING: {
            DELETE: "Are you sure you want to delete this episode?",
            TOS: "By sharing content, you agree to our [tos]Terms of Service[/tos]",
            TOS_AGREE: "agree and share"
        },
        BACK_TO_EPISODES: "back to episodes",
        BACK_TO_MENU: "back to menu",
        CREATE_NEW_EPISODE: "create a new episode",
        PREVIOUS_EPISODES: "previous episodes",
        PROMPT_ADD: "add prompt",
        PROMPT_PLACEHOLDER: "enter a prompt",
        PROMPTS_COUNT_HIDDEN: "({count} hidden)",
        TITLE_PLACEHOLDER: "enter a title"
    },
    rQ = {
        BROADCASTER: {
            SUBTEXT: "You have successfully connected your account to the Jackbox Audience Kit Twitch Extension.",
            WARNING: "THIS ROOM DOESN'T HAVE THE AUDIENCE SETTING ENABLED"
        },
        RECONNECTED: {
            TEXT: "RECONNECTED",
            SUBTEXT: "Have fun!"
        },
        RECONNECTING: {
            CONTROLLER: {
                TEXT: "CONNECTION INTERRUPTED",
                SUBTEXT: "Attempting to reconnect ({attempt} of 5)"
            },
            GAME: {
                TEXT: "GAME CONNECTION INTERRUPTED",
                SUBTEXT: "Please wait while we attempt to reconnect"
            }
        },
        PAUSED: {
            TEXT: "THE GAME IS PAUSED",
            SUBTEXT: "Anything you submit will still be sent to the game."
        }
    },
    sQ = {
        SHARE: "Share",
        COPY_TO_CLIPBOARD: "Copy to clipboard",
        COPIED: "Copied"
    },
    iQ = {
        ACTION: HX,
        ALT: YX,
        ERROR: zX,
        LOADING: KX,
        LOBBY: ZX,
        POST_GAME: XX,
        SEPARATOR: QX,
        TUTORIAL: JX,
        AUDIENCE: eQ,
        GALLERY: tQ,
        UGC: nQ,
        TOAST: rQ,
        SHARE: sQ
    },
    oQ = {
        BACK: "Retour",
        CANCEL: "Annuler",
        CLOSE: "Fermer",
        CONFIRM: "Confirmer",
        CREATE: "Crer",
        DELETE: "Supprimer",
        DONE: "Termin",
        EDIT: "Modifier",
        OK: "OK",
        NEXT: "Suivant",
        NO: "Non",
        PLAY: "Jouer",
        PUBLISH: "Publier",
        REMOVE: "Supprimer",
        RESET: "Rinitialiser",
        SUBMIT: "Envoyer",
        TRY_AGAIN: "Ressayer",
        UNDO: "Annuler",
        YES: "Oui"
    },
    aQ = {
        UGC: {
            VISIBILITY_CONTROLLER_OFF: "sujets non affichs sur les appareils des joueurs",
            VISIBILITY_CONTROLLER_ON: "sujets affichs sur les appareils des joueurs",
            VISIBILITY_SCREEN_OFF: "sujets non affichs sur l'cran de jeu",
            VISIBILITY_SCREEN_ON: "sujets affichs sur l'cran de jeu"
        }
    },
    cQ = {
        DISCONNECTED: "Vous avez t dconnect(e).",
        DRAWING_NOTHING: "Vous devez dessiner quelque chose!",
        PLAYER_KICKED: "Vous avez t ject(e) de la partie par un modrateur.",
        ROOM_DESTROYED: "Merci d'avoir jou!",
        ROOM_DISCONNECTED: "Dconnexion",
        TEXT_NAUGHTY: "Je crains que vous ne puissiez pas crire a. Respectez les autres joueurs.",
        TEXT_NOTHING: "Vous ne pouvez pas ne rien entrer",
        TITLE: "Erreur"
    },
    lQ = "CHARGEMENT",
    uQ = {
        JOINED_COUNT: "{count} joueurs sur {maxPlayers} ont rejoint la partie",
        PLAYERS_NEEDED: "1joueur ncessaire pour commencer | {count}joueurs ncessaires pour commencer",
        WAITING_FOR_VIP: "En attente de {name} pour commencer la partie",
        WAITING_FOR_GAMEPAD: "En attente du dbut de la partie",
        WAITING_FOR_NEW_GAME: "En attente du dbut d'une nouvelle partie",
        GAME_STARTING: "La partie commence",
        BUTTON_START: "Appuyer pour commencer",
        BUTTON_CANCEL: "Appuyer pour annuler"
    },
    hQ = {
        GALLERY_LINK: "Visiter la galerie",
        NEW_GAME_STARTED: "Une nouvelle partie a commenc",
        PLAY_AGAIN: "Rejouer?",
        THANKS_FOR_PLAYING: "Merci d'avoir jou!",
        BUTTON_GO_TO_GAME: "Aller au jeu",
        BUTTON_GO_TO_JACKBOX: "Retour  jackbox.tv",
        BUTTON_SAME_PLAYERS: "Mmes joueurs",
        BUTTON_NEW_PLAYERS: "Nouveaux joueurs"
    },
    fQ = {
        AND: "ET",
        OR: "OU"
    },
    dQ = {
        BUTTON_SKIP: "Passer",
        BUTTON_NEXT: "Suivant",
        BUTTON_DONE: "Allons-y!"
    },
    pQ = {
        NAME: "SPECTATEURS"
    },
    mQ = {
        CART: {
            CHECK_OUT: "Paiement",
            EMPTY: "Votre panier est vide",
            TITLE: "Panier",
            TOTAL: "Total"
        }
    },
    gQ = {
        EPISODE_REPORT: "Signaler l'pisode",
        EPISODE_UNLOAD: "Retirer l'pisode",
        EPISODE_VIEW_AUTHOR: "Voir l'auteur",
        EPISODES_LOAD: "Charger un pisode par id:",
        EPISODES_MENU: "Menu des pisodes",
        EPISODES_SELECT: "Ou slectionner un pisode:",
        EPISODES_WARNING: "Attention: le contenu gnr par les utilisateurs ne fait pas l'objet d'un classement",
        INSTRUCTION: {
            CREATE_TITLE: "commencez par donner un nom  l'pisode qui contiendra vos sujets, puis touchez crer.",
            LOAD: "crer ou charger?",
            PUBLISH: "publiez votre pisode",
            TITLE: "donnez un nom  votre pisode",
            TOGGLE_VISIBILITY: "touchez pour afficher/masquer les sujets",
            WRITE: "crivez vos sujets"
        },
        WARNING: {
            DELETE: "Voulez-vous vraiment supprimer cet pisode?",
            TOS: "En partageant votre contenu, vous acceptez nos [tos]Conditions de service[/tos]",
            TOS_AGREE: "accepter et partager"
        },
        BACK_TO_EPISODES: "retour aux pisodes",
        BACK_TO_MENU: "retour au menu",
        CREATE_NEW_EPISODE: "crer un nouvel pisode",
        PREVIOUS_EPISODES: "pisodes prcdents",
        PROMPT_ADD: "ajouter un sujet",
        PROMPT_PLACEHOLDER: "taper un sujet",
        PROMPTS_COUNT_HIDDEN: "({count} non affich)",
        TITLE_PLACEHOLDER: "taper un titre"
    },
    _Q = {
        BROADCASTER: {
            SUBTEXT: "La connexion de votre compte  l'extension Twitch Jackbox Audience Kit a russi.",
            WARNING: "LE PARAMTRE 'PUBLIC' N'EST PAS ACTIV DANS CETTE SALLE."
        },
        RECONNECTED: {
            TEXT: "RECONNECT(E)",
            SUBTEXT: "Amusez-vous bien!"
        },
        RECONNECTING: {
            CONTROLLER: {
                TEXT: "CONNEXION INTERROMPUE",
                SUBTEXT: "Tentative de reconnexion ({attempt} sur 5)"
            },
            GAME: {
                TEXT: "CONNEXION AU JEU INTERROMPUE",
                SUBTEXT: "Veuillez patienter pendant que nous tentons de vous reconnecter."
            }
        },
        PAUSED: {
            TEXT: "LA PARTIE EST EN PAUSE",
            SUBTEXT: "Tout ce que vous proposez sera quand mme envoy dans le jeu."
        }
    },
    yQ = {
        SHARE: "Partager",
        COPY_TO_CLIPBOARD: "Copier dans le presse-papiers",
        COPIED: "Copi"
    },
    vQ = {
        ACTION: oQ,
        ALT: aQ,
        ERROR: cQ,
        LOADING: lQ,
        LOBBY: uQ,
        POST_GAME: hQ,
        SEPARATOR: fQ,
        TUTORIAL: dQ,
        AUDIENCE: pQ,
        GALLERY: mQ,
        UGC: gQ,
        TOAST: _Q,
        SHARE: yQ
    },
    bQ = {
        BACK: "Indietro",
        CANCEL: "Annulla",
        CLOSE: "Chiuda",
        CONFIRM: "Conferma",
        CREATE: "Crea",
        DELETE: "Elimina",
        DONE: "Fine",
        EDIT: "Modifica",
        OK: "OK",
        NEXT: "Prossimo",
        NO: "No",
        PLAY: "Gioca",
        PUBLISH: "Pubblica",
        REMOVE: "Rimuovi",
        RESET: "Reset",
        SUBMIT: "Invia",
        TRY_AGAIN: "Riprova",
        UNDO: "Annulla",
        YES: "S"
    },
    EQ = {
        UGC: {
            VISIBILITY_CONTROLLER_OFF: "definizioni nascoste sui dispositivi dei giocatori",
            VISIBILITY_CONTROLLER_ON: "definizioni visualizzate sui dispositivi dei giocatori",
            VISIBILITY_SCREEN_OFF: "definizioni nascoste sullo schermo di gioco",
            VISIBILITY_SCREEN_ON: "definizioni visualizzate sullo schermo di gioco"
        }
    },
    TQ = {
        DISCONNECTED: " stata effettuata la disconnessione.",
        DRAWING_NOTHING: "Devi disegnare qualcosa!",
        PLAYER_KICKED: "Un moderatore ti ha cacciato dalla partita.",
        ROOM_DESTROYED: "Grazie per aver scelto di giocare con noi!",
        ROOM_DISCONNECTED: "Disconnessione effettuata",
        TEXT_NAUGHTY: "Purtroppo non puoi scrivere questa cosa. Abbi rispetto per gli altri giocatori.",
        TEXT_NOTHING: "Devi per forza inserire qualcosa!",
        TITLE: "Errore"
    },
    SQ = "CARICAMENTO",
    wQ = {
        JOINED_COUNT: "{count} su {maxPlayers} giocatori in partita",
        PLAYERS_NEEDED: "Manca 1 giocatore per iniziare | Mancano {count} giocatori per iniziare",
        WAITING_FOR_VIP: "In attesa di {name} per iniziare la partita",
        WAITING_FOR_GAMEPAD: "In attesa d'iniziare la partita",
        WAITING_FOR_NEW_GAME: "In attesa d'iniziare una nuova partita",
        GAME_STARTING: "La partita sta per iniziare",
        BUTTON_START: "Premi per avviare",
        BUTTON_CANCEL: "Premi per annullare"
    },
    AQ = {
        GALLERY_LINK: "Visita la galleria",
        NEW_GAME_STARTED: " iniziata una nuova partita",
        PLAY_AGAIN: "Vuoi giocare di nuovo?",
        THANKS_FOR_PLAYING: "Grazie per aver scelto di giocare con noi!",
        BUTTON_GO_TO_GAME: "Vai al gioco",
        BUTTON_GO_TO_JACKBOX: "Torna a jackbox.tv",
        BUTTON_SAME_PLAYERS: "Stessi giocatori",
        BUTTON_NEW_PLAYERS: "Nuovi giocatori"
    },
    OQ = {
        AND: "E",
        OR: "O"
    },
    CQ = {
        BUTTON_SKIP: "Salta",
        BUTTON_NEXT: "Avanti",
        BUTTON_DONE: "Iniziamo!"
    },
    kQ = {
        NAME: "PUBBLICO"
    },
    IQ = {
        CART: {
            CHECK_OUT: "Vai al pagamento",
            EMPTY: "Il carrello  vuoto",
            TITLE: "Carrello",
            TOTAL: "Totale"
        }
    },
    NQ = {
        EPISODE_REPORT: "Segnala episodio",
        EPISODE_UNLOAD: "Rimuovi episodio",
        EPISODE_VIEW_AUTHOR: "Mostra autore",
        EPISODES_LOAD: "Carica un episodio in base al suo id:",
        EPISODES_MENU: "Menu Episodi",
        EPISODES_SELECT: "Oppure seleziona un episodio:",
        EPISODES_WARNING: "Attenzione: il contenuto generato dagli utenti non  classificato",
        INSTRUCTION: {
            CREATE_TITLE: "per prima cosa, inserisci un nome per lepisodio che contenga tutti i tuoi suggerimenti e premi crea.",
            LOAD: "creare o caricare?",
            PUBLISH: "pubblica il tuo episodio",
            TITLE: "dai un nome al tuo episodio",
            TOGGLE_VISIBILITY: "tocca per mostrare/nascondere suggerimenti",
            WRITE: "scrivi le tue definizioni"
        },
        WARNING: {
            DELETE: "Vuoi davvero eliminare questo episodio?",
            TOS: "Condividendo i contenuti, accetti le nostre [tos]Condizioni del servizio[/tos]",
            TOS_AGREE: "accetta e condividi"
        },
        BACK_TO_EPISODES: "torna agli episodi",
        BACK_TO_MENU: "torna al menu",
        CREATE_NEW_EPISODE: "crea un nuovo episodio",
        PREVIOUS_EPISODES: "episodi precedenti",
        PROMPT_ADD: "aggiungi suggerimento",
        PROMPT_PLACEHOLDER: "inserisci suggerimento",
        PROMPTS_COUNT_HIDDEN: "({count} nascosti)",
        TITLE_PLACEHOLDER: "inserisci un titolo"
    },
    xQ = {
        BROADCASTER: {
            SUBTEXT: "Il collegamento del tuo account con l'estensione per Twitch Jackbox Audience Kit  andato a buon fine.",
            WARNING: "L'IMPOSTAZIONE DEL PUBBLICO NON  ATTIVA PER QUESTA STANZA"
        },
        RECONNECTED: {
            TEXT: "RICONNESSO",
            SUBTEXT: "Buon divertimento!"
        },
        RECONNECTING: {
            CONTROLLER: {
                TEXT: "CONNESSIONE INTERROTTA",
                SUBTEXT: "Tentativo di riconnessione in corso ({attempt} di 5)"
            },
            GAME: {
                TEXT: "CONNESSIONE AL GIOCO INTERROTTA",
                SUBTEXT: "Resta in attesa mentre proviamo a riconnetterci"
            }
        },
        PAUSED: {
            TEXT: "IL GIOCO  IN PAUSA",
            SUBTEXT: "Qualsiasi cosa invii sar comunque inviata al gioco."
        }
    },
    PQ = {
        SHARE: "Condividi",
        COPY_TO_CLIPBOARD: "Copia negli appunti",
        COPIED: "Copiato"
    },
    RQ = {
        ACTION: bQ,
        ALT: EQ,
        ERROR: TQ,
        LOADING: SQ,
        LOBBY: wQ,
        POST_GAME: AQ,
        SEPARATOR: OQ,
        TUTORIAL: CQ,
        AUDIENCE: kQ,
        GALLERY: IQ,
        UGC: NQ,
        TOAST: xQ,
        SHARE: PQ
    },
    MQ = {
        BACK: "Zurck",
        CANCEL: "Abbrechen",
        CLOSE: "Schlieen",
        CONFIRM: "Besttigen",
        CREATE: "Erstellen",
        DELETE: "Lschen",
        DONE: "Fertig",
        EDIT: "Bearbeiten",
        OK: "OK",
        NEXT: "Weiter",
        NO: "Nein",
        PLAY: "Spielen",
        PUBLISH: "Verffentlichen",
        REMOVE: "Entfernen",
        RESET: "Neu starten",
        SUBMIT: "Abschicken",
        TRY_AGAIN: "Erneut versuchen",
        UNDO: "Rckgngig",
        YES: "Ja"
    },
    DQ = {
        UGC: {
            VISIBILITY_CONTROLLER_OFF: "Prompts auf Spielergerten verborgen",
            VISIBILITY_CONTROLLER_ON: "Prompts auf Spielergerten angezeigt",
            VISIBILITY_SCREEN_OFF: "Prompts auf Spielbildschirm verborgen",
            VISIBILITY_SCREEN_ON: "Prompts auf Spielbildschirm angezeigt"
        }
    },
    $Q = {
        DISCONNECTED: "Deine Verbindung wurde getrennt.",
        DRAWING_NOTHING: "Du musst irgendwas zeichnen!",
        PLAYER_KICKED: "Du wurdest von einem Moderator gekickt.",
        ROOM_DESTROYED: "Danke frs Spielen!",
        ROOM_DISCONNECTED: "Verbindung getrennt",
        TEXT_NAUGHTY: "Das kannst du leider nicht schreiben. Bitte nimm Rcksicht auf deine Mitspieler.",
        TEXT_NOTHING: "Du musst etwas eingeben!",
        TITLE: "Fehler"
    },
    LQ = "LADE",
    FQ = {
        JOINED_COUNT: "{count} von {maxPlayers} Spielern sind beigetreten",
        PLAYERS_NEEDED: "1 Spieler zum Starten bentigt | {count} Spieler zum Starten bentigt",
        WAITING_FOR_VIP: "Warten, bis {name} das Spiel startet",
        WAITING_FOR_GAMEPAD: "Warten, bis das Spiel startet",
        WAITING_FOR_NEW_GAME: "Warten, bis ein neues Spiel startet",
        GAME_STARTING: "Das Spiel beginnt",
        BUTTON_START: "Zum Starten drcken",
        BUTTON_CANCEL: "Zum Abbrechen drcken"
    },
    UQ = {
        GALLERY_LINK: "Galerie besuchen",
        NEW_GAME_STARTED: "Ein neues Spiel hat begonnen",
        PLAY_AGAIN: "Erneut spielen?",
        THANKS_FOR_PLAYING: "Danke frs Spielen!",
        BUTTON_GO_TO_GAME: "Zum Spiel",
        BUTTON_GO_TO_JACKBOX: "Zurck zu jackbox.tv",
        BUTTON_SAME_PLAYERS: "Selbe Spieler",
        BUTTON_NEW_PLAYERS: "Neue Spieler"
    },
    BQ = {
        AND: "UND",
        OR: "ODER"
    },
    qQ = {
        BUTTON_SKIP: "berspringen",
        BUTTON_NEXT: "Weiter",
        BUTTON_DONE: "Los geht's!"
    },
    GQ = {
        NAME: "PUBLIKUM"
    },
    VQ = {
        CART: {
            CHECK_OUT: "Kasse",
            EMPTY: "Dein Einkaufswagen ist leer",
            TITLE: "Einkaufswagen",
            TOTAL: "Gesamtsumme"
        }
    },
    jQ = {
        EPISODE_REPORT: "Episode melden",
        EPISODE_UNLOAD: "Episode deaktivieren",
        EPISODE_VIEW_AUTHOR: "Autor ansehen",
        EPISODES_LOAD: "Lade eine Episode ber dessen ID:",
        EPISODES_MENU: "Episoden-Men",
        EPISODES_SELECT: "Oder whle eine Episode aus:",
        EPISODES_WARNING: "Achtung: Von Nutzern erstellte Inhalte werden nicht auf Familientauglichkeit geprft",
        INSTRUCTION: {
            CREATE_TITLE: 'Benenne als allererstes deine Episode, die alle deine Prompts enthalten wird und drcke dann "Erstellen".',
            LOAD: "Erstellen oder laden?",
            PUBLISH: "Verffentliche deine Episode",
            TITLE: "Benenne deine Episode",
            TOGGLE_VISIBILITY: "Drcken, um Prompts zu zeigen / zu verstecken",
            WRITE: "Schreibe deine Prompts"
        },
        WARNING: {
            DELETE: "Bist du sicher, dass du diese Episode lschen mchtest?",
            TOS: "Durch das Teilen von Inhalten stimmst du unseren [tos]Nutzungsbedingungen[/tos] zu",
            TOS_AGREE: "Zustimmen und teilen"
        },
        BACK_TO_EPISODES: "Zurck zu den Episoden",
        BACK_TO_MENU: "Zurck zum Men",
        CREATE_NEW_EPISODE: "Eigene Episode erstellen",
        PREVIOUS_EPISODES: "Vorige Episoden",
        PROMPT_ADD: "Prompt hinzufgen",
        PROMPT_PLACEHOLDER: "Prompt eingeben",
        PROMPTS_COUNT_HIDDEN: "({count} versteckt)",
        TITLE_PLACEHOLDER: "Titel eingeben"
    },
    WQ = {
        BROADCASTER: {
            SUBTEXT: "Du hast dein Konto erfolgreich mit der Jackbox Audience Kit Twitch-Erweiterung verknpft.",
            WARNING: "FR DIESEN RAUM IST DIE PUBLIKUMS-EINSTELLUNG NICHT AKTIV"
        },
        RECONNECTED: {
            TEXT: "NEU VERBUNDEN",
            SUBTEXT: "Viel Spa!"
        },
        RECONNECTING: {
            CONTROLLER: {
                TEXT: "VERBINDUNG UNTERBROCHEN",
                SUBTEXT: "Versuche neu zu verbinden ({attempt} von 5)"
            },
            GAME: {
                TEXT: "VERBINDUNG ZUM SPIEL UNTERBROCHEN",
                SUBTEXT: "Bitte warte whrend wir versuchen, die Verbindung wiederherzustellen."
            }
        },
        PAUSED: {
            TEXT: "DAS SPIEL IST PAUSIERT",
            SUBTEXT: "Alles, was du abschickst, wird weiterhin ans Spiel gesendet."
        }
    },
    HQ = {
        SHARE: "Teilen",
        COPY_TO_CLIPBOARD: "In Zwischenablage kopieren",
        COPIED: "Kopiert"
    },
    YQ = {
        ACTION: MQ,
        ALT: DQ,
        ERROR: $Q,
        LOADING: LQ,
        LOBBY: FQ,
        POST_GAME: UQ,
        SEPARATOR: BQ,
        TUTORIAL: qQ,
        AUDIENCE: GQ,
        GALLERY: VQ,
        UGC: jQ,
        TOAST: WQ,
        SHARE: HQ
    },
    zQ = {
        BACK: "Atrs",
        CANCEL: "Cancelar",
        CLOSE: "Cerrar",
        CONFIRM: "Confirmar",
        CREATE: "Crear",
        DELETE: "Borrar",
        DONE: "Hecho",
        EDIT: "Editar",
        OK: "Aceptar",
        NEXT: "Siguiente",
        NO: "No",
        PLAY: "Jugar",
        PUBLISH: "Publicar",
        REMOVE: "Eliminar",
        RESET: "Reiniciar",
        SUBMIT: "Enviar",
        TRY_AGAIN: "Volver a intentarlo",
        UNDO: "Deshacer",
        YES: "S"
    },
    KQ = {
        UGC: {
            VISIBILITY_CONTROLLER_OFF: "los enunciados no se muestran en el dispositivo del jugador",
            VISIBILITY_CONTROLLER_ON: "los enunciados se muestran en el dispositivo del jugador",
            VISIBILITY_SCREEN_OFF: "los enunciados no se muestran en la pantalla",
            VISIBILITY_SCREEN_ON: "los enunciados se muestran en la pantalla"
        }
    },
    ZQ = {
        DISCONNECTED: "Te has desconectado.",
        DRAWING_NOTHING: "Tienes que dibujar algo!",
        PLAYER_KICKED: "Un moderador te ha expulsado de la partida.",
        ROOM_DESTROYED: "Gracias por jugar!",
        ROOM_DISCONNECTED: "Desconectado",
        TEXT_NAUGHTY: "Lo siento, no puedes escribir eso. Hay que ser respetuoso con los dems jugadores.",
        TEXT_NOTHING: "Tienes que escribir algo",
        TITLE: "Error"
    },
    XQ = "CARGANDO",
    QQ = {
        JOINED_COUNT: "Se han unido {count} de {maxPlayers} jugadores",
        PLAYERS_NEEDED: "Se necesita 1 jugador para empezar | Se necesitan {count} jugadores para empezar",
        WAITING_FOR_VIP: "Esperando a que {name} inicie la partida",
        WAITING_FOR_GAMEPAD: "Esperando a que empiece la partida",
        WAITING_FOR_NEW_GAME: "Esperando a que empiece otra partida",
        GAME_STARTING: "La partida va a empezar",
        BUTTON_START: "Pulsa para empezar",
        BUTTON_CANCEL: "Pulsa para cancelar"
    },
    JQ = {
        GALLERY_LINK: "Visita la galera",
        NEW_GAME_STARTED: "Ha empezado una nueva partida",
        PLAY_AGAIN: "Jugar otra vez?",
        THANKS_FOR_PLAYING: "Gracias por jugar!",
        BUTTON_GO_TO_GAME: "Ir a al juego",
        BUTTON_GO_TO_JACKBOX: "Volver a jackbox.tv",
        BUTTON_SAME_PLAYERS: "Los mismos jugadores",
        BUTTON_NEW_PLAYERS: "Nuevos jugadores"
    },
    eJ = {
        AND: "Y",
        OR: "O"
    },
    tJ = {
        BUTTON_SKIP: "Omitir",
        BUTTON_NEXT: "Siguiente",
        BUTTON_DONE: "Vamos!"
    },
    nJ = {
        NAME: "PBLICO"
    },
    rJ = {
        CART: {
            CHECK_OUT: "Pagar",
            EMPTY: "El carrito est vaco",
            TITLE: "Carrito de la compra",
            TOTAL: "Total"
        }
    },
    sJ = {
        EPISODE_REPORT: "Denunciar episodio",
        EPISODE_UNLOAD: "Retirar episodio",
        EPISODE_VIEW_AUTHOR: "Ver autor",
        EPISODES_LOAD: "Cargar un episodio por ID:",
        EPISODES_MENU: "Men de episodios",
        EPISODES_SELECT: "O selecciona un episodio:",
        EPISODES_WARNING: "Aviso: El contenido de los usuarios no tiene clasificacin de edad",
        INSTRUCTION: {
            CREATE_TITLE: "en primer lugar, ponle un nombre al episodio que contendr tus enunciados y dale a crear.",
            LOAD: "crear o cargar?",
            PUBLISH: "publica tu episodio",
            TITLE: "ponle nombre al episodio",
            TOGGLE_VISIBILITY: "toca para mostrar u ocultar los enunciados",
            WRITE: "escribe los enunciados"
        },
        WARNING: {
            DELETE: "Seguro que quieres borrar este episodio?",
            TOS: "Al compartir contenidos, aceptas las [tos]Condiciones del servicio[/tos]",
            TOS_AGREE: "aceptar y compartir"
        },
        BACK_TO_EPISODES: "volver a los episodios",
        BACK_TO_MENU: "volver al men",
        CREATE_NEW_EPISODE: "crear nuevo episodio",
        PREVIOUS_EPISODES: "episodios anteriores",
        PROMPT_ADD: "aadir enunciado",
        PROMPT_PLACEHOLDER: "escribe un enunciado",
        PROMPTS_COUNT_HIDDEN: "({count} ocultos)",
        TITLE_PLACEHOLDER: "escribe un ttulo"
    },
    iJ = {
        BROADCASTER: {
            SUBTEXT: "Has conectado tu cuenta con xito a la extensin de Twitch del kit para pblico de Jackbox.",
            WARNING: "ESTA SALA NO TIENE LA FUNCIN DE PBLICO HABILITADA"
        },
        RECONNECTED: {
            TEXT: "CONEXIN RESTABLECIDA",
            SUBTEXT: "Divirtete!"
        },
        RECONNECTING: {
            CONTROLLER: {
                TEXT: "SE HA INTERRUMPIDO LA CONEXIN",
                SUBTEXT: "Recuperando conexin (intento {attempt} de 5)"
            },
            GAME: {
                TEXT: "SE HA INTERRUMPIDO LA CONEXIN CON EL JUEGO",
                SUBTEXT: "Espera mientras intentamos recuperar la conexin"
            }
        },
        PAUSED: {
            TEXT: "PARTIDA EN PAUSA",
            SUBTEXT: "Tus respuestas se enviarn igualmente al juego."
        }
    },
    oJ = {
        SHARE: "Compartir",
        COPY_TO_CLIPBOARD: "Copiar al portapapeles",
        COPIED: "Copiado"
    },
    aJ = {
        ACTION: zQ,
        ALT: KQ,
        ERROR: ZQ,
        LOADING: XQ,
        LOBBY: QQ,
        POST_GAME: JQ,
        SEPARATOR: eJ,
        TUTORIAL: tJ,
        AUDIENCE: nJ,
        GALLERY: rJ,
        UGC: sJ,
        TOAST: iJ,
        SHARE: oJ
    },
    cJ = {
        BACK: "Volver",
        CANCEL: "Cancelar",
        CLOSE: "Cerrar",
        CONFIRM: "Confirmar",
        CREATE: "Crear",
        DELETE: "Borrar",
        DONE: "Listo",
        EDIT: "Editar",
        OK: "Aceptar",
        NEXT: "Siguiente",
        NO: "No",
        PLAY: "Jugar",
        PUBLISH: "Publicar",
        REMOVE: "Quitar",
        RESET: "Reiniciar",
        SUBMIT: "Enviar",
        TRY_AGAIN: "Volver a intentarlo",
        UNDO: "Deshacer",
        YES: "S"
    },
    lJ = {
        UGC: {
            VISIBILITY_CONTROLLER_OFF: "indicaciones ocultas en los dispositivos de los jugadores",
            VISIBILITY_CONTROLLER_ON: "indicaciones presentes en los dispositivos de los jugadores",
            VISIBILITY_SCREEN_OFF: "indicaciones ocultas en la pantalla del juego",
            VISIBILITY_SCREEN_ON: "indicaciones presentes en la pantalla del juego"
        }
    },
    uJ = {
        DISCONNECTED: "Te desconectaste.",
        DRAWING_NOTHING: "Tienes que dibujar algo!",
        PLAYER_KICKED: "Un moderador te expuls del juego.",
        ROOM_DESTROYED: "Gracias por jugar!",
        ROOM_DISCONNECTED: "Desconectado",
        TEXT_NAUGHTY: "Lo siento, no puedes escribir eso. Seamos respetuosos con los dems jugadores.",
        TEXT_NOTHING: "Tienes que escribir algo!",
        TITLE: "Error"
    },
    hJ = "CARGANDO",
    fJ = {
        JOINED_COUNT: "{count} de {maxPlayers} jugadores se unieron",
        PLAYERS_NEEDED: "Se necesita 1 jugador para empezar | Se necesitan {count} jugadores para empezar",
        WAITING_FOR_VIP: "Esperando a que {name} inicie la partida",
        WAITING_FOR_GAMEPAD: "Esperando a que empiece la partida",
        WAITING_FOR_NEW_GAME: "Esperando a que empiece una partida nueva",
        GAME_STARTING: "La partida va a empezar",
        BUTTON_START: "Pulsa para empezar",
        BUTTON_CANCEL: "Pulsa para cancelar"
    },
    dJ = {
        GALLERY_LINK: "Visita la galera",
        NEW_GAME_STARTED: "Una partida nueva ha empezado",
        PLAY_AGAIN: "Jugar otra vez?",
        THANKS_FOR_PLAYING: "Gracias por jugar!",
        BUTTON_GO_TO_GAME: "Ir a la partida",
        BUTTON_GO_TO_JACKBOX: "Volver a jackbox.tv",
        BUTTON_SAME_PLAYERS: "Los mismos jugadores",
        BUTTON_NEW_PLAYERS: "Nuevos jugadores"
    },
    pJ = {
        AND: "Y",
        OR: "O"
    },
    mJ = {
        BUTTON_SKIP: "Omitir",
        BUTTON_NEXT: "Siguiente",
        BUTTON_DONE: "Vamos!"
    },
    gJ = {
        NAME: "PBLICO"
    },
    _J = {
        CART: {
            CHECK_OUT: "Comprar ahora",
            EMPTY: "Tu carrito est vaco",
            TITLE: "Carrito de compras",
            TOTAL: "Total"
        }
    },
    yJ = {
        EPISODE_REPORT: "Denunciar episodio",
        EPISODE_UNLOAD: "Descargar episodio",
        EPISODE_VIEW_AUTHOR: "Ver autor",
        EPISODES_LOAD: "Cargar un episodio por ID:",
        EPISODES_MENU: "Men de episodios",
        EPISODES_SELECT: "O selecciona un episodio:",
        EPISODES_WARNING: "Aviso: El contenido de los usuarios no tiene clasificacin por edades",
        INSTRUCTION: {
            CREATE_TITLE: "Lo primero que debes hacer es escribir un nombre para el episodio que contendr todas sus indicaciones y pulsar crear.",
            LOAD: "Crear o cargar?",
            PUBLISH: "Publica tu episodio",
            TITLE: "Nombra tu episodio",
            TOGGLE_VISIBILITY: "Pulsa para mostrar/ocultar las indicaciones",
            WRITE: "Escribe tus indicaciones"
        },
        WARNING: {
            DELETE: "De verdad quieres borrar este episodio?",
            TOS: "Al compartir contenido, aceptas nuestros [tos]Trminos de servicio[/tos]",
            TOS_AGREE: "Aceptar y compartir"
        },
        BACK_TO_EPISODES: "Volver a los episodios",
        BACK_TO_MENU: "Volver al men",
        CREATE_NEW_EPISODE: "Crear un nuevo episodio",
        PREVIOUS_EPISODES: "Episodios anteriores",
        PROMPT_ADD: "Aadir indicacin",
        PROMPT_PLACEHOLDER: "Escribe una indicacin",
        PROMPTS_COUNT_HIDDEN: "({count} oculto(s))",
        TITLE_PLACEHOLDER: "Escribir un ttulo"
    },
    vJ = {
        BROADCASTER: {
            SUBTEXT: "Conectaste correctamente tu cuenta a la extensin para Twitch del kit para pblico de Jackbox.",
            WARNING: "ESTA SALA NO TIENE ACTIVADA LA OPCIN DE PBLICO"
        },
        RECONNECTED: {
            TEXT: "CONEXIN RESTABLECIDA",
            SUBTEXT: "Divirtete!"
        },
        RECONNECTING: {
            CONTROLLER: {
                TEXT: "CONEXIN INTERRUMPIDA",
                SUBTEXT: "Intento de reconexin ({attempt} de 5)"
            },
            GAME: {
                TEXT: "SE INTERRUMPI LA CONEXIN AL JUEGO",
                SUBTEXT: "Espera mientras intentamos restablecer la conexin"
            }
        },
        PAUSED: {
            TEXT: "EL JUEGO EST EN PAUSA",
            SUBTEXT: "Todo lo que ingreses ser enviado al juego."
        }
    },
    bJ = {
        SHARE: "Compartir",
        COPY_TO_CLIPBOARD: "Copiar al portapapeles",
        COPIED: "Se copi"
    },
    EJ = {
        ACTION: cJ,
        ALT: lJ,
        ERROR: uJ,
        LOADING: hJ,
        LOBBY: fJ,
        POST_GAME: dJ,
        SEPARATOR: pJ,
        TUTORIAL: mJ,
        AUDIENCE: gJ,
        GALLERY: _J,
        UGC: yJ,
        TOAST: vJ,
        SHARE: bJ
    },
    TJ = {
        BACK: "Voltar",
        CANCEL: "Cancelar",
        CLOSE: "Fechar",
        CONFIRM: "Confirmar",
        CREATE: "Criar",
        DELETE: "Excluir",
        DONE: "Pronto",
        EDIT: "Editar",
        OK: "OK",
        NEXT: "Avanar",
        NO: "No",
        PLAY: "Jogar",
        PUBLISH: "Publicar",
        REMOVE: "Remover",
        RESET: "Redefinir",
        SUBMIT: "Enviar",
        TRY_AGAIN: "Tentar de novo",
        UNDO: "Desfazer",
        YES: "Sim"
    },
    SJ = {
        UGC: {
            VISIBILITY_CONTROLLER_OFF: "enunciados ocultos no dispositivo dos jogadores",
            VISIBILITY_CONTROLLER_ON: "enunciados exibidos no dispositivo dos jogadores",
            VISIBILITY_SCREEN_OFF: "enunciados ocultos na tela do jogo",
            VISIBILITY_SCREEN_ON: "enunciados exibidos na tela do jogo"
        }
    },
    wJ = {
        DISCONNECTED: "Voc foi desconectado.",
        DRAWING_NOTHING: "Voc tem que desenhar!",
        PLAYER_KICKED: "Voc foi expulso do jogo por um moderador.",
        ROOM_DESTROYED: "Obrigado por jogar!",
        ROOM_DISCONNECTED: "Desconectado",
        TEXT_NAUGHTY: "No pode escrever isso. Respeite os outros jogadores.",
        TEXT_NOTHING: "No d para inserir texto vazio!",
        TITLE: "Erro"
    },
    AJ = "CARREGANDO",
    OJ = {
        JOINED_COUNT: "{count} de {maxPlayers} jogadores entraram",
        PLAYERS_NEEDED: "1 jogador necessrio para comear | {count} jogadores necessrios para comear",
        WAITING_FOR_VIP: "Aguardando {name} comear o jogo",
        WAITING_FOR_GAMEPAD: "Aguardando o comeo do jogo",
        WAITING_FOR_NEW_GAME: "Aguardando o comeo de uma nova partida",
        GAME_STARTING: "O jogo est comeando",
        BUTTON_START: "Aperte para comear",
        BUTTON_CANCEL: "Aperte para cancelar"
    },
    CJ = {
        GALLERY_LINK: "Visitar a galeria",
        NEW_GAME_STARTED: "Comeou uma nova partida",
        PLAY_AGAIN: "Jogar de novo?",
        THANKS_FOR_PLAYING: "Obrigado por jogar!",
        BUTTON_GO_TO_GAME: "Ir para o jogo",
        BUTTON_GO_TO_JACKBOX: "Voltar para jackbox.tv",
        BUTTON_SAME_PLAYERS: "Mesmos jogadores",
        BUTTON_NEW_PLAYERS: "Outros jogadores"
    },
    kJ = {
        AND: "E",
        OR: "OU"
    },
    IJ = {
        BUTTON_SKIP: "Pular",
        BUTTON_NEXT: "Avanar",
        BUTTON_DONE: "Vamos l!"
    },
    NJ = {
        NAME: "PLATEIA"
    },
    xJ = {
        CART: {
            CHECK_OUT: "Finalizar",
            EMPTY: "Seu carrinho est vazio",
            TITLE: "Carrinho de Compras",
            TOTAL: "Total"
        }
    },
    PJ = {
        EPISODE_REPORT: "Denunciar episdio",
        EPISODE_UNLOAD: "Excluir cpia local do episdio",
        EPISODE_VIEW_AUTHOR: "Visualizar autor",
        EPISODES_LOAD: "Carregar um episdio por ID:",
        EPISODES_MENU: "Menu de episdios",
        EPISODES_SELECT: "Ou selecione um episdio:",
        EPISODES_WARNING: "Aviso: os contedos gerados pelos usurios no tm classificao indicativa",
        INSTRUCTION: {
            CREATE_TITLE: "para comear, insira o nome do episdio que conter todos os seus enunciados e aperte Criar.",
            LOAD: "criar ou carregar?",
            PUBLISH: "publicar seu episdio",
            TITLE: "d um nome ao seu episdio",
            TOGGLE_VISIBILITY: "toque para exibir/ocultar enunciados",
            WRITE: "escreva seus enunciados"
        },
        WARNING: {
            DELETE: "Deseja mesmo excluir este episdio?",
            TOS: "Ao compartilhar contedo, voc concordar com os nossos [tos]Termos de Servio[/tos]",
            TOS_AGREE: "concordar e compartilhar"
        },
        BACK_TO_EPISODES: "voltar aos episdios",
        BACK_TO_MENU: "voltar ao menu",
        CREATE_NEW_EPISODE: "criar novo episdio",
        PREVIOUS_EPISODES: "episdios anteriores",
        PROMPT_ADD: "adicionar enunciado",
        PROMPT_PLACEHOLDER: "insira um enunciado",
        PROMPTS_COUNT_HIDDEN: "({count} oculto[s])",
        TITLE_PLACEHOLDER: "insira um ttulo"
    },
    RJ = {
        BROADCASTER: {
            SUBTEXT: "Voc conectou sua conta  extenso Jackbox Audience Kit para Twitch.",
            WARNING: "A CONFIGURAO DE PLATEIA NO EST ATIVA NESTA SALA"
        },
        RECONNECTED: {
            TEXT: "CONEXO RESTABELECIDA",
            SUBTEXT: "Divirtam-se!"
        },
        RECONNECTING: {
            CONTROLLER: {
                TEXT: "CONEXO INTERROMPIDA",
                SUBTEXT: "Tentando reconectar-se ({attempt} de 5)"
            },
            GAME: {
                TEXT: "CONEXO DO JOGO INTERROMPIDA",
                SUBTEXT: "Aguarde enquanto tentamos restabelecer a conexo"
            }
        },
        PAUSED: {
            TEXT: "O JOGO EST PAUSADO",
            SUBTEXT: "Tudo que voc enviar ainda ser enviado ao jogo."
        }
    },
    MJ = {
        SHARE: "Compartilhar",
        COPY_TO_CLIPBOARD: "Copiar para rea de transferncia",
        COPIED: "Copiado"
    },
    DJ = {
        ACTION: TJ,
        ALT: SJ,
        ERROR: wJ,
        LOADING: AJ,
        LOBBY: OJ,
        POST_GAME: CJ,
        SEPARATOR: kJ,
        TUTORIAL: IJ,
        AUDIENCE: NJ,
        GALLERY: xJ,
        UGC: PJ,
        TOAST: RJ,
        SHARE: MJ
    },
    $J = {
        en: iQ,
        fr: vQ,
        it: RQ,
        de: YQ,
        es: aJ,
        "es-XL": EJ,
        "pt-BR": DJ
    };
var m1 = {
    exports: {}
};
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
m1.exports;
(function(t, e) {
    (function() {
        var n, r = "4.17.21",
            s = 200,
            i = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
            o = "Expected a function",
            a = "Invalid `variable` option passed into `_.template`",
            l = "__lodash_hash_undefined__",
            u = 500,
            f = "__lodash_placeholder__",
            d = 1,
            p = 2,
            _ = 4,
            v = 1,
            y = 2,
            g = 1,
            b = 2,
            O = 4,
            N = 8,
            k = 16,
            A = 32,
            x = 64,
            D = 128,
            L = 256,
            q = 512,
            ee = 30,
            ae = "...",
            Z = 800,
            fe = 16,
            ge = 1,
            K = 2,
            Q = 3,
            ue = 1 / 0,
            _e = 9007199254740991,
            Oe = 17976931348623157e292,
            Ee = 0 / 0,
            Ce = 4294967295,
            De = Ce - 1,
            Ue = Ce >>> 1,
            ot = [
                ["ary", D],
                ["bind", g],
                ["bindKey", b],
                ["curry", N],
                ["curryRight", k],
                ["flip", q],
                ["partial", A],
                ["partialRight", x],
                ["rearg", L]
            ],
            je = "[object Arguments]",
            Ze = "[object Array]",
            it = "[object AsyncFunction]",
            w = "[object Boolean]",
            M = "[object Date]",
            Y = "[object DOMException]",
            X = "[object Error]",
            I = "[object Function]",
            T = "[object GeneratorFunction]",
            S = "[object Map]",
            P = "[object Number]",
            G = "[object Null]",
            te = "[object Object]",
            le = "[object Promise]",
            me = "[object Proxy]",
            ve = "[object RegExp]",
            de = "[object Set]",
            oe = "[object String]",
            he = "[object Symbol]",
            Me = "[object Undefined]",
            Fe = "[object WeakMap]",
            at = "[object WeakSet]",
            vt = "[object ArrayBuffer]",
            W = "[object DataView]",
            V = "[object Float32Array]",
            se = "[object Float64Array]",
            j = "[object Int8Array]",
            ne = "[object Int16Array]",
            Te = "[object Int32Array]",
            ke = "[object Uint8Array]",
            xe = "[object Uint8ClampedArray]",
            qe = "[object Uint16Array]",
            Tn = "[object Uint32Array]",
            Hr = /\b__p \+= '';/g,
            ct = /\b(__p \+=) '' \+/g,
            qu = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
            o5 = /&(?:amp|lt|gt|quot|#39);/g,
            a5 = /[&<>"']/g,
            vN = RegExp(o5.source),
            bN = RegExp(a5.source),
            EN = /<%-([\s\S]+?)%>/g,
            TN = /<%([\s\S]+?)%>/g,
            c5 = /<%=([\s\S]+?)%>/g,
            SN = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            wN = /^\w*$/,
            AN = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
            Bg = /[\\^$.*+?()[\]{}|]/g,
            ON = RegExp(Bg.source),
            qg = /^\s+/,
            CN = /\s/,
            kN = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
            IN = /\{\n\/\* \[wrapped with (.+)\] \*/,
            NN = /,? & /,
            xN = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
            PN = /[()=,{}\[\]\/\s]/,
            RN = /\\(\\)?/g,
            MN = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
            l5 = /\w*$/,
            DN = /^[-+]0x[0-9a-f]+$/i,
            $N = /^0b[01]+$/i,
            LN = /^\[object .+?Constructor\]$/,
            FN = /^0o[0-7]+$/i,
            UN = /^(?:0|[1-9]\d*)$/,
            BN = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
            hd = /($^)/,
            qN = /['\n\r\u2028\u2029\\]/g,
            fd = "\\ud800-\\udfff",
            GN = "\\u0300-\\u036f",
            VN = "\\ufe20-\\ufe2f",
            jN = "\\u20d0-\\u20ff",
            u5 = GN + VN + jN,
            h5 = "\\u2700-\\u27bf",
            f5 = "a-z\\xdf-\\xf6\\xf8-\\xff",
            WN = "\\xac\\xb1\\xd7\\xf7",
            HN = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
            YN = "\\u2000-\\u206f",
            zN = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
            d5 = "A-Z\\xc0-\\xd6\\xd8-\\xde",
            p5 = "\\ufe0e\\ufe0f",
            m5 = WN + HN + YN + zN,
            Gg = "[']",
            KN = "[" + fd + "]",
            g5 = "[" + m5 + "]",
            dd = "[" + u5 + "]",
            _5 = "\\d+",
            ZN = "[" + h5 + "]",
            y5 = "[" + f5 + "]",
            v5 = "[^" + fd + m5 + _5 + h5 + f5 + d5 + "]",
            Vg = "\\ud83c[\\udffb-\\udfff]",
            XN = "(?:" + dd + "|" + Vg + ")",
            b5 = "[^" + fd + "]",
            jg = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            Wg = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            Vc = "[" + d5 + "]",
            E5 = "\\u200d",
            T5 = "(?:" + y5 + "|" + v5 + ")",
            QN = "(?:" + Vc + "|" + v5 + ")",
            S5 = "(?:" + Gg + "(?:d|ll|m|re|s|t|ve))?",
            w5 = "(?:" + Gg + "(?:D|LL|M|RE|S|T|VE))?",
            A5 = XN + "?",
            O5 = "[" + p5 + "]?",
            JN = "(?:" + E5 + "(?:" + [b5, jg, Wg].join("|") + ")" + O5 + A5 + ")*",
            ex = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
            tx = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
            C5 = O5 + A5 + JN,
            nx = "(?:" + [ZN, jg, Wg].join("|") + ")" + C5,
            rx = "(?:" + [b5 + dd + "?", dd, jg, Wg, KN].join("|") + ")",
            sx = RegExp(Gg, "g"),
            ix = RegExp(dd, "g"),
            Hg = RegExp(Vg + "(?=" + Vg + ")|" + rx + C5, "g"),
            ox = RegExp([Vc + "?" + y5 + "+" + S5 + "(?=" + [g5, Vc, "$"].join("|") + ")", QN + "+" + w5 + "(?=" + [g5, Vc + T5, "$"].join("|") + ")", Vc + "?" + T5 + "+" + S5, Vc + "+" + w5, tx, ex, _5, nx].join("|"), "g"),
            ax = RegExp("[" + E5 + fd + u5 + p5 + "]"),
            cx = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
            lx = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
            ux = -1,
            tn = {};
        tn[V] = tn[se] = tn[j] = tn[ne] = tn[Te] = tn[ke] = tn[xe] = tn[qe] = tn[Tn] = !0, tn[je] = tn[Ze] = tn[vt] = tn[w] = tn[W] = tn[M] = tn[X] = tn[I] = tn[S] = tn[P] = tn[te] = tn[ve] = tn[de] = tn[oe] = tn[Fe] = !1;
        var Zt = {};
        Zt[je] = Zt[Ze] = Zt[vt] = Zt[W] = Zt[w] = Zt[M] = Zt[V] = Zt[se] = Zt[j] = Zt[ne] = Zt[Te] = Zt[S] = Zt[P] = Zt[te] = Zt[ve] = Zt[de] = Zt[oe] = Zt[he] = Zt[ke] = Zt[xe] = Zt[qe] = Zt[Tn] = !0, Zt[X] = Zt[I] = Zt[Fe] = !1;
        var hx = {
                : "A",
                : "A",
                : "A",
                : "A",
                : "A",
                : "A",
                : "a",
                : "a",
                : "a",
                : "a",
                : "a",
                : "a",
                : "C",
                : "c",
                : "D",
                : "d",
                : "E",
                : "E",
                : "E",
                : "E",
                : "e",
                : "e",
                : "e",
                : "e",
                : "I",
                : "I",
                : "I",
                : "I",
                : "i",
                : "i",
                : "i",
                : "i",
                : "N",
                : "n",
                : "O",
                : "O",
                : "O",
                : "O",
                : "O",
                : "O",
                : "o",
                : "o",
                : "o",
                : "o",
                : "o",
                : "o",
                : "U",
                : "U",
                : "U",
                : "U",
                : "u",
                : "u",
                : "u",
                : "u",
                : "Y",
                : "y",
                : "y",
                : "Ae",
                : "ae",
                : "Th",
                : "th",
                : "ss",
                : "A",
                : "A",
                : "A",
                : "a",
                : "a",
                : "a",
                : "C",
                : "C",
                : "C",
                : "C",
                : "c",
                : "c",
                : "c",
                : "c",
                : "D",
                : "D",
                : "d",
                : "d",
                : "E",
                : "E",
                : "E",
                : "E",
                : "E",
                : "e",
                : "e",
                : "e",
                : "e",
                : "e",
                : "G",
                : "G",
                : "G",
                : "G",
                : "g",
                : "g",
                : "g",
                : "g",
                : "H",
                : "H",
                : "h",
                : "h",
                : "I",
                : "I",
                : "I",
                : "I",
                : "I",
                : "i",
                : "i",
                : "i",
                : "i",
                : "i",
                : "J",
                : "j",
                : "K",
                : "k",
                : "k",
                : "L",
                : "L",
                : "L",
                : "L",
                : "L",
                : "l",
                : "l",
                : "l",
                : "l",
                : "l",
                : "N",
                : "N",
                : "N",
                : "N",
                : "n",
                : "n",
                : "n",
                : "n",
                : "O",
                : "O",
                : "O",
                : "o",
                : "o",
                : "o",
                : "R",
                : "R",
                : "R",
                : "r",
                : "r",
                : "r",
                : "S",
                : "S",
                : "S",
                : "S",
                : "s",
                : "s",
                : "s",
                : "s",
                : "T",
                : "T",
                : "T",
                : "t",
                : "t",
                : "t",
                : "U",
                : "U",
                : "U",
                : "U",
                : "U",
                : "U",
                : "u",
                : "u",
                : "u",
                : "u",
                : "u",
                : "u",
                : "W",
                : "w",
                : "Y",
                : "y",
                : "Y",
                : "Z",
                : "Z",
                : "Z",
                : "z",
                : "z",
                : "z",
                : "IJ",
                : "ij",
                : "Oe",
                : "oe",
                : "'n",
                : "s"
            },
            fx = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
            },
            dx = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&quot;": '"',
                "&#39;": "'"
            },
            px = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029"
            },
            mx = parseFloat,
            gx = parseInt,
            k5 = typeof _n == "object" && _n && _n.Object === Object && _n,
            _x = typeof self == "object" && self && self.Object === Object && self,
            Yn = k5 || _x || Function("return this")(),
            Yg = e && !e.nodeType && e,
            La = Yg && !0 && t && !t.nodeType && t,
            I5 = La && La.exports === Yg,
            zg = I5 && k5.process,
            fs = function() {
                try {
                    var ie = La && La.require && La.require("util").types;
                    return ie || zg && zg.binding && zg.binding("util")
                } catch {}
            }(),
            N5 = fs && fs.isArrayBuffer,
            x5 = fs && fs.isDate,
            P5 = fs && fs.isMap,
            R5 = fs && fs.isRegExp,
            M5 = fs && fs.isSet,
            D5 = fs && fs.isTypedArray;

        function Yr(ie, be, pe) {
            switch (pe.length) {
                case 0:
                    return ie.call(be);
                case 1:
                    return ie.call(be, pe[0]);
                case 2:
                    return ie.call(be, pe[0], pe[1]);
                case 3:
                    return ie.call(be, pe[0], pe[1], pe[2])
            }
            return ie.apply(be, pe)
        }

        function yx(ie, be, pe, Be) {
            for (var ut = -1, $t = ie == null ? 0 : ie.length; ++ut < $t;) {
                var Dn = ie[ut];
                be(Be, Dn, pe(Dn), ie)
            }
            return Be
        }

        function ds(ie, be) {
            for (var pe = -1, Be = ie == null ? 0 : ie.length; ++pe < Be && be(ie[pe], pe, ie) !== !1;);
            return ie
        }

        function vx(ie, be) {
            for (var pe = ie == null ? 0 : ie.length; pe-- && be(ie[pe], pe, ie) !== !1;);
            return ie
        }

        function $5(ie, be) {
            for (var pe = -1, Be = ie == null ? 0 : ie.length; ++pe < Be;)
                if (!be(ie[pe], pe, ie)) return !1;
            return !0
        }

        function wo(ie, be) {
            for (var pe = -1, Be = ie == null ? 0 : ie.length, ut = 0, $t = []; ++pe < Be;) {
                var Dn = ie[pe];
                be(Dn, pe, ie) && ($t[ut++] = Dn)
            }
            return $t
        }

        function pd(ie, be) {
            var pe = ie == null ? 0 : ie.length;
            return !!pe && jc(ie, be, 0) > -1
        }

        function Kg(ie, be, pe) {
            for (var Be = -1, ut = ie == null ? 0 : ie.length; ++Be < ut;)
                if (pe(be, ie[Be])) return !0;
            return !1
        }

        function cn(ie, be) {
            for (var pe = -1, Be = ie == null ? 0 : ie.length, ut = Array(Be); ++pe < Be;) ut[pe] = be(ie[pe], pe, ie);
            return ut
        }

        function Ao(ie, be) {
            for (var pe = -1, Be = be.length, ut = ie.length; ++pe < Be;) ie[ut + pe] = be[pe];
            return ie
        }

        function Zg(ie, be, pe, Be) {
            var ut = -1,
                $t = ie == null ? 0 : ie.length;
            for (Be && $t && (pe = ie[++ut]); ++ut < $t;) pe = be(pe, ie[ut], ut, ie);
            return pe
        }

        function bx(ie, be, pe, Be) {
            var ut = ie == null ? 0 : ie.length;
            for (Be && ut && (pe = ie[--ut]); ut--;) pe = be(pe, ie[ut], ut, ie);
            return pe
        }

        function Xg(ie, be) {
            for (var pe = -1, Be = ie == null ? 0 : ie.length; ++pe < Be;)
                if (be(ie[pe], pe, ie)) return !0;
            return !1
        }
        var Ex = Qg("length");

        function Tx(ie) {
            return ie.split("")
        }

        function Sx(ie) {
            return ie.match(xN) || []
        }

        function L5(ie, be, pe) {
            var Be;
            return pe(ie, function(ut, $t, Dn) {
                if (be(ut, $t, Dn)) return Be = $t, !1
            }), Be
        }

        function md(ie, be, pe, Be) {
            for (var ut = ie.length, $t = pe + (Be ? 1 : -1); Be ? $t-- : ++$t < ut;)
                if (be(ie[$t], $t, ie)) return $t;
            return -1
        }

        function jc(ie, be, pe) {
            return be === be ? Dx(ie, be, pe) : md(ie, F5, pe)
        }

        function wx(ie, be, pe, Be) {
            for (var ut = pe - 1, $t = ie.length; ++ut < $t;)
                if (Be(ie[ut], be)) return ut;
            return -1
        }

        function F5(ie) {
            return ie !== ie
        }

        function U5(ie, be) {
            var pe = ie == null ? 0 : ie.length;
            return pe ? e_(ie, be) / pe : Ee
        }

        function Qg(ie) {
            return function(be) {
                return be == null ? n : be[ie]
            }
        }

        function Jg(ie) {
            return function(be) {
                return ie == null ? n : ie[be]
            }
        }

        function B5(ie, be, pe, Be, ut) {
            return ut(ie, function($t, Dn, Wt) {
                pe = Be ? (Be = !1, $t) : be(pe, $t, Dn, Wt)
            }), pe
        }

        function Ax(ie, be) {
            var pe = ie.length;
            for (ie.sort(be); pe--;) ie[pe] = ie[pe].value;
            return ie
        }

        function e_(ie, be) {
            for (var pe, Be = -1, ut = ie.length; ++Be < ut;) {
                var $t = be(ie[Be]);
                $t !== n && (pe = pe === n ? $t : pe + $t)
            }
            return pe
        }

        function t_(ie, be) {
            for (var pe = -1, Be = Array(ie); ++pe < ie;) Be[pe] = be(pe);
            return Be
        }

        function Ox(ie, be) {
            return cn(be, function(pe) {
                return [pe, ie[pe]]
            })
        }

        function q5(ie) {
            return ie && ie.slice(0, W5(ie) + 1).replace(qg, "")
        }

        function zr(ie) {
            return function(be) {
                return ie(be)
            }
        }

        function n_(ie, be) {
            return cn(be, function(pe) {
                return ie[pe]
            })
        }

        function Gu(ie, be) {
            return ie.has(be)
        }

        function G5(ie, be) {
            for (var pe = -1, Be = ie.length; ++pe < Be && jc(be, ie[pe], 0) > -1;);
            return pe
        }

        function V5(ie, be) {
            for (var pe = ie.length; pe-- && jc(be, ie[pe], 0) > -1;);
            return pe
        }

        function Cx(ie, be) {
            for (var pe = ie.length, Be = 0; pe--;) ie[pe] === be && ++Be;
            return Be
        }
        var kx = Jg(hx),
            Ix = Jg(fx);

        function Nx(ie) {
            return "\\" + px[ie]
        }

        function xx(ie, be) {
            return ie == null ? n : ie[be]
        }

        function Wc(ie) {
            return ax.test(ie)
        }

        function Px(ie) {
            return cx.test(ie)
        }

        function Rx(ie) {
            for (var be, pe = []; !(be = ie.next()).done;) pe.push(be.value);
            return pe
        }

        function r_(ie) {
            var be = -1,
                pe = Array(ie.size);
            return ie.forEach(function(Be, ut) {
                pe[++be] = [ut, Be]
            }), pe
        }

        function j5(ie, be) {
            return function(pe) {
                return ie(be(pe))
            }
        }

        function Oo(ie, be) {
            for (var pe = -1, Be = ie.length, ut = 0, $t = []; ++pe < Be;) {
                var Dn = ie[pe];
                (Dn === be || Dn === f) && (ie[pe] = f, $t[ut++] = pe)
            }
            return $t
        }

        function gd(ie) {
            var be = -1,
                pe = Array(ie.size);
            return ie.forEach(function(Be) {
                pe[++be] = Be
            }), pe
        }

        function Mx(ie) {
            var be = -1,
                pe = Array(ie.size);
            return ie.forEach(function(Be) {
                pe[++be] = [Be, Be]
            }), pe
        }

        function Dx(ie, be, pe) {
            for (var Be = pe - 1, ut = ie.length; ++Be < ut;)
                if (ie[Be] === be) return Be;
            return -1
        }

        function $x(ie, be, pe) {
            for (var Be = pe + 1; Be--;)
                if (ie[Be] === be) return Be;
            return Be
        }

        function Hc(ie) {
            return Wc(ie) ? Fx(ie) : Ex(ie)
        }

        function Ds(ie) {
            return Wc(ie) ? Ux(ie) : Tx(ie)
        }

        function W5(ie) {
            for (var be = ie.length; be-- && CN.test(ie.charAt(be)););
            return be
        }
        var Lx = Jg(dx);

        function Fx(ie) {
            for (var be = Hg.lastIndex = 0; Hg.test(ie);) ++be;
            return be
        }

        function Ux(ie) {
            return ie.match(Hg) || []
        }

        function Bx(ie) {
            return ie.match(ox) || []
        }
        var qx = function ie(be) {
                be = be == null ? Yn : Yc.defaults(Yn.Object(), be, Yc.pick(Yn, lx));
                var pe = be.Array,
                    Be = be.Date,
                    ut = be.Error,
                    $t = be.Function,
                    Dn = be.Math,
                    Wt = be.Object,
                    s_ = be.RegExp,
                    Gx = be.String,
                    ps = be.TypeError,
                    _d = pe.prototype,
                    Vx = $t.prototype,
                    zc = Wt.prototype,
                    yd = be["__core-js_shared__"],
                    vd = Vx.toString,
                    Ut = zc.hasOwnProperty,
                    jx = 0,
                    H5 = function() {
                        var c = /[^.]+$/.exec(yd && yd.keys && yd.keys.IE_PROTO || "");
                        return c ? "Symbol(src)_1." + c : ""
                    }(),
                    bd = zc.toString,
                    Wx = vd.call(Wt),
                    Hx = Yn._,
                    Yx = s_("^" + vd.call(Ut).replace(Bg, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                    Ed = I5 ? be.Buffer : n,
                    Co = be.Symbol,
                    Td = be.Uint8Array,
                    Y5 = Ed ? Ed.allocUnsafe : n,
                    Sd = j5(Wt.getPrototypeOf, Wt),
                    z5 = Wt.create,
                    K5 = zc.propertyIsEnumerable,
                    wd = _d.splice,
                    Z5 = Co ? Co.isConcatSpreadable : n,
                    Vu = Co ? Co.iterator : n,
                    Fa = Co ? Co.toStringTag : n,
                    Ad = function() {
                        try {
                            var c = Va(Wt, "defineProperty");
                            return c({}, "", {}), c
                        } catch {}
                    }(),
                    zx = be.clearTimeout !== Yn.clearTimeout && be.clearTimeout,
                    Kx = Be && Be.now !== Yn.Date.now && Be.now,
                    Zx = be.setTimeout !== Yn.setTimeout && be.setTimeout,
                    Od = Dn.ceil,
                    Cd = Dn.floor,
                    i_ = Wt.getOwnPropertySymbols,
                    Xx = Ed ? Ed.isBuffer : n,
                    X5 = be.isFinite,
                    Qx = _d.join,
                    Jx = j5(Wt.keys, Wt),
                    $n = Dn.max,
                    ir = Dn.min,
                    eP = Be.now,
                    tP = be.parseInt,
                    Q5 = Dn.random,
                    nP = _d.reverse,
                    o_ = Va(be, "DataView"),
                    ju = Va(be, "Map"),
                    a_ = Va(be, "Promise"),
                    Kc = Va(be, "Set"),
                    Wu = Va(be, "WeakMap"),
                    Hu = Va(Wt, "create"),
                    kd = Wu && new Wu,
                    Zc = {},
                    rP = ja(o_),
                    sP = ja(ju),
                    iP = ja(a_),
                    oP = ja(Kc),
                    aP = ja(Wu),
                    Id = Co ? Co.prototype : n,
                    Yu = Id ? Id.valueOf : n,
                    J5 = Id ? Id.toString : n;

                function $(c) {
                    if (vn(c) && !ft(c) && !(c instanceof St)) {
                        if (c instanceof ms) return c;
                        if (Ut.call(c, "__wrapped__")) return eE(c)
                    }
                    return new ms(c)
                }
                var Xc = function() {
                    function c() {}
                    return function(h) {
                        if (!dn(h)) return {};
                        if (z5) return z5(h);
                        c.prototype = h;
                        var m = new c;
                        return c.prototype = n, m
                    }
                }();

                function Nd() {}

                function ms(c, h) {
                    this.__wrapped__ = c, this.__actions__ = [], this.__chain__ = !!h, this.__index__ = 0, this.__values__ = n
                }
                $.templateSettings = {
                    escape: EN,
                    evaluate: TN,
                    interpolate: c5,
                    variable: "",
                    imports: {
                        _: $
                    }
                }, $.prototype = Nd.prototype, $.prototype.constructor = $, ms.prototype = Xc(Nd.prototype), ms.prototype.constructor = ms;

                function St(c) {
                    this.__wrapped__ = c, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = Ce, this.__views__ = []
                }

                function cP() {
                    var c = new St(this.__wrapped__);
                    return c.__actions__ = Or(this.__actions__), c.__dir__ = this.__dir__, c.__filtered__ = this.__filtered__, c.__iteratees__ = Or(this.__iteratees__), c.__takeCount__ = this.__takeCount__, c.__views__ = Or(this.__views__), c
                }

                function lP() {
                    if (this.__filtered__) {
                        var c = new St(this);
                        c.__dir__ = -1, c.__filtered__ = !0
                    } else c = this.clone(), c.__dir__ *= -1;
                    return c
                }

                function uP() {
                    var c = this.__wrapped__.value(),
                        h = this.__dir__,
                        m = ft(c),
                        E = h < 0,
                        C = m ? c.length : 0,
                        F = TR(0, C, this.__views__),
                        z = F.start,
                        J = F.end,
                        ce = J - z,
                        we = E ? J : z - 1,
                        Ae = this.__iteratees__,
                        Ie = Ae.length,
                        Re = 0,
                        We = ir(ce, this.__takeCount__);
                    if (!m || !E && C == ce && We == ce) return S4(c, this.__actions__);
                    var et = [];
                    e: for (; ce-- && Re < We;) {
                        we += h;
                        for (var _t = -1, tt = c[we]; ++_t < Ie;) {
                            var Tt = Ae[_t],
                                Ct = Tt.iteratee,
                                Xr = Tt.type,
                                yr = Ct(tt);
                            if (Xr == K) tt = yr;
                            else if (!yr) {
                                if (Xr == ge) continue e;
                                break e
                            }
                        }
                        et[Re++] = tt
                    }
                    return et
                }
                St.prototype = Xc(Nd.prototype), St.prototype.constructor = St;

                function Ua(c) {
                    var h = -1,
                        m = c == null ? 0 : c.length;
                    for (this.clear(); ++h < m;) {
                        var E = c[h];
                        this.set(E[0], E[1])
                    }
                }

                function hP() {
                    this.__data__ = Hu ? Hu(null) : {}, this.size = 0
                }

                function fP(c) {
                    var h = this.has(c) && delete this.__data__[c];
                    return this.size -= h ? 1 : 0, h
                }

                function dP(c) {
                    var h = this.__data__;
                    if (Hu) {
                        var m = h[c];
                        return m === l ? n : m
                    }
                    return Ut.call(h, c) ? h[c] : n
                }

                function pP(c) {
                    var h = this.__data__;
                    return Hu ? h[c] !== n : Ut.call(h, c)
                }

                function mP(c, h) {
                    var m = this.__data__;
                    return this.size += this.has(c) ? 0 : 1, m[c] = Hu && h === n ? l : h, this
                }
                Ua.prototype.clear = hP, Ua.prototype.delete = fP, Ua.prototype.get = dP, Ua.prototype.has = pP, Ua.prototype.set = mP;

                function qi(c) {
                    var h = -1,
                        m = c == null ? 0 : c.length;
                    for (this.clear(); ++h < m;) {
                        var E = c[h];
                        this.set(E[0], E[1])
                    }
                }

                function gP() {
                    this.__data__ = [], this.size = 0
                }

                function _P(c) {
                    var h = this.__data__,
                        m = xd(h, c);
                    if (m < 0) return !1;
                    var E = h.length - 1;
                    return m == E ? h.pop() : wd.call(h, m, 1), --this.size, !0
                }

                function yP(c) {
                    var h = this.__data__,
                        m = xd(h, c);
                    return m < 0 ? n : h[m][1]
                }

                function vP(c) {
                    return xd(this.__data__, c) > -1
                }

                function bP(c, h) {
                    var m = this.__data__,
                        E = xd(m, c);
                    return E < 0 ? (++this.size, m.push([c, h])) : m[E][1] = h, this
                }
                qi.prototype.clear = gP, qi.prototype.delete = _P, qi.prototype.get = yP, qi.prototype.has = vP, qi.prototype.set = bP;

                function Gi(c) {
                    var h = -1,
                        m = c == null ? 0 : c.length;
                    for (this.clear(); ++h < m;) {
                        var E = c[h];
                        this.set(E[0], E[1])
                    }
                }

                function EP() {
                    this.size = 0, this.__data__ = {
                        hash: new Ua,
                        map: new(ju || qi),
                        string: new Ua
                    }
                }

                function TP(c) {
                    var h = Vd(this, c).delete(c);
                    return this.size -= h ? 1 : 0, h
                }

                function SP(c) {
                    return Vd(this, c).get(c)
                }

                function wP(c) {
                    return Vd(this, c).has(c)
                }

                function AP(c, h) {
                    var m = Vd(this, c),
                        E = m.size;
                    return m.set(c, h), this.size += m.size == E ? 0 : 1, this
                }
                Gi.prototype.clear = EP, Gi.prototype.delete = TP, Gi.prototype.get = SP, Gi.prototype.has = wP, Gi.prototype.set = AP;

                function Ba(c) {
                    var h = -1,
                        m = c == null ? 0 : c.length;
                    for (this.__data__ = new Gi; ++h < m;) this.add(c[h])
                }

                function OP(c) {
                    return this.__data__.set(c, l), this
                }

                function CP(c) {
                    return this.__data__.has(c)
                }
                Ba.prototype.add = Ba.prototype.push = OP, Ba.prototype.has = CP;

                function $s(c) {
                    var h = this.__data__ = new qi(c);
                    this.size = h.size
                }

                function kP() {
                    this.__data__ = new qi, this.size = 0
                }

                function IP(c) {
                    var h = this.__data__,
                        m = h.delete(c);
                    return this.size = h.size, m
                }

                function NP(c) {
                    return this.__data__.get(c)
                }

                function xP(c) {
                    return this.__data__.has(c)
                }

                function PP(c, h) {
                    var m = this.__data__;
                    if (m instanceof qi) {
                        var E = m.__data__;
                        if (!ju || E.length < s - 1) return E.push([c, h]), this.size = ++m.size, this;
                        m = this.__data__ = new Gi(E)
                    }
                    return m.set(c, h), this.size = m.size, this
                }
                $s.prototype.clear = kP, $s.prototype.delete = IP, $s.prototype.get = NP, $s.prototype.has = xP, $s.prototype.set = PP;

                function e4(c, h) {
                    var m = ft(c),
                        E = !m && Wa(c),
                        C = !m && !E && Po(c),
                        F = !m && !E && !C && tl(c),
                        z = m || E || C || F,
                        J = z ? t_(c.length, Gx) : [],
                        ce = J.length;
                    for (var we in c)(h || Ut.call(c, we)) && !(z && (we == "length" || C && (we == "offset" || we == "parent") || F && (we == "buffer" || we == "byteLength" || we == "byteOffset") || Hi(we, ce))) && J.push(we);
                    return J
                }

                function t4(c) {
                    var h = c.length;
                    return h ? c[y_(0, h - 1)] : n
                }

                function RP(c, h) {
                    return jd(Or(c), qa(h, 0, c.length))
                }

                function MP(c) {
                    return jd(Or(c))
                }

                function c_(c, h, m) {
                    (m !== n && !Ls(c[h], m) || m === n && !(h in c)) && Vi(c, h, m)
                }

                function zu(c, h, m) {
                    var E = c[h];
                    (!(Ut.call(c, h) && Ls(E, m)) || m === n && !(h in c)) && Vi(c, h, m)
                }

                function xd(c, h) {
                    for (var m = c.length; m--;)
                        if (Ls(c[m][0], h)) return m;
                    return -1
                }

                function DP(c, h, m, E) {
                    return ko(c, function(C, F, z) {
                        h(E, C, m(C), z)
                    }), E
                }

                function n4(c, h) {
                    return c && li(h, qn(h), c)
                }

                function $P(c, h) {
                    return c && li(h, kr(h), c)
                }

                function Vi(c, h, m) {
                    h == "__proto__" && Ad ? Ad(c, h, {
                        configurable: !0,
                        enumerable: !0,
                        value: m,
                        writable: !0
                    }) : c[h] = m
                }

                function l_(c, h) {
                    for (var m = -1, E = h.length, C = pe(E), F = c == null; ++m < E;) C[m] = F ? n : V_(c, h[m]);
                    return C
                }

                function qa(c, h, m) {
                    return c === c && (m !== n && (c = c <= m ? c : m), h !== n && (c = c >= h ? c : h)), c
                }

                function gs(c, h, m, E, C, F) {
                    var z, J = h & d,
                        ce = h & p,
                        we = h & _;
                    if (m && (z = C ? m(c, E, C, F) : m(c)), z !== n) return z;
                    if (!dn(c)) return c;
                    var Ae = ft(c);
                    if (Ae) {
                        if (z = wR(c), !J) return Or(c, z)
                    } else {
                        var Ie = or(c),
                            Re = Ie == I || Ie == T;
                        if (Po(c)) return O4(c, J);
                        if (Ie == te || Ie == je || Re && !C) {
                            if (z = ce || Re ? {} : W4(c), !J) return ce ? dR(c, $P(z, c)) : fR(c, n4(z, c))
                        } else {
                            if (!Zt[Ie]) return C ? c : {};
                            z = AR(c, Ie, J)
                        }
                    }
                    F || (F = new $s);
                    var We = F.get(c);
                    if (We) return We;
                    F.set(c, z), bE(c) ? c.forEach(function(tt) {
                        z.add(gs(tt, h, m, tt, c, F))
                    }) : yE(c) && c.forEach(function(tt, Tt) {
                        z.set(Tt, gs(tt, h, m, Tt, c, F))
                    });
                    var et = we ? ce ? I_ : k_ : ce ? kr : qn,
                        _t = Ae ? n : et(c);
                    return ds(_t || c, function(tt, Tt) {
                        _t && (Tt = tt, tt = c[Tt]), zu(z, Tt, gs(tt, h, m, Tt, c, F))
                    }), z
                }

                function LP(c) {
                    var h = qn(c);
                    return function(m) {
                        return r4(m, c, h)
                    }
                }

                function r4(c, h, m) {
                    var E = m.length;
                    if (c == null) return !E;
                    for (c = Wt(c); E--;) {
                        var C = m[E],
                            F = h[C],
                            z = c[C];
                        if (z === n && !(C in c) || !F(z)) return !1
                    }
                    return !0
                }

                function s4(c, h, m) {
                    if (typeof c != "function") throw new ps(o);
                    return th(function() {
                        c.apply(n, m)
                    }, h)
                }

                function Ku(c, h, m, E) {
                    var C = -1,
                        F = pd,
                        z = !0,
                        J = c.length,
                        ce = [],
                        we = h.length;
                    if (!J) return ce;
                    m && (h = cn(h, zr(m))), E ? (F = Kg, z = !1) : h.length >= s && (F = Gu, z = !1, h = new Ba(h));
                    e: for (; ++C < J;) {
                        var Ae = c[C],
                            Ie = m == null ? Ae : m(Ae);
                        if (Ae = E || Ae !== 0 ? Ae : 0, z && Ie === Ie) {
                            for (var Re = we; Re--;)
                                if (h[Re] === Ie) continue e;
                            ce.push(Ae)
                        } else F(h, Ie, E) || ce.push(Ae)
                    }
                    return ce
                }
                var ko = x4(ci),
                    i4 = x4(h_, !0);

                function FP(c, h) {
                    var m = !0;
                    return ko(c, function(E, C, F) {
                        return m = !!h(E, C, F), m
                    }), m
                }

                function Pd(c, h, m) {
                    for (var E = -1, C = c.length; ++E < C;) {
                        var F = c[E],
                            z = h(F);
                        if (z != null && (J === n ? z === z && !Zr(z) : m(z, J))) var J = z,
                            ce = F
                    }
                    return ce
                }

                function UP(c, h, m, E) {
                    var C = c.length;
                    for (m = mt(m), m < 0 && (m = -m > C ? 0 : C + m), E = E === n || E > C ? C : mt(E), E < 0 && (E += C), E = m > E ? 0 : TE(E); m < E;) c[m++] = h;
                    return c
                }

                function o4(c, h) {
                    var m = [];
                    return ko(c, function(E, C, F) {
                        h(E, C, F) && m.push(E)
                    }), m
                }

                function zn(c, h, m, E, C) {
                    var F = -1,
                        z = c.length;
                    for (m || (m = CR), C || (C = []); ++F < z;) {
                        var J = c[F];
                        h > 0 && m(J) ? h > 1 ? zn(J, h - 1, m, E, C) : Ao(C, J) : E || (C[C.length] = J)
                    }
                    return C
                }
                var u_ = P4(),
                    a4 = P4(!0);

                function ci(c, h) {
                    return c && u_(c, h, qn)
                }

                function h_(c, h) {
                    return c && a4(c, h, qn)
                }

                function Rd(c, h) {
                    return wo(h, function(m) {
                        return Yi(c[m])
                    })
                }

                function Ga(c, h) {
                    h = No(h, c);
                    for (var m = 0, E = h.length; c != null && m < E;) c = c[ui(h[m++])];
                    return m && m == E ? c : n
                }

                function c4(c, h, m) {
                    var E = h(c);
                    return ft(c) ? E : Ao(E, m(c))
                }

                function gr(c) {
                    return c == null ? c === n ? Me : G : Fa && Fa in Wt(c) ? ER(c) : MR(c)
                }

                function f_(c, h) {
                    return c > h
                }

                function BP(c, h) {
                    return c != null && Ut.call(c, h)
                }

                function qP(c, h) {
                    return c != null && h in Wt(c)
                }

                function GP(c, h, m) {
                    return c >= ir(h, m) && c < $n(h, m)
                }

                function d_(c, h, m) {
                    for (var E = m ? Kg : pd, C = c[0].length, F = c.length, z = F, J = pe(F), ce = 1 / 0, we = []; z--;) {
                        var Ae = c[z];
                        z && h && (Ae = cn(Ae, zr(h))), ce = ir(Ae.length, ce), J[z] = !m && (h || C >= 120 && Ae.length >= 120) ? new Ba(z && Ae) : n
                    }
                    Ae = c[0];
                    var Ie = -1,
                        Re = J[0];
                    e: for (; ++Ie < C && we.length < ce;) {
                        var We = Ae[Ie],
                            et = h ? h(We) : We;
                        if (We = m || We !== 0 ? We : 0, !(Re ? Gu(Re, et) : E(we, et, m))) {
                            for (z = F; --z;) {
                                var _t = J[z];
                                if (!(_t ? Gu(_t, et) : E(c[z], et, m))) continue e
                            }
                            Re && Re.push(et), we.push(We)
                        }
                    }
                    return we
                }

                function VP(c, h, m, E) {
                    return ci(c, function(C, F, z) {
                        h(E, m(C), F, z)
                    }), E
                }

                function Zu(c, h, m) {
                    h = No(h, c), c = K4(c, h);
                    var E = c == null ? c : c[ui(ys(h))];
                    return E == null ? n : Yr(E, c, m)
                }

                function l4(c) {
                    return vn(c) && gr(c) == je
                }

                function jP(c) {
                    return vn(c) && gr(c) == vt
                }

                function WP(c) {
                    return vn(c) && gr(c) == M
                }

                function Xu(c, h, m, E, C) {
                    return c === h ? !0 : c == null || h == null || !vn(c) && !vn(h) ? c !== c && h !== h : HP(c, h, m, E, Xu, C)
                }

                function HP(c, h, m, E, C, F) {
                    var z = ft(c),
                        J = ft(h),
                        ce = z ? Ze : or(c),
                        we = J ? Ze : or(h);
                    ce = ce == je ? te : ce, we = we == je ? te : we;
                    var Ae = ce == te,
                        Ie = we == te,
                        Re = ce == we;
                    if (Re && Po(c)) {
                        if (!Po(h)) return !1;
                        z = !0, Ae = !1
                    }
                    if (Re && !Ae) return F || (F = new $s), z || tl(c) ? G4(c, h, m, E, C, F) : vR(c, h, ce, m, E, C, F);
                    if (!(m & v)) {
                        var We = Ae && Ut.call(c, "__wrapped__"),
                            et = Ie && Ut.call(h, "__wrapped__");
                        if (We || et) {
                            var _t = We ? c.value() : c,
                                tt = et ? h.value() : h;
                            return F || (F = new $s), C(_t, tt, m, E, F)
                        }
                    }
                    return Re ? (F || (F = new $s), bR(c, h, m, E, C, F)) : !1
                }

                function YP(c) {
                    return vn(c) && or(c) == S
                }

                function p_(c, h, m, E) {
                    var C = m.length,
                        F = C,
                        z = !E;
                    if (c == null) return !F;
                    for (c = Wt(c); C--;) {
                        var J = m[C];
                        if (z && J[2] ? J[1] !== c[J[0]] : !(J[0] in c)) return !1
                    }
                    for (; ++C < F;) {
                        J = m[C];
                        var ce = J[0],
                            we = c[ce],
                            Ae = J[1];
                        if (z && J[2]) {
                            if (we === n && !(ce in c)) return !1
                        } else {
                            var Ie = new $s;
                            if (E) var Re = E(we, Ae, ce, c, h, Ie);
                            if (!(Re === n ? Xu(Ae, we, v | y, E, Ie) : Re)) return !1
                        }
                    }
                    return !0
                }

                function u4(c) {
                    if (!dn(c) || IR(c)) return !1;
                    var h = Yi(c) ? Yx : LN;
                    return h.test(ja(c))
                }

                function zP(c) {
                    return vn(c) && gr(c) == ve
                }

                function KP(c) {
                    return vn(c) && or(c) == de
                }

                function ZP(c) {
                    return vn(c) && Zd(c.length) && !!tn[gr(c)]
                }

                function h4(c) {
                    return typeof c == "function" ? c : c == null ? Ir : typeof c == "object" ? ft(c) ? p4(c[0], c[1]) : d4(c) : RE(c)
                }

                function m_(c) {
                    if (!eh(c)) return Jx(c);
                    var h = [];
                    for (var m in Wt(c)) Ut.call(c, m) && m != "constructor" && h.push(m);
                    return h
                }

                function XP(c) {
                    if (!dn(c)) return RR(c);
                    var h = eh(c),
                        m = [];
                    for (var E in c) E == "constructor" && (h || !Ut.call(c, E)) || m.push(E);
                    return m
                }

                function g_(c, h) {
                    return c < h
                }

                function f4(c, h) {
                    var m = -1,
                        E = Cr(c) ? pe(c.length) : [];
                    return ko(c, function(C, F, z) {
                        E[++m] = h(C, F, z)
                    }), E
                }

                function d4(c) {
                    var h = x_(c);
                    return h.length == 1 && h[0][2] ? Y4(h[0][0], h[0][1]) : function(m) {
                        return m === c || p_(m, c, h)
                    }
                }

                function p4(c, h) {
                    return R_(c) && H4(h) ? Y4(ui(c), h) : function(m) {
                        var E = V_(m, c);
                        return E === n && E === h ? j_(m, c) : Xu(h, E, v | y)
                    }
                }

                function Md(c, h, m, E, C) {
                    c !== h && u_(h, function(F, z) {
                        if (C || (C = new $s), dn(F)) QP(c, h, z, m, Md, E, C);
                        else {
                            var J = E ? E(D_(c, z), F, z + "", c, h, C) : n;
                            J === n && (J = F), c_(c, z, J)
                        }
                    }, kr)
                }

                function QP(c, h, m, E, C, F, z) {
                    var J = D_(c, m),
                        ce = D_(h, m),
                        we = z.get(ce);
                    if (we) {
                        c_(c, m, we);
                        return
                    }
                    var Ae = F ? F(J, ce, m + "", c, h, z) : n,
                        Ie = Ae === n;
                    if (Ie) {
                        var Re = ft(ce),
                            We = !Re && Po(ce),
                            et = !Re && !We && tl(ce);
                        Ae = ce, Re || We || et ? ft(J) ? Ae = J : Sn(J) ? Ae = Or(J) : We ? (Ie = !1, Ae = O4(ce, !0)) : et ? (Ie = !1, Ae = C4(ce, !0)) : Ae = [] : nh(ce) || Wa(ce) ? (Ae = J, Wa(J) ? Ae = SE(J) : (!dn(J) || Yi(J)) && (Ae = W4(ce))) : Ie = !1
                    }
                    Ie && (z.set(ce, Ae), C(Ae, ce, E, F, z), z.delete(ce)), c_(c, m, Ae)
                }

                function m4(c, h) {
                    var m = c.length;
                    if (m) return h += h < 0 ? m : 0, Hi(h, m) ? c[h] : n
                }

                function g4(c, h, m) {
                    h.length ? h = cn(h, function(F) {
                        return ft(F) ? function(z) {
                            return Ga(z, F.length === 1 ? F[0] : F)
                        } : F
                    }) : h = [Ir];
                    var E = -1;
                    h = cn(h, zr(Xe()));
                    var C = f4(c, function(F, z, J) {
                        var ce = cn(h, function(we) {
                            return we(F)
                        });
                        return {
                            criteria: ce,
                            index: ++E,
                            value: F
                        }
                    });
                    return Ax(C, function(F, z) {
                        return hR(F, z, m)
                    })
                }

                function JP(c, h) {
                    return _4(c, h, function(m, E) {
                        return j_(c, E)
                    })
                }

                function _4(c, h, m) {
                    for (var E = -1, C = h.length, F = {}; ++E < C;) {
                        var z = h[E],
                            J = Ga(c, z);
                        m(J, z) && Qu(F, No(z, c), J)
                    }
                    return F
                }

                function eR(c) {
                    return function(h) {
                        return Ga(h, c)
                    }
                }

                function __(c, h, m, E) {
                    var C = E ? wx : jc,
                        F = -1,
                        z = h.length,
                        J = c;
                    for (c === h && (h = Or(h)), m && (J = cn(c, zr(m))); ++F < z;)
                        for (var ce = 0, we = h[F], Ae = m ? m(we) : we;
                            (ce = C(J, Ae, ce, E)) > -1;) J !== c && wd.call(J, ce, 1), wd.call(c, ce, 1);
                    return c
                }

                function y4(c, h) {
                    for (var m = c ? h.length : 0, E = m - 1; m--;) {
                        var C = h[m];
                        if (m == E || C !== F) {
                            var F = C;
                            Hi(C) ? wd.call(c, C, 1) : E_(c, C)
                        }
                    }
                    return c
                }

                function y_(c, h) {
                    return c + Cd(Q5() * (h - c + 1))
                }

                function tR(c, h, m, E) {
                    for (var C = -1, F = $n(Od((h - c) / (m || 1)), 0), z = pe(F); F--;) z[E ? F : ++C] = c, c += m;
                    return z
                }

                function v_(c, h) {
                    var m = "";
                    if (!c || h < 1 || h > _e) return m;
                    do h % 2 && (m += c), h = Cd(h / 2), h && (c += c); while (h);
                    return m
                }

                function bt(c, h) {
                    return $_(z4(c, h, Ir), c + "")
                }

                function nR(c) {
                    return t4(nl(c))
                }

                function rR(c, h) {
                    var m = nl(c);
                    return jd(m, qa(h, 0, m.length))
                }

                function Qu(c, h, m, E) {
                    if (!dn(c)) return c;
                    h = No(h, c);
                    for (var C = -1, F = h.length, z = F - 1, J = c; J != null && ++C < F;) {
                        var ce = ui(h[C]),
                            we = m;
                        if (ce === "__proto__" || ce === "constructor" || ce === "prototype") return c;
                        if (C != z) {
                            var Ae = J[ce];
                            we = E ? E(Ae, ce, J) : n, we === n && (we = dn(Ae) ? Ae : Hi(h[C + 1]) ? [] : {})
                        }
                        zu(J, ce, we), J = J[ce]
                    }
                    return c
                }
                var v4 = kd ? function(c, h) {
                        return kd.set(c, h), c
                    } : Ir,
                    sR = Ad ? function(c, h) {
                        return Ad(c, "toString", {
                            configurable: !0,
                            enumerable: !1,
                            value: H_(h),
                            writable: !0
                        })
                    } : Ir;

                function iR(c) {
                    return jd(nl(c))
                }

                function _s(c, h, m) {
                    var E = -1,
                        C = c.length;
                    h < 0 && (h = -h > C ? 0 : C + h), m = m > C ? C : m, m < 0 && (m += C), C = h > m ? 0 : m - h >>> 0, h >>>= 0;
                    for (var F = pe(C); ++E < C;) F[E] = c[E + h];
                    return F
                }

                function oR(c, h) {
                    var m;
                    return ko(c, function(E, C, F) {
                        return m = h(E, C, F), !m
                    }), !!m
                }

                function Dd(c, h, m) {
                    var E = 0,
                        C = c == null ? E : c.length;
                    if (typeof h == "number" && h === h && C <= Ue) {
                        for (; E < C;) {
                            var F = E + C >>> 1,
                                z = c[F];
                            z !== null && !Zr(z) && (m ? z <= h : z < h) ? E = F + 1 : C = F
                        }
                        return C
                    }
                    return b_(c, h, Ir, m)
                }

                function b_(c, h, m, E) {
                    var C = 0,
                        F = c == null ? 0 : c.length;
                    if (F === 0) return 0;
                    h = m(h);
                    for (var z = h !== h, J = h === null, ce = Zr(h), we = h === n; C < F;) {
                        var Ae = Cd((C + F) / 2),
                            Ie = m(c[Ae]),
                            Re = Ie !== n,
                            We = Ie === null,
                            et = Ie === Ie,
                            _t = Zr(Ie);
                        if (z) var tt = E || et;
                        else we ? tt = et && (E || Re) : J ? tt = et && Re && (E || !We) : ce ? tt = et && Re && !We && (E || !_t) : We || _t ? tt = !1 : tt = E ? Ie <= h : Ie < h;
                        tt ? C = Ae + 1 : F = Ae
                    }
                    return ir(F, De)
                }

                function b4(c, h) {
                    for (var m = -1, E = c.length, C = 0, F = []; ++m < E;) {
                        var z = c[m],
                            J = h ? h(z) : z;
                        if (!m || !Ls(J, ce)) {
                            var ce = J;
                            F[C++] = z === 0 ? 0 : z
                        }
                    }
                    return F
                }

                function E4(c) {
                    return typeof c == "number" ? c : Zr(c) ? Ee : +c
                }

                function Kr(c) {
                    if (typeof c == "string") return c;
                    if (ft(c)) return cn(c, Kr) + "";
                    if (Zr(c)) return J5 ? J5.call(c) : "";
                    var h = c + "";
                    return h == "0" && 1 / c == -ue ? "-0" : h
                }

                function Io(c, h, m) {
                    var E = -1,
                        C = pd,
                        F = c.length,
                        z = !0,
                        J = [],
                        ce = J;
                    if (m) z = !1, C = Kg;
                    else if (F >= s) {
                        var we = h ? null : _R(c);
                        if (we) return gd(we);
                        z = !1, C = Gu, ce = new Ba
                    } else ce = h ? [] : J;
                    e: for (; ++E < F;) {
                        var Ae = c[E],
                            Ie = h ? h(Ae) : Ae;
                        if (Ae = m || Ae !== 0 ? Ae : 0, z && Ie === Ie) {
                            for (var Re = ce.length; Re--;)
                                if (ce[Re] === Ie) continue e;
                            h && ce.push(Ie), J.push(Ae)
                        } else C(ce, Ie, m) || (ce !== J && ce.push(Ie), J.push(Ae))
                    }
                    return J
                }

                function E_(c, h) {
                    return h = No(h, c), c = K4(c, h), c == null || delete c[ui(ys(h))]
                }

                function T4(c, h, m, E) {
                    return Qu(c, h, m(Ga(c, h)), E)
                }

                function $d(c, h, m, E) {
                    for (var C = c.length, F = E ? C : -1;
                        (E ? F-- : ++F < C) && h(c[F], F, c););
                    return m ? _s(c, E ? 0 : F, E ? F + 1 : C) : _s(c, E ? F + 1 : 0, E ? C : F)
                }

                function S4(c, h) {
                    var m = c;
                    return m instanceof St && (m = m.value()), Zg(h, function(E, C) {
                        return C.func.apply(C.thisArg, Ao([E], C.args))
                    }, m)
                }

                function T_(c, h, m) {
                    var E = c.length;
                    if (E < 2) return E ? Io(c[0]) : [];
                    for (var C = -1, F = pe(E); ++C < E;)
                        for (var z = c[C], J = -1; ++J < E;) J != C && (F[C] = Ku(F[C] || z, c[J], h, m));
                    return Io(zn(F, 1), h, m)
                }

                function w4(c, h, m) {
                    for (var E = -1, C = c.length, F = h.length, z = {}; ++E < C;) {
                        var J = E < F ? h[E] : n;
                        m(z, c[E], J)
                    }
                    return z
                }

                function S_(c) {
                    return Sn(c) ? c : []
                }

                function w_(c) {
                    return typeof c == "function" ? c : Ir
                }

                function No(c, h) {
                    return ft(c) ? c : R_(c, h) ? [c] : J4(Lt(c))
                }
                var aR = bt;

                function xo(c, h, m) {
                    var E = c.length;
                    return m = m === n ? E : m, !h && m >= E ? c : _s(c, h, m)
                }
                var A4 = zx || function(c) {
                    return Yn.clearTimeout(c)
                };

                function O4(c, h) {
                    if (h) return c.slice();
                    var m = c.length,
                        E = Y5 ? Y5(m) : new c.constructor(m);
                    return c.copy(E), E
                }

                function A_(c) {
                    var h = new c.constructor(c.byteLength);
                    return new Td(h).set(new Td(c)), h
                }

                function cR(c, h) {
                    var m = h ? A_(c.buffer) : c.buffer;
                    return new c.constructor(m, c.byteOffset, c.byteLength)
                }

                function lR(c) {
                    var h = new c.constructor(c.source, l5.exec(c));
                    return h.lastIndex = c.lastIndex, h
                }

                function uR(c) {
                    return Yu ? Wt(Yu.call(c)) : {}
                }

                function C4(c, h) {
                    var m = h ? A_(c.buffer) : c.buffer;
                    return new c.constructor(m, c.byteOffset, c.length)
                }

                function k4(c, h) {
                    if (c !== h) {
                        var m = c !== n,
                            E = c === null,
                            C = c === c,
                            F = Zr(c),
                            z = h !== n,
                            J = h === null,
                            ce = h === h,
                            we = Zr(h);
                        if (!J && !we && !F && c > h || F && z && ce && !J && !we || E && z && ce || !m && ce || !C) return 1;
                        if (!E && !F && !we && c < h || we && m && C && !E && !F || J && m && C || !z && C || !ce) return -1
                    }
                    return 0
                }

                function hR(c, h, m) {
                    for (var E = -1, C = c.criteria, F = h.criteria, z = C.length, J = m.length; ++E < z;) {
                        var ce = k4(C[E], F[E]);
                        if (ce) {
                            if (E >= J) return ce;
                            var we = m[E];
                            return ce * (we == "desc" ? -1 : 1)
                        }
                    }
                    return c.index - h.index
                }

                function I4(c, h, m, E) {
                    for (var C = -1, F = c.length, z = m.length, J = -1, ce = h.length, we = $n(F - z, 0), Ae = pe(ce + we), Ie = !E; ++J < ce;) Ae[J] = h[J];
                    for (; ++C < z;)(Ie || C < F) && (Ae[m[C]] = c[C]);
                    for (; we--;) Ae[J++] = c[C++];
                    return Ae
                }

                function N4(c, h, m, E) {
                    for (var C = -1, F = c.length, z = -1, J = m.length, ce = -1, we = h.length, Ae = $n(F - J, 0), Ie = pe(Ae + we), Re = !E; ++C < Ae;) Ie[C] = c[C];
                    for (var We = C; ++ce < we;) Ie[We + ce] = h[ce];
                    for (; ++z < J;)(Re || C < F) && (Ie[We + m[z]] = c[C++]);
                    return Ie
                }

                function Or(c, h) {
                    var m = -1,
                        E = c.length;
                    for (h || (h = pe(E)); ++m < E;) h[m] = c[m];
                    return h
                }

                function li(c, h, m, E) {
                    var C = !m;
                    m || (m = {});
                    for (var F = -1, z = h.length; ++F < z;) {
                        var J = h[F],
                            ce = E ? E(m[J], c[J], J, m, c) : n;
                        ce === n && (ce = c[J]), C ? Vi(m, J, ce) : zu(m, J, ce)
                    }
                    return m
                }

                function fR(c, h) {
                    return li(c, P_(c), h)
                }

                function dR(c, h) {
                    return li(c, V4(c), h)
                }

                function Ld(c, h) {
                    return function(m, E) {
                        var C = ft(m) ? yx : DP,
                            F = h ? h() : {};
                        return C(m, c, Xe(E, 2), F)
                    }
                }

                function Qc(c) {
                    return bt(function(h, m) {
                        var E = -1,
                            C = m.length,
                            F = C > 1 ? m[C - 1] : n,
                            z = C > 2 ? m[2] : n;
                        for (F = c.length > 3 && typeof F == "function" ? (C--, F) : n, z && _r(m[0], m[1], z) && (F = C < 3 ? n : F, C = 1), h = Wt(h); ++E < C;) {
                            var J = m[E];
                            J && c(h, J, E, F)
                        }
                        return h
                    })
                }

                function x4(c, h) {
                    return function(m, E) {
                        if (m == null) return m;
                        if (!Cr(m)) return c(m, E);
                        for (var C = m.length, F = h ? C : -1, z = Wt(m);
                            (h ? F-- : ++F < C) && E(z[F], F, z) !== !1;);
                        return m
                    }
                }

                function P4(c) {
                    return function(h, m, E) {
                        for (var C = -1, F = Wt(h), z = E(h), J = z.length; J--;) {
                            var ce = z[c ? J : ++C];
                            if (m(F[ce], ce, F) === !1) break
                        }
                        return h
                    }
                }

                function pR(c, h, m) {
                    var E = h & g,
                        C = Ju(c);

                    function F() {
                        var z = this && this !== Yn && this instanceof F ? C : c;
                        return z.apply(E ? m : this, arguments)
                    }
                    return F
                }

                function R4(c) {
                    return function(h) {
                        h = Lt(h);
                        var m = Wc(h) ? Ds(h) : n,
                            E = m ? m[0] : h.charAt(0),
                            C = m ? xo(m, 1).join("") : h.slice(1);
                        return E[c]() + C
                    }
                }

                function Jc(c) {
                    return function(h) {
                        return Zg(xE(NE(h).replace(sx, "")), c, "")
                    }
                }

                function Ju(c) {
                    return function() {
                        var h = arguments;
                        switch (h.length) {
                            case 0:
                                return new c;
                            case 1:
                                return new c(h[0]);
                            case 2:
                                return new c(h[0], h[1]);
                            case 3:
                                return new c(h[0], h[1], h[2]);
                            case 4:
                                return new c(h[0], h[1], h[2], h[3]);
                            case 5:
                                return new c(h[0], h[1], h[2], h[3], h[4]);
                            case 6:
                                return new c(h[0], h[1], h[2], h[3], h[4], h[5]);
                            case 7:
                                return new c(h[0], h[1], h[2], h[3], h[4], h[5], h[6])
                        }
                        var m = Xc(c.prototype),
                            E = c.apply(m, h);
                        return dn(E) ? E : m
                    }
                }

                function mR(c, h, m) {
                    var E = Ju(c);

                    function C() {
                        for (var F = arguments.length, z = pe(F), J = F, ce = el(C); J--;) z[J] = arguments[J];
                        var we = F < 3 && z[0] !== ce && z[F - 1] !== ce ? [] : Oo(z, ce);
                        if (F -= we.length, F < m) return F4(c, h, Fd, C.placeholder, n, z, we, n, n, m - F);
                        var Ae = this && this !== Yn && this instanceof C ? E : c;
                        return Yr(Ae, this, z)
                    }
                    return C
                }

                function M4(c) {
                    return function(h, m, E) {
                        var C = Wt(h);
                        if (!Cr(h)) {
                            var F = Xe(m, 3);
                            h = qn(h), m = function(J) {
                                return F(C[J], J, C)
                            }
                        }
                        var z = c(h, m, E);
                        return z > -1 ? C[F ? h[z] : z] : n
                    }
                }

                function D4(c) {
                    return Wi(function(h) {
                        var m = h.length,
                            E = m,
                            C = ms.prototype.thru;
                        for (c && h.reverse(); E--;) {
                            var F = h[E];
                            if (typeof F != "function") throw new ps(o);
                            if (C && !z && Gd(F) == "wrapper") var z = new ms([], !0)
                        }
                        for (E = z ? E : m; ++E < m;) {
                            F = h[E];
                            var J = Gd(F),
                                ce = J == "wrapper" ? N_(F) : n;
                            ce && M_(ce[0]) && ce[1] == (D | N | A | L) && !ce[4].length && ce[9] == 1 ? z = z[Gd(ce[0])].apply(z, ce[3]) : z = F.length == 1 && M_(F) ? z[J]() : z.thru(F)
                        }
                        return function() {
                            var we = arguments,
                                Ae = we[0];
                            if (z && we.length == 1 && ft(Ae)) return z.plant(Ae).value();
                            for (var Ie = 0, Re = m ? h[Ie].apply(this, we) : Ae; ++Ie < m;) Re = h[Ie].call(this, Re);
                            return Re
                        }
                    })
                }

                function Fd(c, h, m, E, C, F, z, J, ce, we) {
                    var Ae = h & D,
                        Ie = h & g,
                        Re = h & b,
                        We = h & (N | k),
                        et = h & q,
                        _t = Re ? n : Ju(c);

                    function tt() {
                        for (var Tt = arguments.length, Ct = pe(Tt), Xr = Tt; Xr--;) Ct[Xr] = arguments[Xr];
                        if (We) var yr = el(tt),
                            Qr = Cx(Ct, yr);
                        if (E && (Ct = I4(Ct, E, C, We)), F && (Ct = N4(Ct, F, z, We)), Tt -= Qr, We && Tt < we) {
                            var wn = Oo(Ct, yr);
                            return F4(c, h, Fd, tt.placeholder, m, Ct, wn, J, ce, we - Tt)
                        }
                        var Fs = Ie ? m : this,
                            Ki = Re ? Fs[c] : c;
                        return Tt = Ct.length, J ? Ct = DR(Ct, J) : et && Tt > 1 && Ct.reverse(), Ae && ce < Tt && (Ct.length = ce), this && this !== Yn && this instanceof tt && (Ki = _t || Ju(Ki)), Ki.apply(Fs, Ct)
                    }
                    return tt
                }

                function $4(c, h) {
                    return function(m, E) {
                        return VP(m, c, h(E), {})
                    }
                }

                function Ud(c, h) {
                    return function(m, E) {
                        var C;
                        if (m === n && E === n) return h;
                        if (m !== n && (C = m), E !== n) {
                            if (C === n) return E;
                            typeof m == "string" || typeof E == "string" ? (m = Kr(m), E = Kr(E)) : (m = E4(m), E = E4(E)), C = c(m, E)
                        }
                        return C
                    }
                }

                function O_(c) {
                    return Wi(function(h) {
                        return h = cn(h, zr(Xe())), bt(function(m) {
                            var E = this;
                            return c(h, function(C) {
                                return Yr(C, E, m)
                            })
                        })
                    })
                }

                function Bd(c, h) {
                    h = h === n ? " " : Kr(h);
                    var m = h.length;
                    if (m < 2) return m ? v_(h, c) : h;
                    var E = v_(h, Od(c / Hc(h)));
                    return Wc(h) ? xo(Ds(E), 0, c).join("") : E.slice(0, c)
                }

                function gR(c, h, m, E) {
                    var C = h & g,
                        F = Ju(c);

                    function z() {
                        for (var J = -1, ce = arguments.length, we = -1, Ae = E.length, Ie = pe(Ae + ce), Re = this && this !== Yn && this instanceof z ? F : c; ++we < Ae;) Ie[we] = E[we];
                        for (; ce--;) Ie[we++] = arguments[++J];
                        return Yr(Re, C ? m : this, Ie)
                    }
                    return z
                }

                function L4(c) {
                    return function(h, m, E) {
                        return E && typeof E != "number" && _r(h, m, E) && (m = E = n), h = zi(h), m === n ? (m = h, h = 0) : m = zi(m), E = E === n ? h < m ? 1 : -1 : zi(E), tR(h, m, E, c)
                    }
                }

                function qd(c) {
                    return function(h, m) {
                        return typeof h == "string" && typeof m == "string" || (h = vs(h), m = vs(m)), c(h, m)
                    }
                }

                function F4(c, h, m, E, C, F, z, J, ce, we) {
                    var Ae = h & N,
                        Ie = Ae ? z : n,
                        Re = Ae ? n : z,
                        We = Ae ? F : n,
                        et = Ae ? n : F;
                    h |= Ae ? A : x, h &= ~(Ae ? x : A), h & O || (h &= ~(g | b));
                    var _t = [c, h, C, We, Ie, et, Re, J, ce, we],
                        tt = m.apply(n, _t);
                    return M_(c) && Z4(tt, _t), tt.placeholder = E, X4(tt, c, h)
                }

                function C_(c) {
                    var h = Dn[c];
                    return function(m, E) {
                        if (m = vs(m), E = E == null ? 0 : ir(mt(E), 292), E && X5(m)) {
                            var C = (Lt(m) + "e").split("e"),
                                F = h(C[0] + "e" + (+C[1] + E));
                            return C = (Lt(F) + "e").split("e"), +(C[0] + "e" + (+C[1] - E))
                        }
                        return h(m)
                    }
                }
                var _R = Kc && 1 / gd(new Kc([, -0]))[1] == ue ? function(c) {
                    return new Kc(c)
                } : K_;

                function U4(c) {
                    return function(h) {
                        var m = or(h);
                        return m == S ? r_(h) : m == de ? Mx(h) : Ox(h, c(h))
                    }
                }

                function ji(c, h, m, E, C, F, z, J) {
                    var ce = h & b;
                    if (!ce && typeof c != "function") throw new ps(o);
                    var we = E ? E.length : 0;
                    if (we || (h &= ~(A | x), E = C = n), z = z === n ? z : $n(mt(z), 0), J = J === n ? J : mt(J), we -= C ? C.length : 0, h & x) {
                        var Ae = E,
                            Ie = C;
                        E = C = n
                    }
                    var Re = ce ? n : N_(c),
                        We = [c, h, m, E, C, Ae, Ie, F, z, J];
                    if (Re && PR(We, Re), c = We[0], h = We[1], m = We[2], E = We[3], C = We[4], J = We[9] = We[9] === n ? ce ? 0 : c.length : $n(We[9] - we, 0), !J && h & (N | k) && (h &= ~(N | k)), !h || h == g) var et = pR(c, h, m);
                    else h == N || h == k ? et = mR(c, h, J) : (h == A || h == (g | A)) && !C.length ? et = gR(c, h, m, E) : et = Fd.apply(n, We);
                    var _t = Re ? v4 : Z4;
                    return X4(_t(et, We), c, h)
                }

                function B4(c, h, m, E) {
                    return c === n || Ls(c, zc[m]) && !Ut.call(E, m) ? h : c
                }

                function q4(c, h, m, E, C, F) {
                    return dn(c) && dn(h) && (F.set(h, c), Md(c, h, n, q4, F), F.delete(h)), c
                }

                function yR(c) {
                    return nh(c) ? n : c
                }

                function G4(c, h, m, E, C, F) {
                    var z = m & v,
                        J = c.length,
                        ce = h.length;
                    if (J != ce && !(z && ce > J)) return !1;
                    var we = F.get(c),
                        Ae = F.get(h);
                    if (we && Ae) return we == h && Ae == c;
                    var Ie = -1,
                        Re = !0,
                        We = m & y ? new Ba : n;
                    for (F.set(c, h), F.set(h, c); ++Ie < J;) {
                        var et = c[Ie],
                            _t = h[Ie];
                        if (E) var tt = z ? E(_t, et, Ie, h, c, F) : E(et, _t, Ie, c, h, F);
                        if (tt !== n) {
                            if (tt) continue;
                            Re = !1;
                            break
                        }
                        if (We) {
                            if (!Xg(h, function(Tt, Ct) {
                                    if (!Gu(We, Ct) && (et === Tt || C(et, Tt, m, E, F))) return We.push(Ct)
                                })) {
                                Re = !1;
                                break
                            }
                        } else if (!(et === _t || C(et, _t, m, E, F))) {
                            Re = !1;
                            break
                        }
                    }
                    return F.delete(c), F.delete(h), Re
                }

                function vR(c, h, m, E, C, F, z) {
                    switch (m) {
                        case W:
                            if (c.byteLength != h.byteLength || c.byteOffset != h.byteOffset) return !1;
                            c = c.buffer, h = h.buffer;
                        case vt:
                            return !(c.byteLength != h.byteLength || !F(new Td(c), new Td(h)));
                        case w:
                        case M:
                        case P:
                            return Ls(+c, +h);
                        case X:
                            return c.name == h.name && c.message == h.message;
                        case ve:
                        case oe:
                            return c == h + "";
                        case S:
                            var J = r_;
                        case de:
                            var ce = E & v;
                            if (J || (J = gd), c.size != h.size && !ce) return !1;
                            var we = z.get(c);
                            if (we) return we == h;
                            E |= y, z.set(c, h);
                            var Ae = G4(J(c), J(h), E, C, F, z);
                            return z.delete(c), Ae;
                        case he:
                            if (Yu) return Yu.call(c) == Yu.call(h)
                    }
                    return !1
                }

                function bR(c, h, m, E, C, F) {
                    var z = m & v,
                        J = k_(c),
                        ce = J.length,
                        we = k_(h),
                        Ae = we.length;
                    if (ce != Ae && !z) return !1;
                    for (var Ie = ce; Ie--;) {
                        var Re = J[Ie];
                        if (!(z ? Re in h : Ut.call(h, Re))) return !1
                    }
                    var We = F.get(c),
                        et = F.get(h);
                    if (We && et) return We == h && et == c;
                    var _t = !0;
                    F.set(c, h), F.set(h, c);
                    for (var tt = z; ++Ie < ce;) {
                        Re = J[Ie];
                        var Tt = c[Re],
                            Ct = h[Re];
                        if (E) var Xr = z ? E(Ct, Tt, Re, h, c, F) : E(Tt, Ct, Re, c, h, F);
                        if (!(Xr === n ? Tt === Ct || C(Tt, Ct, m, E, F) : Xr)) {
                            _t = !1;
                            break
                        }
                        tt || (tt = Re == "constructor")
                    }
                    if (_t && !tt) {
                        var yr = c.constructor,
                            Qr = h.constructor;
                        yr != Qr && "constructor" in c && "constructor" in h && !(typeof yr == "function" && yr instanceof yr && typeof Qr == "function" && Qr instanceof Qr) && (_t = !1)
                    }
                    return F.delete(c), F.delete(h), _t
                }

                function Wi(c) {
                    return $_(z4(c, n, rE), c + "")
                }

                function k_(c) {
                    return c4(c, qn, P_)
                }

                function I_(c) {
                    return c4(c, kr, V4)
                }
                var N_ = kd ? function(c) {
                    return kd.get(c)
                } : K_;

                function Gd(c) {
                    for (var h = c.name + "", m = Zc[h], E = Ut.call(Zc, h) ? m.length : 0; E--;) {
                        var C = m[E],
                            F = C.func;
                        if (F == null || F == c) return C.name
                    }
                    return h
                }

                function el(c) {
                    var h = Ut.call($, "placeholder") ? $ : c;
                    return h.placeholder
                }

                function Xe() {
                    var c = $.iteratee || Y_;
                    return c = c === Y_ ? h4 : c, arguments.length ? c(arguments[0], arguments[1]) : c
                }

                function Vd(c, h) {
                    var m = c.__data__;
                    return kR(h) ? m[typeof h == "string" ? "string" : "hash"] : m.map
                }

                function x_(c) {
                    for (var h = qn(c), m = h.length; m--;) {
                        var E = h[m],
                            C = c[E];
                        h[m] = [E, C, H4(C)]
                    }
                    return h
                }

                function Va(c, h) {
                    var m = xx(c, h);
                    return u4(m) ? m : n
                }

                function ER(c) {
                    var h = Ut.call(c, Fa),
                        m = c[Fa];
                    try {
                        c[Fa] = n;
                        var E = !0
                    } catch {}
                    var C = bd.call(c);
                    return E && (h ? c[Fa] = m : delete c[Fa]), C
                }
                var P_ = i_ ? function(c) {
                        return c == null ? [] : (c = Wt(c), wo(i_(c), function(h) {
                            return K5.call(c, h)
                        }))
                    } : Z_,
                    V4 = i_ ? function(c) {
                        for (var h = []; c;) Ao(h, P_(c)), c = Sd(c);
                        return h
                    } : Z_,
                    or = gr;
                (o_ && or(new o_(new ArrayBuffer(1))) != W || ju && or(new ju) != S || a_ && or(a_.resolve()) != le || Kc && or(new Kc) != de || Wu && or(new Wu) != Fe) && (or = function(c) {
                    var h = gr(c),
                        m = h == te ? c.constructor : n,
                        E = m ? ja(m) : "";
                    if (E) switch (E) {
                        case rP:
                            return W;
                        case sP:
                            return S;
                        case iP:
                            return le;
                        case oP:
                            return de;
                        case aP:
                            return Fe
                    }
                    return h
                });

                function TR(c, h, m) {
                    for (var E = -1, C = m.length; ++E < C;) {
                        var F = m[E],
                            z = F.size;
                        switch (F.type) {
                            case "drop":
                                c += z;
                                break;
                            case "dropRight":
                                h -= z;
                                break;
                            case "take":
                                h = ir(h, c + z);
                                break;
                            case "takeRight":
                                c = $n(c, h - z);
                                break
                        }
                    }
                    return {
                        start: c,
                        end: h
                    }
                }

                function SR(c) {
                    var h = c.match(IN);
                    return h ? h[1].split(NN) : []
                }

                function j4(c, h, m) {
                    h = No(h, c);
                    for (var E = -1, C = h.length, F = !1; ++E < C;) {
                        var z = ui(h[E]);
                        if (!(F = c != null && m(c, z))) break;
                        c = c[z]
                    }
                    return F || ++E != C ? F : (C = c == null ? 0 : c.length, !!C && Zd(C) && Hi(z, C) && (ft(c) || Wa(c)))
                }

                function wR(c) {
                    var h = c.length,
                        m = new c.constructor(h);
                    return h && typeof c[0] == "string" && Ut.call(c, "index") && (m.index = c.index, m.input = c.input), m
                }

                function W4(c) {
                    return typeof c.constructor == "function" && !eh(c) ? Xc(Sd(c)) : {}
                }

                function AR(c, h, m) {
                    var E = c.constructor;
                    switch (h) {
                        case vt:
                            return A_(c);
                        case w:
                        case M:
                            return new E(+c);
                        case W:
                            return cR(c, m);
                        case V:
                        case se:
                        case j:
                        case ne:
                        case Te:
                        case ke:
                        case xe:
                        case qe:
                        case Tn:
                            return C4(c, m);
                        case S:
                            return new E;
                        case P:
                        case oe:
                            return new E(c);
                        case ve:
                            return lR(c);
                        case de:
                            return new E;
                        case he:
                            return uR(c)
                    }
                }

                function OR(c, h) {
                    var m = h.length;
                    if (!m) return c;
                    var E = m - 1;
                    return h[E] = (m > 1 ? "& " : "") + h[E], h = h.join(m > 2 ? ", " : " "), c.replace(kN, `{
/* [wrapped with ` + h + `] */
`)
                }

                function CR(c) {
                    return ft(c) || Wa(c) || !!(Z5 && c && c[Z5])
                }

                function Hi(c, h) {
                    var m = typeof c;
                    return h = h ?? _e, !!h && (m == "number" || m != "symbol" && UN.test(c)) && c > -1 && c % 1 == 0 && c < h
                }

                function _r(c, h, m) {
                    if (!dn(m)) return !1;
                    var E = typeof h;
                    return (E == "number" ? Cr(m) && Hi(h, m.length) : E == "string" && h in m) ? Ls(m[h], c) : !1
                }

                function R_(c, h) {
                    if (ft(c)) return !1;
                    var m = typeof c;
                    return m == "number" || m == "symbol" || m == "boolean" || c == null || Zr(c) ? !0 : wN.test(c) || !SN.test(c) || h != null && c in Wt(h)
                }

                function kR(c) {
                    var h = typeof c;
                    return h == "string" || h == "number" || h == "symbol" || h == "boolean" ? c !== "__proto__" : c === null
                }

                function M_(c) {
                    var h = Gd(c),
                        m = $[h];
                    if (typeof m != "function" || !(h in St.prototype)) return !1;
                    if (c === m) return !0;
                    var E = N_(m);
                    return !!E && c === E[0]
                }

                function IR(c) {
                    return !!H5 && H5 in c
                }
                var NR = yd ? Yi : X_;

                function eh(c) {
                    var h = c && c.constructor,
                        m = typeof h == "function" && h.prototype || zc;
                    return c === m
                }

                function H4(c) {
                    return c === c && !dn(c)
                }

                function Y4(c, h) {
                    return function(m) {
                        return m == null ? !1 : m[c] === h && (h !== n || c in Wt(m))
                    }
                }

                function xR(c) {
                    var h = zd(c, function(E) {
                            return m.size === u && m.clear(), E
                        }),
                        m = h.cache;
                    return h
                }

                function PR(c, h) {
                    var m = c[1],
                        E = h[1],
                        C = m | E,
                        F = C < (g | b | D),
                        z = E == D && m == N || E == D && m == L && c[7].length <= h[8] || E == (D | L) && h[7].length <= h[8] && m == N;
                    if (!(F || z)) return c;
                    E & g && (c[2] = h[2], C |= m & g ? 0 : O);
                    var J = h[3];
                    if (J) {
                        var ce = c[3];
                        c[3] = ce ? I4(ce, J, h[4]) : J, c[4] = ce ? Oo(c[3], f) : h[4]
                    }
                    return J = h[5], J && (ce = c[5], c[5] = ce ? N4(ce, J, h[6]) : J, c[6] = ce ? Oo(c[5], f) : h[6]), J = h[7], J && (c[7] = J), E & D && (c[8] = c[8] == null ? h[8] : ir(c[8], h[8])), c[9] == null && (c[9] = h[9]), c[0] = h[0], c[1] = C, c
                }

                function RR(c) {
                    var h = [];
                    if (c != null)
                        for (var m in Wt(c)) h.push(m);
                    return h
                }

                function MR(c) {
                    return bd.call(c)
                }

                function z4(c, h, m) {
                    return h = $n(h === n ? c.length - 1 : h, 0),
                        function() {
                            for (var E = arguments, C = -1, F = $n(E.length - h, 0), z = pe(F); ++C < F;) z[C] = E[h + C];
                            C = -1;
                            for (var J = pe(h + 1); ++C < h;) J[C] = E[C];
                            return J[h] = m(z), Yr(c, this, J)
                        }
                }

                function K4(c, h) {
                    return h.length < 2 ? c : Ga(c, _s(h, 0, -1))
                }

                function DR(c, h) {
                    for (var m = c.length, E = ir(h.length, m), C = Or(c); E--;) {
                        var F = h[E];
                        c[E] = Hi(F, m) ? C[F] : n
                    }
                    return c
                }

                function D_(c, h) {
                    if (!(h === "constructor" && typeof c[h] == "function") && h != "__proto__") return c[h]
                }
                var Z4 = Q4(v4),
                    th = Zx || function(c, h) {
                        return Yn.setTimeout(c, h)
                    },
                    $_ = Q4(sR);

                function X4(c, h, m) {
                    var E = h + "";
                    return $_(c, OR(E, $R(SR(E), m)))
                }

                function Q4(c) {
                    var h = 0,
                        m = 0;
                    return function() {
                        var E = eP(),
                            C = fe - (E - m);
                        if (m = E, C > 0) {
                            if (++h >= Z) return arguments[0]
                        } else h = 0;
                        return c.apply(n, arguments)
                    }
                }

                function jd(c, h) {
                    var m = -1,
                        E = c.length,
                        C = E - 1;
                    for (h = h === n ? E : h; ++m < h;) {
                        var F = y_(m, C),
                            z = c[F];
                        c[F] = c[m], c[m] = z
                    }
                    return c.length = h, c
                }
                var J4 = xR(function(c) {
                    var h = [];
                    return c.charCodeAt(0) === 46 && h.push(""), c.replace(AN, function(m, E, C, F) {
                        h.push(C ? F.replace(RN, "$1") : E || m)
                    }), h
                });

                function ui(c) {
                    if (typeof c == "string" || Zr(c)) return c;
                    var h = c + "";
                    return h == "0" && 1 / c == -ue ? "-0" : h
                }

                function ja(c) {
                    if (c != null) {
                        try {
                            return vd.call(c)
                        } catch {}
                        try {
                            return c + ""
                        } catch {}
                    }
                    return ""
                }

                function $R(c, h) {
                    return ds(ot, function(m) {
                        var E = "_." + m[0];
                        h & m[1] && !pd(c, E) && c.push(E)
                    }), c.sort()
                }

                function eE(c) {
                    if (c instanceof St) return c.clone();
                    var h = new ms(c.__wrapped__, c.__chain__);
                    return h.__actions__ = Or(c.__actions__), h.__index__ = c.__index__, h.__values__ = c.__values__, h
                }

                function LR(c, h, m) {
                    (m ? _r(c, h, m) : h === n) ? h = 1: h = $n(mt(h), 0);
                    var E = c == null ? 0 : c.length;
                    if (!E || h < 1) return [];
                    for (var C = 0, F = 0, z = pe(Od(E / h)); C < E;) z[F++] = _s(c, C, C += h);
                    return z
                }

                function FR(c) {
                    for (var h = -1, m = c == null ? 0 : c.length, E = 0, C = []; ++h < m;) {
                        var F = c[h];
                        F && (C[E++] = F)
                    }
                    return C
                }

                function UR() {
                    var c = arguments.length;
                    if (!c) return [];
                    for (var h = pe(c - 1), m = arguments[0], E = c; E--;) h[E - 1] = arguments[E];
                    return Ao(ft(m) ? Or(m) : [m], zn(h, 1))
                }
                var BR = bt(function(c, h) {
                        return Sn(c) ? Ku(c, zn(h, 1, Sn, !0)) : []
                    }),
                    qR = bt(function(c, h) {
                        var m = ys(h);
                        return Sn(m) && (m = n), Sn(c) ? Ku(c, zn(h, 1, Sn, !0), Xe(m, 2)) : []
                    }),
                    GR = bt(function(c, h) {
                        var m = ys(h);
                        return Sn(m) && (m = n), Sn(c) ? Ku(c, zn(h, 1, Sn, !0), n, m) : []
                    });

                function VR(c, h, m) {
                    var E = c == null ? 0 : c.length;
                    return E ? (h = m || h === n ? 1 : mt(h), _s(c, h < 0 ? 0 : h, E)) : []
                }

                function jR(c, h, m) {
                    var E = c == null ? 0 : c.length;
                    return E ? (h = m || h === n ? 1 : mt(h), h = E - h, _s(c, 0, h < 0 ? 0 : h)) : []
                }

                function WR(c, h) {
                    return c && c.length ? $d(c, Xe(h, 3), !0, !0) : []
                }

                function HR(c, h) {
                    return c && c.length ? $d(c, Xe(h, 3), !0) : []
                }

                function YR(c, h, m, E) {
                    var C = c == null ? 0 : c.length;
                    return C ? (m && typeof m != "number" && _r(c, h, m) && (m = 0, E = C), UP(c, h, m, E)) : []
                }

                function tE(c, h, m) {
                    var E = c == null ? 0 : c.length;
                    if (!E) return -1;
                    var C = m == null ? 0 : mt(m);
                    return C < 0 && (C = $n(E + C, 0)), md(c, Xe(h, 3), C)
                }

                function nE(c, h, m) {
                    var E = c == null ? 0 : c.length;
                    if (!E) return -1;
                    var C = E - 1;
                    return m !== n && (C = mt(m), C = m < 0 ? $n(E + C, 0) : ir(C, E - 1)), md(c, Xe(h, 3), C, !0)
                }

                function rE(c) {
                    var h = c == null ? 0 : c.length;
                    return h ? zn(c, 1) : []
                }

                function zR(c) {
                    var h = c == null ? 0 : c.length;
                    return h ? zn(c, ue) : []
                }

                function KR(c, h) {
                    var m = c == null ? 0 : c.length;
                    return m ? (h = h === n ? 1 : mt(h), zn(c, h)) : []
                }

                function ZR(c) {
                    for (var h = -1, m = c == null ? 0 : c.length, E = {}; ++h < m;) {
                        var C = c[h];
                        E[C[0]] = C[1]
                    }
                    return E
                }

                function sE(c) {
                    return c && c.length ? c[0] : n
                }

                function XR(c, h, m) {
                    var E = c == null ? 0 : c.length;
                    if (!E) return -1;
                    var C = m == null ? 0 : mt(m);
                    return C < 0 && (C = $n(E + C, 0)), jc(c, h, C)
                }

                function QR(c) {
                    var h = c == null ? 0 : c.length;
                    return h ? _s(c, 0, -1) : []
                }
                var JR = bt(function(c) {
                        var h = cn(c, S_);
                        return h.length && h[0] === c[0] ? d_(h) : []
                    }),
                    eM = bt(function(c) {
                        var h = ys(c),
                            m = cn(c, S_);
                        return h === ys(m) ? h = n : m.pop(), m.length && m[0] === c[0] ? d_(m, Xe(h, 2)) : []
                    }),
                    tM = bt(function(c) {
                        var h = ys(c),
                            m = cn(c, S_);
                        return h = typeof h == "function" ? h : n, h && m.pop(), m.length && m[0] === c[0] ? d_(m, n, h) : []
                    });

                function nM(c, h) {
                    return c == null ? "" : Qx.call(c, h)
                }

                function ys(c) {
                    var h = c == null ? 0 : c.length;
                    return h ? c[h - 1] : n
                }

                function rM(c, h, m) {
                    var E = c == null ? 0 : c.length;
                    if (!E) return -1;
                    var C = E;
                    return m !== n && (C = mt(m), C = C < 0 ? $n(E + C, 0) : ir(C, E - 1)), h === h ? $x(c, h, C) : md(c, F5, C, !0)
                }

                function sM(c, h) {
                    return c && c.length ? m4(c, mt(h)) : n
                }
                var iM = bt(iE);

                function iE(c, h) {
                    return c && c.length && h && h.length ? __(c, h) : c
                }

                function oM(c, h, m) {
                    return c && c.length && h && h.length ? __(c, h, Xe(m, 2)) : c
                }

                function aM(c, h, m) {
                    return c && c.length && h && h.length ? __(c, h, n, m) : c
                }
                var cM = Wi(function(c, h) {
                    var m = c == null ? 0 : c.length,
                        E = l_(c, h);
                    return y4(c, cn(h, function(C) {
                        return Hi(C, m) ? +C : C
                    }).sort(k4)), E
                });

                function lM(c, h) {
                    var m = [];
                    if (!(c && c.length)) return m;
                    var E = -1,
                        C = [],
                        F = c.length;
                    for (h = Xe(h, 3); ++E < F;) {
                        var z = c[E];
                        h(z, E, c) && (m.push(z), C.push(E))
                    }
                    return y4(c, C), m
                }

                function L_(c) {
                    return c == null ? c : nP.call(c)
                }

                function uM(c, h, m) {
                    var E = c == null ? 0 : c.length;
                    return E ? (m && typeof m != "number" && _r(c, h, m) ? (h = 0, m = E) : (h = h == null ? 0 : mt(h), m = m === n ? E : mt(m)), _s(c, h, m)) : []
                }

                function hM(c, h) {
                    return Dd(c, h)
                }

                function fM(c, h, m) {
                    return b_(c, h, Xe(m, 2))
                }

                function dM(c, h) {
                    var m = c == null ? 0 : c.length;
                    if (m) {
                        var E = Dd(c, h);
                        if (E < m && Ls(c[E], h)) return E
                    }
                    return -1
                }

                function pM(c, h) {
                    return Dd(c, h, !0)
                }

                function mM(c, h, m) {
                    return b_(c, h, Xe(m, 2), !0)
                }

                function gM(c, h) {
                    var m = c == null ? 0 : c.length;
                    if (m) {
                        var E = Dd(c, h, !0) - 1;
                        if (Ls(c[E], h)) return E
                    }
                    return -1
                }

                function _M(c) {
                    return c && c.length ? b4(c) : []
                }

                function yM(c, h) {
                    return c && c.length ? b4(c, Xe(h, 2)) : []
                }

                function vM(c) {
                    var h = c == null ? 0 : c.length;
                    return h ? _s(c, 1, h) : []
                }

                function bM(c, h, m) {
                    return c && c.length ? (h = m || h === n ? 1 : mt(h), _s(c, 0, h < 0 ? 0 : h)) : []
                }

                function EM(c, h, m) {
                    var E = c == null ? 0 : c.length;
                    return E ? (h = m || h === n ? 1 : mt(h), h = E - h, _s(c, h < 0 ? 0 : h, E)) : []
                }

                function TM(c, h) {
                    return c && c.length ? $d(c, Xe(h, 3), !1, !0) : []
                }

                function SM(c, h) {
                    return c && c.length ? $d(c, Xe(h, 3)) : []
                }
                var wM = bt(function(c) {
                        return Io(zn(c, 1, Sn, !0))
                    }),
                    AM = bt(function(c) {
                        var h = ys(c);
                        return Sn(h) && (h = n), Io(zn(c, 1, Sn, !0), Xe(h, 2))
                    }),
                    OM = bt(function(c) {
                        var h = ys(c);
                        return h = typeof h == "function" ? h : n, Io(zn(c, 1, Sn, !0), n, h)
                    });

                function CM(c) {
                    return c && c.length ? Io(c) : []
                }

                function kM(c, h) {
                    return c && c.length ? Io(c, Xe(h, 2)) : []
                }

                function IM(c, h) {
                    return h = typeof h == "function" ? h : n, c && c.length ? Io(c, n, h) : []
                }

                function F_(c) {
                    if (!(c && c.length)) return [];
                    var h = 0;
                    return c = wo(c, function(m) {
                        if (Sn(m)) return h = $n(m.length, h), !0
                    }), t_(h, function(m) {
                        return cn(c, Qg(m))
                    })
                }

                function oE(c, h) {
                    if (!(c && c.length)) return [];
                    var m = F_(c);
                    return h == null ? m : cn(m, function(E) {
                        return Yr(h, n, E)
                    })
                }
                var NM = bt(function(c, h) {
                        return Sn(c) ? Ku(c, h) : []
                    }),
                    xM = bt(function(c) {
                        return T_(wo(c, Sn))
                    }),
                    PM = bt(function(c) {
                        var h = ys(c);
                        return Sn(h) && (h = n), T_(wo(c, Sn), Xe(h, 2))
                    }),
                    RM = bt(function(c) {
                        var h = ys(c);
                        return h = typeof h == "function" ? h : n, T_(wo(c, Sn), n, h)
                    }),
                    MM = bt(F_);

                function DM(c, h) {
                    return w4(c || [], h || [], zu)
                }

                function $M(c, h) {
                    return w4(c || [], h || [], Qu)
                }
                var LM = bt(function(c) {
                    var h = c.length,
                        m = h > 1 ? c[h - 1] : n;
                    return m = typeof m == "function" ? (c.pop(), m) : n, oE(c, m)
                });

                function aE(c) {
                    var h = $(c);
                    return h.__chain__ = !0, h
                }

                function FM(c, h) {
                    return h(c), c
                }

                function Wd(c, h) {
                    return h(c)
                }
                var UM = Wi(function(c) {
                    var h = c.length,
                        m = h ? c[0] : 0,
                        E = this.__wrapped__,
                        C = function(F) {
                            return l_(F, c)
                        };
                    return h > 1 || this.__actions__.length || !(E instanceof St) || !Hi(m) ? this.thru(C) : (E = E.slice(m, +m + (h ? 1 : 0)), E.__actions__.push({
                        func: Wd,
                        args: [C],
                        thisArg: n
                    }), new ms(E, this.__chain__).thru(function(F) {
                        return h && !F.length && F.push(n), F
                    }))
                });

                function BM() {
                    return aE(this)
                }

                function qM() {
                    return new ms(this.value(), this.__chain__)
                }

                function GM() {
                    this.__values__ === n && (this.__values__ = EE(this.value()));
                    var c = this.__index__ >= this.__values__.length,
                        h = c ? n : this.__values__[this.__index__++];
                    return {
                        done: c,
                        value: h
                    }
                }

                function VM() {
                    return this
                }

                function jM(c) {
                    for (var h, m = this; m instanceof Nd;) {
                        var E = eE(m);
                        E.__index__ = 0, E.__values__ = n, h ? C.__wrapped__ = E : h = E;
                        var C = E;
                        m = m.__wrapped__
                    }
                    return C.__wrapped__ = c, h
                }

                function WM() {
                    var c = this.__wrapped__;
                    if (c instanceof St) {
                        var h = c;
                        return this.__actions__.length && (h = new St(this)), h = h.reverse(), h.__actions__.push({
                            func: Wd,
                            args: [L_],
                            thisArg: n
                        }), new ms(h, this.__chain__)
                    }
                    return this.thru(L_)
                }

                function HM() {
                    return S4(this.__wrapped__, this.__actions__)
                }
                var YM = Ld(function(c, h, m) {
                    Ut.call(c, m) ? ++c[m] : Vi(c, m, 1)
                });

                function zM(c, h, m) {
                    var E = ft(c) ? $5 : FP;
                    return m && _r(c, h, m) && (h = n), E(c, Xe(h, 3))
                }

                function KM(c, h) {
                    var m = ft(c) ? wo : o4;
                    return m(c, Xe(h, 3))
                }
                var ZM = M4(tE),
                    XM = M4(nE);

                function QM(c, h) {
                    return zn(Hd(c, h), 1)
                }

                function JM(c, h) {
                    return zn(Hd(c, h), ue)
                }

                function eD(c, h, m) {
                    return m = m === n ? 1 : mt(m), zn(Hd(c, h), m)
                }

                function cE(c, h) {
                    var m = ft(c) ? ds : ko;
                    return m(c, Xe(h, 3))
                }

                function lE(c, h) {
                    var m = ft(c) ? vx : i4;
                    return m(c, Xe(h, 3))
                }
                var tD = Ld(function(c, h, m) {
                    Ut.call(c, m) ? c[m].push(h) : Vi(c, m, [h])
                });

                function nD(c, h, m, E) {
                    c = Cr(c) ? c : nl(c), m = m && !E ? mt(m) : 0;
                    var C = c.length;
                    return m < 0 && (m = $n(C + m, 0)), Xd(c) ? m <= C && c.indexOf(h, m) > -1 : !!C && jc(c, h, m) > -1
                }
                var rD = bt(function(c, h, m) {
                        var E = -1,
                            C = typeof h == "function",
                            F = Cr(c) ? pe(c.length) : [];
                        return ko(c, function(z) {
                            F[++E] = C ? Yr(h, z, m) : Zu(z, h, m)
                        }), F
                    }),
                    sD = Ld(function(c, h, m) {
                        Vi(c, m, h)
                    });

                function Hd(c, h) {
                    var m = ft(c) ? cn : f4;
                    return m(c, Xe(h, 3))
                }

                function iD(c, h, m, E) {
                    return c == null ? [] : (ft(h) || (h = h == null ? [] : [h]), m = E ? n : m, ft(m) || (m = m == null ? [] : [m]), g4(c, h, m))
                }
                var oD = Ld(function(c, h, m) {
                    c[m ? 0 : 1].push(h)
                }, function() {
                    return [
                        [],
                        []
                    ]
                });

                function aD(c, h, m) {
                    var E = ft(c) ? Zg : B5,
                        C = arguments.length < 3;
                    return E(c, Xe(h, 4), m, C, ko)
                }

                function cD(c, h, m) {
                    var E = ft(c) ? bx : B5,
                        C = arguments.length < 3;
                    return E(c, Xe(h, 4), m, C, i4)
                }

                function lD(c, h) {
                    var m = ft(c) ? wo : o4;
                    return m(c, Kd(Xe(h, 3)))
                }

                function uD(c) {
                    var h = ft(c) ? t4 : nR;
                    return h(c)
                }

                function hD(c, h, m) {
                    (m ? _r(c, h, m) : h === n) ? h = 1: h = mt(h);
                    var E = ft(c) ? RP : rR;
                    return E(c, h)
                }

                function fD(c) {
                    var h = ft(c) ? MP : iR;
                    return h(c)
                }

                function dD(c) {
                    if (c == null) return 0;
                    if (Cr(c)) return Xd(c) ? Hc(c) : c.length;
                    var h = or(c);
                    return h == S || h == de ? c.size : m_(c).length
                }

                function pD(c, h, m) {
                    var E = ft(c) ? Xg : oR;
                    return m && _r(c, h, m) && (h = n), E(c, Xe(h, 3))
                }
                var mD = bt(function(c, h) {
                        if (c == null) return [];
                        var m = h.length;
                        return m > 1 && _r(c, h[0], h[1]) ? h = [] : m > 2 && _r(h[0], h[1], h[2]) && (h = [h[0]]), g4(c, zn(h, 1), [])
                    }),
                    Yd = Kx || function() {
                        return Yn.Date.now()
                    };

                function gD(c, h) {
                    if (typeof h != "function") throw new ps(o);
                    return c = mt(c),
                        function() {
                            if (--c < 1) return h.apply(this, arguments)
                        }
                }

                function uE(c, h, m) {
                    return h = m ? n : h, h = c && h == null ? c.length : h, ji(c, D, n, n, n, n, h)
                }

                function hE(c, h) {
                    var m;
                    if (typeof h != "function") throw new ps(o);
                    return c = mt(c),
                        function() {
                            return --c > 0 && (m = h.apply(this, arguments)), c <= 1 && (h = n), m
                        }
                }
                var U_ = bt(function(c, h, m) {
                        var E = g;
                        if (m.length) {
                            var C = Oo(m, el(U_));
                            E |= A
                        }
                        return ji(c, E, h, m, C)
                    }),
                    fE = bt(function(c, h, m) {
                        var E = g | b;
                        if (m.length) {
                            var C = Oo(m, el(fE));
                            E |= A
                        }
                        return ji(h, E, c, m, C)
                    });

                function dE(c, h, m) {
                    h = m ? n : h;
                    var E = ji(c, N, n, n, n, n, n, h);
                    return E.placeholder = dE.placeholder, E
                }

                function pE(c, h, m) {
                    h = m ? n : h;
                    var E = ji(c, k, n, n, n, n, n, h);
                    return E.placeholder = pE.placeholder, E
                }

                function mE(c, h, m) {
                    var E, C, F, z, J, ce, we = 0,
                        Ae = !1,
                        Ie = !1,
                        Re = !0;
                    if (typeof c != "function") throw new ps(o);
                    h = vs(h) || 0, dn(m) && (Ae = !!m.leading, Ie = "maxWait" in m, F = Ie ? $n(vs(m.maxWait) || 0, h) : F, Re = "trailing" in m ? !!m.trailing : Re);

                    function We(wn) {
                        var Fs = E,
                            Ki = C;
                        return E = C = n, we = wn, z = c.apply(Ki, Fs), z
                    }

                    function et(wn) {
                        return we = wn, J = th(Tt, h), Ae ? We(wn) : z
                    }

                    function _t(wn) {
                        var Fs = wn - ce,
                            Ki = wn - we,
                            ME = h - Fs;
                        return Ie ? ir(ME, F - Ki) : ME
                    }

                    function tt(wn) {
                        var Fs = wn - ce,
                            Ki = wn - we;
                        return ce === n || Fs >= h || Fs < 0 || Ie && Ki >= F
                    }

                    function Tt() {
                        var wn = Yd();
                        if (tt(wn)) return Ct(wn);
                        J = th(Tt, _t(wn))
                    }

                    function Ct(wn) {
                        return J = n, Re && E ? We(wn) : (E = C = n, z)
                    }

                    function Xr() {
                        J !== n && A4(J), we = 0, E = ce = C = J = n
                    }

                    function yr() {
                        return J === n ? z : Ct(Yd())
                    }

                    function Qr() {
                        var wn = Yd(),
                            Fs = tt(wn);
                        if (E = arguments, C = this, ce = wn, Fs) {
                            if (J === n) return et(ce);
                            if (Ie) return A4(J), J = th(Tt, h), We(ce)
                        }
                        return J === n && (J = th(Tt, h)), z
                    }
                    return Qr.cancel = Xr, Qr.flush = yr, Qr
                }
                var _D = bt(function(c, h) {
                        return s4(c, 1, h)
                    }),
                    yD = bt(function(c, h, m) {
                        return s4(c, vs(h) || 0, m)
                    });

                function vD(c) {
                    return ji(c, q)
                }

                function zd(c, h) {
                    if (typeof c != "function" || h != null && typeof h != "function") throw new ps(o);
                    var m = function() {
                        var E = arguments,
                            C = h ? h.apply(this, E) : E[0],
                            F = m.cache;
                        if (F.has(C)) return F.get(C);
                        var z = c.apply(this, E);
                        return m.cache = F.set(C, z) || F, z
                    };
                    return m.cache = new(zd.Cache || Gi), m
                }
                zd.Cache = Gi;

                function Kd(c) {
                    if (typeof c != "function") throw new ps(o);
                    return function() {
                        var h = arguments;
                        switch (h.length) {
                            case 0:
                                return !c.call(this);
                            case 1:
                                return !c.call(this, h[0]);
                            case 2:
                                return !c.call(this, h[0], h[1]);
                            case 3:
                                return !c.call(this, h[0], h[1], h[2])
                        }
                        return !c.apply(this, h)
                    }
                }

                function bD(c) {
                    return hE(2, c)
                }
                var ED = aR(function(c, h) {
                        h = h.length == 1 && ft(h[0]) ? cn(h[0], zr(Xe())) : cn(zn(h, 1), zr(Xe()));
                        var m = h.length;
                        return bt(function(E) {
                            for (var C = -1, F = ir(E.length, m); ++C < F;) E[C] = h[C].call(this, E[C]);
                            return Yr(c, this, E)
                        })
                    }),
                    B_ = bt(function(c, h) {
                        var m = Oo(h, el(B_));
                        return ji(c, A, n, h, m)
                    }),
                    gE = bt(function(c, h) {
                        var m = Oo(h, el(gE));
                        return ji(c, x, n, h, m)
                    }),
                    TD = Wi(function(c, h) {
                        return ji(c, L, n, n, n, h)
                    });

                function SD(c, h) {
                    if (typeof c != "function") throw new ps(o);
                    return h = h === n ? h : mt(h), bt(c, h)
                }

                function wD(c, h) {
                    if (typeof c != "function") throw new ps(o);
                    return h = h == null ? 0 : $n(mt(h), 0), bt(function(m) {
                        var E = m[h],
                            C = xo(m, 0, h);
                        return E && Ao(C, E), Yr(c, this, C)
                    })
                }

                function AD(c, h, m) {
                    var E = !0,
                        C = !0;
                    if (typeof c != "function") throw new ps(o);
                    return dn(m) && (E = "leading" in m ? !!m.leading : E, C = "trailing" in m ? !!m.trailing : C), mE(c, h, {
                        leading: E,
                        maxWait: h,
                        trailing: C
                    })
                }

                function OD(c) {
                    return uE(c, 1)
                }

                function CD(c, h) {
                    return B_(w_(h), c)
                }

                function kD() {
                    if (!arguments.length) return [];
                    var c = arguments[0];
                    return ft(c) ? c : [c]
                }

                function ID(c) {
                    return gs(c, _)
                }

                function ND(c, h) {
                    return h = typeof h == "function" ? h : n, gs(c, _, h)
                }

                function xD(c) {
                    return gs(c, d | _)
                }

                function PD(c, h) {
                    return h = typeof h == "function" ? h : n, gs(c, d | _, h)
                }

                function RD(c, h) {
                    return h == null || r4(c, h, qn(h))
                }

                function Ls(c, h) {
                    return c === h || c !== c && h !== h
                }
                var MD = qd(f_),
                    DD = qd(function(c, h) {
                        return c >= h
                    }),
                    Wa = l4(function() {
                        return arguments
                    }()) ? l4 : function(c) {
                        return vn(c) && Ut.call(c, "callee") && !K5.call(c, "callee")
                    },
                    ft = pe.isArray,
                    $D = N5 ? zr(N5) : jP;

                function Cr(c) {
                    return c != null && Zd(c.length) && !Yi(c)
                }

                function Sn(c) {
                    return vn(c) && Cr(c)
                }

                function LD(c) {
                    return c === !0 || c === !1 || vn(c) && gr(c) == w
                }
                var Po = Xx || X_,
                    FD = x5 ? zr(x5) : WP;

                function UD(c) {
                    return vn(c) && c.nodeType === 1 && !nh(c)
                }

                function BD(c) {
                    if (c == null) return !0;
                    if (Cr(c) && (ft(c) || typeof c == "string" || typeof c.splice == "function" || Po(c) || tl(c) || Wa(c))) return !c.length;
                    var h = or(c);
                    if (h == S || h == de) return !c.size;
                    if (eh(c)) return !m_(c).length;
                    for (var m in c)
                        if (Ut.call(c, m)) return !1;
                    return !0
                }

                function qD(c, h) {
                    return Xu(c, h)
                }

                function GD(c, h, m) {
                    m = typeof m == "function" ? m : n;
                    var E = m ? m(c, h) : n;
                    return E === n ? Xu(c, h, n, m) : !!E
                }

                function q_(c) {
                    if (!vn(c)) return !1;
                    var h = gr(c);
                    return h == X || h == Y || typeof c.message == "string" && typeof c.name == "string" && !nh(c)
                }

                function VD(c) {
                    return typeof c == "number" && X5(c)
                }

                function Yi(c) {
                    if (!dn(c)) return !1;
                    var h = gr(c);
                    return h == I || h == T || h == it || h == me
                }

                function _E(c) {
                    return typeof c == "number" && c == mt(c)
                }

                function Zd(c) {
                    return typeof c == "number" && c > -1 && c % 1 == 0 && c <= _e
                }

                function dn(c) {
                    var h = typeof c;
                    return c != null && (h == "object" || h == "function")
                }

                function vn(c) {
                    return c != null && typeof c == "object"
                }
                var yE = P5 ? zr(P5) : YP;

                function jD(c, h) {
                    return c === h || p_(c, h, x_(h))
                }

                function WD(c, h, m) {
                    return m = typeof m == "function" ? m : n, p_(c, h, x_(h), m)
                }

                function HD(c) {
                    return vE(c) && c != +c
                }

                function YD(c) {
                    if (NR(c)) throw new ut(i);
                    return u4(c)
                }

                function zD(c) {
                    return c === null
                }

                function KD(c) {
                    return c == null
                }

                function vE(c) {
                    return typeof c == "number" || vn(c) && gr(c) == P
                }

                function nh(c) {
                    if (!vn(c) || gr(c) != te) return !1;
                    var h = Sd(c);
                    if (h === null) return !0;
                    var m = Ut.call(h, "constructor") && h.constructor;
                    return typeof m == "function" && m instanceof m && vd.call(m) == Wx
                }
                var G_ = R5 ? zr(R5) : zP;

                function ZD(c) {
                    return _E(c) && c >= -_e && c <= _e
                }
                var bE = M5 ? zr(M5) : KP;

                function Xd(c) {
                    return typeof c == "string" || !ft(c) && vn(c) && gr(c) == oe
                }

                function Zr(c) {
                    return typeof c == "symbol" || vn(c) && gr(c) == he
                }
                var tl = D5 ? zr(D5) : ZP;

                function XD(c) {
                    return c === n
                }

                function QD(c) {
                    return vn(c) && or(c) == Fe
                }

                function JD(c) {
                    return vn(c) && gr(c) == at
                }
                var e$ = qd(g_),
                    t$ = qd(function(c, h) {
                        return c <= h
                    });

                function EE(c) {
                    if (!c) return [];
                    if (Cr(c)) return Xd(c) ? Ds(c) : Or(c);
                    if (Vu && c[Vu]) return Rx(c[Vu]());
                    var h = or(c),
                        m = h == S ? r_ : h == de ? gd : nl;
                    return m(c)
                }

                function zi(c) {
                    if (!c) return c === 0 ? c : 0;
                    if (c = vs(c), c === ue || c === -ue) {
                        var h = c < 0 ? -1 : 1;
                        return h * Oe
                    }
                    return c === c ? c : 0
                }

                function mt(c) {
                    var h = zi(c),
                        m = h % 1;
                    return h === h ? m ? h - m : h : 0
                }

                function TE(c) {
                    return c ? qa(mt(c), 0, Ce) : 0
                }

                function vs(c) {
                    if (typeof c == "number") return c;
                    if (Zr(c)) return Ee;
                    if (dn(c)) {
                        var h = typeof c.valueOf == "function" ? c.valueOf() : c;
                        c = dn(h) ? h + "" : h
                    }
                    if (typeof c != "string") return c === 0 ? c : +c;
                    c = q5(c);
                    var m = $N.test(c);
                    return m || FN.test(c) ? gx(c.slice(2), m ? 2 : 8) : DN.test(c) ? Ee : +c
                }

                function SE(c) {
                    return li(c, kr(c))
                }

                function n$(c) {
                    return c ? qa(mt(c), -_e, _e) : c === 0 ? c : 0
                }

                function Lt(c) {
                    return c == null ? "" : Kr(c)
                }
                var r$ = Qc(function(c, h) {
                        if (eh(h) || Cr(h)) {
                            li(h, qn(h), c);
                            return
                        }
                        for (var m in h) Ut.call(h, m) && zu(c, m, h[m])
                    }),
                    wE = Qc(function(c, h) {
                        li(h, kr(h), c)
                    }),
                    Qd = Qc(function(c, h, m, E) {
                        li(h, kr(h), c, E)
                    }),
                    s$ = Qc(function(c, h, m, E) {
                        li(h, qn(h), c, E)
                    }),
                    i$ = Wi(l_);

                function o$(c, h) {
                    var m = Xc(c);
                    return h == null ? m : n4(m, h)
                }
                var a$ = bt(function(c, h) {
                        c = Wt(c);
                        var m = -1,
                            E = h.length,
                            C = E > 2 ? h[2] : n;
                        for (C && _r(h[0], h[1], C) && (E = 1); ++m < E;)
                            for (var F = h[m], z = kr(F), J = -1, ce = z.length; ++J < ce;) {
                                var we = z[J],
                                    Ae = c[we];
                                (Ae === n || Ls(Ae, zc[we]) && !Ut.call(c, we)) && (c[we] = F[we])
                            }
                        return c
                    }),
                    c$ = bt(function(c) {
                        return c.push(n, q4), Yr(AE, n, c)
                    });

                function l$(c, h) {
                    return L5(c, Xe(h, 3), ci)
                }

                function u$(c, h) {
                    return L5(c, Xe(h, 3), h_)
                }

                function h$(c, h) {
                    return c == null ? c : u_(c, Xe(h, 3), kr)
                }

                function f$(c, h) {
                    return c == null ? c : a4(c, Xe(h, 3), kr)
                }

                function d$(c, h) {
                    return c && ci(c, Xe(h, 3))
                }

                function p$(c, h) {
                    return c && h_(c, Xe(h, 3))
                }

                function m$(c) {
                    return c == null ? [] : Rd(c, qn(c))
                }

                function g$(c) {
                    return c == null ? [] : Rd(c, kr(c))
                }

                function V_(c, h, m) {
                    var E = c == null ? n : Ga(c, h);
                    return E === n ? m : E
                }

                function _$(c, h) {
                    return c != null && j4(c, h, BP)
                }

                function j_(c, h) {
                    return c != null && j4(c, h, qP)
                }
                var y$ = $4(function(c, h, m) {
                        h != null && typeof h.toString != "function" && (h = bd.call(h)), c[h] = m
                    }, H_(Ir)),
                    v$ = $4(function(c, h, m) {
                        h != null && typeof h.toString != "function" && (h = bd.call(h)), Ut.call(c, h) ? c[h].push(m) : c[h] = [m]
                    }, Xe),
                    b$ = bt(Zu);

                function qn(c) {
                    return Cr(c) ? e4(c) : m_(c)
                }

                function kr(c) {
                    return Cr(c) ? e4(c, !0) : XP(c)
                }

                function E$(c, h) {
                    var m = {};
                    return h = Xe(h, 3), ci(c, function(E, C, F) {
                        Vi(m, h(E, C, F), E)
                    }), m
                }

                function T$(c, h) {
                    var m = {};
                    return h = Xe(h, 3), ci(c, function(E, C, F) {
                        Vi(m, C, h(E, C, F))
                    }), m
                }
                var S$ = Qc(function(c, h, m) {
                        Md(c, h, m)
                    }),
                    AE = Qc(function(c, h, m, E) {
                        Md(c, h, m, E)
                    }),
                    w$ = Wi(function(c, h) {
                        var m = {};
                        if (c == null) return m;
                        var E = !1;
                        h = cn(h, function(F) {
                            return F = No(F, c), E || (E = F.length > 1), F
                        }), li(c, I_(c), m), E && (m = gs(m, d | p | _, yR));
                        for (var C = h.length; C--;) E_(m, h[C]);
                        return m
                    });

                function A$(c, h) {
                    return OE(c, Kd(Xe(h)))
                }
                var O$ = Wi(function(c, h) {
                    return c == null ? {} : JP(c, h)
                });

                function OE(c, h) {
                    if (c == null) return {};
                    var m = cn(I_(c), function(E) {
                        return [E]
                    });
                    return h = Xe(h), _4(c, m, function(E, C) {
                        return h(E, C[0])
                    })
                }

                function C$(c, h, m) {
                    h = No(h, c);
                    var E = -1,
                        C = h.length;
                    for (C || (C = 1, c = n); ++E < C;) {
                        var F = c == null ? n : c[ui(h[E])];
                        F === n && (E = C, F = m), c = Yi(F) ? F.call(c) : F
                    }
                    return c
                }

                function k$(c, h, m) {
                    return c == null ? c : Qu(c, h, m)
                }

                function I$(c, h, m, E) {
                    return E = typeof E == "function" ? E : n, c == null ? c : Qu(c, h, m, E)
                }
                var CE = U4(qn),
                    kE = U4(kr);

                function N$(c, h, m) {
                    var E = ft(c),
                        C = E || Po(c) || tl(c);
                    if (h = Xe(h, 4), m == null) {
                        var F = c && c.constructor;
                        C ? m = E ? new F : [] : dn(c) ? m = Yi(F) ? Xc(Sd(c)) : {} : m = {}
                    }
                    return (C ? ds : ci)(c, function(z, J, ce) {
                        return h(m, z, J, ce)
                    }), m
                }

                function x$(c, h) {
                    return c == null ? !0 : E_(c, h)
                }

                function P$(c, h, m) {
                    return c == null ? c : T4(c, h, w_(m))
                }

                function R$(c, h, m, E) {
                    return E = typeof E == "function" ? E : n, c == null ? c : T4(c, h, w_(m), E)
                }

                function nl(c) {
                    return c == null ? [] : n_(c, qn(c))
                }

                function M$(c) {
                    return c == null ? [] : n_(c, kr(c))
                }

                function D$(c, h, m) {
                    return m === n && (m = h, h = n), m !== n && (m = vs(m), m = m === m ? m : 0), h !== n && (h = vs(h), h = h === h ? h : 0), qa(vs(c), h, m)
                }

                function $$(c, h, m) {
                    return h = zi(h), m === n ? (m = h, h = 0) : m = zi(m), c = vs(c), GP(c, h, m)
                }

                function L$(c, h, m) {
                    if (m && typeof m != "boolean" && _r(c, h, m) && (h = m = n), m === n && (typeof h == "boolean" ? (m = h, h = n) : typeof c == "boolean" && (m = c, c = n)), c === n && h === n ? (c = 0, h = 1) : (c = zi(c), h === n ? (h = c, c = 0) : h = zi(h)), c > h) {
                        var E = c;
                        c = h, h = E
                    }
                    if (m || c % 1 || h % 1) {
                        var C = Q5();
                        return ir(c + C * (h - c + mx("1e-" + ((C + "").length - 1))), h)
                    }
                    return y_(c, h)
                }
                var F$ = Jc(function(c, h, m) {
                    return h = h.toLowerCase(), c + (m ? IE(h) : h)
                });

                function IE(c) {
                    return W_(Lt(c).toLowerCase())
                }

                function NE(c) {
                    return c = Lt(c), c && c.replace(BN, kx).replace(ix, "")
                }

                function U$(c, h, m) {
                    c = Lt(c), h = Kr(h);
                    var E = c.length;
                    m = m === n ? E : qa(mt(m), 0, E);
                    var C = m;
                    return m -= h.length, m >= 0 && c.slice(m, C) == h
                }

                function B$(c) {
                    return c = Lt(c), c && bN.test(c) ? c.replace(a5, Ix) : c
                }

                function q$(c) {
                    return c = Lt(c), c && ON.test(c) ? c.replace(Bg, "\\$&") : c
                }
                var G$ = Jc(function(c, h, m) {
                        return c + (m ? "-" : "") + h.toLowerCase()
                    }),
                    V$ = Jc(function(c, h, m) {
                        return c + (m ? " " : "") + h.toLowerCase()
                    }),
                    j$ = R4("toLowerCase");

                function W$(c, h, m) {
                    c = Lt(c), h = mt(h);
                    var E = h ? Hc(c) : 0;
                    if (!h || E >= h) return c;
                    var C = (h - E) / 2;
                    return Bd(Cd(C), m) + c + Bd(Od(C), m)
                }

                function H$(c, h, m) {
                    c = Lt(c), h = mt(h);
                    var E = h ? Hc(c) : 0;
                    return h && E < h ? c + Bd(h - E, m) : c
                }

                function Y$(c, h, m) {
                    c = Lt(c), h = mt(h);
                    var E = h ? Hc(c) : 0;
                    return h && E < h ? Bd(h - E, m) + c : c
                }

                function z$(c, h, m) {
                    return m || h == null ? h = 0 : h && (h = +h), tP(Lt(c).replace(qg, ""), h || 0)
                }

                function K$(c, h, m) {
                    return (m ? _r(c, h, m) : h === n) ? h = 1 : h = mt(h), v_(Lt(c), h)
                }

                function Z$() {
                    var c = arguments,
                        h = Lt(c[0]);
                    return c.length < 3 ? h : h.replace(c[1], c[2])
                }
                var X$ = Jc(function(c, h, m) {
                    return c + (m ? "_" : "") + h.toLowerCase()
                });

                function Q$(c, h, m) {
                    return m && typeof m != "number" && _r(c, h, m) && (h = m = n), m = m === n ? Ce : m >>> 0, m ? (c = Lt(c), c && (typeof h == "string" || h != null && !G_(h)) && (h = Kr(h), !h && Wc(c)) ? xo(Ds(c), 0, m) : c.split(h, m)) : []
                }
                var J$ = Jc(function(c, h, m) {
                    return c + (m ? " " : "") + W_(h)
                });

                function eL(c, h, m) {
                    return c = Lt(c), m = m == null ? 0 : qa(mt(m), 0, c.length), h = Kr(h), c.slice(m, m + h.length) == h
                }

                function tL(c, h, m) {
                    var E = $.templateSettings;
                    m && _r(c, h, m) && (h = n), c = Lt(c), h = Qd({}, h, E, B4);
                    var C = Qd({}, h.imports, E.imports, B4),
                        F = qn(C),
                        z = n_(C, F),
                        J, ce, we = 0,
                        Ae = h.interpolate || hd,
                        Ie = "__p += '",
                        Re = s_((h.escape || hd).source + "|" + Ae.source + "|" + (Ae === c5 ? MN : hd).source + "|" + (h.evaluate || hd).source + "|$", "g"),
                        We = "//# sourceURL=" + (Ut.call(h, "sourceURL") ? (h.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++ux + "]") + `
`;
                    c.replace(Re, function(tt, Tt, Ct, Xr, yr, Qr) {
                        return Ct || (Ct = Xr), Ie += c.slice(we, Qr).replace(qN, Nx), Tt && (J = !0, Ie += `' +
__e(` + Tt + `) +
'`), yr && (ce = !0, Ie += `';
` + yr + `;
__p += '`), Ct && (Ie += `' +
((__t = (` + Ct + `)) == null ? '' : __t) +
'`), we = Qr + tt.length, tt
                    }), Ie += `';
`;
                    var et = Ut.call(h, "variable") && h.variable;
                    if (!et) Ie = `with (obj) {
` + Ie + `
}
`;
                    else if (PN.test(et)) throw new ut(a);
                    Ie = (ce ? Ie.replace(Hr, "") : Ie).replace(ct, "$1").replace(qu, "$1;"), Ie = "function(" + (et || "obj") + `) {
` + (et ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (J ? ", __e = _.escape" : "") + (ce ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Ie + `return __p
}`;
                    var _t = PE(function() {
                        return $t(F, We + "return " + Ie).apply(n, z)
                    });
                    if (_t.source = Ie, q_(_t)) throw _t;
                    return _t
                }

                function nL(c) {
                    return Lt(c).toLowerCase()
                }

                function rL(c) {
                    return Lt(c).toUpperCase()
                }

                function sL(c, h, m) {
                    if (c = Lt(c), c && (m || h === n)) return q5(c);
                    if (!c || !(h = Kr(h))) return c;
                    var E = Ds(c),
                        C = Ds(h),
                        F = G5(E, C),
                        z = V5(E, C) + 1;
                    return xo(E, F, z).join("")
                }

                function iL(c, h, m) {
                    if (c = Lt(c), c && (m || h === n)) return c.slice(0, W5(c) + 1);
                    if (!c || !(h = Kr(h))) return c;
                    var E = Ds(c),
                        C = V5(E, Ds(h)) + 1;
                    return xo(E, 0, C).join("")
                }

                function oL(c, h, m) {
                    if (c = Lt(c), c && (m || h === n)) return c.replace(qg, "");
                    if (!c || !(h = Kr(h))) return c;
                    var E = Ds(c),
                        C = G5(E, Ds(h));
                    return xo(E, C).join("")
                }

                function aL(c, h) {
                    var m = ee,
                        E = ae;
                    if (dn(h)) {
                        var C = "separator" in h ? h.separator : C;
                        m = "length" in h ? mt(h.length) : m, E = "omission" in h ? Kr(h.omission) : E
                    }
                    c = Lt(c);
                    var F = c.length;
                    if (Wc(c)) {
                        var z = Ds(c);
                        F = z.length
                    }
                    if (m >= F) return c;
                    var J = m - Hc(E);
                    if (J < 1) return E;
                    var ce = z ? xo(z, 0, J).join("") : c.slice(0, J);
                    if (C === n) return ce + E;
                    if (z && (J += ce.length - J), G_(C)) {
                        if (c.slice(J).search(C)) {
                            var we, Ae = ce;
                            for (C.global || (C = s_(C.source, Lt(l5.exec(C)) + "g")), C.lastIndex = 0; we = C.exec(Ae);) var Ie = we.index;
                            ce = ce.slice(0, Ie === n ? J : Ie)
                        }
                    } else if (c.indexOf(Kr(C), J) != J) {
                        var Re = ce.lastIndexOf(C);
                        Re > -1 && (ce = ce.slice(0, Re))
                    }
                    return ce + E
                }

                function cL(c) {
                    return c = Lt(c), c && vN.test(c) ? c.replace(o5, Lx) : c
                }
                var lL = Jc(function(c, h, m) {
                        return c + (m ? " " : "") + h.toUpperCase()
                    }),
                    W_ = R4("toUpperCase");

                function xE(c, h, m) {
                    return c = Lt(c), h = m ? n : h, h === n ? Px(c) ? Bx(c) : Sx(c) : c.match(h) || []
                }
                var PE = bt(function(c, h) {
                        try {
                            return Yr(c, n, h)
                        } catch (m) {
                            return q_(m) ? m : new ut(m)
                        }
                    }),
                    uL = Wi(function(c, h) {
                        return ds(h, function(m) {
                            m = ui(m), Vi(c, m, U_(c[m], c))
                        }), c
                    });

                function hL(c) {
                    var h = c == null ? 0 : c.length,
                        m = Xe();
                    return c = h ? cn(c, function(E) {
                        if (typeof E[1] != "function") throw new ps(o);
                        return [m(E[0]), E[1]]
                    }) : [], bt(function(E) {
                        for (var C = -1; ++C < h;) {
                            var F = c[C];
                            if (Yr(F[0], this, E)) return Yr(F[1], this, E)
                        }
                    })
                }

                function fL(c) {
                    return LP(gs(c, d))
                }

                function H_(c) {
                    return function() {
                        return c
                    }
                }

                function dL(c, h) {
                    return c == null || c !== c ? h : c
                }
                var pL = D4(),
                    mL = D4(!0);

                function Ir(c) {
                    return c
                }

                function Y_(c) {
                    return h4(typeof c == "function" ? c : gs(c, d))
                }

                function gL(c) {
                    return d4(gs(c, d))
                }

                function _L(c, h) {
                    return p4(c, gs(h, d))
                }
                var yL = bt(function(c, h) {
                        return function(m) {
                            return Zu(m, c, h)
                        }
                    }),
                    vL = bt(function(c, h) {
                        return function(m) {
                            return Zu(c, m, h)
                        }
                    });

                function z_(c, h, m) {
                    var E = qn(h),
                        C = Rd(h, E);
                    m == null && !(dn(h) && (C.length || !E.length)) && (m = h, h = c, c = this, C = Rd(h, qn(h)));
                    var F = !(dn(m) && "chain" in m) || !!m.chain,
                        z = Yi(c);
                    return ds(C, function(J) {
                        var ce = h[J];
                        c[J] = ce, z && (c.prototype[J] = function() {
                            var we = this.__chain__;
                            if (F || we) {
                                var Ae = c(this.__wrapped__),
                                    Ie = Ae.__actions__ = Or(this.__actions__);
                                return Ie.push({
                                    func: ce,
                                    args: arguments,
                                    thisArg: c
                                }), Ae.__chain__ = we, Ae
                            }
                            return ce.apply(c, Ao([this.value()], arguments))
                        })
                    }), c
                }

                function bL() {
                    return Yn._ === this && (Yn._ = Hx), this
                }

                function K_() {}

                function EL(c) {
                    return c = mt(c), bt(function(h) {
                        return m4(h, c)
                    })
                }
                var TL = O_(cn),
                    SL = O_($5),
                    wL = O_(Xg);

                function RE(c) {
                    return R_(c) ? Qg(ui(c)) : eR(c)
                }

                function AL(c) {
                    return function(h) {
                        return c == null ? n : Ga(c, h)
                    }
                }
                var OL = L4(),
                    CL = L4(!0);

                function Z_() {
                    return []
                }

                function X_() {
                    return !1
                }

                function kL() {
                    return {}
                }

                function IL() {
                    return ""
                }

                function NL() {
                    return !0
                }

                function xL(c, h) {
                    if (c = mt(c), c < 1 || c > _e) return [];
                    var m = Ce,
                        E = ir(c, Ce);
                    h = Xe(h), c -= Ce;
                    for (var C = t_(E, h); ++m < c;) h(m);
                    return C
                }

                function PL(c) {
                    return ft(c) ? cn(c, ui) : Zr(c) ? [c] : Or(J4(Lt(c)))
                }

                function RL(c) {
                    var h = ++jx;
                    return Lt(c) + h
                }
                var ML = Ud(function(c, h) {
                        return c + h
                    }, 0),
                    DL = C_("ceil"),
                    $L = Ud(function(c, h) {
                        return c / h
                    }, 1),
                    LL = C_("floor");

                function FL(c) {
                    return c && c.length ? Pd(c, Ir, f_) : n
                }

                function UL(c, h) {
                    return c && c.length ? Pd(c, Xe(h, 2), f_) : n
                }

                function BL(c) {
                    return U5(c, Ir)
                }

                function qL(c, h) {
                    return U5(c, Xe(h, 2))
                }

                function GL(c) {
                    return c && c.length ? Pd(c, Ir, g_) : n
                }

                function VL(c, h) {
                    return c && c.length ? Pd(c, Xe(h, 2), g_) : n
                }
                var jL = Ud(function(c, h) {
                        return c * h
                    }, 1),
                    WL = C_("round"),
                    HL = Ud(function(c, h) {
                        return c - h
                    }, 0);

                function YL(c) {
                    return c && c.length ? e_(c, Ir) : 0
                }

                function zL(c, h) {
                    return c && c.length ? e_(c, Xe(h, 2)) : 0
                }
                return $.after = gD, $.ary = uE, $.assign = r$, $.assignIn = wE, $.assignInWith = Qd, $.assignWith = s$, $.at = i$, $.before = hE, $.bind = U_, $.bindAll = uL, $.bindKey = fE, $.castArray = kD, $.chain = aE, $.chunk = LR, $.compact = FR, $.concat = UR, $.cond = hL, $.conforms = fL, $.constant = H_, $.countBy = YM, $.create = o$, $.curry = dE, $.curryRight = pE, $.debounce = mE, $.defaults = a$, $.defaultsDeep = c$, $.defer = _D, $.delay = yD, $.difference = BR, $.differenceBy = qR, $.differenceWith = GR, $.drop = VR, $.dropRight = jR, $.dropRightWhile = WR, $.dropWhile = HR, $.fill = YR, $.filter = KM, $.flatMap = QM, $.flatMapDeep = JM, $.flatMapDepth = eD, $.flatten = rE, $.flattenDeep = zR, $.flattenDepth = KR, $.flip = vD, $.flow = pL, $.flowRight = mL, $.fromPairs = ZR, $.functions = m$, $.functionsIn = g$, $.groupBy = tD, $.initial = QR, $.intersection = JR, $.intersectionBy = eM, $.intersectionWith = tM, $.invert = y$, $.invertBy = v$, $.invokeMap = rD, $.iteratee = Y_, $.keyBy = sD, $.keys = qn, $.keysIn = kr, $.map = Hd, $.mapKeys = E$, $.mapValues = T$, $.matches = gL, $.matchesProperty = _L, $.memoize = zd, $.merge = S$, $.mergeWith = AE, $.method = yL, $.methodOf = vL, $.mixin = z_, $.negate = Kd, $.nthArg = EL, $.omit = w$, $.omitBy = A$, $.once = bD, $.orderBy = iD, $.over = TL, $.overArgs = ED, $.overEvery = SL, $.overSome = wL, $.partial = B_, $.partialRight = gE, $.partition = oD, $.pick = O$, $.pickBy = OE, $.property = RE, $.propertyOf = AL, $.pull = iM, $.pullAll = iE, $.pullAllBy = oM, $.pullAllWith = aM, $.pullAt = cM, $.range = OL, $.rangeRight = CL, $.rearg = TD, $.reject = lD, $.remove = lM, $.rest = SD, $.reverse = L_, $.sampleSize = hD, $.set = k$, $.setWith = I$, $.shuffle = fD, $.slice = uM, $.sortBy = mD, $.sortedUniq = _M, $.sortedUniqBy = yM, $.split = Q$, $.spread = wD, $.tail = vM, $.take = bM, $.takeRight = EM, $.takeRightWhile = TM, $.takeWhile = SM, $.tap = FM, $.throttle = AD, $.thru = Wd, $.toArray = EE, $.toPairs = CE, $.toPairsIn = kE, $.toPath = PL, $.toPlainObject = SE, $.transform = N$, $.unary = OD, $.union = wM, $.unionBy = AM, $.unionWith = OM, $.uniq = CM, $.uniqBy = kM, $.uniqWith = IM, $.unset = x$, $.unzip = F_, $.unzipWith = oE, $.update = P$, $.updateWith = R$, $.values = nl, $.valuesIn = M$, $.without = NM, $.words = xE, $.wrap = CD, $.xor = xM, $.xorBy = PM, $.xorWith = RM, $.zip = MM, $.zipObject = DM, $.zipObjectDeep = $M, $.zipWith = LM, $.entries = CE, $.entriesIn = kE, $.extend = wE, $.extendWith = Qd, z_($, $), $.add = ML, $.attempt = PE, $.camelCase = F$, $.capitalize = IE, $.ceil = DL, $.clamp = D$, $.clone = ID, $.cloneDeep = xD, $.cloneDeepWith = PD, $.cloneWith = ND, $.conformsTo = RD, $.deburr = NE, $.defaultTo = dL, $.divide = $L, $.endsWith = U$, $.eq = Ls, $.escape = B$, $.escapeRegExp = q$, $.every = zM, $.find = ZM, $.findIndex = tE, $.findKey = l$, $.findLast = XM, $.findLastIndex = nE, $.findLastKey = u$, $.floor = LL, $.forEach = cE, $.forEachRight = lE, $.forIn = h$, $.forInRight = f$, $.forOwn = d$, $.forOwnRight = p$, $.get = V_, $.gt = MD, $.gte = DD, $.has = _$, $.hasIn = j_, $.head = sE, $.identity = Ir, $.includes = nD, $.indexOf = XR, $.inRange = $$, $.invoke = b$, $.isArguments = Wa, $.isArray = ft, $.isArrayBuffer = $D, $.isArrayLike = Cr, $.isArrayLikeObject = Sn, $.isBoolean = LD, $.isBuffer = Po, $.isDate = FD, $.isElement = UD, $.isEmpty = BD, $.isEqual = qD, $.isEqualWith = GD, $.isError = q_, $.isFinite = VD, $.isFunction = Yi, $.isInteger = _E, $.isLength = Zd, $.isMap = yE, $.isMatch = jD, $.isMatchWith = WD, $.isNaN = HD, $.isNative = YD, $.isNil = KD, $.isNull = zD, $.isNumber = vE, $.isObject = dn, $.isObjectLike = vn, $.isPlainObject = nh, $.isRegExp = G_, $.isSafeInteger = ZD, $.isSet = bE, $.isString = Xd, $.isSymbol = Zr, $.isTypedArray = tl, $.isUndefined = XD, $.isWeakMap = QD, $.isWeakSet = JD, $.join = nM, $.kebabCase = G$, $.last = ys, $.lastIndexOf = rM, $.lowerCase = V$, $.lowerFirst = j$, $.lt = e$, $.lte = t$, $.max = FL, $.maxBy = UL, $.mean = BL, $.meanBy = qL, $.min = GL, $.minBy = VL, $.stubArray = Z_, $.stubFalse = X_, $.stubObject = kL, $.stubString = IL, $.stubTrue = NL, $.multiply = jL, $.nth = sM, $.noConflict = bL, $.noop = K_, $.now = Yd, $.pad = W$, $.padEnd = H$, $.padStart = Y$, $.parseInt = z$, $.random = L$, $.reduce = aD, $.reduceRight = cD, $.repeat = K$, $.replace = Z$, $.result = C$, $.round = WL, $.runInContext = ie, $.sample = uD, $.size = dD, $.snakeCase = X$, $.some = pD, $.sortedIndex = hM, $.sortedIndexBy = fM, $.sortedIndexOf = dM, $.sortedLastIndex = pM, $.sortedLastIndexBy = mM, $.sortedLastIndexOf = gM, $.startCase = J$, $.startsWith = eL, $.subtract = HL, $.sum = YL, $.sumBy = zL, $.template = tL, $.times = xL, $.toFinite = zi, $.toInteger = mt, $.toLength = TE, $.toLower = nL, $.toNumber = vs, $.toSafeInteger = n$, $.toString = Lt, $.toUpper = rL, $.trim = sL, $.trimEnd = iL, $.trimStart = oL, $.truncate = aL, $.unescape = cL, $.uniqueId = RL, $.upperCase = lL, $.upperFirst = W_, $.each = cE, $.eachRight = lE, $.first = sE, z_($, function() {
                    var c = {};
                    return ci($, function(h, m) {
                        Ut.call($.prototype, m) || (c[m] = h)
                    }), c
                }(), {
                    chain: !1
                }), $.VERSION = r, ds(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(c) {
                    $[c].placeholder = $
                }), ds(["drop", "take"], function(c, h) {
                    St.prototype[c] = function(m) {
                        m = m === n ? 1 : $n(mt(m), 0);
                        var E = this.__filtered__ && !h ? new St(this) : this.clone();
                        return E.__filtered__ ? E.__takeCount__ = ir(m, E.__takeCount__) : E.__views__.push({
                            size: ir(m, Ce),
                            type: c + (E.__dir__ < 0 ? "Right" : "")
                        }), E
                    }, St.prototype[c + "Right"] = function(m) {
                        return this.reverse()[c](m).reverse()
                    }
                }), ds(["filter", "map", "takeWhile"], function(c, h) {
                    var m = h + 1,
                        E = m == ge || m == Q;
                    St.prototype[c] = function(C) {
                        var F = this.clone();
                        return F.__iteratees__.push({
                            iteratee: Xe(C, 3),
                            type: m
                        }), F.__filtered__ = F.__filtered__ || E, F
                    }
                }), ds(["head", "last"], function(c, h) {
                    var m = "take" + (h ? "Right" : "");
                    St.prototype[c] = function() {
                        return this[m](1).value()[0]
                    }
                }), ds(["initial", "tail"], function(c, h) {
                    var m = "drop" + (h ? "" : "Right");
                    St.prototype[c] = function() {
                        return this.__filtered__ ? new St(this) : this[m](1)
                    }
                }), St.prototype.compact = function() {
                    return this.filter(Ir)
                }, St.prototype.find = function(c) {
                    return this.filter(c).head()
                }, St.prototype.findLast = function(c) {
                    return this.reverse().find(c)
                }, St.prototype.invokeMap = bt(function(c, h) {
                    return typeof c == "function" ? new St(this) : this.map(function(m) {
                        return Zu(m, c, h)
                    })
                }), St.prototype.reject = function(c) {
                    return this.filter(Kd(Xe(c)))
                }, St.prototype.slice = function(c, h) {
                    c = mt(c);
                    var m = this;
                    return m.__filtered__ && (c > 0 || h < 0) ? new St(m) : (c < 0 ? m = m.takeRight(-c) : c && (m = m.drop(c)), h !== n && (h = mt(h), m = h < 0 ? m.dropRight(-h) : m.take(h - c)), m)
                }, St.prototype.takeRightWhile = function(c) {
                    return this.reverse().takeWhile(c).reverse()
                }, St.prototype.toArray = function() {
                    return this.take(Ce)
                }, ci(St.prototype, function(c, h) {
                    var m = /^(?:filter|find|map|reject)|While$/.test(h),
                        E = /^(?:head|last)$/.test(h),
                        C = $[E ? "take" + (h == "last" ? "Right" : "") : h],
                        F = E || /^find/.test(h);
                    C && ($.prototype[h] = function() {
                        var z = this.__wrapped__,
                            J = E ? [1] : arguments,
                            ce = z instanceof St,
                            we = J[0],
                            Ae = ce || ft(z),
                            Ie = function(Tt) {
                                var Ct = C.apply($, Ao([Tt], J));
                                return E && Re ? Ct[0] : Ct
                            };
                        Ae && m && typeof we == "function" && we.length != 1 && (ce = Ae = !1);
                        var Re = this.__chain__,
                            We = !!this.__actions__.length,
                            et = F && !Re,
                            _t = ce && !We;
                        if (!F && Ae) {
                            z = _t ? z : new St(this);
                            var tt = c.apply(z, J);
                            return tt.__actions__.push({
                                func: Wd,
                                args: [Ie],
                                thisArg: n
                            }), new ms(tt, Re)
                        }
                        return et && _t ? c.apply(this, J) : (tt = this.thru(Ie), et ? E ? tt.value()[0] : tt.value() : tt)
                    })
                }), ds(["pop", "push", "shift", "sort", "splice", "unshift"], function(c) {
                    var h = _d[c],
                        m = /^(?:push|sort|unshift)$/.test(c) ? "tap" : "thru",
                        E = /^(?:pop|shift)$/.test(c);
                    $.prototype[c] = function() {
                        var C = arguments;
                        if (E && !this.__chain__) {
                            var F = this.value();
                            return h.apply(ft(F) ? F : [], C)
                        }
                        return this[m](function(z) {
                            return h.apply(ft(z) ? z : [], C)
                        })
                    }
                }), ci(St.prototype, function(c, h) {
                    var m = $[h];
                    if (m) {
                        var E = m.name + "";
                        Ut.call(Zc, E) || (Zc[E] = []), Zc[E].push({
                            name: h,
                            func: m
                        })
                    }
                }), Zc[Fd(n, b).name] = [{
                    name: "wrapper",
                    func: n
                }], St.prototype.clone = cP, St.prototype.reverse = lP, St.prototype.value = uP, $.prototype.at = UM, $.prototype.chain = BM, $.prototype.commit = qM, $.prototype.next = GM, $.prototype.plant = jM, $.prototype.reverse = WM, $.prototype.toJSON = $.prototype.valueOf = $.prototype.value = HM, $.prototype.first = $.prototype.head, Vu && ($.prototype[Vu] = VM), $
            },
            Yc = qx();
        La ? ((La.exports = Yc)._ = Yc, Yg._ = Yc) : Yn._ = Yc
    }).call(_n)
})(m1, m1.exports);
m1.exports;
var Za, lp, Ih = typeof Map == "function" ? new Map : (Za = [], lp = [], {
        has: function(t) {
            return Za.indexOf(t) > -1
        },
        get: function(t) {
            return lp[Za.indexOf(t)]
        },
        set: function(t, e) {
            Za.indexOf(t) === -1 && (Za.push(t), lp.push(e))
        },
        delete: function(t) {
            var e = Za.indexOf(t);
            e > -1 && (Za.splice(e, 1), lp.splice(e, 1))
        }
    }),
    EA = function(t) {
        return new Event(t, {
            bubbles: !0
        })
    };
try {
    new Event("test")
} catch {
    EA = function(e) {
        var n = document.createEvent("Event");
        return n.initEvent(e, !0, !1), n
    }
}

function LJ(t) {
    var e = Ih.get(t);
    e && e.destroy()
}

function FJ(t) {
    var e = Ih.get(t);
    e && e.update()
}
var up = null;
typeof window > "u" || typeof window.getComputedStyle != "function" ? ((up = function(t) {
    return t
}).destroy = function(t) {
    return t
}, up.update = function(t) {
    return t
}) : ((up = function(t, e) {
    return t && Array.prototype.forEach.call(t.length ? t : [t], function(n) {
        return function(r) {
            if (r && r.nodeName && r.nodeName === "TEXTAREA" && !Ih.has(r)) {
                var s, i = null,
                    o = null,
                    a = null,
                    l = function() {
                        r.clientWidth !== o && p()
                    },
                    u = (function(_) {
                        window.removeEventListener("resize", l, !1), r.removeEventListener("input", p, !1), r.removeEventListener("keyup", p, !1), r.removeEventListener("autosize:destroy", u, !1), r.removeEventListener("autosize:update", p, !1), Object.keys(_).forEach(function(v) {
                            r.style[v] = _[v]
                        }), Ih.delete(r)
                    }).bind(r, {
                        height: r.style.height,
                        resize: r.style.resize,
                        overflowY: r.style.overflowY,
                        overflowX: r.style.overflowX,
                        wordWrap: r.style.wordWrap
                    });
                r.addEventListener("autosize:destroy", u, !1), "onpropertychange" in r && "oninput" in r && r.addEventListener("keyup", p, !1), window.addEventListener("resize", l, !1), r.addEventListener("input", p, !1), r.addEventListener("autosize:update", p, !1), r.style.overflowX = "hidden", r.style.wordWrap = "break-word", Ih.set(r, {
                    destroy: u,
                    update: p
                }), (s = window.getComputedStyle(r, null)).resize === "vertical" ? r.style.resize = "none" : s.resize === "both" && (r.style.resize = "horizontal"), i = s.boxSizing === "content-box" ? -(parseFloat(s.paddingTop) + parseFloat(s.paddingBottom)) : parseFloat(s.borderTopWidth) + parseFloat(s.borderBottomWidth), isNaN(i) && (i = 0), p()
            }

            function f(_) {
                var v = r.style.width;
                r.style.width = "0px", r.style.width = v, r.style.overflowY = _
            }

            function d() {
                if (r.scrollHeight !== 0) {
                    var _ = function(y) {
                            for (var g = []; y && y.parentNode && y.parentNode instanceof Element;) y.parentNode.scrollTop && g.push({
                                node: y.parentNode,
                                scrollTop: y.parentNode.scrollTop
                            }), y = y.parentNode;
                            return g
                        }(r),
                        v = document.documentElement && document.documentElement.scrollTop;
                    r.style.height = "", r.style.height = r.scrollHeight + i + "px", o = r.clientWidth, _.forEach(function(y) {
                        y.node.scrollTop = y.scrollTop
                    }), v && (document.documentElement.scrollTop = v)
                }
            }

            function p() {
                d();
                var _ = Math.round(parseFloat(r.style.height)),
                    v = window.getComputedStyle(r, null),
                    y = v.boxSizing === "content-box" ? Math.round(parseFloat(v.height)) : r.offsetHeight;
                if (y < _ ? v.overflowY === "hidden" && (f("scroll"), d(), y = v.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(r, null).height)) : r.offsetHeight) : v.overflowY !== "hidden" && (f("hidden"), d(), y = v.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(r, null).height)) : r.offsetHeight), a !== y) {
                    a = y;
                    var g = EA("autosize:resized");
                    try {
                        r.dispatchEvent(g)
                    } catch {}
                }
            }
        }(n)
    }), t
}).destroy = function(t) {
    return t && Array.prototype.forEach.call(t.length ? t : [t], LJ), t
}, up.update = function(t) {
    return t && Array.prototype.forEach.call(t.length ? t : [t], FJ), t
});
var hp = function(t) {
        return t && t.Math == Math && t
    },
    jr = hp(typeof globalThis == "object" && globalThis) || hp(typeof window == "object" && window) || hp(typeof self == "object" && self) || hp(typeof _n == "object" && _n) || function() {
        return this
    }() || _n || Function("return this")(),
    d3 = {},
    hs = function(t) {
        try {
            return !!t()
        } catch {
            return !0
        }
    },
    UJ = hs,
    ka = !UJ(function() {
        return Object.defineProperty({}, 1, {
            get: function() {
                return 7
            }
        })[1] != 7
    }),
    BJ = hs,
    p3 = !BJ(function() {
        var t = (function() {}).bind();
        return typeof t != "function" || t.hasOwnProperty("prototype")
    }),
    qJ = p3,
    fp = Function.prototype.call,
    Ia = qJ ? fp.bind(fp) : function() {
        return fp.apply(fp, arguments)
    },
    TA = {},
    SA = {}.propertyIsEnumerable,
    wA = Object.getOwnPropertyDescriptor,
    GJ = wA && !SA.call({
        1: 2
    }, 1);
TA.f = GJ ? function(e) {
    var n = wA(this, e);
    return !!n && n.enumerable
} : SA;
var AA = function(t, e) {
        return {
            enumerable: !(t & 1),
            configurable: !(t & 2),
            writable: !(t & 4),
            value: e
        }
    },
    OA = p3,
    CA = Function.prototype,
    $0 = CA.call,
    VJ = OA && CA.bind.bind($0, $0),
    pr = OA ? VJ : function(t) {
        return function() {
            return $0.apply(t, arguments)
        }
    },
    kA = pr,
    jJ = kA({}.toString),
    WJ = kA("".slice),
    Bf = function(t) {
        return WJ(jJ(t), 8, -1)
    },
    HJ = pr,
    YJ = hs,
    zJ = Bf,
    Ty = Object,
    KJ = HJ("".split),
    ZJ = YJ(function() {
        return !Ty("z").propertyIsEnumerable(0)
    }) ? function(t) {
        return zJ(t) == "String" ? KJ(t, "") : Ty(t)
    } : Ty,
    eg = function(t) {
        return t == null
    },
    XJ = eg,
    QJ = TypeError,
    qf = function(t) {
        if (XJ(t)) throw QJ("Can't call method on " + t);
        return t
    },
    JJ = ZJ,
    eee = qf,
    tg = function(t) {
        return JJ(eee(t))
    },
    L0 = typeof document == "object" && document.all,
    tee = typeof L0 > "u" && L0 !== void 0,
    IA = {
        all: L0,
        IS_HTMLDDA: tee
    },
    NA = IA,
    nee = NA.all,
    Wr = NA.IS_HTMLDDA ? function(t) {
        return typeof t == "function" || t === nee
    } : function(t) {
        return typeof t == "function"
    },
    ES = Wr,
    xA = IA,
    ree = xA.all,
    Iu = xA.IS_HTMLDDA ? function(t) {
        return typeof t == "object" ? t !== null : ES(t) || t === ree
    } : function(t) {
        return typeof t == "object" ? t !== null : ES(t)
    },
    Sy = jr,
    see = Wr,
    iee = function(t) {
        return see(t) ? t : void 0
    },
    m3 = function(t, e) {
        return arguments.length < 2 ? iee(Sy[t]) : Sy[t] && Sy[t][e]
    },
    oee = pr,
    PA = oee({}.isPrototypeOf),
    aee = typeof navigator < "u" && String(navigator.userAgent) || "",
    RA = jr,
    wy = aee,
    TS = RA.process,
    SS = RA.Deno,
    wS = TS && TS.versions || SS && SS.version,
    AS = wS && wS.v8,
    qs, g1;
AS && (qs = AS.split("."), g1 = qs[0] > 0 && qs[0] < 4 ? 1 : +(qs[0] + qs[1]));
!g1 && wy && (qs = wy.match(/Edge\/(\d+)/), (!qs || qs[1] >= 74) && (qs = wy.match(/Chrome\/(\d+)/), qs && (g1 = +qs[1])));
var cee = g1,
    OS = cee,
    lee = hs,
    uee = jr,
    hee = uee.String,
    MA = !!Object.getOwnPropertySymbols && !lee(function() {
        var t = Symbol();
        return !hee(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && OS && OS < 41
    }),
    fee = MA,
    DA = fee && !Symbol.sham && typeof Symbol.iterator == "symbol",
    dee = m3,
    pee = Wr,
    mee = PA,
    gee = DA,
    _ee = Object,
    $A = gee ? function(t) {
        return typeof t == "symbol"
    } : function(t) {
        var e = dee("Symbol");
        return pee(e) && mee(e.prototype, _ee(t))
    },
    yee = String,
    vee = function(t) {
        try {
            return yee(t)
        } catch {
            return "Object"
        }
    },
    bee = Wr,
    Eee = vee,
    Tee = TypeError,
    See = function(t) {
        if (bee(t)) return t;
        throw Tee(Eee(t) + " is not a function")
    },
    wee = See,
    Aee = eg,
    g3 = function(t, e) {
        var n = t[e];
        return Aee(n) ? void 0 : wee(n)
    },
    Ay = Ia,
    Oy = Wr,
    Cy = Iu,
    Oee = TypeError,
    Cee = function(t, e) {
        var n, r;
        if (e === "string" && Oy(n = t.toString) && !Cy(r = Ay(n, t)) || Oy(n = t.valueOf) && !Cy(r = Ay(n, t)) || e !== "string" && Oy(n = t.toString) && !Cy(r = Ay(n, t))) return r;
        throw Oee("Can't convert object to primitive value")
    },
    LA = {
        exports: {}
    },
    CS = jr,
    kee = Object.defineProperty,
    _3 = function(t, e) {
        try {
            kee(CS, t, {
                value: e,
                configurable: !0,
                writable: !0
            })
        } catch {
            CS[t] = e
        }
        return e
    },
    Iee = jr,
    Nee = _3,
    kS = "__core-js_shared__",
    xee = Iee[kS] || Nee(kS, {}),
    y3 = xee,
    IS = y3;
(LA.exports = function(t, e) {
    return IS[t] || (IS[t] = e !== void 0 ? e : {})
})("versions", []).push({
    version: "3.30.2",
    mode: "global",
    copyright: " 2014-2023 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.30.2/LICENSE",
    source: "https://github.com/zloirock/core-js"
});
var v3 = LA.exports,
    Pee = qf,
    Ree = Object,
    FA = function(t) {
        return Ree(Pee(t))
    },
    Mee = pr,
    Dee = FA,
    $ee = Mee({}.hasOwnProperty),
    Na = Object.hasOwn || function(e, n) {
        return $ee(Dee(e), n)
    },
    Lee = pr,
    Fee = 0,
    Uee = Math.random(),
    Bee = Lee(1 .toString),
    UA = function(t) {
        return "Symbol(" + (t === void 0 ? "" : t) + ")_" + Bee(++Fee + Uee, 36)
    },
    qee = jr,
    Gee = v3,
    NS = Na,
    Vee = UA,
    jee = MA,
    Wee = DA,
    pl = qee.Symbol,
    ky = Gee("wks"),
    Hee = Wee ? pl.for || pl : pl && pl.withoutSetter || Vee,
    Dc = function(t) {
        return NS(ky, t) || (ky[t] = jee && NS(pl, t) ? pl[t] : Hee("Symbol." + t)), ky[t]
    },
    Yee = Ia,
    xS = Iu,
    PS = $A,
    zee = g3,
    Kee = Cee,
    Zee = Dc,
    Xee = TypeError,
    Qee = Zee("toPrimitive"),
    Jee = function(t, e) {
        if (!xS(t) || PS(t)) return t;
        var n = zee(t, Qee),
            r;
        if (n) {
            if (e === void 0 && (e = "default"), r = Yee(n, t, e), !xS(r) || PS(r)) return r;
            throw Xee("Can't convert object to primitive value")
        }
        return e === void 0 && (e = "number"), Kee(t, e)
    },
    ete = Jee,
    tte = $A,
    BA = function(t) {
        var e = ete(t, "string");
        return tte(e) ? e : e + ""
    },
    nte = jr,
    RS = Iu,
    F0 = nte.document,
    rte = RS(F0) && RS(F0.createElement),
    qA = function(t) {
        return rte ? F0.createElement(t) : {}
    },
    ste = ka,
    ite = hs,
    ote = qA,
    GA = !ste && !ite(function() {
        return Object.defineProperty(ote("div"), "a", {
            get: function() {
                return 7
            }
        }).a != 7
    }),
    ate = ka,
    cte = Ia,
    lte = TA,
    ute = AA,
    hte = tg,
    fte = BA,
    dte = Na,
    pte = GA,
    MS = Object.getOwnPropertyDescriptor;
d3.f = ate ? MS : function(e, n) {
    if (e = hte(e), n = fte(n), pte) try {
        return MS(e, n)
    } catch {}
    if (dte(e, n)) return ute(!cte(lte.f, e, n), e[n])
};
var Gf = {},
    mte = ka,
    gte = hs,
    VA = mte && gte(function() {
        return Object.defineProperty(function() {}, "prototype", {
            value: 42,
            writable: !1
        }).prototype != 42
    }),
    _te = Iu,
    yte = String,
    vte = TypeError,
    $c = function(t) {
        if (_te(t)) return t;
        throw vte(yte(t) + " is not an object")
    },
    bte = ka,
    Ete = GA,
    Tte = VA,
    dp = $c,
    DS = BA,
    Ste = TypeError,
    Iy = Object.defineProperty,
    wte = Object.getOwnPropertyDescriptor,
    Ny = "enumerable",
    xy = "configurable",
    Py = "writable";
Gf.f = bte ? Tte ? function(e, n, r) {
    if (dp(e), n = DS(n), dp(r), typeof e == "function" && n === "prototype" && "value" in r && Py in r && !r[Py]) {
        var s = wte(e, n);
        s && s[Py] && (e[n] = r.value, r = {
            configurable: xy in r ? r[xy] : s[xy],
            enumerable: Ny in r ? r[Ny] : s[Ny],
            writable: !1
        })
    }
    return Iy(e, n, r)
} : Iy : function(e, n, r) {
    if (dp(e), n = DS(n), dp(r), Ete) try {
        return Iy(e, n, r)
    } catch {}
    if ("get" in r || "set" in r) throw Ste("Accessors not supported");
    return "value" in r && (e[n] = r.value), e
};
var Ate = ka,
    Ote = Gf,
    Cte = AA,
    b3 = Ate ? function(t, e, n) {
        return Ote.f(t, e, Cte(1, n))
    } : function(t, e, n) {
        return t[e] = n, t
    },
    jA = {
        exports: {}
    },
    U0 = ka,
    kte = Na,
    WA = Function.prototype,
    Ite = U0 && Object.getOwnPropertyDescriptor,
    E3 = kte(WA, "name"),
    Nte = E3 && (function() {}).name === "something",
    xte = E3 && (!U0 || U0 && Ite(WA, "name").configurable),
    Pte = {
        EXISTS: E3,
        PROPER: Nte,
        CONFIGURABLE: xte
    },
    Rte = pr,
    Mte = Wr,
    B0 = y3,
    Dte = Rte(Function.toString);
Mte(B0.inspectSource) || (B0.inspectSource = function(t) {
    return Dte(t)
});
var $te = B0.inspectSource,
    Lte = jr,
    Fte = Wr,
    $S = Lte.WeakMap,
    Ute = Fte($S) && /native code/.test(String($S)),
    Bte = v3,
    qte = UA,
    LS = Bte("keys"),
    HA = function(t) {
        return LS[t] || (LS[t] = qte(t))
    },
    T3 = {},
    Gte = Ute,
    YA = jr,
    Vte = Iu,
    jte = b3,
    Ry = Na,
    My = y3,
    Wte = HA,
    Hte = T3,
    FS = "Object already initialized",
    q0 = YA.TypeError,
    Yte = YA.WeakMap,
    _1, Xh, y1, zte = function(t) {
        return y1(t) ? Xh(t) : _1(t, {})
    },
    Kte = function(t) {
        return function(e) {
            var n;
            if (!Vte(e) || (n = Xh(e)).type !== t) throw q0("Incompatible receiver, " + t + " required");
            return n
        }
    };
if (Gte || My.state) {
    var di = My.state || (My.state = new Yte);
    di.get = di.get, di.has = di.has, di.set = di.set, _1 = function(t, e) {
        if (di.has(t)) throw q0(FS);
        return e.facade = t, di.set(t, e), e
    }, Xh = function(t) {
        return di.get(t) || {}
    }, y1 = function(t) {
        return di.has(t)
    }
} else {
    var il = Wte("state");
    Hte[il] = !0, _1 = function(t, e) {
        if (Ry(t, il)) throw q0(FS);
        return e.facade = t, jte(t, il, e), e
    }, Xh = function(t) {
        return Ry(t, il) ? t[il] : {}
    }, y1 = function(t) {
        return Ry(t, il)
    }
}
var zA = {
        set: _1,
        get: Xh,
        has: y1,
        enforce: zte,
        getterFor: Kte
    },
    S3 = pr,
    Zte = hs,
    Xte = Wr,
    pp = Na,
    G0 = ka,
    Qte = Pte.CONFIGURABLE,
    Jte = $te,
    KA = zA,
    ene = KA.enforce,
    tne = KA.get,
    US = String,
    Up = Object.defineProperty,
    nne = S3("".slice),
    rne = S3("".replace),
    sne = S3([].join),
    ine = G0 && !Zte(function() {
        return Up(function() {}, "length", {
            value: 8
        }).length !== 8
    }),
    one = String(String).split("String"),
    ane = jA.exports = function(t, e, n) {
        nne(US(e), 0, 7) === "Symbol(" && (e = "[" + rne(US(e), /^Symbol\(([^)]*)\)/, "$1") + "]"), n && n.getter && (e = "get " + e), n && n.setter && (e = "set " + e), (!pp(t, "name") || Qte && t.name !== e) && (G0 ? Up(t, "name", {
            value: e,
            configurable: !0
        }) : t.name = e), ine && n && pp(n, "arity") && t.length !== n.arity && Up(t, "length", {
            value: n.arity
        });
        try {
            n && pp(n, "constructor") && n.constructor ? G0 && Up(t, "prototype", {
                writable: !1
            }) : t.prototype && (t.prototype = void 0)
        } catch {}
        var r = ene(t);
        return pp(r, "source") || (r.source = sne(one, typeof e == "string" ? e : "")), t
    };
Function.prototype.toString = ane(function() {
    return Xte(this) && tne(this).source || Jte(this)
}, "toString");
var cne = jA.exports,
    lne = Wr,
    une = Gf,
    hne = cne,
    fne = _3,
    ZA = function(t, e, n, r) {
        r || (r = {});
        var s = r.enumerable,
            i = r.name !== void 0 ? r.name : e;
        if (lne(n) && hne(n, i, r), r.global) s ? t[e] = n : fne(e, n);
        else {
            try {
                r.unsafe ? t[e] && (s = !0) : delete t[e]
            } catch {}
            s ? t[e] = n : une.f(t, e, {
                value: n,
                enumerable: !1,
                configurable: !r.nonConfigurable,
                writable: !r.nonWritable
            })
        }
        return t
    },
    XA = {},
    dne = Math.ceil,
    pne = Math.floor,
    mne = Math.trunc || function(e) {
        var n = +e;
        return (n > 0 ? pne : dne)(n)
    },
    gne = mne,
    ng = function(t) {
        var e = +t;
        return e !== e || e === 0 ? 0 : gne(e)
    },
    _ne = ng,
    yne = Math.max,
    vne = Math.min,
    bne = function(t, e) {
        var n = _ne(t);
        return n < 0 ? yne(n + e, 0) : vne(n, e)
    },
    Ene = ng,
    Tne = Math.min,
    QA = function(t) {
        return t > 0 ? Tne(Ene(t), 9007199254740991) : 0
    },
    Sne = QA,
    wne = function(t) {
        return Sne(t.length)
    },
    Ane = tg,
    One = bne,
    Cne = wne,
    BS = function(t) {
        return function(e, n, r) {
            var s = Ane(e),
                i = Cne(s),
                o = One(r, i),
                a;
            if (t && n != n) {
                for (; i > o;)
                    if (a = s[o++], a != a) return !0
            } else
                for (; i > o; o++)
                    if ((t || o in s) && s[o] === n) return t || o || 0;
            return !t && -1
        }
    },
    kne = {
        includes: BS(!0),
        indexOf: BS(!1)
    },
    Ine = pr,
    Dy = Na,
    Nne = tg,
    xne = kne.indexOf,
    Pne = T3,
    qS = Ine([].push),
    JA = function(t, e) {
        var n = Nne(t),
            r = 0,
            s = [],
            i;
        for (i in n) !Dy(Pne, i) && Dy(n, i) && qS(s, i);
        for (; e.length > r;) Dy(n, i = e[r++]) && (~xne(s, i) || qS(s, i));
        return s
    },
    w3 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
    Rne = JA,
    Mne = w3,
    Dne = Mne.concat("length", "prototype");
XA.f = Object.getOwnPropertyNames || function(e) {
    return Rne(e, Dne)
};
var eO = {};
eO.f = Object.getOwnPropertySymbols;
var $ne = m3,
    Lne = pr,
    Fne = XA,
    Une = eO,
    Bne = $c,
    qne = Lne([].concat),
    Gne = $ne("Reflect", "ownKeys") || function(e) {
        var n = Fne.f(Bne(e)),
            r = Une.f;
        return r ? qne(n, r(e)) : n
    },
    GS = Na,
    Vne = Gne,
    jne = d3,
    Wne = Gf,
    Hne = function(t, e, n) {
        for (var r = Vne(e), s = Wne.f, i = jne.f, o = 0; o < r.length; o++) {
            var a = r[o];
            !GS(t, a) && !(n && GS(n, a)) && s(t, a, i(e, a))
        }
    },
    Yne = hs,
    zne = Wr,
    Kne = /#|\.prototype\./,
    Vf = function(t, e) {
        var n = Xne[Zne(t)];
        return n == Jne ? !0 : n == Qne ? !1 : zne(e) ? Yne(e) : !!e
    },
    Zne = Vf.normalize = function(t) {
        return String(t).replace(Kne, ".").toLowerCase()
    },
    Xne = Vf.data = {},
    Qne = Vf.NATIVE = "N",
    Jne = Vf.POLYFILL = "P",
    ere = Vf,
    $y = jr,
    tre = d3.f,
    nre = b3,
    rre = ZA,
    sre = _3,
    ire = Hne,
    ore = ere,
    tO = function(t, e) {
        var n = t.target,
            r = t.global,
            s = t.stat,
            i, o, a, l, u, f;
        if (r ? o = $y : s ? o = $y[n] || sre(n, {}) : o = ($y[n] || {}).prototype, o)
            for (a in e) {
                if (u = e[a], t.dontCallGetSet ? (f = tre(o, a), l = f && f.value) : l = o[a], i = ore(r ? a : n + (s ? "." : "#") + a, t.forced), !i && l !== void 0) {
                    if (typeof u == typeof l) continue;
                    ire(u, l)
                }(t.sham || l && l.sham) && nre(u, "sham", !0), rre(o, a, u, t)
            }
    },
    are = Iu,
    cre = Bf,
    lre = Dc,
    ure = lre("match"),
    hre = function(t) {
        var e;
        return are(t) && ((e = t[ure]) !== void 0 ? !!e : cre(t) == "RegExp")
    },
    fre = Dc,
    dre = fre("toStringTag"),
    nO = {};
nO[dre] = "z";
var pre = String(nO) === "[object z]",
    mre = pre,
    gre = Wr,
    Bp = Bf,
    _re = Dc,
    yre = _re("toStringTag"),
    vre = Object,
    bre = Bp(function() {
        return arguments
    }()) == "Arguments",
    Ere = function(t, e) {
        try {
            return t[e]
        } catch {}
    },
    Tre = mre ? Bp : function(t) {
        var e, n, r;
        return t === void 0 ? "Undefined" : t === null ? "Null" : typeof(n = Ere(e = vre(t), yre)) == "string" ? n : bre ? Bp(e) : (r = Bp(e)) == "Object" && gre(e.callee) ? "Arguments" : r
    },
    Sre = Tre,
    wre = String,
    rg = function(t) {
        if (Sre(t) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
        return wre(t)
    },
    Are = $c,
    rO = function() {
        var t = Are(this),
            e = "";
        return t.hasIndices && (e += "d"), t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.unicodeSets && (e += "v"), t.sticky && (e += "y"), e
    },
    Ore = Ia,
    Cre = Na,
    kre = PA,
    Ire = rO,
    VS = RegExp.prototype,
    Nre = function(t) {
        var e = t.flags;
        return e === void 0 && !("flags" in VS) && !Cre(t, "flags") && kre(VS, t) ? Ore(Ire, t) : e
    },
    A3 = pr,
    xre = FA,
    Pre = Math.floor,
    Ly = A3("".charAt),
    Rre = A3("".replace),
    Fy = A3("".slice),
    Mre = /\$([$&'`]|\d{1,2}|<[^>]*>)/g,
    Dre = /\$([$&'`]|\d{1,2})/g,
    sO = function(t, e, n, r, s, i) {
        var o = n + t.length,
            a = r.length,
            l = Dre;
        return s !== void 0 && (s = xre(s), l = Mre), Rre(i, l, function(u, f) {
            var d;
            switch (Ly(f, 0)) {
                case "$":
                    return "$";
                case "&":
                    return t;
                case "`":
                    return Fy(e, 0, n);
                case "'":
                    return Fy(e, o);
                case "<":
                    d = s[Fy(f, 1, -1)];
                    break;
                default:
                    var p = +f;
                    if (p === 0) return u;
                    if (p > a) {
                        var _ = Pre(p / 10);
                        return _ === 0 ? u : _ <= a ? r[_ - 1] === void 0 ? Ly(f, 1) : r[_ - 1] + Ly(f, 1) : u
                    }
                    d = r[p - 1]
            }
            return d === void 0 ? "" : d
        })
    },
    $re = tO,
    Lre = Ia,
    O3 = pr,
    jS = qf,
    Fre = Wr,
    Ure = eg,
    Bre = hre,
    oh = rg,
    qre = g3,
    Gre = Nre,
    Vre = sO,
    jre = Dc,
    Wre = jre("replace"),
    Hre = TypeError,
    iO = O3("".indexOf);
O3("".replace);
var WS = O3("".slice),
    Yre = Math.max,
    HS = function(t, e, n) {
        return n > t.length ? -1 : e === "" ? n : iO(t, e, n)
    };
$re({
    target: "String",
    proto: !0
}, {
    replaceAll: function(e, n) {
        var r = jS(this),
            s, i, o, a, l, u, f, d, p, _ = 0,
            v = 0,
            y = "";
        if (!Ure(e)) {
            if (s = Bre(e), s && (i = oh(jS(Gre(e))), !~iO(i, "g"))) throw Hre("`.replaceAll` does not allow non-global regexes");
            if (o = qre(e, Wre), o) return Lre(o, e, r, n)
        }
        for (a = oh(r), l = oh(e), u = Fre(n), u || (n = oh(n)), f = l.length, d = Yre(1, f), _ = HS(a, l, 0); _ !== -1;) p = u ? oh(n(l, _, a)) : Vre(l, a, _, [], void 0, n), y += WS(a, v, _) + p, v = _ + f, _ = HS(a, l, _ + d);
        return v < a.length && (y += WS(a, v)), y
    }
});
var C3 = hs,
    zre = jr,
    k3 = zre.RegExp,
    I3 = C3(function() {
        var t = k3("a", "y");
        return t.lastIndex = 2, t.exec("abcd") != null
    }),
    Kre = I3 || C3(function() {
        return !k3("a", "y").sticky
    }),
    Zre = I3 || C3(function() {
        var t = k3("^r", "gy");
        return t.lastIndex = 2, t.exec("str") != null
    }),
    Xre = {
        BROKEN_CARET: Zre,
        MISSED_STICKY: Kre,
        UNSUPPORTED_Y: I3
    },
    oO = {},
    Qre = JA,
    Jre = w3,
    ese = Object.keys || function(e) {
        return Qre(e, Jre)
    },
    tse = ka,
    nse = VA,
    rse = Gf,
    sse = $c,
    ise = tg,
    ose = ese;
oO.f = tse && !nse ? Object.defineProperties : function(e, n) {
    sse(e);
    for (var r = ise(n), s = ose(n), i = s.length, o = 0, a; i > o;) rse.f(e, a = s[o++], r[a]);
    return e
};
var ase = m3,
    cse = ase("document", "documentElement"),
    lse = $c,
    use = oO,
    YS = w3,
    hse = T3,
    fse = cse,
    dse = qA,
    pse = HA,
    zS = ">",
    KS = "<",
    V0 = "prototype",
    j0 = "script",
    aO = pse("IE_PROTO"),
    Uy = function() {},
    cO = function(t) {
        return KS + j0 + zS + t + KS + "/" + j0 + zS
    },
    ZS = function(t) {
        t.write(cO("")), t.close();
        var e = t.parentWindow.Object;
        return t = null, e
    },
    mse = function() {
        var t = dse("iframe"),
            e = "java" + j0 + ":",
            n;
        return t.style.display = "none", fse.appendChild(t), t.src = String(e), n = t.contentWindow.document, n.open(), n.write(cO("document.F=Object")), n.close(), n.F
    },
    mp, qp = function() {
        try {
            mp = new ActiveXObject("htmlfile")
        } catch {}
        qp = typeof document < "u" ? document.domain && mp ? ZS(mp) : mse() : ZS(mp);
        for (var t = YS.length; t--;) delete qp[V0][YS[t]];
        return qp()
    };
hse[aO] = !0;
var gse = Object.create || function(e, n) {
        var r;
        return e !== null ? (Uy[V0] = lse(e), r = new Uy, Uy[V0] = null, r[aO] = e) : r = qp(), n === void 0 ? r : use.f(r, n)
    },
    _se = hs,
    yse = jr,
    vse = yse.RegExp,
    bse = _se(function() {
        var t = vse(".", "s");
        return !(t.dotAll && t.exec(`
`) && t.flags === "s")
    }),
    Ese = hs,
    Tse = jr,
    Sse = Tse.RegExp,
    wse = Ese(function() {
        var t = Sse("(?<a>b)", "g");
        return t.exec("b").groups.a !== "b" || "b".replace(t, "$<a>c") !== "bc"
    }),
    ml = Ia,
    sg = pr,
    Ase = rg,
    Ose = rO,
    Cse = Xre,
    kse = v3,
    Ise = gse,
    Nse = zA.get,
    xse = bse,
    Pse = wse,
    Rse = kse("native-string-replace", String.prototype.replace),
    v1 = RegExp.prototype.exec,
    W0 = v1,
    Mse = sg("".charAt),
    Dse = sg("".indexOf),
    $se = sg("".replace),
    By = sg("".slice),
    H0 = function() {
        var t = /a/,
            e = /b*/g;
        return ml(v1, t, "a"), ml(v1, e, "a"), t.lastIndex !== 0 || e.lastIndex !== 0
    }(),
    lO = Cse.BROKEN_CARET,
    Y0 = /()??/.exec("")[1] !== void 0,
    Lse = H0 || Y0 || lO || xse || Pse;
Lse && (W0 = function(e) {
    var n = this,
        r = Nse(n),
        s = Ase(e),
        i = r.raw,
        o, a, l, u, f, d, p;
    if (i) return i.lastIndex = n.lastIndex, o = ml(W0, i, s), n.lastIndex = i.lastIndex, o;
    var _ = r.groups,
        v = lO && n.sticky,
        y = ml(Ose, n),
        g = n.source,
        b = 0,
        O = s;
    if (v && (y = $se(y, "y", ""), Dse(y, "g") === -1 && (y += "g"), O = By(s, n.lastIndex), n.lastIndex > 0 && (!n.multiline || n.multiline && Mse(s, n.lastIndex - 1) !== `
`) && (g = "(?: " + g + ")", O = " " + O, b++), a = new RegExp("^(?:" + g + ")", y)), Y0 && (a = new RegExp("^" + g + "$(?!\\s)", y)), H0 && (l = n.lastIndex), u = ml(v1, v ? a : n, O), v ? u ? (u.input = By(u.input, b), u[0] = By(u[0], b), u.index = n.lastIndex, n.lastIndex += u[0].length) : n.lastIndex = 0 : H0 && u && (n.lastIndex = n.global ? u.index + u[0].length : l), Y0 && u && u.length > 1 && ml(Rse, u[0], a, function() {
            for (f = 1; f < arguments.length - 2; f++) arguments[f] === void 0 && (u[f] = void 0)
        }), u && _)
        for (u.groups = d = Ise(null), f = 0; f < _.length; f++) p = _[f], d[p[0]] = u[p[1]];
    return u
});
var N3 = W0,
    Fse = tO,
    XS = N3;
Fse({
    target: "RegExp",
    proto: !0,
    forced: /./.exec !== XS
}, {
    exec: XS
});
var Use = p3,
    uO = Function.prototype,
    QS = uO.apply,
    JS = uO.call,
    Bse = typeof Reflect == "object" && Reflect.apply || (Use ? JS.bind(QS) : function() {
        return JS.apply(QS, arguments)
    }),
    qse = Bf,
    Gse = pr,
    Vse = function(t) {
        if (qse(t) === "Function") return Gse(t)
    },
    e6 = Vse,
    t6 = ZA,
    jse = N3,
    n6 = hs,
    hO = Dc,
    Wse = b3,
    Hse = hO("species"),
    qy = RegExp.prototype,
    Yse = function(t, e, n, r) {
        var s = hO(t),
            i = !n6(function() {
                var u = {};
                return u[s] = function() {
                    return 7
                }, "" [t](u) != 7
            }),
            o = i && !n6(function() {
                var u = !1,
                    f = /a/;
                return t === "split" && (f = {}, f.constructor = {}, f.constructor[Hse] = function() {
                    return f
                }, f.flags = "", f[s] = /./ [s]), f.exec = function() {
                    return u = !0, null
                }, f[s](""), !u
            });
        if (!i || !o || n) {
            var a = e6(/./ [s]),
                l = e(s, "" [t], function(u, f, d, p, _) {
                    var v = e6(u),
                        y = f.exec;
                    return y === jse || y === qy.exec ? i && !_ ? {
                        done: !0,
                        value: a(f, d, p)
                    } : {
                        done: !0,
                        value: v(d, f, p)
                    } : {
                        done: !1
                    }
                });
            t6(String.prototype, t, l[0]), t6(qy, s, l[1])
        }
        r && Wse(qy[s], "sham", !0)
    },
    x3 = pr,
    zse = ng,
    Kse = rg,
    Zse = qf,
    Xse = x3("".charAt),
    r6 = x3("".charCodeAt),
    Qse = x3("".slice),
    s6 = function(t) {
        return function(e, n) {
            var r = Kse(Zse(e)),
                s = zse(n),
                i = r.length,
                o, a;
            return s < 0 || s >= i ? t ? "" : void 0 : (o = r6(r, s), o < 55296 || o > 56319 || s + 1 === i || (a = r6(r, s + 1)) < 56320 || a > 57343 ? t ? Xse(r, s) : o : t ? Qse(r, s, s + 2) : (o - 55296 << 10) + (a - 56320) + 65536)
        }
    },
    Jse = {
        codeAt: s6(!1),
        charAt: s6(!0)
    },
    eie = Jse.charAt,
    tie = function(t, e, n) {
        return e + (n ? eie(t, e).length : 1)
    },
    i6 = Ia,
    nie = $c,
    rie = Wr,
    sie = Bf,
    iie = N3,
    oie = TypeError,
    aie = function(t, e) {
        var n = t.exec;
        if (rie(n)) {
            var r = i6(n, t, e);
            return r !== null && nie(r), r
        }
        if (sie(t) === "RegExp") return i6(iie, t, e);
        throw oie("RegExp#exec called on incompatible receiver")
    },
    cie = Bse,
    o6 = Ia,
    ig = pr,
    lie = Yse,
    uie = hs,
    hie = $c,
    fie = Wr,
    die = eg,
    pie = ng,
    mie = QA,
    ol = rg,
    gie = qf,
    _ie = tie,
    yie = g3,
    vie = sO,
    bie = aie,
    Eie = Dc,
    z0 = Eie("replace"),
    Tie = Math.max,
    Sie = Math.min,
    wie = ig([].concat),
    Gy = ig([].push),
    a6 = ig("".indexOf),
    c6 = ig("".slice),
    Aie = function(t) {
        return t === void 0 ? t : String(t)
    },
    Oie = function() {
        return "a".replace(/./, "$0") === "$0"
    }(),
    l6 = function() {
        return /./ [z0] ? /./ [z0]("a", "$0") === "" : !1
    }(),
    Cie = !uie(function() {
        var t = /./;
        return t.exec = function() {
            var e = [];
            return e.groups = {
                a: "7"
            }, e
        }, "".replace(t, "$<a>") !== "7"
    });
lie("replace", function(t, e, n) {
    var r = l6 ? "$" : "$0";
    return [function(i, o) {
        var a = gie(this),
            l = die(i) ? void 0 : yie(i, z0);
        return l ? o6(l, i, a, o) : o6(e, ol(a), i, o)
    }, function(s, i) {
        var o = hie(this),
            a = ol(s);
        if (typeof i == "string" && a6(i, r) === -1 && a6(i, "$<") === -1) {
            var l = n(e, o, a, i);
            if (l.done) return l.value
        }
        var u = fie(i);
        u || (i = ol(i));
        var f = o.global;
        if (f) {
            var d = o.unicode;
            o.lastIndex = 0
        }
        for (var p = [];;) {
            var _ = bie(o, a);
            if (_ === null || (Gy(p, _), !f)) break;
            var v = ol(_[0]);
            v === "" && (o.lastIndex = _ie(a, mie(o.lastIndex), d))
        }
        for (var y = "", g = 0, b = 0; b < p.length; b++) {
            _ = p[b];
            for (var O = ol(_[0]), N = Tie(Sie(pie(_.index), a.length), 0), k = [], A = 1; A < _.length; A++) Gy(k, Aie(_[A]));
            var x = _.groups;
            if (u) {
                var D = wie([O], k, N, a);
                x !== void 0 && Gy(D, x);
                var L = ol(cie(i, void 0, D))
            } else L = vie(O, a, N, k, x, i);
            N >= g && (y += c6(a, g, N) + L, g = N + O.length)
        }
        return y + c6(a, g)
    }]
}, !Cie || !Oie || l6);
var kie = jr,
    Iie = pr,
    Nie = function(t, e) {
        return Iie(kie[t].prototype[e])
    },
    xie = Nie;
xie("String", "replaceAll");
const Pie = st({
    props: {
        count: {
            type: Number,
            required: !1
        }
    },
    computed: {
        displayCount() {
            return this.count ? this.count < 0 ? "X" : this.count : null
        }
    }
});
const fO = t => (Gr("data-v-1177328a"), t = t(), Vr(), t),
    Rie = {
        viewBox: "0 0 100 100"
    },
    Mie = fO(() => U("path", {
        class: "handle",
        d: "m0,9.52c0-2.3,1.87-4.17,4.17-4.17h12.51c2,0,3.72,1.42,4.1,3.39l10.48,55h53.54c2.31,0,4.17,1.86,4.17,4.17s-1.86,4.17-4.17,4.17H27.65c-1.84,0-3.56-1.42-3.94-3.39L13.23,13.69H4.17c-2.3,0-4.17-1.87-4.17-4.17Zm38.93,76.47c0,4.61-3.74,8.34-8.34,8.34s-8.34-3.74-8.34-8.34,3.74-8.34,8.34-8.34,8.34,3.74,8.34,8.34Zm33.37,0c0-4.61,3.74-8.34,8.34-8.34s8.34,3.74,8.34,8.34-3.74,8.34-8.34,8.34-8.34-3.74-8.34-8.34Z"
    }, null, -1)),
    Die = fO(() => U("path", {
        class: "basket",
        d: "m21.05,10.91h73.11c3.53,0,6.34,3.52,5.35,7.07l-9.38,33.37c-.68,2.4-2.87,4.05-5.35,4.05H29.66L21.05,10.91Z"
    }, null, -1)),
    $ie = {
        key: 0,
        cx: "83",
        cy: "70",
        r: "28"
    },
    Lie = {
        key: 1,
        x: "83",
        y: "86",
        "text-anchor": "middle",
        lengthAdjust: "spacing",
        textLength: "46"
    };

function Fie(t, e, n, r, s, i) {
    return B(), H("svg", Rie, [Mie, Die, t.displayCount ? (B(), H("circle", $ie)) : Pe("", !0), t.displayCount ? (B(), H("text", Lie, rt(t.displayCount), 1)) : Pe("", !0)])
}
const dO = He(Pie, [
    ["render", Fie],
    ["__scopeId", "data-v-1177328a"]
]);
const Uie = {},
    Bie = t => (Gr("data-v-110d22cc"), t = t(), Vr(), t),
    qie = {
        viewBox: "0 0 100 100"
    },
    Gie = Bie(() => U("path", {
        d: "m80,25.25l-5.25-5.25-24.75,24.75-24.75-24.75-5.25,5.25,24.75,24.75-24.75,24.75,5.25,5.25,24.75-24.75,24.75,24.75,5.25-5.25-24.75-24.75,24.75-24.75Z"
    }, null, -1)),
    Vie = [Gie];

function jie(t, e) {
    return B(), H("svg", qie, Vie)
}
const Wie = He(Uie, [
        ["render", jie],
        ["__scopeId", "data-v-110d22cc"]
    ]),
    Hie = {},
    Yie = {
        viewBox: "0 0 100 100"
    },
    zie = U("path", {
        d: "m89.06,15.62c2.6,0,4.69,2.1,4.69,4.69s-2.09,4.69-4.69,4.69h-2.27l-4.69,63.42c-.49,6.52-5.92,11.58-12.46,11.58H30.35c-6.54,0-11.97-5.06-12.46-11.58l-4.7-63.42h-2.26c-2.59,0-4.69-2.09-4.69-4.69s2.1-4.69,4.69-4.69h13.64l7.16-10.75c2.03-3.04,5.45-4.87,9.1-4.87h18.32c3.65,0,7.07,1.83,9.1,4.87l7.17,10.75h13.63Zm-48.22-6.25c-.51,0-1.17.26-1.29.7l-3.71,5.55h28.32l-3.71-5.55c-.29-.43-.78-.7-1.29-.7h-18.32Zm36.56,15.62H22.6l4.65,62.73c.12,1.62,1.48,2.89,3.11,2.89h39.3c1.62,0,2.99-1.27,3.11-2.89l4.65-62.73Z"
    }, null, -1),
    Kie = [zie];

function Zie(t, e) {
    return B(), H("svg", Yie, Kie)
}
const Xie = He(Hie, [
        ["render", Zie]
    ]),
    Qie = st({
        components: {
            CartSVG: dO,
            CloseSVG: Wie,
            TrashSVG: Xie
        },
        props: {
            artifactId: {
                type: String,
                required: !0
            },
            categoryId: {
                type: String,
                required: !0
            },
            shopify: {
                type: Object,
                required: !0
            }
        },
        emits: {
            resolve: () => !0
        },
        computed: {
            items() {
                return this.shopify.cart.lines.map(t => {
                    var s, i, o, a, l, u, f, d;
                    const e = ((i = (s = t.merchandise) == null ? void 0 : s.price) == null ? void 0 : i.amount) ?? "0",
                        n = ((a = (o = t.merchandise) == null ? void 0 : o.price) == null ? void 0 : a.currencyCode) ?? "USD",
                        r = (u = (l = t.merchandise) == null ? void 0 : l.image) == null ? void 0 : u.url;
                    return {
                        id: t.id,
                        image: r,
                        title: ((d = (f = t.merchandise) == null ? void 0 : f.product) == null ? void 0 : d.title) ?? "Product",
                        price: parseFloat(e).toLocaleString(this.$i18n.locale, {
                            style: "currency",
                            currency: n
                        }),
                        quantity: `${t.quantity}x`
                    }
                })
            },
            currency() {
                var t;
                return ((t = this.shopify.cart) == null ? void 0 : t.currency) ?? "USD"
            },
            total() {
                var e, n;
                const t = ((n = (e = this.shopify.cart) == null ? void 0 : e.subtotal) == null ? void 0 : n.amount) ?? "0";
                return parseFloat(t).toLocaleString(this.$i18n.locale, {
                    style: "currency",
                    currency: this.currency
                })
            }
        },
        methods: {
            onCloseClick() {
                this.$emit("resolve")
            },
            async onTrashClick(t) {
                try {
                    await this.shopify.cart.removeItem([t.id])
                } catch (e) {
                    console.error(e)
                }
            },
            onCheckoutClick() {
                var e, n, r;
                const t = ((n = (e = this.shopify.cart) == null ? void 0 : e.subtotal) == null ? void 0 : n.amount) ?? "0";
                zl.galleryCheckout(this.categoryId, {
                    locale: this.$i18n.locale,
                    artifactId: this.artifactId,
                    itemCount: ((r = this.shopify.cart) == null ? void 0 : r.totalQuantity) ?? 0,
                    subtotal: parseFloat(t)
                })
            }
        }
    });
const Jie = {
        class: "gallery-ui"
    },
    eoe = {
        key: 0,
        class: "empty"
    },
    toe = {
        class: "graphic"
    },
    noe = {
        class: "title"
    },
    roe = {
        class: "form-section"
    },
    soe = ["src", "alt"],
    ioe = {
        class: "info"
    },
    ooe = {
        class: "name"
    },
    aoe = {
        class: "price"
    },
    coe = {
        class: "quantity"
    },
    loe = ["onClick"],
    uoe = {
        class: "form-group"
    },
    hoe = {
        class: "total"
    },
    foe = {
        class: "form-group"
    },
    doe = ["href"];

function poe(t, e, n, r, s, i) {
    var f;
    const o = Ge("CartSVG"),
        a = Ge("TrashSVG"),
        l = Ge("CloseSVG"),
        u = Gt("t");
    return B(), H("div", Jie, [t.shopify.cart.lines.length ? (B(), H(lt, {
        key: 1
    }, [U("h2", noe, rt(t.$t("GALLERY.CART.TITLE")), 1), U("section", roe, [(B(!0), H(lt, null, gn(t.items, d => (B(), H("div", {
        key: d.id,
        class: "item"
    }, [U("img", {
        src: d.image ?? "",
        alt: d.title
    }, null, 8, soe), U("div", ioe, [U("p", ooe, rt(d.title), 1), U("p", aoe, rt(d.price), 1)]), U("div", coe, [U("p", null, rt(d.quantity), 1)]), U("button", {
        class: "trash",
        onClick: p => t.onTrashClick(d)
    }, [Ve(a)], 8, loe)]))), 128)), U("div", uoe, [U("p", hoe, [mn(rt(t.$t("GALLERY.CART.TOTAL")) + " (" + rt(t.currency) + ") ", 1), U("span", null, rt(t.total), 1)])]), U("div", foe, [U("a", {
        class: "button submit",
        href: ((f = t.shopify.cart) == null ? void 0 : f.checkoutUrl) ?? "",
        target: "_blank",
        onClick: e[0] || (e[0] = (...d) => t.onCheckoutClick && t.onCheckoutClick(...d))
    }, rt(t.$t("GALLERY.CART.CHECK_OUT")), 9, doe)])])], 64)) : (B(), H("section", eoe, [U("div", toe, [Ve(o, {
        count: -1
    }), $e(U("p", null, null, 512), [
        [u, "GALLERY.CART.EMPTY"]
    ])])])), U("button", {
        class: "close",
        onClick: e[1] || (e[1] = (...d) => t.onCloseClick && t.onCloseClick(...d))
    }, [Ve(l)])])
}
const moe = He(Qie, [
    ["render", poe],
    ["__scopeId", "data-v-0c1c2b81"]
]);

function og(t) {
    const e = {};
    return t.id && (e.id = t.id), t.url && (e.url = t.url), e
}

function goe(t) {
    const e = {};
    return t.id && (e.id = t.id), t.fields && (e.fields = t.fields), e
}

function P3(t) {
    const e = {};
    return t.id && (e.id = t.id), t.key && (e.key = t.key), t.namespace && (e.namespace = t.namespace), t.value && (e.value = t.value), t.reference && (e.reference = goe(t.reference)), e
}

function pO(t) {
    var n;
    const e = {};
    return t.id && (e.id = t.id), t.title && (e.title = t.title), t.price && (e.price = t.price), (n = t.product) != null && n.id && (e.productId = t.product.id), t.image && (e.image = og(t.image)), t.metafields && (e.metafields = t.metafields.map(P3)), e
}

function b1(t) {
    const e = {};
    return t.id && (e.id = t.id), t.description && (e.description = t.description), t.handle && (e.handle = t.handle), t.title && (e.title = t.title), t.priceRange && (e.priceRange = t.priceRange), t.compareAtPriceRange && (e.compareAtPriceRange = t.compareAtPriceRange), t.images && (e.images = t.images.nodes.map(og)), t.metafields && (e.metafields = t.metafields.map(P3)), t.variants && (e.variants = t.variants.nodes.map(pO)), e
}

function _oe(t) {
    const e = {};
    return t.id && (e.id = t.id), t.price && (e.price = t.price), t.product && (e.product = b1(t.product)), t.image && (e.image = og(t.image)), e
}

function yoe(t) {
    const e = {};
    return t.id && (e.id = t.id), t.attributes && (e.attributes = t.attributes), t.quantity !== void 0 && (e.quantity = t.quantity), t.merchandise && (e.merchandise = _oe(t.merchandise)), e
}

function voe(t) {
    const e = {};
    return t.id && (e.id = t.id), t.description && (e.description = t.description), t.title && (e.title = t.title), t.image && (e.image = og(t.image)), t.metafields && (e.metafields = t.metafields.map(P3)), t.products && (e.products = t.products.nodes.map(b1)), e
}

function gp(t) {
    var n, r;
    const e = {};
    return t.id && (e.id = t.id), t.checkoutUrl && (e.checkoutUrl = t.checkoutUrl), ((n = t.cost) == null ? void 0 : n.subtotalAmount) !== void 0 && (e.subtotal = (r = t.cost) == null ? void 0 : r.subtotalAmount), t.totalQuantity !== void 0 && (e.totalQuantity = t.totalQuantity), t.lines && (e.lines = t.lines.nodes.map(yoe)), e
}
class boe {
    constructor(e, n) {
        ye(this, "locale");
        ye(this, "makeRequest");
        ye(this, "checkoutUrl");
        ye(this, "lines", []);
        ye(this, "currency", "USD");
        ye(this, "subtotal");
        ye(this, "totalQuantity", 0);
        ye(this, "sharedGetCartProperties", `
        checkoutUrl
        id
        totalQuantity
        cost {
            subtotalAmount {
                amount
                currencyCode
            }
        }
        lines(first: 100) {
            nodes {
                id
                quantity
                merchandise {
                    ... on ProductVariant {
                        price {
                            amount
                            currencyCode
                        }
                        product {
                            title
                        }
                        image {
                            url
                        }
                    }
                }
                attributes {
                    key
                    value
                }
            }
        }`);
        this.locale = n, this.makeRequest = e
    }
    get localeDirective() {
        return `@inContext(language: ${this.locale})`
    }
    getCartId() {
        const e = localStorage.getItem("cartId");
        return e || (this.resetCart(), null)
    }
    resetCart() {
        delete this.checkoutUrl, this.lines = [], delete this.subtotal, this.totalQuantity = 0, localStorage.removeItem("cartId")
    }
    setCartValues(e) {
        var n;
        e.checkoutUrl && (this.checkoutUrl = e.checkoutUrl), e.lines && (this.lines = e.lines), e.subtotal && (this.subtotal = e.subtotal), e.totalQuantity && (this.totalQuantity = e.totalQuantity), (n = e.subtotal) != null && n.currencyCode && (this.currency = e.subtotal.currencyCode)
    }
    async createCart() {
        const e = `mutation {
            cartCreate(input: {}) {
                cart {
                    ${this.sharedGetCartProperties}
                }
            }
        }`,
            n = await this.makeRequest(e),
            r = gp(n.data.cartCreate.cart);
        return localStorage.setItem("cartId", r.id), this.setCartValues(r), r
    }
    async refresh() {
        const e = this.getCartId();
        if (!e) return null;
        const n = `query getCart($cartId: ID!) @inContext(language: EN) {
            cart(id: $cartId) {
                ${this.sharedGetCartProperties}
            }
        }`,
            r = await this.makeRequest(n, {
                cartId: e
            });
        if (!r.data.cart) return this.resetCart(), null;
        const s = gp(r.data.cart);
        return this.setCartValues(s), s
    }
    async addItems(e) {
        let n = this.getCartId();
        n || (await this.createCart(), n = this.getCartId());
        const r = `mutation add($cartId: ID!, $lines: [CartLineInput!]!) {
            cartLinesAdd(cartId: $cartId, lines: $lines) {
                cart {
                    ${this.sharedGetCartProperties}
                }
            }
        }`,
            s = await this.makeRequest(r, {
                cartId: n,
                lines: e
            }),
            i = gp(s.data.cartLinesAdd.cart);
        return this.setCartValues(i), i
    }
    async removeItem(e) {
        const n = this.getCartId();
        if (!n) throw new Error("No cart is available");
        const r = `mutation remove($cartId: ID!, $lineIds: [ID!]!) {
            cartLinesRemove(cartId: $cartId, lineIds: $lineIds) {
                cart {
                    ${this.sharedGetCartProperties}
                }
            }
        }`,
            s = await this.makeRequest(r, {
                cartId: n,
                lineIds: e
            }),
            i = gp(s.data.cartLinesRemove.cart);
        return this.setCartValues(i), i
    }
}
class Eoe {
    constructor(e, n) {
        ye(this, "locale");
        ye(this, "makeRequest");
        this.locale = n, this.makeRequest = e
    }
    get localeDirective() {
        return `@inContext(language: ${this.locale})`
    }
    async getStorefrontPricing(e) {
        const n = `query getProductBy($id: ID!) ${this.localeDirective} {
            product(id: $id) {
                title
                variants(first: 1) {
                    nodes {
                        id
                        title
                        price {
                            amount
                        }
                    }
                }
                metafields(
                    identifiers: [{ namespace: "custom", key: "storefront_pricing" }]
                ) {
                    key
                        reference {
                        ... on Metaobject {
                            fields {
                                key
                                value
                            }
                        }
                    }
                }
                priceRange {
                    minVariantPrice {
                        amount
                        currencyCode
                    }
                }
                compareAtPriceRange {
                    maxVariantPrice {
                        amount
                        currencyCode
                    }
                }
            }
        }`,
            r = await this.makeRequest(n, {
                id: `gid://shopify/Product/${e}`
            });
        return b1(r.data.product)
    }
    async getTeeKO2Products() {
        const e = `query ${this.localeDirective} {
            collection(id: "gid://shopify/Collection/269996851334") {
                products(first: 100) {
                    nodes {
                        handle
                        metafields(identifiers: [
                            { namespace: "custom", key: "teeko2_metadata" },
                            { namespace: "custom", key: "product_type" }
                        ]) {
                            key
                            value
                            reference {
                                ... on Metaobject {
                                    fields {
                                        key
                                        value
                                    }
                                }
                            }
                        }
                        variants(first: 100) {
                            nodes {
                                id
                                title
                                price {
                                    amount
                                    currencyCode
                                }
                                metafields(
                                    identifiers: [
                                        { namespace: "gooten", key: "layout_image" }
                                    ]
                                ) {
                                    key
                                    value
                                }
                            }
                        }
                    }
                }
            }
        }`,
            n = await this.makeRequest(e);
        return voe(n.data.collection)
    }
    async getProductWithMetafields(e, n) {
        const r = `query variantWithMetafields($id: ID!, $metafields: [HasMetafieldsIdentifier!]!) ${this.localeDirective} {
            node(id: $id) {
                ... on Product {
                    metafields(identifiers: $metafields) {
                        key
                        value
                        reference {
                        ... on Metaobject {
                                fields {
                                    key
                                    value
                                }
                            }
                        }
                    }
                }
            }
        }`,
            s = await this.makeRequest(r, {
                id: `gid://shopify/Product/${e}`,
                metafields: n
            });
        return b1(s.data.node)
    }
    async getVariantWithMetafields(e, n) {
        const r = `query variantWithMetafields($id: ID!, $metafields: [HasMetafieldsIdentifier!]!) ${this.localeDirective} {
            node(id: $id) {
                ... on ProductVariant {
                    product {
                        id
                    }
                    metafields(identifiers: $metafields) {
                        key
                        value
                        reference {
                        ... on Metaobject {
                                fields {
                                    key
                                    value
                                }
                            }
                        }
                    }
                }
            }
        }`,
            s = await this.makeRequest(r, {
                id: `gid://shopify/ProductVariant/${e}`,
                metafields: n
            });
        return pO(s.data.node)
    }
}
class Toe {
    constructor(e) {
        ye(this, "shopUrl");
        ye(this, "apiToken");
        ye(this, "isDebug");
        ye(this, "locale");
        ye(this, "query");
        ye(this, "cart");
        this.shopUrl = `https://${e.shopName}.myshopify.com/api/2023-10/graphql.json`, this.apiToken = e.apiToken, this.locale = this.parseLocale(e.locale), this.isDebug = e.debug ?? !1, this.query = new Eoe(this.makeRequest.bind(this), this.locale), e.enableCart && (this.cart = new boe(this.makeRequest.bind(this), this.locale))
    }
    parseLocale(e) {
        return e ? {
            "es-XL": "ES",
            "pr-BR": "PT_BR"
        } [e] || e.toLocaleUpperCase() : "EN"
    }
    async makeRequest(e, n = {}) {
        const r = {
                method: "POST",
                headers: new Headers({
                    "Content-Type": "application/json",
                    Accept: "application/json",
                    "X-Shopify-Storefront-Access-Token": this.apiToken
                }),
                body: JSON.stringify({
                    query: e,
                    variables: n
                })
            },
            s = await fetch(this.shopUrl, r);
        if (!s.ok) throw console.error(s), new Error("Shopify response is not okay");
        let i;
        try {
            i = await s.json()
        } catch (o) {
            throw new Error("Failed to parse Shopify response as JSON", {
                cause: o
            })
        }
        if (this.isDebug && console.log(i), i.errors) throw console.error(i.errors), new Error("Errors returned in Shopify response");
        return i
    }
    static getMetaValue(e, n) {
        const r = n.split(".");
        if (r.length > 2) {
            console.warn("getMetaValue only supports 1 level of reference fields");
            return
        }
        const s = e.find(o => o.key === r[0]);
        if (!s) {
            console.warn(`getMetaValue could find a field with key ${r[0]}`);
            return
        }
        if (r.length === 1) {
            if (!s.value) {
                console.warn(`getMetaValue could find a value for key ${r[0]}`);
                return
            }
            return s.value
        }
        if (!s.reference) {
            console.warn(`getMetaValue could find reference for key ${r[0]}`);
            return
        }
        if (!s.reference.fields) {
            console.warn(`getMetaValue could find a fields for key ${r[0]}`);
            return
        }
        const i = s.reference.fields.find(o => o.key === r[1]);
        if (!i) {
            console.warn(`getMetaValue could find a field for key ${r[1]}`);
            return
        }
        if (!i.value) {
            console.warn(`getMetaValue could find a value for key ${r[1]}`);
            return
        }
        return i.value
    }
}
const Soe = {},
    woe = t => (Gr("data-v-8a441c8b"), t = t(), Vr(), t),
    Aoe = {
        viewBox: "0 0 100 100"
    },
    Ooe = woe(() => U("path", {
        d: "m71.43,100.05c-3.1,3-45.42-43.71-47.91-44.95-2.79-2.79-2.79-7.31,0-10.1L66.38,2.15c6.45-6.63,16.76,3.63,10.1,10.1,0,0-37.81,37.81-37.81,37.81l37.81,37.81c4.55,4.24,1.06,12.41-5.06,12.19Z"
    }, null, -1)),
    Coe = [Ooe];

function koe(t, e) {
    return B(), H("svg", Aoe, Coe)
}
const Ioe = He(Soe, [
    ["render", koe],
    ["__scopeId", "data-v-8a441c8b"]
]);
const Noe = {},
    xoe = {
        viewBox: "0 0 450 170"
    },
    Poe = Pc('<path d="m125.22,148.61c-3.8,10.71,14.07,8.66,14.51-4.66,0,0,.76-6.07.76-6.07h-.65c-11.11,10.26-31.98,7.94-32.16-14.19-1.85-27.91,29.59-42.89,41.49-24.04h.65l3.79-7.15h13.97l-9.1,51.44c-2.6,14.84-10.62,24.37-29.57,24.37-20.48-.04-26.86-8.42-21.24-20.04,0,0,17.55.33,17.55.33Zm17.22-21.78l3.35-17.22c-6.25-12.46-19.63.91-18.3,12.56.14,11.01,9.67,11.01,14.94,4.66h0Z" data-v-16eba653></path><path d="m165.94,125c-1.72-26.97,26.98-45.33,40.73-25.45h.65l3.79-7.04h14.3l-6.29,35.96c-1.35,4.75,1.4,6.23,5.63,4.22l-1.74,12.24c-6.89,2.04-22.54,4.11-22.64-5.85h-.54c-9.93,11.62-34.55,11.48-33.9-14.08h0Zm37.47-16.03c-6.44-10.75-17.57.3-17,15.17-.36,11.33,8.81,11.4,13.43,5.3,0,0,3.57-20.47,3.57-20.47Z" data-v-16eba653></path><path d="m252.28,101.6c4.42-12.87,28.7-14.17,31.63.22h.65c5.51-14.74,32.91-14.34,31.84,5.09.15,4.28-2.71,17.11-3.35,21.56-1.3,4.58,1.77,6.12,5.74,4.11l-1.74,12.34c-34.19,8.67-21.76-14.97-19.93-35.42,0-3.14-1.3-4.76-4.55-4.76-3.68,0-7.69,3.35-9.64,14.4l-4.55,26.43h-19.06l5.74-32.27c.78-3.85.99-8.78-4.12-8.55-10.61-1.45-12.12,32.87-14.41,40.83h-19.17l6.39-36.18c1.21-4.47-2.17-5.66-5.74-3.9l1.52-12.56c8.04-2.59,24.49-2.8,22.09,8.66.02,0,.65-.02.67,0Z" data-v-16eba653></path><path d="m353.55,91.43c20.8-.36,28.06,14.61,21.01,29.46h-33.57c-4.34,16.32,14.4,16.73,15.16,6.08l17.43.11c0,13.64-11.81,19.6-26.65,19.6-40.37,1.13-28.87-58.07,6.61-55.24h.01Zm5.74,20.47c3.92-12.52-15.1-12.22-16.68,0h16.68Z" data-v-16eba653></path><path d="m394.5,128.03c-4.38,9.29,14.81,10.75,15.06,2.92.44-4.29-8.84-5.01-12.14-6.07-11.27-2.7-16.14-6.83-16.14-14.3-3.22-24.42,57.55-26.61,49.5-.98l-16.68.11c4.14-9.01-13.94-9.7-14.09-2.38,0,2.92,2.81,3.79,6.07,4.55,10.57,1.76,23.87,5.95,22.96,15.6,3.86,24.26-59.53,26.83-51.67.65l17.12-.11h0Z" data-v-16eba653></path><path d="m37.75,86.06c-2.29,20.58-21.35,26.17-37.37,20.78l4.06-13.69c6.65,2.32,11.4,2.88,13-7.77,0,0,10.1-57.91,10.1-57.91h20.54l-10.33,58.61h0ZM31.84,3.65h20.43l-2.78,15.55h-20.43l2.78-15.55Z" data-v-16eba653></path><path d="m47.04,62.26c-1.84-28.91,28.89-48.57,43.64-27.27h.7l4.06-7.54h15.32l-6.74,38.53c-1.46,5.09,1.5,6.68,6.03,4.53l-1.86,13.11c-7.38,2.18-24.15,4.39-24.26-6.27h-.58c-10.63,12.44-37.02,12.3-36.33-15.09h0Zm40.16-17.17c-6.89-11.53-18.82.31-18.21,16.25-.39,12.15,9.42,12.22,14.39,5.69,0,0,3.83-21.94,3.83-21.94h0Z" data-v-16eba653></path><path d="m146.26,26.28c23.79,1.01,27.73,12.42,23.68,24.02l-20.08.23c4.26-17.57-17.81-11.55-16.49,11.48-.73,13.3,15.25,11.41,14.74-.7l19.96.12c5.09,29.5-56.87,34.36-55.71,1.16,0-19.15,9.98-36.33,33.89-36.33v.02Z" data-v-16eba653></path><path d="m226.57,70.74c1.05,0,2.32-.23,3.36-.58l-2.44,13.69c-24.48,7.36-21.86-8.84-28.31-22.98h-5.46l-4.06,23.44h-20.54L183.86.75h20.55l-8.35,47.12,4.41-.46c2.44-2.33,12.3-17.99,14.62-19.96h21.59l-.47,2.33c-2.44,2.09-15.55,20.43-19.03,24.26,1.83,1.3,4.65,16.99,9.4,16.71h0Z" data-v-16eba653></path><path d="m246.3.75h20.43l-5.81,32.26h.58c10.83-12.1,33.79-8.54,33.54,15.43.8,34.11-30.04,47.15-43.87,29.13h-.58l-3.94,6.74h-15.32L246.3.75Zm8.59,66.61c7.66,10.18,19.51-.27,19.26-16.83,0-7.55-3.71-9.98-7.31-9.98-2.78,0-6.15,1.98-8.12,4.53l-3.83,22.28h0Z" data-v-16eba653></path><path d="m329.86,26.28c44.54-1.33,30.54,62.33-5.34,59.19-44.34,1.39-30.24-62.31,5.34-59.19Zm6.62,23.32c0-6.15-2.67-9.05-6.85-9.05-10.49-2.62-18.27,30.4-4.87,30.76,7.32,0,11.73-7.55,11.73-21.71h0Z" data-v-16eba653></path><path d="m387.77,37.2c1.05,3.36,1.98,6.5,2.55,9.28h.47c2.87-6.04,8.83-13.46,12.65-19.03h21.82l-.35,1.98-21.48,25.77,6.39,12.65c2.13,3.84,5.23,3.16,8.12,2.1l-2.44,13.93c-19.63,5.42-22.79-2.11-26.47-19.5h-.58c-2.84,6.34-9.23,14.26-13.11,19.96h-21.82l.35-1.86,21.94-26.82-5.81-11.72c-1.84-3.78-5.56-3.18-8.47-2.1l2.55-13.92c10.53-2.64,21.58-3.83,23.67,9.29v-.02Z" data-v-16eba653></path><path d="m441.34,94.3c3.47.57,3.38-3.01,0-2.21v2.21h0Zm-.04,4.31h-1.78v-7.68c1.08-.2,4.75-.53,5.58.37,1.33.88.9,3.14-.79,3.46v.09c1.29.08,1.53,3.22,1.92,3.75h-1.88c-.72-1.38-.33-3.52-3.04-3.04v3.04h0Zm-4.73-3.98c-.21,7.89,12.05,8.05,11.85.04.23-7.99-12.01-8.04-11.85-.04m13.81,0c.21,10.07-15.96,10.03-15.79,0-.23-9.93,15.98-10.06,15.78,0" data-v-16eba653></path>', 13),
    Roe = [Poe];

function Moe(t, e) {
    return B(), H("svg", xoe, Roe)
}
const Doe = He(Noe, [
        ["render", Moe],
        ["__scopeId", "data-v-16eba653"]
    ]),
    $oe = st({
        components: {
            BackSVG: Ioe,
            CartSVG: dO,
            LogoSVG: Doe
        },
        props: {
            artifactId: {
                type: String,
                required: !1
            },
            categoryId: {
                type: String,
                required: !1
            },
            itemId: {
                type: String,
                required: !1
            },
            context: {
                type: String,
                required: !0
            },
            view: {
                type: Object,
                required: !0
            }
        },
        themeColor: "#000000",
        data() {
            return {
                isError: !1,
                isLoading: !0,
                artifact: null,
                shopify: new Toe({
                    shopName: "jackbox-games",
                    apiToken: "272f9467112ef071c8d5622704def9a9",
                    enableCart: !0
                })
            }
        },
        computed: {
            propsToPass() {
                const t = {};
                return this.view.props.artifactId && (t.artifactId = this.artifactId), this.view.props.itemId && (t.itemId = this.itemId), this.view.props.artifact && (t.artifact = this.artifact), this.view.props.context && (t.context = this.context), this.view.props.shopify && (t.shopify = this.shopify), t
            },
            cart() {
                return this.shopify.cart
            }
        },
        mounted() {
            this.fetchArtifact(), this.fetchCart()
        },
        methods: {
            async fetchArtifact() {
                try {
                    const t = `https://jbg-blobcast-artifacts.s3.amazonaws.com/${this.categoryId}/${this.artifactId}/data.json.gz`,
                        n = await (await fetch(t)).json();
                    this.artifact = f9.hydrate(n)
                } catch (t) {
                    this.isError = !0, console.error(t)
                } finally {
                    this.isLoading = !1
                }
            },
            async fetchCart() {
                try {
                    await this.cart.refresh()
                } catch (t) {
                    console.error(t)
                }
            },
            onCartClick() {
                this.$showModal(c2(moe), {
                    artifactId: this.artifactId,
                    categoryId: this.categoryId,
                    shopify: this.shopify
                }, {
                    classes: ["gallery-modal", "is-tab"]
                })
            }
        }
    });
const Loe = {
        class: "gallery-root"
    },
    Foe = {
        class: "topbar"
    },
    Uoe = {
        class: "back"
    },
    Boe = {
        key: 0,
        href: "https://jackbox.tv/past-games",
        "aria-label": "back"
    },
    qoe = {
        class: "logo"
    },
    Goe = {
        class: "cart"
    },
    Voe = {
        class: "content"
    },
    joe = {
        key: 0,
        class: "empty"
    },
    Woe = {
        key: 1,
        class: "loading"
    },
    Hoe = {
        key: 2,
        class: "error"
    },
    Yoe = {
        class: "post-game"
    };

function zoe(t, e, n, r, s, i) {
    const o = Ge("BackSVG"),
        a = Ge("LogoSVG"),
        l = Ge("CartSVG"),
        u = Gt("t");
    return B(), H("div", Loe, [U("nav", Foe, [U("div", Uoe, [t.context === "standalone" ? (B(), H("a", Boe, [Ve(o)])) : Pe("", !0)]), U("div", qoe, [Ve(a)]), U("div", Goe, [U("button", {
        onClick: e[0] || (e[0] = (...f) => t.onCartClick && t.onCartClick(...f))
    }, [Ve(l, {
        count: t.shopify.cart.totalQuantity
    }, null, 8, ["count"])])])]), U("div", Voe, [t.artifactId ? t.isLoading ? $e((B(), H("div", Woe, null, 512)), [
        [u, "LOADING"]
    ]) : t.isError ? $e((B(), H("div", Hoe, null, 512)), [
        [u, "ERROR.TITLE"]
    ]) : (B(), At(Fm(t.view), cF(Mf({
        key: 3
    }, t.propsToPass)), null, 16)) : $e((B(), H("div", joe, null, 512)), [
        [u, "POST_GAME.THANKS_FOR_PLAYING"]
    ])]), U("div", Yoe, [g7(t.$slots, "default", {}, void 0, !0)])])
}
const mO = He($oe, [
    ["render", zoe],
    ["__scopeId", "data-v-84ae5b8a"]
]);
var Qi = {},
    ag = {},
    gO = {},
    cg = {},
    R3 = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.Token = void 0;
    var e = function() {
        function n(r, s, i, o) {
            this.type = r, this.content = s, this.attributes = i, this.text = o
        }
        return n.prototype.toString = function() {
            return this.content + " (" + this.type + ")"
        }, n.prototype.equals = function(r) {
            return this.type === r.type && this.content === r.content
        }, n.prototype.convertToTextToken = function() {
            var r;
            this.type === n.Type.startTag ? (this.content = (r = this.text) !== null && r !== void 0 ? r : "", this.type = n.Type.text) : this.type === n.Type.endTag && (this.content = "[/" + this.content + "]", this.type = n.Type.text)
        }, n
    }();
    t.Token = e,
        function(n) {
            (function(r) {
                r[r.text = 0] = "text", r[r.startTag = 1] = "startTag", r[r.endTag = 2] = "endTag"
            })(n.Type || (n.Type = {}))
        }(e = t.Token || (t.Token = {})), t.Token = e
})(R3);
Object.defineProperty(cg, "__esModule", {
    value: !0
});
cg.Tokenizer = void 0;
var $o = R3,
    Koe = function() {
        function t(e) {
            this.tags = e
        }
        return t.prototype.tokenizeString = function(e) {
            var n = this,
                r = this.getTokens(e),
                s = [],
                i = !1,
                o = "",
                a = "";
            return r.forEach(function(l) {
                var u = n.tags[l.content],
                    f = !0;
                !u && !i ? l.convertToTextToken() : i ? l.type === $o.Token.Type.endTag && l.content === o ? (i = !1, s.push(t.createTextToken(a))) : (l.convertToTextToken(), a += l.content, f = !1) : u.noNesting && l.type === $o.Token.Type.startTag && (i = !0, o = l.content, a = ""), f && s.push(l)
            }), s
        }, t.prototype.getTokens = function(e) {
            for (var n = '\\[(/\\w*)\\]|\\[(\\w*)+(=(["])' + t.valueChars + "*\\4)?( (" + t.nameChars + '+)?=(["])(' + t.valueChars + "+)\\7)*\\]", r = new RegExp(n, "g"), s = [], i = r.exec(e), o = 0; i;) {
                var a = i.index - o;
                a > 0 && s.push(t.createTextToken(e.substr(o, a))), s.push(t.createTagToken(i)), o = r.lastIndex, i = r.exec(e)
            }
            var l = e.length - o;
            return l > 0 && s.push(t.createTextToken(e.substr(o, l))), s
        }, t.createTextToken = function(e) {
            return new $o.Token($o.Token.Type.text, e)
        }, t.createTagToken = function(e) {
            if (!e[1]) {
                for (var n = e[2], r = {}, s = new RegExp("(" + t.nameChars + '+)?=(["])(' + t.valueChars + "+)\\2", "g"), i = e[0].substr(1 + n.length, e[0].length - 2 - n.length), o = s.exec(i); o;) o[1] ? r[o[1]] = o[3] : r[n] = o[3], o = s.exec(i);
                return new $o.Token($o.Token.Type.startTag, n, r, e[0])
            }
            return new $o.Token($o.Token.Type.endTag, e[1].substr(1, e[1].length - 1))
        }, t.nameChars = "[a-zA-Z0-9\\.\\-_:;/]", t.valueChars = "[a-zA-Z0-9\\.\\-_:;#/\\s]", t
    }();
cg.Tokenizer = Koe;
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.ParseTree = void 0;
    var e = cg,
        n = R3,
        r = function() {
            function s(i) {
                this.subTrees = [], this.type = i.type, this.content = i.content, i.attributes && (this.attributes = i.attributes), i.subTrees && (this.subTrees = i.subTrees)
            }
            return Object.defineProperty(s.prototype, "isValid", {
                get: function() {
                    return this.subTrees.length ? this.subTrees.every(function(i) {
                        return i.isValid
                    }) : !0
                },
                enumerable: !1,
                configurable: !0
            }), s.prototype.toString = function() {
                return this.type + " - " + this.content
            }, s.buildTree = function(i, o) {
                var a = new e.Tokenizer(o),
                    l = a.tokenizeString(i),
                    u = new s({
                        type: s.Type.root,
                        content: i
                    });
                return this.buildTreeFromTokens(u, l.reverse())
            }, s.buildTreeFromTokens = function(i, o, a) {
                if (a === void 0 && (a = ""), !i) return null;
                if (!o.length) return i;
                var l = o.pop();
                if (!l) return null;
                if (l.type === n.Token.Type.text) {
                    var u = new s({
                        type: s.Type.text,
                        content: l.content
                    });
                    i.subTrees.push(u)
                }
                if (l.type === n.Token.Type.startTag) {
                    var f = l.content,
                        u = new s({
                            type: s.Type.tag,
                            content: f,
                            attributes: l.attributes
                        }),
                        d = s.buildTreeFromTokens(u, o, f);
                    if (!d) return null;
                    i.subTrees.push(d)
                }
                if (l.type === n.Token.Type.endTag) {
                    var f = l.content;
                    return f === a ? i : null
                }
                return !o.length && a !== "" ? null : this.buildTreeFromTokens(i, o, a)
            }, s
        }();
    t.ParseTree = r,
        function(s) {
            (function(i) {
                i[i.root = 0] = "root", i[i.text = 1] = "text", i[i.tag = 2] = "tag"
            })(s.Type || (s.Type = {}))
        }(r = t.ParseTree || (t.ParseTree = {})), t.ParseTree = r
})(gO);
var jf = {};
Object.defineProperty(jf, "__esModule", {
    value: !0
});
jf.Tag = void 0;
var Zoe = function() {
    function t(e) {
        var n;
        this.tagName = e.tagName, this.insertLineBreaks = e.insertLineBreaks, this.suppressLineBreaks = e.suppressLineBreaks, this.noNesting = e.noNesting, this.markupGenerator = (n = e.markupGenerator) !== null && n !== void 0 ? n : function(r, s) {
            return "<" + r.tagName + ">" + s + "</" + r.tagName + ">"
        }
    }
    return t.create = function(e, n, r) {
        var s, i, o;
        return r === void 0 && (r = {}), new t({
            tagName: e,
            insertLineBreaks: (s = r.insertLineBreaks) !== null && s !== void 0 ? s : !0,
            suppressLineBreaks: (i = r.suppressLineBreaks) !== null && i !== void 0 ? i : !1,
            noNesting: (o = r.noNesting) !== null && o !== void 0 ? o : !1,
            markupGenerator: n
        })
    }, t
}();
jf.Tag = Zoe;
Object.defineProperty(ag, "__esModule", {
    value: !0
});
ag.BBCodeParser = void 0;
var u6 = gO,
    h6 = jf,
    Xoe = function() {
        function t(e, n) {
            this.options = n, this.escapeHTML = !1, this.tags = e, n && (this.escapeHTML = n.escapeHTML)
        }
        return Object.defineProperty(t, "defaultTags", {
            get: function() {
                return {
                    b: h6.Tag.create("b"),
                    i: h6.Tag.create("i")
                }
            },
            enumerable: !1,
            configurable: !0
        }), t.prototype.parse = function(e, n, r, s) {
            n === void 0 && (n = !1), r === void 0 && (r = !0), s === void 0 && (s = !0);
            var i = u6.ParseTree.buildTree(e, this.tags);
            return !i || !i.isValid ? e : this.treeToHtml(i.subTrees, r, s, n)
        }, t.prototype.addTag = function(e, n) {
            this.tags[e] = n
        }, t.prototype.treeToHtml = function(e, n, r, s) {
            var i = this;
            s === void 0 && (s = !1);
            var o = "",
                a = !1;
            return e.forEach(function(l) {
                var u;
                if (l.type === u6.ParseTree.Type.text) {
                    var f = l.content;
                    r && (f = i.escapeHTML ? t.escapeHTML(f) : f), n && !a && (f = f.replace(/(\r\n|\n|\r)/gm, "<br>"), a = !1), o += f
                } else {
                    var d = i.tags[l.content],
                        p = i.treeToHtml(l.subTrees, d.insertLineBreaks, r, s);
                    s ? o += p : o += d.markupGenerator(d, p, (u = l.attributes) !== null && u !== void 0 ? u : {}), a = d.suppressLineBreaks
                }
            }), o
        }, t.escapeHTML = function(e) {
            return e.replace(/[&<>]/g, function(n) {
                return t.tagsToReplace[n] || n
            })
        }, t.tagsToReplace = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;"
        }, t
    }();
ag.BBCodeParser = Xoe;
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.Tag = t.BBCodeParser = void 0;
    var e = ag;
    Object.defineProperty(t, "BBCodeParser", {
        enumerable: !0,
        get: function() {
            return e.BBCodeParser
        }
    });
    var n = jf;
    Object.defineProperty(t, "Tag", {
        enumerable: !0,
        get: function() {
            return n.Tag
        }
    })
})(Qi);
const Qoe = {
    install: t => {
        const e = {
            section: Qi.Tag.create("section", (i, o, {
                section: a
            }) => `<div ${a?`class="section ${a}"`:'class="section"'}>${o}</div>`)
        };
        ["b", "bold", "B"].forEach(i => {
            e[i] = Qi.Tag.create(i, (o, a) => `<strong>${a}</strong>`)
        }), ["i", "italic", "I"].forEach(i => {
            e[i] = Qi.Tag.create(i, (o, a) => `<em>${a}</em>`)
        }), e.tos = Qi.Tag.create("tos", (i, o) => `<a class="tosLink" href="https://jackboxgames.com/terms-of-service/" target="_blank">${o}</a>`), e.pp = Qi.Tag.create("pp", (i, o) => `<a class="ppLink" href="https://jackboxgames.com/privacy-policy/" target="_blank">${o}</a>`);
        const s = new Qi.BBCodeParser(e);
        t.directive("bb", {
            mounted(i, o) {
                const a = document.createElement("div");
                a.textContent = o.value, i.innerHTML = s.parse(a.innerHTML)
            },
            updated(i, o) {
                const a = document.createElement("div");
                a.textContent = o.value, i.innerHTML = s.parse(a.innerHTML)
            }
        }), t.mixin({
            beforeCreate() {
                this.$options.bb && Object.keys(this.$options.bb).forEach(i => {
                    const o = this.$options.bb[i];
                    if (o instanceof Function) {
                        s.addTag(i, Qi.Tag.create(i, o));
                        return
                    }
                    s.addTag(i, Qi.Tag.create(i, o.generator, o.options))
                })
            }
        }), t.config.globalProperties.$bb = i => (typeof i != "string" && console.warn(`[BBCodePlugin] Received unexpected ${typeof i} with value ${i};converting to string before parsing.`), s.parse(String(i)))
    }
};
const Joe = st({
    data() {
        return {
            showPowerNav: !1
        }
    },
    computed: {
        debugNav() {
            return this.$refs.debugNav
        },
        replayer() {
            return this.$debugReplayer
        }
    },
    mounted() {
        window.addEventListener("keydown", t => {
            var e, n, r, s;
            return t.key === "," ? (e = this.replayer) == null ? void 0 : e.toPreviousEntity() : t.key === "." ? (n = this.replayer) == null ? void 0 : n.toNextEntity() : t.key === "q" ? (r = this.replayer) == null ? void 0 : r.toPreviousMarker() : t.key === "w" ? (s = this.replayer) == null ? void 0 : s.toNextMarker() : null
        })
    },
    methods: {
        onPreviousClick() {
            var t;
            (t = this.replayer) == null || t.toPreviousMarker()
        },
        onNextClick() {
            var t;
            (t = this.replayer) == null || t.toNextMarker()
        },
        onOpenPowerNavClick() {
            this.showPowerNav = !0, this.debugNav.focus()
        },
        onClosePowerNavClick() {
            this.showPowerNav = !1, this.debugNav.focus()
        },
        onMarkerClick(t) {
            var e;
            (e = this.replayer) == null || e.toMarkerIndex(t)
        },
        onKillClick() {
            var t;
            (t = this.replayer) == null || t.kill()
        },
        onDisconnectClick() {
            var t;
            (t = this.replayer) == null || t.disconnect()
        }
    }
});
const bo = t => (Gr("data-v-220ec4c0"), t = t(), Vr(), t),
    eae = {
        key: 0,
        ref: "debugNav",
        class: "debug-nav",
        tabindex: "0"
    },
    tae = {
        key: 0,
        class: "power-nav"
    },
    nae = bo(() => U("p", null, "MARKERS", -1)),
    rae = ["onClick"],
    sae = bo(() => U("br", null, null, -1)),
    iae = bo(() => U("p", {
        class: "title blurred"
    }, "DEBUG", -1)),
    oae = {
        key: 1,
        class: "title focused"
    },
    aae = {
        key: 2,
        class: "title focused"
    },
    cae = bo(() => U("svg", {
        viewBox: "0 0 20 10"
    }, [U("polygon", {
        points: "0,10 10,0 20,10"
    })], -1)),
    lae = bo(() => U("div", {
        class: "visually-hidden"
    }, "Open debug menu", -1)),
    uae = [cae, lae],
    hae = bo(() => U("svg", {
        viewBox: "0 0 60 50"
    }, [U("polygon", {
        class: "outline",
        points: "40,35.6 20,25 40,14.4"
    }), U("polygon", {
        points: "40,35.6 20,25 40,14.4"
    })], -1)),
    fae = bo(() => U("div", {
        class: "visually-hidden"
    }, "Previous", -1)),
    dae = [hae, fae],
    pae = bo(() => U("svg", {
        viewBox: "0 0 60 50"
    }, [U("polygon", {
        class: "outline",
        points: "40,35.6 20,25 40,14.4"
    }), U("polygon", {
        points: "40,35.6 20,25 40,14.4"
    })], -1)),
    mae = bo(() => U("div", {
        class: "visually-hidden"
    }, "Next", -1)),
    gae = [pae, mae];

function _ae(t, e, n, r, s, i) {
    return t.replayer ? (B(), H("div", eae, [t.showPowerNav ? (B(), H("div", tae, [U("button", {
        class: "close",
        onClick: e[0] || (e[0] = (...o) => t.onClosePowerNavClick && t.onClosePowerNavClick(...o))
    }, "X"), nae, U("ul", null, [(B(!0), H(lt, null, gn(t.replayer.markerMap, (o, a) => (B(), H("li", {
        key: a,
        class: nt({
            active: a === t.replayer.currentMarkerItemIndex
        }),
        onClick: l => t.onMarkerClick(a)
    }, rt(o[1].marker), 11, rae))), 128))]), U("button", {
        class: "option",
        onClick: e[1] || (e[1] = (...o) => t.onKillClick && t.onKillClick(...o))
    }, [mn("KILL"), sae, mn("ROOM")]), U("button", {
        class: "option",
        onClick: e[2] || (e[2] = (...o) => t.onDisconnectClick && t.onDisconnectClick(...o))
    }, "DISCONNECT")])) : Pe("", !0), iae, t.replayer.markerMap.length ? (B(), H("p", aae, rt(t.replayer.currentMarkerItemIndex) + " : " + rt(t.replayer.currentMarkerItem[1].marker) + " (" + rt(t.replayer.currentEntityItemIndex) + ") ", 1)) : (B(), H("p", oae, "Item #" + rt(t.replayer.currentEntityItemIndex), 1)), t.showPowerNav ? Pe("", !0) : (B(), H("button", {
        key: 3,
        class: "open-power-nav",
        onClick: e[3] || (e[3] = (...o) => t.onOpenPowerNavClick && t.onOpenPowerNavClick(...o))
    }, uae)), U("button", {
        class: "direction previous",
        onClick: e[4] || (e[4] = (...o) => t.onPreviousClick && t.onPreviousClick(...o))
    }, dae), U("button", {
        class: "direction next",
        onClick: e[5] || (e[5] = (...o) => t.onNextClick && t.onNextClick(...o))
    }, gae)], 512)) : Pe("", !0)
}
const yae = He(Joe, [
    ["render", _ae],
    ["__scopeId", "data-v-220ec4c0"]
]);

function vae(t, e) {
    for (var n = -1, r = t == null ? 0 : t.length; ++n < r && e(t[n], n, t) !== !1;);
    return t
}
var bae = vae,
    Eae = t9,
    Tae = Eae(Object.keys, Object),
    Sae = Tae,
    wae = G2,
    Aae = Sae,
    Oae = Object.prototype,
    Cae = Oae.hasOwnProperty;

function kae(t) {
    if (!wae(t)) return Aae(t);
    var e = [];
    for (var n in Object(t)) Cae.call(t, n) && n != "constructor" && e.push(n);
    return e
}
var Iae = kae,
    Nae = l9,
    xae = Iae,
    Pae = Zm;

function Rae(t) {
    return Pae(t) ? Nae(t) : xae(t)
}
var lg = Rae,
    Mae = $f,
    Dae = lg;

function $ae(t, e) {
    return t && Mae(e, Dae(e), t)
}
var Lae = $ae,
    Fae = $f,
    Uae = Lf;

function Bae(t, e) {
    return t && Fae(e, Uae(e), t)
}
var qae = Bae;

function Gae(t, e) {
    for (var n = -1, r = t == null ? 0 : t.length, s = 0, i = []; ++n < r;) {
        var o = t[n];
        e(o, n, t) && (i[s++] = o)
    }
    return i
}
var Vae = Gae;

function jae() {
    return []
}
var _O = jae,
    Wae = Vae,
    Hae = _O,
    Yae = Object.prototype,
    zae = Yae.propertyIsEnumerable,
    f6 = Object.getOwnPropertySymbols,
    Kae = f6 ? function(t) {
        return t == null ? [] : (t = Object(t), Wae(f6(t), function(e) {
            return zae.call(t, e)
        }))
    } : Hae,
    M3 = Kae,
    Zae = $f,
    Xae = M3;

function Qae(t, e) {
    return Zae(t, Xae(t), e)
}
var Jae = Qae;

function ece(t, e) {
    for (var n = -1, r = e.length, s = t.length; ++n < r;) t[s + n] = e[n];
    return t
}
var yO = ece,
    tce = yO,
    nce = q2,
    rce = M3,
    sce = _O,
    ice = Object.getOwnPropertySymbols,
    oce = ice ? function(t) {
        for (var e = []; t;) tce(e, rce(t)), t = nce(t);
        return e
    } : sce,
    vO = oce,
    ace = $f,
    cce = vO;

function lce(t, e) {
    return ace(t, cce(t), e)
}
var uce = lce,
    hce = yO,
    fce = Oa;

function dce(t, e, n) {
    var r = e(t);
    return fce(t) ? r : hce(r, n(t))
}
var bO = dce,
    pce = bO,
    mce = M3,
    gce = lg;

function _ce(t) {
    return pce(t, gce, mce)
}
var yce = _ce,
    vce = bO,
    bce = vO,
    Ece = Lf;

function Tce(t) {
    return vce(t, Ece, bce)
}
var Sce = Tce,
    wce = Mc,
    Ace = ni,
    Oce = wce(Ace, "DataView"),
    Cce = Oce,
    kce = Mc,
    Ice = ni,
    Nce = kce(Ice, "Promise"),
    xce = Nce,
    Pce = Mc,
    Rce = ni,
    Mce = Pce(Rce, "Set"),
    Dce = Mce,
    $ce = Mc,
    Lce = ni,
    Fce = $ce(Lce, "WeakMap"),
    Uce = Fce,
    K0 = Cce,
    Z0 = F2,
    X0 = xce,
    Q0 = Dce,
    J0 = Uce,
    EO = wu,
    Nu = Y7,
    d6 = "[object Map]",
    Bce = "[object Object]",
    p6 = "[object Promise]",
    m6 = "[object Set]",
    g6 = "[object WeakMap]",
    _6 = "[object DataView]",
    qce = Nu(K0),
    Gce = Nu(Z0),
    Vce = Nu(X0),
    jce = Nu(Q0),
    Wce = Nu(J0),
    Ja = EO;
(K0 && Ja(new K0(new ArrayBuffer(1))) != _6 || Z0 && Ja(new Z0) != d6 || X0 && Ja(X0.resolve()) != p6 || Q0 && Ja(new Q0) != m6 || J0 && Ja(new J0) != g6) && (Ja = function(t) {
    var e = EO(t),
        n = e == Bce ? t.constructor : void 0,
        r = n ? Nu(n) : "";
    if (r) switch (r) {
        case qce:
            return _6;
        case Gce:
            return d6;
        case Vce:
            return p6;
        case jce:
            return m6;
        case Wce:
            return g6
    }
    return e
});
var D3 = Ja,
    Hce = Object.prototype,
    Yce = Hce.hasOwnProperty;

function zce(t) {
    var e = t.length,
        n = new t.constructor(e);
    return e && typeof t[0] == "string" && Yce.call(t, "index") && (n.index = t.index, n.input = t.input), n
}
var Kce = zce,
    Zce = B2;

function Xce(t, e) {
    var n = e ? Zce(t.buffer) : t.buffer;
    return new t.constructor(n, t.byteOffset, t.byteLength)
}
var Qce = Xce,
    Jce = /\w*$/;

function ele(t) {
    var e = new t.constructor(t.source, Jce.exec(t));
    return e.lastIndex = t.lastIndex, e
}
var tle = ele,
    y6 = Ym,
    v6 = y6 ? y6.prototype : void 0,
    b6 = v6 ? v6.valueOf : void 0;

function nle(t) {
    return b6 ? Object(b6.call(t)) : {}
}
var rle = nle,
    sle = B2,
    ile = Qce,
    ole = tle,
    ale = rle,
    cle = J7,
    lle = "[object Boolean]",
    ule = "[object Date]",
    hle = "[object Map]",
    fle = "[object Number]",
    dle = "[object RegExp]",
    ple = "[object Set]",
    mle = "[object String]",
    gle = "[object Symbol]",
    _le = "[object ArrayBuffer]",
    yle = "[object DataView]",
    vle = "[object Float32Array]",
    ble = "[object Float64Array]",
    Ele = "[object Int8Array]",
    Tle = "[object Int16Array]",
    Sle = "[object Int32Array]",
    wle = "[object Uint8Array]",
    Ale = "[object Uint8ClampedArray]",
    Ole = "[object Uint16Array]",
    Cle = "[object Uint32Array]";

function kle(t, e, n) {
    var r = t.constructor;
    switch (e) {
        case _le:
            return sle(t);
        case lle:
        case ule:
            return new r(+t);
        case yle:
            return ile(t, n);
        case vle:
        case ble:
        case Ele:
        case Tle:
        case Sle:
        case wle:
        case Ale:
        case Ole:
        case Cle:
            return cle(t, n);
        case hle:
            return new r;
        case fle:
        case mle:
            return new r(t);
        case dle:
            return ole(t);
        case ple:
            return new r;
        case gle:
            return ale(t)
    }
}
var Ile = kle,
    Nle = D3,
    xle = Aa,
    Ple = "[object Map]";

function Rle(t) {
    return xle(t) && Nle(t) == Ple
}
var Mle = Rle,
    Dle = Mle,
    $le = j2,
    E6 = W2,
    T6 = E6 && E6.isMap,
    Lle = T6 ? $le(T6) : Dle,
    Fle = Lle,
    Ule = D3,
    Ble = Aa,
    qle = "[object Set]";

function Gle(t) {
    return Ble(t) && Ule(t) == qle
}
var Vle = Gle,
    jle = Vle,
    Wle = j2,
    S6 = W2,
    w6 = S6 && S6.isSet,
    Hle = w6 ? Wle(w6) : jle,
    Yle = Hle,
    zle = K7,
    Kle = bae,
    Zle = H2,
    Xle = Lae,
    Qle = qae,
    Jle = Q7,
    eue = e9,
    tue = Jae,
    nue = uce,
    rue = yce,
    sue = Sce,
    iue = D3,
    oue = Kce,
    aue = Ile,
    cue = n9,
    lue = Oa,
    uue = V2,
    hue = Fle,
    fue = ri,
    due = Yle,
    pue = lg,
    mue = Lf,
    gue = 1,
    _ue = 2,
    yue = 4,
    TO = "[object Arguments]",
    vue = "[object Array]",
    bue = "[object Boolean]",
    Eue = "[object Date]",
    Tue = "[object Error]",
    SO = "[object Function]",
    Sue = "[object GeneratorFunction]",
    wue = "[object Map]",
    Aue = "[object Number]",
    wO = "[object Object]",
    Oue = "[object RegExp]",
    Cue = "[object Set]",
    kue = "[object String]",
    Iue = "[object Symbol]",
    Nue = "[object WeakMap]",
    xue = "[object ArrayBuffer]",
    Pue = "[object DataView]",
    Rue = "[object Float32Array]",
    Mue = "[object Float64Array]",
    Due = "[object Int8Array]",
    $ue = "[object Int16Array]",
    Lue = "[object Int32Array]",
    Fue = "[object Uint8Array]",
    Uue = "[object Uint8ClampedArray]",
    Bue = "[object Uint16Array]",
    que = "[object Uint32Array]",
    Xt = {};
Xt[TO] = Xt[vue] = Xt[xue] = Xt[Pue] = Xt[bue] = Xt[Eue] = Xt[Rue] = Xt[Mue] = Xt[Due] = Xt[$ue] = Xt[Lue] = Xt[wue] = Xt[Aue] = Xt[wO] = Xt[Oue] = Xt[Cue] = Xt[kue] = Xt[Iue] = Xt[Fue] = Xt[Uue] = Xt[Bue] = Xt[que] = !0;
Xt[Tue] = Xt[SO] = Xt[Nue] = !1;

function Gp(t, e, n, r, s, i) {
    var o, a = e & gue,
        l = e & _ue,
        u = e & yue;
    if (n && (o = s ? n(t, r, s, i) : n(t)), o !== void 0) return o;
    if (!fue(t)) return t;
    var f = lue(t);
    if (f) {
        if (o = oue(t), !a) return eue(t, o)
    } else {
        var d = iue(t),
            p = d == SO || d == Sue;
        if (uue(t)) return Jle(t, a);
        if (d == wO || d == TO || p && !s) {
            if (o = l || p ? {} : cue(t), !a) return l ? nue(t, Qle(o, t)) : tue(t, Xle(o, t))
        } else {
            if (!Xt[d]) return s ? t : {};
            o = aue(t, d, a)
        }
    }
    i || (i = new zle);
    var _ = i.get(t);
    if (_) return _;
    i.set(t, o), due(t) ? t.forEach(function(g) {
        o.add(Gp(g, e, n, g, t, i))
    }) : hue(t) && t.forEach(function(g, b) {
        o.set(b, Gp(g, e, n, b, t, i))
    });
    var v = u ? l ? sue : rue : l ? mue : pue,
        y = f ? void 0 : v(t);
    return Kle(y || t, function(g, b) {
        y && (b = g, g = t[b]), Zle(o, b, Gp(g, e, n, b, t, i))
    }), o
}
var Gue = Gp,
    Vue = Gue,
    jue = 1,
    Wue = 4;

function Hue(t) {
    return Vue(t, jue | Wue)
}
var Yue = Hue;
const AO = Rc(Yue),
    zue = st({
        emits: {
            resolve: () => !0
        },
        data() {
            return {
                screen: "options",
                vibe: null,
                message: "",
                content: null,
                isContent: !0,
                values: {}
            }
        },
        mounted() {
            var e, n;
            const t = (n = (e = this.$debugRecorder) == null ? void 0 : e.room) == null ? void 0 : n.appTag;
            t && (this.values = AO(this.$ecastValues), this.content = bS.getPromptGuess(this.values, t) ?? null)
        },
        methods: {
            onFeedbackClick() {
                this.screen = "feedback"
            },
            onDebugClick() {
                this.screen = "debug"
            },
            onVibeClick(t) {
                this.vibe = t
            },
            async onSubmitClick() {
                this.$debugRecorder && (this.screen === "debug" && (await this.$debugRecorder.send(this.message), this.$emit("resolve")), this.screen === "feedback" && (await bS.send({
                    room: this.$debugRecorder.room,
                    name: this.$ecast.name,
                    role: this.$ecast.role,
                    content: this.isContent ? this.content : null,
                    message: this.message ?? "",
                    vibe: this.vibe ?? "none",
                    values: this.values
                }), this.$emit("resolve")))
            }
        }
    }),
    OO = "main/pp10/nopus-opus/assets/ad9172fc.png",
    CO = "main/pp10/nopus-opus/assets/dc131b16.png",
    Kue = "main/pp10/nopus-opus/assets/38715b18.png",
    Zue = "main/pp10/nopus-opus/assets/b0d7c822.png",
    Xue = "main/pp10/nopus-opus/assets/06150f24.png";
const Ms = t => (Gr("data-v-2c53389f"), t = t(), Vr(), t),
    Que = {
        class: "jbg"
    },
    Jue = {
        key: 0,
        class: "options"
    },
    ehe = Ms(() => U("img", {
        src: OO,
        alt: "Leave Feedback"
    }, null, -1)),
    the = Ms(() => U("span", null, [mn("LEAVE"), U("br"), mn("FEEDBACK")], -1)),
    nhe = [ehe, the],
    rhe = Ms(() => U("img", {
        src: CO,
        alt: "Send Debug"
    }, null, -1)),
    she = Ms(() => U("span", null, [mn("SEND A"), U("br"), mn("DEBUG")], -1)),
    ihe = [rhe, she],
    ohe = {
        key: 1,
        class: "feedback"
    },
    ahe = Ms(() => U("img", {
        class: "image",
        src: OO,
        alt: "Feedback"
    }, null, -1)),
    che = Ms(() => U("h3", {
        class: "text"
    }, "Send Feedback", -1)),
    lhe = Ms(() => U("p", {
        class: "cta"
    }, "CHOOSE A VIBE", -1)),
    uhe = {
        class: "buttons"
    },
    hhe = Ms(() => U("img", {
        src: Kue,
        alt: "good"
    }, null, -1)),
    fhe = [hhe],
    dhe = Ms(() => U("img", {
        src: Zue,
        alt: "good"
    }, null, -1)),
    phe = [dhe],
    mhe = Ms(() => U("img", {
        src: Xue,
        alt: "bad"
    }, null, -1)),
    ghe = [mhe],
    _he = {
        class: "actions"
    },
    yhe = {
        key: 0,
        class: "content-guess"
    },
    vhe = {
        key: 2,
        class: "debug"
    },
    bhe = Ms(() => U("img", {
        class: "image",
        src: CO,
        alt: "Debug"
    }, null, -1)),
    Ehe = Ms(() => U("h3", {
        class: "text"
    }, "What is Happening?", -1)),
    The = {
        class: "actions"
    };

function She(t, e, n, r, s, i) {
    return B(), H("div", Que, [t.screen === "options" ? (B(), H("div", Jue, [U("button", {
        class: "feedback-button",
        onClick: e[0] || (e[0] = (...o) => t.onFeedbackClick && t.onFeedbackClick(...o))
    }, nhe), U("button", {
        onClick: e[1] || (e[1] = (...o) => t.onDebugClick && t.onDebugClick(...o))
    }, ihe)])) : t.screen === "feedback" ? (B(), H("div", ohe, [ahe, che, U("div", {
        class: nt(["vibes", {
            "has-selected": t.vibe
        }])
    }, [lhe, U("div", uhe, [U("button", {
        class: nt({
            selected: t.vibe === "good"
        }),
        onClick: e[2] || (e[2] = o => t.onVibeClick("good"))
    }, fhe, 2), U("button", {
        class: nt({
            selected: t.vibe === "meh"
        }),
        onClick: e[3] || (e[3] = o => t.onVibeClick("meh"))
    }, phe, 2), U("button", {
        class: nt({
            selected: t.vibe === "bad"
        }),
        onClick: e[4] || (e[4] = o => t.onVibeClick("bad"))
    }, ghe, 2)])], 2), U("div", _he, [t.content ? (B(), H("div", yhe, [$e(U("input", {
        "onUpdate:modelValue": e[5] || (e[5] = o => t.isContent = o),
        type: "checkbox"
    }, null, 512), [
        [TB, t.isContent]
    ]), U("span", null, [mn("Feedback is about: "), U("em", null, rt(t.content), 1)])])) : Pe("", !0), $e(U("textarea", {
        "onUpdate:modelValue": e[6] || (e[6] = o => t.message = o),
        rows: "3",
        placeholder: "(optional) more details",
        "aria-label": "Details"
    }, null, 512), [
        [yT, t.message]
    ]), U("button", {
        onClick: e[7] || (e[7] = Oi((...o) => t.onSubmitClick && t.onSubmitClick(...o), ["prevent"]))
    }, rt(t.$t("ACTION.SUBMIT")), 1)])])) : t.screen === "debug" ? (B(), H("div", vhe, [bhe, Ehe, U("div", The, [$e(U("textarea", {
        "onUpdate:modelValue": e[8] || (e[8] = o => t.message = o),
        rows: "3",
        placeholder: "Enter details",
        "aria-label": "Details"
    }, null, 512), [
        [yT, t.message]
    ]), U("button", {
        onClick: e[9] || (e[9] = Oi((...o) => t.onSubmitClick && t.onSubmitClick(...o), ["prevent"]))
    }, rt(t.$t("ACTION.OK")), 1)])])) : Pe("", !0)])
}
const whe = He(zue, [
        ["render", She],
        ["__scopeId", "data-v-2c53389f"]
    ]),
    Ahe = st({
        methods: {
            onFeedbackClick() {
                this.$showModal(whe)
            }
        }
    });

function Ohe(t, e, n, r, s, i) {
    return B(), H("div", {
        class: "feedback-button",
        onClick: e[0] || (e[0] = (...o) => t.onFeedbackClick && t.onFeedbackClick(...o))
    }, "SEND FEEDBACK")
}
const Che = He(Ahe, [
        ["render", Ohe],
        ["__scopeId", "data-v-6f2f1788"]
    ]),
    khe = {
        install: (t, e) => {
            if (!t.config.globalProperties.$debugRecorder && !t.config.globalProperties.$debugReplayer) {
                if (e.replayer) {
                    t.config.globalProperties.$debugReplayer = e.replayer, t.component("Debug", yae);
                    return
                }
                if (t.config.globalProperties.$debugRecorder = new jX(e.client, e.room), !t.config.globalProperties.$showModal) {
                    console.warn("[debugPlugin] Sending debug and feedback messages is disabled because the modalPlugin is missing.");
                    return
                }(!js.isProduction() || js.getQueryParam("feedback")) && t.component("Debug", Che)
            }
        }
    };
var Ihe = ni,
    Nhe = function() {
        return Ihe.Date.now()
    },
    xhe = Nhe,
    Phe = /\s/;

function Rhe(t) {
    for (var e = t.length; e-- && Phe.test(t.charAt(e)););
    return e
}
var Mhe = Rhe,
    Dhe = Mhe,
    $he = /^\s+/;

function Lhe(t) {
    return t && t.slice(0, Dhe(t) + 1).replace($he, "")
}
var Fhe = Lhe,
    Uhe = wu,
    Bhe = Aa,
    qhe = "[object Symbol]";

function Ghe(t) {
    return typeof t == "symbol" || Bhe(t) && Uhe(t) == qhe
}
var ug = Ghe,
    Vhe = Fhe,
    A6 = ri,
    jhe = ug,
    O6 = 0 / 0,
    Whe = /^[-+]0x[0-9a-f]+$/i,
    Hhe = /^0b[01]+$/i,
    Yhe = /^0o[0-7]+$/i,
    zhe = parseInt;

function Khe(t) {
    if (typeof t == "number") return t;
    if (jhe(t)) return O6;
    if (A6(t)) {
        var e = typeof t.valueOf == "function" ? t.valueOf() : t;
        t = A6(e) ? e + "" : e
    }
    if (typeof t != "string") return t === 0 ? t : +t;
    t = Vhe(t);
    var n = Hhe.test(t);
    return n || Yhe.test(t) ? zhe(t.slice(2), n ? 2 : 8) : Whe.test(t) ? O6 : +t
}
var Zhe = Khe,
    Xhe = ri,
    Vy = xhe,
    C6 = Zhe,
    Qhe = "Expected a function",
    Jhe = Math.max,
    efe = Math.min;

function tfe(t, e, n) {
    var r, s, i, o, a, l, u = 0,
        f = !1,
        d = !1,
        p = !0;
    if (typeof t != "function") throw new TypeError(Qhe);
    e = C6(e) || 0, Xhe(n) && (f = !!n.leading, d = "maxWait" in n, i = d ? Jhe(C6(n.maxWait) || 0, e) : i, p = "trailing" in n ? !!n.trailing : p);

    function _(x) {
        var D = r,
            L = s;
        return r = s = void 0, u = x, o = t.apply(L, D), o
    }

    function v(x) {
        return u = x, a = setTimeout(b, e), f ? _(x) : o
    }

    function y(x) {
        var D = x - l,
            L = x - u,
            q = e - D;
        return d ? efe(q, i - L) : q
    }

    function g(x) {
        var D = x - l,
            L = x - u;
        return l === void 0 || D >= e || D < 0 || d && L >= i
    }

    function b() {
        var x = Vy();
        if (g(x)) return O(x);
        a = setTimeout(b, y(x))
    }

    function O(x) {
        return a = void 0, p && r ? _(x) : (r = s = void 0, o)
    }

    function N() {
        a !== void 0 && clearTimeout(a), u = 0, r = l = s = a = void 0
    }

    function k() {
        return a === void 0 ? o : O(Vy())
    }

    function A() {
        var x = Vy(),
            D = g(x);
        if (r = arguments, s = this, l = x, D) {
            if (a === void 0) return v(l);
            if (d) return clearTimeout(a), a = setTimeout(b, e), _(l)
        }
        return a === void 0 && (a = setTimeout(b, e)), o
    }
    return A.cancel = N, A.flush = k, A
}
var nfe = tfe;
const rfe = Rc(nfe);
var sfe = Oa,
    ife = ug,
    ofe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    afe = /^\w*$/;

function cfe(t, e) {
    if (sfe(t)) return !1;
    var n = typeof t;
    return n == "number" || n == "symbol" || n == "boolean" || t == null || ife(t) ? !0 : afe.test(t) || !ofe.test(t) || e != null && t in Object(e)
}
var lfe = cfe,
    kO = z7,
    ufe = "Expected a function";

function $3(t, e) {
    if (typeof t != "function" || e != null && typeof e != "function") throw new TypeError(ufe);
    var n = function() {
        var r = arguments,
            s = e ? e.apply(this, r) : r[0],
            i = n.cache;
        if (i.has(s)) return i.get(s);
        var o = t.apply(this, r);
        return n.cache = i.set(s, o) || i, o
    };
    return n.cache = new($3.Cache || kO), n
}
$3.Cache = kO;
var hfe = $3,
    ffe = hfe,
    dfe = 500;

function pfe(t) {
    var e = ffe(t, function(r) {
            return n.size === dfe && n.clear(), r
        }),
        n = e.cache;
    return e
}
var mfe = pfe,
    gfe = mfe,
    _fe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    yfe = /\\(\\)?/g,
    vfe = gfe(function(t) {
        var e = [];
        return t.charCodeAt(0) === 46 && e.push(""), t.replace(_fe, function(n, r, s, i) {
            e.push(s ? i.replace(yfe, "$1") : r || n)
        }), e
    }),
    bfe = vfe;

function Efe(t, e) {
    for (var n = -1, r = t == null ? 0 : t.length, s = Array(r); ++n < r;) s[n] = e(t[n], n, t);
    return s
}
var IO = Efe,
    k6 = Ym,
    Tfe = IO,
    Sfe = Oa,
    wfe = ug,
    Afe = 1 / 0,
    I6 = k6 ? k6.prototype : void 0,
    N6 = I6 ? I6.toString : void 0;

function NO(t) {
    if (typeof t == "string") return t;
    if (Sfe(t)) return Tfe(t, NO) + "";
    if (wfe(t)) return N6 ? N6.call(t) : "";
    var e = t + "";
    return e == "0" && 1 / t == -Afe ? "-0" : e
}
var Ofe = NO,
    Cfe = Ofe;

function kfe(t) {
    return t == null ? "" : Cfe(t)
}
var Ife = kfe,
    Nfe = Oa,
    xfe = lfe,
    Pfe = bfe,
    Rfe = Ife;

function Mfe(t, e) {
    return Nfe(t) ? t : xfe(t, e) ? [t] : Pfe(Rfe(t))
}
var xO = Mfe,
    Dfe = ug,
    $fe = 1 / 0;

function Lfe(t) {
    if (typeof t == "string" || Dfe(t)) return t;
    var e = t + "";
    return e == "0" && 1 / t == -$fe ? "-0" : e
}
var PO = Lfe,
    Ffe = H2,
    Ufe = xO,
    Bfe = Y2,
    x6 = ri,
    qfe = PO;

function Gfe(t, e, n, r) {
    if (!x6(t)) return t;
    e = Ufe(e, t);
    for (var s = -1, i = e.length, o = i - 1, a = t; a != null && ++s < i;) {
        var l = qfe(e[s]),
            u = n;
        if (l === "__proto__" || l === "constructor" || l === "prototype") return t;
        if (s != o) {
            var f = a[l];
            u = r ? r(f, l, a) : void 0, u === void 0 && (u = x6(f) ? f : Bfe(e[s + 1]) ? [] : {})
        }
        Ffe(a, l, u), a = a[l]
    }
    return t
}
var Vfe = Gfe,
    jfe = Vfe;

function Wfe(t, e, n) {
    return t == null ? t : jfe(t, e, n)
}
var Hfe = Wfe;
const Yfe = Rc(Hfe);
class zfe {
    constructor() {
        ye(this, "wsClient");
        ye(this, "isKicked", !1);
        ye(this, "isHostPaused", !1);
        ye(this, "watchStopHandler");
        ye(this, "keyMap");
        ye(this, "providerMap");
        ye(this, "mappedValues", Ec({}));
        ye(this, "shouldParseBlobcast", !1);
        ye(this, "callbackMap", new Map);
        ye(this, "pausedKeys", null);
        ye(this, "pausedEvents", null);
        ye(this, "keyMapKeys");
        ye(this, "providerMapKeys");
        ye(this, "hotValues");
        ye(this, "newValues");
        ye(this, "pause", (e = [], n = null) => {
            if (e) {
                const r = this.pausedKeys ?? [];
                r.push(...e), this.pausedKeys = r
            }
            if (n) {
                const r = this.pausedEvents ?? [];
                r.push(...n), this.pausedEvents = r
            }
        });
        ye(this, "resume", () => {
            this.pausedKeys = null, this.pausedEvents = null, this.sync()
        });
        ye(this, "sync", rfe(() => {
            if (this.wsClient && !(!this.keyMap && !this.providerMap)) {
                if (this.pausedKeys && !this.pausedKeys.length) {
                    this.emit("didReceivePausedEntities", this.wsClient.entities);
                    return
                }
                this.hotValues = {}, this.newValues = {}, this.normalize().mapKeysToValues().mapProvidersToValues().deleteDropped().hydrateRefs().syncExisting(), delete this.hotValues, delete this.newValues, this.checkHostIsPausedChange()
            }
        }, 50))
    }
    setWSClient(e) {
        this.wsClient = e, this.setupWatcher(), e.on("connection", this.onConnection.bind(this)), e.on("room/exit", this.onRoomExit.bind(this)), e.on("room/lock", this.onRoomLock.bind(this)), e.on("client/connected", this.onClientConnected.bind(this)), e.on("client/disconnected", this.onClientDisconnected.bind(this)), e.on("client/kicked", this.onClientKicked.bind(this)), e.on("socketClose", this.onSocketClose.bind(this))
    }
    setupWatcher() {
        this.wsClient.entities = Ec(this.wsClient.entities), this.watchStopHandler = na(this.wsClient.entities, this.sync)
    }
    valueForEntity(e) {
        return e instanceof Pr.ArtifactEntity || e instanceof Pr.DoodleEntity || e instanceof Pr.TextMapEntity || e instanceof Pr.NumberEntity ? e : e instanceof Pr.ObjectEntity ? AO(e.val) : e instanceof Pr.TextEntity ? e.text : null
    }
    normalize() {
        var n;
        const e = Object.keys(this.wsClient.entities);
        for (let r = 0; r < e.length; r++) {
            let s = e[r];
            if ((n = this.pausedKeys) != null && n.includes(s)) {
                this.emit("didReceivePausedEntities", {
                    [s]: this.wsClient.entities[s]
                });
                continue
            }
            const i = this.valueForEntity(this.wsClient.entities[s]);
            if (i != null) {
                if (this.shouldParseBlobcast) {
                    const o = s.split(":");
                    if (o[0] === "bc")
                        if (o[1] === "customer") {
                            if (o[2] !== `${this.wsClient.id}`) continue;
                            s = "player"
                        } else o[1] === "room" && (s = "room")
                }
                this.hotValues[s] = i
            }
        }
        return this
    }
    hydrateRefs() {
        const e = (n, r, s = !1, i = !1) => {
            const o = n.$ref ?? n.ref;
            if (o) {
                const a = this.hotValues[o];
                if (a === void 0)
                    if (i) console.warn(`[ecastPlugin] entity "${r}" referenced nonexistent optional entity "${o}"`);
                    else throw new Error(`[ecastPlugin] entity "${r}" referenced entity "${o}" but it does not exist`);
                Yfe(this.newValues, r, a)
            } else s && Object.entries(n).forEach(([a, l]) => {
                l !== null && typeof l == "object" && e(l, `${r}.${a}`, s, i)
            })
        };
        return Object.entries(this.newValues).forEach(([n, r]) => {
            r && Object.entries(r).forEach(([s, i]) => {
                i !== null && typeof i == "object" && e(i, `${n}.${s}`, this.keyHasDeepRefs(n), this.keyHasOptionalRefs(n))
            })
        }), this
    }
    keyHasDeepRefs(e) {
        var n, r, s, i;
        return !!((r = (n = this.keyMap) == null ? void 0 : n[e]) != null && r.hasDeepRefs || (i = (s = this.providerMap) == null ? void 0 : s[e]) != null && i.hasDeepRefs)
    }
    keyHasOptionalRefs(e) {
        var n, r, s, i;
        return !!((r = (n = this.keyMap) == null ? void 0 : n[e]) != null && r.hasOptionalRefs || (i = (s = this.providerMap) == null ? void 0 : s[e]) != null && i.hasOptionalRefs)
    }
    mapKeysToValues() {
        if (!this.keyMap) return this;
        for (let e = 0; e < this.keyMapKeys.length; e++) this.newValues[this.keyMapKeys[e]] = this.hotValues[this.keyMap[this.keyMapKeys[e]].key];
        return this
    }
    mapProvidersToValues() {
        if (!this.providerMap) return this;
        for (let e = 0; e < this.providerMapKeys.length; e++) this.newValues[this.providerMapKeys[e]] = this.providerMap[this.providerMapKeys[e]].fn(this.hotValues, this.wsClient);
        return this
    }
    deleteDropped() {
        const e = Object.keys(this.mappedValues);
        for (let n = 0; n < e.length; n++) this.newValues[e[n]] || delete this.mappedValues[e[n]];
        return this
    }
    syncExisting() {
        const e = Object.keys(this.newValues);
        for (let n = 0; n < e.length; n++) this.mappedValues[e[n]] = this.newValues[e[n]];
        return this.mappedValues
    }
    checkHostIsPausedChange() {
        const e = this.mappedValues.hostIsPaused;
        e && !this.isHostPaused ? (this.isHostPaused = !0, this.emit("hostDidPause")) : !e && this.isHostPaused && (this.isHostPaused = !1, this.emit("hostDidUnpause"))
    }
    addKeys(e) {
        this.keyMap || (this.keyMap = {}), Object.keys(e).forEach(n => {
            if (typeof e[n] == "function") {
                const r = e[n];
                this.keyMap[n] = {
                    key: r(this.wsClient),
                    hasDeepRefs: !1,
                    hasOptionalRefs: !1
                };
                return
            }
            if (typeof e[n] == "object") {
                const r = e[n];
                this.keyMap[n] = {
                    key: r.fn ? r.fn(this.wsClient) : r.key,
                    hasDeepRefs: r.hasDeepRefs ?? !1,
                    hasOptionalRefs: r.hasOptionalRefs ?? !1
                };
                return
            }
            this.keyMap[n] = {
                key: e[n]
            }
        }), this.keyMapKeys = Object.keys(this.keyMap), this.sync()
    }
    purgeKeys(e) {
        this.keyMap && (Object.keys(e).forEach(n => {
            this.keyMap[n] && delete this.keyMap[n]
        }), this.keyMapKeys = Object.keys(this.keyMap), this.sync())
    }
    addProviders(e) {
        this.providerMap || (this.providerMap = {}), Object.keys(e).forEach(n => {
            if (typeof e[n] == "object") {
                const r = e[n];
                this.providerMap[n] = {
                    fn: r.fn,
                    hasDeepRefs: r.hasDeepRefs ?? !1
                };
                return
            }
            this.providerMap[n] = {
                fn: e[n]
            }
        }), this.providerMapKeys = Object.keys(this.providerMap), this.sync()
    }
    purgeProviders(e) {
        this.providerMap && (Object.keys(e).forEach(n => {
            this.providerMap[n] && delete this.providerMap[n]
        }), this.providerMapKeys = Object.keys(this.providerMap), this.sync())
    }
    on(e, n) {
        const r = this.callbackMap.get(e) ?? new Set;
        r.size || this.callbackMap.set(e, r), r.add(n)
    }
    off(e, n) {
        const r = this.callbackMap.get(e);
        r && r.delete(n)
    }
    emit(e, n) {
        var r, s;
        if (this.pausedEvents && this.pausedEvents.includes(e)) {
            (r = this.callbackMap.get("didEmitPausedEvent")) == null || r.forEach(i => i(e));
            return
        }(s = this.callbackMap.get(e)) == null || s.forEach(i => i(n))
    }
    onConnection(e) {
        if (e.status === "connected") {
            this.emit("didReconnect");
            return
        }
        this.emit("isReconnecting", e.attempt ?? 0)
    }
    onClientConnected(e) {
        e.role === "host" && e.reconnect && this.emit("hostDidReconnect")
    }
    onClientDisconnected(e) {
        e.role === "host" && this.emit("hostDidDisconnect")
    }
    onRoomLock() {
        this.emit("roomDidLock")
    }
    onRoomExit() {
        this.emit("roomDidExit")
    }
    onClientKicked() {
        var e;
        this.isKicked = !0, (e = this.watchStopHandler) == null || e.call(this), this.emit("wasKicked")
    }
    onSocketClose() {
        this.isKicked || this.emit("didDisconnect")
    }
}
const Jr = new zfe,
    Kfe = {
        install: (t, e) => {
            t.config.globalProperties.$setupEcast = n => {
                Jr.setWSClient(n.wsClient), n.wsClient.on("artifact", r => wh.add(r)), n.wsClient.on("connection", r => {
                    r.status === "connected" && Jr.setupWatcher()
                }), Jr.sync(), t.config.globalProperties.$ecast = Jr.wsClient, t.config.globalProperties.$ecastManager = Jr, t.config.globalProperties.$ecastValues = Jr.mappedValues, t.config.globalProperties.$ecastRoom = n.room, t.config.globalProperties.$ecastWelcome = n.welcome, t.config.globalProperties.$syncEcast = Jr.sync, t.config.globalProperties.$pauseEcastUpdates = Jr.pause, t.config.globalProperties.$resumeEcastUpdates = Jr.resume, t.mixin({
                    beforeCreate() {
                        this.$options.ecastKeys && Jr.addKeys(this.$options.ecastKeys), this.$options.ecastProviders && Jr.addProviders(this.$options.ecastProviders)
                    },
                    beforeDestroy() {
                        this.$options.ecastKeys && Jr.purgeKeys(this.$options.ecastKeys), this.$options.ecastProviders && Jr.purgeProviders(this.$options.ecastProviders)
                    }
                })
            }, e != null && e.wsClient && t.config.globalProperties.$setupEcast(e)
        }
    },
    xu = {
        fatal: {
            error: Symbol("fatal.error")
        },
        modal: {
            active: Symbol("modal.active")
        },
        textDescriptions: {
            announcement: Symbol("textDescriptions.announcement")
        }
    },
    RO = Object.prototype.toString;

function MO(t) {
    switch (RO.call(t)) {
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
            return !0;
        default:
            return Ru(t, Error)
    }
}

function Pu(t, e) {
    return RO.call(t) === `[object ${e}]`
}

function DO(t) {
    return Pu(t, "ErrorEvent")
}

function P6(t) {
    return Pu(t, "DOMError")
}

function Zfe(t) {
    return Pu(t, "DOMException")
}

function wc(t) {
    return Pu(t, "String")
}

function Xfe(t) {
    return t === null || typeof t != "object" && typeof t != "function"
}

function hg(t) {
    return Pu(t, "Object")
}

function L3(t) {
    return typeof Event < "u" && Ru(t, Event)
}

function Qfe(t) {
    return typeof Element < "u" && Ru(t, Element)
}

function Jfe(t) {
    return Pu(t, "RegExp")
}

function $O(t) {
    return !!(t && t.then && typeof t.then == "function")
}

function ede(t) {
    return hg(t) && "nativeEvent" in t && "preventDefault" in t && "stopPropagation" in t
}

function tde(t) {
    return typeof t == "number" && t !== t
}

function Ru(t, e) {
    try {
        return t instanceof e
    } catch {
        return !1
    }
}

function _p(t) {
    return t && t.Math == Math ? t : void 0
}
const Ks = typeof globalThis == "object" && _p(globalThis) || typeof window == "object" && _p(window) || typeof self == "object" && _p(self) || typeof global == "object" && _p(global) || function() {
    return this
}() || {};

function Wf() {
    return Ks
}

function F3(t, e, n) {
    const r = n || Ks,
        s = r.__SENTRY__ = r.__SENTRY__ || {};
    return s[t] || (s[t] = e())
}
const nde = Wf(),
    rde = 80;

function ev(t, e = {}) {
    try {
        let n = t;
        const r = 5,
            s = [];
        let i = 0,
            o = 0;
        const a = " > ",
            l = a.length;
        let u;
        const f = Array.isArray(e) ? e : e.keyAttrs,
            d = !Array.isArray(e) && e.maxStringLength || rde;
        for (; n && i++ < r && (u = sde(n, f), !(u === "html" || i > 1 && o + s.length * l + u.length >= d));) s.push(u), o += u.length, n = n.parentNode;
        return s.reverse().join(a)
    } catch {
        return "<unknown>"
    }
}

function sde(t, e) {
    const n = t,
        r = [];
    let s, i, o, a, l;
    if (!n || !n.tagName) return "";
    r.push(n.tagName.toLowerCase());
    const u = e && e.length ? e.filter(d => n.getAttribute(d)).map(d => [d, n.getAttribute(d)]) : null;
    if (u && u.length) u.forEach(d => {
        r.push(`[${d[0]}="${d[1]}"]`)
    });
    else if (n.id && r.push(`#${n.id}`), s = n.className, s && wc(s))
        for (i = s.split(/\s+/), l = 0; l < i.length; l++) r.push(`.${i[l]}`);
    const f = ["aria-label", "type", "name", "title", "alt"];
    for (l = 0; l < f.length; l++) o = f[l], a = n.getAttribute(o), a && r.push(`[${o}="${a}"]`);
    return r.join("")
}

function ide() {
    try {
        return nde.document.location.href
    } catch {
        return ""
    }
}
class dh extends Error {
    constructor(e, n = "warn") {
        super(e), this.message = e, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = n
    }
}
const ode = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

function ade(t) {
    return t === "http" || t === "https"
}

function cde(t, e = !1) {
    const {
        host: n,
        path: r,
        pass: s,
        port: i,
        projectId: o,
        protocol: a,
        publicKey: l
    } = t;
    return `${a}://${l}${e&&s?`:${s}`:""}@${n}${i?`:${i}`:""}/${r&&`${r}/`}${o}`
}

function lde(t) {
    const e = ode.exec(t);
    if (!e) throw new dh(`Invalid Sentry Dsn: ${t}`);
    const [n, r, s = "", i, o = "", a] = e.slice(1);
    let l = "",
        u = a;
    const f = u.split("/");
    if (f.length > 1 && (l = f.slice(0, -1).join("/"), u = f.pop()), u) {
        const d = u.match(/^\d+/);
        d && (u = d[0])
    }
    return LO({
        host: i,
        pass: s,
        path: l,
        projectId: u,
        port: o,
        protocol: n,
        publicKey: r
    })
}

function LO(t) {
    return {
        protocol: t.protocol,
        publicKey: t.publicKey || "",
        pass: t.pass || "",
        host: t.host,
        port: t.port || "",
        path: t.path || "",
        projectId: t.projectId
    }
}

function ude(t) {
    if (!(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__)) return;
    const {
        port: e,
        projectId: n,
        protocol: r
    } = t;
    if (["protocol", "publicKey", "host", "projectId"].forEach(i => {
            if (!t[i]) throw new dh(`Invalid Sentry Dsn: ${i} missing`)
        }), !n.match(/^\d+$/)) throw new dh(`Invalid Sentry Dsn: Invalid projectId ${n}`);
    if (!ade(r)) throw new dh(`Invalid Sentry Dsn: Invalid protocol ${r}`);
    if (e && isNaN(parseInt(e, 10))) throw new dh(`Invalid Sentry Dsn: Invalid port ${e}`);
    return !0
}

function hde(t) {
    const e = typeof t == "string" ? lde(t) : LO(t);
    return ude(e), e
}
const fde = "Sentry Logger ",
    E1 = ["debug", "info", "warn", "error", "log", "assert", "trace"];

function FO(t) {
    if (!("console" in Ks)) return t();
    const e = Ks.console,
        n = {};
    E1.forEach(r => {
        const s = e[r] && e[r].__sentry_original__;
        r in e && s && (n[r] = e[r], e[r] = s)
    });
    try {
        return t()
    } finally {
        Object.keys(n).forEach(r => {
            e[r] = n[r]
        })
    }
}

function R6() {
    let t = !1;
    const e = {
        enable: () => {
            t = !0
        },
        disable: () => {
            t = !1
        }
    };
    return typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? E1.forEach(n => {
        e[n] = (...r) => {
            t && FO(() => {
                Ks.console[n](`${fde}[${n}]:`, ...r)
            })
        }
    }) : E1.forEach(n => {
        e[n] = () => {}
    }), e
}
let Cn;
typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? Cn = F3("logger", R6) : Cn = R6();

function M6(t, e = 0) {
    return typeof t != "string" || e === 0 || t.length <= e ? t : `${t.slice(0,e)}...`
}

function D6(t, e) {
    if (!Array.isArray(t)) return "";
    const n = [];
    for (let r = 0; r < t.length; r++) {
        const s = t[r];
        try {
            n.push(String(s))
        } catch {
            n.push("[value cannot be serialized]")
        }
    }
    return n.join(e)
}

function dde(t, e, n = !1) {
    return wc(t) ? Jfe(e) ? e.test(t) : wc(e) ? n ? t === e : t.includes(e) : !1 : !1
}

function fg(t, e = [], n = !1) {
    return e.some(r => dde(t, r, n))
}

function Jn(t, e, n) {
    if (!(e in t)) return;
    const r = t[e],
        s = n(r);
    if (typeof s == "function") try {
        BO(s, r)
    } catch {}
    t[e] = s
}

function UO(t, e, n) {
    Object.defineProperty(t, e, {
        value: n,
        writable: !0,
        configurable: !0
    })
}

function BO(t, e) {
    const n = e.prototype || {};
    t.prototype = e.prototype = n, UO(t, "__sentry_original__", e)
}

function U3(t) {
    return t.__sentry_original__
}

function qO(t) {
    if (MO(t)) return {
        message: t.message,
        name: t.name,
        stack: t.stack,
        ...L6(t)
    };
    if (L3(t)) {
        const e = {
            type: t.type,
            target: $6(t.target),
            currentTarget: $6(t.currentTarget),
            ...L6(t)
        };
        return typeof CustomEvent < "u" && Ru(t, CustomEvent) && (e.detail = t.detail), e
    } else return t
}

function $6(t) {
    try {
        return Qfe(t) ? ev(t) : Object.prototype.toString.call(t)
    } catch {
        return "<unknown>"
    }
}

function L6(t) {
    if (typeof t == "object" && t !== null) {
        const e = {};
        for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        return e
    } else return {}
}

function pde(t, e = 40) {
    const n = Object.keys(qO(t));
    if (n.sort(), !n.length) return "[object has no keys]";
    if (n[0].length >= e) return M6(n[0], e);
    for (let r = n.length; r > 0; r--) {
        const s = n.slice(0, r).join(", ");
        if (!(s.length > e)) return r === n.length ? s : M6(s, e)
    }
    return ""
}

function mde(t) {
    return tv(t, new Map)
}

function tv(t, e) {
    if (hg(t)) {
        const n = e.get(t);
        if (n !== void 0) return n;
        const r = {};
        e.set(t, r);
        for (const s of Object.keys(t)) typeof t[s] < "u" && (r[s] = tv(t[s], e));
        return r
    }
    if (Array.isArray(t)) {
        const n = e.get(t);
        if (n !== void 0) return n;
        const r = [];
        return e.set(t, r), t.forEach(s => {
            r.push(tv(s, e))
        }), r
    }
    return t
}
const jy = "<anonymous>";

function fa(t) {
    try {
        return !t || typeof t != "function" ? jy : t.name || jy
    } catch {
        return jy
    }
}
const nv = Wf();

function gde() {
    if (!("fetch" in nv)) return !1;
    try {
        return new Headers, new Request("http://www.example.com"), new Response, !0
    } catch {
        return !1
    }
}

function F6(t) {
    return t && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
}

function _de() {
    if (!gde()) return !1;
    if (F6(nv.fetch)) return !0;
    let t = !1;
    const e = nv.document;
    if (e && typeof e.createElement == "function") try {
        const n = e.createElement("iframe");
        n.hidden = !0, e.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (t = F6(n.contentWindow.fetch)), e.head.removeChild(n)
    } catch (n) {
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n)
    }
    return t
}
const yp = Wf();

function yde() {
    const t = yp.chrome,
        e = t && t.app && t.app.runtime,
        n = "history" in yp && !!yp.history.pushState && !!yp.history.replaceState;
    return !e && n
}
const hn = Wf(),
    ph = "__sentry_xhr_v2__",
    Nh = {},
    U6 = {};

function vde(t) {
    if (!U6[t]) switch (U6[t] = !0, t) {
        case "console":
            bde();
            break;
        case "dom":
            kde();
            break;
        case "xhr":
            Sde();
            break;
        case "fetch":
            Ede();
            break;
        case "history":
            wde();
            break;
        case "error":
            Ide();
            break;
        case "unhandledrejection":
            Nde();
            break;
        default:
            (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.warn("unknown instrumentation type:", t);
            return
    }
}

function oc(t, e) {
    Nh[t] = Nh[t] || [], Nh[t].push(e), vde(t)
}

function Zs(t, e) {
    if (!(!t || !Nh[t]))
        for (const n of Nh[t] || []) try {
            n(e)
        } catch (r) {
            (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${fa(n)}
Error:`, r)
        }
}

function bde() {
    "console" in hn && E1.forEach(function(t) {
        t in hn.console && Jn(hn.console, t, function(e) {
            return function(...n) {
                Zs("console", {
                    args: n,
                    level: t
                }), e && e.apply(hn.console, n)
            }
        })
    })
}

function Ede() {
    _de() && Jn(hn, "fetch", function(t) {
        return function(...e) {
            const {
                method: n,
                url: r
            } = Tde(e), s = {
                args: e,
                fetchData: {
                    method: n,
                    url: r
                },
                startTimestamp: Date.now()
            };
            return Zs("fetch", {
                ...s
            }), t.apply(hn, e).then(i => (Zs("fetch", {
                ...s,
                endTimestamp: Date.now(),
                response: i
            }), i), i => {
                throw Zs("fetch", {
                    ...s,
                    endTimestamp: Date.now(),
                    error: i
                }), i
            })
        }
    })
}

function rv(t, e) {
    return !!t && typeof t == "object" && !!t[e]
}

function B6(t) {
    return typeof t == "string" ? t : t ? rv(t, "url") ? t.url : t.toString ? t.toString() : "" : ""
}

function Tde(t) {
    if (t.length === 0) return {
        method: "GET",
        url: ""
    };
    if (t.length === 2) {
        const [n, r] = t;
        return {
            url: B6(n),
            method: rv(r, "method") ? String(r.method).toUpperCase() : "GET"
        }
    }
    const e = t[0];
    return {
        url: B6(e),
        method: rv(e, "method") ? String(e.method).toUpperCase() : "GET"
    }
}

function Sde() {
    if (!("XMLHttpRequest" in hn)) return;
    const t = XMLHttpRequest.prototype;
    Jn(t, "open", function(e) {
        return function(...n) {
            const r = n[1],
                s = this[ph] = {
                    method: wc(n[0]) ? n[0].toUpperCase() : n[0],
                    url: n[1],
                    request_headers: {}
                };
            wc(r) && s.method === "POST" && r.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
            const i = () => {
                const o = this[ph];
                if (o && this.readyState === 4) {
                    try {
                        o.status_code = this.status
                    } catch {}
                    Zs("xhr", {
                        args: n,
                        endTimestamp: Date.now(),
                        startTimestamp: Date.now(),
                        xhr: this
                    })
                }
            };
            return "onreadystatechange" in this && typeof this.onreadystatechange == "function" ? Jn(this, "onreadystatechange", function(o) {
                return function(...a) {
                    return i(), o.apply(this, a)
                }
            }) : this.addEventListener("readystatechange", i), Jn(this, "setRequestHeader", function(o) {
                return function(...a) {
                    const [l, u] = a, f = this[ph];
                    return f && (f.request_headers[l.toLowerCase()] = u), o.apply(this, a)
                }
            }), e.apply(this, n)
        }
    }), Jn(t, "send", function(e) {
        return function(...n) {
            const r = this[ph];
            return r && n[0] !== void 0 && (r.body = n[0]), Zs("xhr", {
                args: n,
                startTimestamp: Date.now(),
                xhr: this
            }), e.apply(this, n)
        }
    })
}
let vp;

function wde() {
    if (!yde()) return;
    const t = hn.onpopstate;
    hn.onpopstate = function(...n) {
        const r = hn.location.href,
            s = vp;
        if (vp = r, Zs("history", {
                from: s,
                to: r
            }), t) try {
            return t.apply(this, n)
        } catch {}
    };

    function e(n) {
        return function(...r) {
            const s = r.length > 2 ? r[2] : void 0;
            if (s) {
                const i = vp,
                    o = String(s);
                vp = o, Zs("history", {
                    from: i,
                    to: o
                })
            }
            return n.apply(this, r)
        }
    }
    Jn(hn.history, "pushState", e), Jn(hn.history, "replaceState", e)
}
const Ade = 1e3;
let bp, Ep;

function Ode(t, e) {
    if (!t || t.type !== e.type) return !0;
    try {
        if (t.target !== e.target) return !0
    } catch {}
    return !1
}

function Cde(t) {
    if (t.type !== "keypress") return !1;
    try {
        const e = t.target;
        if (!e || !e.tagName) return !0;
        if (e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable) return !1
    } catch {}
    return !0
}

function q6(t, e = !1) {
    return n => {
        if (!n || Ep === n || Cde(n)) return;
        const r = n.type === "keypress" ? "input" : n.type;
        bp === void 0 ? (t({
            event: n,
            name: r,
            global: e
        }), Ep = n) : Ode(Ep, n) && (t({
            event: n,
            name: r,
            global: e
        }), Ep = n), clearTimeout(bp), bp = hn.setTimeout(() => {
            bp = void 0
        }, Ade)
    }
}

function kde() {
    if (!("document" in hn)) return;
    const t = Zs.bind(null, "dom"),
        e = q6(t, !0);
    hn.document.addEventListener("click", e, !1), hn.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach(n => {
        const r = hn[n] && hn[n].prototype;
        !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (Jn(r, "addEventListener", function(s) {
            return function(i, o, a) {
                if (i === "click" || i == "keypress") try {
                    const l = this,
                        u = l.__sentry_instrumentation_handlers__ = l.__sentry_instrumentation_handlers__ || {},
                        f = u[i] = u[i] || {
                            refCount: 0
                        };
                    if (!f.handler) {
                        const d = q6(t);
                        f.handler = d, s.call(this, i, d, a)
                    }
                    f.refCount++
                } catch {}
                return s.call(this, i, o, a)
            }
        }), Jn(r, "removeEventListener", function(s) {
            return function(i, o, a) {
                if (i === "click" || i == "keypress") try {
                    const l = this,
                        u = l.__sentry_instrumentation_handlers__ || {},
                        f = u[i];
                    f && (f.refCount--, f.refCount <= 0 && (s.call(this, i, f.handler, a), f.handler = void 0, delete u[i]), Object.keys(u).length === 0 && delete l.__sentry_instrumentation_handlers__)
                } catch {}
                return s.call(this, i, o, a)
            }
        }))
    })
}
let Tp = null;

function Ide() {
    Tp = hn.onerror, hn.onerror = function(t, e, n, r, s) {
        return Zs("error", {
            column: r,
            error: s,
            line: n,
            msg: t,
            url: e
        }), Tp && !Tp.__SENTRY_LOADER__ ? Tp.apply(this, arguments) : !1
    }, hn.onerror.__SENTRY_INSTRUMENTED__ = !0
}
let Sp = null;

function Nde() {
    Sp = hn.onunhandledrejection, hn.onunhandledrejection = function(t) {
        return Zs("unhandledrejection", t), Sp && !Sp.__SENTRY_LOADER__ ? Sp.apply(this, arguments) : !0
    }, hn.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
}

function xde() {
    const t = typeof WeakSet == "function",
        e = t ? new WeakSet : [];

    function n(s) {
        if (t) return e.has(s) ? !0 : (e.add(s), !1);
        for (let i = 0; i < e.length; i++)
            if (e[i] === s) return !0;
        return e.push(s), !1
    }

    function r(s) {
        if (t) e.delete(s);
        else
            for (let i = 0; i < e.length; i++)
                if (e[i] === s) {
                    e.splice(i, 1);
                    break
                }
    }
    return [n, r]
}

function xh() {
    const t = Ks,
        e = t.crypto || t.msCrypto;
    if (e && e.randomUUID) return e.randomUUID().replace(/-/g, "");
    const n = e && e.getRandomValues ? () => e.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;
    return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, r => (r ^ (n() & 15) >> r / 4).toString(16))
}

function GO(t) {
    return t.exception && t.exception.values ? t.exception.values[0] : void 0
}

function jo(t) {
    const {
        message: e,
        event_id: n
    } = t;
    if (e) return e;
    const r = GO(t);
    return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>"
}

function sv(t, e, n) {
    const r = t.exception = t.exception || {},
        s = r.values = r.values || [],
        i = s[0] = s[0] || {};
    i.value || (i.value = e || ""), i.type || (i.type = n || "Error")
}

function T1(t, e) {
    const n = GO(t);
    if (!n) return;
    const r = {
            type: "generic",
            handled: !0
        },
        s = n.mechanism;
    if (n.mechanism = {
            ...r,
            ...s,
            ...e
        }, e && "data" in e) {
        const i = {
            ...s && s.data,
            ...e.data
        };
        n.mechanism.data = i
    }
}

function Pde(t) {
    return Array.isArray(t) ? t : [t]
}

function Rde() {
    return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__
}

function Mde() {
    return !Rde() && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]"
}

function Dde(t, e) {
    return t.require(e)
}

function $de(t, e = 100, n = 1 / 0) {
    try {
        return iv("", t, e, n)
    } catch (r) {
        return {
            ERROR: `**non-serializable** (${r})`
        }
    }
}

function VO(t, e = 3, n = 100 * 1024) {
    const r = $de(t, e);
    return Bde(r) > n ? VO(t, e - 1, n) : r
}

function iv(t, e, n = 1 / 0, r = 1 / 0, s = xde()) {
    const [i, o] = s;
    if (e == null || ["number", "boolean", "string"].includes(typeof e) && !tde(e)) return e;
    const a = Lde(t, e);
    if (!a.startsWith("[object ")) return a;
    if (e.__sentry_skip_normalization__) return e;
    const l = typeof e.__sentry_override_normalization_depth__ == "number" ? e.__sentry_override_normalization_depth__ : n;
    if (l === 0) return a.replace("object ", "");
    if (i(e)) return "[Circular ~]";
    const u = e;
    if (u && typeof u.toJSON == "function") try {
        const _ = u.toJSON();
        return iv("", _, l - 1, r, s)
    } catch {}
    const f = Array.isArray(e) ? [] : {};
    let d = 0;
    const p = qO(e);
    for (const _ in p) {
        if (!Object.prototype.hasOwnProperty.call(p, _)) continue;
        if (d >= r) {
            f[_] = "[MaxProperties ~]";
            break
        }
        const v = p[_];
        f[_] = iv(_, v, l - 1, r, s), d++
    }
    return o(e), f
}

function Lde(t, e) {
    try {
        if (t === "domain" && e && typeof e == "object" && e._events) return "[Domain]";
        if (t === "domainEmitter") return "[DomainEmitter]";
        if (typeof global < "u" && e === global) return "[Global]";
        if (typeof window < "u" && e === window) return "[Window]";
        if (typeof document < "u" && e === document) return "[Document]";
        if (ede(e)) return "[SyntheticEvent]";
        if (typeof e == "number" && e !== e) return "[NaN]";
        if (typeof e == "function") return `[Function: ${fa(e)}]`;
        if (typeof e == "symbol") return `[${String(e)}]`;
        if (typeof e == "bigint") return `[BigInt: ${String(e)}]`;
        const n = Fde(e);
        return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`
    } catch (n) {
        return `**non-serializable** (${n})`
    }
}

function Fde(t) {
    const e = Object.getPrototypeOf(t);
    return e ? e.constructor.name : "null prototype"
}

function Ude(t) {
    return ~-encodeURI(t).split(/%..|./).length
}

function Bde(t) {
    return Ude(JSON.stringify(t))
}
var eo;
(function(t) {
    t[t.PENDING = 0] = "PENDING";
    const n = 1;
    t[t.RESOLVED = n] = "RESOLVED";
    const r = 2;
    t[t.REJECTED = r] = "REJECTED"
})(eo || (eo = {}));
class _i {
    __init() {
        this._state = eo.PENDING
    }
    __init2() {
        this._handlers = []
    }
    constructor(e) {
        _i.prototype.__init.call(this), _i.prototype.__init2.call(this), _i.prototype.__init3.call(this), _i.prototype.__init4.call(this), _i.prototype.__init5.call(this), _i.prototype.__init6.call(this);
        try {
            e(this._resolve, this._reject)
        } catch (n) {
            this._reject(n)
        }
    }
    then(e, n) {
        return new _i((r, s) => {
            this._handlers.push([!1, i => {
                if (!e) r(i);
                else try {
                    r(e(i))
                } catch (o) {
                    s(o)
                }
            }, i => {
                if (!n) s(i);
                else try {
                    r(n(i))
                } catch (o) {
                    s(o)
                }
            }]), this._executeHandlers()
        })
    } catch (e) {
        return this.then(n => n, e)
    } finally(e) {
        return new _i((n, r) => {
            let s, i;
            return this.then(o => {
                i = !1, s = o, e && e()
            }, o => {
                i = !0, s = o, e && e()
            }).then(() => {
                if (i) {
                    r(s);
                    return
                }
                n(s)
            })
        })
    }
    __init3() {
        this._resolve = e => {
            this._setResult(eo.RESOLVED, e)
        }
    }
    __init4() {
        this._reject = e => {
            this._setResult(eo.REJECTED, e)
        }
    }
    __init5() {
        this._setResult = (e, n) => {
            if (this._state === eo.PENDING) {
                if ($O(n)) {
                    n.then(this._resolve, this._reject);
                    return
                }
                this._state = e, this._value = n, this._executeHandlers()
            }
        }
    }
    __init6() {
        this._executeHandlers = () => {
            if (this._state === eo.PENDING) return;
            const e = this._handlers.slice();
            this._handlers = [], e.forEach(n => {
                n[0] || (this._state === eo.RESOLVED && n[1](this._value), this._state === eo.REJECTED && n[2](this._value), n[0] = !0)
            })
        }
    }
}

function Wy(t) {
    if (!t) return {};
    const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!e) return {};
    const n = e[6] || "",
        r = e[8] || "";
    return {
        host: e[4],
        path: e[5],
        protocol: e[2],
        search: n,
        hash: r,
        relative: e[5] + n + r
    }
}
const qde = ["fatal", "error", "warning", "log", "info", "debug"];

function Gde(t) {
    return t === "warn" ? "warning" : qde.includes(t) ? t : "log"
}
const jO = Wf(),
    ov = {
        nowSeconds: () => Date.now() / 1e3
    };

function Vde() {
    const {
        performance: t
    } = jO;
    if (!t || !t.now) return;
    const e = Date.now() - t.now();
    return {
        now: () => t.now(),
        timeOrigin: e
    }
}

function jde() {
    try {
        return Dde(module, "perf_hooks").performance
    } catch {
        return
    }
}
const Hy = Mde() ? jde() : Vde(),
    G6 = Hy === void 0 ? ov : {
        nowSeconds: () => (Hy.timeOrigin + Hy.now()) / 1e3
    },
    WO = ov.nowSeconds.bind(ov),
    HO = G6.nowSeconds.bind(G6);
(() => {
    const {
        performance: t
    } = jO;
    if (!t || !t.now) return;
    const e = 3600 * 1e3,
        n = t.now(),
        r = Date.now(),
        s = t.timeOrigin ? Math.abs(t.timeOrigin + n - r) : e,
        i = s < e,
        o = t.timing && t.timing.navigationStart,
        l = typeof o == "number" ? Math.abs(o + n - r) : e,
        u = l < e;
    return i || u ? s <= l ? t.timeOrigin : o : r
})();
const Wde = "production";

function Hde(t) {
    const e = HO(),
        n = {
            sid: xh(),
            init: !0,
            timestamp: e,
            started: e,
            duration: 0,
            status: "ok",
            errors: 0,
            ignoreDuration: !1,
            toJSON: () => zde(n)
        };
    return t && dg(n, t), n
}

function dg(t, e = {}) {
    if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address), !t.did && !e.did && (t.did = e.user.id || e.user.email || e.user.username)), t.timestamp = e.timestamp || HO(), e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration), e.sid && (t.sid = e.sid.length === 32 ? e.sid : xh()), e.init !== void 0 && (t.init = e.init), !t.did && e.did && (t.did = `${e.did}`), typeof e.started == "number" && (t.started = e.started), t.ignoreDuration) t.duration = void 0;
    else if (typeof e.duration == "number") t.duration = e.duration;
    else {
        const n = t.timestamp - t.started;
        t.duration = n >= 0 ? n : 0
    }
    e.release && (t.release = e.release), e.environment && (t.environment = e.environment), !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress), !t.userAgent && e.userAgent && (t.userAgent = e.userAgent), typeof e.errors == "number" && (t.errors = e.errors), e.status && (t.status = e.status)
}

function Yde(t, e) {
    let n = {};
    e ? n = {
        status: e
    } : t.status === "ok" && (n = {
        status: "exited"
    }), dg(t, n)
}

function zde(t) {
    return mde({
        sid: `${t.sid}`,
        init: t.init,
        started: new Date(t.started * 1e3).toISOString(),
        timestamp: new Date(t.timestamp * 1e3).toISOString(),
        status: t.status,
        errors: t.errors,
        did: typeof t.did == "number" || typeof t.did == "string" ? `${t.did}` : void 0,
        duration: t.duration,
        attrs: {
            release: t.release,
            environment: t.environment,
            ip_address: t.ipAddress,
            user_agent: t.userAgent
        }
    })
}
const Kde = 100;
class Pl {
    constructor() {
        this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}
    }
    static clone(e) {
        const n = new Pl;
        return e && (n._breadcrumbs = [...e._breadcrumbs], n._tags = {
            ...e._tags
        }, n._extra = {
            ...e._extra
        }, n._contexts = {
            ...e._contexts
        }, n._user = e._user, n._level = e._level, n._span = e._span, n._session = e._session, n._transactionName = e._transactionName, n._fingerprint = e._fingerprint, n._eventProcessors = [...e._eventProcessors], n._requestSession = e._requestSession, n._attachments = [...e._attachments], n._sdkProcessingMetadata = {
            ...e._sdkProcessingMetadata
        }), n
    }
    addScopeListener(e) {
        this._scopeListeners.push(e)
    }
    addEventProcessor(e) {
        return this._eventProcessors.push(e), this
    }
    setUser(e) {
        return this._user = e || {}, this._session && dg(this._session, {
            user: e
        }), this._notifyScopeListeners(), this
    }
    getUser() {
        return this._user
    }
    getRequestSession() {
        return this._requestSession
    }
    setRequestSession(e) {
        return this._requestSession = e, this
    }
    setTags(e) {
        return this._tags = {
            ...this._tags,
            ...e
        }, this._notifyScopeListeners(), this
    }
    setTag(e, n) {
        return this._tags = {
            ...this._tags,
            [e]: n
        }, this._notifyScopeListeners(), this
    }
    setExtras(e) {
        return this._extra = {
            ...this._extra,
            ...e
        }, this._notifyScopeListeners(), this
    }
    setExtra(e, n) {
        return this._extra = {
            ...this._extra,
            [e]: n
        }, this._notifyScopeListeners(), this
    }
    setFingerprint(e) {
        return this._fingerprint = e, this._notifyScopeListeners(), this
    }
    setLevel(e) {
        return this._level = e, this._notifyScopeListeners(), this
    }
    setTransactionName(e) {
        return this._transactionName = e, this._notifyScopeListeners(), this
    }
    setContext(e, n) {
        return n === null ? delete this._contexts[e] : this._contexts[e] = n, this._notifyScopeListeners(), this
    }
    setSpan(e) {
        return this._span = e, this._notifyScopeListeners(), this
    }
    getSpan() {
        return this._span
    }
    getTransaction() {
        const e = this.getSpan();
        return e && e.transaction
    }
    setSession(e) {
        return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this
    }
    getSession() {
        return this._session
    }
    update(e) {
        if (!e) return this;
        if (typeof e == "function") {
            const n = e(this);
            return n instanceof Pl ? n : this
        }
        return e instanceof Pl ? (this._tags = {
            ...this._tags,
            ...e._tags
        }, this._extra = {
            ...this._extra,
            ...e._extra
        }, this._contexts = {
            ...this._contexts,
            ...e._contexts
        }, e._user && Object.keys(e._user).length && (this._user = e._user), e._level && (this._level = e._level), e._fingerprint && (this._fingerprint = e._fingerprint), e._requestSession && (this._requestSession = e._requestSession)) : hg(e) && (e = e, this._tags = {
            ...this._tags,
            ...e.tags
        }, this._extra = {
            ...this._extra,
            ...e.extra
        }, this._contexts = {
            ...this._contexts,
            ...e.contexts
        }, e.user && (this._user = e.user), e.level && (this._level = e.level), e.fingerprint && (this._fingerprint = e.fingerprint), e.requestSession && (this._requestSession = e.requestSession)), this
    }
    clear() {
        return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this
    }
    addBreadcrumb(e, n) {
        const r = typeof n == "number" ? n : Kde;
        if (r <= 0) return this;
        const s = {
            timestamp: WO(),
            ...e
        };
        return this._breadcrumbs = [...this._breadcrumbs, s].slice(-r), this._notifyScopeListeners(), this
    }
    getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1]
    }
    clearBreadcrumbs() {
        return this._breadcrumbs = [], this._notifyScopeListeners(), this
    }
    addAttachment(e) {
        return this._attachments.push(e), this
    }
    getAttachments() {
        return this._attachments
    }
    clearAttachments() {
        return this._attachments = [], this
    }
    applyToEvent(e, n = {}) {
        if (this._extra && Object.keys(this._extra).length && (e.extra = {
                ...this._extra,
                ...e.extra
            }), this._tags && Object.keys(this._tags).length && (e.tags = {
                ...this._tags,
                ...e.tags
            }), this._user && Object.keys(this._user).length && (e.user = {
                ...this._user,
                ...e.user
            }), this._contexts && Object.keys(this._contexts).length && (e.contexts = {
                ...this._contexts,
                ...e.contexts
            }), this._level && (e.level = this._level), this._transactionName && (e.transaction = this._transactionName), this._span) {
            e.contexts = {
                trace: this._span.getTraceContext(),
                ...e.contexts
            };
            const r = this._span.transaction;
            if (r) {
                e.sdkProcessingMetadata = {
                    dynamicSamplingContext: r.getDynamicSamplingContext(),
                    ...e.sdkProcessingMetadata
                };
                const s = r.name;
                s && (e.tags = {
                    transaction: s,
                    ...e.tags
                })
            }
        }
        return this._applyFingerprint(e), e.breadcrumbs = [...e.breadcrumbs || [], ...this._breadcrumbs], e.breadcrumbs = e.breadcrumbs.length > 0 ? e.breadcrumbs : void 0, e.sdkProcessingMetadata = {
            ...e.sdkProcessingMetadata,
            ...this._sdkProcessingMetadata
        }, this._notifyEventProcessors([...YO(), ...this._eventProcessors], e, n)
    }
    setSDKProcessingMetadata(e) {
        return this._sdkProcessingMetadata = {
            ...this._sdkProcessingMetadata,
            ...e
        }, this
    }
    _notifyEventProcessors(e, n, r, s = 0) {
        return new _i((i, o) => {
            const a = e[s];
            if (n === null || typeof a != "function") i(n);
            else {
                const l = a({
                    ...n
                }, r);
                (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && a.id && l === null && Cn.log(`Event processor "${a.id}" dropped event`), $O(l) ? l.then(u => this._notifyEventProcessors(e, u, r, s + 1).then(i)).then(null, o) : this._notifyEventProcessors(e, l, r, s + 1).then(i).then(null, o)
            }
        })
    }
    _notifyScopeListeners() {
        this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(e => {
            e(this)
        }), this._notifyingListeners = !1)
    }
    _applyFingerprint(e) {
        e.fingerprint = e.fingerprint ? Pde(e.fingerprint) : [], this._fingerprint && (e.fingerprint = e.fingerprint.concat(this._fingerprint)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint
    }
}

function YO() {
    return F3("globalEventProcessors", () => [])
}

function zO(t) {
    YO().push(t)
}
const KO = 4,
    Zde = 100;
class ZO {
    constructor(e, n = new Pl, r = KO) {
        this._version = r, this._stack = [{
            scope: n
        }], e && this.bindClient(e)
    }
    isOlderThan(e) {
        return this._version < e
    }
    bindClient(e) {
        const n = this.getStackTop();
        n.client = e, e && e.setupIntegrations && e.setupIntegrations()
    }
    pushScope() {
        const e = Pl.clone(this.getScope());
        return this.getStack().push({
            client: this.getClient(),
            scope: e
        }), e
    }
    popScope() {
        return this.getStack().length <= 1 ? !1 : !!this.getStack().pop()
    }
    withScope(e) {
        const n = this.pushScope();
        try {
            e(n)
        } finally {
            this.popScope()
        }
    }
    getClient() {
        return this.getStackTop().client
    }
    getScope() {
        return this.getStackTop().scope
    }
    getStack() {
        return this._stack
    }
    getStackTop() {
        return this._stack[this._stack.length - 1]
    }
    captureException(e, n) {
        const r = this._lastEventId = n && n.event_id ? n.event_id : xh(),
            s = new Error("Sentry syntheticException");
        return this._withClient((i, o) => {
            i.captureException(e, {
                originalException: e,
                syntheticException: s,
                ...n,
                event_id: r
            }, o)
        }), r
    }
    captureMessage(e, n, r) {
        const s = this._lastEventId = r && r.event_id ? r.event_id : xh(),
            i = new Error(e);
        return this._withClient((o, a) => {
            o.captureMessage(e, n, {
                originalException: e,
                syntheticException: i,
                ...r,
                event_id: s
            }, a)
        }), s
    }
    captureEvent(e, n) {
        const r = n && n.event_id ? n.event_id : xh();
        return e.type || (this._lastEventId = r), this._withClient((s, i) => {
            s.captureEvent(e, {
                ...n,
                event_id: r
            }, i)
        }), r
    }
    lastEventId() {
        return this._lastEventId
    }
    addBreadcrumb(e, n) {
        const {
            scope: r,
            client: s
        } = this.getStackTop();
        if (!s) return;
        const {
            beforeBreadcrumb: i = null,
            maxBreadcrumbs: o = Zde
        } = s.getOptions && s.getOptions() || {};
        if (o <= 0) return;
        const l = {
                timestamp: WO(),
                ...e
            },
            u = i ? FO(() => i(l, n)) : l;
        u !== null && (s.emit && s.emit("beforeAddBreadcrumb", u, n), r.addBreadcrumb(u, o))
    }
    setUser(e) {
        this.getScope().setUser(e)
    }
    setTags(e) {
        this.getScope().setTags(e)
    }
    setExtras(e) {
        this.getScope().setExtras(e)
    }
    setTag(e, n) {
        this.getScope().setTag(e, n)
    }
    setExtra(e, n) {
        this.getScope().setExtra(e, n)
    }
    setContext(e, n) {
        this.getScope().setContext(e, n)
    }
    configureScope(e) {
        const {
            scope: n,
            client: r
        } = this.getStackTop();
        r && e(n)
    }
    run(e) {
        const n = V6(this);
        try {
            e(this)
        } finally {
            V6(n)
        }
    }
    getIntegration(e) {
        const n = this.getClient();
        if (!n) return null;
        try {
            return n.getIntegration(e)
        } catch {
            return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.warn(`Cannot retrieve integration ${e.id} from the current Hub`), null
        }
    }
    startTransaction(e, n) {
        const r = this._callExtensionMethod("startTransaction", e, n);
        return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && !r && console.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`), r
    }
    traceHeaders() {
        return this._callExtensionMethod("traceHeaders")
    }
    captureSession(e = !1) {
        if (e) return this.endSession();
        this._sendSessionUpdate()
    }
    endSession() {
        const n = this.getStackTop().scope,
            r = n.getSession();
        r && Yde(r), this._sendSessionUpdate(), n.setSession()
    }
    startSession(e) {
        const {
            scope: n,
            client: r
        } = this.getStackTop(), {
            release: s,
            environment: i = Wde
        } = r && r.getOptions() || {}, {
            userAgent: o
        } = Ks.navigator || {}, a = Hde({
            release: s,
            environment: i,
            user: n.getUser(),
            ...o && {
                userAgent: o
            },
            ...e
        }), l = n.getSession && n.getSession();
        return l && l.status === "ok" && dg(l, {
            status: "exited"
        }), this.endSession(), n.setSession(a), a
    }
    shouldSendDefaultPii() {
        const e = this.getClient(),
            n = e && e.getOptions();
        return !!(n && n.sendDefaultPii)
    }
    _sendSessionUpdate() {
        const {
            scope: e,
            client: n
        } = this.getStackTop(), r = e.getSession();
        r && n && n.captureSession && n.captureSession(r)
    }
    _withClient(e) {
        const {
            scope: n,
            client: r
        } = this.getStackTop();
        r && e(r, n)
    }
    _callExtensionMethod(e, ...n) {
        const s = pg().__SENTRY__;
        if (s && s.extensions && typeof s.extensions[e] == "function") return s.extensions[e].apply(this, n);
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.warn(`Extension method ${e} couldn't be found, doing nothing.`)
    }
}

function pg() {
    return Ks.__SENTRY__ = Ks.__SENTRY__ || {
        extensions: {},
        hub: void 0
    }, Ks
}

function V6(t) {
    const e = pg(),
        n = av(e);
    return XO(e, t), n
}

function wr() {
    const t = pg();
    if (t.__SENTRY__ && t.__SENTRY__.acs) {
        const e = t.__SENTRY__.acs.getCurrentHub();
        if (e) return e
    }
    return Xde(t)
}

function Xde(t = pg()) {
    return (!Qde(t) || av(t).isOlderThan(KO)) && XO(t, new ZO), av(t)
}

function Qde(t) {
    return !!(t && t.__SENTRY__ && t.__SENTRY__.hub)
}

function av(t) {
    return F3("hub", () => new ZO, t)
}

function XO(t, e) {
    if (!t) return !1;
    const n = t.__SENTRY__ = t.__SENTRY__ || {};
    return n.hub = e, !0
}

function Jde(t, e) {
    return wr().captureException(t, {
        captureContext: e
    })
}

function epe(t) {
    wr().withScope(t)
}

function tpe(t) {
    const e = t.protocol ? `${t.protocol}:` : "",
        n = t.port ? `:${t.port}` : "";
    return `${e}//${t.host}${n}${t.path?`/${t.path}`:""}/api/`
}

function npe(t, e) {
    const n = hde(t),
        r = `${tpe(n)}embed/error-page/`;
    let s = `dsn=${cde(n)}`;
    for (const i in e)
        if (i !== "dsn")
            if (i === "user") {
                const o = e.user;
                if (!o) continue;
                o.name && (s += `&name=${encodeURIComponent(o.name)}`), o.email && (s += `&email=${encodeURIComponent(o.email)}`)
            } else s += `&${encodeURIComponent(i)}=${encodeURIComponent(e[i])}`;
    return `${r}?${s}`
}
let j6;
class Qh {
    constructor() {
        Qh.prototype.__init.call(this)
    }
    static __initStatic() {
        this.id = "FunctionToString"
    }
    __init() {
        this.name = Qh.id
    }
    setupOnce() {
        j6 = Function.prototype.toString;
        try {
            Function.prototype.toString = function(...e) {
                const n = U3(this) || this;
                return j6.apply(n, e)
            }
        } catch {}
    }
}
Qh.__initStatic();
const rpe = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
class Rl {
    static __initStatic() {
        this.id = "InboundFilters"
    }
    __init() {
        this.name = Rl.id
    }
    constructor(e = {}) {
        this._options = e, Rl.prototype.__init.call(this)
    }
    setupOnce(e, n) {
        const r = s => {
            const i = n();
            if (i) {
                const o = i.getIntegration(Rl);
                if (o) {
                    const a = i.getClient(),
                        l = a ? a.getOptions() : {},
                        u = spe(o._options, l);
                    return ipe(s, u) ? null : s
                }
            }
            return s
        };
        r.id = this.name, e(r)
    }
}
Rl.__initStatic();

function spe(t = {}, e = {}) {
    return {
        allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
        denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
        ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...rpe],
        ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []],
        ignoreInternal: t.ignoreInternal !== void 0 ? t.ignoreInternal : !0
    }
}

function ipe(t, e) {
    return e.ignoreInternal && hpe(t) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.warn(`Event dropped due to being internal Sentry Error.
Event: ${jo(t)}`), !0) : ope(t, e.ignoreErrors) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${jo(t)}`), !0) : ape(t, e.ignoreTransactions) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${jo(t)}`), !0) : cpe(t, e.denyUrls) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${jo(t)}.
Url: ${S1(t)}`), !0) : lpe(t, e.allowUrls) ? !1 : ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${jo(t)}.
Url: ${S1(t)}`), !0)
}

function ope(t, e) {
    return t.type || !e || !e.length ? !1 : upe(t).some(n => fg(n, e))
}

function ape(t, e) {
    if (t.type !== "transaction" || !e || !e.length) return !1;
    const n = t.transaction;
    return n ? fg(n, e) : !1
}

function cpe(t, e) {
    if (!e || !e.length) return !1;
    const n = S1(t);
    return n ? fg(n, e) : !1
}

function lpe(t, e) {
    if (!e || !e.length) return !0;
    const n = S1(t);
    return n ? fg(n, e) : !0
}

function upe(t) {
    if (t.message) return [t.message];
    if (t.exception) {
        const {
            values: e
        } = t.exception;
        try {
            const {
                type: n = "",
                value: r = ""
            } = e && e[e.length - 1] || {};
            return [`${r}`, `${n}: ${r}`]
        } catch {
            return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.error(`Cannot extract message for event ${jo(t)}`), []
        }
    }
    return []
}

function hpe(t) {
    try {
        return t.exception.values[0].type === "SentryError"
    } catch {}
    return !1
}

function fpe(t = []) {
    for (let e = t.length - 1; e >= 0; e--) {
        const n = t[e];
        if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]") return n.filename || null
    }
    return null
}

function S1(t) {
    try {
        let e;
        try {
            e = t.exception.values[0].stacktrace.frames
        } catch {}
        return e ? fpe(e) : null
    } catch {
        return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.error(`Cannot extract url for event ${jo(t)}`), null
    }
}
const Kn = Ks;
let cv = 0;

function QO() {
    return cv > 0
}

function dpe() {
    cv++, setTimeout(() => {
        cv--
    })
}

function Ql(t, e = {}, n) {
    if (typeof t != "function") return t;
    try {
        const s = t.__sentry_wrapped__;
        if (s) return s;
        if (U3(t)) return t
    } catch {
        return t
    }
    const r = function() {
        const s = Array.prototype.slice.call(arguments);
        try {
            n && typeof n == "function" && n.apply(this, arguments);
            const i = s.map(o => Ql(o, e));
            return t.apply(this, i)
        } catch (i) {
            throw dpe(), epe(o => {
                o.addEventProcessor(a => (e.mechanism && (sv(a, void 0, void 0), T1(a, e.mechanism)), a.extra = {
                    ...a.extra,
                    arguments: s
                }, a)), Jde(i)
            }), i
        }
    };
    try {
        for (const s in t) Object.prototype.hasOwnProperty.call(t, s) && (r[s] = t[s])
    } catch {}
    BO(r, t), UO(t, "__sentry_wrapped__", r);
    try {
        Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
            get() {
                return t.name
            }
        })
    } catch {}
    return r
}

function JO(t, e) {
    const n = B3(t, e),
        r = {
            type: e && e.name,
            value: _pe(e)
        };
    return n.length && (r.stacktrace = {
        frames: n
    }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r
}

function ppe(t, e, n, r) {
    const i = wr().getClient(),
        o = i && i.getOptions().normalizeDepth,
        a = {
            exception: {
                values: [{
                    type: L3(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
                    value: `Non-Error ${r?"promise rejection":"exception"} captured with keys: ${pde(e)}`
                }]
            },
            extra: {
                __serialized__: VO(e, o)
            }
        };
    if (n) {
        const l = B3(t, n);
        l.length && (a.exception.values[0].stacktrace = {
            frames: l
        })
    }
    return a
}

function Yy(t, e) {
    return {
        exception: {
            values: [JO(t, e)]
        }
    }
}

function B3(t, e) {
    const n = e.stacktrace || e.stack || "",
        r = gpe(e);
    try {
        return t(n, r)
    } catch {}
    return []
}
const mpe = /Minified React error #\d+;/i;

function gpe(t) {
    if (t) {
        if (typeof t.framesToPop == "number") return t.framesToPop;
        if (mpe.test(t.message)) return 1
    }
    return 0
}

function _pe(t) {
    const e = t && t.message;
    return e ? e.error && typeof e.error.message == "string" ? e.error.message : e : "No error message"
}

function eC(t, e, n, r, s) {
    let i;
    if (DO(e) && e.error) return Yy(t, e.error);
    if (P6(e) || Zfe(e)) {
        const o = e;
        if ("stack" in e) i = Yy(t, e);
        else {
            const a = o.name || (P6(o) ? "DOMError" : "DOMException"),
                l = o.message ? `${a}: ${o.message}` : a;
            i = W6(t, l, n, r), sv(i, l)
        }
        return "code" in o && (i.tags = {
            ...i.tags,
            "DOMException.code": `${o.code}`
        }), i
    }
    return MO(e) ? Yy(t, e) : hg(e) || L3(e) ? (i = ppe(t, e, n, s), T1(i, {
        synthetic: !0
    }), i) : (i = W6(t, e, n, r), sv(i, `${e}`, void 0), T1(i, {
        synthetic: !0
    }), i)
}

function W6(t, e, n, r) {
    const s = {
        message: e
    };
    if (r && n) {
        const i = B3(t, n);
        i.length && (s.exception = {
            values: [{
                value: e,
                stacktrace: {
                    frames: i
                }
            }]
        })
    }
    return s
}
const wp = 1024,
    ype = "Breadcrumbs";
class Jh {
    static __initStatic() {
        this.id = ype
    }
    __init() {
        this.name = Jh.id
    }
    constructor(e) {
        Jh.prototype.__init.call(this), this.options = {
            console: !0,
            dom: !0,
            fetch: !0,
            history: !0,
            sentry: !0,
            xhr: !0,
            ...e
        }
    }
    setupOnce() {
        this.options.console && oc("console", bpe), this.options.dom && oc("dom", vpe(this.options.dom)), this.options.xhr && oc("xhr", Epe), this.options.fetch && oc("fetch", Tpe), this.options.history && oc("history", Spe)
    }
    addSentryBreadcrumb(e) {
        this.options.sentry && wr().addBreadcrumb({
            category: `sentry.${e.type==="transaction"?"transaction":"event"}`,
            event_id: e.event_id,
            level: e.level,
            message: jo(e)
        }, {
            event: e
        })
    }
}
Jh.__initStatic();

function vpe(t) {
    function e(n) {
        let r, s = typeof t == "object" ? t.serializeAttribute : void 0,
            i = typeof t == "object" && typeof t.maxStringLength == "number" ? t.maxStringLength : void 0;
        i && i > wp && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.warn(`\`dom.maxStringLength\` cannot exceed ${wp}, but a value of ${i} was configured. Sentry will use ${wp} instead.`), i = wp), typeof s == "string" && (s = [s]);
        try {
            const o = n.event;
            r = wpe(o) ? ev(o.target, {
                keyAttrs: s,
                maxStringLength: i
            }) : ev(o, {
                keyAttrs: s,
                maxStringLength: i
            })
        } catch {
            r = "<unknown>"
        }
        r.length !== 0 && wr().addBreadcrumb({
            category: `ui.${n.name}`,
            message: r
        }, {
            event: n.event,
            name: n.name,
            global: n.global
        })
    }
    return e
}

function bpe(t) {
    for (let n = 0; n < t.args.length; n++)
        if (t.args[n] === "ref=Ref<") {
            t.args[n + 1] = "viewRef";
            break
        } const e = {
        category: "console",
        data: {
            arguments: t.args,
            logger: "console"
        },
        level: Gde(t.level),
        message: D6(t.args, " ")
    };
    if (t.level === "assert")
        if (t.args[0] === !1) e.message = `Assertion failed: ${D6(t.args.slice(1)," ")||"console.assert"}`, e.data.arguments = t.args.slice(1);
        else return;
    wr().addBreadcrumb(e, {
        input: t.args,
        level: t.level
    })
}

function Epe(t) {
    const {
        startTimestamp: e,
        endTimestamp: n
    } = t, r = t.xhr[ph];
    if (!e || !n || !r) return;
    const {
        method: s,
        url: i,
        status_code: o,
        body: a
    } = r, l = {
        method: s,
        url: i,
        status_code: o
    }, u = {
        xhr: t.xhr,
        input: a,
        startTimestamp: e,
        endTimestamp: n
    };
    wr().addBreadcrumb({
        category: "xhr",
        data: l,
        type: "http"
    }, u)
}

function Tpe(t) {
    const {
        startTimestamp: e,
        endTimestamp: n
    } = t;
    if (n && !(t.fetchData.url.match(/sentry_key/) && t.fetchData.method === "POST"))
        if (t.error) {
            const r = t.fetchData,
                s = {
                    data: t.error,
                    input: t.args,
                    startTimestamp: e,
                    endTimestamp: n
                };
            wr().addBreadcrumb({
                category: "fetch",
                data: r,
                level: "error",
                type: "http"
            }, s)
        } else {
            const r = {
                    ...t.fetchData,
                    status_code: t.response && t.response.status
                },
                s = {
                    input: t.args,
                    response: t.response,
                    startTimestamp: e,
                    endTimestamp: n
                };
            wr().addBreadcrumb({
                category: "fetch",
                data: r,
                type: "http"
            }, s)
        }
}

function Spe(t) {
    let e = t.from,
        n = t.to;
    const r = Wy(Kn.location.href);
    let s = Wy(e);
    const i = Wy(n);
    s.path || (s = r), r.protocol === i.protocol && r.host === i.host && (n = i.relative), r.protocol === s.protocol && r.host === s.host && (e = s.relative), wr().addBreadcrumb({
        category: "navigation",
        data: {
            from: e,
            to: n
        }
    })
}

function wpe(t) {
    return t && !!t.target
}
class ra {
    static __initStatic() {
        this.id = "GlobalHandlers"
    }
    __init() {
        this.name = ra.id
    }
    __init2() {
        this._installFunc = {
            onerror: Ape,
            onunhandledrejection: Ope
        }
    }
    constructor(e) {
        ra.prototype.__init.call(this), ra.prototype.__init2.call(this), this._options = {
            onerror: !0,
            onunhandledrejection: !0,
            ...e
        }
    }
    setupOnce() {
        Error.stackTraceLimit = 50;
        const e = this._options;
        for (const n in e) {
            const r = this._installFunc[n];
            r && e[n] && (Ipe(n), r(), this._installFunc[n] = void 0)
        }
    }
}
ra.__initStatic();

function Ape() {
    oc("error", t => {
        const [e, n, r] = rC();
        if (!e.getIntegration(ra)) return;
        const {
            msg: s,
            url: i,
            line: o,
            column: a,
            error: l
        } = t;
        if (QO() || l && l.__sentry_own_request__) return;
        const u = l === void 0 && wc(s) ? kpe(s, i, o, a) : tC(eC(n, l || s, void 0, r, !1), i, o, a);
        u.level = "error", nC(e, l, u, "onerror")
    })
}

function Ope() {
    oc("unhandledrejection", t => {
        const [e, n, r] = rC();
        if (!e.getIntegration(ra)) return;
        let s = t;
        try {
            "reason" in t ? s = t.reason : "detail" in t && "reason" in t.detail && (s = t.detail.reason)
        } catch {}
        if (QO() || s && s.__sentry_own_request__) return !0;
        const i = Xfe(s) ? Cpe(s) : eC(n, s, void 0, r, !0);
        i.level = "error", nC(e, s, i, "onunhandledrejection")
    })
}

function Cpe(t) {
    return {
        exception: {
            values: [{
                type: "UnhandledRejection",
                value: `Non-Error promise rejection captured with value: ${String(t)}`
            }]
        }
    }
}

function kpe(t, e, n, r) {
    const s = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
    let i = DO(t) ? t.message : t,
        o = "Error";
    const a = i.match(s);
    return a && (o = a[1], i = a[2]), tC({
        exception: {
            values: [{
                type: o,
                value: i
            }]
        }
    }, e, n, r)
}

function tC(t, e, n, r) {
    const s = t.exception = t.exception || {},
        i = s.values = s.values || [],
        o = i[0] = i[0] || {},
        a = o.stacktrace = o.stacktrace || {},
        l = a.frames = a.frames || [],
        u = isNaN(parseInt(r, 10)) ? void 0 : r,
        f = isNaN(parseInt(n, 10)) ? void 0 : n,
        d = wc(e) && e.length > 0 ? e : ide();
    return l.length === 0 && l.push({
        colno: u,
        filename: d,
        function: "?",
        in_app: !0,
        lineno: f
    }), t
}

function Ipe(t) {
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.log(`Global Handler attached: ${t}`)
}

function nC(t, e, n, r) {
    T1(n, {
        handled: !1,
        type: r
    }), t.captureEvent(n, {
        originalException: e
    })
}

function rC() {
    const t = wr(),
        e = t.getClient(),
        n = e && e.getOptions() || {
            stackParser: () => [],
            attachStacktrace: !1
        };
    return [t, n.stackParser, n.attachStacktrace]
}
const Npe = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
class ef {
    static __initStatic() {
        this.id = "TryCatch"
    }
    __init() {
        this.name = ef.id
    }
    constructor(e) {
        ef.prototype.__init.call(this), this._options = {
            XMLHttpRequest: !0,
            eventTarget: !0,
            requestAnimationFrame: !0,
            setInterval: !0,
            setTimeout: !0,
            ...e
        }
    }
    setupOnce() {
        this._options.setTimeout && Jn(Kn, "setTimeout", H6), this._options.setInterval && Jn(Kn, "setInterval", H6), this._options.requestAnimationFrame && Jn(Kn, "requestAnimationFrame", xpe), this._options.XMLHttpRequest && "XMLHttpRequest" in Kn && Jn(XMLHttpRequest.prototype, "send", Ppe);
        const e = this._options.eventTarget;
        e && (Array.isArray(e) ? e : Npe).forEach(Rpe)
    }
}
ef.__initStatic();

function H6(t) {
    return function(...e) {
        const n = e[0];
        return e[0] = Ql(n, {
            mechanism: {
                data: {
                    function: fa(t)
                },
                handled: !0,
                type: "instrument"
            }
        }), t.apply(this, e)
    }
}

function xpe(t) {
    return function(e) {
        return t.apply(this, [Ql(e, {
            mechanism: {
                data: {
                    function: "requestAnimationFrame",
                    handler: fa(t)
                },
                handled: !0,
                type: "instrument"
            }
        })])
    }
}

function Ppe(t) {
    return function(...e) {
        const n = this;
        return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(s => {
            s in n && typeof n[s] == "function" && Jn(n, s, function(i) {
                const o = {
                        mechanism: {
                            data: {
                                function: s,
                                handler: fa(i)
                            },
                            handled: !0,
                            type: "instrument"
                        }
                    },
                    a = U3(i);
                return a && (o.mechanism.data.handler = fa(a)), Ql(i, o)
            })
        }), t.apply(this, e)
    }
}

function Rpe(t) {
    const e = Kn,
        n = e[t] && e[t].prototype;
    !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (Jn(n, "addEventListener", function(r) {
        return function(s, i, o) {
            try {
                typeof i.handleEvent == "function" && (i.handleEvent = Ql(i.handleEvent, {
                    mechanism: {
                        data: {
                            function: "handleEvent",
                            handler: fa(i),
                            target: t
                        },
                        handled: !0,
                        type: "instrument"
                    }
                }))
            } catch {}
            return r.apply(this, [s, Ql(i, {
                mechanism: {
                    data: {
                        function: "addEventListener",
                        handler: fa(i),
                        target: t
                    },
                    handled: !0,
                    type: "instrument"
                }
            }), o])
        }
    }), Jn(n, "removeEventListener", function(r) {
        return function(s, i, o) {
            const a = i;
            try {
                const l = a && a.__sentry_wrapped__;
                l && r.call(this, s, l, o)
            } catch {}
            return r.call(this, s, a, o)
        }
    }))
}
const Mpe = "cause",
    Dpe = 5;
class Ml {
    static __initStatic() {
        this.id = "LinkedErrors"
    }
    __init() {
        this.name = Ml.id
    }
    constructor(e = {}) {
        Ml.prototype.__init.call(this), this._key = e.key || Mpe, this._limit = e.limit || Dpe
    }
    setupOnce() {
        const e = wr().getClient();
        e && zO((n, r) => {
            const s = wr().getIntegration(Ml);
            return s ? $pe(e.getOptions().stackParser, s._key, s._limit, n, r) : n
        })
    }
}
Ml.__initStatic();

function $pe(t, e, n, r, s) {
    if (!r.exception || !r.exception.values || !s || !Ru(s.originalException, Error)) return r;
    const i = sC(t, n, s.originalException, e);
    return r.exception.values = [...i, ...r.exception.values], r
}

function sC(t, e, n, r, s = []) {
    if (!Ru(n[r], Error) || s.length + 1 >= e) return s;
    const i = JO(t, n[r]);
    return sC(t, e, n[r], r, [i, ...s])
}
class Dl {
    constructor() {
        Dl.prototype.__init.call(this)
    }
    static __initStatic() {
        this.id = "HttpContext"
    }
    __init() {
        this.name = Dl.id
    }
    setupOnce() {
        zO(e => {
            if (wr().getIntegration(Dl)) {
                if (!Kn.navigator && !Kn.location && !Kn.document) return e;
                const n = e.request && e.request.url || Kn.location && Kn.location.href,
                    {
                        referrer: r
                    } = Kn.document || {},
                    {
                        userAgent: s
                    } = Kn.navigator || {},
                    i = {
                        ...e.request && e.request.headers,
                        ...r && {
                            Referer: r
                        },
                        ...s && {
                            "User-Agent": s
                        }
                    },
                    o = {
                        ...e.request,
                        ...n && {
                            url: n
                        },
                        headers: i
                    };
                return {
                    ...e,
                    request: o
                }
            }
            return e
        })
    }
}
Dl.__initStatic();
class $l {
    constructor() {
        $l.prototype.__init.call(this)
    }
    static __initStatic() {
        this.id = "Dedupe"
    }
    __init() {
        this.name = $l.id
    }
    setupOnce(e, n) {
        const r = s => {
            if (s.type) return s;
            const i = n().getIntegration($l);
            if (i) {
                try {
                    if (Lpe(s, i._previousEvent)) return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.warn("Event dropped due to being a duplicate of previously captured event."), null
                } catch {
                    return i._previousEvent = s
                }
                return i._previousEvent = s
            }
            return s
        };
        r.id = this.name, e(r)
    }
}
$l.__initStatic();

function Lpe(t, e) {
    return e ? !!(Fpe(t, e) || Upe(t, e)) : !1
}

function Fpe(t, e) {
    const n = t.message,
        r = e.message;
    return !(!n && !r || n && !r || !n && r || n !== r || !oC(t, e) || !iC(t, e))
}

function Upe(t, e) {
    const n = Y6(e),
        r = Y6(t);
    return !(!n || !r || n.type !== r.type || n.value !== r.value || !oC(t, e) || !iC(t, e))
}

function iC(t, e) {
    let n = z6(t),
        r = z6(e);
    if (!n && !r) return !0;
    if (n && !r || !n && r || (n = n, r = r, r.length !== n.length)) return !1;
    for (let s = 0; s < r.length; s++) {
        const i = r[s],
            o = n[s];
        if (i.filename !== o.filename || i.lineno !== o.lineno || i.colno !== o.colno || i.function !== o.function) return !1
    }
    return !0
}

function oC(t, e) {
    let n = t.fingerprint,
        r = e.fingerprint;
    if (!n && !r) return !0;
    if (n && !r || !n && r) return !1;
    n = n, r = r;
    try {
        return n.join("") === r.join("")
    } catch {
        return !1
    }
}

function Y6(t) {
    return t.exception && t.exception.values && t.exception.values[0]
}

function z6(t) {
    const e = t.exception;
    if (e) try {
        return e.values[0].stacktrace.frames
    } catch {
        return
    }
}
new Rl, new Qh, new ef, new Jh, new ra, new Ml, new $l, new Dl;

function Bpe(t = {}, e = wr()) {
    if (!Kn.document) {
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.error("Global document not defined in showReportDialog call");
        return
    }
    const {
        client: n,
        scope: r
    } = e.getStackTop(), s = t.dsn || n && n.getDsn();
    if (!s) {
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.error("DSN not configured for showReportDialog call");
        return
    }
    r && (t.user = {
        ...r.getUser(),
        ...t.user
    }), t.eventId || (t.eventId = e.lastEventId());
    const i = Kn.document.createElement("script");
    i.async = !0, i.src = npe(s, t), t.onLoad && (i.onload = t.onLoad);
    const o = Kn.document.head || Kn.document.body;
    o ? o.appendChild(i) : (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Cn.error("Not injecting report dialog. No injection point found in HTML")
}
const qpe = st({
    setup() {
        return {
            fatalError: ao(xu.fatal.error)
        }
    },
    computed: {
        message() {
            var r, s, i, o;
            const t = ((s = (r = this.fatalError) == null ? void 0 : r.event) == null ? void 0 : s.event_id) ?? "Unknown";
            let e = "";
            const n = (o = (i = this.fatalError) == null ? void 0 : i.hint) == null ? void 0 : o.originalException;
            return n ? typeof n == "string" ? e = n : e = n.message : e = "An unknown error occured", `Version:
${window.tv.manifest.loader.version}

Event ID:
${t}

${e}`
        }
    },
    methods: {
        onFeedbackClick() {
            var t, e;
            Bpe({
                id: ((e = (t = this.fatalError) == null ? void 0 : t.event) == null ? void 0 : e.event_id) ?? "Unknown"
            })
        }
    }
});
const Hf = t => (Gr("data-v-a7272d53"), t = t(), Vr(), t),
    Gpe = {
        class: "jbg fatal"
    },
    Vpe = {
        class: "constrain"
    },
    jpe = Hf(() => U("a", {
        class: "logo",
        href: "/",
        "aria-label": "Jackbox Games Logo"
    }, null, -1)),
    Wpe = {
        class: "content"
    },
    Hpe = Hf(() => U("h1", null, "You have encountered an error", -1)),
    Ype = Hf(() => U("p", null, "Something went wrong! But don't worry, you can try a few things to get going.", -1)),
    zpe = Hf(() => U("ul", null, [U("li", null, "Refresh the page"), U("li", null, "Turn off adblockers or other browser extensions."), U("li", null, "Check your connection to the Internet."), U("li", null, "Make sure you're using an up-to-date browser."), U("li", null, "If that doesn't work, let us know.")], -1)),
    Kpe = Hf(() => U("hr", null, null, -1)),
    Zpe = {
        class: "error"
    };

function Xpe(t, e, n, r, s, i) {
    return B(), H("div", Gpe, [U("div", Vpe, [jpe, U("div", Wpe, [Hpe, Ype, zpe, U("button", {
        onClick: e[0] || (e[0] = (...o) => t.onFeedbackClick && t.onFeedbackClick(...o))
    }, "Tell us what happened"), Kpe, U("pre", Zpe, rt(t.message), 1)])])])
}
const Qpe = He(qpe, [
        ["render", Xpe],
        ["__scopeId", "data-v-a7272d53"]
    ]),
    Ap = Ec({
        hasCrashed: !1
    }),
    Jpe = {
        install: t => {
            if (t.config.globalProperties.$handleEcastError) return;
            t.provide(xu.fatal.error, ns(() => Ap));
            const e = (n, r) => {
                var s, i;
                if (n instanceof kh.EcastEntityNotFound || n instanceof kh.EcastFilterError || n instanceof kh.EcastRateLimitExceeded || n instanceof Error && ((s = n.message) != null && s.includes("Socket not ready to send")) || n instanceof Error && ((i = n.message) != null && i.includes("No connection available"))) return console.warn(n);
                throw r ? console.error(r, n) : console.error(n), n
            };
            window.tv.onError = async (n, r) => {
                if (n.level === "error" && (Ap.hasCrashed = !0, Ap.event = n, Ap.hint = r), t.config.globalProperties.$debugRecorder) return await t.config.globalProperties.$debugRecorder.sendToEcast()
            }, t.component("Fatal", Qpe), t.config.globalProperties.$handleEcastError = e
        }
    };
var e1e = xO,
    t1e = PO;

function n1e(t, e) {
    e = e1e(e, t);
    for (var n = 0, r = e.length; t != null && n < r;) t = t[t1e(e[n++])];
    return n && n == r ? t : void 0
}
var r1e = n1e,
    s1e = r1e;

function i1e(t, e, n) {
    var r = t == null ? void 0 : s1e(t, e);
    return r === void 0 ? n : r
}
var o1e = i1e;
const a1e = Rc(o1e);
var c1e = Math.floor,
    l1e = Math.random;

function u1e(t, e) {
    return t + c1e(l1e() * (e - t + 1))
}
var h1e = u1e,
    f1e = h1e;

function d1e(t) {
    var e = t.length;
    return e ? t[f1e(0, e - 1)] : void 0
}
var aC = d1e,
    p1e = IO;

function m1e(t, e) {
    return p1e(e, function(n) {
        return t[n]
    })
}
var g1e = m1e,
    _1e = g1e,
    y1e = lg;

function v1e(t) {
    return t == null ? [] : _1e(t, y1e(t))
}
var b1e = v1e,
    E1e = aC,
    T1e = b1e;

function S1e(t) {
    return E1e(T1e(t))
}
var w1e = S1e,
    A1e = aC,
    O1e = w1e,
    C1e = Oa;

function k1e(t) {
    var e = C1e(t) ? A1e : O1e;
    return e(t)
}
var I1e = k1e;
const N1e = Rc(I1e);

function K6(t, e) {
    const n = t.global.locale,
        r = t.global.messages[n],
        s = a1e(r, e);
    return Array.isArray(s) || console.warn(`[i18nPlugin] Translation with key ${e} is not an array`), N1e(s)
}
const x1e = {
        install: (t, e) => {
            t.directive("ts", (n, r) => {
                const s = K6(e.i18n, r.value);
                n.textContent = s || ""
            }), t.config.globalProperties.$ts = function(r) {
                return K6(e.i18n, r) || ""
            }, t.config.globalProperties.$messages = e.i18n.global.messages, t.config.globalProperties.$t = e.i18n.global.t, t.config.globalProperties.$tc = e.i18n.global.tc, t.config.globalProperties.$te = e.i18n.global.te, t.config.globalProperties.$tm = e.i18n.global.tm
        }
    },
    P1e = st({
        props: {
            image: String,
            text: String,
            subtext: String,
            classes: {
                type: [Array, String],
                default: () => "jbg"
            },
            dismissText: String
        }
    }),
    R1e = "main/pp10/nopus-opus/assets/928ef0da.png",
    M1e = "main/pp10/nopus-opus/assets/0bb76a2d.png",
    D1e = "main/pp10/nopus-opus/assets/ed4469b3.png";
const $1e = {
        key: 0,
        class: "image",
        src: R1e,
        alt: "Kicked"
    },
    L1e = {
        key: 1,
        class: "image",
        src: M1e,
        alt: "Thank You"
    },
    F1e = {
        key: 2,
        class: "image",
        src: D1e,
        alt: "Error"
    },
    U1e = {
        class: "text"
    },
    B1e = {
        key: 3,
        class: "subtext"
    },
    q1e = {
        class: "actions"
    };

function G1e(t, e, n, r, s, i) {
    const o = Gt("bb");
    return B(), H("div", {
        class: nt(["error-model", t.classes])
    }, [t.image === "tear" ? (B(), H("img", $1e)) : t.image === "moon" ? (B(), H("img", L1e)) : (B(), H("img", F1e)), $e(U("h3", U1e, null, 512), [
        [o, t.text]
    ]), t.subtext ? $e((B(), H("h3", B1e, null, 512)), [
        [o, t.subtext]
    ]) : Pe("", !0), U("div", q1e, [$e(U("button", {
        onClick: e[0] || (e[0] = Oi(a => t.$emit("resolve"), ["prevent"]))
    }, null, 512), [
        [o, t.dismissText]
    ])])], 2)
}
const V1e = He(P1e, [
        ["render", G1e],
        ["__scopeId", "data-v-39debcb6"]
    ]),
    j1e = st({
        props: {
            text: String,
            subtext: String,
            classes: {
                type: [Array, String],
                default: () => "jbg"
            },
            options: Array
        },
        emits: ["resolve"]
    });
const W1e = {
        class: "text"
    },
    H1e = {
        key: 0,
        class: "subtext"
    },
    Y1e = {
        class: "actions"
    },
    z1e = ["onClick"];

function K1e(t, e, n, r, s, i) {
    const o = Gt("bb");
    return B(), H("div", {
        class: nt(["options-modal", t.classes])
    }, [$e(U("h3", W1e, null, 512), [
        [o, t.text]
    ]), t.subtext ? $e((B(), H("h3", H1e, null, 512)), [
        [o, t.subtext]
    ]) : Pe("", !0), U("div", Y1e, [(B(!0), H(lt, null, gn(t.options, (a, l) => $e((B(), H("button", {
        key: l,
        class: nt(a.classes),
        onClick: Oi(u => t.$emit("resolve", a.value), ["prevent"])
    }, null, 10, z1e)), [
        [o, a.text]
    ])), 128))])], 2)
}
const Z1e = He(j1e, [
        ["render", K1e],
        ["__scopeId", "data-v-adb60058"]
    ]),
    X1e = st({
        data() {
            return {
                classes: "jbg",
                props: null,
                resolve: null,
                content: null
            }
        },
        beforeMount() {
            this.$registerModal(this)
        },
        methods: {
            show(t, e = {}, n = {}) {
                return this.props = e, this.classes = n.classes || "jbg", t === "Error" ? this.content = V1e : t === "Options" ? this.content = Z1e : this.content = t, new Promise(r => {
                    this.resolve = r
                })
            },
            hide() {
                this.props = null, this.resolve && this.resolve()
            },
            onResolve(...t) {
                this.props = null, this.resolve(...t)
            },
            onBackgroundClick() {
                this.props = null, this.resolve()
            }
        }
    });
const Q1e = {
    class: "sandbox"
};

function J1e(t, e, n, r, s, i) {
    return B(), At(Ta, {
        name: "modal-transition"
    }, {
        default: $i(() => [t.props ? (B(), H("div", {
            key: 0,
            class: nt(["modal", t.classes]),
            onKeyup: e[0] || (e[0] = E2((...o) => t.onBackgroundClick && t.onBackgroundClick(...o), ["esc"])),
            onClick: e[1] || (e[1] = Oi((...o) => t.onBackgroundClick && t.onBackgroundClick(...o), ["self"]))
        }, [U("div", Q1e, [t.content ? (B(), At(Fm(t.content), Mf({
            key: 0,
            class: "content"
        }, t.props, {
            onResolve: t.onResolve
        }), null, 16, ["onResolve"])) : Pe("", !0)])], 34)) : Pe("", !0)]),
        _: 1
    })
}
const eme = He(X1e, [
        ["render", J1e],
        ["__scopeId", "data-v-374ad43c"]
    ]),
    tme = {
        install: t => {
            let e;
            const n = () => {
                    if (!e) throw new Error("No ModalComponent is registered");
                    return e.hide()
                },
                r = (i, o, a) => {
                    if (!e) throw new Error("No ModalComponent is registered");
                    return e.show(i, o, a)
                },
                s = i => {
                    e = i
                };
            t.component("Modal", eme), t.config.globalProperties.$hideModal = n, t.config.globalProperties.$showModal = r, t.config.globalProperties.$registerModal = s
        }
    },
    nme = {
        install: t => {
            const e = new Map;
            t.directive("pointerbox", {
                mounted(n, r) {
                    const s = new D0(n, {
                        restrictToBox: r.modifiers.restrict,
                        isMultitouch: r.modifiers.multi
                    });
                    e.set(n, s)
                },
                unmounted(n) {
                    var r;
                    (r = e.get(n)) == null || r.destroy(), e.delete(n)
                }
            }), t.directive("pointerbox-translate", {
                mounted(n, r) {
                    n.setAttribute("data-pointerboxtranslateid", r.value.id ?? ""), n.setAttribute("data-pointerboxtranslatewidth", r.value.width ?? ""), n.setAttribute("data-pointerboxtranslateheight", r.value.height ?? "")
                },
                unmounted(n) {
                    n.removeAttribute("data-pointerboxtranslateid"), n.removeAttribute("data-pointerboxtranslatewidth"), n.removeAttribute("data-pointerboxtranslateheight")
                }
            })
        }
    },
    rme = st({
        setup() {
            return {
                announcment: ao(xu.textDescriptions.announcement)
            }
        },
        ecastKeys: {
            textDescriptions: "textDescriptions"
        },
        data() {
            return {
                lines: []
            }
        },
        computed: {
            textDescriptions() {
                return !this.$ecastValues || !this.$ecastValues.textDescriptions ? null : this.$ecastValues.textDescriptions
            }
        },
        watch: {
            announcment: function(e) {
                this.lines.push({
                    id: Math.random(),
                    category: "announce",
                    text: e
                })
            },
            "textDescriptions.latestDescriptions": function(e) {
                !e || !e.length || e.forEach(n => {
                    n.id !== void 0 && this.lines.find(r => r.id === n.id) || this.lines.push(n)
                })
            }
        }
    });
const sme = {
    class: "text-descriptions",
    role: "log",
    "aria-atomic": "false",
    "aria-relevant": "additions",
    "aria-live": "polite"
};

function ime(t, e, n, r, s, i) {
    return B(), H("div", sme, [(B(!0), H(lt, null, gn(t.lines, o => (B(), H("p", {
        key: o.id
    }, rt(o.text), 1))), 128))])
}
const ome = He(rme, [
        ["render", ime]
    ]),
    Z6 = ts(""),
    ame = {
        install: t => {
            if (t.config.globalProperties.$announce) return;
            t.provide(xu.textDescriptions.announcement, ns(() => Z6.value));
            const e = n => {
                Z6.value = n
            };
            t.component("TextDescriptions", ome), t.config.globalProperties.$announce = e
        }
    },
    cme = {
        install: t => {
            let e = "",
                n = "";
            const r = i => i instanceof Function ? i() : i,
                s = i => {
                    const o = document.querySelector('meta[name="theme-color"]');
                    o && (document.body && (document.body.style.background = i), o.setAttribute("content", i), n = i)
                };
            t.config.globalProperties.$setThemeColor = function(o) {
                this.$options.themeColor = o, s(o)
            }, t.mixin({
                mounted() {
                    if (!this.$options.themeColor) return;
                    const i = r(this.$options.themeColor);
                    s(i), this.$attrs.name === "game" && (e = i)
                },
                beforeDestroy() {
                    !this.$options.themeColor || r(this.$options.themeColor) !== n || s(e)
                }
            })
        }
    },
    lme = {
        install: t => {
            t.config.globalProperties.$vibrate = (e = [100, 100]) => {
                var n;
                if (!((n = window.navigator) != null && n.vibrate)) return !1;
                try {
                    return window.navigator.vibrate(e), !0
                } catch {
                    return !1
                }
            }
        }
    };
/*!
 * shared v9.2.2
 * (c) 2022 kazuya kawaguchi
 * Released under the MIT License.
 */
const lv = typeof window < "u",
    ume = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol",
    xa = t => ume ? Symbol(t) : t,
    hme = (t, e, n) => fme({
        l: t,
        k: e,
        s: n
    }),
    fme = t => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"),
    Ln = t => typeof t == "number" && isFinite(t),
    dme = t => G3(t) === "[object Date]",
    da = t => G3(t) === "[object RegExp]",
    mg = t => ht(t) && Object.keys(t).length === 0;

function pme(t, e) {
    typeof console < "u" && (console.warn("[intlify] " + t), e && console.warn(e.stack))
}
const nr = Object.assign;

function X6(t) {
    return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
}
const mme = Object.prototype.hasOwnProperty;

function q3(t, e) {
    return mme.call(t, e)
}
const Qt = Array.isArray,
    On = t => typeof t == "function",
    Le = t => typeof t == "string",
    It = t => typeof t == "boolean",
    Jt = t => t !== null && typeof t == "object",
    cC = Object.prototype.toString,
    G3 = t => cC.call(t),
    ht = t => G3(t) === "[object Object]",
    gme = t => t == null ? "" : Qt(t) || ht(t) && t.toString === cC ? JSON.stringify(t, null, 2) : String(t);
/*!
 * message-compiler v9.2.2
 * (c) 2022 kazuya kawaguchi
 * Released under the MIT License.
 */
const Mt = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    __EXTEND_POINT__: 15
};

function gg(t, e, n = {}) {
    const {
        domain: r,
        messages: s,
        args: i
    } = n, o = t, a = new SyntaxError(String(o));
    return a.code = t, e && (a.location = e), a.domain = r, a
}

function _me(t) {
    throw t
}

function yme(t, e, n) {
    return {
        line: t,
        column: e,
        offset: n
    }
}

function uv(t, e, n) {
    const r = {
        start: t,
        end: e
    };
    return n != null && (r.source = n), r
}
const Zi = " ",
    vme = "\r",
    br = `
`,
    bme = String.fromCharCode(8232),
    Eme = String.fromCharCode(8233);

function Tme(t) {
    const e = t;
    let n = 0,
        r = 1,
        s = 1,
        i = 0;
    const o = D => e[D] === vme && e[D + 1] === br,
        a = D => e[D] === br,
        l = D => e[D] === Eme,
        u = D => e[D] === bme,
        f = D => o(D) || a(D) || l(D) || u(D),
        d = () => n,
        p = () => r,
        _ = () => s,
        v = () => i,
        y = D => o(D) || l(D) || u(D) ? br : e[D],
        g = () => y(n),
        b = () => y(n + i);

    function O() {
        return i = 0, f(n) && (r++, s = 0), o(n) && n++, n++, s++, e[n]
    }

    function N() {
        return o(n + i) && i++, i++, e[n + i]
    }

    function k() {
        n = 0, r = 1, s = 1, i = 0
    }

    function A(D = 0) {
        i = D
    }

    function x() {
        const D = n + i;
        for (; D !== n;) O();
        i = 0
    }
    return {
        index: d,
        line: p,
        column: _,
        peekOffset: v,
        charAt: y,
        currentChar: g,
        currentPeek: b,
        next: O,
        peek: N,
        reset: k,
        resetPeek: A,
        skipToPeek: x
    }
}
const Lo = void 0,
    Q6 = "'",
    Sme = "tokenizer";

function wme(t, e = {}) {
    const n = e.location !== !1,
        r = Tme(t),
        s = () => r.index(),
        i = () => yme(r.line(), r.column(), r.index()),
        o = i(),
        a = s(),
        l = {
            currentType: 14,
            offset: a,
            startLoc: o,
            endLoc: o,
            lastType: 14,
            lastOffset: a,
            lastStartLoc: o,
            lastEndLoc: o,
            braceNest: 0,
            inLinked: !1,
            text: ""
        },
        u = () => l,
        {
            onError: f
        } = e;

    function d(T, S, P, ...G) {
        const te = u();
        if (S.column += P, S.offset += P, f) {
            const le = uv(te.startLoc, S),
                me = gg(T, le, {
                    domain: Sme,
                    args: G
                });
            f(me)
        }
    }

    function p(T, S, P) {
        T.endLoc = i(), T.currentType = S;
        const G = {
            type: S
        };
        return n && (G.loc = uv(T.startLoc, T.endLoc)), P != null && (G.value = P), G
    }
    const _ = T => p(T, 14);

    function v(T, S) {
        return T.currentChar() === S ? (T.next(), S) : (d(Mt.EXPECTED_TOKEN, i(), 0, S), "")
    }

    function y(T) {
        let S = "";
        for (; T.currentPeek() === Zi || T.currentPeek() === br;) S += T.currentPeek(), T.peek();
        return S
    }

    function g(T) {
        const S = y(T);
        return T.skipToPeek(), S
    }

    function b(T) {
        if (T === Lo) return !1;
        const S = T.charCodeAt(0);
        return S >= 97 && S <= 122 || S >= 65 && S <= 90 || S === 95
    }

    function O(T) {
        if (T === Lo) return !1;
        const S = T.charCodeAt(0);
        return S >= 48 && S <= 57
    }

    function N(T, S) {
        const {
            currentType: P
        } = S;
        if (P !== 2) return !1;
        y(T);
        const G = b(T.currentPeek());
        return T.resetPeek(), G
    }

    function k(T, S) {
        const {
            currentType: P
        } = S;
        if (P !== 2) return !1;
        y(T);
        const G = T.currentPeek() === "-" ? T.peek() : T.currentPeek(),
            te = O(G);
        return T.resetPeek(), te
    }

    function A(T, S) {
        const {
            currentType: P
        } = S;
        if (P !== 2) return !1;
        y(T);
        const G = T.currentPeek() === Q6;
        return T.resetPeek(), G
    }

    function x(T, S) {
        const {
            currentType: P
        } = S;
        if (P !== 8) return !1;
        y(T);
        const G = T.currentPeek() === ".";
        return T.resetPeek(), G
    }

    function D(T, S) {
        const {
            currentType: P
        } = S;
        if (P !== 9) return !1;
        y(T);
        const G = b(T.currentPeek());
        return T.resetPeek(), G
    }

    function L(T, S) {
        const {
            currentType: P
        } = S;
        if (!(P === 8 || P === 12)) return !1;
        y(T);
        const G = T.currentPeek() === ":";
        return T.resetPeek(), G
    }

    function q(T, S) {
        const {
            currentType: P
        } = S;
        if (P !== 10) return !1;
        const G = () => {
                const le = T.currentPeek();
                return le === "{" ? b(T.peek()) : le === "@" || le === "%" || le === "|" || le === ":" || le === "." || le === Zi || !le ? !1 : le === br ? (T.peek(), G()) : b(le)
            },
            te = G();
        return T.resetPeek(), te
    }

    function ee(T) {
        y(T);
        const S = T.currentPeek() === "|";
        return T.resetPeek(), S
    }

    function ae(T) {
        const S = y(T),
            P = T.currentPeek() === "%" && T.peek() === "{";
        return T.resetPeek(), {
            isModulo: P,
            hasSpace: S.length > 0
        }
    }

    function Z(T, S = !0) {
        const P = (te = !1, le = "", me = !1) => {
                const ve = T.currentPeek();
                return ve === "{" ? le === "%" ? !1 : te : ve === "@" || !ve ? le === "%" ? !0 : te : ve === "%" ? (T.peek(), P(te, "%", !0)) : ve === "|" ? le === "%" || me ? !0 : !(le === Zi || le === br) : ve === Zi ? (T.peek(), P(!0, Zi, me)) : ve === br ? (T.peek(), P(!0, br, me)) : !0
            },
            G = P();
        return S && T.resetPeek(), G
    }

    function fe(T, S) {
        const P = T.currentChar();
        return P === Lo ? Lo : S(P) ? (T.next(), P) : null
    }

    function ge(T) {
        return fe(T, P => {
            const G = P.charCodeAt(0);
            return G >= 97 && G <= 122 || G >= 65 && G <= 90 || G >= 48 && G <= 57 || G === 95 || G === 36
        })
    }

    function K(T) {
        return fe(T, P => {
            const G = P.charCodeAt(0);
            return G >= 48 && G <= 57
        })
    }

    function Q(T) {
        return fe(T, P => {
            const G = P.charCodeAt(0);
            return G >= 48 && G <= 57 || G >= 65 && G <= 70 || G >= 97 && G <= 102
        })
    }

    function ue(T) {
        let S = "",
            P = "";
        for (; S = K(T);) P += S;
        return P
    }

    function _e(T) {
        g(T);
        const S = T.currentChar();
        return S !== "%" && d(Mt.EXPECTED_TOKEN, i(), 0, S), T.next(), "%"
    }

    function Oe(T) {
        let S = "";
        for (;;) {
            const P = T.currentChar();
            if (P === "{" || P === "}" || P === "@" || P === "|" || !P) break;
            if (P === "%")
                if (Z(T)) S += P, T.next();
                else break;
            else if (P === Zi || P === br)
                if (Z(T)) S += P, T.next();
                else {
                    if (ee(T)) break;
                    S += P, T.next()
                }
            else S += P, T.next()
        }
        return S
    }

    function Ee(T) {
        g(T);
        let S = "",
            P = "";
        for (; S = ge(T);) P += S;
        return T.currentChar() === Lo && d(Mt.UNTERMINATED_CLOSING_BRACE, i(), 0), P
    }

    function Ce(T) {
        g(T);
        let S = "";
        return T.currentChar() === "-" ? (T.next(), S += `-${ue(T)}`) : S += ue(T), T.currentChar() === Lo && d(Mt.UNTERMINATED_CLOSING_BRACE, i(), 0), S
    }

    function De(T) {
        g(T), v(T, "'");
        let S = "",
            P = "";
        const G = le => le !== Q6 && le !== br;
        for (; S = fe(T, G);) S === "\\" ? P += Ue(T) : P += S;
        const te = T.currentChar();
        return te === br || te === Lo ? (d(Mt.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, i(), 0), te === br && (T.next(), v(T, "'")), P) : (v(T, "'"), P)
    }

    function Ue(T) {
        const S = T.currentChar();
        switch (S) {
            case "\\":
            case "'":
                return T.next(), `\\${S}`;
            case "u":
                return ot(T, S, 4);
            case "U":
                return ot(T, S, 6);
            default:
                return d(Mt.UNKNOWN_ESCAPE_SEQUENCE, i(), 0, S), ""
        }
    }

    function ot(T, S, P) {
        v(T, S);
        let G = "";
        for (let te = 0; te < P; te++) {
            const le = Q(T);
            if (!le) {
                d(Mt.INVALID_UNICODE_ESCAPE_SEQUENCE, i(), 0, `\\${S}${G}${T.currentChar()}`);
                break
            }
            G += le
        }
        return `\\${S}${G}`
    }

    function je(T) {
        g(T);
        let S = "",
            P = "";
        const G = te => te !== "{" && te !== "}" && te !== Zi && te !== br;
        for (; S = fe(T, G);) P += S;
        return P
    }

    function Ze(T) {
        let S = "",
            P = "";
        for (; S = ge(T);) P += S;
        return P
    }

    function it(T) {
        const S = (P = !1, G) => {
            const te = T.currentChar();
            return te === "{" || te === "%" || te === "@" || te === "|" || !te || te === Zi ? G : te === br ? (G += te, T.next(), S(P, G)) : (G += te, T.next(), S(!0, G))
        };
        return S(!1, "")
    }

    function w(T) {
        g(T);
        const S = v(T, "|");
        return g(T), S
    }

    function M(T, S) {
        let P = null;
        switch (T.currentChar()) {
            case "{":
                return S.braceNest >= 1 && d(Mt.NOT_ALLOW_NEST_PLACEHOLDER, i(), 0), T.next(), P = p(S, 2, "{"), g(T), S.braceNest++, P;
            case "}":
                return S.braceNest > 0 && S.currentType === 2 && d(Mt.EMPTY_PLACEHOLDER, i(), 0), T.next(), P = p(S, 3, "}"), S.braceNest--, S.braceNest > 0 && g(T), S.inLinked && S.braceNest === 0 && (S.inLinked = !1), P;
            case "@":
                return S.braceNest > 0 && d(Mt.UNTERMINATED_CLOSING_BRACE, i(), 0), P = Y(T, S) || _(S), S.braceNest = 0, P;
            default:
                let te = !0,
                    le = !0,
                    me = !0;
                if (ee(T)) return S.braceNest > 0 && d(Mt.UNTERMINATED_CLOSING_BRACE, i(), 0), P = p(S, 1, w(T)), S.braceNest = 0, S.inLinked = !1, P;
                if (S.braceNest > 0 && (S.currentType === 5 || S.currentType === 6 || S.currentType === 7)) return d(Mt.UNTERMINATED_CLOSING_BRACE, i(), 0), S.braceNest = 0, X(T, S);
                if (te = N(T, S)) return P = p(S, 5, Ee(T)), g(T), P;
                if (le = k(T, S)) return P = p(S, 6, Ce(T)), g(T), P;
                if (me = A(T, S)) return P = p(S, 7, De(T)), g(T), P;
                if (!te && !le && !me) return P = p(S, 13, je(T)), d(Mt.INVALID_TOKEN_IN_PLACEHOLDER, i(), 0, P.value), g(T), P;
                break
        }
        return P
    }

    function Y(T, S) {
        const {
            currentType: P
        } = S;
        let G = null;
        const te = T.currentChar();
        switch ((P === 8 || P === 9 || P === 12 || P === 10) && (te === br || te === Zi) && d(Mt.INVALID_LINKED_FORMAT, i(), 0), te) {
            case "@":
                return T.next(), G = p(S, 8, "@"), S.inLinked = !0, G;
            case ".":
                return g(T), T.next(), p(S, 9, ".");
            case ":":
                return g(T), T.next(), p(S, 10, ":");
            default:
                return ee(T) ? (G = p(S, 1, w(T)), S.braceNest = 0, S.inLinked = !1, G) : x(T, S) || L(T, S) ? (g(T), Y(T, S)) : D(T, S) ? (g(T), p(S, 12, Ze(T))) : q(T, S) ? (g(T), te === "{" ? M(T, S) || G : p(S, 11, it(T))) : (P === 8 && d(Mt.INVALID_LINKED_FORMAT, i(), 0), S.braceNest = 0, S.inLinked = !1, X(T, S))
        }
    }

    function X(T, S) {
        let P = {
            type: 14
        };
        if (S.braceNest > 0) return M(T, S) || _(S);
        if (S.inLinked) return Y(T, S) || _(S);
        switch (T.currentChar()) {
            case "{":
                return M(T, S) || _(S);
            case "}":
                return d(Mt.UNBALANCED_CLOSING_BRACE, i(), 0), T.next(), p(S, 3, "}");
            case "@":
                return Y(T, S) || _(S);
            default:
                if (ee(T)) return P = p(S, 1, w(T)), S.braceNest = 0, S.inLinked = !1, P;
                const {
                    isModulo: te, hasSpace: le
                } = ae(T);
                if (te) return le ? p(S, 0, Oe(T)) : p(S, 4, _e(T));
                if (Z(T)) return p(S, 0, Oe(T));
                break
        }
        return P
    }

    function I() {
        const {
            currentType: T,
            offset: S,
            startLoc: P,
            endLoc: G
        } = l;
        return l.lastType = T, l.lastOffset = S, l.lastStartLoc = P, l.lastEndLoc = G, l.offset = s(), l.startLoc = i(), r.currentChar() === Lo ? p(l, 14) : X(r, l)
    }
    return {
        nextToken: I,
        currentOffset: s,
        currentPosition: i,
        context: u
    }
}
const Ame = "parser",
    Ome = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

function Cme(t, e, n) {
    switch (t) {
        case "\\\\":
            return "\\";
        case "\\'":
            return "'";
        default: {
            const r = parseInt(e || n, 16);
            return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : ""
        }
    }
}

function kme(t = {}) {
    const e = t.location !== !1,
        {
            onError: n
        } = t;

    function r(b, O, N, k, ...A) {
        const x = b.currentPosition();
        if (x.offset += k, x.column += k, n) {
            const D = uv(N, x),
                L = gg(O, D, {
                    domain: Ame,
                    args: A
                });
            n(L)
        }
    }

    function s(b, O, N) {
        const k = {
            type: b,
            start: O,
            end: O
        };
        return e && (k.loc = {
            start: N,
            end: N
        }), k
    }

    function i(b, O, N, k) {
        b.end = O, k && (b.type = k), e && b.loc && (b.loc.end = N)
    }

    function o(b, O) {
        const N = b.context(),
            k = s(3, N.offset, N.startLoc);
        return k.value = O, i(k, b.currentOffset(), b.currentPosition()), k
    }

    function a(b, O) {
        const N = b.context(),
            {
                lastOffset: k,
                lastStartLoc: A
            } = N,
            x = s(5, k, A);
        return x.index = parseInt(O, 10), b.nextToken(), i(x, b.currentOffset(), b.currentPosition()), x
    }

    function l(b, O) {
        const N = b.context(),
            {
                lastOffset: k,
                lastStartLoc: A
            } = N,
            x = s(4, k, A);
        return x.key = O, b.nextToken(), i(x, b.currentOffset(), b.currentPosition()), x
    }

    function u(b, O) {
        const N = b.context(),
            {
                lastOffset: k,
                lastStartLoc: A
            } = N,
            x = s(9, k, A);
        return x.value = O.replace(Ome, Cme), b.nextToken(), i(x, b.currentOffset(), b.currentPosition()), x
    }

    function f(b) {
        const O = b.nextToken(),
            N = b.context(),
            {
                lastOffset: k,
                lastStartLoc: A
            } = N,
            x = s(8, k, A);
        return O.type !== 12 ? (r(b, Mt.UNEXPECTED_EMPTY_LINKED_MODIFIER, N.lastStartLoc, 0), x.value = "", i(x, k, A), {
            nextConsumeToken: O,
            node: x
        }) : (O.value == null && r(b, Mt.UNEXPECTED_LEXICAL_ANALYSIS, N.lastStartLoc, 0, pi(O)), x.value = O.value || "", i(x, b.currentOffset(), b.currentPosition()), {
            node: x
        })
    }

    function d(b, O) {
        const N = b.context(),
            k = s(7, N.offset, N.startLoc);
        return k.value = O, i(k, b.currentOffset(), b.currentPosition()), k
    }

    function p(b) {
        const O = b.context(),
            N = s(6, O.offset, O.startLoc);
        let k = b.nextToken();
        if (k.type === 9) {
            const A = f(b);
            N.modifier = A.node, k = A.nextConsumeToken || b.nextToken()
        }
        switch (k.type !== 10 && r(b, Mt.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, pi(k)), k = b.nextToken(), k.type === 2 && (k = b.nextToken()), k.type) {
            case 11:
                k.value == null && r(b, Mt.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, pi(k)), N.key = d(b, k.value || "");
                break;
            case 5:
                k.value == null && r(b, Mt.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, pi(k)), N.key = l(b, k.value || "");
                break;
            case 6:
                k.value == null && r(b, Mt.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, pi(k)), N.key = a(b, k.value || "");
                break;
            case 7:
                k.value == null && r(b, Mt.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, pi(k)), N.key = u(b, k.value || "");
                break;
            default:
                r(b, Mt.UNEXPECTED_EMPTY_LINKED_KEY, O.lastStartLoc, 0);
                const A = b.context(),
                    x = s(7, A.offset, A.startLoc);
                return x.value = "", i(x, A.offset, A.startLoc), N.key = x, i(N, A.offset, A.startLoc), {
                    nextConsumeToken: k,
                    node: N
                }
        }
        return i(N, b.currentOffset(), b.currentPosition()), {
            node: N
        }
    }

    function _(b) {
        const O = b.context(),
            N = O.currentType === 1 ? b.currentOffset() : O.offset,
            k = O.currentType === 1 ? O.endLoc : O.startLoc,
            A = s(2, N, k);
        A.items = [];
        let x = null;
        do {
            const q = x || b.nextToken();
            switch (x = null, q.type) {
                case 0:
                    q.value == null && r(b, Mt.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, pi(q)), A.items.push(o(b, q.value || ""));
                    break;
                case 6:
                    q.value == null && r(b, Mt.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, pi(q)), A.items.push(a(b, q.value || ""));
                    break;
                case 5:
                    q.value == null && r(b, Mt.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, pi(q)), A.items.push(l(b, q.value || ""));
                    break;
                case 7:
                    q.value == null && r(b, Mt.UNEXPECTED_LEXICAL_ANALYSIS, O.lastStartLoc, 0, pi(q)), A.items.push(u(b, q.value || ""));
                    break;
                case 8:
                    const ee = p(b);
                    A.items.push(ee.node), x = ee.nextConsumeToken || null;
                    break
            }
        } while (O.currentType !== 14 && O.currentType !== 1);
        const D = O.currentType === 1 ? O.lastOffset : b.currentOffset(),
            L = O.currentType === 1 ? O.lastEndLoc : b.currentPosition();
        return i(A, D, L), A
    }

    function v(b, O, N, k) {
        const A = b.context();
        let x = k.items.length === 0;
        const D = s(1, O, N);
        D.cases = [], D.cases.push(k);
        do {
            const L = _(b);
            x || (x = L.items.length === 0), D.cases.push(L)
        } while (A.currentType !== 14);
        return x && r(b, Mt.MUST_HAVE_MESSAGES_IN_PLURAL, N, 0), i(D, b.currentOffset(), b.currentPosition()), D
    }

    function y(b) {
        const O = b.context(),
            {
                offset: N,
                startLoc: k
            } = O,
            A = _(b);
        return O.currentType === 14 ? A : v(b, N, k, A)
    }

    function g(b) {
        const O = wme(b, nr({}, t)),
            N = O.context(),
            k = s(0, N.offset, N.startLoc);
        return e && k.loc && (k.loc.source = b), k.body = y(O), N.currentType !== 14 && r(O, Mt.UNEXPECTED_LEXICAL_ANALYSIS, N.lastStartLoc, 0, b[N.offset] || ""), i(k, O.currentOffset(), O.currentPosition()), k
    }
    return {
        parse: g
    }
}

function pi(t) {
    if (t.type === 14) return "EOF";
    const e = (t.value || "").replace(/\r?\n/gu, "\\n");
    return e.length > 10 ? e.slice(0, 9) + "" : e
}

function Ime(t, e = {}) {
    const n = {
        ast: t,
        helpers: new Set
    };
    return {
        context: () => n,
        helper: i => (n.helpers.add(i), i)
    }
}

function J6(t, e) {
    for (let n = 0; n < t.length; n++) V3(t[n], e)
}

function V3(t, e) {
    switch (t.type) {
        case 1:
            J6(t.cases, e), e.helper("plural");
            break;
        case 2:
            J6(t.items, e);
            break;
        case 6:
            V3(t.key, e), e.helper("linked"), e.helper("type");
            break;
        case 5:
            e.helper("interpolate"), e.helper("list");
            break;
        case 4:
            e.helper("interpolate"), e.helper("named");
            break
    }
}

function Nme(t, e = {}) {
    const n = Ime(t);
    n.helper("normalize"), t.body && V3(t.body, n);
    const r = n.context();
    t.helpers = Array.from(r.helpers)
}

function xme(t, e) {
    const {
        sourceMap: n,
        filename: r,
        breakLineCode: s,
        needIndent: i
    } = e, o = {
        source: t.loc.source,
        filename: r,
        code: "",
        column: 1,
        line: 1,
        offset: 0,
        map: void 0,
        breakLineCode: s,
        needIndent: i,
        indentLevel: 0
    }, a = () => o;

    function l(y, g) {
        o.code += y
    }

    function u(y, g = !0) {
        const b = g ? s : "";
        l(i ? b + "  ".repeat(y) : b)
    }

    function f(y = !0) {
        const g = ++o.indentLevel;
        y && u(g)
    }

    function d(y = !0) {
        const g = --o.indentLevel;
        y && u(g)
    }

    function p() {
        u(o.indentLevel)
    }
    return {
        context: a,
        push: l,
        indent: f,
        deindent: d,
        newline: p,
        helper: y => `_${y}`,
        needIndent: () => o.needIndent
    }
}

function Pme(t, e) {
    const {
        helper: n
    } = t;
    t.push(`${n("linked")}(`), Jl(t, e.key), e.modifier ? (t.push(", "), Jl(t, e.modifier), t.push(", _type")) : t.push(", undefined, _type"), t.push(")")
}

function Rme(t, e) {
    const {
        helper: n,
        needIndent: r
    } = t;
    t.push(`${n("normalize")}([`), t.indent(r());
    const s = e.items.length;
    for (let i = 0; i < s && (Jl(t, e.items[i]), i !== s - 1); i++) t.push(", ");
    t.deindent(r()), t.push("])")
}

function Mme(t, e) {
    const {
        helper: n,
        needIndent: r
    } = t;
    if (e.cases.length > 1) {
        t.push(`${n("plural")}([`), t.indent(r());
        const s = e.cases.length;
        for (let i = 0; i < s && (Jl(t, e.cases[i]), i !== s - 1); i++) t.push(", ");
        t.deindent(r()), t.push("])")
    }
}

function Dme(t, e) {
    e.body ? Jl(t, e.body) : t.push("null")
}

function Jl(t, e) {
    const {
        helper: n
    } = t;
    switch (e.type) {
        case 0:
            Dme(t, e);
            break;
        case 1:
            Mme(t, e);
            break;
        case 2:
            Rme(t, e);
            break;
        case 6:
            Pme(t, e);
            break;
        case 8:
            t.push(JSON.stringify(e.value), e);
            break;
        case 7:
            t.push(JSON.stringify(e.value), e);
            break;
        case 5:
            t.push(`${n("interpolate")}(${n("list")}(${e.index}))`, e);
            break;
        case 4:
            t.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(e.key)}))`, e);
            break;
        case 9:
            t.push(JSON.stringify(e.value), e);
            break;
        case 3:
            t.push(JSON.stringify(e.value), e);
            break
    }
}
const $me = (t, e = {}) => {
    const n = Le(e.mode) ? e.mode : "normal",
        r = Le(e.filename) ? e.filename : "message.intl",
        s = !!e.sourceMap,
        i = e.breakLineCode != null ? e.breakLineCode : n === "arrow" ? ";" : `
`,
        o = e.needIndent ? e.needIndent : n !== "arrow",
        a = t.helpers || [],
        l = xme(t, {
            mode: n,
            filename: r,
            sourceMap: s,
            breakLineCode: i,
            needIndent: o
        });
    l.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), l.indent(o), a.length > 0 && (l.push(`const { ${a.map(d=>`${d}: _${d}`).join(", ")} } = ctx`), l.newline()), l.push("return "), Jl(l, t), l.deindent(o), l.push("}");
    const {
        code: u,
        map: f
    } = l.context();
    return {
        ast: t,
        code: u,
        map: f ? f.toJSON() : void 0
    }
};

function Lme(t, e = {}) {
    const n = nr({}, e),
        s = kme(n).parse(t);
    return Nme(s, n), $me(s, n)
}
/*!
 * core-base v9.2.2
 * (c) 2022 kazuya kawaguchi
 * Released under the MIT License.
 */
const Pa = [];
Pa[0] = {
    w: [0],
    i: [3, 0],
    "[": [4],
    o: [7]
};
Pa[1] = {
    w: [1],
    ".": [2],
    "[": [4],
    o: [7]
};
Pa[2] = {
    w: [2],
    i: [3, 0],
    0: [3, 0]
};
Pa[3] = {
    i: [3, 0],
    0: [3, 0],
    w: [1, 1],
    ".": [2, 1],
    "[": [4, 1],
    o: [7, 1]
};
Pa[4] = {
    "'": [5, 0],
    '"': [6, 0],
    "[": [4, 2],
    "]": [1, 3],
    o: 8,
    l: [4, 0]
};
Pa[5] = {
    "'": [4, 0],
    o: 8,
    l: [5, 0]
};
Pa[6] = {
    '"': [4, 0],
    o: 8,
    l: [6, 0]
};
const Fme = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

function Ume(t) {
    return Fme.test(t)
}

function Bme(t) {
    const e = t.charCodeAt(0),
        n = t.charCodeAt(t.length - 1);
    return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t
}

function qme(t) {
    if (t == null) return "o";
    switch (t.charCodeAt(0)) {
        case 91:
        case 93:
        case 46:
        case 34:
        case 39:
            return t;
        case 95:
        case 36:
        case 45:
            return "i";
        case 9:
        case 10:
        case 13:
        case 160:
        case 65279:
        case 8232:
        case 8233:
            return "w"
    }
    return "i"
}

function Gme(t) {
    const e = t.trim();
    return t.charAt(0) === "0" && isNaN(parseInt(t)) ? !1 : Ume(e) ? Bme(e) : "*" + e
}

function Vme(t) {
    const e = [];
    let n = -1,
        r = 0,
        s = 0,
        i, o, a, l, u, f, d;
    const p = [];
    p[0] = () => {
        o === void 0 ? o = a : o += a
    }, p[1] = () => {
        o !== void 0 && (e.push(o), o = void 0)
    }, p[2] = () => {
        p[0](), s++
    }, p[3] = () => {
        if (s > 0) s--, r = 4, p[0]();
        else {
            if (s = 0, o === void 0 || (o = Gme(o), o === !1)) return !1;
            p[1]()
        }
    };

    function _() {
        const v = t[n + 1];
        if (r === 5 && v === "'" || r === 6 && v === '"') return n++, a = "\\" + v, p[0](), !0
    }
    for (; r !== null;)
        if (n++, i = t[n], !(i === "\\" && _())) {
            if (l = qme(i), d = Pa[r], u = d[l] || d.l || 8, u === 8 || (r = u[0], u[1] !== void 0 && (f = p[u[1]], f && (a = i, f() === !1)))) return;
            if (r === 7) return e
        }
}
const ew = new Map;

function jme(t, e) {
    return Jt(t) ? t[e] : null
}

function Wme(t, e) {
    if (!Jt(t)) return null;
    let n = ew.get(e);
    if (n || (n = Vme(e), n && ew.set(e, n)), !n) return null;
    const r = n.length;
    let s = t,
        i = 0;
    for (; i < r;) {
        const o = s[n[i]];
        if (o === void 0) return null;
        s = o, i++
    }
    return s
}
const Hme = t => t,
    Yme = t => "",
    zme = "text",
    Kme = t => t.length === 0 ? "" : t.join(""),
    Zme = gme;

function tw(t, e) {
    return t = Math.abs(t), e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0
}

function Xme(t) {
    const e = Ln(t.pluralIndex) ? t.pluralIndex : -1;
    return t.named && (Ln(t.named.count) || Ln(t.named.n)) ? Ln(t.named.count) ? t.named.count : Ln(t.named.n) ? t.named.n : e : e
}

function Qme(t, e) {
    e.count || (e.count = t), e.n || (e.n = t)
}

function Jme(t = {}) {
    const e = t.locale,
        n = Xme(t),
        r = Jt(t.pluralRules) && Le(e) && On(t.pluralRules[e]) ? t.pluralRules[e] : tw,
        s = Jt(t.pluralRules) && Le(e) && On(t.pluralRules[e]) ? tw : void 0,
        i = b => b[r(n, b.length, s)],
        o = t.list || [],
        a = b => o[b],
        l = t.named || {};
    Ln(t.pluralIndex) && Qme(n, l);
    const u = b => l[b];

    function f(b) {
        const O = On(t.messages) ? t.messages(b) : Jt(t.messages) ? t.messages[b] : !1;
        return O || (t.parent ? t.parent.message(b) : Yme)
    }
    const d = b => t.modifiers ? t.modifiers[b] : Hme,
        p = ht(t.processor) && On(t.processor.normalize) ? t.processor.normalize : Kme,
        _ = ht(t.processor) && On(t.processor.interpolate) ? t.processor.interpolate : Zme,
        v = ht(t.processor) && Le(t.processor.type) ? t.processor.type : zme,
        g = {
            list: a,
            named: u,
            plural: i,
            linked: (b, ...O) => {
                const [N, k] = O;
                let A = "text",
                    x = "";
                O.length === 1 ? Jt(N) ? (x = N.modifier || x, A = N.type || A) : Le(N) && (x = N || x) : O.length === 2 && (Le(N) && (x = N || x), Le(k) && (A = k || A));
                let D = f(b)(g);
                return A === "vnode" && Qt(D) && x && (D = D[0]), x ? d(x)(D, A) : D
            },
            message: f,
            type: v,
            interpolate: _,
            normalize: p
        };
    return g
}

function ege(t, e, n) {
    return [...new Set([n, ...Qt(e) ? e : Jt(e) ? Object.keys(e) : Le(e) ? [e] : [n]])]
}

function lC(t, e, n) {
    const r = Le(n) ? n : Yf,
        s = t;
    s.__localeChainCache || (s.__localeChainCache = new Map);
    let i = s.__localeChainCache.get(r);
    if (!i) {
        i = [];
        let o = [n];
        for (; Qt(o);) o = nw(i, o, e);
        const a = Qt(e) || !ht(e) ? e : e.default ? e.default : null;
        o = Le(a) ? [a] : a, Qt(o) && nw(i, o, !1), s.__localeChainCache.set(r, i)
    }
    return i
}

function nw(t, e, n) {
    let r = !0;
    for (let s = 0; s < e.length && It(r); s++) {
        const i = e[s];
        Le(i) && (r = tge(t, e[s], n))
    }
    return r
}

function tge(t, e, n) {
    let r;
    const s = e.split("-");
    do {
        const i = s.join("-");
        r = nge(t, i, n), s.splice(-1, 1)
    } while (s.length && r === !0);
    return r
}

function nge(t, e, n) {
    let r = !1;
    if (!t.includes(e) && (r = !0, e)) {
        r = e[e.length - 1] !== "!";
        const s = e.replace(/!/g, "");
        t.push(s), (Qt(n) || ht(n)) && n[s] && (r = n[s])
    }
    return r
}
const rge = "9.2.2",
    _g = -1,
    Yf = "en-US",
    rw = "",
    sw = t => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;

function sge() {
    return {
        upper: (t, e) => e === "text" && Le(t) ? t.toUpperCase() : e === "vnode" && Jt(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
        lower: (t, e) => e === "text" && Le(t) ? t.toLowerCase() : e === "vnode" && Jt(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
        capitalize: (t, e) => e === "text" && Le(t) ? sw(t) : e === "vnode" && Jt(t) && "__v_isVNode" in t ? sw(t.children) : t
    }
}
let uC;

function ige(t) {
    uC = t
}
let hC;

function oge(t) {
    hC = t
}
let fC;

function age(t) {
    fC = t
}
let iw = 0;

function cge(t = {}) {
    const e = Le(t.version) ? t.version : rge,
        n = Le(t.locale) ? t.locale : Yf,
        r = Qt(t.fallbackLocale) || ht(t.fallbackLocale) || Le(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : n,
        s = ht(t.messages) ? t.messages : {
            [n]: {}
        },
        i = ht(t.datetimeFormats) ? t.datetimeFormats : {
            [n]: {}
        },
        o = ht(t.numberFormats) ? t.numberFormats : {
            [n]: {}
        },
        a = nr({}, t.modifiers || {}, sge()),
        l = t.pluralRules || {},
        u = On(t.missing) ? t.missing : null,
        f = It(t.missingWarn) || da(t.missingWarn) ? t.missingWarn : !0,
        d = It(t.fallbackWarn) || da(t.fallbackWarn) ? t.fallbackWarn : !0,
        p = !!t.fallbackFormat,
        _ = !!t.unresolving,
        v = On(t.postTranslation) ? t.postTranslation : null,
        y = ht(t.processor) ? t.processor : null,
        g = It(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
        b = !!t.escapeParameter,
        O = On(t.messageCompiler) ? t.messageCompiler : uC,
        N = On(t.messageResolver) ? t.messageResolver : hC || jme,
        k = On(t.localeFallbacker) ? t.localeFallbacker : fC || ege,
        A = Jt(t.fallbackContext) ? t.fallbackContext : void 0,
        x = On(t.onWarn) ? t.onWarn : pme,
        D = t,
        L = Jt(D.__datetimeFormatters) ? D.__datetimeFormatters : new Map,
        q = Jt(D.__numberFormatters) ? D.__numberFormatters : new Map,
        ee = Jt(D.__meta) ? D.__meta : {};
    iw++;
    const ae = {
        version: e,
        cid: iw,
        locale: n,
        fallbackLocale: r,
        messages: s,
        modifiers: a,
        pluralRules: l,
        missing: u,
        missingWarn: f,
        fallbackWarn: d,
        fallbackFormat: p,
        unresolving: _,
        postTranslation: v,
        processor: y,
        warnHtmlMessage: g,
        escapeParameter: b,
        messageCompiler: O,
        messageResolver: N,
        localeFallbacker: k,
        fallbackContext: A,
        onWarn: x,
        __meta: ee
    };
    return ae.datetimeFormats = i, ae.numberFormats = o, ae.__datetimeFormatters = L, ae.__numberFormatters = q, ae
}

function j3(t, e, n, r, s) {
    const {
        missing: i,
        onWarn: o
    } = t;
    if (i !== null) {
        const a = i(t, n, e, s);
        return Le(a) ? a : e
    } else return e
}

function ah(t, e, n) {
    const r = t;
    r.__localeChainCache = new Map, t.localeFallbacker(t, n, e)
}
const lge = t => t;
let ow = Object.create(null);

function uge(t, e = {}) {
    {
        const r = (e.onCacheKey || lge)(t),
            s = ow[r];
        if (s) return s;
        let i = !1;
        const o = e.onError || _me;
        e.onError = u => {
            i = !0, o(u)
        };
        const {
            code: a
        } = Lme(t, e), l = new Function(`return ${a}`)();
        return i ? l : ow[r] = l
    }
}
let dC = Mt.__EXTEND_POINT__;
const zy = () => ++dC,
    gl = {
        INVALID_ARGUMENT: dC,
        INVALID_DATE_ARGUMENT: zy(),
        INVALID_ISO_DATE_ARGUMENT: zy(),
        __EXTEND_POINT__: zy()
    };

function _l(t) {
    return gg(t, null, void 0)
}
const aw = () => "",
    gc = t => On(t);

function cw(t, ...e) {
    const {
        fallbackFormat: n,
        postTranslation: r,
        unresolving: s,
        messageCompiler: i,
        fallbackLocale: o,
        messages: a
    } = t, [l, u] = hv(...e), f = It(u.missingWarn) ? u.missingWarn : t.missingWarn, d = It(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn, p = It(u.escapeParameter) ? u.escapeParameter : t.escapeParameter, _ = !!u.resolvedMessage, v = Le(u.default) || It(u.default) ? It(u.default) ? i ? l : () => l : u.default : n ? i ? l : () => l : "", y = n || v !== "", g = Le(u.locale) ? u.locale : t.locale;
    p && hge(u);
    let [b, O, N] = _ ? [l, g, a[g] || {}] : pC(t, l, g, o, d, f), k = b, A = l;
    if (!_ && !(Le(k) || gc(k)) && y && (k = v, A = k), !_ && (!(Le(k) || gc(k)) || !Le(O))) return s ? _g : l;
    let x = !1;
    const D = () => {
            x = !0
        },
        L = gc(k) ? k : mC(t, l, O, k, A, D);
    if (x) return k;
    const q = pge(t, O, N, u),
        ee = Jme(q),
        ae = fge(t, L, ee);
    return r ? r(ae, l) : ae
}

function hge(t) {
    Qt(t.list) ? t.list = t.list.map(e => Le(e) ? X6(e) : e) : Jt(t.named) && Object.keys(t.named).forEach(e => {
        Le(t.named[e]) && (t.named[e] = X6(t.named[e]))
    })
}

function pC(t, e, n, r, s, i) {
    const {
        messages: o,
        onWarn: a,
        messageResolver: l,
        localeFallbacker: u
    } = t, f = u(t, r, n);
    let d = {},
        p, _ = null;
    const v = "translate";
    for (let y = 0; y < f.length && (p = f[y], d = o[p] || {}, (_ = l(d, e)) === null && (_ = d[e]), !(Le(_) || On(_))); y++) {
        const g = j3(t, e, p, i, v);
        g !== e && (_ = g)
    }
    return [_, p, d]
}

function mC(t, e, n, r, s, i) {
    const {
        messageCompiler: o,
        warnHtmlMessage: a
    } = t;
    if (gc(r)) {
        const u = r;
        return u.locale = u.locale || n, u.key = u.key || e, u
    }
    if (o == null) {
        const u = () => r;
        return u.locale = n, u.key = e, u
    }
    const l = o(r, dge(t, n, s, r, a, i));
    return l.locale = n, l.key = e, l.source = r, l
}

function fge(t, e, n) {
    return e(n)
}

function hv(...t) {
    const [e, n, r] = t, s = {};
    if (!Le(e) && !Ln(e) && !gc(e)) throw _l(gl.INVALID_ARGUMENT);
    const i = Ln(e) ? String(e) : (gc(e), e);
    return Ln(n) ? s.plural = n : Le(n) ? s.default = n : ht(n) && !mg(n) ? s.named = n : Qt(n) && (s.list = n), Ln(r) ? s.plural = r : Le(r) ? s.default = r : ht(r) && nr(s, r), [i, s]
}

function dge(t, e, n, r, s, i) {
    return {
        warnHtmlMessage: s,
        onError: o => {
            throw i && i(o), o
        },
        onCacheKey: o => hme(e, n, o)
    }
}

function pge(t, e, n, r) {
    const {
        modifiers: s,
        pluralRules: i,
        messageResolver: o,
        fallbackLocale: a,
        fallbackWarn: l,
        missingWarn: u,
        fallbackContext: f
    } = t, p = {
        locale: e,
        modifiers: s,
        pluralRules: i,
        messages: _ => {
            let v = o(n, _);
            if (v == null && f) {
                const [, , y] = pC(f, _, e, a, l, u);
                v = o(y, _)
            }
            if (Le(v)) {
                let y = !1;
                const b = mC(t, _, e, v, _, () => {
                    y = !0
                });
                return y ? aw : b
            } else return gc(v) ? v : aw
        }
    };
    return t.processor && (p.processor = t.processor), r.list && (p.list = r.list), r.named && (p.named = r.named), Ln(r.plural) && (p.pluralIndex = r.plural), p
}

function lw(t, ...e) {
    const {
        datetimeFormats: n,
        unresolving: r,
        fallbackLocale: s,
        onWarn: i,
        localeFallbacker: o
    } = t, {
        __datetimeFormatters: a
    } = t, [l, u, f, d] = fv(...e), p = It(f.missingWarn) ? f.missingWarn : t.missingWarn;
    It(f.fallbackWarn) ? f.fallbackWarn : t.fallbackWarn;
    const _ = !!f.part,
        v = Le(f.locale) ? f.locale : t.locale,
        y = o(t, s, v);
    if (!Le(l) || l === "") return new Intl.DateTimeFormat(v, d).format(u);
    let g = {},
        b, O = null;
    const N = "datetime format";
    for (let x = 0; x < y.length && (b = y[x], g = n[b] || {}, O = g[l], !ht(O)); x++) j3(t, l, b, p, N);
    if (!ht(O) || !Le(b)) return r ? _g : l;
    let k = `${b}__${l}`;
    mg(d) || (k = `${k}__${JSON.stringify(d)}`);
    let A = a.get(k);
    return A || (A = new Intl.DateTimeFormat(b, nr({}, O, d)), a.set(k, A)), _ ? A.formatToParts(u) : A.format(u)
}
const gC = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];

function fv(...t) {
    const [e, n, r, s] = t, i = {};
    let o = {},
        a;
    if (Le(e)) {
        const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
        if (!l) throw _l(gl.INVALID_ISO_DATE_ARGUMENT);
        const u = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
        a = new Date(u);
        try {
            a.toISOString()
        } catch {
            throw _l(gl.INVALID_ISO_DATE_ARGUMENT)
        }
    } else if (dme(e)) {
        if (isNaN(e.getTime())) throw _l(gl.INVALID_DATE_ARGUMENT);
        a = e
    } else if (Ln(e)) a = e;
    else throw _l(gl.INVALID_ARGUMENT);
    return Le(n) ? i.key = n : ht(n) && Object.keys(n).forEach(l => {
        gC.includes(l) ? o[l] = n[l] : i[l] = n[l]
    }), Le(r) ? i.locale = r : ht(r) && (o = r), ht(s) && (o = s), [i.key || "", a, i, o]
}

function uw(t, e, n) {
    const r = t;
    for (const s in n) {
        const i = `${e}__${s}`;
        r.__datetimeFormatters.has(i) && r.__datetimeFormatters.delete(i)
    }
}

function hw(t, ...e) {
    const {
        numberFormats: n,
        unresolving: r,
        fallbackLocale: s,
        onWarn: i,
        localeFallbacker: o
    } = t, {
        __numberFormatters: a
    } = t, [l, u, f, d] = dv(...e), p = It(f.missingWarn) ? f.missingWarn : t.missingWarn;
    It(f.fallbackWarn) ? f.fallbackWarn : t.fallbackWarn;
    const _ = !!f.part,
        v = Le(f.locale) ? f.locale : t.locale,
        y = o(t, s, v);
    if (!Le(l) || l === "") return new Intl.NumberFormat(v, d).format(u);
    let g = {},
        b, O = null;
    const N = "number format";
    for (let x = 0; x < y.length && (b = y[x], g = n[b] || {}, O = g[l], !ht(O)); x++) j3(t, l, b, p, N);
    if (!ht(O) || !Le(b)) return r ? _g : l;
    let k = `${b}__${l}`;
    mg(d) || (k = `${k}__${JSON.stringify(d)}`);
    let A = a.get(k);
    return A || (A = new Intl.NumberFormat(b, nr({}, O, d)), a.set(k, A)), _ ? A.formatToParts(u) : A.format(u)
}
const _C = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];

function dv(...t) {
    const [e, n, r, s] = t, i = {};
    let o = {};
    if (!Ln(e)) throw _l(gl.INVALID_ARGUMENT);
    const a = e;
    return Le(n) ? i.key = n : ht(n) && Object.keys(n).forEach(l => {
        _C.includes(l) ? o[l] = n[l] : i[l] = n[l]
    }), Le(r) ? i.locale = r : ht(r) && (o = r), ht(s) && (o = s), [i.key || "", a, i, o]
}

function fw(t, e, n) {
    const r = t;
    for (const s in n) {
        const i = `${e}__${s}`;
        r.__numberFormatters.has(i) && r.__numberFormatters.delete(i)
    }
}
/*!
 * vue-i18n v9.2.2
 * (c) 2022 kazuya kawaguchi
 * Released under the MIT License.
 */
const mge = "9.2.2";
let yC = Mt.__EXTEND_POINT__;
const Nr = () => ++yC,
    Pn = {
        UNEXPECTED_RETURN_TYPE: yC,
        INVALID_ARGUMENT: Nr(),
        MUST_BE_CALL_SETUP_TOP: Nr(),
        NOT_INSLALLED: Nr(),
        NOT_AVAILABLE_IN_LEGACY_MODE: Nr(),
        REQUIRED_VALUE: Nr(),
        INVALID_VALUE: Nr(),
        CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: Nr(),
        NOT_INSLALLED_WITH_PROVIDE: Nr(),
        UNEXPECTED_ERROR: Nr(),
        NOT_COMPATIBLE_LEGACY_VUE_I18N: Nr(),
        BRIDGE_SUPPORT_VUE_2_ONLY: Nr(),
        MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: Nr(),
        NOT_AVAILABLE_COMPOSITION_IN_LEGACY: Nr(),
        __EXTEND_POINT__: Nr()
    };

function Fn(t, ...e) {
    return gg(t, null, void 0)
}
const pv = xa("__transrateVNode"),
    mv = xa("__datetimeParts"),
    gv = xa("__numberParts"),
    vC = xa("__setPluralRules");
xa("__intlifyMeta");
const bC = xa("__injectWithOption");

function _v(t) {
    if (!Jt(t)) return t;
    for (const e in t)
        if (q3(t, e))
            if (!e.includes(".")) Jt(t[e]) && _v(t[e]);
            else {
                const n = e.split("."),
                    r = n.length - 1;
                let s = t;
                for (let i = 0; i < r; i++) n[i] in s || (s[n[i]] = {}), s = s[n[i]];
                s[n[r]] = t[e], delete t[e], Jt(s[n[r]]) && _v(s[n[r]])
            } return t
}

function yg(t, e) {
    const {
        messages: n,
        __i18n: r,
        messageResolver: s,
        flatJson: i
    } = e, o = ht(n) ? n : Qt(r) ? {} : {
        [t]: {}
    };
    if (Qt(r) && r.forEach(a => {
            if ("locale" in a && "resource" in a) {
                const {
                    locale: l,
                    resource: u
                } = a;
                l ? (o[l] = o[l] || {}, Ph(u, o[l])) : Ph(u, o)
            } else Le(a) && Ph(JSON.parse(a), o)
        }), s == null && i)
        for (const a in o) q3(o, a) && _v(o[a]);
    return o
}
const Op = t => !Jt(t) || Qt(t);

function Ph(t, e) {
    if (Op(t) || Op(e)) throw Fn(Pn.INVALID_VALUE);
    for (const n in t) q3(t, n) && (Op(t[n]) || Op(e[n]) ? e[n] = t[n] : Ph(t[n], e[n]))
}

function gge(t) {
    return t.type
}

function EC(t, e, n) {
    let r = Jt(e.messages) ? e.messages : {};
    "__i18nGlobal" in n && (r = yg(t.locale.value, {
        messages: r,
        __i18n: n.__i18nGlobal
    }));
    const s = Object.keys(r);
    s.length && s.forEach(i => {
        t.mergeLocaleMessage(i, r[i])
    }); {
        if (Jt(e.datetimeFormats)) {
            const i = Object.keys(e.datetimeFormats);
            i.length && i.forEach(o => {
                t.mergeDateTimeFormat(o, e.datetimeFormats[o])
            })
        }
        if (Jt(e.numberFormats)) {
            const i = Object.keys(e.numberFormats);
            i.length && i.forEach(o => {
                t.mergeNumberFormat(o, e.numberFormats[o])
            })
        }
    }
}

function dw(t) {
    return Ve(Rf, null, t, 0)
}
let pw = 0;

function mw(t) {
    return (e, n, r, s) => t(n, r, Yh() || void 0, s)
}

function W3(t = {}, e) {
    const {
        __root: n
    } = t, r = n === void 0;
    let s = It(t.inheritLocale) ? t.inheritLocale : !0;
    const i = ts(n && s ? n.locale.value : Le(t.locale) ? t.locale : Yf),
        o = ts(n && s ? n.fallbackLocale.value : Le(t.fallbackLocale) || Qt(t.fallbackLocale) || ht(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : i.value),
        a = ts(yg(i.value, t)),
        l = ts(ht(t.datetimeFormats) ? t.datetimeFormats : {
            [i.value]: {}
        }),
        u = ts(ht(t.numberFormats) ? t.numberFormats : {
            [i.value]: {}
        });
    let f = n ? n.missingWarn : It(t.missingWarn) || da(t.missingWarn) ? t.missingWarn : !0,
        d = n ? n.fallbackWarn : It(t.fallbackWarn) || da(t.fallbackWarn) ? t.fallbackWarn : !0,
        p = n ? n.fallbackRoot : It(t.fallbackRoot) ? t.fallbackRoot : !0,
        _ = !!t.fallbackFormat,
        v = On(t.missing) ? t.missing : null,
        y = On(t.missing) ? mw(t.missing) : null,
        g = On(t.postTranslation) ? t.postTranslation : null,
        b = n ? n.warnHtmlMessage : It(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
        O = !!t.escapeParameter;
    const N = n ? n.modifiers : ht(t.modifiers) ? t.modifiers : {};
    let k = t.pluralRules || n && n.pluralRules,
        A;
    A = (() => {
        const oe = {
            version: mge,
            locale: i.value,
            fallbackLocale: o.value,
            messages: a.value,
            modifiers: N,
            pluralRules: k,
            missing: y === null ? void 0 : y,
            missingWarn: f,
            fallbackWarn: d,
            fallbackFormat: _,
            unresolving: !0,
            postTranslation: g === null ? void 0 : g,
            warnHtmlMessage: b,
            escapeParameter: O,
            messageResolver: t.messageResolver,
            __meta: {
                framework: "vue"
            }
        };
        return oe.datetimeFormats = l.value, oe.numberFormats = u.value, oe.__datetimeFormatters = ht(A) ? A.__datetimeFormatters : void 0, oe.__numberFormatters = ht(A) ? A.__numberFormatters : void 0, cge(oe)
    })(), ah(A, i.value, o.value);

    function D() {
        return [i.value, o.value, a.value, l.value, u.value]
    }
    const L = ns({
            get: () => i.value,
            set: oe => {
                i.value = oe, A.locale = i.value
            }
        }),
        q = ns({
            get: () => o.value,
            set: oe => {
                o.value = oe, A.fallbackLocale = o.value, ah(A, i.value, oe)
            }
        }),
        ee = ns(() => a.value),
        ae = ns(() => l.value),
        Z = ns(() => u.value);

    function fe() {
        return On(g) ? g : null
    }

    function ge(oe) {
        g = oe, A.postTranslation = oe
    }

    function K() {
        return v
    }

    function Q(oe) {
        oe !== null && (y = mw(oe)), v = oe, A.missing = y
    }
    const ue = (oe, he, Me, Fe, at, vt) => {
        D();
        let W;
        if (W = oe(A), Ln(W) && W === _g) {
            const [V, se] = he();
            return n && p ? Fe(n) : at(V)
        } else {
            if (vt(W)) return W;
            throw Fn(Pn.UNEXPECTED_RETURN_TYPE)
        }
    };

    function _e(...oe) {
        return ue(he => Reflect.apply(cw, null, [he, ...oe]), () => hv(...oe), "translate", he => Reflect.apply(he.t, he, [...oe]), he => he, he => Le(he))
    }

    function Oe(...oe) {
        const [he, Me, Fe] = oe;
        if (Fe && !Jt(Fe)) throw Fn(Pn.INVALID_ARGUMENT);
        return _e(he, Me, nr({
            resolvedMessage: !0
        }, Fe || {}))
    }

    function Ee(...oe) {
        return ue(he => Reflect.apply(lw, null, [he, ...oe]), () => fv(...oe), "datetime format", he => Reflect.apply(he.d, he, [...oe]), () => rw, he => Le(he))
    }

    function Ce(...oe) {
        return ue(he => Reflect.apply(hw, null, [he, ...oe]), () => dv(...oe), "number format", he => Reflect.apply(he.n, he, [...oe]), () => rw, he => Le(he))
    }

    function De(oe) {
        return oe.map(he => Le(he) || Ln(he) || It(he) ? dw(String(he)) : he)
    }
    const ot = {
        normalize: De,
        interpolate: oe => oe,
        type: "vnode"
    };

    function je(...oe) {
        return ue(he => {
            let Me;
            const Fe = he;
            try {
                Fe.processor = ot, Me = Reflect.apply(cw, null, [Fe, ...oe])
            } finally {
                Fe.processor = null
            }
            return Me
        }, () => hv(...oe), "translate", he => he[pv](...oe), he => [dw(he)], he => Qt(he))
    }

    function Ze(...oe) {
        return ue(he => Reflect.apply(hw, null, [he, ...oe]), () => dv(...oe), "number format", he => he[gv](...oe), () => [], he => Le(he) || Qt(he))
    }

    function it(...oe) {
        return ue(he => Reflect.apply(lw, null, [he, ...oe]), () => fv(...oe), "datetime format", he => he[mv](...oe), () => [], he => Le(he) || Qt(he))
    }

    function w(oe) {
        k = oe, A.pluralRules = k
    }

    function M(oe, he) {
        const Me = Le(he) ? he : i.value,
            Fe = I(Me);
        return A.messageResolver(Fe, oe) !== null
    }

    function Y(oe) {
        let he = null;
        const Me = lC(A, o.value, i.value);
        for (let Fe = 0; Fe < Me.length; Fe++) {
            const at = a.value[Me[Fe]] || {},
                vt = A.messageResolver(at, oe);
            if (vt != null) {
                he = vt;
                break
            }
        }
        return he
    }

    function X(oe) {
        const he = Y(oe);
        return he ?? (n ? n.tm(oe) || {} : {})
    }

    function I(oe) {
        return a.value[oe] || {}
    }

    function T(oe, he) {
        a.value[oe] = he, A.messages = a.value
    }

    function S(oe, he) {
        a.value[oe] = a.value[oe] || {}, Ph(he, a.value[oe]), A.messages = a.value
    }

    function P(oe) {
        return l.value[oe] || {}
    }

    function G(oe, he) {
        l.value[oe] = he, A.datetimeFormats = l.value, uw(A, oe, he)
    }

    function te(oe, he) {
        l.value[oe] = nr(l.value[oe] || {}, he), A.datetimeFormats = l.value, uw(A, oe, he)
    }

    function le(oe) {
        return u.value[oe] || {}
    }

    function me(oe, he) {
        u.value[oe] = he, A.numberFormats = u.value, fw(A, oe, he)
    }

    function ve(oe, he) {
        u.value[oe] = nr(u.value[oe] || {}, he), A.numberFormats = u.value, fw(A, oe, he)
    }
    pw++, n && lv && (na(n.locale, oe => {
        s && (i.value = oe, A.locale = oe, ah(A, i.value, o.value))
    }), na(n.fallbackLocale, oe => {
        s && (o.value = oe, A.fallbackLocale = oe, ah(A, i.value, o.value))
    }));
    const de = {
        id: pw,
        locale: L,
        fallbackLocale: q,
        get inheritLocale() {
            return s
        },
        set inheritLocale(oe) {
            s = oe, oe && n && (i.value = n.locale.value, o.value = n.fallbackLocale.value, ah(A, i.value, o.value))
        },
        get availableLocales() {
            return Object.keys(a.value).sort()
        },
        messages: ee,
        get modifiers() {
            return N
        },
        get pluralRules() {
            return k || {}
        },
        get isGlobal() {
            return r
        },
        get missingWarn() {
            return f
        },
        set missingWarn(oe) {
            f = oe, A.missingWarn = f
        },
        get fallbackWarn() {
            return d
        },
        set fallbackWarn(oe) {
            d = oe, A.fallbackWarn = d
        },
        get fallbackRoot() {
            return p
        },
        set fallbackRoot(oe) {
            p = oe
        },
        get fallbackFormat() {
            return _
        },
        set fallbackFormat(oe) {
            _ = oe, A.fallbackFormat = _
        },
        get warnHtmlMessage() {
            return b
        },
        set warnHtmlMessage(oe) {
            b = oe, A.warnHtmlMessage = oe
        },
        get escapeParameter() {
            return O
        },
        set escapeParameter(oe) {
            O = oe, A.escapeParameter = oe
        },
        t: _e,
        getLocaleMessage: I,
        setLocaleMessage: T,
        mergeLocaleMessage: S,
        getPostTranslationHandler: fe,
        setPostTranslationHandler: ge,
        getMissingHandler: K,
        setMissingHandler: Q,
        [vC]: w
    };
    return de.datetimeFormats = ae, de.numberFormats = Z, de.rt = Oe, de.te = M, de.tm = X, de.d = Ee, de.n = Ce, de.getDateTimeFormat = P, de.setDateTimeFormat = G, de.mergeDateTimeFormat = te, de.getNumberFormat = le, de.setNumberFormat = me, de.mergeNumberFormat = ve, de[bC] = t.__injectWithOption, de[pv] = je, de[mv] = it, de[gv] = Ze, de
}

function _ge(t) {
    const e = Le(t.locale) ? t.locale : Yf,
        n = Le(t.fallbackLocale) || Qt(t.fallbackLocale) || ht(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : e,
        r = On(t.missing) ? t.missing : void 0,
        s = It(t.silentTranslationWarn) || da(t.silentTranslationWarn) ? !t.silentTranslationWarn : !0,
        i = It(t.silentFallbackWarn) || da(t.silentFallbackWarn) ? !t.silentFallbackWarn : !0,
        o = It(t.fallbackRoot) ? t.fallbackRoot : !0,
        a = !!t.formatFallbackMessages,
        l = ht(t.modifiers) ? t.modifiers : {},
        u = t.pluralizationRules,
        f = On(t.postTranslation) ? t.postTranslation : void 0,
        d = Le(t.warnHtmlInMessage) ? t.warnHtmlInMessage !== "off" : !0,
        p = !!t.escapeParameterHtml,
        _ = It(t.sync) ? t.sync : !0;
    let v = t.messages;
    if (ht(t.sharedMessages)) {
        const A = t.sharedMessages;
        v = Object.keys(A).reduce((D, L) => {
            const q = D[L] || (D[L] = {});
            return nr(q, A[L]), D
        }, v || {})
    }
    const {
        __i18n: y,
        __root: g,
        __injectWithOption: b
    } = t, O = t.datetimeFormats, N = t.numberFormats, k = t.flatJson;
    return {
        locale: e,
        fallbackLocale: n,
        messages: v,
        flatJson: k,
        datetimeFormats: O,
        numberFormats: N,
        missing: r,
        missingWarn: s,
        fallbackWarn: i,
        fallbackRoot: o,
        fallbackFormat: a,
        modifiers: l,
        pluralRules: u,
        postTranslation: f,
        warnHtmlMessage: d,
        escapeParameter: p,
        messageResolver: t.messageResolver,
        inheritLocale: _,
        __i18n: y,
        __root: g,
        __injectWithOption: b
    }
}

function yv(t = {}, e) {
    {
        const n = W3(_ge(t)),
            r = {
                id: n.id,
                get locale() {
                    return n.locale.value
                },
                set locale(s) {
                    n.locale.value = s
                },
                get fallbackLocale() {
                    return n.fallbackLocale.value
                },
                set fallbackLocale(s) {
                    n.fallbackLocale.value = s
                },
                get messages() {
                    return n.messages.value
                },
                get datetimeFormats() {
                    return n.datetimeFormats.value
                },
                get numberFormats() {
                    return n.numberFormats.value
                },
                get availableLocales() {
                    return n.availableLocales
                },
                get formatter() {
                    return {
                        interpolate() {
                            return []
                        }
                    }
                },
                set formatter(s) {},
                get missing() {
                    return n.getMissingHandler()
                },
                set missing(s) {
                    n.setMissingHandler(s)
                },
                get silentTranslationWarn() {
                    return It(n.missingWarn) ? !n.missingWarn : n.missingWarn
                },
                set silentTranslationWarn(s) {
                    n.missingWarn = It(s) ? !s : s
                },
                get silentFallbackWarn() {
                    return It(n.fallbackWarn) ? !n.fallbackWarn : n.fallbackWarn
                },
                set silentFallbackWarn(s) {
                    n.fallbackWarn = It(s) ? !s : s
                },
                get modifiers() {
                    return n.modifiers
                },
                get formatFallbackMessages() {
                    return n.fallbackFormat
                },
                set formatFallbackMessages(s) {
                    n.fallbackFormat = s
                },
                get postTranslation() {
                    return n.getPostTranslationHandler()
                },
                set postTranslation(s) {
                    n.setPostTranslationHandler(s)
                },
                get sync() {
                    return n.inheritLocale
                },
                set sync(s) {
                    n.inheritLocale = s
                },
                get warnHtmlInMessage() {
                    return n.warnHtmlMessage ? "warn" : "off"
                },
                set warnHtmlInMessage(s) {
                    n.warnHtmlMessage = s !== "off"
                },
                get escapeParameterHtml() {
                    return n.escapeParameter
                },
                set escapeParameterHtml(s) {
                    n.escapeParameter = s
                },
                get preserveDirectiveContent() {
                    return !0
                },
                set preserveDirectiveContent(s) {},
                get pluralizationRules() {
                    return n.pluralRules || {}
                },
                __composer: n,
                t(...s) {
                    const [i, o, a] = s, l = {};
                    let u = null,
                        f = null;
                    if (!Le(i)) throw Fn(Pn.INVALID_ARGUMENT);
                    const d = i;
                    return Le(o) ? l.locale = o : Qt(o) ? u = o : ht(o) && (f = o), Qt(a) ? u = a : ht(a) && (f = a), Reflect.apply(n.t, n, [d, u || f || {}, l])
                },
                rt(...s) {
                    return Reflect.apply(n.rt, n, [...s])
                },
                tc(...s) {
                    const [i, o, a] = s, l = {
                        plural: 1
                    };
                    let u = null,
                        f = null;
                    if (!Le(i)) throw Fn(Pn.INVALID_ARGUMENT);
                    const d = i;
                    return Le(o) ? l.locale = o : Ln(o) ? l.plural = o : Qt(o) ? u = o : ht(o) && (f = o), Le(a) ? l.locale = a : Qt(a) ? u = a : ht(a) && (f = a), Reflect.apply(n.t, n, [d, u || f || {}, l])
                },
                te(s, i) {
                    return n.te(s, i)
                },
                tm(s) {
                    return n.tm(s)
                },
                getLocaleMessage(s) {
                    return n.getLocaleMessage(s)
                },
                setLocaleMessage(s, i) {
                    n.setLocaleMessage(s, i)
                },
                mergeLocaleMessage(s, i) {
                    n.mergeLocaleMessage(s, i)
                },
                d(...s) {
                    return Reflect.apply(n.d, n, [...s])
                },
                getDateTimeFormat(s) {
                    return n.getDateTimeFormat(s)
                },
                setDateTimeFormat(s, i) {
                    n.setDateTimeFormat(s, i)
                },
                mergeDateTimeFormat(s, i) {
                    n.mergeDateTimeFormat(s, i)
                },
                n(...s) {
                    return Reflect.apply(n.n, n, [...s])
                },
                getNumberFormat(s) {
                    return n.getNumberFormat(s)
                },
                setNumberFormat(s, i) {
                    n.setNumberFormat(s, i)
                },
                mergeNumberFormat(s, i) {
                    n.mergeNumberFormat(s, i)
                },
                getChoiceIndex(s, i) {
                    return -1
                },
                __onComponentInstanceCreated(s) {
                    const {
                        componentInstanceCreatedListener: i
                    } = t;
                    i && i(s, r)
                }
            };
        return r
    }
}
const H3 = {
    tag: {
        type: [String, Object]
    },
    locale: {
        type: String
    },
    scope: {
        type: String,
        validator: t => t === "parent" || t === "global",
        default: "parent"
    },
    i18n: {
        type: Object
    }
};

function yge({
    slots: t
}, e) {
    return e.length === 1 && e[0] === "default" ? (t.default ? t.default() : []).reduce((r, s) => r = [...r, ...Qt(s.children) ? s.children : [s]], []) : e.reduce((n, r) => {
        const s = t[r];
        return s && (n[r] = s()), n
    }, {})
}

function TC(t) {
    return lt
}
const gw = {
    name: "i18n-t",
    props: nr({
        keypath: {
            type: String,
            required: !0
        },
        plural: {
            type: [Number, String],
            validator: t => Ln(t) || !isNaN(t)
        }
    }, H3),
    setup(t, e) {
        const {
            slots: n,
            attrs: r
        } = e, s = t.i18n || Y3({
            useScope: t.scope,
            __useComponent: !0
        });
        return () => {
            const i = Object.keys(n).filter(d => d !== "_"),
                o = {};
            t.locale && (o.locale = t.locale), t.plural !== void 0 && (o.plural = Le(t.plural) ? +t.plural : t.plural);
            const a = yge(e, i),
                l = s[pv](t.keypath, a, o),
                u = nr({}, r),
                f = Le(t.tag) || Jt(t.tag) ? t.tag : TC();
            return b2(f, u, l)
        }
    }
};

function vge(t) {
    return Qt(t) && !Le(t[0])
}

function SC(t, e, n, r) {
    const {
        slots: s,
        attrs: i
    } = e;
    return () => {
        const o = {
            part: !0
        };
        let a = {};
        t.locale && (o.locale = t.locale), Le(t.format) ? o.key = t.format : Jt(t.format) && (Le(t.format.key) && (o.key = t.format.key), a = Object.keys(t.format).reduce((p, _) => n.includes(_) ? nr({}, p, {
            [_]: t.format[_]
        }) : p, {}));
        const l = r(t.value, o, a);
        let u = [o.key];
        Qt(l) ? u = l.map((p, _) => {
            const v = s[p.type],
                y = v ? v({
                    [p.type]: p.value,
                    index: _,
                    parts: l
                }) : [p.value];
            return vge(y) && (y[0].key = `${p.type}-${_}`), y
        }) : Le(l) && (u = [l]);
        const f = nr({}, i),
            d = Le(t.tag) || Jt(t.tag) ? t.tag : TC();
        return b2(d, f, u)
    }
}
const _w = {
        name: "i18n-n",
        props: nr({
            value: {
                type: Number,
                required: !0
            },
            format: {
                type: [String, Object]
            }
        }, H3),
        setup(t, e) {
            const n = t.i18n || Y3({
                useScope: "parent",
                __useComponent: !0
            });
            return SC(t, e, _C, (...r) => n[gv](...r))
        }
    },
    yw = {
        name: "i18n-d",
        props: nr({
            value: {
                type: [Number, Date],
                required: !0
            },
            format: {
                type: [String, Object]
            }
        }, H3),
        setup(t, e) {
            const n = t.i18n || Y3({
                useScope: "parent",
                __useComponent: !0
            });
            return SC(t, e, gC, (...r) => n[mv](...r))
        }
    };

function bge(t, e) {
    const n = t;
    if (t.mode === "composition") return n.__getInstance(e) || t.global; {
        const r = n.__getInstance(e);
        return r != null ? r.__composer : t.global.__composer
    }
}

function Ege(t) {
    const e = o => {
        const {
            instance: a,
            modifiers: l,
            value: u
        } = o;
        if (!a || !a.$) throw Fn(Pn.UNEXPECTED_ERROR);
        const f = bge(t, a.$),
            d = vw(u);
        return [Reflect.apply(f.t, f, [...bw(d)]), f]
    };
    return {
        created: (o, a) => {
            const [l, u] = e(a);
            lv && t.global === u && (o.__i18nWatcher = na(u.locale, () => {
                a.instance && a.instance.$forceUpdate()
            })), o.__composer = u, o.textContent = l
        },
        unmounted: o => {
            lv && o.__i18nWatcher && (o.__i18nWatcher(), o.__i18nWatcher = void 0, delete o.__i18nWatcher), o.__composer && (o.__composer = void 0, delete o.__composer)
        },
        beforeUpdate: (o, {
            value: a
        }) => {
            if (o.__composer) {
                const l = o.__composer,
                    u = vw(a);
                o.textContent = Reflect.apply(l.t, l, [...bw(u)])
            }
        },
        getSSRProps: o => {
            const [a] = e(o);
            return {
                textContent: a
            }
        }
    }
}

function vw(t) {
    if (Le(t)) return {
        path: t
    };
    if (ht(t)) {
        if (!("path" in t)) throw Fn(Pn.REQUIRED_VALUE, "path");
        return t
    } else throw Fn(Pn.INVALID_VALUE)
}

function bw(t) {
    const {
        path: e,
        locale: n,
        args: r,
        choice: s,
        plural: i
    } = t, o = {}, a = r || {};
    return Le(n) && (o.locale = n), Ln(s) && (o.plural = s), Ln(i) && (o.plural = i), [e, a, o]
}

function Tge(t, e, ...n) {
    const r = ht(n[0]) ? n[0] : {},
        s = !!r.useI18nComponentName;
    (It(r.globalInstall) ? r.globalInstall : !0) && (t.component(s ? "i18n" : gw.name, gw), t.component(_w.name, _w), t.component(yw.name, yw)), t.directive("t", Ege(e))
}

function Sge(t, e, n) {
    return {
        beforeCreate() {
            const r = Yh();
            if (!r) throw Fn(Pn.UNEXPECTED_ERROR);
            const s = this.$options;
            if (s.i18n) {
                const i = s.i18n;
                s.__i18n && (i.__i18n = s.__i18n), i.__root = e, this === this.$root ? this.$i18n = Ew(t, i) : (i.__injectWithOption = !0, this.$i18n = yv(i))
            } else s.__i18n ? this === this.$root ? this.$i18n = Ew(t, s) : this.$i18n = yv({
                __i18n: s.__i18n,
                __injectWithOption: !0,
                __root: e
            }) : this.$i18n = t;
            s.__i18nGlobal && EC(e, s, s), t.__onComponentInstanceCreated(this.$i18n), n.__setInstance(r, this.$i18n), this.$t = (...i) => this.$i18n.t(...i), this.$rt = (...i) => this.$i18n.rt(...i), this.$tc = (...i) => this.$i18n.tc(...i), this.$te = (i, o) => this.$i18n.te(i, o), this.$d = (...i) => this.$i18n.d(...i), this.$n = (...i) => this.$i18n.n(...i), this.$tm = i => this.$i18n.tm(i)
        },
        mounted() {},
        unmounted() {
            const r = Yh();
            if (!r) throw Fn(Pn.UNEXPECTED_ERROR);
            delete this.$t, delete this.$rt, delete this.$tc, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, n.__deleteInstance(r), delete this.$i18n
        }
    }
}

function Ew(t, e) {
    t.locale = e.locale || t.locale, t.fallbackLocale = e.fallbackLocale || t.fallbackLocale, t.missing = e.missing || t.missing, t.silentTranslationWarn = e.silentTranslationWarn || t.silentFallbackWarn, t.silentFallbackWarn = e.silentFallbackWarn || t.silentFallbackWarn, t.formatFallbackMessages = e.formatFallbackMessages || t.formatFallbackMessages, t.postTranslation = e.postTranslation || t.postTranslation, t.warnHtmlInMessage = e.warnHtmlInMessage || t.warnHtmlInMessage, t.escapeParameterHtml = e.escapeParameterHtml || t.escapeParameterHtml, t.sync = e.sync || t.sync, t.__composer[vC](e.pluralizationRules || t.pluralizationRules);
    const n = yg(t.locale, {
        messages: e.messages,
        __i18n: e.__i18n
    });
    return Object.keys(n).forEach(r => t.mergeLocaleMessage(r, n[r])), e.datetimeFormats && Object.keys(e.datetimeFormats).forEach(r => t.mergeDateTimeFormat(r, e.datetimeFormats[r])), e.numberFormats && Object.keys(e.numberFormats).forEach(r => t.mergeNumberFormat(r, e.numberFormats[r])), t
}
const wge = xa("global-vue-i18n");

function Age(t = {}, e) {
    const n = It(t.legacy) ? t.legacy : !0,
        r = It(t.globalInjection) ? t.globalInjection : !0,
        s = n ? !!t.allowComposition : !0,
        i = new Map,
        [o, a] = Oge(t, n),
        l = xa("");

    function u(p) {
        return i.get(p) || null
    }

    function f(p, _) {
        i.set(p, _)
    }

    function d(p) {
        i.delete(p)
    } {
        const p = {
            get mode() {
                return n ? "legacy" : "composition"
            },
            get allowComposition() {
                return s
            },
            async install(_, ...v) {
                _.__VUE_I18N_SYMBOL__ = l, _.provide(_.__VUE_I18N_SYMBOL__, p), !n && r && Dge(_, p.global), Tge(_, p, ...v), n && _.mixin(Sge(a, a.__composer, p));
                const y = _.unmount;
                _.unmount = () => {
                    p.dispose(), y()
                }
            },
            get global() {
                return a
            },
            dispose() {
                o.stop()
            },
            __instances: i,
            __getInstance: u,
            __setInstance: f,
            __deleteInstance: d
        };
        return p
    }
}

function Y3(t = {}) {
    const e = Yh();
    if (e == null) throw Fn(Pn.MUST_BE_CALL_SETUP_TOP);
    if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__) throw Fn(Pn.NOT_INSLALLED);
    const n = Cge(e),
        r = Ige(n),
        s = gge(e),
        i = kge(t, s);
    if (n.mode === "legacy" && !t.__useComponent) {
        if (!n.allowComposition) throw Fn(Pn.NOT_AVAILABLE_IN_LEGACY_MODE);
        return Pge(e, i, r, t)
    }
    if (i === "global") return EC(r, t, s), r;
    if (i === "parent") {
        let l = Nge(n, e, t.__useComponent);
        return l == null && (l = r), l
    }
    const o = n;
    let a = o.__getInstance(e);
    if (a == null) {
        const l = nr({}, t);
        "__i18n" in s && (l.__i18n = s.__i18n), r && (l.__root = r), a = W3(l), xge(o, e), o.__setInstance(e, a)
    }
    return a
}

function Oge(t, e, n) {
    const r = fF(); {
        const s = e ? r.run(() => yv(t)) : r.run(() => W3(t));
        if (s == null) throw Fn(Pn.UNEXPECTED_ERROR);
        return [r, s]
    }
}

function Cge(t) {
    {
        const e = ao(t.isCE ? wge : t.appContext.app.__VUE_I18N_SYMBOL__);
        if (!e) throw Fn(t.isCE ? Pn.NOT_INSLALLED_WITH_PROVIDE : Pn.UNEXPECTED_ERROR);
        return e
    }
}

function kge(t, e) {
    return mg(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local"
}

function Ige(t) {
    return t.mode === "composition" ? t.global : t.global.__composer
}

function Nge(t, e, n = !1) {
    let r = null;
    const s = e.root;
    let i = e.parent;
    for (; i != null;) {
        const o = t;
        if (t.mode === "composition") r = o.__getInstance(i);
        else {
            const a = o.__getInstance(i);
            a != null && (r = a.__composer, n && r && !r[bC] && (r = null))
        }
        if (r != null || s === i) break;
        i = i.parent
    }
    return r
}

function xge(t, e, n) {
    f2(() => {}, e), d2(() => {
        t.__deleteInstance(e)
    }, e)
}

function Pge(t, e, n, r = {}) {
    const s = e === "local",
        i = GF(null);
    if (s && t.proxy && !(t.proxy.$options.i18n || t.proxy.$options.__i18n)) throw Fn(Pn.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
    const o = It(r.inheritLocale) ? r.inheritLocale : !0,
        a = ts(s && o ? n.locale.value : Le(r.locale) ? r.locale : Yf),
        l = ts(s && o ? n.fallbackLocale.value : Le(r.fallbackLocale) || Qt(r.fallbackLocale) || ht(r.fallbackLocale) || r.fallbackLocale === !1 ? r.fallbackLocale : a.value),
        u = ts(yg(a.value, r)),
        f = ts(ht(r.datetimeFormats) ? r.datetimeFormats : {
            [a.value]: {}
        }),
        d = ts(ht(r.numberFormats) ? r.numberFormats : {
            [a.value]: {}
        }),
        p = s ? n.missingWarn : It(r.missingWarn) || da(r.missingWarn) ? r.missingWarn : !0,
        _ = s ? n.fallbackWarn : It(r.fallbackWarn) || da(r.fallbackWarn) ? r.fallbackWarn : !0,
        v = s ? n.fallbackRoot : It(r.fallbackRoot) ? r.fallbackRoot : !0,
        y = !!r.fallbackFormat,
        g = On(r.missing) ? r.missing : null,
        b = On(r.postTranslation) ? r.postTranslation : null,
        O = s ? n.warnHtmlMessage : It(r.warnHtmlMessage) ? r.warnHtmlMessage : !0,
        N = !!r.escapeParameter,
        k = s ? n.modifiers : ht(r.modifiers) ? r.modifiers : {},
        A = r.pluralRules || s && n.pluralRules;

    function x() {
        return [a.value, l.value, u.value, f.value, d.value]
    }
    const D = ns({
            get: () => i.value ? i.value.locale.value : a.value,
            set: S => {
                i.value && (i.value.locale.value = S), a.value = S
            }
        }),
        L = ns({
            get: () => i.value ? i.value.fallbackLocale.value : l.value,
            set: S => {
                i.value && (i.value.fallbackLocale.value = S), l.value = S
            }
        }),
        q = ns(() => i.value ? i.value.messages.value : u.value),
        ee = ns(() => f.value),
        ae = ns(() => d.value);

    function Z() {
        return i.value ? i.value.getPostTranslationHandler() : b
    }

    function fe(S) {
        i.value && i.value.setPostTranslationHandler(S)
    }

    function ge() {
        return i.value ? i.value.getMissingHandler() : g
    }

    function K(S) {
        i.value && i.value.setMissingHandler(S)
    }

    function Q(S) {
        return x(), S()
    }

    function ue(...S) {
        return i.value ? Q(() => Reflect.apply(i.value.t, null, [...S])) : Q(() => "")
    }

    function _e(...S) {
        return i.value ? Reflect.apply(i.value.rt, null, [...S]) : ""
    }

    function Oe(...S) {
        return i.value ? Q(() => Reflect.apply(i.value.d, null, [...S])) : Q(() => "")
    }

    function Ee(...S) {
        return i.value ? Q(() => Reflect.apply(i.value.n, null, [...S])) : Q(() => "")
    }

    function Ce(S) {
        return i.value ? i.value.tm(S) : {}
    }

    function De(S, P) {
        return i.value ? i.value.te(S, P) : !1
    }

    function Ue(S) {
        return i.value ? i.value.getLocaleMessage(S) : {}
    }

    function ot(S, P) {
        i.value && (i.value.setLocaleMessage(S, P), u.value[S] = P)
    }

    function je(S, P) {
        i.value && i.value.mergeLocaleMessage(S, P)
    }

    function Ze(S) {
        return i.value ? i.value.getDateTimeFormat(S) : {}
    }

    function it(S, P) {
        i.value && (i.value.setDateTimeFormat(S, P), f.value[S] = P)
    }

    function w(S, P) {
        i.value && i.value.mergeDateTimeFormat(S, P)
    }

    function M(S) {
        return i.value ? i.value.getNumberFormat(S) : {}
    }

    function Y(S, P) {
        i.value && (i.value.setNumberFormat(S, P), d.value[S] = P)
    }

    function X(S, P) {
        i.value && i.value.mergeNumberFormat(S, P)
    }
    const I = {
        get id() {
            return i.value ? i.value.id : -1
        },
        locale: D,
        fallbackLocale: L,
        messages: q,
        datetimeFormats: ee,
        numberFormats: ae,
        get inheritLocale() {
            return i.value ? i.value.inheritLocale : o
        },
        set inheritLocale(S) {
            i.value && (i.value.inheritLocale = S)
        },
        get availableLocales() {
            return i.value ? i.value.availableLocales : Object.keys(u.value)
        },
        get modifiers() {
            return i.value ? i.value.modifiers : k
        },
        get pluralRules() {
            return i.value ? i.value.pluralRules : A
        },
        get isGlobal() {
            return i.value ? i.value.isGlobal : !1
        },
        get missingWarn() {
            return i.value ? i.value.missingWarn : p
        },
        set missingWarn(S) {
            i.value && (i.value.missingWarn = S)
        },
        get fallbackWarn() {
            return i.value ? i.value.fallbackWarn : _
        },
        set fallbackWarn(S) {
            i.value && (i.value.missingWarn = S)
        },
        get fallbackRoot() {
            return i.value ? i.value.fallbackRoot : v
        },
        set fallbackRoot(S) {
            i.value && (i.value.fallbackRoot = S)
        },
        get fallbackFormat() {
            return i.value ? i.value.fallbackFormat : y
        },
        set fallbackFormat(S) {
            i.value && (i.value.fallbackFormat = S)
        },
        get warnHtmlMessage() {
            return i.value ? i.value.warnHtmlMessage : O
        },
        set warnHtmlMessage(S) {
            i.value && (i.value.warnHtmlMessage = S)
        },
        get escapeParameter() {
            return i.value ? i.value.escapeParameter : N
        },
        set escapeParameter(S) {
            i.value && (i.value.escapeParameter = S)
        },
        t: ue,
        getPostTranslationHandler: Z,
        setPostTranslationHandler: fe,
        getMissingHandler: ge,
        setMissingHandler: K,
        rt: _e,
        d: Oe,
        n: Ee,
        tm: Ce,
        te: De,
        getLocaleMessage: Ue,
        setLocaleMessage: ot,
        mergeLocaleMessage: je,
        getDateTimeFormat: Ze,
        setDateTimeFormat: it,
        mergeDateTimeFormat: w,
        getNumberFormat: M,
        setNumberFormat: Y,
        mergeNumberFormat: X
    };

    function T(S) {
        S.locale.value = a.value, S.fallbackLocale.value = l.value, Object.keys(u.value).forEach(P => {
            S.mergeLocaleMessage(P, u.value[P])
        }), Object.keys(f.value).forEach(P => {
            S.mergeDateTimeFormat(P, f.value[P])
        }), Object.keys(d.value).forEach(P => {
            S.mergeNumberFormat(P, d.value[P])
        }), S.escapeParameter = N, S.fallbackFormat = y, S.fallbackRoot = v, S.fallbackWarn = _, S.missingWarn = p, S.warnHtmlMessage = O
    }
    return d7(() => {
        if (t.proxy == null || t.proxy.$i18n == null) throw Fn(Pn.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
        const S = i.value = t.proxy.$i18n.__composer;
        e === "global" ? (a.value = S.locale.value, l.value = S.fallbackLocale.value, u.value = S.messages.value, f.value = S.datetimeFormats.value, d.value = S.numberFormats.value) : s && T(S)
    }), I
}
const Rge = ["locale", "fallbackLocale", "availableLocales"],
    Mge = ["t", "rt", "d", "n", "tm"];

function Dge(t, e) {
    const n = Object.create(null);
    Rge.forEach(r => {
        const s = Object.getOwnPropertyDescriptor(e, r);
        if (!s) throw Fn(Pn.UNEXPECTED_ERROR);
        const i = Xn(s.value) ? {
            get() {
                return s.value.value
            },
            set(o) {
                s.value.value = o
            }
        } : {
            get() {
                return s.get && s.get()
            }
        };
        Object.defineProperty(n, r, i)
    }), t.config.globalProperties.$i18n = n, Mge.forEach(r => {
        const s = Object.getOwnPropertyDescriptor(e, r);
        if (!s || !s.value) throw Fn(Pn.UNEXPECTED_ERROR);
        Object.defineProperty(t.config.globalProperties, `$${r}`, s)
    })
}
ige(uge);
oge(Wme);
age(lC);
const $ge = {
        install: (t, e = {}) => {
            t.config.globalProperties.$renderers = e
        }
    },
    Lge = st({
        data() {
            return {
                isVisible: !1,
                options: null,
                timeout: null
            }
        },
        beforeMount() {
            this.$registerToast(this)
        },
        methods: {
            show(t) {
                this.isVisible = !0, this.options = t, this.timeout && (window.clearTimeout(this.timeout), this.timeout = null), t.duration && (this.timeout = window.setTimeout(() => {
                    this.hide()
                }, t.duration))
            },
            hide() {
                this.isVisible = !1, this.options = null, this.timeout && (window.clearTimeout(this.timeout), this.timeout = null)
            }
        }
    }),
    Fge = "main/pp10/nopus-opus/assets/c8afd972.svg";
const Uge = {
        class: "constrain"
    },
    Bge = {
        class: "text"
    },
    qge = {
        class: "subtext"
    },
    Gge = {
        key: 0,
        class: "warning"
    },
    Vge = {
        key: 1,
        class: "spinner"
    },
    jge = {
        key: 2,
        class: "pause"
    };

function Wge(t, e, n, r, s, i) {
    return B(), At(Ta, {
        name: "toast-transition"
    }, {
        default: $i(() => [t.isVisible && t.options ? (B(), H("div", {
            key: 0,
            class: nt([t.options.type, "jbg toast"])
        }, [U("div", Uge, [U("img", {
            class: "close",
            alt: "close",
            src: Fge,
            onClick: e[0] || (e[0] = (...o) => t.hide && t.hide(...o)),
            onKeydown: e[1] || (e[1] = E2((...o) => t.hide && t.hide(...o), ["esc"]))
        }, null, 32), U("p", Bge, rt(t.options.text), 1), U("p", qge, rt(t.options.subtext), 1), t.options.warning ? (B(), H("p", Gge, rt(t.options.warning), 1)) : Pe("", !0), t.options.type === "reconnecting" || t.options.type === "paused" ? (B(), H("div", Vge)) : Pe("", !0), t.options.type === "paused" ? (B(), H("div", jge)) : Pe("", !0)])], 2)) : Pe("", !0)]),
        _: 1
    })
}
const Hge = He(Lge, [
        ["render", Wge],
        ["__scopeId", "data-v-6d2a2aa3"]
    ]),
    Yge = {
        install: t => {
            if (t.config.globalProperties.$showToast) return;
            let e;
            const n = i => {
                    if (!e) throw new Error("No ToastComponent is registered to show");
                    e.show(i)
                },
                r = () => {
                    if (!e) throw new Error("No ToastComponent is registered to hide");
                    e.hide()
                },
                s = i => {
                    e = i
                };
            t.component("Toast", Hge), t.config.globalProperties.$showToast = n, t.config.globalProperties.$hideToast = r, t.config.globalProperties.$registerToast = s
        }
    },
    zge = async (t, e, n) => {
        if (!e) throw new Error(`No renderers are available for app ${t.data.galleryId}`);
        const r = e[t.data.renderer];
        if (!r) throw new Error(`No renderer found with type ${t.data.renderer}`);
        const s = `https://s3.amazonaws.com/jbg-blobcast-artifacts/${t.data.galleryId}/${t.data.artifactId}/data.json.gz`,
            o = await (await fetch(s)).json(),
            a = new r({
                artifact: f9.hydrate(o),
                params: t.params,
                messages: n
            });
        await a.ready(), window.tv.renderData = a.renderData
    }, Kge = st({
        props: {
            options: {
                type: Object,
                required: !0
            },
            mainView: {
                type: Object,
                required: !0
            }
        },
        setup() {
            return {
                fatalError: ao(xu.fatal.error)
            }
        },
        data() {
            return {
                isKicked: !1
            }
        },
        computed: {
            ecast() {
                return this.$ecast
            },
            ecastValues() {
                return this.$ecastValues ? this.$ecastValues : null
            },
            classes() {
                return [`locale-${this.$i18n.locale}`]
            },
            shouldShowFatal() {
                var t;
                return ((t = this.fatalError) == null ? void 0 : t.hasCrashed) ?? !1
            }
        },
        beforeMount() {
            this.$ecastManager.on("didReconnect", this.onDidReconnect), this.$ecastManager.on("isReconnecting", this.onIsReconnecting), this.$ecastManager.on("roomDidExit", () => {
                this.onRoomDidExit()
            }), this.$ecastManager.on("didDisconnect", () => {
                this.onDidDisconnect()
            }), this.$ecastManager.on("wasKicked", () => {
                this.onWasKicked()
            }), this.$ecastManager.on("hostDidDisconnect", this.onHostDidDisconnect), this.$ecastManager.on("hostDidReconnect", this.onHostDidReconnect), this.$ecastManager.on("hostDidPause", this.onHostDidPause), this.$ecastManager.on("hostDidUnpause", this.onHostDidUnpause)
        },
        methods: {
            onDidReconnect() {
                this.$showToast({
                    type: "generic",
                    text: this.$t("TOAST.RECONNECTED.TEXT"),
                    subtext: this.$t("TOAST.RECONNECTED.SUBTEXT"),
                    duration: 1500
                })
            },
            onIsReconnecting(t) {
                this.$showToast({
                    type: "reconnecting",
                    text: this.$t("TOAST.RECONNECTING.CONTROLLER.TEXT"),
                    subtext: this.$t("TOAST.RECONNECTING.CONTROLLER.SUBTEXT", {
                        attempt: t
                    })
                })
            },
            async onRoomDidExit() {
                this.$hideToast(), await this.$showModal("Error", {
                    image: "moon",
                    text: this.$t("ERROR.ROOM_DISCONNECTED"),
                    subtext: this.$t("ERROR.ROOM_DESTROYED"),
                    dismissText: this.$t("ACTION.OK")
                }), window.location.reload()
            },
            async onDidDisconnect() {
                this.$hideToast(), await this.$showModal("Error", {
                    image: "moon",
                    text: this.$t("ERROR.ROOM_DISCONNECTED"),
                    dismissText: this.$t("ACTION.OK")
                }), window.location.reload()
            },
            async onWasKicked() {
                this.$hideToast(), await this.$showModal("Error", {
                    image: "tear",
                    text: this.$t("ERROR.ROOM_DISCONNECTED"),
                    subtext: this.$t("ERROR.PLAYER_KICKED"),
                    dismissText: this.$t("ACTION.OK")
                }), window.location.reload()
            },
            onHostDidDisconnect() {
                this.$showToast({
                    type: "reconnecting",
                    text: this.$t("TOAST.RECONNECTING.GAME.TEXT"),
                    subtext: this.$t("TOAST.RECONNECTING.GAME.SUBTEXT")
                })
            },
            onHostDidReconnect() {
                this.$showToast({
                    type: "generic",
                    text: this.$t("TOAST.RECONNECTED.TEXT"),
                    subtext: this.$t("TOAST.RECONNECTED.SUBTEXT"),
                    duration: 1500
                })
            },
            onHostDidPause() {
                this.$showToast({
                    type: "paused",
                    text: this.$t("TOAST.PAUSED.TEXT"),
                    subtext: this.$t("TOAST.PAUSED.SUBTEXT")
                })
            },
            onHostDidUnpause() {
                this.$hideToast()
            }
        }
    });

function Zge(t, e, n, r, s, i) {
    const o = Ge("Fatal"),
        a = Ge("TextDescriptions"),
        l = Ge("Debug"),
        u = Ge("Modal"),
        f = Ge("Toast");
    return t.shouldShowFatal ? (B(), At(o, {
        key: 0
    })) : (B(), H(lt, {
        key: 1
    }, [Ve(a), (B(), At(Fm(t.mainView), Mf({
        id: "game",
        class: t.classes
    }, t.ecastValues), null, 16, ["class"])), Ve(l), Ve(u), Ve(f)], 64))
}
const Tw = He(Kge, [
        ["render", Zge]
    ]),
    Xge = st({
        components: {
            Gallery: mO
        },
        props: {
            options: {
                type: Object,
                required: !0
            },
            galleryView: {
                type: Object,
                required: !0
            }
        },
        setup() {
            return {
                fatalError: ao(xu.fatal.error)
            }
        },
        computed: {
            classes() {
                return [`locale-${this.$i18n.locale}`]
            },
            shouldShowFatal() {
                var t;
                return ((t = this.fatalError) == null ? void 0 : t.hasCrashed) ?? !1
            },
            categoryId() {
                var t, e;
                return ((e = (t = this.options.match) == null ? void 0 : t.data) == null ? void 0 : e.categoryId) ?? ""
            },
            artifactId() {
                var t, e;
                return ((e = (t = this.options.match) == null ? void 0 : t.data) == null ? void 0 : e.artifactId) ?? ""
            },
            itemId() {
                var t, e;
                return ((e = (t = this.options.match) == null ? void 0 : t.data) == null ? void 0 : e.itemId) ?? ""
            }
        }
    });

function Qge(t, e, n, r, s, i) {
    const o = Ge("Fatal"),
        a = Ge("Gallery"),
        l = Ge("Modal"),
        u = Ge("Toast");
    return t.shouldShowFatal ? (B(), At(o, {
        key: 0
    })) : (B(), H(lt, {
        key: 1
    }, [Ve(a, {
        view: t.galleryView,
        "artifact-id": t.artifactId,
        "category-id": t.categoryId,
        "item-id": t.itemId,
        context: "standalone"
    }, null, 8, ["view", "artifact-id", "category-id", "item-id"]), Ve(l), Ve(u)], 64))
}
const Sw = He(Xge, [
    ["render", Qge]
]);

function Jge(t, e, n) {
    Tw.name = e.app;
    const r = P7(Tw, {
        options: e,
        mainView: t.MainView
    });
    if (r.use(khe, {
            replayer: e.replayer,
            client: n,
            room: e.room
        }), r.use(Kfe, {
            wsClient: n,
            room: e.room,
            welcome: e.welcome
        }), r.use(ame), r.use(lme), t.plugins) {
        const s = i => i.plugin === void 0;
        t.plugins.forEach(i => {
            if (s(i)) {
                r.use(i);
                return
            }
            r.use(i.plugin, ...i.options)
        })
    }
    return r
}

function e_e(t, e) {
    return Sw.name = e.app, P7(Sw, {
        options: e,
        galleryView: t.GalleryView
    })
}

function t_e(t) {
    return t != null && t.parts ? t.parts[0] === "gallery" ? "gallery" : t.parts[0] === "render" ? "render" : "game" : "game"
}
const n_e = t => {
    let e;
    window.tv.register({
        connect: (n, r) => (e = r ? r.setClient(Pr.WSClient, n) : new Pr.WSClient(n), e.connect()),
        mount: n => {
            var a, l;
            const r = t_e(n.match);
            if (r === "render") {
                zge(n.match, t.renderers, t.messages);
                return
            }
            let s = r === "gallery" ? e_e(t, n) : Jge(t, n, e),
                i;
            (a = n.room) != null && a.locale && (i = n.room.locale), (l = n.match) != null && l.params.locale && (i = n.match.params.locale), kl.set(i);
            const o = Age({
                fallbackLocale: "en",
                locale: kl.locale,
                messages: kl.mergeMessages($J, t.messages ?? {})
            });
            return s.use(Qoe), s.use($ge, t.renderers), s.use(tme), s.use(Jpe), s.use(o), s.use(x1e, {
                i18n: o
            }), s.use(cme), s.use(Yge), s.mount("#app"), () => {
                s.unmount(), s = null
            }
        },
        info: n => ({
            tag: n.app,
            version: n.version,
            type: n.type,
            wrapper: "vue",
            branch: n.branch
        })
    })
};
class r_e {
    constructor() {
        ye(this, "isDesktop", ts(!1));
        ye(this, "mappings", Ec(new Map));
        ye(this, "customMappings", new Map);
        ye(this, "defaultMappings", new Map([
            [1, [" "]],
            [2, ["g", "h"]],
            [3, ["f", "g", "h"]],
            [4, ["f", "g", "h", "j"]],
            [5, ["d", "f", "g", "h", "j"]],
            [6, ["d", "f", "g", "h", "j", "k"]]
        ]));
        this.defaultMappings = this.getDefaultMappings(), window.matchMedia("(any-hover: hover)").matches && (this.isDesktop.value = !0), this.update()
    }
    reset(e) {
        xn.remove(`hotkey${e}`, "tag"), this.update()
    }
    set(e, n) {
        xn.set(`hotkey${e}`, n.join(""), "tag"), this.update()
    }
    checkEvent(e) {
        if (!this.isDesktop.value) {
            if (e instanceof KeyboardEvent) {
                this.isDesktop.value = !0;
                return
            }
            e instanceof PointerEvent && e.pointerType === "mouse" && (this.isDesktop.value = !0)
        }
    }
    getKeyFromEvent(e) {
        return e.key === "Alt" || e.key === "Backspace" || e.key === "CapsLock" || e.key === "Control" || e.key === "Enter" || e.key === "Escape" || e.key === "Meta" || e.key === "Shift" ? null : e.key.toLowerCase()
    }
    getCountInKeys(e) {
        const n = e ? this.mappings.get(e).keys : this.defaultMappings.get(6);
        return n.push(" "), n
    }
    update() {
        this.customMappings = this.getCustomMappings(), this.setMappings()
    }
    getDefaultMappings() {
        return new Map([
            [1, [" "]],
            [2, ["g", "h"]],
            [3, ["f", "g", "h"]],
            [4, ["f", "g", "h", "j"]],
            [5, ["d", "f", "g", "h", "j"]],
            [6, ["d", "f", "g", "h", "j", "k"]]
        ])
    }
    getCustomMappings() {
        const e = new Map;
        return this.defaultMappings.forEach((n, r) => {
            const s = xn.get(`hotkey${r}`, "tag");
            s && e.set(r, s.split(""))
        }), e
    }
    setMappings() {
        this.mappings.clear(), this.defaultMappings.forEach((e, n) => {
            const r = this.customMappings.get(n),
                s = {
                    isCustom: !1,
                    keys: []
                };
            r ? (s.isCustom = !0, s.keys = r.map(i => i)) : s.keys = e.map(i => i), this.mappings.set(n, s)
        })
    }
}
const s_e = {
        install: t => {
            t.config.globalProperties.$hotkeyManager || (t.config.globalProperties.$hotkeyManager = new r_e)
        }
    },
    i_e = {
        AVATARS: {
            0: "calm light green bird with a single dark green feather on its head",
            1: "punky yellow bird with yellow feathers that look like a mohawk",
            2: "fancy teal bird with round yellow feathers on its head and tail",
            3: "sleek red bird with a pointy head and curly black tail",
            4: "tufted green bird with yellow wings",
            5: "wild magenta bird with light pink, unkempt feathers on its head",
            6: "dramatic white bird with angular black eyebrow feathers",
            7: "flamboyant purple bird with forward feathers on its head and a big curly tail",
            8: "chill brown bird with a foxy tail",
            9: "cute pink bird with a tail that looks like ice cream cones",
            10: "dorky blue bird with perfect hair",
            11: "emo pink bird with feathers brushed forward on its head"
        },
        CHANGE_AVATAR: "Change Avatar",
        LOGO: "the Dodo Re Mi logo"
    },
    o_e = {
        CHANGE_AVATAR: "change avatar",
        SONG_DOWN: "scroll to the next song {songName}",
        SONG_UP: "scroll to the previous song {songName}",
        SELECT_SONG: "select song {songName}"
    },
    a_e = {
        BASS: "Bass",
        MELODY: "Melody",
        COUNTER: "Counter",
        DRUMS: "Drums",
        PERCUSSION: "Percussion",
        HARMONY: "Harmony",
        SIGNATURE: "Signature"
    },
    c_e = {
        GET_READY: "Get Ready",
        TAP: "tap",
        TAP_ALONG: "and then tap along",
        TAP_HERE: "TAP[break][/break]ZONE[info](OR PRESS SPACEBAR)[/info]",
        SYNCED: "synced",
        SYNCING: "Syncing",
        WAIT: "Wait for the count down"
    },
    l_e = {
        SHARE: "Share",
        SILENT_PHONE: "Don't forget to put your phone back on silent!"
    },
    u_e = {
        VERY_EASY: "Super Easy",
        EASY: "Easy",
        MEDIUM: "Medium",
        HARD: "Hard",
        VERY_HARD: "Super Hard"
    },
    h_e = {
        DOWNLOAD: "DOWNLOAD MP3"
    },
    f_e = {
        CONTINUOUS: "Tap and hold notes when they enter the zone below",
        DISCRETE: "Tap notes when they fill the circles below",
        PAUSED: "Game Paused",
        IN_PROGRESS: "Song In Progress",
        PROCESSING: "The birds are preparing to play back your performance"
    },
    d_e = {
        BACK_TO_MENU: "Back to Game Menu",
        BEST_SCORE: "Best Score",
        CANCEL: "Cancel",
        CHANGE_HOST: "Change[break][/break]Host?",
        CHOOSE_HOST: "Choose New Host",
        CHOOSE_INSTRUMENT: "Choose an Instrument",
        CHOOSE_SONG: "Choose a Song",
        COMPLETED_PARTS: "Parts Survived",
        CUSTOMIZE: "Customize?",
        DIFFICULTY: "Difficulty",
        END_SESSION: "End Session",
        LANES: "Lanes",
        LOADING: "Loading",
        LOCKED: "Locked",
        NEVERMIND: "Nevermind",
        NEW_SONG: "New Song",
        RETRY_SONG: "Retry Song",
        RESET: "Reset",
        SELECT_SONG: "Select Song",
        SONG_PART: "Song Part",
        SPACEBAR: "SPACE",
        START_SONG: "Play Song",
        TEST_IT: "Test It Out",
        THANKS: "Thanks for playing",
        UNLOCKED: "Unlocked Instruments",
        VOTE_SONG: "Vote for a Song",
        WAITING_FOR: "Waiting for {vipName}",
        WAITING_FOR_SONG: "Waiting for {vipName} to select song",
        WHAT_NEXT: "What's Next?"
    },
    p_e = {
        SIT_BACK: "Sit back and enjoy",
        LOOK_UP: "Performance on the main screen"
    },
    m_e = {
        PERFECT: "Perfect",
        GREAT: "Great",
        OKAY: "Okay",
        MISS: "Miss"
    },
    g_e = {
        AUDIENCE: "Audience",
        SURVIVED: "Survived",
        EATEN: "Eaten"
    },
    __e = {
        AUDIO_CHECK: "Audio Check",
        CHECK_SETTINGS: "Check these settings on your device",
        CONFIRM: "Sounds good",
        NOT_HEARING: "Not hearing anything?",
        OFF: "OFF",
        POWER_SAVER: "Power Saver Mode",
        SILENT: "Silent Mode",
        TEST: "Play test audio",
        UP: "UP",
        VOLUME: "Volume"
    },
    y_e = {
        ALT: i_e,
        ARIA: o_e,
        BEATMAPS: a_e,
        COUNT_IN: c_e,
        CREDITS: l_e,
        DIFFICULTY: u_e,
        GALLERY: h_e,
        INFO: f_e,
        MENU: d_e,
        PLAYBACK: p_e,
        QUALITY: m_e,
        RESULTS: g_e,
        WELCOME: __e
    },
    v_e = {
        AVATARS: {
            0: "oiseau calme vert clair avec une seule plume vert fonc sur sa tte",
            1: "oiseau jaune punk avec plumes jaunes faon crte",
            2: "oiseau chic bleu sarcelle avec plumes jaunes rondes sur sa tte et sa queue",
            3: "oiseau rouge au plumage soyeux avec une tte pointue et une queue noire boucle",
            4: "oiseau vert touffu avec ailes jaunes",
            5: "oiseau sauvage magenta avec plumes hirsutes rose clair sur sa tte",
            6: "oiseau blanc dramatique avec plumes noires angulaires au niveau des sourcils",
            7: "oiseau violet flamboyant avec plumes vers l'avant sur sa tte et une grande queue frise",
            8: "oiseau marron relax avec queue rousse",
            9: "oiseau rose mignon avec une queue en forme de cornet de glace",
            10: "oiseau bleu intello au plumage trs soign",
            11: "oiseau rose emo avec plumes de sa tte coiffes vers l'avant"
        },
        CHANGE_AVATAR: "Changer d'avatar",
        LOGO: "logo Dodo R Mi"
    },
    b_e = {
        CHANGE_AVATAR: "changer d'avatar",
        SONG_DOWN: "faire dfiler jusqu' la prochaine chanson {songName}",
        SONG_UP: "faire dfiler jusqu' la chanson prcdente {songName}",
        SELECT_SONG: "choisir la chanson {songName}"
    },
    E_e = {
        BASS: "Basse",
        MELODY: "Mlodie",
        COUNTER: "Contre",
        DRUMS: "Batterie",
        PERCUSSION: "Percussion",
        HARMONY: "Harmonie",
        SIGNATURE: "Signature"
    },
    T_e = {
        GET_READY: "Prparez-vous",
        TAP: "toucher",
        TAP_ALONG: "puis touchez en rythme",
        TAP_HERE: "TOUCHEZ[break][/break]LA ZONE[info](OU APPUYEZ SUR LA BARRE DESPACE)[/info]",
        SYNCED: "synchronis",
        SYNCING: "Synchro en cours",
        WAIT: "Attendez le compte  rebours"
    },
    S_e = {
        SHARE: "Partager",
        SILENT_PHONE: "Pensez  repasser votre tlphone sur silencieux!"
    },
    w_e = {
        VERY_EASY: "Super facile",
        EASY: "Facile",
        MEDIUM: "Moyen",
        HARD: "Difficile",
        VERY_HARD: "Super difficile"
    },
    A_e = {
        DOWNLOAD: "TLCHARGER LE MP3"
    },
    O_e = {
        CONTINUOUS: "Touchez et maintenez les notes lorsquelles passent dans la zone ci-dessous",
        DISCRETE: "Touchez les notes quand elles remplissent les cercles ci-dessous",
        PAUSED: "Partie en pause",
        IN_PROGRESS: "Chanson en cours",
        PROCESSING: "Les oiseaux sont prts  rejouer votre performance"
    },
    C_e = {
        BACK_TO_MENU: "Retour au menu du jeu",
        BEST_SCORE: "Meilleur score",
        CANCEL: "Annuler",
        CHANGE_HOST: "Changer[break][/break]d'hte?",
        CHOOSE_HOST: "Choisissez un nouvel hte",
        CHOOSE_INSTRUMENT: "Choisissez un instrument",
        CHOOSE_SONG: "Choisissez une chanson",
        COMPLETED_PARTS: "Sections survcues",
        CUSTOMIZE: "Personnaliser?",
        DIFFICULTY: "Difficult",
        END_SESSION: "Terminer la session",
        LANES: "Lanes",
        LOADING: "Chargement",
        LOCKED: "Verrouill",
        NEVERMIND: "Tant pis !",
        NEW_SONG: "Nouvelle chanson",
        RETRY_SONG: "Ressayer la chanson",
        RESET: "Rinitialiser",
        SELECT_SONG: "Choisir la chanson",
        SONG_PART: "Section de la chanson",
        SPACEBAR: "ESPACE",
        START_SONG: "Lancer la chanson",
        TEST_IT: "Tester",
        THANKS: "Merci d'avoir jou!",
        UNLOCKED: "Instruments dbloqus",
        VOTE_SONG: "Votez pour une chanson",
        WAITING_FOR: "En attente de {vipName}",
        WAITING_FOR_SONG: "On attend que {vipName} slectionne une chanson",
        WHAT_NEXT: "Et ensuite?"
    },
    k_e = {
        SIT_BACK: "Asseyez-vous et profitez",
        LOOK_UP: "Prestation sur lcran principal"
    },
    I_e = {
        PERFECT: "Parfait",
        GREAT: "Super",
        OKAY: "Passable",
        MISS: "Rat"
    },
    N_e = {
        AUDIENCE: "Public",
        SURVIVED: "Survcu",
        EATEN: "Mang"
    },
    x_e = {
        AUDIO_CHECK: "Vrification audio",
        CHECK_SETTINGS: "Vrifiez ces paramtres sur votre appareil",
        CONFIRM: "Cest bon",
        NOT_HEARING: "Vous nentendez rien?",
        OFF: "OFF",
        POWER_SAVER: "Mode conomie dnergie",
        SILENT: "Mode silencieux",
        TEST: "Lancer laudio de test",
        UP: "Augmenter",
        VOLUME: "Volume"
    },
    P_e = {
        ALT: v_e,
        ARIA: b_e,
        BEATMAPS: E_e,
        COUNT_IN: T_e,
        CREDITS: S_e,
        DIFFICULTY: w_e,
        GALLERY: A_e,
        INFO: O_e,
        MENU: C_e,
        PLAYBACK: k_e,
        QUALITY: I_e,
        RESULTS: N_e,
        WELCOME: x_e
    },
    R_e = {
        AVATARS: {
            0: "uccello calmo di colore verde chiaro con un'unica piuma verde scuro sulla testa",
            1: "uccello punk di colore giallo con piume gialle che sembrano un taglio alla moicana",
            2: "uccello splendido di colore verde acqua con piume gialle rotonde sulla testa e sulla coda",
            3: "uccello sinuoso di colore rosso con una testa a punta e una coda nera arricciata",
            4: "uccello di colore verde con un ciuffo e le ali gialle",
            5: "uccello selvatico di colore magenta con piume arruffate rosa chiaro in testa",
            6: "uccello vistoso di colore bianco con piume nere ad angolo come sopracciglia",
            7: "uccello appariscente di colore viola con piume all'ins sulla testa e una grande coda arricciata",
            8: "uccello calmo di colore marrone con una coda di volpe",
            9: "uccello carino di colore rosa con una coda che ricorda dei coni gelato",
            10: "uccello maldestro di colore blu con capelli perfetti",
            11: "uccello emo di colore rosa con piume pettinate in avanti sulla testa"
        },
        CHANGE_AVATAR: "Cambia avatar",
        LOGO: "il logo di Dodo Re Mi"
    },
    M_e = {
        CHANGE_AVATAR: "cambia avatar",
        SONG_DOWN: "scorri alla canzone successiva {songName}",
        SONG_UP: "scorri alla canzone precedente {songName}",
        SELECT_SONG: "seleziona canzone {songName}"
    },
    D_e = {
        BASS: "Basso",
        MELODY: "Melodia",
        COUNTER: "Controcanto",
        DRUMS: "Batteria",
        PERCUSSION: "Percussioni",
        HARMONY: "Armonia",
        SIGNATURE: "Alterazione"
    },
    $_e = {
        GET_READY: "Preparati",
        TAP: "tuca",
        TAP_ALONG: "e poi tocca a ritmo",
        TAP_HERE: "TOCCA[break][/break]LA ZONA[info](O PREMI LA BARRA SPAZIATRICE)[/info]",
        SYNCED: "sincronizzato",
        SYNCING: "Sincronizzazione",
        WAIT: "Aspetta il conto alla rovescia"
    },
    L_e = {
        SHARE: "Condividi",
        SILENT_PHONE: "Ricordati di rimettere il telefono in modalit silenziosa!"
    },
    F_e = {
        VERY_EASY: "Facilissima",
        EASY: "Facile",
        MEDIUM: "Media",
        HARD: "Difficile",
        VERY_HARD: "Difficilissima"
    },
    U_e = {
        DOWNLOAD: "SCARICA MP3"
    },
    B_e = {
        CONTINUOUS: "Tocca e tieni premute le note quando entrano nella zona qui sotto",
        DISCRETE: "Tocca le note quando entrano nei cerchi qui sotto",
        PAUSED: "Gioco in pausa",
        IN_PROGRESS: "Canzone in corso",
        PROCESSING: "Gli uccelli si stanno preparando a riprodurre la tua performance"
    },
    q_e = {
        BACK_TO_MENU: "Torna al menu di gioco",
        BEST_SCORE: "Miglior punteggio",
        CANCEL: "Annulla",
        CHANGE_HOST: "Cambia[break][/break]ospite?",
        CHOOSE_HOST: "Scegli un nuovo ospite",
        CHOOSE_INSTRUMENT: "Scegli uno strumento",
        CHOOSE_SONG: "Scegli una canzone",
        COMPLETED_PARTS: "Parti sopravvissute",
        CUSTOMIZE: "Personalizza?",
        DIFFICULTY: "Difficolt",
        END_SESSION: "Concludi sessione",
        LANES: "Corsie",
        LOADING: "Caricamento",
        LOCKED: "Bloccata",
        NEVERMIND: "Non importa",
        NEW_SONG: "Nuova canzone",
        RETRY_SONG: "Riprova canzone",
        RESET: "Reset",
        SELECT_SONG: "Seleziona canzone",
        SONG_PART: "Parte della canzone",
        SPACEBAR: "SPAZIO",
        START_SONG: "Riproduci canzone",
        TEST_IT: "Provala",
        THANKS: "Grazie per aver scelto di giocare con noi",
        UNLOCKED: "Strumenti sbloccati",
        VOTE_SONG: "Vota una canzone",
        WAITING_FOR: "In attesa di {vipName}",
        WAITING_FOR_SONG: "In attesa che {vipName} selezioni la canzone",
        WHAT_NEXT: "Che si fa dopo?"
    },
    G_e = {
        SIT_BACK: "Mettiti comod e divertiti",
        LOOK_UP: "Performance sulla schermata principale"
    },
    V_e = {
        PERFECT: "Perfetta",
        GREAT: "Ottima",
        OKAY: "Buona",
        MISS: "Sbagliata"
    },
    j_e = {
        AUDIENCE: "Pubblico",
        SURVIVED: "Se l' cavata",
        EATEN: " stat mangiat"
    },
    W_e = {
        AUDIO_CHECK: "Controllo audio",
        CHECK_SETTINGS: "Controlla queste impostazioni sul dispositivo",
        CONFIRM: "Sembra a posto",
        NOT_HEARING: "Non senti niente?",
        OFF: "OFF",
        POWER_SAVER: "Modalit risparmio energetico",
        SILENT: "Modalit silenziosa",
        TEST: "Riproduci audio di prova",
        UP: "ALZA",
        VOLUME: "Volume"
    },
    H_e = {
        ALT: R_e,
        ARIA: M_e,
        BEATMAPS: D_e,
        COUNT_IN: $_e,
        CREDITS: L_e,
        DIFFICULTY: F_e,
        GALLERY: U_e,
        INFO: B_e,
        MENU: q_e,
        PLAYBACK: G_e,
        QUALITY: V_e,
        RESULTS: j_e,
        WELCOME: W_e
    },
    Y_e = {
        AVATARS: {
            0: "ruhiger hellgrner Vogel mit einer einzigen dunklen Feder auf dem Kopf",
            1: "punkiger gelber Vogel mit gelben Federn, die wir ein Irokesenschnitt aussehen",
            2: "schicker trkiser Vogel mit runden, gelben Federn auf dem Kopf sowie einem Schwanz",
            3: "geschmeidiger roter Vogel mit einem spitzen Kopf und einem lockigen schwarzen Schwanz",
            4: "grner Vogel mit gelben Flgeln",
            5: "wilder magentafarbener Vogel mit ungegltteten hellrosa Federn auf dem Kopf",
            6: "dramatisch aussehender weier Vogel mit rechteckigen schwarzen Federn als Augenbrauen",
            7: "extravaganter lila Vogel mit nach vorne zeigenden Federn auf dem Kopf sowie einem groen, gelockten Schwanz",
            8: "entspannter brauner Vogel mit einem Fuchsartigen Schwanz",
            9: "niedlicher rosa Vogel mit einem Schwanz, der wie Eiswaffeln aussieht",
            10: "einfltig aussehender blauer Vogel mit perfektem Federkleid",
            11: "rosa Emo-Vogel, dessen Kopffedern nach vorn gebrstet sind"
        },
        CHANGE_AVATAR: "Avatar wechseln",
        LOGO: "das Dodo Re Mi-Logo "
    },
    z_e = {
        CHANGE_AVATAR: "Avatar wechseln",
        SONG_DOWN: "Zum nchsten Lied scrollen: {songName}",
        SONG_UP: "Zum vorigen Lied scrollen: {songName}",
        SELECT_SONG: "Lied auswhlen: {songName}"
    },
    K_e = {
        BASS: "Bass",
        MELODY: "Melodie",
        COUNTER: "Gegenstimme",
        DRUMS: "Schlagzeug",
        PERCUSSION: "Perkussion",
        HARMONY: "Harmonie",
        SIGNATURE: "Sonderinstrument"
    },
    Z_e = {
        GET_READY: "Bereitmachen",
        TAP: "DRCK",
        TAP_ALONG: "und dann drck im Rythmus",
        TAP_HERE: "DRCK[break][/break]ZONE[info](ODER DRCKE LEERTASTE)[/info]",
        SYNCED: "Synchronisiert",
        SYNCING: "Synchronisierung luft",
        WAIT: "Warte auf den Countdown"
    },
    X_e = {
        SHARE: "Teilen",
        SILENT_PHONE: "Vergiss nicht, dein Telefon wieder auf Stumm zu stellen!"
    },
    Q_e = {
        VERY_EASY: "Supereinfach",
        EASY: "Einfach",
        MEDIUM: "Mittel",
        HARD: "Schwer",
        VERY_HARD: "Superschwer"
    },
    J_e = {
        DOWNLOAD: "MP3 HERUNTERLADEN"
    },
    eye = {
        CONTINUOUS: "Drcke und halte Noten, wenn sie in die Zone unten kommen",
        DISCRETE: "Drcke Noten, wenn sie die Kreise unten fllen",
        PAUSED: "Spiel pausiert",
        IN_PROGRESS: "Lied luft",
        PROCESSING: "Die Vgel bereiten die Wiedergabe der Darbietung vor"
    },
    tye = {
        BACK_TO_MENU: "Zurck zum Spielmen",
        BEST_SCORE: "Bester Punktestand",
        CANCEL: "Abbrechen",
        CHANGE_HOST: "Gastgeber[break][/break]wechseln?",
        CHOOSE_HOST: "Neuen Gastgeber whlen",
        CHOOSE_INSTRUMENT: "Instrument whlen",
        CHOOSE_SONG: "Lied whlen",
        COMPLETED_PARTS: "berlebte Abschnitte",
        CUSTOMIZE: "Anpassen?",
        DIFFICULTY: "Schwierigkeitsgrad",
        END_SESSION: "Konzert beenden",
        LANES: "Spuren",
        LOADING: "Lade",
        LOCKED: "Gesperrt",
        NEVERMIND: "Schon gut",
        NEW_SONG: "Neues Lied",
        RETRY_SONG: "Lied erneut versuchen",
        RESET: "Neu starten",
        SELECT_SONG: "Lied auswhlen",
        SONG_PART: "Lied-Abschnitt",
        SPACEBAR: "LEER",
        START_SONG: "Lied starten",
        TEST_IT: "Ausprobieren",
        THANKS: "Danke frs Spielen",
        UNLOCKED: "Freigeschaltete Instrumente",
        VOTE_SONG: "Stimme fr ein Lied ab",
        WAITING_FOR: "Warte auf {vipName}",
        WAITING_FOR_SONG: "Warte darauf, dass {vipName} einen Song auswhlt",
        WHAT_NEXT: "Was jetzt?"
    },
    nye = {
        SIT_BACK: "Lehn dich zurck und geniee",
        LOOK_UP: "Darbietung auf dem Hauptbildschirm"
    },
    rye = {
        PERFECT: "Perfekt",
        GREAT: "Klasse",
        OKAY: "Okay",
        MISS: "Verfehlt"
    },
    sye = {
        AUDIENCE: "Publikum",
        SURVIVED: "berlebt",
        EATEN: "Gefressen"
    },
    iye = {
        AUDIO_CHECK: "Audiotest",
        CHECK_SETTINGS: "berprfe diese Einstellungen auf deinem Gert",
        CONFIRM: "Klingt gut",
        NOT_HEARING: "Du hrst nichts?",
        OFF: "AUS",
        POWER_SAVER: "Stromsparfunktion",
        SILENT: "Stumm",
        TEST: "Audiowiedergabe testen",
        UP: "HOCH",
        VOLUME: "Lautstrke"
    },
    oye = {
        ALT: Y_e,
        ARIA: z_e,
        BEATMAPS: K_e,
        COUNT_IN: Z_e,
        CREDITS: X_e,
        DIFFICULTY: Q_e,
        GALLERY: J_e,
        INFO: eye,
        MENU: tye,
        PLAYBACK: nye,
        QUALITY: rye,
        RESULTS: sye,
        WELCOME: iye
    },
    aye = {
        AVATARS: {
            0: "pjaro sereno de color verde claro con una sola pluma verde oscuro en la cabeza",
            1: "pjaro amarillo macarra con plumas amarillas que parecen un peinado mohicano",
            2: "pjaro elegante con plumas amarillas redondas en la cabeza y la cola",
            3: "pjaro rojo distinguido con la cabeza puntiaguda y una cola negra rizada",
            4: "pjaro verde con muchas plumas y alas amarillas",
            5: "pjaro silvestre magenta con plumas rosa claro despeinadas en la cabeza",
            6: "pjaro blanco dramtico con plumas negras angulares a modo de ceja",
            7: "pjaro morado extravagante con plumas hacia delante en la cabeza y una gran cola rizada",
            8: "pjaro marrn tranquilo con cola de zorro",
            9: "pjaro rosa bonito con una cola que parece unos cucuruchos de helado",
            10: "pjaro azul tontorrn con un peinado ideal",
            11: "pjaro rosa emo con plumas peinadas hacia delante en la cabeza"
        },
        CHANGE_AVATAR: "Cambiar avatar",
        LOGO: "el logotipo de Dodo Re Mi"
    },
    cye = {
        CHANGE_AVATAR: "cambiar avatar",
        SONG_DOWN: "ir a la cancin siguiente {songName}",
        SONG_UP: "volver a la cancin anterior {songName}",
        SELECT_SONG: "elegir cancin {songName}"
    },
    lye = {
        BASS: "Bajo",
        MELODY: "Meloda",
        COUNTER: "Contrapunto",
        DRUMS: "Batera",
        PERCUSSION: "Percusin",
        HARMONY: "Armona",
        SIGNATURE: "Comps"
    },
    uye = {
        GET_READY: "Preprate",
        TAP: "toca",
        TAP_ALONG: "y luego toca al ritmo",
        TAP_HERE: "TOCA[break][/break]LA ZONA[info](O PULSA LA BARRA ESPACIADORA)[/info]",
        SYNCED: "sincronizado",
        SYNCING: "Sincronizando",
        WAIT: "Espera a la cuenta atrs"
    },
    hye = {
        SHARE: "Compartir",
        SILENT_PHONE: "No olvides volver a poner el telfono en silencio!"
    },
    fye = {
        VERY_EASY: "Muy fcil",
        EASY: "Fcil",
        MEDIUM: "Normal",
        HARD: "Difcil",
        VERY_HARD: "Muy difcil"
    },
    dye = {
        DOWNLOAD: "DESCARGAR MP3"
    },
    pye = {
        CONTINUOUS: "Toca y mantn las notas cuando entren en la zona inferior.",
        DISCRETE: "Toca las notas cuando llenen los crculos de abajo.",
        PAUSED: "Partida pausada",
        IN_PROGRESS: "Cancin en curso",
        PROCESSING: "Los pjaros se preparan para reproducir tu actuacin"
    },
    mye = {
        BACK_TO_MENU: "Volver al men del juego",
        BEST_SCORE: "Mejor puntuacin",
        CANCEL: "Cancelar",
        CHANGE_HOST: "Cambiar[break][/break]anfitrin?",
        CHOOSE_HOST: "Elige un nuevo anfitrin",
        CHOOSE_INSTRUMENT: "Elige un instrumento",
        CHOOSE_SONG: "Elige una cancin",
        COMPLETED_PARTS: "Partes sobrevividas",
        CUSTOMIZE: "Personalizar?",
        DIFFICULTY: "Dificultad",
        END_SESSION: "Finalizar sesin",
        LANES: "Pistas",
        LOADING: "Cargando",
        LOCKED: "Bloqueado",
        NEVERMIND: "Da igual",
        NEW_SONG: "Nueva cancin",
        RETRY_SONG: "Volver a intentar",
        RESET: "Reiniciar",
        SELECT_SONG: "Seleccionar cancin",
        SONG_PART: "Parte de la cancin",
        SPACEBAR: "ESPACIO",
        START_SONG: "Reproducir cancin",
        TEST_IT: "Probar",
        THANKS: "Gracias por jugar",
        UNLOCKED: "Instrumentos desbloqueados",
        VOTE_SONG: "Vota una cancin",
        WAITING_FOR: "Esperando a {vipName}",
        WAITING_FOR_SONG: "Esperando a que {vipName} seleccione una cancin",
        WHAT_NEXT: "Qu hay a continuacin?"
    },
    gye = {
        SIT_BACK: "Reljate y disfruta",
        LOOK_UP: "Actuacin en la pantalla principal"
    },
    _ye = {
        PERFECT: "Perfecto",
        GREAT: "Genial",
        OKAY: "Bien",
        MISS: "Fallo"
    },
    yye = {
        AUDIENCE: "Pblico",
        SURVIVED: "Superviviente",
        EATEN: "Devorado"
    },
    vye = {
        AUDIO_CHECK: "Comprobar sonido",
        CHECK_SETTINGS: "Comprueba estos ajustes en tu dispositivo",
        CONFIRM: "Suena bien",
        NOT_HEARING: "No se oye nada?",
        OFF: "NO",
        POWER_SAVER: "Modo de ahorro de energa",
        SILENT: "Modo silencio",
        TEST: "Reproducir sonido de prueba",
        UP: "ARRIBA",
        VOLUME: "Volumen"
    },
    bye = {
        ALT: aye,
        ARIA: cye,
        BEATMAPS: lye,
        COUNT_IN: uye,
        CREDITS: hye,
        DIFFICULTY: fye,
        GALLERY: dye,
        INFO: pye,
        MENU: mye,
        PLAYBACK: gye,
        QUALITY: _ye,
        RESULTS: yye,
        WELCOME: vye
    },
    Eye = {
        AVATARS: {
            0: "ave tranquila de color verde claro con una sola pluma verde oscura en la cabeza",
            1: "ave amarilla con plumas amarillas en forma de cresta punk",
            2: "ave distinguida verde azulada con plumas amarillas en la cabeza y cola",
            3: "ave roja elegante con la cabeza puntiaguda y cola negra enrulada",
            4: "ave verde con copete y alas amarillas",
            5: "ave magenta con tonos rosados y plumas alborotadas en la cabeza",
            6: "ave blanca impresionante con cejas angulares de plumas negras",
            7: "ave violeta llamativa con plumas hacia adelante en la cabeza y una cola larga y enrulada",
            8: "ave marrn tranquila con cola de zorro",
            9: "ave rosa adorable con una cola que parece un cono de helado",
            10: "ave azul tonta con cabello perfecto",
            11: "ave rosa rebelde con plumas peinadas hacia adelante en la cabeza"
        },
        CHANGE_AVATAR: "Cambiar avatar",
        LOGO: "el logotipo de Dodo Re Mi"
    },
    Tye = {
        CHANGE_AVATAR: "cambiar avatar",
        SONG_DOWN: "avanza a la siguiente cancin {songName}",
        SONG_UP: "retrocede a la siguiente cancin {songName}",
        SELECT_SONG: "elige la cancin {songName}"
    },
    Sye = {
        BASS: "Bajo",
        MELODY: "Meloda",
        COUNTER: "Contra",
        DRUMS: "Batera",
        PERCUSSION: "Percusin",
        HARMONY: "Armona",
        SIGNATURE: "Armadura"
    },
    wye = {
        GET_READY: "Preprate",
        TAP: "toca",
        TAP_ALONG: "y sigue tocando",
        TAP_HERE: "ZONA[break][/break]PARA TOCAR[info](O PRESIONA LA BARRA ESPACIADORA)[/info]",
        SYNCED: "sincronizado",
        SYNCING: "Sincronizando",
        WAIT: "Espera la cuenta regresiva"
    },
    Aye = {
        SHARE: "Compartir",
        SILENT_PHONE: "No olvides volver a poner el telfono en silencio!"
    },
    Oye = {
        VERY_EASY: "Superfcil",
        EASY: "Fcil",
        MEDIUM: "Medio",
        HARD: "Difcil",
        VERY_HARD: "Superdifcil"
    },
    Cye = {
        DOWNLOAD: "DESCARGAR MP3"
    },
    kye = {
        CONTINUOUS: "Toca y mantn las notas cuando entren en la zona de abajo",
        DISCRETE: "Toca las notas cuando llenen los crculos de abajo",
        PAUSED: "Partida pausada",
        IN_PROGRESS: "Cancin en curso",
        PROCESSING: "Las aves se preparan para reproducir tu puesta en escena"
    },
    Iye = {
        BACK_TO_MENU: "Volver al men del juego",
        BEST_SCORE: "Mejor puntuacin",
        CANCEL: "Cancelar",
        CHANGE_HOST: "Cambiar[break][/break]anfitrin?",
        CHOOSE_HOST: "Elegir nuevo anfitrin",
        CHOOSE_INSTRUMENT: "Elige un instrumento",
        CHOOSE_SONG: "Elige una cancin",
        COMPLETED_PARTS: "Partes sobrevividas",
        CUSTOMIZE: "Personalizar?",
        DIFFICULTY: "Dificultad",
        END_SESSION: "Finalizar sesin",
        LANES: "Pistas",
        LOADING: "Cargando",
        LOCKED: "Bloqueado",
        NEVERMIND: "Olvidar",
        NEW_SONG: "Nueva cancin",
        RETRY_SONG: "Volver a intentar la cancin",
        RESET: "Reiniciar",
        SELECT_SONG: "Elegir la cancin",
        SONG_PART: "Parte de la cancin",
        SPACEBAR: "ESPACIO",
        START_SONG: "Reproducir cancin",
        TEST_IT: "Intento de prueba",
        THANKS: "Gracias por jugar",
        UNLOCKED: "Instrumentos desbloqueados",
        VOTE_SONG: "Votar por una cancin",
        WAITING_FOR: "Esperando a {vipName}",
        WAITING_FOR_SONG: "Esperando que {vipName} elija una cancin",
        WHAT_NEXT: "Qu sigue?"
    },
    Nye = {
        SIT_BACK: "Reljate y disfruta",
        LOOK_UP: "Actuacin en la pantalla principal"
    },
    xye = {
        PERFECT: "Perfecto",
        GREAT: "Grandioso",
        OKAY: "Bien",
        MISS: "Fallo"
    },
    Pye = {
        AUDIENCE: "Pblico",
        SURVIVED: "Sobreviviste",
        EATEN: "Te comieron"
    },
    Rye = {
        AUDIO_CHECK: "Prueba de audio",
        CHECK_SETTINGS: "Revisa los ajustes de tu dispositivo",
        CONFIRM: "Suena bien",
        NOT_HEARING: "No escuchas nada?",
        OFF: "NO",
        POWER_SAVER: "Modo de ahorro de energa",
        SILENT: "Modo silencioso",
        TEST: "Reproducir prueba de audio",
        UP: "SUBIR",
        VOLUME: "Volumen"
    },
    Mye = {
        ALT: Eye,
        ARIA: Tye,
        BEATMAPS: Sye,
        COUNT_IN: wye,
        CREDITS: Aye,
        DIFFICULTY: Oye,
        GALLERY: Cye,
        INFO: kye,
        MENU: Iye,
        PLAYBACK: Nye,
        QUALITY: xye,
        RESULTS: Pye,
        WELCOME: Rye
    },
    Dye = {
        AVATARS: {
            0: "pssaro calmo, verde-claro, com uma nica pena verde-escura na cabea",
            1: "pssaro punk, amarelo, com penacho amarelo em formato de moicano",
            2: "pssaro chique, verde-azul, com penas amarelas arredondadas na cabea e na cauda",
            3: "pssaro elegante, vermelho, com cabea pontuda e cauda preta enroladinha",
            4: "pssaro topetudo, verde, com asas amarelas",
            5: "pssaro selvagem, prpura, com penacho bagunado rosa-claro",
            6: "pssaro dramtico, branco, com penas pretas angulosas nas sobrancelhas",
            7: "pssaro fabuloso, roxo, com um topete de penas e uma grande cauda enrolada",
            8: "pssaro tranquilo, marrom, com cauda de raposa",
            9: "pssaro fofo, rosa, com uma cauda semelhante a sorvetes de casquinha",
            10: "pssaro nerd, azul, com cabelo arrumadinho",
            11: "pssaro emo, rosa, com penacho penteado para a frente"
        },
        CHANGE_AVATAR: "Trocar avatar",
        LOGO: "logotipo de Dodo Re Mi"
    },
    $ye = {
        CHANGE_AVATAR: "trocar avatar",
        SONG_DOWN: "rolar para a prxima msica {songName}",
        SONG_UP: "rolar para a msica anterior {songName}",
        SELECT_SONG: "selecionar msica {songName}"
    },
    Lye = {
        BASS: "Baixo",
        MELODY: "Melodia",
        COUNTER: "Contador",
        DRUMS: "Bateria",
        PERCUSSION: "Percusso",
        HARMONY: "Harmonia",
        SIGNATURE: "Compasso"
    },
    Fye = {
        GET_READY: "Prepare-se",
        TAP: "toque",
        TAP_ALONG: "e ento toque junto",
        TAP_HERE: "ZONA[break][/break]DE TOQUE[info](OU APERTE A BARRA DE ESPAO)[/info]",
        SYNCED: "sincronizado",
        SYNCING: "Sincronizando",
        WAIT: "Aguardando a contagem regressiva"
    },
    Uye = {
        SHARE: "Compartilhar",
        SILENT_PHONE: "No se esquea de colocar o celular no modo silencioso!"
    },
    Bye = {
        VERY_EASY: "Superfcil",
        EASY: "Fcil",
        MEDIUM: "Mdia",
        HARD: "Difcil",
        VERY_HARD: "Superdifcil"
    },
    qye = {
        DOWNLOAD: "BAIXAR MP3"
    },
    Gye = {
        CONTINUOUS: "Toque e segure as notas quando elas entrarem na zona abaixo",
        DISCRETE: "Toque nas notas quando elas preencherem os crculos abaixo",
        PAUSED: "Jogo pausado",
        IN_PROGRESS: "Msica em andamento",
        PROCESSING: "Os pssaros esto se preparando para reproduzir o seu show"
    },
    Vye = {
        BACK_TO_MENU: "Voltar ao menu do jogo",
        BEST_SCORE: "Recorde",
        CANCEL: "Cancelar",
        CHANGE_HOST: "Trocar[break][/break]anfitrio?",
        CHOOSE_HOST: "Escolher novo anfitrio",
        CHOOSE_INSTRUMENT: "Escolha um instrumento",
        CHOOSE_SONG: "Escolha uma msica",
        COMPLETED_PARTS: "Partes concludas com sobrevivncia",
        CUSTOMIZE: "Personalizar?",
        DIFFICULTY: "Dificuldade",
        END_SESSION: "Encerrar sesso",
        LANES: "Pistas",
        LOADING: "Carregando",
        LOCKED: "Bloqueada",
        NEVERMIND: "Deixa pra l",
        NEW_SONG: "Nova msica",
        RETRY_SONG: "Repetir msica",
        RESET: "Redefinir",
        SELECT_SONG: "Selecionar msica",
        SONG_PART: "Parte da msica",
        SPACEBAR: "ESPAO",
        START_SONG: "Tocar msica",
        TEST_IT: "Testar",
        THANKS: "Obrigado por jogar",
        UNLOCKED: "Instrumentos desbloqueados",
        VOTE_SONG: "Vote numa msica",
        WAITING_FOR: "Aguardando {vipName}",
        WAITING_FOR_SONG: "Aguardando {vipName} selecionar a msica",
        WHAT_NEXT: "E agora?"
    },
    jye = {
        SIT_BACK: "Agora  s curtir",
        LOOK_UP: "Desempenho na tela principal"
    },
    Wye = {
        PERFECT: "Perfeito",
        GREAT: "timo",
        OKAY: "OK",
        MISS: "Errou"
    },
    Hye = {
        AUDIENCE: "Plateia",
        SURVIVED: "Sobreviveram",
        EATEN: "Devorados"
    },
    Yye = {
        AUDIO_CHECK: "Verificao de udio",
        CHECK_SETTINGS: "Verifique estas configuraes no seu dispositivo",
        CONFIRM: "Tudo certo",
        NOT_HEARING: "No est ouvindo nada?",
        OFF: "DESLIGADO",
        POWER_SAVER: "Modo de economia de bateria",
        SILENT: "Modo silencioso",
        TEST: "Tocar udio de teste",
        UP: "+",
        VOLUME: "Volume"
    },
    zye = {
        ALT: Dye,
        ARIA: $ye,
        BEATMAPS: Lye,
        COUNT_IN: Fye,
        CREDITS: Uye,
        DIFFICULTY: Bye,
        GALLERY: qye,
        INFO: Gye,
        MENU: Vye,
        PLAYBACK: jye,
        QUALITY: Wye,
        RESULTS: Hye,
        WELCOME: Yye
    },
    Kye = {
        en: y_e,
        fr: P_e,
        it: H_e,
        de: oye,
        es: bye,
        "es-XL": Mye,
        "pt-BR": zye
    },
    Zye = "modulepreload",
    Xye = function(t) {
        return "https://bundles.jackbox.tv/main/pp10-nopus-opus/" + t
    },
    ww = {},
    Qye = function(e, n, r) {
        if (!n || n.length === 0) return e();
        const s = document.getElementsByTagName("link");
        return Promise.all(n.map(i => {
            if (i = Xye(i), i in ww) return;
            ww[i] = !0;
            const o = i.endsWith(".css"),
                a = o ? '[rel="stylesheet"]' : "";
            if (!!r)
                for (let f = s.length - 1; f >= 0; f--) {
                    const d = s[f];
                    if (d.href === i && (!o || d.rel === "stylesheet")) return
                } else if (document.querySelector(`link[href="${i}"]${a}`)) return;
            const u = document.createElement("link");
            if (u.rel = o ? "stylesheet" : Zye, o || (u.as = "script", u.crossOrigin = ""), u.href = i, document.head.appendChild(u), o) return new Promise((f, d) => {
                u.addEventListener("load", f), u.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${i}`)))
            })
        })).then(() => e()).catch(i => {
            const o = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (o.payload = i, window.dispatchEvent(o), !o.defaultPrevented) throw i
        })
    },
    Jye = st({
        props: {
            artifact: {
                type: Object,
                required: !0
            },
            artifactId: {
                type: String,
                required: !0
            },
            params: {
                type: Object,
                required: !0
            },
            renderData: {
                type: Object,
                required: !1
            },
            status: {
                type: String,
                required: !0
            }
        },
        emits: {
            "update:renderData": t => !0,
            "update:status": t => !0
        },
        computed: {
            index() {
                return parseInt(this.params.index, 10)
            },
            title() {
                return this.artifact.blob.songs[this.index].title
            }
        },
        watch: {
            status(t) {
                t === "requested" && this.onRequested()
            }
        },
        methods: {
            async onRequested() {
                this.renderData || await this.generateVideo()
            },
            async onVideoClick() {
                this.renderData || await this.generateVideo();
                const t = this.$refs.video;
                if (this.status === "playing") t.pause(), this.$emit("update:status", "paused");
                else {
                    await t.play(), this.$emit("update:status", "playing");
                    try {
                        zl.galleryWatch(this.artifact.categoryId, {
                            locale: this.$i18n.locale,
                            artifactId: this.artifactId,
                            itemId: this.index,
                            title: this.title
                        })
                    } catch (e) {
                        console.error(e)
                    }
                }
            },
            async generateVideo() {
                if (!this.renderData && this.status !== "loading") {
                    this.$emit("update:status", "loading");
                    try {
                        const t = await Qye(() => import("main/pp10/nopus-opus/assets/Muxer-ce5cf19a.js"), []),
                            e = new t.Muxer({
                                artifact: this.artifact,
                                params: this.params
                            });
                        await e.ready();
                        const n = this.$refs.video;
                        n.src = e.renderData.dataURL, this.$emit("update:renderData", e.renderData), this.$emit("update:status", "paused")
                    } catch (t) {
                        console.error(t)
                    }
                }
            }
        }
    });
const wC = t => (Gr("data-v-8c856a91"), t = t(), Vr(), t),
    e0e = {
        class: "video"
    },
    t0e = {
        ref: "video",
        playsinline: ""
    },
    n0e = ["disabled"],
    r0e = {
        viewBox: "0 0 1024 1024"
    },
    s0e = {
        key: 0,
        class: "loading"
    },
    i0e = wC(() => U("path", {
        class: "loading-shape",
        d: "m512.19,409.17c25.23-1.49,50.75,5.42,72.06,18.97,52,32.88,72.71,99.46,49.08,156.26-24.39,59.09-90.03,91.81-151.59,73.19-28.76-8.75-53.87-29.42-67.2-56.38-10.38-20.8-13.3-44.53-7.78-65.26,1.99,7.09,4.16,13.63,7.02,20.21,15.89,36.57,50.49,62.75,90.11,63.95,46.43,2.02,86.37-33.7,88.25-80.22,1.23-28.13-12.09-55-34.85-71.47-8.94-6.47-19.17-11.27-29.89-13.95-4.98-1.32-10.02-2.05-15.2-2.61-27.39-2.1-27.26-40.79,0-42.7h0Z"
    }, null, -1)),
    o0e = wC(() => U("circle", {
        class: "loading-circle",
        cx: "512.5",
        cy: "535.9",
        r: "214"
    }, null, -1)),
    a0e = [i0e, o0e],
    c0e = {
        key: 1,
        class: "play",
        d: "m377.26,714.86v-357.71c0-11,11.87-17.91,21.43-12.49l315.38,178.86c9.7,5.5,9.7,19.47,0,24.97l-315.38,178.86c-9.57,5.43-21.43-1.49-21.43-12.49Z"
    },
    l0e = {
        key: 0,
        class: "song-name"
    };

function u0e(t, e, n, r, s, i) {
    return B(), H("div", e0e, [U("video", t0e, null, 512), U("button", {
        class: "play-pause",
        disabled: t.status === "loading",
        onClick: e[0] || (e[0] = (...o) => t.onVideoClick && t.onVideoClick(...o))
    }, [(B(), H("svg", r0e, [t.status === "loading" ? (B(), H("g", s0e, a0e)) : t.status === "paused" ? (B(), H("path", c0e)) : Pe("", !0)]))], 8, n0e), t.renderData ? Pe("", !0) : (B(), H("p", l0e, rt(t.title), 1))])
}
const h0e = He(Jye, [
        ["render", u0e],
        ["__scopeId", "data-v-8c856a91"]
    ]),
    f0e = {},
    d0e = {
        viewBox: "0 0 80 100"
    },
    p0e = U("path", {
        d: "m9.69,100c-22.03-2.79-1.78-29.92,14.06-21.33V13.83L79.68,0c-1.07,7.9,2.83,79.11-2.84,84.29-3.99,7.74-16.19,13.35-23.78,7.78-9.11-11.56,9.48-25.36,21.08-19.16V11.05l-44.86,11.98v56.07c.3,10.79-8.3,20.84-19.59,20.89Z"
    }, null, -1),
    m0e = [p0e];

function g0e(t, e) {
    return B(), H("svg", d0e, m0e)
}
const z3 = He(f0e, [
        ["render", g0e]
    ]),
    _0e = st({
        props: {
            theme: {
                type: String,
                default: () => "mono"
            }
        },
        data() {
            return {
                wordClasses: ["note", "do-1", "do-2", "re", "mi", "note", "do-1", "do-2", "re", "mi", "note", "do-1", "do-2", "re", "mi", "fa", "so", "la", "ti"],
                wordClassIndex: 0
            }
        },
        computed: {
            classes() {
                return [this.theme, this.wordClass]
            },
            wordClass() {
                return this.wordClasses[this.wordClassIndex]
            }
        },
        methods: {
            onClick(t) {
                this.wordClassIndex = this.wordClassIndex < this.wordClasses.length - 1 ? this.wordClassIndex + 1 : 0
            }
        }
    });
const AC = t => (Gr("data-v-6aa58b27"), t = t(), Vr(), t),
    y0e = AC(() => U("path", {
        class: "staff",
        d: "m75.9,81.23h63.61v-5.06h-68.87c2.53,1.46,4.28,3.15,5.26,5.06Zm-6.01-35.13l-.17.17.17-.08v-.08Zm132.07,35.13v-5.06h-30.61v5.06h30.61Zm53.34-22.34h33.29v-5.06h-38.35c2.3,1.17,3.99,2.86,5.06,5.06Zm-53.34-5.06h-124.55c-.49,2.3-1.25,3.99-2.29,5.06h126.84v-5.06ZM22.6,98.56h-14.21v5.06h14.21v-5.06Zm281.42,5.06h95.98v-5.06h-95.98v5.06Zm80.06-22.39h15.92v-5.06h-15.92v5.06Zm0-27.4v5.06h15.92v-5.06h-15.92ZM22.6,120.9h-14.21v5.06h14.21v-5.06Zm0-44.73h-14.21v5.06h14.21v-5.06Zm-14.21,72.33h391.61v-5.06H8.39v5.06Zm206.76-22.53h184.85v-5.06h-184.85v5.06Z"
    }, null, -1)),
    v0e = AC(() => U("path", {
        class: "dodo",
        d: "m373.82,59.13c1.52-1.98,1.56-9.79.1-11.78-1.76-3.48-12.13-3.18-13.82.29-4.67,10.7,4.7,19.24,13.73,11.49ZM82.18,102.35c-3.3,5.2-3.55,24.24.73,29.64,5.09,9.45,28.85,8.86,33.63,0,4.02-5.04,3.82-25.2.19-30.18-4.31-10.06-30.25-8.92-34.56.54Zm21.95,23.46c-.89,3.18-8.36,3.32-9.34,0-.58-1.14-.71-13.45,0-14.75.65-2.29,9.03-4.24,9.49-.78.23.65.34,3.23.34,7.74,0,4.19-.16,6.78-.49,7.79Zm-57.89-46.81c.24-1.98-.03-5.88.02-6.56-.06-.75-.15-4.35-.44-4.32-.46.04-1.88.18-2.35.24-.18.02.17,4.32,0,4.34.23.84-.34,4.44.07,6.48-1.83.12-3.71.26-5.62.38.63-1.88-.1-5.77.14-6.69-.08-.65.34-4,0-4h-2.8c-.26,0,.26,4,0,4,.31.97-.52,5.03.2,6.84-1.52.09-3.06.16-4.62.21l-.15,57.24c25.92,1.24,46.62,8.82,45.46-28.38,1.44-29.35-11.62-30.84-29.91-29.77Zm-.32,45.89v-25.94c12.63-1.87,14.65-.28,13.19,15.67,1.01,10.69-5.29,11.84-13.19,10.27Zm313.83-32.95h14.65l.54-26.43-15.33.92.15,25.5Zm-195.27-13l-16.6.97.34,20.93h-.49c-3.71-9.42-19.68-6.51-23.46.39-2.14,3.18-3.21,7.84-3.21,13.97-.75,14.63,4.92,21.95,16.99,21.95,7.59,1.14,12.05-2.08,13.38-9.64l-.92,9.64h14.31c-.57-11.56-.27-45.51-.34-58.21Zm-21.66,48.57c-8.23,1.08-6.85-13.11-5.16-17.38,1.85-4.68,10-3.87,10.56-.92.44,4.18,3.35,19.62-5.4,18.3Zm98.75-39.47c8.63-.55,11.9-8.14,11.05-16.01-.36-21.2-29.71-12.27-42.54-13.38v37.28c3.28,2.4,5.19,8.29,5.74,17.67h9.73v-17.28c14.27-4.54,12.67,6.84,12.65,17.28h15.82c-.9-15.31,1.83-23.77-12.46-25.55Zm-16.69-2.82v-13.53c3.28.17,11.24-2.66,10.85,3.36.59,10.61-.79,10.45-10.85,10.17Zm51.01-12.17c-8.18.32-13.6,2.77-16.26,7.35-3.17,4.87-3.41,23.22.68,28.28,4.56,8.68,26.53,8.43,31.59.88,2.14-2.73,3.29-6.96,3.46-12.7l-14.11,1.41c0,3.28-.23,5.4-.68,6.38-1.07,2.81-7.99,2.89-8.81-.34-.39-1.07-.58-3.7-.58-7.88l24.19-2.19c-.2-13.37-5.2-21.8-19.47-21.17Zm5.11,18.11v-.1l-9.83,1.02.05-5.99c-.46-2.89,4.94-5.03,7.64-3.16,2.14,1.03,1.68,6.29,2.14,8.13h.05l-.05.1Zm51.15-54.22l-6.18,37.53c-2.5-12.2-4.98-24.95-7.45-38.26l-20.25.73-.97,35.34c4.09,4.02,6.44,10.58,7.06,19.66h9.39l.68-35.09,8.66,34.85,9.78-.54,4.53-34.31,2.63,35.09h16.26l-2.63-55.73-21.51.73Zm-144.6,57.87c-16.11.92-19.55,7.1-19.47,22.44-.06,14.02,4.74,21.49,19.47,21.61,15.89-.32,20.43-6.53,20.39-21.76-.02-15.4-4.02-22.7-20.39-22.29Zm4.92,31c-.79,3.15-8.38,3.35-9.25,0-.31-4.07-3.18-17.31,4.48-17.18,6.8-.88,4.86,2.19,5.35,9.39,0,4.19-.2,6.78-.58,7.79Z"
    }, null, -1)),
    b0e = {
        key: 0,
        class: "bird"
    },
    E0e = {
        key: 0,
        class: "body",
        d: "m65.99,25.43c-6.97-4.63-13.14-6-18.58-5.08-.42-5.85-.77-11.25-3.78-16.01-2.83-4.32-8.28-.27-6.35,3.98,2.08,3.76,8.03,8.89,8.66,12.34-13.2,3.3-21.97,20.14-27.53,35.43-6.78-8.13-12.42-16.3-15.53-23.2-2.41,8.59-.7,18.58,4.57,25.75C4.85,57.24,2.36,55.7,0,54.06c1.38,6.94,8.1,12.36,14.74,14.57l-.34-.17c16.03,6.89,40,7.19,53.2-5.42,9.33-10.02,9.09-28.74-1.61-37.61ZM28.21,59.31c-23.71,30.43.77-35.57,10.76-10.25,2.57,5.95-15.05,25.64-10.76,10.25Zm42.1-22.79c.01,2.58-4.2,2.69-4.15,0-.05-2.69,4.16-2.58,4.15,0Zm-21.35,3.05c-2.64.06-2.64-4.13,0-4.07,2.64-.06,2.64,4.13,0,4.07Zm20.41,6.86c-.97,7.77-14.69,8.56-15.93.42,0-.06.03-.08.08-.08-.06,0-.08-.03-.08-.08l-.08-.08c.06.01.11.02.17.08,4.53.12,11.92-.36,16.01-.25h-.17Zm.51-.25c-.08.04-.25.13-.34.17.13-.05.24-.15.34-.25v.08Zm.25-.25v.08h-.08c-3.57-.32-13.16.13-16.35.25h-.42c.1-3.7,2.62-7.29,6.27-8.22,6.67-3.39,14.45,7.08,10.59,7.88Z"
    },
    T0e = {
        key: 1,
        class: "bird"
    },
    S0e = Pc('<path class="body" d="m68.09,27.21c-5.66-5.9-14.06-8.01-22.04-6.32-19.35,3.7-25.66,31.48-31.66,47.43,7.29,3.62,15.59,4.7,23.66,4.4,7.3-.06,15.39-.91,21.78-4.16,15.41-6.75,19.11-29.17,8.25-41.36" data-v-6aa58b27></path><path class="feathers" d="m7.65,41.36c-2.59-4.27-4.16-7.13-4.71-8.6-2.48,8.63-.58,18.43,4.52,25.75C4.84,57.1,2.34,55.58,0,53.88c1.41,7.04,8.22,12.41,14.95,14.62,0,0,2.23-8.29,3.65-12.34-4.88-5.9-8.53-10.83-10.96-14.79m25.46,1.98c-12.14-.27-23.72,41.31-4.9,15.79-.03.87-1.24,4.9-.5,5.54,2.45,1.3,7.34-4.67,8.56-6.52,1.13-1.86,2.12-3.87,2.68-5.99.89-3.97-1.35-8.89-5.83-8.82m13.36-31.79c-.88-3.16-1.63-7.37-4.75-8.96-3.32-1.41-5.66,2.73-4.44,5.56.33.87,1.09,1.98,2.28,3.31,3.56,3.52,5.72,6.66,6.49,9.42-.02.36,1.06-.11,1.38-.06-.03-2.76-.5-7.2-.97-9.28Z" data-v-6aa58b27></path><path class="eyes" d="m70.3,36.41c.06-2.66-4.16-2.68-4.09,0-.07,2.66,4.15,2.64,4.09,0Zm-23.34,1c0,2.68,4.17,2.66,4.09,0-.08-2.83-4.09-2.58-4.09,0Z" data-v-6aa58b27></path><path class="dodo" d="m53.44,46.47c.98,8.36,14.89,7.71,16-.14l.74-.52c.53-.06.86-.2.98-.41.03-2.74-2.05-5.25-4.14-6.8-5.54-3.62-14.36,1.08-13.58,7.87Z" data-v-6aa58b27></path><path class="mouth" d="m69.97,45.94l.03-.03h.03c-.2-.25-19.28-.19-16.5.6,4.37.16,12.04-.26,16.03-.24-.02-.08.14-.14.19-.17.06-.06.1-.12.17-.12.01-.02.02-.03.03-.03Z" data-v-6aa58b27></path>', 5),
    w0e = [S0e],
    A0e = {
        key: 2,
        class: "word",
        d: "m110.67,1.51l-17.28,3.99-9.59,15.53,3.8,13.38-7.59,7.59,14.02-.97,8.91,5.89,17.28-4.38,9.59-14.75-4.48-16.79-14.65-9.49m-15.53,29.74c.03-5.37,6.91-9.01,10.85-5.26,1.17-10.48,1.74-15.87,1.7-16.16,6.05-.44,12.2,5.53,8.61,10.27-1.55-3.04-1.74-5.56-6.67-5.7-.39,9.54-.68,15.14-.88,16.79-1.01,5.74-13.39,6.54-13.63.05Z"
    },
    O0e = {
        key: 3,
        class: "word",
        d: "m101.02,21.42c-.41.04-1.71.13-1.97.24l.26,7.53c.27.06,1.55.07,1.94.03,2-.17,1.78-1.54,1.8-3.16.05-3.36.12-4.96-2.02-4.64Zm13.22,2.49c-1.51.32-1.47.8-1.4,2.83.07,2,.08,2.97,1.6,2.92,1.62-.06,1.51-1.02,1.44-3.02-.07-2.03.13-3.12-1.64-2.72Zm11.08-12.91l-14.65-9.49-17.28,3.99-9.59,15.53,3.8,13.38-7.59,7.59,14.02-.97,8.91,5.89,17.28-4.38,9.59-14.75-4.48-16.79Zm-18.48,20.01c-.9,1.24-2.44,2.19-5.05,2.11l-6.8-.22-.56-16.64,6.8-.55c2.58-.21,4.18.58,5.16,1.75,1.84,2.16,2.04,11.39.45,13.55Zm7.66,1.69c-5.09.18-5.79-3.01-5.89-6.06-.1-2.99-.17-6.3,5.42-6.74,5.81-.44,6.04,3.37,6.14,6.29.11,3.14-.12,6.31-5.67,6.51Z"
    },
    C0e = {
        key: 4,
        class: "word",
        d: "m102.28,18.6l-2.23.06-.16,4.13,1.86.07c.31.01,1.45-.04,1.5-1.3l.07-1.74c0-.85-.39-1.2-1.04-1.23Zm14.08,6.63l.02-.02h-.02v.02Zm-1.37-2.76c-1.14.08-1.5.62-1.52,1.13l-.09,1.79v.02s2.98-.2,2.98-.2l-.12-1.79c-.08-.53-.59-.99-1.24-.94Zm10.33-11.46l-14.65-9.49-17.28,3.99-9.59,15.53,3.8,13.38-7.59,7.59,14.02-.97,8.91,5.89,17.28-4.38,9.59-14.75-4.48-16.79Zm-16.92,20.73l-4.83-.19.09-2.17c.13-3.21-.69-3.85-3.69-3.22l-.21,5.24-4.71-.19.66-16.66,7.78.07c.87.01,2.24.21,3.3.9,1.01.67,1.58,2.12,1.65,3.6v.89c-.09,2.08-1.17,3.73-3.52,3.8,3.57.31,3.67,2.71,3.48,7.92Zm12.29-5.39l-7.37.36c-.09,2.17-.15,3.14,1.37,3.2,1.52.06,1.58-.78,1.65-2.52l4.31-.26c-.19,2.87-.99,5.55-6.11,5.34-5.09-.2-5.55-3.44-5.43-6.48.12-2.99.3-6.3,5.91-6.32,5.32,0,5.69,4,5.66,6.68Z"
    },
    k0e = {
        key: 5,
        class: "word",
        d: "m125.32,11l-14.65-9.49-17.28,3.99-9.59,15.53,3.8,13.38-7.59,7.59,14.02-.97,8.91,5.89,17.28-4.38,9.59-14.75-4.48-16.79Zm-11.85,21.88l-4.91-.43.13-10.66-2.28,10.23-2.98-.09-1.7-10.75-1.12,10.57-5.13-.45,1.89-16.57,6.16.3c.02-.22.58,6.14,1.23,11.77l2.87-11.17,6.52.33-.68,16.92Zm5.52.48l-4.43-.39.6-7.71,4.67.12-.84,7.98Zm1.19-11.71c-.11,1.3-.4,2.61-2.69,2.41-2.12-.19-2.24-1.53-2.13-2.81.11-1.25.24-2.43,2.56-2.32,2.44.12,2.37,1.52,2.26,2.72Z"
    },
    I0e = {
        key: 6,
        class: "word",
        d: "m111.11,28c-.72,0-1.23.31-1.23.87s.51.84,1.23.84c.77,0,1.57-.84,1.57-.84,0,0-.8-.87-1.57-.87Zm14.21-17l-14.65-9.49-17.28,3.99-9.59,15.53,3.8,13.38-7.59,7.59,14.02-.97,8.91,5.89,17.28-4.38,9.59-14.75-4.48-16.79Zm-19.51,15.16l-5.22.24v5.15h-4.62V14.88l11.26-.24v4.83l-6.89.24v2.47l5.46-.48v4.47Zm12.18,5.39h-3.7l-.07-1.67c-1.14,1.04-2.75,1.67-4.18,1.67-2.22,0-3.29-1.3-3.29-2.8,0-1.93,1.5-2.51,3.21-2.51,1.52,0,3.21.46,4.23.87v-3.12l-6.96.6v-5.12c5.9.05,10.87.34,10.87.34l-.12,11.74Z"
    },
    N0e = {
        key: 7,
        class: "word",
        d: "m125.32,11l-14.65-9.49-17.28,3.99-9.59,15.53,3.8,13.38-7.59,7.59,14.02-.97,8.91,5.89,17.28-4.38,9.59-14.75-4.48-16.79Zm-24.83,8.38c-1.64.25-1.28,2.05-1.38,3.54-.11,1.64,1.39,1.62,1.39,1.62,3.98.27,6.92,0,6.64,4.2-.27,4.03-5.27,3.86-7.34,3.72-6.56-.44-5.62-5.32-5.62-5.32l4.87.71c-.1,1.49-.04,2.37,1.29,2.43,1.4.09,2.04-.03,2.09-3.35-3.64-.24-4.78-.22-6.35-.98-1.53-.68-2.04-2.03-1.87-4.58.08-1.23-.06-3.78,1.84-5.37,1.1-.92,2.67-1.52,5.56-1.32,3.06.21,4.59,1.62,5.33,3.26,1.15,2.64.23,5.92.23,5.92l-4.75-.32.14-2.12c.1-1.54-.09-2.33-2.07-2.05Zm19.08,8.04c-.21,3.13-.76,6.27-6.31,5.9-5.09-.34-5.45-3.59-5.25-6.62.2-2.99.47-6.29,6.08-6.16,5.83.15,5.67,3.96,5.47,6.88Zm-5.67-2.87c-1.54.16-1.54.65-1.68,2.67-.13,2-.22,2.96,1.3,3.07,1.61.11,1.61-.86,1.74-2.86.14-2.02.45-3.09-1.36-2.88Z"
    },
    x0e = {
        key: 8,
        class: "word",
        d: "m125.32,11l-14.65-9.49-17.28,3.99-9.59,15.53,3.8,13.38-7.59,7.59,14.02-.97,8.91,5.89,17.28-4.38,9.59-14.75-4.48-16.79Zm-29.26,21.26l-1.21-16.63,5.31-.63.25,13.4,5.87-.91.29,4-10.51.76Zm18.75-1.36l-.19-1.66c-1.06,1.12-2.63,1.86-4.05,1.97-2.22.16-3.37-1.06-3.48-2.56-.14-1.93,1.31-2.62,3.02-2.74,1.52-.11,3.24.23,4.28.56l-.23-3.11-6.9,1.11-.37-5.11c5.88-.38,10.87-.45,10.87-.45l.73,11.72-3.69.27Zm-4.6-2.35c.04.58.57.81,1.29.75.77-.06,1.51-.96,1.51-.96,0,0-.86-.81-1.63-.75-.72.05-1.21.4-1.17.96Z"
    },
    P0e = {
        key: 9,
        class: "word",
        d: "m125.32,11l-14.65-9.49-17.28,3.99-9.59,15.53,3.8,13.38-7.59,7.59,14.02-.97,8.91,5.89,17.28-4.38,9.59-14.75-4.48-16.79Zm-18.4,11.22l-.57,10.98-5.4-.32.76-10.87-3.91-.16.34-5.84,12.53.49-.27,5.84-3.48-.13Zm8.12,11.49l-4.44-.26.38-7.72,4.67-.02-.61,8Zm.86-11.74c-.08,1.3-.32,2.62-2.61,2.48-2.12-.12-2.29-1.47-2.21-2.74.07-1.25.17-2.43,2.49-2.4,2.44.05,2.41,1.45,2.34,2.65Z"
    };

function R0e(t, e, n, r, s, i) {
    return B(), H("svg", {
        viewBox: "0 0 400 150",
        class: nt(t.classes),
        onClick: e[0] || (e[0] = (...o) => t.onClick && t.onClick(...o))
    }, [y0e, v0e, t.theme === "mono" ? (B(), H("g", b0e, [t.theme === "mono" ? (B(), H("path", E0e)) : Pe("", !0)])) : (B(), H("g", T0e, w0e)), t.wordClass === "note" ? (B(), H("path", A0e)) : Pe("", !0), t.wordClass === "do-1" || t.wordClass === "do-2" ? (B(), H("path", O0e)) : Pe("", !0), t.wordClass === "re" ? (B(), H("path", C0e)) : Pe("", !0), t.wordClass === "mi" ? (B(), H("path", k0e)) : Pe("", !0), t.wordClass === "fa" ? (B(), H("path", I0e)) : Pe("", !0), t.wordClass === "so" ? (B(), H("path", N0e)) : Pe("", !0), t.wordClass === "la" ? (B(), H("path", x0e)) : Pe("", !0), t.wordClass === "ti" ? (B(), H("path", P0e)) : Pe("", !0)], 2)
}
const OC = He(_0e, [
        ["render", R0e],
        ["__scopeId", "data-v-6aa58b27"]
    ]),
    M0e = st({
        components: {
            LazyMuxedVideo: h0e,
            LogoSVG: OC,
            NoteSVG: z3
        },
        props: {
            artifact: {
                type: Object,
                required: !0
            },
            artifactId: {
                type: String,
                required: !0
            },
            context: {
                type: String,
                required: !0
            }
        },
        data({
            artifact: t
        }) {
            return {
                shareables: t.blob.songs.map((n, r) => ({
                    title: n.title,
                    index: r,
                    hash: n.hash,
                    status: "paused",
                    renderData: null,
                    mp3: n.renderUrl
                })),
                canShare: Ey.canShare
            }
        },
        methods: {
            requestMux(t, e) {
                t.status = "requested";
                const n = na(t, ({
                    status: r
                }) => {
                    r === "paused" && (e(t), n())
                })
            },
            async onCopyClick(t) {
                if (!t.renderData) {
                    this.requestMux(t, this.onCopyClick);
                    return
                }
                try {
                    await Ey.copyToClipboard(t.renderData.file, {
                        categoryId: this.artifact.categoryId,
                        options: {
                            locale: this.$i18n.locale,
                            artifactId: this.artifactId,
                            itemId: t.index,
                            title: t.title
                        }
                    })
                } catch (e) {
                    console.warn(e)
                }
            },
            async onShareClick(t) {
                if (!t.renderData) {
                    this.requestMux(t, this.onShareClick);
                    return
                }
                try {
                    await Ey.share(t.renderData.file, {
                        title: "Check out my game of Dodo Re Mi"
                    }, {
                        categoryId: this.artifact.categoryId,
                        options: {
                            locale: this.$i18n.locale,
                            artifactId: this.artifactId,
                            itemId: t.index,
                            title: t.title
                        }
                    })
                } catch (e) {
                    console.warn(e)
                }
            },
            onDownloadClick(t) {
                zl.galleryDownload(this.artifact.categoryId, {
                    locale: this.$i18n.locale,
                    artifactId: this.artifactId,
                    itemId: t.index,
                    title: t.title
                })
            }
        }
    });
const D0e = {
        class: "nopus theme-purple"
    },
    $0e = {
        class: "constrain"
    },
    L0e = {
        class: "name"
    },
    F0e = {
        class: "actions"
    },
    U0e = ["href", "onClick"],
    B0e = ["disabled", "onClick"],
    q0e = ["disabled", "onClick"];

function G0e(t, e, n, r, s, i) {
    const o = Ge("LogoSVG"),
        a = Ge("NoteSVG"),
        l = Ge("LazyMuxedVideo"),
        u = Gt("t");
    return B(), H("div", D0e, [U("div", $0e, [Ve(o, {
        class: "logo",
        theme: "full",
        "aria-label": t.$t("ALT.LOGO")
    }, null, 8, ["aria-label"]), (B(!0), H(lt, null, gn(t.shareables, (f, d) => (B(), H("div", {
        key: f.hash,
        class: "shareable"
    }, [U("p", L0e, [Ve(a, {
        class: "icon"
    }), mn(rt(f.title), 1)]), Ve(l, {
        ref_for: !0,
        ref: "video",
        status: f.status,
        "onUpdate:status": p => f.status = p,
        renderData: f.renderData,
        "onUpdate:renderData": p => f.renderData = p,
        "artifact-id": t.artifactId,
        artifact: t.artifact,
        params: {
            index: `${d}`
        }
    }, null, 8, ["status", "onUpdate:status", "renderData", "onUpdate:renderData", "artifact-id", "artifact", "params"]), U("div", F0e, [U("a", {
        href: f.mp3,
        class: "button primary mp3",
        onClick: p => t.onDownloadClick(f)
    }, [Ve(a, {
        class: "icon"
    }), mn("MP3 ")], 8, U0e), t.canShare ? $e((B(), H("button", {
        key: 0,
        class: "share",
        disabled: f.status === "loading",
        onClick: p => t.onShareClick(f)
    }, null, 8, B0e)), [
        [u, "SHARE.SHARE"]
    ]) : $e((B(), H("button", {
        key: 1,
        class: "share",
        disabled: f.status === "loading",
        onClick: p => t.onCopyClick(f)
    }, null, 8, q0e)), [
        [u, "SHARE.COPY_TO_CLIPBOARD"]
    ])])]))), 128))])])
}
const CC = He(M0e, [
    ["render", G0e],
    ["__scopeId", "data-v-a393407e"]
]);
class ur {
    static difficultyI18ByNumber(e) {
        return this.difficulty.numberToI18n[e]
    }
    static categoryI18nBySlug(e) {
        return this.category.slugToI18n[e]
    }
    static categoryI18ByKey(e) {
        return this.category.keyToI18n[e]
    }
    static categoryKeyBySlug(e) {
        return this.category.slugToKey[e]
    }
    static categorySortOrderByKey(e) {
        return this.category.sortOrder[e]
    }
    static categorySlugByKey(e) {
        return this.category.keyToSlug[e]
    }
    static instrumentIconBySlug(e) {
        return this.instrument.slugToIcon[e]
    }
}
ye(ur, "difficulty", {
    numberToI18n: ["", "DIFFICULTY.VERY_EASY", "DIFFICULTY.EASY", "DIFFICULTY.MEDIUM", "DIFFICULTY.HARD", "DIFFICULTY.VERY_HARD"]
}), ye(ur, "category", {
    slugToI18n: {
        "aux-percussion": "BEATMAPS.PERCUSSION",
        bass: "BEATMAPS.BASS",
        "counter-melody": "BEATMAPS.COUNTER",
        drums: "BEATMAPS.DRUMS",
        harmony: "BEATMAPS.HARMONY",
        melody: "BEATMAPS.MELODY",
        signature: "BEATMAPS.SIGNATURE"
    },
    keyToI18n: {
        AuxPercussion: "BEATMAPS.PERCUSSION",
        Bass: "BEATMAPS.BASS",
        CounterMelody: "BEATMAPS.COUNTER",
        Drums: "BEATMAPS.DRUMS",
        Harmony: "BEATMAPS.HARMONY",
        Melody: "BEATMAPS.MELODY",
        Signature: "BEATMAPS.SIGNATURE"
    },
    slugToKey: {
        "aux-percussion": "AuxPercussion",
        bass: "Bass",
        "counter-melody": "CounterMelody",
        drums: "Drums",
        harmony: "Harmony",
        melody: "Melody",
        signature: "Signature"
    },
    keyToSlug: {
        AuxPercussion: "aux-percussion",
        Bass: "bass",
        CounterMelody: "counter-melody",
        Drums: "drums",
        Harmony: "harmony",
        Melody: "melody",
        Signature: "signature"
    },
    sortOrder: {
        Melody: 0,
        CounterMelody: 1,
        Harmony: 2,
        Bass: 3,
        Drums: 4,
        AuxPercussion: 5,
        Signature: 6
    }
}), ye(ur, "instrument", {
    slugToIcon: {
        "agnes-the-dog-howls": "dog",
        "agnes-the-dog": "dog",
        "alarm-clock": "clock",
        "arp-synth": "synth",
        "baby-sloppy-horn": "trombone",
        banjo: "banjo",
        "bari-sax": "sax",
        "bass-flute": "flute",
        bassoon: "flute",
        beatbox: "mouth",
        bitdrums: "synth",
        bottlecaps: "shaker",
        "burpin-conga": "mouth",
        "burps-melody": "mouth",
        cajon: "woodblock",
        cannon: "canon",
        "car-alarm": "car",
        castanets: "castanets",
        "casual-saxophone": "sax",
        caxixi: "shaker",
        "cello-bowed": "cello",
        "cello-plucked": "cello",
        "cheeks-melody": "mouth",
        "cheeks-percussion": "mouth",
        clarinet: "flute",
        "constant-scream": "mouth",
        "continuous-agnes": "dog",
        "continuous-burp": "mouth",
        "continuous-constant-screaming": "mouth",
        "continuous-doug": "mouth",
        "continuous-flute": "flute",
        "continuous-gargles": "mouth",
        "continuous-jan": "mouth",
        "continuous-kazoo": "kazoo",
        "continuous-lip-flipper": "mouth",
        "continuous-mario": "",
        "continuous-natures-bugle": "poop",
        "continuous-shredding-guitar": "electric-guitar",
        "continuous-slide-whistle": "whistle",
        "continuous-susan": "",
        "continuous-taz": "cat",
        "contrabass-clarinet": "flute",
        "contrabass-flute": "flute",
        contrabassoon: "flute",
        "cow-bell": "bell",
        cussin: "mouth",
        didgeridoo: "whistle",
        "dinner-bell": "bell",
        "dj-drums": "synth",
        "double-bass-bowed": "cello",
        "double-bass-plucked": "cello",
        doug: "mouth",
        "drum-set-clean": "drumKit",
        "eb-soprano-clarinet": "flute",
        "electric-bass": "electric-guitar",
        euphonium: "tuba",
        "extra-sloppy-horn": "trombone",
        "extra-tall-bongos": "tallBongo",
        "fast-food-cup": "cup",
        "field-drums": "snare",
        flugelhorn: "trumpet",
        flute: "flute",
        "french-horn-redo": "frenchHorn",
        gargles: "mouth",
        goat: "goat",
        gong: "gong",
        "grandmas-piano": "piano",
        guiro: "fish",
        "guitar-acoustic-chords": "guitar",
        "guitar-acoustic-notes": "guitar",
        "guitar-electric-chords": "electric-guitar",
        "guitar-electric-noamp": "electric-guitar",
        "guitar-metal-chords": "electric-guitar",
        "guitar-metal-notes": "electric-guitar",
        "guitar-rock-chords": "electric-guitar",
        "guitar-rock-notes": "electric-guitar",
        "h0-ly-crap": "poop",
        "husky-clarinet": "flute",
        "jaw-harp": "mouth",
        "jazz-drums": "drumKit",
        kazoo: "kazoo",
        "kettle-drums": "snare",
        "kung-fu-drums": "hands",
        "lil-ukulele-friend-redo": "guitar",
        "lip-flipper": "mouth",
        "little-congas": "bongos",
        "marching-bass-drum": "snare",
        "marching-drums": "snare",
        marimba: "xylophone",
        mario: "mouth",
        "mommy-sax": "sax",
        mosquito: "mosquito",
        "music-box": "woodblock",
        oboe: "flute",
        ocarina: "ocarina",
        "piccolo-trumpet": "trumpet",
        piccolo: "flute",
        "pieces-of-wood": "sticks",
        "pluck-synth": "synth",
        "plucky-violin": "cello",
        "plucky-violins-cousin": "cello",
        "pots-n-pans": "pots",
        "rain-stick": "whistle",
        "rave-synth": "synth",
        rhodes: "piano",
        "robot-synth": "synth",
        "shaky-shaker": "shaker",
        "shy-flute": "flute",
        "sloppy-horn-sampler": "trombone",
        "sloppy-horn-senior": "trombone",
        "snap-clap-stomp": "hands",
        "snare-drum": "snare",
        "squeeze-box": "accordion",
        "tall-bongos": "tallBongo",
        tamborine: "tamborine",
        "taz-the-cat": "cat",
        "the-beef": "synth",
        tootsaphone: "poop",
        trumpet: "trumpet",
        tuba: "tuba",
        tutorial: "cap",
        "uncle-sax": "sax",
        vibes: "xylophone",
        vibraslap: "vibraslap",
        violin: "cello",
        "violins-cousin": "cello",
        "voice-alto": "mouth",
        "voice-soprano": "mouth",
        "weird-oboe": "flute",
        whistle: "mouth",
        "wind-chimes": "chimes",
        "wobble-bass": "electric-guitar",
        "wood-block": "woodblock"
    }
});
const V0e = st({
    props: {
        avatar: {
            type: Number,
            required: !0
        }
    }
});
const Ot = t => (Gr("data-v-762a6505"), t = t(), Vr(), t),
    j0e = Ot(() => U("path", {
        class: "legs",
        d: "m260.33,479.5c.14,9.96-15.51,9.97-15.36,0,0,0,0-69.65,0-69.65h15.36v69.65Zm45.85-69.65h-15.49v69.65c0,4.24,3.44,7.68,7.68,7.68s7.68-3.44,7.68-7.68l.13-69.65Z"
    }, null, -1)),
    W0e = {
        class: "dancer"
    },
    H0e = {
        key: 0
    },
    Y0e = Ot(() => U("path", {
        class: "body",
        d: "m427.34,191.3c-31.47-32.8-78.21-44.55-122.57-35.13-107.61,20.57-142.69,175.09-176.04,263.77,40.53,20.16,86.68,26.16,131.6,24.48,40.59-.35,85.58-5.03,121.13-23.13,85.67-37.54,106.25-162.21,45.88-229.98"
    }, null, -1)),
    z0e = Ot(() => U("path", {
        class: "feathers",
        d: "m91.21,270.01c-14.4-23.74-23.13-39.67-26.2-47.8-13.81,47.97-3.21,102.5,25.15,143.21-14.53-7.92-28.44-16.34-41.47-25.82,7.83,39.15,45.74,69,83.16,81.3,0,0,12.37-46.11,20.31-68.63-27.13-32.83-47.45-60.25-60.95-82.26m141.58,11.04c-67.49-1.5-131.89,229.74-27.26,87.83-.19,4.84-6.88,27.27-2.78,30.81,13.63,7.21,40.81-25.98,47.61-36.28,6.28-10.33,11.81-21.51,14.88-33.31,4.93-22.08-7.48-49.46-32.44-49.05m74.29-176.81c-4.9-17.55-9.09-40.99-26.39-49.82-18.45-7.86-31.49,15.17-24.67,30.91,1.85,4.86,6.08,11.01,12.67,18.43,19.77,19.58,31.8,37.05,36.09,52.41-.14,1.98,5.89-.63,7.68-.34-.18-15.36-2.8-40.04-5.38-51.58Z"
    }, null, -1)),
    K0e = [Y0e, z0e],
    Z0e = {
        key: 1
    },
    X0e = Ot(() => U("path", {
        class: "body",
        d: "m341.25,153.29c-38.56-1.39-79.06,10.63-104.91,40.51-57.31,63.16-79.73,147.99-108.6,226.14,41.16,19.52,87.26,26.43,132.6,24.48,40.58-.35,85.58-5.04,121.13-23.13,121.51-54.31,102.75-263.79-40.22-267.99"
    }, null, -1)),
    Q0e = Ot(() => U("path", {
        class: "feathers",
        d: "m109.06,219.14c2.5-5.46-5.75-4.52-9.79-4.03-39.06,7.01-61.12,54.76-56.25,92.05-10.25-10.47-21.39-18.52-38.49-23.61-1.06,67.22,62.63,119.11,124.2,136.4,2.69-8,5.44-15.97,8.25-23.9-39.64-30.25-28.75-114.47,21.6-125.36-18.53-30.58-55.85-19.23-67.38,10.27.68-21.55,7.69-42.59,17.85-61.81m102.42,62.49c-18.35,3.35-34.86,26.3-42.33,44.35l-.19.1c6.44-2.87,12.27-5.83,19.39-9.98-21.03,34.19-27.3,44.35-32.44,53.46.63-.75-4.81,9.27-.86,6.72,8.01-3.54,16.45-5.93,24.09-10.17-2.68,4.18-30.04,48.15-32.06,50.87,3.15,5.9,23.87-3.26,31.67-5.57,26.97-10.75,40.36-14.32,58.26-31.68,33.96-27.61,29.19-109.02-25.53-98.1m97.23-249.52c.05-8.48-8.66,3.14-10.27,4.42-26.13,30.97-44.83,73.77-50.1,113.07-4-22.91-5.67-51.71-7.97-73.62-1.08-1.87-2.69-1.12-3.74.67-20.11,31.18-32.02,77.36-29.56,118.83-2.19-2.56-9.77-28.42-14.59-26.78-12.68,16.3-9.49,63.01,7.1,76.12,32.21-56.04,73.46-93.81,141.67-90.51,3.25-43.42,14.66-93.2,32.73-129.29,1.15-2.18,1.15-3.62,0-4.32-35.94,14.1-58.18,56.83-71.12,94.16.45-27.58,2.4-55.16,5.86-82.74Z"
    }, null, -1)),
    J0e = [X0e, Q0e],
    eve = {
        key: 2
    },
    tve = Ot(() => U("path", {
        class: "body",
        d: "m351.9,153.06c-145.64-15.71-184.78,160.75-224.16,266.88,89.43,38.11,223.82,39.36,297.02-31.42,70.05-74.69,38.65-225.27-72.85-235.46"
    }, null, -1)),
    nve = Ot(() => U("path", {
        class: "feathers",
        d: "m113.47,246.69c-35.76-6.86-45.17,27.33-34.07,56.15-55.31-80.2-106.43,21.56-23.32,54.52-32.26-8.59-45.14,25.83-20.93,44.63,24.52,17.96,67.15,21.49,106.26,23.8l-12.67-5.86c.45-1.41,23.77-68.79,25.05-72.37-6.65-15.19-11.54-31.26-16.03-47.13-6.5-17.76-4.85-45.92-24.28-53.75m170.18,86.68c-2.51-10.55-4.98-18.29-9.69-26.3.7,1.66-80.95-2.59-74.68-7.97-15.37,9.52-35.22,22.73-42.14,39.16-11.36,22.64,12.88,37.22,32.25,24.86-29.74,49.46,39.51,65.92,45.21,8.16,8.34,55.32,69.47,40.79,49.05-37.91m80.44-177.38c33.47-101.26-65.61-124.6-59.32-41.85-13.57-88.04-114.45-68.93-60.76,22.27-47.46-62.94-91.28,31.16-17.66,68.92,33.85-47.51,91.74-58.07,137.74-49.34Z"
    }, null, -1)),
    rve = Ot(() => U("path", {
        class: "feathers top",
        d: "m113.09,283.64c-11.66-9.82-20.87,2.23-21.4,15.84-2.52,11.61,10.17,38.26,15.93,45.5-8.19-8.89-16.8-16.89-25.82-24-14.93-9.86-17.88-18.87-31.48-12.29-24.95,23.13,25.18,53.01,47.8,63.93-19.74-2.81-53.5-15.77-53.75,12.48,2.89,24.52,63.86,26.44,85.81,30.62,6.53-19.13,13.15-38.23,19.87-57.3-9.24-22.94-33.37-75.14-36.95-74.77m162.79,28.8c-13.93-42.75-71.8-26.05-92.14,1.83-21.19,24.14,3.54,44.63,25.05,20.44-27.69,53.52,25.56,52.2,27.64-3.17,5.59,51.37,62.08,38.4,39.45-19.1m-9.69-142.64c-12.78-8.26-26.29-22.61-41.66-22.37-8.73,1.79-12.37,10.44-12.29,19.97.19,9.66,7.39,19.39,21.6,29.18,9.47-10.69,19.83-20.23,32.35-26.78m9.21-71.32c-38.71-1.94-22.95,39.69-4.51,68.92,12.13-5.97,25.37-10.09,38.97-12.19-11.64-26.16-14.25-50.99-34.46-56.73m74.29,7.77c-26.28-31.77-36.59,28.66-37.63,48.66,13.13-1.8,26.98-2.43,39.83-.86,2.9-14.29,6.18-36.66-2.21-47.8Z"
    }, null, -1)),
    sve = [tve, nve, rve],
    ive = {
        key: 3
    },
    ove = Ot(() => U("path", {
        class: "body",
        d: "m218.19,214.53c-2.01,3.1-8.51,12.63-10.27,15.65h-.19l.1.1-1.34,2.11c.13-.13.26-.26.38-.38-36.49,57.91-56.56,123.97-79.13,187.94,45.57,23.03,98.75,26.56,149.01,24.09,55.1-1.7,113.65-15.19,150.6-57.3,41.89-47.62,45.66-127.64,11.71-180.16-37.62-55.4-91.5-94.41-141.87-134-2.55,36.93-61.38,111.5-79,141.96"
    }, null, -1)),
    ave = Ot(() => U("path", {
        class: "feathers",
        d: "m149.66,293.53c-36.47-63.88-136.29-26.41-129.96,43.87,5.24,58.16,71.55,74.35,119.5,87.35l-10.46-4.8c1.47-4.29,2.94-8.54,4.42-12.77-30.44-9.38-86.83-38.82-57.21-76.21,12.46-14.48,21.62-18.29,36.67-18.81,18.61-.52,23.87,13.07,11.23,26.11-4.66,5.37-16.09,6.29-24.48,6.05-6.27-1.15-4.03.83,6.72,5.95,11.46,6.39,23.46,2.01,31.58-7.1,13.11-12.5,21.09-32.75,12-49.62m100.11-14.21c-.64-3.01-1.54-5.7-2.69-8.06-22.95,16.23-44.73,30.18-59.41,52.89-10.37,15.58-17.59,33.56-20.25,52.02-.1,7.77-5.13,21.57-1.73,27.84,53.71-15.65,98.83-66.1,84.08-124.69"
    }, null, -1)),
    cve = [ove, ave],
    lve = {
        key: 4
    },
    uve = Ot(() => U("path", {
        class: "body",
        d: "m236.81,193.32c-25.47,27.04-43.71,59.29-58.65,93.01.62,4.16-33.49,89.64-44.92,93.11-91.3,60.83,6.69,77.13,46.26,58.26,59.52,12.23,147.51,10.47,201.95-16.41,88.43-38.42,108.35-172.68,38.49-236.8,15.99-26.52,13.5-68-9.21-89.56-.83,0-1.67.67-2.5,2.02-4.99,8.77-11.1,16.54-18.33,23.32-.53-18.07-16.16-50.56-31.67-61.34-23.32,43.95-87.93,93.72-121.42,134.38"
    }, null, -1)),
    hve = Ot(() => U("path", {
        class: "feathers",
        d: "m125.95,386.92c2.69-2.94,5.12-5.44,7.29-7.49-25.92,22.78-53.87,32.94-89.07,39.55-2.35.51-3.73.72-4.22,2.69,15.36,7.61,22.66,9.68,38.3,9.98,19.43,23.65,67.84,17.75,93.01,9.5-4.3,1.11-18.17,3.42-23.61,2.78-11.83-.19-36.01-5.54-15.36-17.28,9.01-5.54-11.97-1.77-19.01-3.94-15.2-3.06-16.9-3.87-6.34-14.59,8.02-8.31,11.21-13.04,19-21.21m115.47-52.12c19.73-22.74,8.47-65.6-22.75-69.3-17.45-2.73-28.01,9.35-40.51,20.83-10.28,9.48-29.76,29-43.58,42.91-31.37,36.38,62.93,46.26,80.34,32.35,10.17-7.68,19-16.61,26.49-26.78"
    }, null, -1)),
    fve = Ot(() => U("path", {
        class: "feathers top",
        d: "m129.7,344.21c-.38-3.78,1.25-8.77,4.9-14.97-13.25,13.12-24.16,23.26-32.73,30.43-3.08,3.03-12.92,9.59-12.67,13.82,5.11,18.76,51.8-.95,64.79-9.21-20.41,22.94-2.16,24.48,17.85,18.81,15.42-4.24,30.06-11.63,43.1-21.5-25.22,10.86-45.21,9.97-34.84-21.21-11.24,5.83-19.16,11.6-30.33,12.86-8.86.91-18.5.02-20.06-9.02m50.68-4.51c-.06.19-.16.42-.29.67.06-.06.16-.13.29-.19v-.48Z"
    }, null, -1)),
    dve = [uve, hve, fve],
    pve = {
        key: 5
    },
    mve = Ot(() => U("path", {
        class: "body",
        d: "m210.84,442.81c56.23,3.81,119.7,3.04,170.61-21.7,127.76-57.95,98.22-278.38-53.96-267.87-124.91,2.33-161.79,162.01-198.83,266.52-.26.73,5.97,2.68,6.82,3.07,0,0,75.37,19.97,75.37,19.97Z"
    }, null, -1)),
    gve = Ot(() => U("path", {
        class: "feathers",
        d: "m69.51,236.77c-6.08-11.91-11.43-24.16-16.03-36.77-.45-1.22-1.28-1.6-2.5-1.15-6.1,32.73-6.78,67.49.67,99.95,29.91,33.07,59.43,58.91,83.91,84.78v.1c-36.59-23-90.98-58.41-135.56-86.12l4.61,12.1-.1-.58c8.02,18.4,14.88,40.8,32.26,52.52,30.96,15.16,62.04,22.62,95.72,32.07l-126.44-11.04c6.25,8.57,24.48,21.37,33.03,26.69,23.12,4.87,62.57-5.34,92.55-7.59-13.84,4.1-22.19,6.91-44.84,12.87-25.53,7.9-35.73,6.36-51.94,15.46,18.83,3.91,37.99,7.04,56.93,10.56,2.05.58,3.97.29,5.76-.86,10.69-6.66,21.47-13.12,32.36-19.39l-1.25-.58c5.31-15.68,10.72-31.33,16.23-46.95-15.75-25.47-62.28-109.7-75.37-136.05m184.05,165.23c10.01,10.73,1.55-48.09,1.54-52.23,2.76-9.07-58.64-42.27-66.82-43.4-.75-.78-3.22,1.31-3.26,2.59-21.55,38.38-45.37,105.85-65,151.89-5.42,14.97,35.22-28.17,37.93-29.09,7.42-7.62,18.05-15.61,23.81-23.91,3.93-19.53,4.6-47.2,6.14-66.63,3.29,43.42,4.8,65.46,9.5,99.66,1.16,3.18,2.05,28.71,5.95,20.93,11.7-25.41,16.85-52.07,22.75-76.91-.26-3.69-.83-4.18-2.98-8.83-4.84-11.49-7.08-21.11-13.35-31.88,14.42,19.85,29.11,39.13,43.78,57.8m3.36-226.97c3.2-2.11,6.5-4.03,9.89-5.76-76.57-56.32-89.3-76.68-161.39-47.24,46.55,20.93,91.14,32.88,138.64,62.31-61.65-16.4-66.5-17.49-99.37,3.46-7.23,4.03-20.29,13.06-39.17,27.07,31.02-6.67,82.11-7.93,120.11-8.93,9.11-11.37,19.6-22.5,31.3-30.92m45.12-53c-8.19-27.91-14.05-45.6-17.57-53.09-5.21-14.4-55.62-48.65-66.63-57.7-3.28-2.83-5.22-3.03-6.82-6.05-.77-1.09-.74-.7.1,1.15,11.19,21.92,49.99,96.01,65.29,133.65,12.61,29.19,9.12,26.05-10.46-9.41-34.28-66.82-60.17-72.27-117.23-75.75,38.17,29.82,89,75.59,118.96,113.96,13.94-7.46,29.6-12.23,45.51-14.31-3.46-8.13-7.17-18.95-11.14-32.45Z"
    }, null, -1)),
    _ve = [mve, gve],
    yve = {
        key: 6
    },
    vve = Ot(() => U("path", {
        class: "body",
        d: "m279.24,163.66c-94.04,38.57-119.14,172.16-150.5,256.28,40.52,20.19,86.68,26.14,131.6,24.48,40.58-.35,85.58-5.04,121.13-23.13,89.04-38.68,108.55-174.44,37.15-238.04,0,0-52.8-55.08-139.37-19.58Z"
    }, null, -1)),
    bve = Ot(() => U("path", {
        class: "feathers",
        d: "m89.48,240.93c-15.29-20,19.54,103.96,24.96,131.79l-106.16-10.85c-2.18-.13-3.42.42-3.74,1.63-.32,1.15.51,2.21,2.5,3.17,56.28,27.25,78.63,38.72,125.16,54.9l-3.46-1.63c7.55-22.14,15.2-44.25,22.94-66.33-.58-1.09-1.18-2.21-1.82-3.36l-60.37-109.33m110,41.95l1.92,26.4c-13.79,22.54-35.56,62.51-46.84,84.76-.89,2.37-2.72,6.21-5.47,11.52-2.75,5.31-2.37,6.14,1.15,2.5s12.16-9.79,25.92-18.43c13.55-8.07,69.55-45.6,80.24-51.26-8.25-14.69-36.13-39.68-56.92-55.48m116.62-128.53c-38.44-20.67-78.72-41.12-112.11-54.71,12.58,19.44,52.13,46.81,75.25,64.02,46.91,33.09,55.9,37.67,111.34,74.1,25.45-43.3,55.02-106.52,55.58-157.7-9.4,16.01-55.43,94.59-63.83,108.75-17.53-8.83-39.61-20.32-66.23-34.46Z"
    }, null, -1)),
    Eve = [vve, bve],
    Tve = {
        key: 7
    },
    Sve = Ot(() => U("path", {
        class: "body",
        d: "m427.34,191.3c-3.93-4.1-24.27-43.38-24.27-43.38l-12.67,17.12c-177.99-49.1-214.07,124.01-261.67,254.9,76.87,34.7,175.82,33.8,252.73,1.35,85.67-37.55,106.25-162.22,45.88-229.99"
    }, null, -1)),
    wve = Ot(() => U("path", {
        class: "feathers",
        d: "m252.65,330.67c-.89-4.25,4.64-7.56,6.43-2.98,1.17,3.77-.51,18.08-.19,28.32,3.82,10.62,19.04,17.95,28.41,9.5,11.85-12.62,8.2-33.24,6.14-52.02-3.07-41.9-77.78-31.47-114.03-28.99-21.54,2.88-37.88,19.02-43.19,40.12-2.84,13.98-4.55,36.58,10.84,43.19,8.6,4,21.41-2.57,24.09-12.19,1.16-6.18-.1-20.03-.58-26.11-.71-5.9,6.44-5.67,5.86-.1.71,10.39-1.9,21.55,2.21,31.39,3.68,10.54,17.88,12.96,25.92,5.76,11.01-8.2,5.84-28.29,7.01-40.03,1.46-2.64,5.15-2.13,7.01-.1h-.19c1.26,12.97-4.11,30.53,7.01,40.12,11.08,8.7,25.07,2.28,27.36-11.14,0,0-.1-24.76-.1-24.76m-18.43-143.4c-5.47,12.61-7.58,13.09-7.01,17.85l.58-.1v-.38c64.9-65.28,104.61-6.53,177.28-22.08-5.12-7.53-5.21-18.59-4.13-27.55,4.6-1.13,1.62,2.86,1.82,5.85.12,6.78.35,15.84,5.18,20.93.83-.26.1.1.1.1,20.17,26.14,55.37,20.23,68.25-9.79,5.93-15.28,3.61-44.77-18.72-42.62-15.78-1.06-30.92,4.21-47.03,2.4-64.37-15.42-142.41-6.61-176.32,55.39M160.12,7.97C-17.74,62.21-69.08,370.46,138.53,424.26l-9.41-4.32c2.11-6.14,4.22-12.29,6.33-18.43-92.51-58.72-102.12-224.9-5.28-280.76,19.54-10.9,61.56-19.46,67.29,7.2-.62,14.86-20.8,20.17-33.12,16.8l-.48,1.54c31.8,21.92,74.81,6.62,104.62-13.24,42.89-26.56,43.68-88.53,3.07-116.91C239.63-5.74,196.6-2.13,160.12,7.97Z"
    }, null, -1)),
    Ave = [Sve, wve],
    Ove = {
        key: 8
    },
    Cve = Ot(() => U("path", {
        class: "body",
        d: "m427.34,191.3c-169.76-133.72-259.43,94.21-298.61,228.64,76.87,34.7,175.82,33.8,252.73,1.35,85.67-37.55,106.25-162.22,45.88-229.99"
    }, null, -1)),
    kve = Ot(() => U("path", {
        class: "feathers",
        d: "m53.77,206.95c-14.84,11.47-32.03,24.91-37.15,42.14,0,.58.1,1.12.29,1.63,17.91-9.5,38.82-6.5,17.66,14.88-90.52,75.1,23.6,135.74,94.16,154.35,1.54-4.54,3.1-9.09,4.7-13.63-70.15-39.32-.62-99.2,24-144.55,40.99-85.66-48.79-97.97-103.67-54.81M372.82,65.37c-18.71-5.95-30.65,16.2-34.36,30.91-2.13,14.27.12,19.63,6.53,38.78-21.17-33.93-55.37-11.29-43.96,21.79,11.6,26.94,38.47,44.71,60.95,61.72,7.44,4.27,15.13,13.57,24.28,9.6,1.15.77,4.61-3.36,10.37-12.38,13.2-21.74,24.77-40.42,32.64-63.83,9.14-28.96-14.31-65.94-31.39-18.62.1-23.91,1.51-57.98-25.05-67.96Z"
    }, null, -1)),
    Ive = Ot(() => U("path", {
        class: "feathers top",
        d: "m245.82,340.95c5.44-5,6.11-7.18,10.65-11.71,5.58,2.14-19.15,22.58-22.75,28.41-1.48,1.41-35.64,41.3-36.67,40.99,223.36-26.37-65.09-269.62-50.87-27.36,14.51-32.07,31.31-54.8,58.07-77.75l2.3.58c-23.88,20.74-44.08,47.68-60.18,79.57,1.38,7.84,1.25,17.4,5.76,23.61,12.88,4.69,26.95,2.53,43.87,1.44,10.38-14.71,37.56-42.46,49.82-57.78"
    }, null, -1)),
    Nve = [Cve, kve, Ive],
    xve = {
        key: 9
    },
    Pve = Ot(() => U("path", {
        class: "body",
        d: "m427.34,191.3c-31.47-32.8-78.21-44.55-122.57-35.13-107.61,20.57-142.69,175.09-176.04,263.77,40.53,20.16,86.68,26.16,131.6,24.48,40.59-.35,85.58-5.03,121.13-23.13,85.67-37.54,106.25-162.21,45.88-229.98"
    }, null, -1)),
    Rve = Ot(() => U("path", {
        class: "feathers",
        d: "m152.25,296.79l.1-.48-.1-.19.19-.19-60.95,5.18c-.55.67,36.59,103.62,36.57,104.34-.38-.86-44.88-99.04-45.21-99.83l-48.47,37.15c-.54.91,94.93,74.25,95.12,74.87,10.52-18.22,19.47-99.49,22.75-120.85m92.15-5.47l-.48-.29-88.11,50.97-6.05,3.46v.1h-.29c21.05,12.82,72.74,44.28,93.11,56.73h.38l1.44-110.96m115.57-190.34c-.1-21.6-29.46-29.99-44.15-16.7-7.52,7.49-21.91,24.83-18.05,33.88l.96-.19c.06-.19.16-.38.29-.58,0-.06.06-.1.19-.1,4.17-9.11,12.59-17.97,23.13-18.72,7.76.07,13.21,9.5,9.21,16.22-6.02,13.51-21.52,6.14-31.48,4.7-2.95,1.02-7.64-.17-10.65,1.06h.77c-8.92,1.79-12.56,5.87-20.54,6.34-10.25.77-19.94-11.87-11.61-20.25,0-.06.03-.1.1-.1,10.51-6.97,24.71,3.65,31,12.19h1.06c2.06-7.6-9.77-17.59-17.28-24.38-14.86-14.78-42.09-8.82-47.32,11.71-4.32,33.31,36.57,48.46,59.41,28.32l3.26,26.01c6.33-2.13,13-3.72,19.68-4.9l-1.92-23.04c22.25,12.91,57.49-2.85,53.94-31.48Z"
    }, null, -1)),
    Mve = Ot(() => U("path", {
        class: "feathers top",
        d: "m74.89,281.05c-47.97-52.91-107.51,40.7-40.22,62.39l-.29-.29v-.38l48.47-37.15c.02.24.25.67.38.86.38-9.34-2.4-17.82-8.35-25.44m74.48,64.41c-.06.06-.1.13-.1.19-.13,0-.16.06-.1.19-12.81,22.8,14.73,40.89,30.24,19.29-11.83,24.16,16.97,39.93,31.39,17.76-.1-.1-61.38-37.3-61.43-37.43m-4.51-101.27c-38.78-30.78-87.09,21.68-53.37,57.69-.09-.2-.09-.57,0-.77l60.95-5.18-.19.19.1.19-.1.48c11.51-16.08,8.25-40.4-7.39-52.6m96.37,158.86c.33-.37.51-.82.77-1.15l-30.81-18.72v.1c-.13,0-.16.06-.1.19-12.89,22.44,14.76,40.75,30.14,19.58Z"
    }, null, -1)),
    Dve = [Pve, Rve, Mve],
    $ve = {
        key: 10
    },
    Lve = Ot(() => U("path", {
        class: "body",
        d: "m304.87,156.08c-94.26,18.24-129.7,135.36-159.05,214.34-28.49-43.69-51.63-89.82-71.56-136.34l-2.44.81c-18.73,13.21-35.38,31.72-44.06,53.18.1.19,21.13,22.6,21.12,22.84h-.1l-.1.1c26.15,27.64,55.01,56.67,88.69,83.89-2.91,8.36-5.8,16.69-8.64,25.05,54.48,27.37,117.77,27.38,177.19,21.98,46.2-4.96,90.89-20.74,121.42-55.19,79.89-98.68,16.6-258.5-122.48-230.65"
    }, null, -1)),
    Fve = Ot(() => U("path", {
        class: "feathers",
        d: "m89.04,403.38c17.26,7.98,27.6,12.45,40.99,16.7,2.75-8.06,5.54-16.13,8.35-24.19-33.66-27.2-62.56-56.27-88.69-83.89l.1-.1h.1l-.1-.19c-11.15,15.21-30.54,39.24-29.37,50.97,17.33,15.15,44.04,29.03,68.63,40.7m42.04-156.07c-.32-.96-.8-1.5-1.44-1.63l-.1-.48c-13.48,6.6-26.19,14.97-39.35,25.92,14.37,31.47,36.86,69.44,56.63,100.31,3.77-10.75,7.38-21.51,11.33-32.16-8.28-29.01-17.06-65.48-27.07-91.95m115.05,122.25c6.13-36.91-27.08-33.22-39.16-6.72,8.07-48.16-29.3-25.38-46.75-1.06-26.41,72.58,4.08,65.57,45.31,7.1-.28,4.96-6.81,27.18-2.78,30.81,12.53,6.73,35.55-20.75,43.39-30.14m135.43-254.8c2.95-43.91-102.06-29.37-125.26-13.73-6.2,3.41-13.67,9.14-11.33,17.38,3.07,20.6,5.14,41.44,6.05,62.49,35.81-27.95,90.1-34.1,131.69-18.24.38-15.93,0-31.9-1.15-47.9Z"
    }, null, -1)),
    Uve = Ot(() => U("path", {
        class: "feathers top",
        d: "m260,343.38c16.26-30.58-6.86-74.89-43.87-57.49-29.05,14.9-44.25,46-56.92,76.88,8-11.73,35.66-38.3,46.36-22.56,1.26,3.73,1.06,20.48.38,23.61,12.12-26.55,45.3-30.14,39.16,6.72,6.13-8.51,11.06-17.36,14.88-27.16"
    }, null, -1)),
    Bve = [Lve, Fve, Uve],
    qve = {
        key: 11
    },
    Gve = Ot(() => U("path", {
        class: "body",
        d: "m304.87,155.69c-85.74,16.74-119.78,111.87-148.39,183.91-6.33,17.8-12.45,35.72-18.62,53.56-8.48,14.16-18.75,34.65-27.55,47.8-24.06,34.26,7.13,7.01,18.14,1.25.64,1.76-28.12,58.72-21.79,57.88,16.92-11.3,32.49-32.36,46.46-46.55,1.4,2.36,3.01,27.01,7.77,25.44,8.99-13.85,14.43-30.22,19.77-41.47,59.1,12.05,146.8,10.1,200.8-16.6,138.74-67.15,89.2-299.08-76.6-265.21"
    }, null, -1)),
    Vve = Ot(() => U("path", {
        class: "eyes emo",
        d: "m439.63,242.46c1.85-14.67-22.74-14.91-22.75,0,0,7.63,20.64,16.7,22.75,0Zm-129.77,5.57c0,14.91,23.17,14.78,22.75,0-.45-15.75-22.75-14.32-22.75,0Z"
    }, null, -1)),
    jve = Ot(() => U("path", {
        class: "feathers",
        d: "m276.74,343.92c1.35-1.72,1.91-2.45,1.63-3.94-9.73,4.74-23.71,12.96-41.95,24.67,2.97-3.38,2.62-21.3,5.28-24.86l-29.76,11.04c-2.3.75,10.79-26.92,8.93-26.2l-19.48,1.63,12.86-27.93-.1.48c.79-2.14,1.71-4.69,2.5-6.43-24.13,17.33-45.57,41.59-65.56,62.58v.1c-4.15,6.18,37.59-10.12,38.01-9.21-59.33,95.27-48.45,72.61,30.72,23.61.19,19.01.13,30.52-.19,34.55-.06,4.03.42,5.57,1.44,4.61,18.29-22.35,35.51-39.67,55.67-64.69m115.85-160.58c-.9-.7-.64.35.77,3.17,1.81,3.02,7.33,19.65,9.02,27.07-16.92-11.48-36.93-27.72-53.66-36.28,1.87,3.82,7.79,24.53,8.73,25.34-10.82-5.54-26.29-13.25-35.8-13.53-.26,0-.48.03-.67.1.26.19.54.35.86.48v.1c18.92,11.21,36.79,24.41,53.56,39.16,3.46.81-10.11-24.38-9.79-25.15,21.98,14.47,41.22,33.92,60.76,50.97,2.53-1.85-2.32-13.06-3.74-20.35-.13,0-.64-1.86-.58-1.92-1.79-6.21-3.74-12.32-5.86-18.33,9.02,5.12,17.63,10.24,25.82,15.36,4.88,2.35,1.92-4.41.19-7.1-6.54-12.54-19.62-35.37-33.21-40.31,3.14,4.03,8.06,11.68,14.78,22.94-6.85-6.33-23.64-16.66-31.2-21.69Z"
    }, null, -1)),
    Wve = [Gve, Vve, jve],
    Hve = {
        key: 12
    },
    Yve = Ot(() => U("path", {
        class: "body",
        d: "m402.51,289.92c0,89.27-38.24,154.39-125.03,154.39s-125.03-65.11-125.03-154.39,51.05-172.02,125.03-172.02,125.03,82.74,125.03,172.02Z"
    }, null, -1)),
    zve = Ot(() => U("path", {
        class: "feathers",
        d: "m236.37,386.86c0,6.79-5.51,12.3-12.3,12.3s-12.3-5.51-12.3-12.3,5.51-12.3,12.3-12.3,12.3,5.51,12.3,12.3Zm-44.51-59.29c-9.06,0-16.4,7.34-16.4,16.4s7.34,16.4,16.4,16.4,16.4-7.34,16.4-16.4-7.34-16.4-16.4-16.4Zm158.83,25.17c-5.13,0-9.28,4.16-9.28,9.28s4.16,9.28,9.28,9.28,9.28-4.16,9.28-9.28-4.16-9.28-9.28-9.28Zm-43.44,46.42c-7.74,0-14.01,6.27-14.01,14.01s6.27,14.01,14.01,14.01,14.01-6.27,14.01-14.01-6.27-14.01-14.01-14.01Zm-63.48-115.75c-5.47,0-9.91,4.44-9.91,9.91s4.44,9.91,9.91,9.91,9.91-4.44,9.91-9.91-4.44-9.91-9.91-9.91Zm53.57,35.27c-8.5,0-15.38,6.89-15.38,15.38s6.89,15.38,15.38,15.38,15.38-6.89,15.38-15.38-6.89-15.38-15.38-15.38Zm-106.49-45.59c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm17.41-101.68c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm62.43,244.03c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm52.32-122.12c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm-66.44,63.85c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm25.37-109.33c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm30.77-112.84c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Z"
    }, null, -1)),
    Kve = [Yve, zve],
    Zve = Ot(() => U("path", {
        class: "eyes",
        d: "m439.63,242.46c.33-14.78-23.12-14.9-22.75,0-.4,14.8,23.1,14.68,22.75,0Zm-129.77,5.57c0,14.91,23.17,14.78,22.75,0-.45-15.75-22.75-14.32-22.75,0Z"
    }, null, -1)),
    Xve = Ot(() => U("path", {
        class: "beak",
        d: "m345.85,298.42c5.42,46.48,82.83,42.85,88.98-.77l4.13-2.88c2.94-.32,4.77-1.09,5.47-2.3.17-15.23-11.4-29.2-23.04-37.82-30.82-20.14-79.86,6.01-75.54,43.77Z"
    }, null, -1)),
    Qve = Ot(() => U("path", {
        class: "mouth",
        d: "m437.81,295.45l.19-.19h.19c-1.11-1.38-107.2-1.04-91.76,3.36,24.28.89,66.94-1.43,89.17-1.34-.1-.42.77-.8,1.06-.96.32-.35.56-.69.96-.67.06-.13.13-.19.19-.19Z"
    }, null, -1));

function Jve(t, e, n, r, s, i) {
    return B(), H("svg", {
        viewBox: "0 0 500 500",
        class: nt(["avatar", `avatar-${t.avatar}`])
    }, [j0e, U("g", W0e, [t.avatar === 0 ? (B(), H("g", H0e, K0e)) : t.avatar === 1 ? (B(), H("g", Z0e, J0e)) : t.avatar === 2 ? (B(), H("g", eve, sve)) : t.avatar === 3 ? (B(), H("g", ive, cve)) : t.avatar === 4 ? (B(), H("g", lve, dve)) : t.avatar === 5 ? (B(), H("g", pve, _ve)) : t.avatar === 6 ? (B(), H("g", yve, Eve)) : t.avatar === 7 ? (B(), H("g", Tve, Ave)) : t.avatar === 8 ? (B(), H("g", Ove, Nve)) : t.avatar === 9 ? (B(), H("g", xve, Dve)) : t.avatar === 10 ? (B(), H("g", $ve, Bve)) : t.avatar === 11 ? (B(), H("g", qve, Wve)) : t.avatar === 99 ? (B(), H("g", Hve, Kve)) : Pe("", !0), Zve, Xve, Qve])], 2)
}
const K3 = He(V0e, [
        ["render", Jve],
        ["__scopeId", "data-v-762a6505"]
    ]),
    e2e = {},
    t2e = {
        viewBox: "0 0 100 100"
    },
    n2e = U("path", {
        d: "m50,0C22.39,0,0,22.39,0,50s22.39,50,50,50,50-22.39,50-50S77.61,0,50,0Zm17.31,72.45c-12.4,0-22.45-10.05-22.45-22.45-.4-16.04-23.92-16.03-24.32,0,0,6.72,5.44,12.16,12.16,12.16,3.13.17,6.82-1.94,9.58-3.07l4.12,9.43-4.72,2.06c-14.3,6.59-31.81-4.71-31.44-20.58.76-29.62,44.16-29.61,44.91,0,0,6.72,5.44,12.16,12.16,12.16,16.03-.4,16.04-23.92,0-24.32-3.44-.2-7.13,2.2-10.06,3.61l-4.64-9.19,4.59-2.32c14.32-7.64,32.98,3.68,32.56,20.06,0,12.4-10.05,22.45-22.45,22.45Z"
    }, null, -1),
    r2e = [n2e];

function s2e(t, e) {
    return B(), H("svg", t2e, r2e)
}
const i2e = He(e2e, [
        ["render", s2e]
    ]),
    o2e = st({
        props: {
            category: {
                type: String,
                required: !0
            },
            slug: {
                type: String,
                required: !0
            }
        },
        computed: {
            categoryClass() {
                return ur.categorySlugByKey(this.category)
            },
            icon() {
                return ur.instrumentIconBySlug(this.slug)
            }
        }
    });
const a2e = {
        key: 0,
        d: "m133.26,90.5v-6.5l-3.48,3,3.48,3.5ZM31.33,45l2.48,10,21.38-3,1.83,10.32-15.25,2.68v7l16.25-4.09,1.76,9.96-15.03,6.13,2.99,5.5,13.08-5.8,2.05,11.59-13.15,5.21v6.5l14.56-3.75,1.59,8.93-14.65,5.32,3.97,4.5,11.83-3.34,2.1,11.84-19.4,2.5v11.5l35.8-5.5-16.4-101-37.79,7Zm97.95,61.5l-4.97,1,3.48,5,1.49-6Zm-5.47,15l1-4.5h-4.98l3.98,4.5Zm-17.9-78.5l-6.96-5.5-6.96,7.5-6.46-7.5-3.49,10.5-8.95-10.5,14.92,100h10.94l15.41-100-8.45,5.5Zm18.4,51l3.48,5.5.99-7-4.47,1.5Zm12.93-24v-6.5l-3.98,3,3.98,3.5Zm-19.4-33l-16.4,100,28.34,6,1.99-14.5-13.93-3-1.98-5.5,11.93-63,15.91,2.5,2.49-16-28.35-6.5Zm13.93,36l-3.98,1.5,1.99,4.5,1.99-6Z"
    },
    c2e = {
        key: 1,
        d: "m50.02,96.74c-9.78,14.26-8.34,12.27-11.63,28.91l8.67,14.46c19.13,9.82,13.79,7.23,34.67,6.38,12.67-17.79,9.85-12.43,11.71-33.8l-8.09-11.34,37.99-54.99,20.35-10.35-2.38-7.09-21.07,4.93c1.61,2.1-39.98,58.25-41.69,61.16l-13.11-2.51-15.43,4.25Zm5.15,22.49l14.43,9.49-1.26,2.02-14.63-9.97,1.46-1.54Z"
    },
    l2e = {
        key: 2,
        d: "m75.08,94.5l7.46,27-3.98,20,4.48,5.5c29.34-4.44,22.28-1.44,45.81-19.43l-5.36-3.05c-16.08,14.36-11,11.24-31.87,15.48l-4.11-1.5c6.34-7.33,31.58-25.87,40.03-31.25l.07.02,11.62-3.27-3.31,5.66,4.44,1.27,4.33-8.93-5.46-7c-24.07-3.71-19.08-2.07-38.79-16l-9.94,3-20.89-37-11.93-10-5.97,4,5.97,15,24.36,33-6.96,7.5Zm43.51,22.75l8.52,7.63h9.32l3.73-6-4.97-6.88-7.9-2.01-8.7,7.25Z"
    },
    u2e = {
        key: 3,
        d: "m132.57,76.01l-25.44-2.48-16.94,6.13-.28,6.44,3.78,2.72,2.43,29.39,10.85,6.26,19.77.04,10.59-4.49,5.25-27.93,3.81-2.39.28-6.44-14.1-7.27Zm1.14,14.03l-29.64-2.07-12.34-4.55,2.47-3.31,17.28-4.14,22.23,2.48,9.46,4.97,1.24,2.9-10.7,3.72Zm-41.67-.83l-5.15.62-.62,20.18,6.9.21-1.13-21Zm-3.56-17.17l-16.66-4.23-27.99,2.48-14.82,8.64.5,5.36,3.88,1.71,11.24,34.64,25.34,1.36,13.94-5.06,2.54-35.56,3.91-2.45-1.88-6.89Zm-11.57,8.89l-23.87,1.66-19.76-1.66,1.24-3.31,11.93-5.38,21.41-2.07,16.87,2.07,1.23,3.31-9.05,5.38Z"
    },
    h2e = {
        key: 4,
        d: "m29.59,66.75l11.43-16.25,9.7,1.5,4.39,5.04,72.21,14.49,17.97,10.05,5.27,15.65,6.41-.69,1.39,9.29-4.78,7.08-5.14-3.87-12.31,14.71-.62-.04c3.83-22.49,4.86-17.09-2.31-39l-17.63-9.29-19.05,6.97-10.35,20.74-.54,5.03-36.01-16.86-6.8,2.83-10.25-3.12-2.98-24.25Zm6.06,3.21l5.02-8.27,5.74.89,1.81,10.41-5.1,10.33-6.63-1.65-.84-11.71Zm79.4,9.62l-16.94,6.2-9.21,18.44-1.93,18.18,6.42,19.46,17.11,5.35,12.56-6.99c11.21-17.73,9.44-15.71,12.82-35.87,0,0-5.15-16.52-5.15-16.52l-15.68-8.26Zm1.2,27.17l5.5,4.5-.5,5.12-6,3.75-3.38-3.12.38-7.12,4-3.12Zm-55.75,12.25l2.33-19.27,20.61,10.96.06,10.45,2.17,9.57-8.17,8.79-11.5-2.5-5.5-18Z"
    },
    f2e = {
        key: 5,
        d: "m14.42,68l29.84,16.5,40.27-18,3.98-5,8.45,1.5v5c-6.73-.76-44.79,14.24-51.71,16.5l46.24,20.5,75.08-37c-98.08-29.69-54.24-29.58-152.15,0Zm38.79,48.5v-25.5l38.28,17.5,37.79-17.5-.5,25.5-12.92,10-26.36,4-26.35-4-9.94-10Zm-8.95-6.5l.99-17.5,1.49,17.5,2.98,6.5c0,4.48,0,13.52,0,18l-2.98,2.5-4.47-2.5v-15.5l1.99-9Z"
    },
    d2e = {
        key: 6,
        d: "m30.83,94l2.98,17.5s31.33,9,31.33,9c13.04-1.38,71.3-7.16,83.04-9-3.24-11.77-13.91-43.99-17.9-56l-55.2,1-13.67,33-30.58,4.5Zm36.8-4.75l10.44-27.5,15.91.25.99,29-27.34-1.75Zm31.57-26.75l1.49,28.25,16.41-.75-4.97-28.25-12.93.75Zm-62.9,45l-1.24-7.75,7.46.25,1.49,8.75-7.71-1.25Zm19.39-3.75l-.25,8,8.46,2.25.99-9-9.2-1.25Zm23.5,27.25l-8.08-7.47,24.24-2.28-3.88,8.77-12.28.98Zm45.59-5.75l-10.59-6.47,24.21-2.28-5.29,8.75h-8.33Zm-73.53-2l-7-6.75,16.25,4.5-.75,2.25h-8.5Zm8.75-85.75l10.62,11.25,3.38-3.88-7.62-13.25-6.38,5.88Zm23-6.25l-.5,13.75,5,1.75,5-15-9.5-.5Zm-35.12,22.38l13.62,4.25-1.25,5.38h-13.5l1.13-9.62Z"
    },
    p2e = {
        key: 7,
        d: "m82.99,54.23l21.42,11.23,22.46-.56-9.98,20.99,12.22,25.6-15.17,25.32-28.93,2.12-22.78-23.59,4.42-26.34,19.74-12.76-3.39-22Zm-5.89,3.17l-6.19-5.03,4.28,21.41-21.01,9.99-5.87,29.42,15.32,19.83,8.34.35-15.61-19.83,4.57-24.97,19.74-12.76-3.57-18.41Zm35.67,16.35l-15.31-3.69-1.32,6.07,13.2,2.64,3.43-5.01Zm6.07-23.23l-7.13,12.93,6.6-.79,6.07-13.46-7.13-12.4-15.57-2.38-2.11-2.64,3.17-2.64v-7.39l-9.24,7.92,4.22,9.24,15.31,1.85,5.81,9.77Z"
    },
    m2e = {
        key: 8,
        d: "m64.14,43.5l-3.73-.07-6.59,28.61c-4.93,9.4-12.05,29.78-14.79,40.09l21.38,20.5,22.87,9.25,28.59-5c18.42-13.39,16.58-9.78,28.09-30l-16.21-31.86-7.16-30.76-4.24.92-15.4,27.08-15.66-.05-17.15-28.7Zm1.74,54l-7.23-4.51,5.85,6.11,11.67.72,6.82-5.87c-8.8,4.39-7.3,4.13-17.12,3.55Zm38.78.62l-8.74-3.93,7.49,5.05,10.58-.71,3.83-5.43c-6.01,4.93-5.87,3.92-13.17,5.01Zm24.33,23.38l-17,13.5-28,4-24-10-16-16.5,1.5-12.5,24,5,10-1.5,1.5,2.77,4-.77,7-16,7,16,4,1.5,16-3.5,14-5.5,3.5,11-7.5,12.5Zm-44.02-14.13l6.12,5.12,5.58-5.64-6.69-1.38-5.01,1.9Zm4.52-.87l-.5,1.5.5,1.5,2-2.5-2-.5Zm3.27,10.99l-11.26,5.15,1.73,6.99,12.94.5,7.7-7.36-4.07-1.93-1.67,5.08-2-6.82-3.37-1.6Zm46.01-71.99l19.35,6.14-.89,8.23-16.37-6.43-1.19,23.94-11.16-1.65-1.34-6.58,5.06-2.24,4.76,2.69,1.79-24.09Z"
    },
    g2e = {
        key: 9,
        d: "m54.42,82l17.09-8.36,4.31-28.79-6.41.37.49-5.37,6.31,2.45.82-5.49-6.91-1.07v-3.04l7.27,1.7.7-4.7-3.54-5.13,7.35-5.81,4.95,9.54-3.28,1.94-.13,2.1,7.24-1.44-.65,5.61-6.75-1.57-.35,5.58,6.71,1.08-.12,2.14-6.73-.94-2.07,32.76,11.21,5.89c-.03,5.83.22,19.51,1.68,25.06l-7.61,1-2.21,7.95,2.17,8.39,5.3,2.04,2.52,18.1-15.5,13.55-29.83-3.22-7.57-15.34,4.11-17.95,8.09-.45,4.25-7.62-.56-6.84-6.82-3.19,3.03-6.74,1.44-14.19Zm51.26-62.46l24.53,126.48,1.73,7-2.29.74-1.35-6.59-3.23.52c-5.27-32.39-18.1-98.27-25.05-130.53l5.66,2.38Z"
    },
    _2e = {
        key: 10,
        d: "m106.06,119.81l9.01,1.85V32.23h-5.41l-3.6,87.58Zm-42.78-.41h5.63l3.38-87.17h-5.07l-3.94,87.17Zm12.79,24.27l3.04,9.82,10.96,5.53,10.35-3.68,2.44-9.82-6.09-9.82-6.7-3.68-7.31,3.68-6.69,7.98Zm7.48-110.31h-5.41l-3.6,84.91,6.6-4.31,2.41-80.6Zm10.85-14.71l.26-8.73-1.9-.51-.29,8.8-.47-.11-26.79,2.46-3.04,4.3v2.46l29.96,1.23-.23,7.08h-1.36l-3.61,83.54,2.17,1.64-.33,9.98,1.31,1.23v-.53s1,.53,1,.53l.28-9.5.38.29,4.2-87.17h-2.03l.21-6.99,27.72,1.14v-4.91l-27.42-6.21Zm6.36,102.2l4.18-88.62h-5.37l-4.77,91.7,5.96-3.08Z"
    },
    y2e = {
        key: 11,
        d: "m93.05,35.53l-26.08,4.92-24.45,21.86-5.98,10.38v44.26l17.93,24.04-4.34,11.47-1.63,12.57h5.97l9.78-18.58,14.13,6.01,23.91,1.09,18.47-7.1,11.96,18.58h4.89l-3.26-17.48-3.8-6.56,16.3-22.95,2.71-8.74-1.08-31.69-21.74-30.6-33.69-11.47Zm0,9.29l-22.82,2.73-22.28,23.5-2.72,41.53,16.85,22.95,16.84,8.2h22.83l20.64-8.2,17.94-25.68v-27.87l-17.94-27.32-29.34-9.84Zm-43.06-.95l-18.1,14.83-4.39-8.79,9.32-21.42,13.17-5.49,15.91,5.49-15.91,15.38Zm75.7-19.22l-6.59,5.49,14.81,15.38,20.3,13.18,3.29-16.48-8.23-13.73-11.52-5.49-12.06,1.65Zm-26.62,71.6l.43,1.75h-4.57l-3.43-4.31,2.26-.97-7.57-31.82,2.74-8.24,3.3,8.79,2,31.07,3.56-1.52,1.06,4.36,28.48-.95,1.65,6.59-29.91-4.75Z"
    },
    v2e = {
        key: 12,
        d: "m69.49,164.56l-2.31-27.52-2.31-11.71,20.24,14.05,8.09-2.34-3.47-11.71,25.44,5.27v-11.71h7.52l-7.52,48.6-35.85,3.51-9.83-6.44Zm36.42-51.53h16.77l5.2-38.65-18.5,4.68-30.06,1.76-18.5-4.1,2.89,37.48,22.55,20.49-5.2-17.57,28.33,8.2-3.47-12.3Zm-4.05-96.03l-8.09,2.34-6.36,48.6,5.2,1.17,6.94-2.93,2.31-49.19Zm-34.69,44.5l20.24-2.93-2.31,9.96,8.09,2.93,8.67-2.93v-9.96h7.52l18.5,4.68,2.89,5.27-27.17,8.2h-30.64l-16.77-5.27v-4.68l10.98-5.27Z"
    },
    b2e = {
        key: 13,
        d: "m103.54,79.14c3.75,3.75,11.61,11.66,15.29,15.38l11.94.36,9.82,13.88,9.57,5-5.34,5.75-20.01-1.12-6.72-5.88,5.58,10.88-32.68,16.37c-1.75-8.83-25.23-46.98-29.95-55.38l.3-2.46,3.06,1.23,3.1-2.64-.35,3.56,8.26,4.61-9.79-17.22,3.67-14.45,26.91,23.37,7.34-1.23Zm29.36,51.05l-5.51-6.77-39.9,20.76,2.6,7.07,42.81-21.06Zm-35.1-37.51l-3.61-7.63,1.75,9.66,8.79,1.81-6.94-3.84ZM49.28,25.5l19.34,6.14-.89,8.23-16.37-6.43-1.19,23.94-11.16-1.65-1.34-6.58,5.06-2.24,4.76,2.69,1.79-24.09Z"
    },
    E2e = {
        key: 14,
        d: "m113.21,105.67l-4.54-.06,5.71,9.53-5.6,23.65-17.92,11.54-22.84-.93-16.36-9.49-5.6-21.68,11.21-21.12,3.47-1.71-2.96-29.46-37.82,3.08,24.42-8.18,12.03-8.52-.44-4.41,3.05-.51.51,4.37,10.79,4.97,24.92,6.14-34.09,2.78,3.25,27.93,7.19-3.54h17.81l14.36,7.33,1.94,3.23-.1-20.53,8.51-2.69,19.61-1.13,12.57,2.28v26.08l-33.07,1.02Zm-4.47,10.31l-8.87-14.8c-15.87-6.89-12.89-5.43-29.73-4.94-14.28,9.12-10.25,6.71-18.14,21.11l4.41,19.31,11.92,6.75,19.69,1.3,15.81-10.16,4.92-18.56Zm2.14,28.49l5.08-1.02,9.16-13.3,13.74,13.3,6.1-1.02-16.79-15.86-1.01-18.92h-3.56l1.01,16.37-13.73,20.46Zm4.91-65.65l20.44-.28,6.99,2.82-11.76,2.82h-14.56l-8.95-2.53,7.84-2.82Zm-25.77-47.02l.56-3.38,3.09.56c-1.83,1.31,33.13,29.7,33.88,30.69l-.56,2.53c-4.8.07-32.55-30.02-36.96-30.41Zm-11.19,91.5l-1.4,14.08,9.8-18.3-5.05-.28,5.33-11.26h-11.49l-3.36,16.05,6.16-.28Z"
    },
    T2e = {
        key: 15,
        d: "m59.98,48.46l-21.27-4.71,3.62,10.7-7.02-3.42,4.89,14.33,13.25,21.15,9.7,26c.76-3.14,2.82-11.61,3.98-14.5,3.09,1.02,24.47,12.74,27.87,14.52,0,0,25.33,8.98,25.33,8.98l1.26,15.83,2.98,11.98,5.96-23.32,22.12-5.99c-5.01-1.18-19.81-4.72-24.68-5.35l-14.25-26.53-14.25-16.26,5.53-4.07,12.76-5.56-32.33-.43-11.59-8.32-13.86-5.04Zm-3.82,5.6l-5.11.43,1.91,4.49,4.68-.21-1.48-4.71Z"
    },
    S2e = {
        key: 16,
        d: "m142.26,31l-9.2,7.2-3.58-2.6-15.31,15.45,3.08,2.55-12.78,11.3.7,8.75-7.86-.5-7.16,6.65.45,7.95-8.1-.75-6.66,7.2.15,8.05-9.35-.85-7.66,7.7.2,8.2-7.36-.5-21.48,23.15,9.2,8.2L124.41,60.8l4.57,2.05,20.93-26.2-7.66-5.65Z"
    },
    w2e = {
        key: 17,
        d: "m146.68,31.5v-4.5l-37.79,7-35.8,15.5,3.48,3.5,13.92,2,15.91,13.5,8.45,19,.99,31.5-9.45,15,2.49-18.5-10.44-1.5-1.99,24h-9.45l9.45-42-10.94-2.5-10.94,44.5-4.97-4,6.96-31h-8.95l-5.97,23.5-5.97-6,5.97-24.5,11.44-8.5h23.37l12.43,8.5v-10l-4.47-6-25.85-4.5-26.35,14.5-5.97,32,21.38,28.5,28.84,2.5,9.94-4.5,21.88-29.5v-50.5l3.98-23.5,14.42-13.5Zm-102.43,96.5l-13.92-9c-5.15,5.43-4.51,4.8-5.97,12l27.84,8.5-7.96-11.5Z"
    },
    A2e = {
        key: 18,
        d: "m28.16,121.11c1.64-.98,38.97-20.47,39.27-21.24l.78-4.99,4.57-3.14,5.66,3.02,1.33,6.05h0s-6.01,4.69-6.01,4.69l-4.97-3.16c-3.33,1.67-35.28,19.04-39.4,21.24l-1.22-2.46Zm15.95-3.22l-.76,24.99h8.08l.77-29.36-8.09,4.37Zm97.84-67.95h-8.07l5.06,93.16-7.69.39-5.84-93.93-12.24.09-1.7,23.42,8.11,4.18,5.47,23.75-7.45,23.25-24.87,11.5-24.86-6.75-10.13-18.48c1.6-.86,9.49-5.15,10.95-5.88l5.19,3.3,8.11-6.34-1.81-8.17-7.54-4.03-6.27,4.3-.78,4.97c-1.38,1.04-6.45,3.67-8.05,4.52l.88-15.45,10.19-15.25,3.34-1.03-.55-21.5-17.54.13-1.47,55.84-8.05,4.29,1.83-59.74h-7.69l-6.15-11.22,113.87.23-4.24,10.44Zm-30.79-.28l-37.75.29.54,20.9,14.07-4.35h10.69l10.84,5.58,1.63-22.41Z"
    },
    O2e = {
        key: 19,
        d: "m138.73,54.23c5.47-6.87,7.69-10.3,6.66-10.3l-12.78-10.75-33.21,37-23.02-6.7-12.29,19.55-32.66,14.9-2.59,23.1,23.02,23.15,25.01,1.55,15.86-32.9,20.44-16.45-5.12-19.55,25.06-28.75,5.62,6.15Zm-54.55,30.45c3.58-.17,5.59-.03,6.02.4l2.04,10.25-7.16,5.65-8.21-6.15,2.04-9.75c1.73-.17,3.48-.3,5.27-.4Z"
    },
    C2e = {
        key: 20,
        d: "m96.84,137.12l.5,10.62,26.23-9.42c-.41-5.47,1.42-19.51,2.24-25.07,0,0-3.98-19.97-3.98-19.97,0,0-9.94-22.52-9.94-22.52l-3.48.21c1.23,4.98,5.29,19.7,6.71,24.86-2.89-7.91-10.06-23.22-14.17-30.59l-4.48,1.27,10.19,31.87-13.67-27.83-4.47.64.5,11.47,5.47,15.72c.94,4,1.99,13.09,2.36,17.23l-4.23-8.62-5.84-6.91-5.97,1.06c2.05,5,4.12,17.79,4.85,23.22l11.19,12.75Zm-38.91-36.19l2.98,7.22c1.38-7.94,3.17-24.29,2.98-32.29l4.72-.43c1.66,5.98,1.63,21.33,1.49,27.62l2.98-29.32,4.72.85.5,22.52,1.99-16.99,3.73,1.06-.25,17.63-6.46,1.91,3.23,8.07,1.49,18.06,3.73,2.97-1.24,11.05h-22.62c4.07-15.03,2.83-8.51-8.45-21.67l-1.49-14.45-3.48-5.52,4.47-2.55,4.97,4.25Zm1.24-55.44l9.7,12.25,2.74-3.5-5.97-12-6.46,3.25Zm21.88-11.25l1.99,15,5.47-.75.25-14.25h-7.71Zm23.12,7.5l-2.98,8,3.23,1.5,3.98-7.25-4.23-2.25Zm-18.15,48.12l-.87,8.5,2.11.38,2.24,2-.25-10.12-3.23-.75Z"
    },
    k2e = {
        key: 21,
        d: "m33.69,105.38l2.49-12,25.35-9.25.13-5.38-4.1-4.25,2.98-3.75,19.02-4.62,16.53.88,4.1,4.38-2.48,2.38v2.62l42.39-8.12,7.45,3.75,2.61,7.75c-12.02,4.91-87.41,37.74-98.07,40.12l-13.93-6.5-4.47-8Zm60.43-33.09l-3.13-2.41-12.68-.51-10.94,2.43-2.74,2.08,6.82,3.21,18.07-1.8,4.6-3Zm-55.71,24.09l12.68,4.25,3.98,7-3.23,8.75-12.43-5-1.99-6.75.99-8.25Z"
    },
    I2e = {
        key: 22,
        d: "m109.89,63.5l-22.87,9-24.86-9-30.83,19.15,16.93,28.14,18.38,8.21,40.28,2.5,22.37-9.35,20.09-25.87v-6.78l-39.48-16Zm-49.67,31.06l-3.16.68-4.29-9.08,8.8,1.59-1.35,6.81Zm13.77,4.31l-4.97.91-3.84-2.27-1.35-9.76,10.38,2.95-.22,8.17Zm14.07,3.4l-10.24-2.48-1.46-9.09,13.65.28-1.95,11.3Zm17.97-4.9l-4.2,4.9-10.01-.52.46-10.32,13.98-2.32-.23,8.26Zm12.31-1.35l-3.88,2.85-6.39-1.22v-9.38l10.83-1.43-.56,9.17Zm5.98-3.16h-2.71l-.9-6.13,7.22-1.82-3.61,7.94Z"
    },
    N2e = {
        key: 23,
        d: "m12.46,108.65l9.4-14.49.8-18.31,21.32-17.01c26-8.68,80.89-27.99,108.45-26.26l-1.35,11.87-41.55,44.71c-5.94,13.24-17.78,39.97-23.55,53.25l-18.5-6.22-3.41-13.39-10.67-5.49-16.66.99-24.28-9.66Zm72.27-52.61l6.52-4.42,6.06,6.67-7.93,3.14-4.65-5.39Zm-12.94.59l-9.73,2.5,5.7,11.7,11.27-2.9.35-7.22-7.59-4.08Zm-21.32,17.01l5.6-8.03,8.51,9.88-9.57,7.4-4.54-9.26Zm-18.52,12.99l2.13-8.78,9.5.85,2.75,10.81-8.71,2.24-5.67-5.13Zm66.24-7.71l-2.65,6.72,7.17-1.84-4.52-4.87Zm17.75-13.89l-4.97,6.22,5.27,1.39-.3-7.6Zm7.54-4.68l7.79-5.84-3.03,9.56-4.76-3.71Z"
    },
    x2e = {
        key: 24,
        d: "m23.56,131.42l18.51-91.04,29.67-25.74,33.96,4.31,11.76,8.16,10.73,28.54-3.15,22.92,8.43,15.77,14.53,15.7-9.31,48.94-12.75-.76,5.82-24.58-13.6-3.26-3.08,19.12-8.64-2.07,4.45-18.79-12.23-2.93-3.94,16.62-8.43.27,4.45-18.79-12.95-3.1-4.45,18.79-7.92-1.9,4.45-18.79-15.11-3.62-4.45,18.79-5.96-3.72,3.94-16.62-7.92-1.9-5.82,24.58-9.15.1-1.85-5.03Z"
    },
    P2e = {
        key: 25,
        d: "m60.17,144l-22.87-13-1.49-16.5,10.94-13,22.38,6.5,66.63,8.5,13.92,12.5-20.39,11.5-69.11,3.5Zm-9.45-61l3.48,12.5,10.94,3,60.66,7,6.96-15-10.44-18.5-17.4-.5-38.78-5-15.41,16.5Zm26.35-35.5l3.48,13.5,28.84,5,8.95-7-11.44-15-17.9-16-11.93,19.5Z"
    },
    R2e = {
        key: 26,
        d: "m77.74,100l-34.1-3.25-17.28-13,.46-1.86,13.08-7.43,29.43-4.18,24.29,5.11,12.15,8.82,1.4,4.64-29.43,11.14Zm26.63-29.71l6.07,4.18,1.87,5.11.93-8.36,44.38-30.64v-3.71l-6.54-1.86-46.71,35.29Zm-84.51,10.29l3.28-7.07,16.87-9.42,30.93-2.83,26.71,6.12,12.18,8.48c.89,1.78,2.19,5.68,2.69,7.62l.12-.08c0,.08-.05.4,0,.47l-.04.03-4.18,50.86-6.56,11.78-34.67,8.95-43.11-11.78-4.69-8.95c0-.65,0-50.72,0-51.36h.07l.4-2.83Zm3.89,4l19.54,14.85c37.75,2.97,29.57,5.77,65.13-8.95.02-2.45-.02-7.41,0-9.9,0,0-1.4-2.83-1.4-2.83l-11.25-8.48-25.77-5.65-29.99,3.77s-14.52,8.48-14.52,8.48l-1.74,8.71Z"
    },
    M2e = {
        key: 27,
        d: "m90.8,24.7l5.32,11.1-53.85,92.05,3.83,18.7,23.52,10.35,21.13-7.5,14.02-27.6,9.35-4.95,11.73,8.2,11.24-9c-1.15-31.16,2.45-23.17-14.52-49.8l-7.96,3.4-3.13,12.75-15.86,7.25-23.77,35.6-11.34,4.25,27.74-54,10.54-5.2-1.29-9.2,9.35-4.9-3.18-7.55,8.05-9.9-10.79-22.75-33.07,4.7c.4.27,1.97,1.85,4.72,4.75l18.2-.75Zm41.82,65.7l-.35,21-5.62,5.65-12.68-21.05c.99-.63,3.88-7.57,8.65-20.8l9.99,15.2Z"
    },
    D2e = {
        key: 28,
        d: "m77.17,127.37l10.11-14.39,5.21,6.77-5.22,12.75-8.47,3.82-1.63-8.95Zm-14.83-68.54l14.88,4.82-.36-13.78-5.26-5.38-17.4-.25-13,9.1-5.4,18.9,8.54,14.31.52-13.82,14.97,3.57,2.51-17.48Zm49.89,60.82l-33.7-30.5,7.99-12.39-1.24-18.25-3.28-3.36.41,15.46-15.96-5.18-2.45,17.02-14.37-3.43-.39,10.21-.69-.03,9.88,5.06,15.33-1.18,31.53,37.05,8.2.38-1.26-10.85Zm18.54-71.4l-15.66-5.5-15.94,5.11-2.85,4.6c6.07,4.35,29.16,20.99,43.68,31.45l.22-.16,1.74-20.25-11.19-15.25Zm-40.52,14l.89,16.27,9.98,12.33-5.77,9.97,6.3,4.91,6.63-11.93,16.93.76,10.52-7.58c-14.36-10.35-35.84-25.82-42.05-30.27l-3.43,5.53Z"
    },
    $2e = {
        key: 29,
        d: "m49.2,140.64l21.41,9.36h12.43l-17.02-41.39-16.82,32.03Zm47.98-40.37l-23.49-.78-6.39,6.43-.25-.05,17.45,42.44,16.8-43.3-4.12-4.74Zm11.35-22.26c-2.55.06-25.98-.64-27.72.27l-33.53-21.44-2.66,1.53-.73,3.63,28.78,17.45-19.98,2.87-7.75,9.73,3.76,4.16-.93,42.89,17.74-33.78-4.99-6.7-8.75-2.01-4.2-4.64,6.19-7.77,21.61-3.1c3.2,2.03,17.7,10.16,19.72,13.17h5.58l-3.22-5.74c-2.72-1.2-11.42-6.9-14.06-8.58,10.06-.62,30.68.23,40.47,2.03l11.2,10.8-1.37,3.38-13.36,47.75,10.44-3.38c.85-5.61,2.7-44.42,6.65-48.25l-12.66-12.2-16.24-2.04Zm-22.53,71.99h15.45l16.03-5.19-15.26-36.63-16.22,41.82Zm45.33-55.42l-20.36,5.25-7.82,5.38,15.51,37.25,13.13-46.9-.46-.97Zm-39.55-31.98l47.58-28.86-.73-3.63-2.66-1.53-46.12,29.49-3.9,1.04-4.75,5.88h6.86l3.72-2.4Z"
    },
    L2e = {
        key: 30,
        d: "m96.91,94.69l-40.1,37.2-.35,4.43,9.54,1.24c17.83-19.69,56.26-57.76,76.9-74.14,0,0,6.12-12.02,6.12-12.02l-2.75-2.93-6.32,10.76-35.43,26.56,1.61-16.48-4.16.51-5.06,24.87Zm-12.39,57.75l-4-1.61-3.54-19.79,4.74-5.18,7.61,21.75-4.81,4.83Zm-10.82-105.44l-.79,26.1,4.8,32.62-5.6,6.04-5.21-40.27,1.6-24.97-4-14.9,2.8-2.01,6.22,16.42,1.39-1.92.8-8.05,8.81-7.25,7.21-2.82-5.61,12.89c-2.48,1.51-10.41,6.21-12.42,8.13Z"
    },
    F2e = {
        key: 31,
        d: "m89.92,93.77h-7.46v5.42l11.55,14.47h6l1.55-5.81-11.65-14.09Zm-15.79,4.34h-7.09v4.87l11.14,19.02,6.59-2.28v-4.68l-10.64-16.94Zm-28.52,28.55l-6.86-23.14-6.92,1.72c-1.41,3.01,6.49,23.58,7.33,26.75l6.46-1.74v-3.59Zm6.94-20.63h-7.34c-1.63,2.3,8.39,23.48,9.14,25.94l6.41-1.72v-5.07l-8.21-19.15Zm-22.09,16.38l-5.73-22.79-6.29,1.81c-1.07,3.36,4.56,23.76,5.29,27.39l6.73-1.79v-4.62Zm78.94-23.38v5l16.22,13.17,6.68-1.84v-5l-16.93-11.32h-5.96Zm34.44,18.21l-17.38-14.53.79-4.56,5.31.71,18.93,12.3-.6,5.44-7.04.65Zm13.74.48l-12.4-13.95,2.15-2.63c4.21.95,15.12,11.41,18.37,14.22l-1.91,4.21-6.2-1.84Zm-75.07-34.29c-.48.14-10.17,4.68-10.83,4.73-.25,0-12.45,0-12.7,0-.34-.12-10.49-4.72-10.57-4.7l.07-.72s2.83-28.51,2.83-28.51c.03-.3.09-.95.12-1.24l9.43,2.91,16.24-4.03c.05.31.14.84.2,1.15l5.08,29.64.13.77Zm-5.69-33.16l-15.68,3.79-9.55-2.73c.04-.39.15-1.47.18-1.85.18-.08,9.22-4.03,9.57-4.18l.26.03,4.78.5-2.84,3.86,1.41.42,3.16-4.11c1.34.14,6.75.7,8.12.84l.13.75.46,2.68Zm24.78-1.54v-3.06c.3-.13,10.2-4.54,10.64-4.74.32.09,15.27,4.33,15.61,4.42,0,0,.59.17.59.17.08.41.37,1.91.46,2.35l-5.92,3.51h-10.02l.56-4.24h-1.84l-.56,4.09-9.52-2.51Zm33.12,28.89c-.34.08-12.12,6.23-12.69,6.21-.27,0-12.49,0-12.75,0-.38-.2-7.44-4.13-7.68-4.25v-28.25l9.24,2.03h12.56l5.84-3.74s.11.56.11.56c.08.43.2,1.04.29,1.47l4.93,25.23.15.75Z"
    },
    U2e = {
        key: 32,
        d: "m99.3,92.93l-3.61-1.98-1.17-28.88-23.92,16.44-2.38-2.24,12.43-25.72-9.09,9.53c-5.64,10.97-13.99,55.75-16.64,68.36l14.94,10.64,18.39,5.15c3.65-5.69,34.94-47.4,35.23-53.27l-4.51-19.67-19.67,21.63Zm22.41-38.01l-18.14-9.48-13.49-2.39c-.45.28-5.25,2.72-5.32,3.2,0,0-12.1,27.46-12.1,27.46l20.66-13.18,2.82,1.61,2.35,26.05,18.26-17.25,3.72-.31,4.28,17.4c2.08-1.2,2.17-23.76,2.49-26.04l-5.53-7.08Zm-26.79-1.35l-6.24-8.3,13.37,1.49,17.02,8.82,6.21,6.62-2.43,1.04-2.8,6.41-3.56-.06.35-6.49-15.43-6.38-4.61,4.43-2.92-1.97,1.04-5.61Z"
    },
    B2e = {
        key: 33,
        d: "m87.02,41l-13.93,2-20.88,12.5-11.93,23,4.47,34,20.39,20,23.37,5,22.37-6,19.39-21,4.98-24-4.98-18.5-14.41-18-28.84-9Zm0,3l-13.43,2.5-17.9,11-10.94,22,5.97,31,15.41,16.5,22.38,5.5,20.38-6,16.41-17.5,5.47-22.5-3.98-17-12.92-17-26.85-8.5Zm-13.43,7l13.43-3,24.86,7.5,12.93,15.5,3.48,15.5-4.98,21.5-14.42,16.5-20.38,6-21.38-6-14.42-15-5.47-29.5,11.44-19.5,14.91-9.5Zm4.91-16l-2.5,5.5,11.5-2,12.5,3.5-2.5-7-10-4-9,4Zm39,9l-5,3,5,1.5,13,15,2-4.5-3-10.5-12-4.5Zm24.5,36l-6.5-2.5,2.5,8.5-3,14.5,7-2,3.5-8-3.5-10.5Zm-9.5,38l-2-3-5,5.5-1,5.5h-5.5l-5,5.5,10.5,2,6.5-6,1.5-9.5Zm-78,6l6.5,7.5-8,2-8-5-1.5-9,1.5-4,9.5,8.5Zm-14-34.5l.5,11.5-8.5-4-2.5-8.5,4-8.5,5-2.5,1.5,12Zm11-35.5l-5.5,9.5-2.5-6.5,1-5.5,6-5.5,8.5-1,4,2-11.5,7Z"
    },
    q2e = {
        key: 34,
        d: "m161.04,93.27l-12.38-4.03-14.35,4.42,5.02-3.18-5.13-28.91-27.91-35.21-8.65,2.32-8,30.66-58.69,33.9-10.32,22.53,14.12,15.36,61.71-19-2.62,16.91-16.49,5.87-6.37-4.58,2.61,13.99,4.22,1.59,1.53-4.63,77.83-25.44,7.25-12.75-3.38-9.83Zm-54.39-54.96l2.24-1.75c19.2,24.13,17.77,14.98,22.62,46.25l-16.41-10.06-9.7-24.75,1.24-9.69ZM39.76,122.81l-6.22-11.33,4.93-8.66,19.83-7.11,11.47,17.85-30.01,9.25Zm35.26-10.87l-12.18-17.86,39.04-14c4.09,1.56,24.23,12.54,28.52,14.79l-55.38,17.07Zm23.41,15.48l2.58-16.68,46.26-14.24,6.98,2.44,1.17,8.2-56.98,20.28Z"
    },
    G2e = {
        key: 35,
        d: "m47.24,133.05l-1-12.8-17.9,15.9,7.66,12.35c2.48-3.18,11.04-14.26,11.24-15.45ZM111.13,19l-5.62,3.6,6.12,19.5.5,11.85-15.81,17.95-16.86,1.55,3.58,11.3-12.78-3.05.5,16.45-12.78-1.55,2.54,11.8-7.16,7.2,3.08,20.55,15.32,14.9,21.48-5.15,42.41-53.45-16.36-22.05-6.12,9.75,8.7,14.4-31.72,40.6-22.47,2.05-1.54-24.15c10.99-10.41,51.89-49.15,54.69-50.9,0,0,17.4-1.05,17.4-1.05l11.24,6.2,5.62-5.15-16.36-31.35-27.6-11.8Z"
    },
    V2e = {
        key: 36,
        d: "m104.6,33.79l-19.23-4.32,6.34-4.1,21.95-1.14,16.97,2.96-.9,4.32-25.11,2.28Zm-6.22,47.78l-1.58,1.71,2.15,38.23v22.18l-8.82,8.65-14.82-1.82-9.05-5.23-1.47-54.49-1.02-25.48,5.43-10.92,10.3-.23,9.28,8.3,1.13,17.07,4.64-4.89-2.38-23.55-7.81-9.21-16.74-.11-11.88,11.95-1.47,27.99,2.83,55.52,7.01,17.52,14.48,8.53,19.91-1.82,13.69-16.5,3.17-33.56,3.05-30.6-9.62,1.48-10.41-.68Zm23.87-60.07l-28.74.11-15.84,6.26,2.94,5.01,8.26,4.89,4.98,10.47,2.49,24,13.35,1.14,9.16-2.73,4.07-26.62,13.12-11.83,2.49-5.23-16.29-5.46Zm6.22,46.53l-.43,1.67-.37-1.1-6.69,4.76-11.79,2.18-13.46-.61-5.4,6.9.91,53.29-6.74,9.3-8.63-1.86-3.28-5.8-.11-13.54-.9-34.58,4.19-3.3,6.34,2.42.23,19.6.4,21.34,3.23,5.77,4.07-1.47-.23-4.89-2.04-.23-.11-20.36-.11-24h.11s-.23-6.37-.23-6.37l-2.72-5.8-3.85,5.23-3.85-5.01-3.73,4.55-5.43-4.89-1.92,4.09.68,8.65,1.95-.04-2.2,1.84.93,38.29.24,16.97,6.25,7.26,14.55.98,7.47-10.24.45-18.43-1.02-37.54,2.64-3.48,11.65.53,12.87-2.38,7.45-2.64-.2-.6,1.44.94-2.6-7.4Z"
    },
    j2e = {
        key: 37,
        d: "m48.73,122.5L124.81,49l-3.48-7,1.99-8.5,8.45-6,10.94,1.5,5.97,11-1.49,9-7.96,6-12.43-3L47.74,127.5l-6.46-3-4.97-25.5-5.47-3-4.47,8,6.46,44.5,62.15-30.5v-8.5l36.8-28c10.93.14,9.2-1.4,18.89,4.5l3.98,15v8.5l-51.71,18-5.97-5-66.13,30.5c-.41-5.83-9.79-52.57-5.97-57l7.95-5,6.46,5,4.97,25,4.48,1.5Z"
    },
    W2e = {
        key: 38,
        d: "m19.41,121.34l94.13-60.35,7.87.88,12.68-6.59.53-6.74,11.34-8.03,9.04,4.57,2.51,5.12-.43,7.28-9.91,6.67-8.41-.79-11.52,6.95-.97,7.38-80.27,57.45-12.17-3.48-3.59-4.94-6.17-3.94-4.3.73-.36-2.16Zm22.7-9.4l5.19,4.66.71-5.67-5.9,1Z"
    },
    H2e = {
        key: 39,
        d: "m45.06,63.28l42.73-12.28,46.65,11.84-.12.5-43.48,15.28-45.21-13.47-.57-1.88Zm.65,3.12l18.97,62.33,27.91,8.77,26.16-9.21,15.53-63.77-43.87,20.36-44.7-18.48Z"
    },
    Y2e = {
        key: 40,
        d: "m40.27,92.25l-16.16,39.25,9.08,3,11.31-3,9.45-38.51c-6.91-2.1-6.54-2.31-13.68-.74Zm6.71,38.51l9.95-37.02,5.59-1.61,6.59,1.8-6.71,36.83-8.33,3-7.09-3Zm25.36-35.72l6.34-1.54,5.84,2.28-2.48,33.97-8.7,3.24-7.71-2.69,6.71-35.27Zm12.68,34.79l2.74-33.32c5.79-1.83,5.65-1.57,11.43-.17l3.48,33.48c-9.59,2.74-8.17,2.3-17.65,0Zm18.4-32.18l5.22-1.16,5.22,1.34,7.71,30.51-7.46,2.12-7.96-2.12-2.73-30.69Zm14.92,1.86l5.71-1.38,5.72,1.19,8.45,27.53-6.21,1.65-7.46-2.21-6.21-26.79Zm23.37,25.3l-7.46-24.55,4.35-1.12,5.34,1.12,10.44,24.18-5.59,1.94-7.08-1.57Zm-35.31-49.8l42.52-30.25,2.23,3.25-42.01,31.5-1.99,8.25-8.95,1.75-5.97-5.25,1.49-7.25,7.21-4,5.47,2Zm-32.81-5.5l-18.15-34.75-3.73,1.5,17.65,35-3.23,7.5,5.47,6.75,7.95-2.5,3.48-7-2.98-5.75-6.46-.75Z"
    },
    z2e = {
        key: 41,
        d: "m41.5,111.57l.31-16.44-7.77,3.66,7.46,12.78Zm102.42-49.84l-13.78-3.75-4.96,6.76-.1-.31-.66-14.49,7.2-15.09-22.28,12.08-8.12,18.51-58.35,27.46.55,21.16,5.49,10.24,22.04-7.58,4.94,2.73-25.41,7.51,4.27,7.31,4.29-.76,20.74,13.68-2.59-16.89,56.22-13.59-6.19-45.75,6.19-1.85,10.5-7.4Zm-34.92,27.48l-6.29,2.99-7.61-2.07-.87-5.68,2.07-5.71,5.67-2.78,6.1,1.67,2.39,6.07-1.45,5.5Z"
    },
    K2e = {
        key: 42,
        d: "m51.47,75.84c-1.38-.45-5.85.49-7.26.73-1.73.39-5.4,1.5-6.85,2.53,1.43.44,5.81-.47,7.26-.73,1.17-.37,6.04-1.58,6.85-2.53Zm3.78,4.3l-4.06.19-9.98,3.57-7.9,3.9-4.47,3.75,4.23-.24s9.81-3.53,9.81-3.53c2.22-1.21,11.21-5.29,12.37-7.65Zm56.51,3.47l-7.7-6.04,18.82-10,17.91-14.73,3.21-7.04-8.98.61-19.35,10.23-14.37,11.11-3.24,5.12-5.4-4.23-.75-.08-2.94-7.34-14.26-6.1-8.62,4.12c-.75-1.73-21.09-12.34-23.06-13.54l-7.73-.39,3.88,8.12,16.65,14.2,1.41.83-2.24,6.36,5.21,13.35,3.94,1.73-19.51,46.84,3.21-1.46,9.19-23.41,14.88-18.56,2.78,1.22,10.88-3.71,7.2,10.92,19.54,15.19,14.45,1.38-1.73-16.6-13.27-18.1Zm-44.4-3.71l-3.02,1.03-3.63-1.59-1.3-3.34,1.09-3.1,3.84-1.84,3.57,1.53,1.36,3.4-1.92,3.9Zm15.7,8.74l-2.95,1.01-3.55-1.56-1.28-3.27,1.07-3.03,3.76-1.8,3.49,1.5,1.34,3.34-1.88,3.82Zm32.29-13.31c2.06.66,9.17.44,11.4.41,1.88-.19,9.7-.61,11.32-1.43-5.09-1.02-13.2-.25-18.34.1l-4.38.93Zm28.56,5.27l-14.83-2.22-12.44-.63-8.06,1.28,5.44,2.29s14.59,2.17,14.58,2.16c3.49.05,17.47,1.15,20.5-.65l-5.2-2.23Z"
    },
    Z2e = {
        key: 43,
        d: "m141.32,24.27l-24.54,16.1,1.18,5.28-36.43,37.93-6.35-4.81,8.16-13.87-5.82-1.83-9.78,6.08-10.6,25.05-21.78,11.41-7.09,22.53c14.02,20.62,10.13,17.2,31.77,29.62l18.78-8.5,7.1-25.71,15.48-11.77,3.8-7.18-3.14-2.37-7.95,4.04-7.97-4.06,38.91-51.2,5.91.09,18.71-20.51-8.36-6.33Zm-79.21,111.34l-13.24-10.02,4.84-6.4,11.44,10.53-3.05,5.88Zm5.16-11.77l-10.18-9.11,2.7-3.57,10.41,8.81-2.93,3.87Z"
    };

function X2e(t, e, n, r, s, i) {
    return B(), H("svg", {
        viewBox: "0 0 180 180",
        class: nt(["instrument", `type-${t.categoryClass}`])
    }, [t.icon === "accordion" ? (B(), H("path", a2e)) : t.icon === "banjo" ? (B(), H("path", c2e)) : t.icon === "bell" ? (B(), H("path", l2e)) : t.icon === "bongos" ? (B(), H("path", u2e)) : t.icon === "canon" ? (B(), H("path", h2e)) : t.icon === "cap" ? (B(), H("path", f2e)) : t.icon === "car" ? (B(), H("path", d2e)) : t.icon === "castanets" ? (B(), H("path", p2e)) : t.icon === "cat" ? (B(), H("path", m2e)) : t.icon === "cello" ? (B(), H("path", g2e)) : t.icon === "chimes" ? (B(), H("path", _2e)) : t.icon === "clock" ? (B(), H("path", y2e)) : t.icon === "cup" ? (B(), H("path", v2e)) : t.icon === "dog" ? (B(), H("path", b2e)) : t.icon === "drumKit" ? (B(), H("path", E2e)) : t.icon === "fish" ? (B(), H("path", T2e)) : t.icon === "flute" ? (B(), H("path", S2e)) : t.icon === "frenchHorn" ? (B(), H("path", w2e)) : t.icon === "gong" ? (B(), H("path", A2e)) : t.icon === "guitar" ? (B(), H("path", O2e)) : t.icon === "hands" ? (B(), H("path", C2e)) : t.icon === "kazoo" ? (B(), H("path", k2e)) : t.icon === "mouth" ? (B(), H("path", I2e)) : t.icon === "ocarina" ? (B(), H("path", N2e)) : t.icon === "piano" ? (B(), H("path", x2e)) : t.icon === "poop" ? (B(), H("path", P2e)) : t.icon === "pots" ? (B(), H("path", R2e)) : t.icon === "sax" ? (B(), H("path", M2e)) : t.icon === "shaker" ? (B(), H("path", D2e)) : t.icon === "snare" ? (B(), H("path", $2e)) : t.icon === "sticks" ? (B(), H("path", L2e)) : t.icon === "synth" ? (B(), H("path", F2e)) : t.icon === "tallBongo" ? (B(), H("path", U2e)) : t.icon === "tamborine" ? (B(), H("path", B2e)) : t.icon === "trombone" ? (B(), H("path", q2e)) : t.icon === "trumpet" ? (B(), H("path", G2e)) : t.icon === "tuba" ? (B(), H("path", V2e)) : t.icon === "vibraslap" ? (B(), H("path", j2e)) : t.icon === "whistle" ? (B(), H("path", W2e)) : t.icon === "woodblock" ? (B(), H("path", H2e)) : t.icon === "xylophone" ? (B(), H("path", Y2e)) : t.icon === "goat" ? (B(), H("path", z2e)) : t.icon === "mosquito" ? (B(), H("path", K2e)) : t.icon === "electric-guitar" ? (B(), H("path", Z2e)) : Pe("", !0)], 2)
}
const kC = He(o2e, [
        ["render", X2e],
        ["__scopeId", "data-v-1717ac28"]
    ]),
    Q2e = st({
        components: {
            AvatarSVG: K3,
            InfinitySVG: i2e,
            InstrumentSVG: kC
        },
        props: {
            choice: {
                type: Object,
                required: !0
            }
        },
        computed: {
            difficultyKey() {
                return ur.difficultyI18ByNumber(this.choice.beatmap.config.difficulty)
            }
        }
    });
const J2e = {
        class: "sub"
    },
    e3e = {
        key: 1,
        class: "avatars"
    };

function t3e(t, e, n, r, s, i) {
    const o = Ge("InstrumentSVG"),
        a = Ge("InfinitySVG"),
        l = Ge("AvatarSVG"),
        u = Gt("t");
    return B(), H("button", {
        class: nt([{
            selected: t.choice.isSelected
        }, "choice has-icon has-sub"])
    }, [Ve(o, {
        category: t.choice.beatmap.config.category,
        slug: t.choice.instrumentSlug,
        class: "icon"
    }, null, 8, ["category", "slug"]), mn(" " + rt(t.choice.label) + " ", 1), t.choice.beatmap.config.type === "Continuous" ? (B(), At(a, {
        key: 0,
        class: "infinity"
    })) : Pe("", !0), $e(U("span", J2e, null, 512), [
        [u, t.difficultyKey]
    ]), t.choice.players ? (B(), H("div", e3e, [(B(!0), H(lt, null, gn(t.choice.players, f => (B(), H("div", {
        key: f.name,
        focusable: "false",
        class: "avatar-wrapper"
    }, [Ve(l, {
        avatar: f.avatar
    }, null, 8, ["avatar"])]))), 128))])) : Pe("", !0)], 2)
}
const n3e = He(Q2e, [
        ["render", t3e],
        ["__scopeId", "data-v-30b2a248"]
    ]),
    r3e = st({
        components: {
            AvatarSVG: K3
        },
        props: {
            info: {
                type: Object,
                required: !0
            },
            isVip: {
                type: Boolean,
                default: () => !1
            },
            players: {
                type: Object,
                required: !1
            },
            responseKey: {
                type: String,
                required: !1
            }
        },
        emits: {
            didRequestChangeVip: () => !0
        },
        methods: {
            async onAvatarClick() {
                if (!this.players || !this.responseKey) return;
                const t = Object.values(this.players).map(s => s.avatar),
                    e = [],
                    n = [];
                let r = this.info.avatar;
                for (let s = 0; s < 12; s++) t.includes(s) || (s < this.info.avatar ? e.push(s) : n.push(s));
                n.length ? r = n[0] : e.length && (r = e[0]);
                try {
                    await this.$ecast.updateObject(this.responseKey, {
                        changeAvatar: r
                    })
                } catch (s) {
                    this.$handleEcastError(s)
                }
            },
            onChangeHostClick() {
                this.isVip && this.$emit("didRequestChangeVip")
            }
        }
    });
const s3e = {
        class: "player-header"
    },
    i3e = {
        class: "constrain"
    },
    o3e = {
        key: 0,
        class: "name"
    },
    a3e = {
        key: 1,
        class: "name"
    },
    c3e = ["aria-label", "disabled"];

function l3e(t, e, n, r, s, i) {
    const o = Ge("AvatarSVG"),
        a = Gt("t"),
        l = Gt("bb");
    return B(), H("div", s3e, [U("div", i3e, [t.info.isAudience ? $e((B(), H("p", o3e, null, 512)), [
        [a, "AUDIENCE.NAME"]
    ]) : (B(), H("p", a3e, rt(t.info.name), 1)), U("button", {
        class: "change-avatar",
        "aria-label": t.$t("ARIA.CHANGE_AVATAR"),
        disabled: !t.responseKey,
        onClick: e[0] || (e[0] = (...u) => t.onAvatarClick && t.onAvatarClick(...u))
    }, [Ve(o, {
        focusable: "false",
        class: "header-avatar",
        avatar: t.info.avatar
    }, null, 8, ["avatar"])], 8, c3e), t.isVip ? $e((B(), H("button", {
        key: 2,
        class: "change-host",
        onClick: e[1] || (e[1] = (...u) => t.onChangeHostClick && t.onChangeHostClick(...u))
    }, null, 512)), [
        [l, t.$t("MENU.CHANGE_HOST")]
    ]) : Pe("", !0)])])
}
const zf = He(r3e, [
        ["render", l3e],
        ["__scopeId", "data-v-dbeb3660"]
    ]),
    IC = "14.7.77",
    Aw = (t, e, n) => ({
        endTime: e,
        insertTime: n,
        type: "exponentialRampToValue",
        value: t
    }),
    Ow = (t, e, n) => ({
        endTime: e,
        insertTime: n,
        type: "linearRampToValue",
        value: t
    }),
    vv = (t, e) => ({
        startTime: e,
        type: "setValue",
        value: t
    }),
    NC = (t, e, n) => ({
        duration: n,
        startTime: e,
        type: "setValueCurve",
        values: t
    }),
    xC = (t, e, {
        startTime: n,
        target: r,
        timeConstant: s
    }) => r + (e - r) * Math.exp((n - t) / s),
    yl = t => t.type === "exponentialRampToValue",
    w1 = t => t.type === "linearRampToValue",
    Vo = t => yl(t) || w1(t),
    Z3 = t => t.type === "setValue",
    to = t => t.type === "setValueCurve",
    A1 = (t, e, n, r) => {
        const s = t[e];
        return s === void 0 ? r : Vo(s) || Z3(s) ? s.value : to(s) ? s.values[s.values.length - 1] : xC(n, A1(t, e - 1, s.startTime, r), s)
    },
    Cw = (t, e, n, r, s) => n === void 0 ? [r.insertTime, s] : Vo(n) ? [n.endTime, n.value] : Z3(n) ? [n.startTime, n.value] : to(n) ? [n.startTime + n.duration, n.values[n.values.length - 1]] : [n.startTime, A1(t, e - 1, n.startTime, s)],
    bv = t => t.type === "cancelAndHold",
    Ev = t => t.type === "cancelScheduledValues",
    Fo = t => bv(t) || Ev(t) ? t.cancelTime : yl(t) || w1(t) ? t.endTime : t.startTime,
    kw = (t, e, n, {
        endTime: r,
        value: s
    }) => n === s ? s : 0 < n && 0 < s || n < 0 && s < 0 ? n * (s / n) ** ((t - e) / (r - e)) : 0,
    Iw = (t, e, n, {
        endTime: r,
        value: s
    }) => n + (t - e) / (r - e) * (s - n),
    u3e = (t, e) => {
        const n = Math.floor(e),
            r = Math.ceil(e);
        return n === r ? t[n] : (1 - (e - n)) * t[n] + (1 - (r - e)) * t[r]
    },
    h3e = (t, {
        duration: e,
        startTime: n,
        values: r
    }) => {
        const s = (t - n) / e * (r.length - 1);
        return u3e(r, s)
    },
    Cp = t => t.type === "setTarget";
class f3e {
    constructor(e) {
        this._automationEvents = [], this._currenTime = 0, this._defaultValue = e
    } [Symbol.iterator]() {
        return this._automationEvents[Symbol.iterator]()
    }
    add(e) {
        const n = Fo(e);
        if (bv(e) || Ev(e)) {
            const r = this._automationEvents.findIndex(i => Ev(e) && to(i) ? i.startTime + i.duration >= n : Fo(i) >= n),
                s = this._automationEvents[r];
            if (r !== -1 && (this._automationEvents = this._automationEvents.slice(0, r)), bv(e)) {
                const i = this._automationEvents[this._automationEvents.length - 1];
                if (s !== void 0 && Vo(s)) {
                    if (Cp(i)) throw new Error("The internal list is malformed.");
                    const o = to(i) ? i.startTime + i.duration : Fo(i),
                        a = to(i) ? i.values[i.values.length - 1] : i.value,
                        l = yl(s) ? kw(n, o, a, s) : Iw(n, o, a, s),
                        u = yl(s) ? Aw(l, n, this._currenTime) : Ow(l, n, this._currenTime);
                    this._automationEvents.push(u)
                }
                i !== void 0 && Cp(i) && this._automationEvents.push(vv(this.getValue(n), n)), i !== void 0 && to(i) && i.startTime + i.duration > n && (this._automationEvents[this._automationEvents.length - 1] = NC(new Float32Array([6, 7]), i.startTime, n - i.startTime))
            }
        } else {
            const r = this._automationEvents.findIndex(o => Fo(o) > n),
                s = r === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[r - 1];
            if (s !== void 0 && to(s) && Fo(s) + s.duration > n) return !1;
            const i = yl(e) ? Aw(e.value, e.endTime, this._currenTime) : w1(e) ? Ow(e.value, n, this._currenTime) : e;
            if (r === -1) this._automationEvents.push(i);
            else {
                if (to(e) && n + e.duration > Fo(this._automationEvents[r])) return !1;
                this._automationEvents.splice(r, 0, i)
            }
        }
        return !0
    }
    flush(e) {
        const n = this._automationEvents.findIndex(r => Fo(r) > e);
        if (n > 1) {
            const r = this._automationEvents.slice(n - 1),
                s = r[0];
            Cp(s) && r.unshift(vv(A1(this._automationEvents, n - 2, s.startTime, this._defaultValue), s.startTime)), this._automationEvents = r
        }
    }
    getValue(e) {
        if (this._automationEvents.length === 0) return this._defaultValue;
        const n = this._automationEvents.findIndex(o => Fo(o) > e),
            r = this._automationEvents[n],
            s = (n === -1 ? this._automationEvents.length : n) - 1,
            i = this._automationEvents[s];
        if (i !== void 0 && Cp(i) && (r === void 0 || !Vo(r) || r.insertTime > e)) return xC(e, A1(this._automationEvents, s - 1, i.startTime, this._defaultValue), i);
        if (i !== void 0 && Z3(i) && (r === void 0 || !Vo(r))) return i.value;
        if (i !== void 0 && to(i) && (r === void 0 || !Vo(r) || i.startTime + i.duration > e)) return e < i.startTime + i.duration ? h3e(e, i) : i.values[i.values.length - 1];
        if (i !== void 0 && Vo(i) && (r === void 0 || !Vo(r))) return i.value;
        if (r !== void 0 && yl(r)) {
            const [o, a] = Cw(this._automationEvents, s, i, r, this._defaultValue);
            return kw(e, o, a, r)
        }
        if (r !== void 0 && w1(r)) {
            const [o, a] = Cw(this._automationEvents, s, i, r, this._defaultValue);
            return Iw(e, o, a, r)
        }
        return this._defaultValue
    }
}
const d3e = t => ({
        cancelTime: t,
        type: "cancelAndHold"
    }),
    p3e = t => ({
        cancelTime: t,
        type: "cancelScheduledValues"
    }),
    m3e = (t, e) => ({
        endTime: e,
        type: "exponentialRampToValue",
        value: t
    }),
    g3e = (t, e) => ({
        endTime: e,
        type: "linearRampToValue",
        value: t
    }),
    _3e = (t, e, n) => ({
        startTime: e,
        target: t,
        timeConstant: n,
        type: "setTarget"
    }),
    y3e = () => new DOMException("", "AbortError"),
    v3e = t => (e, n, [r, s, i], o) => {
        t(e[s], [n, r, i], a => a[0] === n && a[1] === r, o)
    },
    b3e = t => (e, n, r) => {
        const s = [];
        for (let i = 0; i < r.numberOfInputs; i += 1) s.push(new Set);
        t.set(e, {
            activeInputs: s,
            outputs: new Set,
            passiveInputs: new WeakMap,
            renderer: n
        })
    },
    E3e = t => (e, n) => {
        t.set(e, {
            activeInputs: new Set,
            passiveInputs: new WeakMap,
            renderer: n
        })
    },
    eu = new WeakSet,
    PC = new WeakMap,
    X3 = new WeakMap,
    RC = new WeakMap,
    Q3 = new WeakMap,
    vg = new WeakMap,
    MC = new WeakMap,
    Tv = new WeakMap,
    Sv = new WeakMap,
    wv = new WeakMap,
    DC = {
        construct() {
            return DC
        }
    },
    T3e = t => {
        try {
            const e = new Proxy(t, DC);
            new e
        } catch {
            return !1
        }
        return !0
    },
    Nw = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/,
    xw = (t, e) => {
        const n = [];
        let r = t.replace(/^[\s]+/, ""),
            s = r.match(Nw);
        for (; s !== null;) {
            const i = s[1].slice(1, -1),
                o = s[0].replace(/([\s]+)?;?$/, "").replace(i, new URL(i, e).toString());
            n.push(o), r = r.slice(s[0].length).replace(/^[\s]+/, ""), s = r.match(Nw)
        }
        return [n.join(";"), r]
    },
    Pw = t => {
        if (t !== void 0 && !Array.isArray(t)) throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")
    },
    Rw = t => {
        if (!T3e(t)) throw new TypeError("The given value for processorCtor should be a constructor.");
        if (t.prototype === null || typeof t.prototype != "object") throw new TypeError("The given value for processorCtor should have a prototype.")
    },
    S3e = (t, e, n, r, s, i, o, a, l, u, f, d, p) => {
        let _ = 0;
        return (v, y, g = {
            credentials: "omit"
        }) => {
            const b = f.get(v);
            if (b !== void 0 && b.has(y)) return Promise.resolve();
            const O = u.get(v);
            if (O !== void 0) {
                const A = O.get(y);
                if (A !== void 0) return A
            }
            const N = i(v),
                k = N.audioWorklet === void 0 ? s(y).then(([A, x]) => {
                    const [D, L] = xw(A, x), q = `${D};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${L}
})})(window,'_AWGS')`;
                    return n(q)
                }).then(() => {
                    const A = p._AWGS.pop();
                    if (A === void 0) throw new SyntaxError;
                    r(N.currentTime, N.sampleRate, () => A(class {}, void 0, (x, D) => {
                        if (x.trim() === "") throw e();
                        const L = Sv.get(N);
                        if (L !== void 0) {
                            if (L.has(x)) throw e();
                            Rw(D), Pw(D.parameterDescriptors), L.set(x, D)
                        } else Rw(D), Pw(D.parameterDescriptors), Sv.set(N, new Map([
                            [x, D]
                        ]))
                    }, N.sampleRate, void 0, void 0))
                }) : Promise.all([s(y), Promise.resolve(t(d, d))]).then(([
                    [A, x], D
                ]) => {
                    const L = _ + 1;
                    _ = L;
                    const [q, ee] = xw(A, x), ge = `${q};((AudioWorkletProcessor,registerProcessor)=>{${ee}
})(${D?"AudioWorkletProcessor":"class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${D?"":"__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${D?"":"i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${L}',class extends AudioWorkletProcessor{process(){return !1}})`, K = new Blob([ge], {
                        type: "application/javascript; charset=utf-8"
                    }), Q = URL.createObjectURL(K);
                    return N.audioWorklet.addModule(Q, g).then(() => {
                        if (a(N)) return N;
                        const ue = o(N);
                        return ue.audioWorklet.addModule(Q, g).then(() => ue)
                    }).then(ue => {
                        if (l === null) throw new SyntaxError;
                        try {
                            new l(ue, `__sac${L}`)
                        } catch {
                            throw new SyntaxError
                        }
                    }).finally(() => URL.revokeObjectURL(Q))
                });
            return O === void 0 ? u.set(v, new Map([
                [y, k]
            ])) : O.set(y, k), k.then(() => {
                const A = f.get(v);
                A === void 0 ? f.set(v, new Set([y])) : A.add(y)
            }).finally(() => {
                const A = u.get(v);
                A !== void 0 && A.delete(y)
            }), k
        }
    },
    Xs = (t, e) => {
        const n = t.get(e);
        if (n === void 0) throw new Error("A value with the given key could not be found.");
        return n
    },
    bg = (t, e) => {
        const n = Array.from(t).filter(e);
        if (n.length > 1) throw Error("More than one element was found.");
        if (n.length === 0) throw Error("No element was found.");
        const [r] = n;
        return t.delete(r), r
    },
    $C = (t, e, n, r) => {
        const s = Xs(t, e),
            i = bg(s, o => o[0] === n && o[1] === r);
        return s.size === 0 && t.delete(e), i
    },
    Kf = t => Xs(MC, t),
    tu = t => {
        if (eu.has(t)) throw new Error("The AudioNode is already stored.");
        eu.add(t), Kf(t).forEach(e => e(!0))
    },
    LC = t => "port" in t,
    Zf = t => {
        if (!eu.has(t)) throw new Error("The AudioNode is not stored.");
        eu.delete(t), Kf(t).forEach(e => e(!1))
    },
    Av = (t, e) => {
        !LC(t) && e.every(n => n.size === 0) && Zf(t)
    },
    w3e = (t, e, n, r, s, i, o, a, l, u, f, d, p) => {
        const _ = new WeakMap;
        return (v, y, g, b, O) => {
            const {
                activeInputs: N,
                passiveInputs: k
            } = i(y), {
                outputs: A
            } = i(v), x = a(v), D = L => {
                const q = l(y),
                    ee = l(v);
                if (L) {
                    const ae = $C(k, v, g, b);
                    t(N, v, ae, !1), !O && !d(v) && n(ee, q, g, b), p(y) && tu(y)
                } else {
                    const ae = r(N, v, g, b);
                    e(k, b, ae, !1), !O && !d(v) && s(ee, q, g, b);
                    const Z = o(y);
                    if (Z === 0) f(y) && Av(y, N);
                    else {
                        const fe = _.get(y);
                        fe !== void 0 && clearTimeout(fe), _.set(y, setTimeout(() => {
                            f(y) && Av(y, N)
                        }, Z * 1e3))
                    }
                }
            };
            return u(A, [y, g, b], L => L[0] === y && L[1] === g && L[2] === b, !0) ? (x.add(D), f(v) ? t(N, v, [g, b, D], !0) : e(k, b, [v, g, D], !0), !0) : !1
        }
    },
    A3e = t => (e, n, [r, s, i], o) => {
        const a = e.get(r);
        a === void 0 ? e.set(r, new Set([
            [s, n, i]
        ])) : t(a, [s, n, i], l => l[0] === s && l[1] === n, o)
    },
    O3e = t => (e, n) => {
        const r = t(e, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            gain: 0
        });
        n.connect(r).connect(e.destination);
        const s = () => {
            n.removeEventListener("ended", s), n.disconnect(r), r.disconnect()
        };
        n.addEventListener("ended", s)
    },
    C3e = t => (e, n) => {
        t(e).add(n)
    },
    k3e = {
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        fftSize: 2048,
        maxDecibels: -30,
        minDecibels: -100,
        smoothingTimeConstant: .8
    },
    I3e = (t, e, n, r, s, i) => class extends t {
        constructor(a, l) {
            const u = s(a),
                f = {
                    ...k3e,
                    ...l
                },
                d = r(u, f),
                p = i(u) ? e() : null;
            super(a, !1, d, p), this._nativeAnalyserNode = d
        }
        get fftSize() {
            return this._nativeAnalyserNode.fftSize
        }
        set fftSize(a) {
            this._nativeAnalyserNode.fftSize = a
        }
        get frequencyBinCount() {
            return this._nativeAnalyserNode.frequencyBinCount
        }
        get maxDecibels() {
            return this._nativeAnalyserNode.maxDecibels
        }
        set maxDecibels(a) {
            const l = this._nativeAnalyserNode.maxDecibels;
            if (this._nativeAnalyserNode.maxDecibels = a, !(a > this._nativeAnalyserNode.minDecibels)) throw this._nativeAnalyserNode.maxDecibels = l, n()
        }
        get minDecibels() {
            return this._nativeAnalyserNode.minDecibels
        }
        set minDecibels(a) {
            const l = this._nativeAnalyserNode.minDecibels;
            if (this._nativeAnalyserNode.minDecibels = a, !(this._nativeAnalyserNode.maxDecibels > a)) throw this._nativeAnalyserNode.minDecibels = l, n()
        }
        get smoothingTimeConstant() {
            return this._nativeAnalyserNode.smoothingTimeConstant
        }
        set smoothingTimeConstant(a) {
            this._nativeAnalyserNode.smoothingTimeConstant = a
        }
        getByteFrequencyData(a) {
            this._nativeAnalyserNode.getByteFrequencyData(a)
        }
        getByteTimeDomainData(a) {
            this._nativeAnalyserNode.getByteTimeDomainData(a)
        }
        getFloatFrequencyData(a) {
            this._nativeAnalyserNode.getFloatFrequencyData(a)
        }
        getFloatTimeDomainData(a) {
            this._nativeAnalyserNode.getFloatTimeDomainData(a)
        }
    },
    mr = (t, e) => t.context === e,
    N3e = (t, e, n) => () => {
        const r = new WeakMap,
            s = async (i, o) => {
                let a = e(i);
                if (!mr(a, o)) {
                    const u = {
                        channelCount: a.channelCount,
                        channelCountMode: a.channelCountMode,
                        channelInterpretation: a.channelInterpretation,
                        fftSize: a.fftSize,
                        maxDecibels: a.maxDecibels,
                        minDecibels: a.minDecibels,
                        smoothingTimeConstant: a.smoothingTimeConstant
                    };
                    a = t(o, u)
                }
                return r.set(o, a), await n(i, o, a), a
            };
        return {
            render(i, o) {
                const a = r.get(o);
                return a !== void 0 ? Promise.resolve(a) : s(i, o)
            }
        }
    },
    O1 = t => {
        try {
            t.copyToChannel(new Float32Array(1), 0, -1)
        } catch {
            return !1
        }
        return !0
    },
    Fi = () => new DOMException("", "IndexSizeError"),
    J3 = t => {
        t.getChannelData = (e => n => {
            try {
                return e.call(t, n)
            } catch (r) {
                throw r.code === 12 ? Fi() : r
            }
        })(t.getChannelData)
    },
    x3e = {
        numberOfChannels: 1
    },
    P3e = (t, e, n, r, s, i, o, a) => {
        let l = null;
        return class FC {
            constructor(f) {
                if (s === null) throw new Error("Missing the native OfflineAudioContext constructor.");
                const {
                    length: d,
                    numberOfChannels: p,
                    sampleRate: _
                } = {
                    ...x3e,
                    ...f
                };
                l === null && (l = new s(1, 1, 44100));
                const v = r !== null && e(i, i) ? new r({
                    length: d,
                    numberOfChannels: p,
                    sampleRate: _
                }) : l.createBuffer(p, d, _);
                if (v.numberOfChannels === 0) throw n();
                return typeof v.copyFromChannel != "function" ? (o(v), J3(v)) : e(O1, () => O1(v)) || a(v), t.add(v), v
            }
            static[Symbol.hasInstance](f) {
                return f !== null && typeof f == "object" && Object.getPrototypeOf(f) === FC.prototype || t.has(f)
            }
        }
    },
    Rr = -34028234663852886e22,
    Er = -Rr,
    uo = t => eu.has(t),
    R3e = {
        buffer: null,
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        loop: !1,
        loopEnd: 0,
        loopStart: 0,
        playbackRate: 1
    },
    M3e = (t, e, n, r, s, i, o, a) => class extends t {
        constructor(u, f) {
            const d = i(u),
                p = {
                    ...R3e,
                    ...f
                },
                _ = s(d, p),
                v = o(d),
                y = v ? e() : null;
            super(u, !1, _, y), this._audioBufferSourceNodeRenderer = y, this._isBufferNullified = !1, this._isBufferSet = p.buffer !== null, this._nativeAudioBufferSourceNode = _, this._onended = null, this._playbackRate = n(this, v, _.playbackRate, Er, Rr)
        }
        get buffer() {
            return this._isBufferNullified ? null : this._nativeAudioBufferSourceNode.buffer
        }
        set buffer(u) {
            if (this._nativeAudioBufferSourceNode.buffer = u, u !== null) {
                if (this._isBufferSet) throw r();
                this._isBufferSet = !0
            }
        }
        get loop() {
            return this._nativeAudioBufferSourceNode.loop
        }
        set loop(u) {
            this._nativeAudioBufferSourceNode.loop = u
        }
        get loopEnd() {
            return this._nativeAudioBufferSourceNode.loopEnd
        }
        set loopEnd(u) {
            this._nativeAudioBufferSourceNode.loopEnd = u
        }
        get loopStart() {
            return this._nativeAudioBufferSourceNode.loopStart
        }
        set loopStart(u) {
            this._nativeAudioBufferSourceNode.loopStart = u
        }
        get onended() {
            return this._onended
        }
        set onended(u) {
            const f = typeof u == "function" ? a(this, u) : null;
            this._nativeAudioBufferSourceNode.onended = f;
            const d = this._nativeAudioBufferSourceNode.onended;
            this._onended = d !== null && d === f ? u : d
        }
        get playbackRate() {
            return this._playbackRate
        }
        start(u = 0, f = 0, d) {
            if (this._nativeAudioBufferSourceNode.start(u, f, d), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.start = d === void 0 ? [u, f] : [u, f, d]), this.context.state !== "closed") {
                tu(this);
                const p = () => {
                    this._nativeAudioBufferSourceNode.removeEventListener("ended", p), uo(this) && Zf(this)
                };
                this._nativeAudioBufferSourceNode.addEventListener("ended", p)
            }
        }
        stop(u = 0) {
            this._nativeAudioBufferSourceNode.stop(u), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.stop = u)
        }
    },
    D3e = (t, e, n, r, s) => () => {
        const i = new WeakMap;
        let o = null,
            a = null;
        const l = async (u, f) => {
            let d = n(u);
            const p = mr(d, f);
            if (!p) {
                const _ = {
                    buffer: d.buffer,
                    channelCount: d.channelCount,
                    channelCountMode: d.channelCountMode,
                    channelInterpretation: d.channelInterpretation,
                    loop: d.loop,
                    loopEnd: d.loopEnd,
                    loopStart: d.loopStart,
                    playbackRate: d.playbackRate.value
                };
                d = e(f, _), o !== null && d.start(...o), a !== null && d.stop(a)
            }
            return i.set(f, d), p ? await t(f, u.playbackRate, d.playbackRate) : await r(f, u.playbackRate, d.playbackRate), await s(u, f, d), d
        };
        return {
            set start(u) {
                o = u
            },
            set stop(u) {
                a = u
            },
            render(u, f) {
                const d = i.get(f);
                return d !== void 0 ? Promise.resolve(d) : l(u, f)
            }
        }
    },
    $3e = t => "playbackRate" in t,
    L3e = t => "frequency" in t && "gain" in t,
    F3e = t => "offset" in t,
    U3e = t => !("frequency" in t) && "gain" in t,
    B3e = t => "detune" in t && "frequency" in t,
    q3e = t => "pan" in t,
    Tr = t => Xs(PC, t),
    Xf = t => Xs(RC, t),
    Ov = (t, e) => {
        const {
            activeInputs: n
        } = Tr(t);
        n.forEach(s => s.forEach(([i]) => {
            e.includes(t) || Ov(i, [...e, t])
        }));
        const r = $3e(t) ? [t.playbackRate] : LC(t) ? Array.from(t.parameters.values()) : L3e(t) ? [t.Q, t.detune, t.frequency, t.gain] : F3e(t) ? [t.offset] : U3e(t) ? [t.gain] : B3e(t) ? [t.detune, t.frequency] : q3e(t) ? [t.pan] : [];
        for (const s of r) {
            const i = Xf(s);
            i !== void 0 && i.activeInputs.forEach(([o]) => Ov(o, e))
        }
        uo(t) && Zf(t)
    },
    UC = t => {
        Ov(t.destination, [])
    },
    G3e = t => t === void 0 || typeof t == "number" || typeof t == "string" && (t === "balanced" || t === "interactive" || t === "playback"),
    V3e = (t, e, n, r, s, i, o, a, l) => class extends t {
        constructor(f = {}) {
            if (l === null) throw new Error("Missing the native AudioContext constructor.");
            let d;
            try {
                d = new l(f)
            } catch (v) {
                throw v.code === 12 && v.message === "sampleRate is not in range" ? n() : v
            }
            if (d === null) throw r();
            if (!G3e(f.latencyHint)) throw new TypeError(`The provided value '${f.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
            if (f.sampleRate !== void 0 && d.sampleRate !== f.sampleRate) throw n();
            super(d, 2);
            const {
                latencyHint: p
            } = f, {
                sampleRate: _
            } = d;
            if (this._baseLatency = typeof d.baseLatency == "number" ? d.baseLatency : p === "balanced" ? 512 / _ : p === "interactive" || p === void 0 ? 256 / _ : p === "playback" ? 1024 / _ : Math.max(2, Math.min(128, Math.round(p * _ / 128))) * 128 / _, this._nativeAudioContext = d, l.name === "webkitAudioContext" ? (this._nativeGainNode = d.createGain(), this._nativeOscillatorNode = d.createOscillator(), this._nativeGainNode.gain.value = 1e-37, this._nativeOscillatorNode.connect(this._nativeGainNode).connect(d.destination), this._nativeOscillatorNode.start()) : (this._nativeGainNode = null, this._nativeOscillatorNode = null), this._state = null, d.state === "running") {
                this._state = "suspended";
                const v = () => {
                    this._state === "suspended" && (this._state = null), d.removeEventListener("statechange", v)
                };
                d.addEventListener("statechange", v)
            }
        }
        get baseLatency() {
            return this._baseLatency
        }
        get state() {
            return this._state !== null ? this._state : this._nativeAudioContext.state
        }
        close() {
            return this.state === "closed" ? this._nativeAudioContext.close().then(() => {
                throw e()
            }) : (this._state === "suspended" && (this._state = null), this._nativeAudioContext.close().then(() => {
                this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(), this._nativeGainNode.disconnect(), this._nativeOscillatorNode.disconnect()), UC(this)
            }))
        }
        createMediaElementSource(f) {
            return new s(this, {
                mediaElement: f
            })
        }
        createMediaStreamDestination() {
            return new i(this)
        }
        createMediaStreamSource(f) {
            return new o(this, {
                mediaStream: f
            })
        }
        createMediaStreamTrackSource(f) {
            return new a(this, {
                mediaStreamTrack: f
            })
        }
        resume() {
            return this._state === "suspended" ? new Promise((f, d) => {
                const p = () => {
                    this._nativeAudioContext.removeEventListener("statechange", p), this._nativeAudioContext.state === "running" ? f() : this.resume().then(f, d)
                };
                this._nativeAudioContext.addEventListener("statechange", p)
            }) : this._nativeAudioContext.resume().catch(f => {
                throw f === void 0 || f.code === 15 ? e() : f
            })
        }
        suspend() {
            return this._nativeAudioContext.suspend().catch(f => {
                throw f === void 0 ? e() : f
            })
        }
    },
    j3e = (t, e, n, r, s, i, o, a) => class extends t {
        constructor(u, f) {
            const d = i(u),
                p = o(d),
                _ = s(d, f, p),
                v = p ? e(a) : null;
            super(u, !1, _, v), this._isNodeOfNativeOfflineAudioContext = p, this._nativeAudioDestinationNode = _
        }
        get channelCount() {
            return this._nativeAudioDestinationNode.channelCount
        }
        set channelCount(u) {
            if (this._isNodeOfNativeOfflineAudioContext) throw r();
            if (u > this._nativeAudioDestinationNode.maxChannelCount) throw n();
            this._nativeAudioDestinationNode.channelCount = u
        }
        get channelCountMode() {
            return this._nativeAudioDestinationNode.channelCountMode
        }
        set channelCountMode(u) {
            if (this._isNodeOfNativeOfflineAudioContext) throw r();
            this._nativeAudioDestinationNode.channelCountMode = u
        }
        get maxChannelCount() {
            return this._nativeAudioDestinationNode.maxChannelCount
        }
    },
    W3e = t => {
        const e = new WeakMap,
            n = async (r, s) => {
                const i = s.destination;
                return e.set(s, i), await t(r, s, i), i
            };
        return {
            render(r, s) {
                const i = e.get(s);
                return i !== void 0 ? Promise.resolve(i) : n(r, s)
            }
        }
    },
    H3e = (t, e, n, r, s, i, o, a) => (l, u) => {
        const f = u.listener,
            d = () => {
                const A = new Float32Array(1),
                    x = e(u, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "speakers",
                        numberOfInputs: 9
                    }),
                    D = o(u);
                let L = !1,
                    q = [0, 0, -1, 0, 1, 0],
                    ee = [0, 0, 0];
                const ae = () => {
                        if (L) return;
                        L = !0;
                        const K = r(u, 256, 9, 0);
                        K.onaudioprocess = ({
                            inputBuffer: Q
                        }) => {
                            const ue = [i(Q, A, 0), i(Q, A, 1), i(Q, A, 2), i(Q, A, 3), i(Q, A, 4), i(Q, A, 5)];
                            ue.some((Oe, Ee) => Oe !== q[Ee]) && (f.setOrientation(...ue), q = ue);
                            const _e = [i(Q, A, 6), i(Q, A, 7), i(Q, A, 8)];
                            _e.some((Oe, Ee) => Oe !== ee[Ee]) && (f.setPosition(..._e), ee = _e)
                        }, x.connect(K)
                    },
                    Z = K => Q => {
                        Q !== q[K] && (q[K] = Q, f.setOrientation(...q))
                    },
                    fe = K => Q => {
                        Q !== ee[K] && (ee[K] = Q, f.setPosition(...ee))
                    },
                    ge = (K, Q, ue) => {
                        const _e = n(u, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            offset: Q
                        });
                        _e.connect(x, 0, K), _e.start(), Object.defineProperty(_e.offset, "defaultValue", {
                            get() {
                                return Q
                            }
                        });
                        const Oe = t({
                            context: l
                        }, D, _e.offset, Er, Rr);
                        return a(Oe, "value", Ee => () => Ee.call(Oe), Ee => Ce => {
                            try {
                                Ee.call(Oe, Ce)
                            } catch (De) {
                                if (De.code !== 9) throw De
                            }
                            ae(), D && ue(Ce)
                        }), Oe.cancelAndHoldAtTime = (Ee => D ? () => {
                            throw s()
                        } : (...Ce) => {
                            const De = Ee.apply(Oe, Ce);
                            return ae(), De
                        })(Oe.cancelAndHoldAtTime), Oe.cancelScheduledValues = (Ee => D ? () => {
                            throw s()
                        } : (...Ce) => {
                            const De = Ee.apply(Oe, Ce);
                            return ae(), De
                        })(Oe.cancelScheduledValues), Oe.exponentialRampToValueAtTime = (Ee => D ? () => {
                            throw s()
                        } : (...Ce) => {
                            const De = Ee.apply(Oe, Ce);
                            return ae(), De
                        })(Oe.exponentialRampToValueAtTime), Oe.linearRampToValueAtTime = (Ee => D ? () => {
                            throw s()
                        } : (...Ce) => {
                            const De = Ee.apply(Oe, Ce);
                            return ae(), De
                        })(Oe.linearRampToValueAtTime), Oe.setTargetAtTime = (Ee => D ? () => {
                            throw s()
                        } : (...Ce) => {
                            const De = Ee.apply(Oe, Ce);
                            return ae(), De
                        })(Oe.setTargetAtTime), Oe.setValueAtTime = (Ee => D ? () => {
                            throw s()
                        } : (...Ce) => {
                            const De = Ee.apply(Oe, Ce);
                            return ae(), De
                        })(Oe.setValueAtTime), Oe.setValueCurveAtTime = (Ee => D ? () => {
                            throw s()
                        } : (...Ce) => {
                            const De = Ee.apply(Oe, Ce);
                            return ae(), De
                        })(Oe.setValueCurveAtTime), Oe
                    };
                return {
                    forwardX: ge(0, 0, Z(0)),
                    forwardY: ge(1, 0, Z(1)),
                    forwardZ: ge(2, -1, Z(2)),
                    positionX: ge(6, 0, fe(0)),
                    positionY: ge(7, 0, fe(1)),
                    positionZ: ge(8, 0, fe(2)),
                    upX: ge(3, 0, Z(3)),
                    upY: ge(4, 1, Z(4)),
                    upZ: ge(5, 0, Z(5))
                }
            },
            {
                forwardX: p,
                forwardY: _,
                forwardZ: v,
                positionX: y,
                positionY: g,
                positionZ: b,
                upX: O,
                upY: N,
                upZ: k
            } = f.forwardX === void 0 ? d() : f;
        return {
            get forwardX() {
                return p
            },
            get forwardY() {
                return _
            },
            get forwardZ() {
                return v
            },
            get positionX() {
                return y
            },
            get positionY() {
                return g
            },
            get positionZ() {
                return b
            },
            get upX() {
                return O
            },
            get upY() {
                return N
            },
            get upZ() {
                return k
            }
        }
    },
    C1 = t => "context" in t,
    Qf = t => C1(t[0]),
    Lc = (t, e, n, r) => {
        for (const s of t)
            if (n(s)) {
                if (r) return !1;
                throw Error("The set contains at least one similar element.")
            } return t.add(e), !0
    },
    Mw = (t, e, [n, r], s) => {
        Lc(t, [e, n, r], i => i[0] === e && i[1] === n, s)
    },
    Dw = (t, [e, n, r], s) => {
        const i = t.get(e);
        i === void 0 ? t.set(e, new Set([
            [n, r]
        ])) : Lc(i, [n, r], o => o[0] === n, s)
    },
    Mu = t => "inputs" in t,
    k1 = (t, e, n, r) => {
        if (Mu(e)) {
            const s = e.inputs[r];
            return t.connect(s, n, 0), [s, n, 0]
        }
        return t.connect(e, n, r), [e, n, r]
    },
    BC = (t, e, n) => {
        for (const r of t)
            if (r[0] === e && r[1] === n) return t.delete(r), r;
        return null
    },
    Y3e = (t, e, n) => bg(t, r => r[0] === e && r[1] === n),
    qC = (t, e) => {
        if (!Kf(t).delete(e)) throw new Error("Missing the expected event listener.")
    },
    GC = (t, e, n) => {
        const r = Xs(t, e),
            s = bg(r, i => i[0] === n);
        return r.size === 0 && t.delete(e), s
    },
    I1 = (t, e, n, r) => {
        Mu(e) ? t.disconnect(e.inputs[r], n, 0) : t.disconnect(e, n, r)
    },
    on = t => Xs(X3, t),
    tf = t => Xs(Q3, t),
    Ac = t => Tv.has(t),
    Vp = t => !eu.has(t),
    $w = (t, e) => new Promise(n => {
        if (e !== null) n(!0);
        else {
            const r = t.createScriptProcessor(256, 1, 1),
                s = t.createGain(),
                i = t.createBuffer(1, 2, 44100),
                o = i.getChannelData(0);
            o[0] = 1, o[1] = 1;
            const a = t.createBufferSource();
            a.buffer = i, a.loop = !0, a.connect(r).connect(t.destination), a.connect(s), a.disconnect(s), r.onaudioprocess = l => {
                const u = l.inputBuffer.getChannelData(0);
                Array.prototype.some.call(u, f => f === 1) ? n(!0) : n(!1), a.stop(), r.onaudioprocess = null, a.disconnect(r), r.disconnect(t.destination)
            }, a.start()
        }
    }),
    Ky = (t, e) => {
        const n = new Map;
        for (const r of t)
            for (const s of r) {
                const i = n.get(s);
                n.set(s, i === void 0 ? 1 : i + 1)
            }
        n.forEach((r, s) => e(s, r))
    },
    N1 = t => "context" in t,
    z3e = t => {
        const e = new Map;
        t.connect = (n => (r, s = 0, i = 0) => {
            const o = N1(r) ? n(r, s, i) : n(r, s),
                a = e.get(r);
            return a === void 0 ? e.set(r, [{
                input: i,
                output: s
            }]) : a.every(l => l.input !== i || l.output !== s) && a.push({
                input: i,
                output: s
            }), o
        })(t.connect.bind(t)), t.disconnect = (n => (r, s, i) => {
            if (n.apply(t), r === void 0) e.clear();
            else if (typeof r == "number")
                for (const [o, a] of e) {
                    const l = a.filter(u => u.output !== r);
                    l.length === 0 ? e.delete(o) : e.set(o, l)
                } else if (e.has(r))
                    if (s === void 0) e.delete(r);
                    else {
                        const o = e.get(r);
                        if (o !== void 0) {
                            const a = o.filter(l => l.output !== s && (l.input !== i || i === void 0));
                            a.length === 0 ? e.delete(r) : e.set(r, a)
                        }
                    } for (const [o, a] of e) a.forEach(l => {
                N1(o) ? t.connect(o, l.output, l.input) : t.connect(o, l.output)
            })
        })(t.disconnect)
    },
    K3e = (t, e, n, r) => {
        const {
            activeInputs: s,
            passiveInputs: i
        } = Xf(e), {
            outputs: o
        } = Tr(t), a = Kf(t), l = u => {
            const f = on(t),
                d = tf(e);
            if (u) {
                const p = GC(i, t, n);
                Mw(s, t, p, !1), !r && !Ac(t) && f.connect(d, n)
            } else {
                const p = Y3e(s, t, n);
                Dw(i, p, !1), !r && !Ac(t) && f.disconnect(d, n)
            }
        };
        return Lc(o, [e, n], u => u[0] === e && u[1] === n, !0) ? (a.add(l), uo(t) ? Mw(s, t, [n, l], !0) : Dw(i, [t, n, l], !0), !0) : !1
    },
    Z3e = (t, e, n, r) => {
        const {
            activeInputs: s,
            passiveInputs: i
        } = Tr(e), o = BC(s[r], t, n);
        return o === null ? [$C(i, t, n, r)[2], !1] : [o[2], !0]
    },
    X3e = (t, e, n) => {
        const {
            activeInputs: r,
            passiveInputs: s
        } = Xf(e), i = BC(r, t, n);
        return i === null ? [GC(s, t, n)[1], !1] : [i[2], !0]
    },
    eb = (t, e, n, r, s) => {
        const [i, o] = Z3e(t, n, r, s);
        if (i !== null && (qC(t, i), o && !e && !Ac(t) && I1(on(t), on(n), r, s)), uo(n)) {
            const {
                activeInputs: a
            } = Tr(n);
            Av(n, a)
        }
    },
    tb = (t, e, n, r) => {
        const [s, i] = X3e(t, n, r);
        s !== null && (qC(t, s), i && !e && !Ac(t) && on(t).disconnect(tf(n), r))
    },
    Q3e = (t, e) => {
        const n = Tr(t),
            r = [];
        for (const s of n.outputs) Qf(s) ? eb(t, e, ...s) : tb(t, e, ...s), r.push(s[0]);
        return n.outputs.clear(), r
    },
    J3e = (t, e, n) => {
        const r = Tr(t),
            s = [];
        for (const i of r.outputs) i[1] === n && (Qf(i) ? eb(t, e, ...i) : tb(t, e, ...i), s.push(i[0]), r.outputs.delete(i));
        return s
    },
    ebe = (t, e, n, r, s) => {
        const i = Tr(t);
        return Array.from(i.outputs).filter(o => o[0] === n && (r === void 0 || o[1] === r) && (s === void 0 || o[2] === s)).map(o => (Qf(o) ? eb(t, e, ...o) : tb(t, e, ...o), i.outputs.delete(o), o[0]))
    },
    tbe = (t, e, n, r, s, i, o, a, l, u, f, d, p, _, v, y) => class extends u {
        constructor(b, O, N, k) {
            super(N), this._context = b, this._nativeAudioNode = N;
            const A = f(b);
            d(A) && n($w, () => $w(A, y)) !== !0 && z3e(N), X3.set(this, N), MC.set(this, new Set), b.state !== "closed" && O && tu(this), t(this, k, N)
        }
        get channelCount() {
            return this._nativeAudioNode.channelCount
        }
        set channelCount(b) {
            this._nativeAudioNode.channelCount = b
        }
        get channelCountMode() {
            return this._nativeAudioNode.channelCountMode
        }
        set channelCountMode(b) {
            this._nativeAudioNode.channelCountMode = b
        }
        get channelInterpretation() {
            return this._nativeAudioNode.channelInterpretation
        }
        set channelInterpretation(b) {
            this._nativeAudioNode.channelInterpretation = b
        }
        get context() {
            return this._context
        }
        get numberOfInputs() {
            return this._nativeAudioNode.numberOfInputs
        }
        get numberOfOutputs() {
            return this._nativeAudioNode.numberOfOutputs
        }
        connect(b, O = 0, N = 0) {
            if (O < 0 || O >= this._nativeAudioNode.numberOfOutputs) throw s();
            const k = f(this._context),
                A = v(k);
            if (p(b) || _(b)) throw i();
            if (C1(b)) {
                const L = on(b);
                try {
                    const ee = k1(this._nativeAudioNode, L, O, N),
                        ae = Vp(this);
                    (A || ae) && this._nativeAudioNode.disconnect(...ee), this.context.state !== "closed" && !ae && Vp(b) && tu(b)
                } catch (ee) {
                    throw ee.code === 12 ? i() : ee
                }
                if (e(this, b, O, N, A)) {
                    const ee = l([this], b);
                    Ky(ee, r(A))
                }
                return b
            }
            const x = tf(b);
            if (x.name === "playbackRate" && x.maxValue === 1024) throw o();
            try {
                this._nativeAudioNode.connect(x, O), (A || Vp(this)) && this._nativeAudioNode.disconnect(x, O)
            } catch (L) {
                throw L.code === 12 ? i() : L
            }
            if (K3e(this, b, O, A)) {
                const L = l([this], b);
                Ky(L, r(A))
            }
        }
        disconnect(b, O, N) {
            let k;
            const A = f(this._context),
                x = v(A);
            if (b === void 0) k = Q3e(this, x);
            else if (typeof b == "number") {
                if (b < 0 || b >= this.numberOfOutputs) throw s();
                k = J3e(this, x, b)
            } else {
                if (O !== void 0 && (O < 0 || O >= this.numberOfOutputs) || C1(b) && N !== void 0 && (N < 0 || N >= b.numberOfInputs)) throw s();
                if (k = ebe(this, x, b, O, N), k.length === 0) throw i()
            }
            for (const D of k) {
                const L = l([this], D);
                Ky(L, a)
            }
        }
    },
    nbe = (t, e, n, r, s, i, o, a, l, u, f, d, p) => (_, v, y, g = null, b = null) => {
        const O = new f3e(y.defaultValue),
            N = v ? r(O) : null,
            k = {
                get defaultValue() {
                    return y.defaultValue
                },
                get maxValue() {
                    return g === null ? y.maxValue : g
                },
                get minValue() {
                    return b === null ? y.minValue : b
                },
                get value() {
                    return y.value
                },
                set value(A) {
                    y.value = A, k.setValueAtTime(A, _.context.currentTime)
                },
                cancelAndHoldAtTime(A) {
                    if (typeof y.cancelAndHoldAtTime == "function") N === null && O.flush(_.context.currentTime), O.add(s(A)), y.cancelAndHoldAtTime(A);
                    else {
                        const x = Array.from(O).pop();
                        N === null && O.flush(_.context.currentTime), O.add(s(A));
                        const D = Array.from(O).pop();
                        y.cancelScheduledValues(A), x !== D && D !== void 0 && (D.type === "exponentialRampToValue" ? y.exponentialRampToValueAtTime(D.value, D.endTime) : D.type === "linearRampToValue" ? y.linearRampToValueAtTime(D.value, D.endTime) : D.type === "setValue" ? y.setValueAtTime(D.value, D.startTime) : D.type === "setValueCurve" && y.setValueCurveAtTime(D.values, D.startTime, D.duration))
                    }
                    return k
                },
                cancelScheduledValues(A) {
                    return N === null && O.flush(_.context.currentTime), O.add(i(A)), y.cancelScheduledValues(A), k
                },
                exponentialRampToValueAtTime(A, x) {
                    if (A === 0) throw new RangeError;
                    if (!Number.isFinite(x) || x < 0) throw new RangeError;
                    return N === null && O.flush(_.context.currentTime), O.add(o(A, x)), y.exponentialRampToValueAtTime(A, x), k
                },
                linearRampToValueAtTime(A, x) {
                    return N === null && O.flush(_.context.currentTime), O.add(a(A, x)), y.linearRampToValueAtTime(A, x), k
                },
                setTargetAtTime(A, x, D) {
                    return N === null && O.flush(_.context.currentTime), O.add(l(A, x, D)), y.setTargetAtTime(A, x, D), k
                },
                setValueAtTime(A, x) {
                    return N === null && O.flush(_.context.currentTime), O.add(u(A, x)), y.setValueAtTime(A, x), k
                },
                setValueCurveAtTime(A, x, D) {
                    const L = A instanceof Float32Array ? A : new Float32Array(A);
                    if (d !== null && d.name === "webkitAudioContext") {
                        const q = x + D,
                            ee = _.context.sampleRate,
                            ae = Math.ceil(x * ee),
                            Z = Math.floor(q * ee),
                            fe = Z - ae,
                            ge = new Float32Array(fe);
                        for (let Q = 0; Q < fe; Q += 1) {
                            const ue = (L.length - 1) / D * ((ae + Q) / ee - x),
                                _e = Math.floor(ue),
                                Oe = Math.ceil(ue);
                            ge[Q] = _e === Oe ? L[_e] : (1 - (ue - _e)) * L[_e] + (1 - (Oe - ue)) * L[Oe]
                        }
                        N === null && O.flush(_.context.currentTime), O.add(f(ge, x, D)), y.setValueCurveAtTime(ge, x, D);
                        const K = Z / ee;
                        K < q && p(k, ge[ge.length - 1], K), p(k, L[L.length - 1], q)
                    } else N === null && O.flush(_.context.currentTime), O.add(f(L, x, D)), y.setValueCurveAtTime(L, x, D);
                    return k
                }
            };
        return n.set(k, y), e.set(k, _), t(k, N), k
    },
    rbe = t => ({
        replay(e) {
            for (const n of t)
                if (n.type === "exponentialRampToValue") {
                    const {
                        endTime: r,
                        value: s
                    } = n;
                    e.exponentialRampToValueAtTime(s, r)
                } else if (n.type === "linearRampToValue") {
                const {
                    endTime: r,
                    value: s
                } = n;
                e.linearRampToValueAtTime(s, r)
            } else if (n.type === "setTarget") {
                const {
                    startTime: r,
                    target: s,
                    timeConstant: i
                } = n;
                e.setTargetAtTime(s, r, i)
            } else if (n.type === "setValue") {
                const {
                    startTime: r,
                    value: s
                } = n;
                e.setValueAtTime(s, r)
            } else if (n.type === "setValueCurve") {
                const {
                    duration: r,
                    startTime: s,
                    values: i
                } = n;
                e.setValueCurveAtTime(i, s, r)
            } else throw new Error("Can't apply an unknown automation.")
        }
    });
class VC {
    constructor(e) {
        this._map = new Map(e)
    }
    get size() {
        return this._map.size
    }
    entries() {
        return this._map.entries()
    }
    forEach(e, n = null) {
        return this._map.forEach((r, s) => e.call(n, r, s, this))
    }
    get(e) {
        return this._map.get(e)
    }
    has(e) {
        return this._map.has(e)
    }
    keys() {
        return this._map.keys()
    }
    values() {
        return this._map.values()
    }
}
const sbe = {
        channelCount: 2,
        channelCountMode: "explicit",
        channelInterpretation: "speakers",
        numberOfInputs: 1,
        numberOfOutputs: 1,
        parameterData: {},
        processorOptions: {}
    },
    ibe = (t, e, n, r, s, i, o, a, l, u, f, d, p, _) => class extends e {
        constructor(y, g, b) {
            var O;
            const N = a(y),
                k = l(N),
                A = f({
                    ...sbe,
                    ...b
                });
            p(A);
            const x = Sv.get(N),
                D = x == null ? void 0 : x.get(g),
                L = k || N.state !== "closed" ? N : (O = o(N)) !== null && O !== void 0 ? O : N,
                q = s(L, k ? null : y.baseLatency, u, g, D, A),
                ee = k ? r(g, A, D) : null;
            super(y, !0, q, ee);
            const ae = [];
            q.parameters.forEach((fe, ge) => {
                const K = n(this, k, fe);
                ae.push([ge, K])
            }), this._nativeAudioWorkletNode = q, this._onprocessorerror = null, this._parameters = new VC(ae), k && t(N, this);
            const {
                activeInputs: Z
            } = i(this);
            d(q, Z)
        }
        get onprocessorerror() {
            return this._onprocessorerror
        }
        set onprocessorerror(y) {
            const g = typeof y == "function" ? _(this, y) : null;
            this._nativeAudioWorkletNode.onprocessorerror = g;
            const b = this._nativeAudioWorkletNode.onprocessorerror;
            this._onprocessorerror = b !== null && b === g ? y : b
        }
        get parameters() {
            return this._parameters === null ? this._nativeAudioWorkletNode.parameters : this._parameters
        }
        get port() {
            return this._nativeAudioWorkletNode.port
        }
    };

function x1(t, e, n, r, s) {
    if (typeof t.copyFromChannel == "function") e[n].byteLength === 0 && (e[n] = new Float32Array(128)), t.copyFromChannel(e[n], r, s);
    else {
        const i = t.getChannelData(r);
        if (e[n].byteLength === 0) e[n] = i.slice(s, s + 128);
        else {
            const o = new Float32Array(i.buffer, s * Float32Array.BYTES_PER_ELEMENT, 128);
            e[n].set(o)
        }
    }
}
const jC = (t, e, n, r, s) => {
        typeof t.copyToChannel == "function" ? e[n].byteLength !== 0 && t.copyToChannel(e[n], r, s) : e[n].byteLength !== 0 && t.getChannelData(r).set(e[n], s)
    },
    P1 = (t, e) => {
        const n = [];
        for (let r = 0; r < t; r += 1) {
            const s = [],
                i = typeof e == "number" ? e : e[r];
            for (let o = 0; o < i; o += 1) s.push(new Float32Array(128));
            n.push(s)
        }
        return n
    },
    obe = (t, e) => {
        const n = Xs(wv, t),
            r = on(e);
        return Xs(n, r)
    },
    abe = async (t, e, n, r, s, i, o) => {
        const a = e === null ? Math.ceil(t.context.length / 128) * 128 : e.length,
            l = r.channelCount * r.numberOfInputs,
            u = s.reduce((g, b) => g + b, 0),
            f = u === 0 ? null : n.createBuffer(u, a, n.sampleRate);
        if (i === void 0) throw new Error("Missing the processor constructor.");
        const d = Tr(t),
            p = await obe(n, t),
            _ = P1(r.numberOfInputs, r.channelCount),
            v = P1(r.numberOfOutputs, s),
            y = Array.from(t.parameters.keys()).reduce((g, b) => ({
                ...g,
                [b]: new Float32Array(128)
            }), {});
        for (let g = 0; g < a; g += 128) {
            if (r.numberOfInputs > 0 && e !== null)
                for (let b = 0; b < r.numberOfInputs; b += 1)
                    for (let O = 0; O < r.channelCount; O += 1) x1(e, _[b], O, O, g);
            i.parameterDescriptors !== void 0 && e !== null && i.parameterDescriptors.forEach(({
                name: b
            }, O) => {
                x1(e, y, b, l + O, g)
            });
            for (let b = 0; b < r.numberOfInputs; b += 1)
                for (let O = 0; O < s[b]; O += 1) v[b][O].byteLength === 0 && (v[b][O] = new Float32Array(128));
            try {
                const b = _.map((N, k) => d.activeInputs[k].size === 0 ? [] : N),
                    O = o(g / n.sampleRate, n.sampleRate, () => p.process(b, v, y));
                if (f !== null)
                    for (let N = 0, k = 0; N < r.numberOfOutputs; N += 1) {
                        for (let A = 0; A < s[N]; A += 1) jC(f, v[N], A, k + A, g);
                        k += s[N]
                    }
                if (!O) break
            } catch (b) {
                t.dispatchEvent(new ErrorEvent("processorerror", {
                    colno: b.colno,
                    filename: b.filename,
                    lineno: b.lineno,
                    message: b.message
                }));
                break
            }
        }
        return f
    }, cbe = (t, e, n, r, s, i, o, a, l, u, f, d, p, _, v, y) => (g, b, O) => {
        const N = new WeakMap;
        let k = null;
        const A = async (x, D) => {
            let L = f(x),
                q = null;
            const ee = mr(L, D),
                ae = Array.isArray(b.outputChannelCount) ? b.outputChannelCount : Array.from(b.outputChannelCount);
            if (d === null) {
                const Z = ae.reduce((Q, ue) => Q + ue, 0),
                    fe = s(D, {
                        channelCount: Math.max(1, Z),
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        numberOfOutputs: Math.max(1, Z)
                    }),
                    ge = [];
                for (let Q = 0; Q < x.numberOfOutputs; Q += 1) ge.push(r(D, {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers",
                    numberOfInputs: ae[Q]
                }));
                const K = o(D, {
                    channelCount: b.channelCount,
                    channelCountMode: b.channelCountMode,
                    channelInterpretation: b.channelInterpretation,
                    gain: 1
                });
                K.connect = e.bind(null, ge), K.disconnect = l.bind(null, ge), q = [fe, ge, K]
            } else ee || (L = new d(D, g));
            if (N.set(D, q === null ? L : q[2]), q !== null) {
                if (k === null) {
                    if (O === void 0) throw new Error("Missing the processor constructor.");
                    if (p === null) throw new Error("Missing the native OfflineAudioContext constructor.");
                    const ue = x.channelCount * x.numberOfInputs,
                        _e = O.parameterDescriptors === void 0 ? 0 : O.parameterDescriptors.length,
                        Oe = ue + _e;
                    k = abe(x, Oe === 0 ? null : await (async () => {
                        const Ce = new p(Oe, Math.ceil(x.context.length / 128) * 128, D.sampleRate),
                            De = [],
                            Ue = [];
                        for (let Ze = 0; Ze < b.numberOfInputs; Ze += 1) De.push(o(Ce, {
                            channelCount: b.channelCount,
                            channelCountMode: b.channelCountMode,
                            channelInterpretation: b.channelInterpretation,
                            gain: 1
                        })), Ue.push(s(Ce, {
                            channelCount: b.channelCount,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            numberOfOutputs: b.channelCount
                        }));
                        const ot = await Promise.all(Array.from(x.parameters.values()).map(async Ze => {
                                const it = i(Ce, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "discrete",
                                    offset: Ze.value
                                });
                                return await _(Ce, Ze, it.offset), it
                            })),
                            je = r(Ce, {
                                channelCount: 1,
                                channelCountMode: "explicit",
                                channelInterpretation: "speakers",
                                numberOfInputs: Math.max(1, ue + _e)
                            });
                        for (let Ze = 0; Ze < b.numberOfInputs; Ze += 1) {
                            De[Ze].connect(Ue[Ze]);
                            for (let it = 0; it < b.channelCount; it += 1) Ue[Ze].connect(je, it, Ze * b.channelCount + it)
                        }
                        for (const [Ze, it] of ot.entries()) it.connect(je, 0, ue + Ze), it.start(0);
                        return je.connect(Ce.destination), await Promise.all(De.map(Ze => v(x, Ce, Ze))), y(Ce)
                    })(), D, b, ae, O, u)
                }
                const Z = await k,
                    fe = n(D, {
                        buffer: null,
                        channelCount: 2,
                        channelCountMode: "max",
                        channelInterpretation: "speakers",
                        loop: !1,
                        loopEnd: 0,
                        loopStart: 0,
                        playbackRate: 1
                    }),
                    [ge, K, Q] = q;
                Z !== null && (fe.buffer = Z, fe.start(0)), fe.connect(ge);
                for (let ue = 0, _e = 0; ue < x.numberOfOutputs; ue += 1) {
                    const Oe = K[ue];
                    for (let Ee = 0; Ee < ae[ue]; Ee += 1) ge.connect(Oe, _e + Ee, Ee);
                    _e += ae[ue]
                }
                return Q
            }
            if (ee)
                for (const [Z, fe] of x.parameters.entries()) await t(D, fe, L.parameters.get(Z));
            else
                for (const [Z, fe] of x.parameters.entries()) await _(D, fe, L.parameters.get(Z));
            return await v(x, D, L), L
        };
        return {
            render(x, D) {
                a(D, x);
                const L = N.get(D);
                return L !== void 0 ? Promise.resolve(L) : A(x, D)
            }
        }
    }, lbe = (t, e, n, r, s, i, o, a, l, u, f, d, p, _, v, y, g, b, O, N) => class extends v {
        constructor(A, x) {
            super(A, x), this._nativeContext = A, this._audioWorklet = t === void 0 ? void 0 : {
                addModule: (D, L) => t(this, D, L)
            }
        }
        get audioWorklet() {
            return this._audioWorklet
        }
        createAnalyser() {
            return new e(this)
        }
        createBiquadFilter() {
            return new s(this)
        }
        createBuffer(A, x, D) {
            return new n({
                length: x,
                numberOfChannels: A,
                sampleRate: D
            })
        }
        createBufferSource() {
            return new r(this)
        }
        createChannelMerger(A = 6) {
            return new i(this, {
                numberOfInputs: A
            })
        }
        createChannelSplitter(A = 6) {
            return new o(this, {
                numberOfOutputs: A
            })
        }
        createConstantSource() {
            return new a(this)
        }
        createConvolver() {
            return new l(this)
        }
        createDelay(A = 1) {
            return new f(this, {
                maxDelayTime: A
            })
        }
        createDynamicsCompressor() {
            return new d(this)
        }
        createGain() {
            return new p(this)
        }
        createIIRFilter(A, x) {
            return new _(this, {
                feedback: x,
                feedforward: A
            })
        }
        createOscillator() {
            return new y(this)
        }
        createPanner() {
            return new g(this)
        }
        createPeriodicWave(A, x, D = {
            disableNormalization: !1
        }) {
            return new b(this, {
                ...D,
                imag: x,
                real: A
            })
        }
        createStereoPanner() {
            return new O(this)
        }
        createWaveShaper() {
            return new N(this)
        }
        decodeAudioData(A, x, D) {
            return u(this._nativeContext, A).then(L => (typeof x == "function" && x(L), L), L => {
                throw typeof D == "function" && D(L), L
            })
        }
    }, ube = {
        Q: 1,
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        detune: 0,
        frequency: 350,
        gain: 0,
        type: "lowpass"
    }, hbe = (t, e, n, r, s, i, o, a) => class extends t {
        constructor(u, f) {
            const d = i(u),
                p = {
                    ...ube,
                    ...f
                },
                _ = s(d, p),
                v = o(d),
                y = v ? n() : null;
            super(u, !1, _, y), this._Q = e(this, v, _.Q, Er, Rr), this._detune = e(this, v, _.detune, 1200 * Math.log2(Er), -1200 * Math.log2(Er)), this._frequency = e(this, v, _.frequency, u.sampleRate / 2, 0), this._gain = e(this, v, _.gain, 40 * Math.log10(Er), Rr), this._nativeBiquadFilterNode = _, a(this, 1)
        }
        get detune() {
            return this._detune
        }
        get frequency() {
            return this._frequency
        }
        get gain() {
            return this._gain
        }
        get Q() {
            return this._Q
        }
        get type() {
            return this._nativeBiquadFilterNode.type
        }
        set type(u) {
            this._nativeBiquadFilterNode.type = u
        }
        getFrequencyResponse(u, f, d) {
            try {
                this._nativeBiquadFilterNode.getFrequencyResponse(u, f, d)
            } catch (p) {
                throw p.code === 11 ? r() : p
            }
            if (u.length !== f.length || f.length !== d.length) throw r()
        }
    }, fbe = (t, e, n, r, s) => () => {
        const i = new WeakMap,
            o = async (a, l) => {
                let u = n(a);
                const f = mr(u, l);
                if (!f) {
                    const d = {
                        Q: u.Q.value,
                        channelCount: u.channelCount,
                        channelCountMode: u.channelCountMode,
                        channelInterpretation: u.channelInterpretation,
                        detune: u.detune.value,
                        frequency: u.frequency.value,
                        gain: u.gain.value,
                        type: u.type
                    };
                    u = e(l, d)
                }
                return i.set(l, u), f ? (await t(l, a.Q, u.Q), await t(l, a.detune, u.detune), await t(l, a.frequency, u.frequency), await t(l, a.gain, u.gain)) : (await r(l, a.Q, u.Q), await r(l, a.detune, u.detune), await r(l, a.frequency, u.frequency), await r(l, a.gain, u.gain)), await s(a, l, u), u
            };
        return {
            render(a, l) {
                const u = i.get(l);
                return u !== void 0 ? Promise.resolve(u) : o(a, l)
            }
        }
    }, dbe = (t, e) => (n, r) => {
        const s = e.get(n);
        if (s !== void 0) return s;
        const i = t.get(n);
        if (i !== void 0) return i;
        try {
            const o = r();
            return o instanceof Promise ? (t.set(n, o), o.catch(() => !1).then(a => (t.delete(n), e.set(n, a), a))) : (e.set(n, o), o)
        } catch {
            return e.set(n, !1), !1
        }
    }, pbe = {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "speakers",
        numberOfInputs: 6
    }, mbe = (t, e, n, r, s) => class extends t {
        constructor(o, a) {
            const l = r(o),
                u = {
                    ...pbe,
                    ...a
                },
                f = n(l, u),
                d = s(l) ? e() : null;
            super(o, !1, f, d)
        }
    }, gbe = (t, e, n) => () => {
        const r = new WeakMap,
            s = async (i, o) => {
                let a = e(i);
                if (!mr(a, o)) {
                    const u = {
                        channelCount: a.channelCount,
                        channelCountMode: a.channelCountMode,
                        channelInterpretation: a.channelInterpretation,
                        numberOfInputs: a.numberOfInputs
                    };
                    a = t(o, u)
                }
                return r.set(o, a), await n(i, o, a), a
            };
        return {
            render(i, o) {
                const a = r.get(o);
                return a !== void 0 ? Promise.resolve(a) : s(i, o)
            }
        }
    }, _be = {
        channelCount: 6,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        numberOfOutputs: 6
    }, ybe = (t, e, n, r, s, i) => class extends t {
        constructor(a, l) {
            const u = r(a),
                f = i({
                    ..._be,
                    ...l
                }),
                d = n(u, f),
                p = s(u) ? e() : null;
            super(a, !1, d, p)
        }
    }, vbe = (t, e, n) => () => {
        const r = new WeakMap,
            s = async (i, o) => {
                let a = e(i);
                if (!mr(a, o)) {
                    const u = {
                        channelCount: a.channelCount,
                        channelCountMode: a.channelCountMode,
                        channelInterpretation: a.channelInterpretation,
                        numberOfOutputs: a.numberOfOutputs
                    };
                    a = t(o, u)
                }
                return r.set(o, a), await n(i, o, a), a
            };
        return {
            render(i, o) {
                const a = r.get(o);
                return a !== void 0 ? Promise.resolve(a) : s(i, o)
            }
        }
    }, bbe = t => (e, n, r) => t(n, e, r), Ebe = t => (e, n, r = 0, s = 0) => {
        const i = e[r];
        if (i === void 0) throw t();
        return N1(n) ? i.connect(n, 0, s) : i.connect(n, 0)
    }, Tbe = t => (e, n) => {
        const r = t(e, {
                buffer: null,
                channelCount: 2,
                channelCountMode: "max",
                channelInterpretation: "speakers",
                loop: !1,
                loopEnd: 0,
                loopStart: 0,
                playbackRate: 1
            }),
            s = e.createBuffer(1, 2, 44100);
        return r.buffer = s, r.loop = !0, r.connect(n), r.start(), () => {
            r.stop(), r.disconnect(n)
        }
    }, Sbe = {
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        offset: 1
    }, wbe = (t, e, n, r, s, i, o) => class extends t {
        constructor(l, u) {
            const f = s(l),
                d = {
                    ...Sbe,
                    ...u
                },
                p = r(f, d),
                _ = i(f),
                v = _ ? n() : null;
            super(l, !1, p, v), this._constantSourceNodeRenderer = v, this._nativeConstantSourceNode = p, this._offset = e(this, _, p.offset, Er, Rr), this._onended = null
        }
        get offset() {
            return this._offset
        }
        get onended() {
            return this._onended
        }
        set onended(l) {
            const u = typeof l == "function" ? o(this, l) : null;
            this._nativeConstantSourceNode.onended = u;
            const f = this._nativeConstantSourceNode.onended;
            this._onended = f !== null && f === u ? l : f
        }
        start(l = 0) {
            if (this._nativeConstantSourceNode.start(l), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.start = l), this.context.state !== "closed") {
                tu(this);
                const u = () => {
                    this._nativeConstantSourceNode.removeEventListener("ended", u), uo(this) && Zf(this)
                };
                this._nativeConstantSourceNode.addEventListener("ended", u)
            }
        }
        stop(l = 0) {
            this._nativeConstantSourceNode.stop(l), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.stop = l)
        }
    }, Abe = (t, e, n, r, s) => () => {
        const i = new WeakMap;
        let o = null,
            a = null;
        const l = async (u, f) => {
            let d = n(u);
            const p = mr(d, f);
            if (!p) {
                const _ = {
                    channelCount: d.channelCount,
                    channelCountMode: d.channelCountMode,
                    channelInterpretation: d.channelInterpretation,
                    offset: d.offset.value
                };
                d = e(f, _), o !== null && d.start(o), a !== null && d.stop(a)
            }
            return i.set(f, d), p ? await t(f, u.offset, d.offset) : await r(f, u.offset, d.offset), await s(u, f, d), d
        };
        return {
            set start(u) {
                o = u
            },
            set stop(u) {
                a = u
            },
            render(u, f) {
                const d = i.get(f);
                return d !== void 0 ? Promise.resolve(d) : l(u, f)
            }
        }
    }, Obe = t => e => (t[0] = e, t[0]), Cbe = {
        buffer: null,
        channelCount: 2,
        channelCountMode: "clamped-max",
        channelInterpretation: "speakers",
        disableNormalization: !1
    }, kbe = (t, e, n, r, s, i) => class extends t {
        constructor(a, l) {
            const u = r(a),
                f = {
                    ...Cbe,
                    ...l
                },
                d = n(u, f),
                _ = s(u) ? e() : null;
            super(a, !1, d, _), this._isBufferNullified = !1, this._nativeConvolverNode = d, f.buffer !== null && i(this, f.buffer.duration)
        }
        get buffer() {
            return this._isBufferNullified ? null : this._nativeConvolverNode.buffer
        }
        set buffer(a) {
            if (this._nativeConvolverNode.buffer = a, a === null && this._nativeConvolverNode.buffer !== null) {
                const l = this._nativeConvolverNode.context;
                this._nativeConvolverNode.buffer = l.createBuffer(1, 1, l.sampleRate), this._isBufferNullified = !0, i(this, 0)
            } else this._isBufferNullified = !1, i(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration)
        }
        get normalize() {
            return this._nativeConvolverNode.normalize
        }
        set normalize(a) {
            this._nativeConvolverNode.normalize = a
        }
    }, Ibe = (t, e, n) => () => {
        const r = new WeakMap,
            s = async (i, o) => {
                let a = e(i);
                if (!mr(a, o)) {
                    const u = {
                        buffer: a.buffer,
                        channelCount: a.channelCount,
                        channelCountMode: a.channelCountMode,
                        channelInterpretation: a.channelInterpretation,
                        disableNormalization: !a.normalize
                    };
                    a = t(o, u)
                }
                return r.set(o, a), Mu(a) ? await n(i, o, a.inputs[0]) : await n(i, o, a), a
            };
        return {
            render(i, o) {
                const a = r.get(o);
                return a !== void 0 ? Promise.resolve(a) : s(i, o)
            }
        }
    }, Nbe = (t, e) => (n, r, s) => {
        if (e === null) throw new Error("Missing the native OfflineAudioContext constructor.");
        try {
            return new e(n, r, s)
        } catch (i) {
            throw i.name === "SyntaxError" ? t() : i
        }
    }, xbe = () => new DOMException("", "DataCloneError"), Lw = t => {
        const {
            port1: e,
            port2: n
        } = new MessageChannel;
        return new Promise(r => {
            const s = () => {
                n.onmessage = null, e.close(), n.close(), r()
            };
            n.onmessage = () => s();
            try {
                e.postMessage(t, [t])
            } finally {
                s()
            }
        })
    }, Pbe = (t, e, n, r, s, i, o, a, l, u, f) => (d, p) => {
        const _ = o(d) ? d : i(d);
        if (s.has(p)) {
            const v = n();
            return Promise.reject(v)
        }
        try {
            s.add(p)
        } catch {}
        return e(l, () => l(_)) ? _.decodeAudioData(p).then(v => (Lw(p).catch(() => {}), e(a, () => a(v)) || f(v), t.add(v), v)) : new Promise((v, y) => {
            const g = async () => {
                try {
                    await Lw(p)
                } catch {}
            }, b = O => {
                y(O), g()
            };
            try {
                _.decodeAudioData(p, O => {
                    typeof O.copyFromChannel != "function" && (u(O), J3(O)), t.add(O), g().then(() => v(O))
                }, O => {
                    b(O === null ? r() : O)
                })
            } catch (O) {
                b(O)
            }
        })
    }, Rbe = (t, e, n, r, s, i, o, a) => (l, u) => {
        const f = e.get(l);
        if (f === void 0) throw new Error("Missing the expected cycle count.");
        const d = i(l.context),
            p = a(d);
        if (f === u) {
            if (e.delete(l), !p && o(l)) {
                const _ = r(l),
                    {
                        outputs: v
                    } = n(l);
                for (const y of v)
                    if (Qf(y)) {
                        const g = r(y[0]);
                        t(_, g, y[1], y[2])
                    } else {
                        const g = s(y[0]);
                        _.connect(g, y[1])
                    }
            }
        } else e.set(l, f - u)
    }, Mbe = {
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        delayTime: 0,
        maxDelayTime: 1
    }, Dbe = (t, e, n, r, s, i, o) => class extends t {
        constructor(l, u) {
            const f = s(l),
                d = {
                    ...Mbe,
                    ...u
                },
                p = r(f, d),
                _ = i(f),
                v = _ ? n(d.maxDelayTime) : null;
            super(l, !1, p, v), this._delayTime = e(this, _, p.delayTime), o(this, d.maxDelayTime)
        }
        get delayTime() {
            return this._delayTime
        }
    }, $be = (t, e, n, r, s) => i => {
        const o = new WeakMap,
            a = async (l, u) => {
                let f = n(l);
                const d = mr(f, u);
                if (!d) {
                    const p = {
                        channelCount: f.channelCount,
                        channelCountMode: f.channelCountMode,
                        channelInterpretation: f.channelInterpretation,
                        delayTime: f.delayTime.value,
                        maxDelayTime: i
                    };
                    f = e(u, p)
                }
                return o.set(u, f), d ? await t(u, l.delayTime, f.delayTime) : await r(u, l.delayTime, f.delayTime), await s(l, u, f), f
            };
        return {
            render(l, u) {
                const f = o.get(u);
                return f !== void 0 ? Promise.resolve(f) : a(l, u)
            }
        }
    }, Lbe = t => (e, n, r, s) => t(e[s], i => i[0] === n && i[1] === r), Fbe = t => (e, n) => {
        t(e).delete(n)
    }, Ube = t => "delayTime" in t, Bbe = (t, e, n) => function r(s, i) {
        const o = C1(i) ? i : n(t, i);
        if (Ube(o)) return [];
        if (s[0] === o) return [s];
        if (s.includes(o)) return [];
        const {
            outputs: a
        } = e(o);
        return Array.from(a).map(l => r([...s, o], l[0])).reduce((l, u) => l.concat(u), [])
    }, kp = (t, e, n) => {
        const r = e[n];
        if (r === void 0) throw t();
        return r
    }, qbe = t => (e, n = void 0, r = void 0, s = 0) => n === void 0 ? e.forEach(i => i.disconnect()) : typeof n == "number" ? kp(t, e, n).disconnect() : N1(n) ? r === void 0 ? e.forEach(i => i.disconnect(n)) : s === void 0 ? kp(t, e, r).disconnect(n, 0) : kp(t, e, r).disconnect(n, 0, s) : r === void 0 ? e.forEach(i => i.disconnect(n)) : kp(t, e, r).disconnect(n, 0), Gbe = {
        attack: .003,
        channelCount: 2,
        channelCountMode: "clamped-max",
        channelInterpretation: "speakers",
        knee: 30,
        ratio: 12,
        release: .25,
        threshold: -24
    }, Vbe = (t, e, n, r, s, i, o, a) => class extends t {
        constructor(u, f) {
            const d = i(u),
                p = {
                    ...Gbe,
                    ...f
                },
                _ = r(d, p),
                v = o(d),
                y = v ? n() : null;
            super(u, !1, _, y), this._attack = e(this, v, _.attack), this._knee = e(this, v, _.knee), this._nativeDynamicsCompressorNode = _, this._ratio = e(this, v, _.ratio), this._release = e(this, v, _.release), this._threshold = e(this, v, _.threshold), a(this, .006)
        }
        get attack() {
            return this._attack
        }
        get channelCount() {
            return this._nativeDynamicsCompressorNode.channelCount
        }
        set channelCount(u) {
            const f = this._nativeDynamicsCompressorNode.channelCount;
            if (this._nativeDynamicsCompressorNode.channelCount = u, u > 2) throw this._nativeDynamicsCompressorNode.channelCount = f, s()
        }
        get channelCountMode() {
            return this._nativeDynamicsCompressorNode.channelCountMode
        }
        set channelCountMode(u) {
            const f = this._nativeDynamicsCompressorNode.channelCountMode;
            if (this._nativeDynamicsCompressorNode.channelCountMode = u, u === "max") throw this._nativeDynamicsCompressorNode.channelCountMode = f, s()
        }
        get knee() {
            return this._knee
        }
        get ratio() {
            return this._ratio
        }
        get reduction() {
            return typeof this._nativeDynamicsCompressorNode.reduction.value == "number" ? this._nativeDynamicsCompressorNode.reduction.value : this._nativeDynamicsCompressorNode.reduction
        }
        get release() {
            return this._release
        }
        get threshold() {
            return this._threshold
        }
    }, jbe = (t, e, n, r, s) => () => {
        const i = new WeakMap,
            o = async (a, l) => {
                let u = n(a);
                const f = mr(u, l);
                if (!f) {
                    const d = {
                        attack: u.attack.value,
                        channelCount: u.channelCount,
                        channelCountMode: u.channelCountMode,
                        channelInterpretation: u.channelInterpretation,
                        knee: u.knee.value,
                        ratio: u.ratio.value,
                        release: u.release.value,
                        threshold: u.threshold.value
                    };
                    u = e(l, d)
                }
                return i.set(l, u), f ? (await t(l, a.attack, u.attack), await t(l, a.knee, u.knee), await t(l, a.ratio, u.ratio), await t(l, a.release, u.release), await t(l, a.threshold, u.threshold)) : (await r(l, a.attack, u.attack), await r(l, a.knee, u.knee), await r(l, a.ratio, u.ratio), await r(l, a.release, u.release), await r(l, a.threshold, u.threshold)), await s(a, l, u), u
            };
        return {
            render(a, l) {
                const u = i.get(l);
                return u !== void 0 ? Promise.resolve(u) : o(a, l)
            }
        }
    }, Wbe = () => new DOMException("", "EncodingError"), Hbe = t => e => new Promise((n, r) => {
        if (t === null) {
            r(new SyntaxError);
            return
        }
        const s = t.document.head;
        if (s === null) r(new SyntaxError);
        else {
            const i = t.document.createElement("script"),
                o = new Blob([e], {
                    type: "application/javascript"
                }),
                a = URL.createObjectURL(o),
                l = t.onerror,
                u = () => {
                    t.onerror = l, URL.revokeObjectURL(a)
                };
            t.onerror = (f, d, p, _, v) => {
                if (d === a || d === t.location.href && p === 1 && _ === 1) return u(), r(v), !1;
                if (l !== null) return l(f, d, p, _, v)
            }, i.onerror = () => {
                u(), r(new SyntaxError)
            }, i.onload = () => {
                u(), n()
            }, i.src = a, i.type = "module", s.appendChild(i)
        }
    }), Ybe = t => class {
        constructor(n) {
            this._nativeEventTarget = n, this._listeners = new WeakMap
        }
        addEventListener(n, r, s) {
            if (r !== null) {
                let i = this._listeners.get(r);
                i === void 0 && (i = t(this, r), typeof r == "function" && this._listeners.set(r, i)), this._nativeEventTarget.addEventListener(n, i, s)
            }
        }
        dispatchEvent(n) {
            return this._nativeEventTarget.dispatchEvent(n)
        }
        removeEventListener(n, r, s) {
            const i = r === null ? void 0 : this._listeners.get(r);
            this._nativeEventTarget.removeEventListener(n, i === void 0 ? null : i, s)
        }
    }, zbe = t => (e, n, r) => {
        Object.defineProperties(t, {
            currentFrame: {
                configurable: !0,
                get() {
                    return Math.round(e * n)
                }
            },
            currentTime: {
                configurable: !0,
                get() {
                    return e
                }
            }
        });
        try {
            return r()
        } finally {
            t !== null && (delete t.currentFrame, delete t.currentTime)
        }
    }, Kbe = t => async e => {
        try {
            const n = await fetch(e);
            if (n.ok) return [await n.text(), n.url]
        } catch {}
        throw t()
    }, Zbe = {
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        gain: 1
    }, Xbe = (t, e, n, r, s, i) => class extends t {
        constructor(a, l) {
            const u = s(a),
                f = {
                    ...Zbe,
                    ...l
                },
                d = r(u, f),
                p = i(u),
                _ = p ? n() : null;
            super(a, !1, d, _), this._gain = e(this, p, d.gain, Er, Rr)
        }
        get gain() {
            return this._gain
        }
    }, Qbe = (t, e, n, r, s) => () => {
        const i = new WeakMap,
            o = async (a, l) => {
                let u = n(a);
                const f = mr(u, l);
                if (!f) {
                    const d = {
                        channelCount: u.channelCount,
                        channelCountMode: u.channelCountMode,
                        channelInterpretation: u.channelInterpretation,
                        gain: u.gain.value
                    };
                    u = e(l, d)
                }
                return i.set(l, u), f ? await t(l, a.gain, u.gain) : await r(l, a.gain, u.gain), await s(a, l, u), u
            };
        return {
            render(a, l) {
                const u = i.get(l);
                return u !== void 0 ? Promise.resolve(u) : o(a, l)
            }
        }
    }, Jbe = (t, e) => n => e(t, n), e5e = t => e => {
        const n = t(e);
        if (n.renderer === null) throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
        return n.renderer
    }, t5e = t => e => {
        var n;
        return (n = t.get(e)) !== null && n !== void 0 ? n : 0
    }, n5e = t => e => {
        const n = t(e);
        if (n.renderer === null) throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
        return n.renderer
    }, r5e = t => e => t.get(e), Hn = () => new DOMException("", "InvalidStateError"), s5e = t => e => {
        const n = t.get(e);
        if (n === void 0) throw Hn();
        return n
    }, i5e = (t, e) => n => {
        let r = t.get(n);
        if (r !== void 0) return r;
        if (e === null) throw new Error("Missing the native OfflineAudioContext constructor.");
        return r = new e(1, 1, 44100), t.set(n, r), r
    }, o5e = t => e => {
        const n = t.get(e);
        if (n === void 0) throw new Error("The context has no set of AudioWorkletNodes.");
        return n
    }, Eg = () => new DOMException("", "InvalidAccessError"), a5e = t => {
        t.getFrequencyResponse = (e => (n, r, s) => {
            if (n.length !== r.length || r.length !== s.length) throw Eg();
            return e.call(t, n, r, s)
        })(t.getFrequencyResponse)
    }, c5e = {
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers"
    }, l5e = (t, e, n, r, s, i) => class extends t {
        constructor(a, l) {
            const u = r(a),
                f = s(u),
                d = {
                    ...c5e,
                    ...l
                },
                p = e(u, f ? null : a.baseLatency, d),
                _ = f ? n(d.feedback, d.feedforward) : null;
            super(a, !1, p, _), a5e(p), this._nativeIIRFilterNode = p, i(this, 1)
        }
        getFrequencyResponse(a, l, u) {
            return this._nativeIIRFilterNode.getFrequencyResponse(a, l, u)
        }
    }, WC = (t, e, n, r, s, i, o, a, l, u, f) => {
        const d = u.length;
        let p = a;
        for (let _ = 0; _ < d; _ += 1) {
            let v = n[0] * u[_];
            for (let y = 1; y < s; y += 1) {
                const g = p - y & l - 1;
                v += n[y] * i[g], v -= t[y] * o[g]
            }
            for (let y = s; y < r; y += 1) v += n[y] * i[p - y & l - 1];
            for (let y = s; y < e; y += 1) v -= t[y] * o[p - y & l - 1];
            i[p] = u[_], o[p] = v, p = p + 1 & l - 1, f[_] = v
        }
        return p
    }, u5e = (t, e, n, r) => {
        const s = n instanceof Float64Array ? n : new Float64Array(n),
            i = r instanceof Float64Array ? r : new Float64Array(r),
            o = s.length,
            a = i.length,
            l = Math.min(o, a);
        if (s[0] !== 1) {
            for (let v = 0; v < o; v += 1) i[v] /= s[0];
            for (let v = 1; v < a; v += 1) s[v] /= s[0]
        }
        const u = 32,
            f = new Float32Array(u),
            d = new Float32Array(u),
            p = e.createBuffer(t.numberOfChannels, t.length, t.sampleRate),
            _ = t.numberOfChannels;
        for (let v = 0; v < _; v += 1) {
            const y = t.getChannelData(v),
                g = p.getChannelData(v);
            f.fill(0), d.fill(0), WC(s, o, i, a, l, f, d, 0, u, y, g)
        }
        return p
    }, h5e = (t, e, n, r, s) => (i, o) => {
        const a = new WeakMap;
        let l = null;
        const u = async (f, d) => {
            let p = null,
                _ = e(f);
            const v = mr(_, d);
            if (d.createIIRFilter === void 0 ? p = t(d, {
                    buffer: null,
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    loop: !1,
                    loopEnd: 0,
                    loopStart: 0,
                    playbackRate: 1
                }) : v || (_ = d.createIIRFilter(o, i)), a.set(d, p === null ? _ : p), p !== null) {
                if (l === null) {
                    if (n === null) throw new Error("Missing the native OfflineAudioContext constructor.");
                    const g = new n(f.context.destination.channelCount, f.context.length, d.sampleRate);
                    l = (async () => {
                        await r(f, g, g.destination);
                        const b = await s(g);
                        return u5e(b, d, i, o)
                    })()
                }
                const y = await l;
                return p.buffer = y, p.start(0), p
            }
            return await r(f, d, _), _
        };
        return {
            render(f, d) {
                const p = a.get(d);
                return p !== void 0 ? Promise.resolve(p) : u(f, d)
            }
        }
    }, f5e = (t, e, n, r, s, i) => o => (a, l) => {
        const u = t.get(a);
        if (u === void 0) {
            if (!o && i(a)) {
                const f = r(a),
                    {
                        outputs: d
                    } = n(a);
                for (const p of d)
                    if (Qf(p)) {
                        const _ = r(p[0]);
                        e(f, _, p[1], p[2])
                    } else {
                        const _ = s(p[0]);
                        f.disconnect(_, p[1])
                    }
            }
            t.set(a, l)
        } else t.set(a, u + l)
    }, d5e = (t, e) => n => {
        const r = t.get(n);
        return e(r) || e(n)
    }, p5e = (t, e) => n => t.has(n) || e(n), m5e = (t, e) => n => t.has(n) || e(n), g5e = (t, e) => n => {
        const r = t.get(n);
        return e(r) || e(n)
    }, _5e = t => e => t !== null && e instanceof t, y5e = t => e => t !== null && typeof t.AudioNode == "function" && e instanceof t.AudioNode, v5e = t => e => t !== null && typeof t.AudioParam == "function" && e instanceof t.AudioParam, b5e = (t, e) => n => t(n) || e(n), E5e = t => e => t !== null && e instanceof t, T5e = t => t !== null && t.isSecureContext, S5e = (t, e, n, r) => class extends t {
        constructor(i, o) {
            const a = n(i),
                l = e(a, o);
            if (r(a)) throw TypeError();
            super(i, !0, l, null), this._nativeMediaElementAudioSourceNode = l
        }
        get mediaElement() {
            return this._nativeMediaElementAudioSourceNode.mediaElement
        }
    }, w5e = {
        channelCount: 2,
        channelCountMode: "explicit",
        channelInterpretation: "speakers"
    }, A5e = (t, e, n, r) => class extends t {
        constructor(i, o) {
            const a = n(i);
            if (r(a)) throw new TypeError;
            const l = {
                    ...w5e,
                    ...o
                },
                u = e(a, l);
            super(i, !1, u, null), this._nativeMediaStreamAudioDestinationNode = u
        }
        get stream() {
            return this._nativeMediaStreamAudioDestinationNode.stream
        }
    }, O5e = (t, e, n, r) => class extends t {
        constructor(i, o) {
            const a = n(i),
                l = e(a, o);
            if (r(a)) throw new TypeError;
            super(i, !0, l, null), this._nativeMediaStreamAudioSourceNode = l
        }
        get mediaStream() {
            return this._nativeMediaStreamAudioSourceNode.mediaStream
        }
    }, C5e = (t, e, n) => class extends t {
        constructor(s, i) {
            const o = n(s),
                a = e(o, i);
            super(s, !0, a, null)
        }
    }, k5e = (t, e, n, r, s, i) => class extends n {
        constructor(a, l) {
            super(a), this._nativeContext = a, vg.set(this, a), r(a) && s.set(a, new Set), this._destination = new t(this, l), this._listener = e(this, a), this._onstatechange = null
        }
        get currentTime() {
            return this._nativeContext.currentTime
        }
        get destination() {
            return this._destination
        }
        get listener() {
            return this._listener
        }
        get onstatechange() {
            return this._onstatechange
        }
        set onstatechange(a) {
            const l = typeof a == "function" ? i(this, a) : null;
            this._nativeContext.onstatechange = l;
            const u = this._nativeContext.onstatechange;
            this._onstatechange = u !== null && u === l ? a : u
        }
        get sampleRate() {
            return this._nativeContext.sampleRate
        }
        get state() {
            return this._nativeContext.state
        }
    }, nf = t => {
        const e = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
        try {
            const n = t.decodeAudioData(e.buffer, () => {});
            return n === void 0 ? !1 : (n.catch(() => {}), !0)
        } catch {}
        return !1
    }, I5e = (t, e) => (n, r, s) => {
        const i = new Set;
        return n.connect = (o => (a, l = 0, u = 0) => {
            const f = i.size === 0;
            if (e(a)) return o.call(n, a, l, u), t(i, [a, l, u], d => d[0] === a && d[1] === l && d[2] === u, !0), f && r(), a;
            o.call(n, a, l), t(i, [a, l], d => d[0] === a && d[1] === l, !0), f && r()
        })(n.connect), n.disconnect = (o => (a, l, u) => {
            const f = i.size > 0;
            if (a === void 0) o.apply(n), i.clear();
            else if (typeof a == "number") {
                o.call(n, a);
                for (const p of i) p[1] === a && i.delete(p)
            } else {
                e(a) ? o.call(n, a, l, u) : o.call(n, a, l);
                for (const p of i) p[0] === a && (l === void 0 || p[1] === l) && (u === void 0 || p[2] === u) && i.delete(p)
            }
            const d = i.size === 0;
            f && d && s()
        })(n.disconnect), n
    }, ln = (t, e, n) => {
        const r = e[n];
        r !== void 0 && r !== t[n] && (t[n] = r)
    }, Un = (t, e) => {
        ln(t, e, "channelCount"), ln(t, e, "channelCountMode"), ln(t, e, "channelInterpretation")
    }, Fw = t => typeof t.getFloatTimeDomainData == "function", N5e = t => {
        t.getFloatTimeDomainData = e => {
            const n = new Uint8Array(e.length);
            t.getByteTimeDomainData(n);
            const r = Math.max(n.length, t.fftSize);
            for (let s = 0; s < r; s += 1) e[s] = (n[s] - 128) * .0078125;
            return e
        }
    }, x5e = (t, e) => (n, r) => {
        const s = n.createAnalyser();
        if (Un(s, r), !(r.maxDecibels > r.minDecibels)) throw e();
        return ln(s, r, "fftSize"), ln(s, r, "maxDecibels"), ln(s, r, "minDecibels"), ln(s, r, "smoothingTimeConstant"), t(Fw, () => Fw(s)) || N5e(s), s
    }, P5e = t => t === null ? null : t.hasOwnProperty("AudioBuffer") ? t.AudioBuffer : null, bn = (t, e, n) => {
        const r = e[n];
        r !== void 0 && r !== t[n].value && (t[n].value = r)
    }, R5e = t => {
        t.start = (e => {
            let n = !1;
            return (r = 0, s = 0, i) => {
                if (n) throw Hn();
                e.call(t, r, s, i), n = !0
            }
        })(t.start)
    }, nb = t => {
        t.start = (e => (n = 0, r = 0, s) => {
            if (typeof s == "number" && s < 0 || r < 0 || n < 0) throw new RangeError("The parameters can't be negative.");
            e.call(t, n, r, s)
        })(t.start)
    }, rb = t => {
        t.stop = (e => (n = 0) => {
            if (n < 0) throw new RangeError("The parameter can't be negative.");
            e.call(t, n)
        })(t.stop)
    }, M5e = (t, e, n, r, s, i, o, a, l, u, f) => (d, p) => {
        const _ = d.createBufferSource();
        return Un(_, p), bn(_, p, "playbackRate"), ln(_, p, "buffer"), ln(_, p, "loop"), ln(_, p, "loopEnd"), ln(_, p, "loopStart"), e(n, () => n(d)) || R5e(_), e(r, () => r(d)) || l(_), e(s, () => s(d)) || u(_, d), e(i, () => i(d)) || nb(_), e(o, () => o(d)) || f(_, d), e(a, () => a(d)) || rb(_), t(d, _), _
    }, D5e = t => t === null ? null : t.hasOwnProperty("AudioContext") ? t.AudioContext : t.hasOwnProperty("webkitAudioContext") ? t.webkitAudioContext : null, $5e = (t, e) => (n, r, s) => {
        const i = n.destination;
        if (i.channelCount !== r) try {
            i.channelCount = r
        } catch {}
        s && i.channelCountMode !== "explicit" && (i.channelCountMode = "explicit"), i.maxChannelCount === 0 && Object.defineProperty(i, "maxChannelCount", {
            value: r
        });
        const o = t(n, {
            channelCount: r,
            channelCountMode: i.channelCountMode,
            channelInterpretation: i.channelInterpretation,
            gain: 1
        });
        return e(o, "channelCount", a => () => a.call(o), a => l => {
            a.call(o, l);
            try {
                i.channelCount = l
            } catch (u) {
                if (l > i.maxChannelCount) throw u
            }
        }), e(o, "channelCountMode", a => () => a.call(o), a => l => {
            a.call(o, l), i.channelCountMode = l
        }), e(o, "channelInterpretation", a => () => a.call(o), a => l => {
            a.call(o, l), i.channelInterpretation = l
        }), Object.defineProperty(o, "maxChannelCount", {
            get: () => i.maxChannelCount
        }), o.connect(i), o
    }, L5e = t => t === null ? null : t.hasOwnProperty("AudioWorkletNode") ? t.AudioWorkletNode : null, F5e = t => {
        const {
            port1: e
        } = new MessageChannel;
        try {
            e.postMessage(t)
        } finally {
            e.close()
        }
    }, U5e = (t, e, n, r, s) => (i, o, a, l, u, f) => {
        if (a !== null) try {
            const d = new a(i, l, f),
                p = new Map;
            let _ = null;
            if (Object.defineProperties(d, {
                    channelCount: {
                        get: () => f.channelCount,
                        set: () => {
                            throw t()
                        }
                    },
                    channelCountMode: {
                        get: () => "explicit",
                        set: () => {
                            throw t()
                        }
                    },
                    onprocessorerror: {
                        get: () => _,
                        set: v => {
                            typeof _ == "function" && d.removeEventListener("processorerror", _), _ = typeof v == "function" ? v : null, typeof _ == "function" && d.addEventListener("processorerror", _)
                        }
                    }
                }), d.addEventListener = (v => (...y) => {
                    if (y[0] === "processorerror") {
                        const g = typeof y[1] == "function" ? y[1] : typeof y[1] == "object" && y[1] !== null && typeof y[1].handleEvent == "function" ? y[1].handleEvent : null;
                        if (g !== null) {
                            const b = p.get(y[1]);
                            b !== void 0 ? y[1] = b : (y[1] = O => {
                                O.type === "error" ? (Object.defineProperties(O, {
                                    type: {
                                        value: "processorerror"
                                    }
                                }), g(O)) : g(new ErrorEvent(y[0], {
                                    ...O
                                }))
                            }, p.set(g, y[1]))
                        }
                    }
                    return v.call(d, "error", y[1], y[2]), v.call(d, ...y)
                })(d.addEventListener), d.removeEventListener = (v => (...y) => {
                    if (y[0] === "processorerror") {
                        const g = p.get(y[1]);
                        g !== void 0 && (p.delete(y[1]), y[1] = g)
                    }
                    return v.call(d, "error", y[1], y[2]), v.call(d, y[0], y[1], y[2])
                })(d.removeEventListener), f.numberOfOutputs !== 0) {
                const v = n(i, {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    gain: 0
                });
                return d.connect(v).connect(i.destination), s(d, () => v.disconnect(), () => v.connect(i.destination))
            }
            return d
        } catch (d) {
            throw d.code === 11 ? r() : d
        }
        if (u === void 0) throw r();
        return F5e(f), e(i, o, u, f)
    }, HC = (t, e) => t === null ? 512 : Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(t * e))))), B5e = t => new Promise((e, n) => {
        const {
            port1: r,
            port2: s
        } = new MessageChannel;
        r.onmessage = ({
            data: i
        }) => {
            r.close(), s.close(), e(i)
        }, r.onmessageerror = ({
            data: i
        }) => {
            r.close(), s.close(), n(i)
        }, s.postMessage(t)
    }), q5e = async (t, e) => {
        const n = await B5e(e);
        return new t(n)
    }, G5e = (t, e, n, r) => {
        let s = wv.get(t);
        s === void 0 && (s = new WeakMap, wv.set(t, s));
        const i = q5e(n, r);
        return s.set(e, i), i
    }, V5e = (t, e, n, r, s, i, o, a, l, u, f, d, p) => (_, v, y, g) => {
        if (g.numberOfInputs === 0 && g.numberOfOutputs === 0) throw l();
        const b = Array.isArray(g.outputChannelCount) ? g.outputChannelCount : Array.from(g.outputChannelCount);
        if (b.some(P => P < 1)) throw l();
        if (b.length !== g.numberOfOutputs) throw e();
        if (g.channelCountMode !== "explicit") throw l();
        const O = g.channelCount * g.numberOfInputs,
            N = b.reduce((P, G) => P + G, 0),
            k = y.parameterDescriptors === void 0 ? 0 : y.parameterDescriptors.length;
        if (O + k > 6 || N > 6) throw l();
        const A = new MessageChannel,
            x = [],
            D = [];
        for (let P = 0; P < g.numberOfInputs; P += 1) x.push(o(_, {
            channelCount: g.channelCount,
            channelCountMode: g.channelCountMode,
            channelInterpretation: g.channelInterpretation,
            gain: 1
        })), D.push(s(_, {
            channelCount: g.channelCount,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            numberOfOutputs: g.channelCount
        }));
        const L = [];
        if (y.parameterDescriptors !== void 0)
            for (const {
                    defaultValue: P,
                    maxValue: G,
                    minValue: te,
                    name: le
                }
                of y.parameterDescriptors) {
                const me = i(_, {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    offset: g.parameterData[le] !== void 0 ? g.parameterData[le] : P === void 0 ? 0 : P
                });
                Object.defineProperties(me.offset, {
                    defaultValue: {
                        get: () => P === void 0 ? 0 : P
                    },
                    maxValue: {
                        get: () => G === void 0 ? Er : G
                    },
                    minValue: {
                        get: () => te === void 0 ? Rr : te
                    }
                }), L.push(me)
            }
        const q = r(_, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "speakers",
                numberOfInputs: Math.max(1, O + k)
            }),
            ee = HC(v, _.sampleRate),
            ae = a(_, ee, O + k, Math.max(1, N)),
            Z = s(_, {
                channelCount: Math.max(1, N),
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                numberOfOutputs: Math.max(1, N)
            }),
            fe = [];
        for (let P = 0; P < g.numberOfOutputs; P += 1) fe.push(r(_, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: b[P]
        }));
        for (let P = 0; P < g.numberOfInputs; P += 1) {
            x[P].connect(D[P]);
            for (let G = 0; G < g.channelCount; G += 1) D[P].connect(q, G, P * g.channelCount + G)
        }
        const ge = new VC(y.parameterDescriptors === void 0 ? [] : y.parameterDescriptors.map(({
            name: P
        }, G) => {
            const te = L[G];
            return te.connect(q, 0, O + G), te.start(0), [P, te.offset]
        }));
        q.connect(ae);
        let K = g.channelInterpretation,
            Q = null;
        const ue = g.numberOfOutputs === 0 ? [ae] : fe,
            _e = {
                get bufferSize() {
                    return ee
                },
                get channelCount() {
                    return g.channelCount
                },
                set channelCount(P) {
                    throw n()
                },
                get channelCountMode() {
                    return g.channelCountMode
                },
                set channelCountMode(P) {
                    throw n()
                },
                get channelInterpretation() {
                    return K
                },
                set channelInterpretation(P) {
                    for (const G of x) G.channelInterpretation = P;
                    K = P
                },
                get context() {
                    return ae.context
                },
                get inputs() {
                    return x
                },
                get numberOfInputs() {
                    return g.numberOfInputs
                },
                get numberOfOutputs() {
                    return g.numberOfOutputs
                },
                get onprocessorerror() {
                    return Q
                },
                set onprocessorerror(P) {
                    typeof Q == "function" && _e.removeEventListener("processorerror", Q), Q = typeof P == "function" ? P : null, typeof Q == "function" && _e.addEventListener("processorerror", Q)
                },
                get parameters() {
                    return ge
                },
                get port() {
                    return A.port2
                },
                addEventListener(...P) {
                    return ae.addEventListener(P[0], P[1], P[2])
                },
                connect: t.bind(null, ue),
                disconnect: u.bind(null, ue),
                dispatchEvent(...P) {
                    return ae.dispatchEvent(P[0])
                },
                removeEventListener(...P) {
                    return ae.removeEventListener(P[0], P[1], P[2])
                }
            },
            Oe = new Map;
        A.port1.addEventListener = (P => (...G) => {
            if (G[0] === "message") {
                const te = typeof G[1] == "function" ? G[1] : typeof G[1] == "object" && G[1] !== null && typeof G[1].handleEvent == "function" ? G[1].handleEvent : null;
                if (te !== null) {
                    const le = Oe.get(G[1]);
                    le !== void 0 ? G[1] = le : (G[1] = me => {
                        f(_.currentTime, _.sampleRate, () => te(me))
                    }, Oe.set(te, G[1]))
                }
            }
            return P.call(A.port1, G[0], G[1], G[2])
        })(A.port1.addEventListener), A.port1.removeEventListener = (P => (...G) => {
            if (G[0] === "message") {
                const te = Oe.get(G[1]);
                te !== void 0 && (Oe.delete(G[1]), G[1] = te)
            }
            return P.call(A.port1, G[0], G[1], G[2])
        })(A.port1.removeEventListener);
        let Ee = null;
        Object.defineProperty(A.port1, "onmessage", {
            get: () => Ee,
            set: P => {
                typeof Ee == "function" && A.port1.removeEventListener("message", Ee), Ee = typeof P == "function" ? P : null, typeof Ee == "function" && (A.port1.addEventListener("message", Ee), A.port1.start())
            }
        }), y.prototype.port = A.port1;
        let Ce = null;
        G5e(_, _e, y, g).then(P => Ce = P);
        const Ue = P1(g.numberOfInputs, g.channelCount),
            ot = P1(g.numberOfOutputs, b),
            je = y.parameterDescriptors === void 0 ? [] : y.parameterDescriptors.reduce((P, {
                name: G
            }) => ({
                ...P,
                [G]: new Float32Array(128)
            }), {});
        let Ze = !0;
        const it = () => {
                g.numberOfOutputs > 0 && ae.disconnect(Z);
                for (let P = 0, G = 0; P < g.numberOfOutputs; P += 1) {
                    const te = fe[P];
                    for (let le = 0; le < b[P]; le += 1) Z.disconnect(te, G + le, le);
                    G += b[P]
                }
            },
            w = new Map;
        ae.onaudioprocess = ({
            inputBuffer: P,
            outputBuffer: G
        }) => {
            if (Ce !== null) {
                const te = d(_e);
                for (let le = 0; le < ee; le += 128) {
                    for (let me = 0; me < g.numberOfInputs; me += 1)
                        for (let ve = 0; ve < g.channelCount; ve += 1) x1(P, Ue[me], ve, ve, le);
                    y.parameterDescriptors !== void 0 && y.parameterDescriptors.forEach(({
                        name: me
                    }, ve) => {
                        x1(P, je, me, O + ve, le)
                    });
                    for (let me = 0; me < g.numberOfInputs; me += 1)
                        for (let ve = 0; ve < b[me]; ve += 1) ot[me][ve].byteLength === 0 && (ot[me][ve] = new Float32Array(128));
                    try {
                        const me = Ue.map((de, oe) => {
                            if (te[oe].size > 0) return w.set(oe, ee / 128), de;
                            const Me = w.get(oe);
                            return Me === void 0 ? [] : (de.every(Fe => Fe.every(at => at === 0)) && (Me === 1 ? w.delete(oe) : w.set(oe, Me - 1)), de)
                        });
                        Ze = f(_.currentTime + le / _.sampleRate, _.sampleRate, () => Ce.process(me, ot, je));
                        for (let de = 0, oe = 0; de < g.numberOfOutputs; de += 1) {
                            for (let he = 0; he < b[de]; he += 1) jC(G, ot[de], he, oe + he, le);
                            oe += b[de]
                        }
                    } catch (me) {
                        Ze = !1, _e.dispatchEvent(new ErrorEvent("processorerror", {
                            colno: me.colno,
                            filename: me.filename,
                            lineno: me.lineno,
                            message: me.message
                        }))
                    }
                    if (!Ze) {
                        for (let me = 0; me < g.numberOfInputs; me += 1) {
                            x[me].disconnect(D[me]);
                            for (let ve = 0; ve < g.channelCount; ve += 1) D[le].disconnect(q, ve, me * g.channelCount + ve)
                        }
                        if (y.parameterDescriptors !== void 0) {
                            const me = y.parameterDescriptors.length;
                            for (let ve = 0; ve < me; ve += 1) {
                                const de = L[ve];
                                de.disconnect(q, 0, O + ve), de.stop()
                            }
                        }
                        q.disconnect(ae), ae.onaudioprocess = null, M ? it() : I();
                        break
                    }
                }
            }
        };
        let M = !1;
        const Y = o(_, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                gain: 0
            }),
            X = () => ae.connect(Y).connect(_.destination),
            I = () => {
                ae.disconnect(Y), Y.disconnect()
            },
            T = () => {
                if (Ze) {
                    I(), g.numberOfOutputs > 0 && ae.connect(Z);
                    for (let P = 0, G = 0; P < g.numberOfOutputs; P += 1) {
                        const te = fe[P];
                        for (let le = 0; le < b[P]; le += 1) Z.connect(te, G + le, le);
                        G += b[P]
                    }
                }
                M = !0
            },
            S = () => {
                Ze && (X(), it()), M = !1
            };
        return X(), p(_e, T, S)
    }, YC = (t, e) => {
        const n = t.createBiquadFilter();
        return Un(n, e), bn(n, e, "Q"), bn(n, e, "detune"), bn(n, e, "frequency"), bn(n, e, "gain"), ln(n, e, "type"), n
    }, j5e = (t, e) => (n, r) => {
        const s = n.createChannelMerger(r.numberOfInputs);
        return t !== null && t.name === "webkitAudioContext" && e(n, s), Un(s, r), s
    }, W5e = t => {
        const e = t.numberOfOutputs;
        Object.defineProperty(t, "channelCount", {
            get: () => e,
            set: n => {
                if (n !== e) throw Hn()
            }
        }), Object.defineProperty(t, "channelCountMode", {
            get: () => "explicit",
            set: n => {
                if (n !== "explicit") throw Hn()
            }
        }), Object.defineProperty(t, "channelInterpretation", {
            get: () => "discrete",
            set: n => {
                if (n !== "discrete") throw Hn()
            }
        })
    }, Jf = (t, e) => {
        const n = t.createChannelSplitter(e.numberOfOutputs);
        return Un(n, e), W5e(n), n
    }, H5e = (t, e, n, r, s) => (i, o) => {
        if (i.createConstantSource === void 0) return n(i, o);
        const a = i.createConstantSource();
        return Un(a, o), bn(a, o, "offset"), e(r, () => r(i)) || nb(a), e(s, () => s(i)) || rb(a), t(i, a), a
    }, Du = (t, e) => (t.connect = e.connect.bind(e), t.disconnect = e.disconnect.bind(e), t), Y5e = (t, e, n, r) => (s, {
        offset: i,
        ...o
    }) => {
        const a = s.createBuffer(1, 2, 44100),
            l = e(s, {
                buffer: null,
                channelCount: 2,
                channelCountMode: "max",
                channelInterpretation: "speakers",
                loop: !1,
                loopEnd: 0,
                loopStart: 0,
                playbackRate: 1
            }),
            u = n(s, {
                ...o,
                gain: i
            }),
            f = a.getChannelData(0);
        f[0] = 1, f[1] = 1, l.buffer = a, l.loop = !0;
        const d = {
                get bufferSize() {},
                get channelCount() {
                    return u.channelCount
                },
                set channelCount(v) {
                    u.channelCount = v
                },
                get channelCountMode() {
                    return u.channelCountMode
                },
                set channelCountMode(v) {
                    u.channelCountMode = v
                },
                get channelInterpretation() {
                    return u.channelInterpretation
                },
                set channelInterpretation(v) {
                    u.channelInterpretation = v
                },
                get context() {
                    return u.context
                },
                get inputs() {
                    return []
                },
                get numberOfInputs() {
                    return l.numberOfInputs
                },
                get numberOfOutputs() {
                    return u.numberOfOutputs
                },
                get offset() {
                    return u.gain
                },
                get onended() {
                    return l.onended
                },
                set onended(v) {
                    l.onended = v
                },
                addEventListener(...v) {
                    return l.addEventListener(v[0], v[1], v[2])
                },
                dispatchEvent(...v) {
                    return l.dispatchEvent(v[0])
                },
                removeEventListener(...v) {
                    return l.removeEventListener(v[0], v[1], v[2])
                },
                start(v = 0) {
                    l.start.call(l, v)
                },
                stop(v = 0) {
                    l.stop.call(l, v)
                }
            },
            p = () => l.connect(u),
            _ = () => l.disconnect(u);
        return t(s, l), r(Du(d, u), p, _)
    }, z5e = (t, e) => (n, r) => {
        const s = n.createConvolver();
        if (Un(s, r), r.disableNormalization === s.normalize && (s.normalize = !r.disableNormalization), ln(s, r, "buffer"), r.channelCount > 2 || (e(s, "channelCount", i => () => i.call(s), i => o => {
                if (o > 2) throw t();
                return i.call(s, o)
            }), r.channelCountMode === "max")) throw t();
        return e(s, "channelCountMode", i => () => i.call(s), i => o => {
            if (o === "max") throw t();
            return i.call(s, o)
        }), s
    }, zC = (t, e) => {
        const n = t.createDelay(e.maxDelayTime);
        return Un(n, e), bn(n, e, "delayTime"), n
    }, K5e = t => (e, n) => {
        const r = e.createDynamicsCompressor();
        if (Un(r, n), n.channelCount > 2 || n.channelCountMode === "max") throw t();
        return bn(r, n, "attack"), bn(r, n, "knee"), bn(r, n, "ratio"), bn(r, n, "release"), bn(r, n, "threshold"), r
    }, qr = (t, e) => {
        const n = t.createGain();
        return Un(n, e), bn(n, e, "gain"), n
    }, Z5e = t => (e, n, r) => {
        if (e.createIIRFilter === void 0) return t(e, n, r);
        const s = e.createIIRFilter(r.feedforward, r.feedback);
        return Un(s, r), s
    };

function X5e(t, e) {
    const n = e[0] * e[0] + e[1] * e[1];
    return [(t[0] * e[0] + t[1] * e[1]) / n, (t[1] * e[0] - t[0] * e[1]) / n]
}

function Q5e(t, e) {
    return [t[0] * e[0] - t[1] * e[1], t[0] * e[1] + t[1] * e[0]]
}

function Uw(t, e) {
    let n = [0, 0];
    for (let r = t.length - 1; r >= 0; r -= 1) n = Q5e(n, e), n[0] += t[r];
    return n
}
const J5e = (t, e, n, r) => (s, i, {
        channelCount: o,
        channelCountMode: a,
        channelInterpretation: l,
        feedback: u,
        feedforward: f
    }) => {
        const d = HC(i, s.sampleRate),
            p = u instanceof Float64Array ? u : new Float64Array(u),
            _ = f instanceof Float64Array ? f : new Float64Array(f),
            v = p.length,
            y = _.length,
            g = Math.min(v, y);
        if (v === 0 || v > 20) throw r();
        if (p[0] === 0) throw e();
        if (y === 0 || y > 20) throw r();
        if (_[0] === 0) throw e();
        if (p[0] !== 1) {
            for (let L = 0; L < y; L += 1) _[L] /= p[0];
            for (let L = 1; L < v; L += 1) p[L] /= p[0]
        }
        const b = n(s, d, o, o);
        b.channelCount = o, b.channelCountMode = a, b.channelInterpretation = l;
        const O = 32,
            N = [],
            k = [],
            A = [];
        for (let L = 0; L < o; L += 1) {
            N.push(0);
            const q = new Float32Array(O),
                ee = new Float32Array(O);
            q.fill(0), ee.fill(0), k.push(q), A.push(ee)
        }
        b.onaudioprocess = L => {
            const q = L.inputBuffer,
                ee = L.outputBuffer,
                ae = q.numberOfChannels;
            for (let Z = 0; Z < ae; Z += 1) {
                const fe = q.getChannelData(Z),
                    ge = ee.getChannelData(Z);
                N[Z] = WC(p, v, _, y, g, k[Z], A[Z], N[Z], O, fe, ge)
            }
        };
        const x = s.sampleRate / 2;
        return Du({
            get bufferSize() {
                return d
            },
            get channelCount() {
                return b.channelCount
            },
            set channelCount(L) {
                b.channelCount = L
            },
            get channelCountMode() {
                return b.channelCountMode
            },
            set channelCountMode(L) {
                b.channelCountMode = L
            },
            get channelInterpretation() {
                return b.channelInterpretation
            },
            set channelInterpretation(L) {
                b.channelInterpretation = L
            },
            get context() {
                return b.context
            },
            get inputs() {
                return [b]
            },
            get numberOfInputs() {
                return b.numberOfInputs
            },
            get numberOfOutputs() {
                return b.numberOfOutputs
            },
            addEventListener(...L) {
                return b.addEventListener(L[0], L[1], L[2])
            },
            dispatchEvent(...L) {
                return b.dispatchEvent(L[0])
            },
            getFrequencyResponse(L, q, ee) {
                if (L.length !== q.length || q.length !== ee.length) throw t();
                const ae = L.length;
                for (let Z = 0; Z < ae; Z += 1) {
                    const fe = -Math.PI * (L[Z] / x),
                        ge = [Math.cos(fe), Math.sin(fe)],
                        K = Uw(_, ge),
                        Q = Uw(p, ge),
                        ue = X5e(K, Q);
                    q[Z] = Math.sqrt(ue[0] * ue[0] + ue[1] * ue[1]), ee[Z] = Math.atan2(ue[1], ue[0])
                }
            },
            removeEventListener(...L) {
                return b.removeEventListener(L[0], L[1], L[2])
            }
        }, b)
    },
    e4e = (t, e) => t.createMediaElementSource(e.mediaElement),
    t4e = (t, e) => {
        const n = t.createMediaStreamDestination();
        return Un(n, e), n.numberOfOutputs === 1 && Object.defineProperty(n, "numberOfOutputs", {
            get: () => 0
        }), n
    },
    n4e = (t, {
        mediaStream: e
    }) => {
        const n = e.getAudioTracks();
        n.sort((i, o) => i.id < o.id ? -1 : i.id > o.id ? 1 : 0);
        const r = n.slice(0, 1),
            s = t.createMediaStreamSource(new MediaStream(r));
        return Object.defineProperty(s, "mediaStream", {
            value: e
        }), s
    },
    r4e = (t, e) => (n, {
        mediaStreamTrack: r
    }) => {
        if (typeof n.createMediaStreamTrackSource == "function") return n.createMediaStreamTrackSource(r);
        const s = new MediaStream([r]),
            i = n.createMediaStreamSource(s);
        if (r.kind !== "audio") throw t();
        if (e(n)) throw new TypeError;
        return i
    },
    s4e = t => t === null ? null : t.hasOwnProperty("OfflineAudioContext") ? t.OfflineAudioContext : t.hasOwnProperty("webkitOfflineAudioContext") ? t.webkitOfflineAudioContext : null,
    i4e = (t, e, n, r, s, i) => (o, a) => {
        const l = o.createOscillator();
        return Un(l, a), bn(l, a, "detune"), bn(l, a, "frequency"), a.periodicWave !== void 0 ? l.setPeriodicWave(a.periodicWave) : ln(l, a, "type"), e(n, () => n(o)) || nb(l), e(r, () => r(o)) || i(l, o), e(s, () => s(o)) || rb(l), t(o, l), l
    },
    o4e = t => (e, n) => {
        const r = e.createPanner();
        return r.orientationX === void 0 ? t(e, n) : (Un(r, n), bn(r, n, "orientationX"), bn(r, n, "orientationY"), bn(r, n, "orientationZ"), bn(r, n, "positionX"), bn(r, n, "positionY"), bn(r, n, "positionZ"), ln(r, n, "coneInnerAngle"), ln(r, n, "coneOuterAngle"), ln(r, n, "coneOuterGain"), ln(r, n, "distanceModel"), ln(r, n, "maxDistance"), ln(r, n, "panningModel"), ln(r, n, "refDistance"), ln(r, n, "rolloffFactor"), r)
    },
    a4e = (t, e, n, r, s, i, o, a, l, u) => (f, {
        coneInnerAngle: d,
        coneOuterAngle: p,
        coneOuterGain: _,
        distanceModel: v,
        maxDistance: y,
        orientationX: g,
        orientationY: b,
        orientationZ: O,
        panningModel: N,
        positionX: k,
        positionY: A,
        positionZ: x,
        refDistance: D,
        rolloffFactor: L,
        ...q
    }) => {
        const ee = f.createPanner();
        if (q.channelCount > 2 || q.channelCountMode === "max") throw o();
        Un(ee, q);
        const ae = {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete"
            },
            Z = n(f, {
                ...ae,
                channelInterpretation: "speakers",
                numberOfInputs: 6
            }),
            fe = r(f, {
                ...q,
                gain: 1
            }),
            ge = r(f, {
                ...ae,
                gain: 1
            }),
            K = r(f, {
                ...ae,
                gain: 0
            }),
            Q = r(f, {
                ...ae,
                gain: 0
            }),
            ue = r(f, {
                ...ae,
                gain: 0
            }),
            _e = r(f, {
                ...ae,
                gain: 0
            }),
            Oe = r(f, {
                ...ae,
                gain: 0
            }),
            Ee = s(f, 256, 6, 1),
            Ce = i(f, {
                ...ae,
                curve: new Float32Array([1, 1]),
                oversample: "none"
            });
        let De = [g, b, O],
            Ue = [k, A, x];
        const ot = new Float32Array(1);
        Ee.onaudioprocess = ({
            inputBuffer: w
        }) => {
            const M = [l(w, ot, 0), l(w, ot, 1), l(w, ot, 2)];
            M.some((X, I) => X !== De[I]) && (ee.setOrientation(...M), De = M);
            const Y = [l(w, ot, 3), l(w, ot, 4), l(w, ot, 5)];
            Y.some((X, I) => X !== Ue[I]) && (ee.setPosition(...Y), Ue = Y)
        }, Object.defineProperty(K.gain, "defaultValue", {
            get: () => 0
        }), Object.defineProperty(Q.gain, "defaultValue", {
            get: () => 0
        }), Object.defineProperty(ue.gain, "defaultValue", {
            get: () => 0
        }), Object.defineProperty(_e.gain, "defaultValue", {
            get: () => 0
        }), Object.defineProperty(Oe.gain, "defaultValue", {
            get: () => 0
        });
        const je = {
            get bufferSize() {},
            get channelCount() {
                return ee.channelCount
            },
            set channelCount(w) {
                if (w > 2) throw o();
                fe.channelCount = w, ee.channelCount = w
            },
            get channelCountMode() {
                return ee.channelCountMode
            },
            set channelCountMode(w) {
                if (w === "max") throw o();
                fe.channelCountMode = w, ee.channelCountMode = w
            },
            get channelInterpretation() {
                return ee.channelInterpretation
            },
            set channelInterpretation(w) {
                fe.channelInterpretation = w, ee.channelInterpretation = w
            },
            get coneInnerAngle() {
                return ee.coneInnerAngle
            },
            set coneInnerAngle(w) {
                ee.coneInnerAngle = w
            },
            get coneOuterAngle() {
                return ee.coneOuterAngle
            },
            set coneOuterAngle(w) {
                ee.coneOuterAngle = w
            },
            get coneOuterGain() {
                return ee.coneOuterGain
            },
            set coneOuterGain(w) {
                if (w < 0 || w > 1) throw e();
                ee.coneOuterGain = w
            },
            get context() {
                return ee.context
            },
            get distanceModel() {
                return ee.distanceModel
            },
            set distanceModel(w) {
                ee.distanceModel = w
            },
            get inputs() {
                return [fe]
            },
            get maxDistance() {
                return ee.maxDistance
            },
            set maxDistance(w) {
                if (w < 0) throw new RangeError;
                ee.maxDistance = w
            },
            get numberOfInputs() {
                return ee.numberOfInputs
            },
            get numberOfOutputs() {
                return ee.numberOfOutputs
            },
            get orientationX() {
                return ge.gain
            },
            get orientationY() {
                return K.gain
            },
            get orientationZ() {
                return Q.gain
            },
            get panningModel() {
                return ee.panningModel
            },
            set panningModel(w) {
                ee.panningModel = w
            },
            get positionX() {
                return ue.gain
            },
            get positionY() {
                return _e.gain
            },
            get positionZ() {
                return Oe.gain
            },
            get refDistance() {
                return ee.refDistance
            },
            set refDistance(w) {
                if (w < 0) throw new RangeError;
                ee.refDistance = w
            },
            get rolloffFactor() {
                return ee.rolloffFactor
            },
            set rolloffFactor(w) {
                if (w < 0) throw new RangeError;
                ee.rolloffFactor = w
            },
            addEventListener(...w) {
                return fe.addEventListener(w[0], w[1], w[2])
            },
            dispatchEvent(...w) {
                return fe.dispatchEvent(w[0])
            },
            removeEventListener(...w) {
                return fe.removeEventListener(w[0], w[1], w[2])
            }
        };
        d !== je.coneInnerAngle && (je.coneInnerAngle = d), p !== je.coneOuterAngle && (je.coneOuterAngle = p), _ !== je.coneOuterGain && (je.coneOuterGain = _), v !== je.distanceModel && (je.distanceModel = v), y !== je.maxDistance && (je.maxDistance = y), g !== je.orientationX.value && (je.orientationX.value = g), b !== je.orientationY.value && (je.orientationY.value = b), O !== je.orientationZ.value && (je.orientationZ.value = O), N !== je.panningModel && (je.panningModel = N), k !== je.positionX.value && (je.positionX.value = k), A !== je.positionY.value && (je.positionY.value = A), x !== je.positionZ.value && (je.positionZ.value = x), D !== je.refDistance && (je.refDistance = D), L !== je.rolloffFactor && (je.rolloffFactor = L), (De[0] !== 1 || De[1] !== 0 || De[2] !== 0) && ee.setOrientation(...De), (Ue[0] !== 0 || Ue[1] !== 0 || Ue[2] !== 0) && ee.setPosition(...Ue);
        const Ze = () => {
                fe.connect(ee), t(fe, Ce, 0, 0), Ce.connect(ge).connect(Z, 0, 0), Ce.connect(K).connect(Z, 0, 1), Ce.connect(Q).connect(Z, 0, 2), Ce.connect(ue).connect(Z, 0, 3), Ce.connect(_e).connect(Z, 0, 4), Ce.connect(Oe).connect(Z, 0, 5), Z.connect(Ee).connect(f.destination)
            },
            it = () => {
                fe.disconnect(ee), a(fe, Ce, 0, 0), Ce.disconnect(ge), ge.disconnect(Z), Ce.disconnect(K), K.disconnect(Z), Ce.disconnect(Q), Q.disconnect(Z), Ce.disconnect(ue), ue.disconnect(Z), Ce.disconnect(_e), _e.disconnect(Z), Ce.disconnect(Oe), Oe.disconnect(Z), Z.disconnect(Ee), Ee.disconnect(f.destination)
            };
        return u(Du(je, ee), Ze, it)
    },
    c4e = t => (e, {
        disableNormalization: n,
        imag: r,
        real: s
    }) => {
        const i = r instanceof Float32Array ? r : new Float32Array(r),
            o = s instanceof Float32Array ? s : new Float32Array(s),
            a = e.createPeriodicWave(o, i, {
                disableNormalization: n
            });
        if (Array.from(r).length < 2) throw t();
        return a
    },
    ed = (t, e, n, r) => t.createScriptProcessor(e, n, r),
    l4e = (t, e) => (n, r) => {
        const s = r.channelCountMode;
        if (s === "clamped-max") throw e();
        if (n.createStereoPanner === void 0) return t(n, r);
        const i = n.createStereoPanner();
        return Un(i, r), bn(i, r, "pan"), Object.defineProperty(i, "channelCountMode", {
            get: () => s,
            set: o => {
                if (o !== s) throw e()
            }
        }), i
    },
    u4e = (t, e, n, r, s, i) => {
        const a = new Float32Array([1, 1]),
            l = Math.PI / 2,
            u = {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete"
            },
            f = {
                ...u,
                oversample: "none"
            },
            d = (v, y, g, b) => {
                const O = new Float32Array(16385),
                    N = new Float32Array(16385);
                for (let q = 0; q < 16385; q += 1) {
                    const ee = q / 16384 * l;
                    O[q] = Math.cos(ee), N[q] = Math.sin(ee)
                }
                const k = n(v, {
                        ...u,
                        gain: 0
                    }),
                    A = r(v, {
                        ...f,
                        curve: O
                    }),
                    x = r(v, {
                        ...f,
                        curve: a
                    }),
                    D = n(v, {
                        ...u,
                        gain: 0
                    }),
                    L = r(v, {
                        ...f,
                        curve: N
                    });
                return {
                    connectGraph() {
                        y.connect(k), y.connect(x.inputs === void 0 ? x : x.inputs[0]), y.connect(D), x.connect(g), g.connect(A.inputs === void 0 ? A : A.inputs[0]), g.connect(L.inputs === void 0 ? L : L.inputs[0]), A.connect(k.gain), L.connect(D.gain), k.connect(b, 0, 0), D.connect(b, 0, 1)
                    },
                    disconnectGraph() {
                        y.disconnect(k), y.disconnect(x.inputs === void 0 ? x : x.inputs[0]), y.disconnect(D), x.disconnect(g), g.disconnect(A.inputs === void 0 ? A : A.inputs[0]), g.disconnect(L.inputs === void 0 ? L : L.inputs[0]), A.disconnect(k.gain), L.disconnect(D.gain), k.disconnect(b, 0, 0), D.disconnect(b, 0, 1)
                    }
                }
            },
            p = (v, y, g, b) => {
                const O = new Float32Array(16385),
                    N = new Float32Array(16385),
                    k = new Float32Array(16385),
                    A = new Float32Array(16385),
                    x = Math.floor(16385 / 2);
                for (let ue = 0; ue < 16385; ue += 1)
                    if (ue > x) {
                        const _e = (ue - x) / (16384 - x) * l;
                        O[ue] = Math.cos(_e), N[ue] = Math.sin(_e), k[ue] = 0, A[ue] = 1
                    } else {
                        const _e = ue / (16384 - x) * l;
                        O[ue] = 1, N[ue] = 0, k[ue] = Math.cos(_e), A[ue] = Math.sin(_e)
                    } const D = e(v, {
                        channelCount: 2,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        numberOfOutputs: 2
                    }),
                    L = n(v, {
                        ...u,
                        gain: 0
                    }),
                    q = r(v, {
                        ...f,
                        curve: O
                    }),
                    ee = n(v, {
                        ...u,
                        gain: 0
                    }),
                    ae = r(v, {
                        ...f,
                        curve: N
                    }),
                    Z = r(v, {
                        ...f,
                        curve: a
                    }),
                    fe = n(v, {
                        ...u,
                        gain: 0
                    }),
                    ge = r(v, {
                        ...f,
                        curve: k
                    }),
                    K = n(v, {
                        ...u,
                        gain: 0
                    }),
                    Q = r(v, {
                        ...f,
                        curve: A
                    });
                return {
                    connectGraph() {
                        y.connect(D), y.connect(Z.inputs === void 0 ? Z : Z.inputs[0]), D.connect(L, 0), D.connect(ee, 0), D.connect(fe, 1), D.connect(K, 1), Z.connect(g), g.connect(q.inputs === void 0 ? q : q.inputs[0]), g.connect(ae.inputs === void 0 ? ae : ae.inputs[0]), g.connect(ge.inputs === void 0 ? ge : ge.inputs[0]), g.connect(Q.inputs === void 0 ? Q : Q.inputs[0]), q.connect(L.gain), ae.connect(ee.gain), ge.connect(fe.gain), Q.connect(K.gain), L.connect(b, 0, 0), fe.connect(b, 0, 0), ee.connect(b, 0, 1), K.connect(b, 0, 1)
                    },
                    disconnectGraph() {
                        y.disconnect(D), y.disconnect(Z.inputs === void 0 ? Z : Z.inputs[0]), D.disconnect(L, 0), D.disconnect(ee, 0), D.disconnect(fe, 1), D.disconnect(K, 1), Z.disconnect(g), g.disconnect(q.inputs === void 0 ? q : q.inputs[0]), g.disconnect(ae.inputs === void 0 ? ae : ae.inputs[0]), g.disconnect(ge.inputs === void 0 ? ge : ge.inputs[0]), g.disconnect(Q.inputs === void 0 ? Q : Q.inputs[0]), q.disconnect(L.gain), ae.disconnect(ee.gain), ge.disconnect(fe.gain), Q.disconnect(K.gain), L.disconnect(b, 0, 0), fe.disconnect(b, 0, 0), ee.disconnect(b, 0, 1), K.disconnect(b, 0, 1)
                    }
                }
            },
            _ = (v, y, g, b, O) => {
                if (y === 1) return d(v, g, b, O);
                if (y === 2) return p(v, g, b, O);
                throw s()
            };
        return (v, {
            channelCount: y,
            channelCountMode: g,
            pan: b,
            ...O
        }) => {
            if (g === "max") throw s();
            const N = t(v, {
                    ...O,
                    channelCount: 1,
                    channelCountMode: g,
                    numberOfInputs: 2
                }),
                k = n(v, {
                    ...O,
                    channelCount: y,
                    channelCountMode: g,
                    gain: 1
                }),
                A = n(v, {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    gain: b
                });
            let {
                connectGraph: x,
                disconnectGraph: D
            } = _(v, y, k, A, N);
            Object.defineProperty(A.gain, "defaultValue", {
                get: () => 0
            }), Object.defineProperty(A.gain, "maxValue", {
                get: () => 1
            }), Object.defineProperty(A.gain, "minValue", {
                get: () => -1
            });
            const L = {
                get bufferSize() {},
                get channelCount() {
                    return k.channelCount
                },
                set channelCount(Z) {
                    k.channelCount !== Z && (q && D(), {
                        connectGraph: x,
                        disconnectGraph: D
                    } = _(v, Z, k, A, N), q && x()), k.channelCount = Z
                },
                get channelCountMode() {
                    return k.channelCountMode
                },
                set channelCountMode(Z) {
                    if (Z === "clamped-max" || Z === "max") throw s();
                    k.channelCountMode = Z
                },
                get channelInterpretation() {
                    return k.channelInterpretation
                },
                set channelInterpretation(Z) {
                    k.channelInterpretation = Z
                },
                get context() {
                    return k.context
                },
                get inputs() {
                    return [k]
                },
                get numberOfInputs() {
                    return k.numberOfInputs
                },
                get numberOfOutputs() {
                    return k.numberOfOutputs
                },
                get pan() {
                    return A.gain
                },
                addEventListener(...Z) {
                    return k.addEventListener(Z[0], Z[1], Z[2])
                },
                dispatchEvent(...Z) {
                    return k.dispatchEvent(Z[0])
                },
                removeEventListener(...Z) {
                    return k.removeEventListener(Z[0], Z[1], Z[2])
                }
            };
            let q = !1;
            const ee = () => {
                    x(), q = !0
                },
                ae = () => {
                    D(), q = !1
                };
            return i(Du(L, N), ee, ae)
        }
    },
    h4e = (t, e, n, r, s, i, o) => (a, l) => {
        const u = a.createWaveShaper();
        if (i !== null && i.name === "webkitAudioContext" && a.createGain().gain.automationRate === void 0) return n(a, l);
        Un(u, l);
        const f = l.curve === null || l.curve instanceof Float32Array ? l.curve : new Float32Array(l.curve);
        if (f !== null && f.length < 2) throw e();
        ln(u, {
            curve: f
        }, "curve"), ln(u, l, "oversample");
        let d = null,
            p = !1;
        return o(u, "curve", y => () => y.call(u), y => g => (y.call(u, g), p && (r(g) && d === null ? d = t(a, u) : !r(g) && d !== null && (d(), d = null)), g)), s(u, () => {
            p = !0, r(u.curve) && (d = t(a, u))
        }, () => {
            p = !1, d !== null && (d(), d = null)
        })
    },
    f4e = (t, e, n, r, s) => (i, {
        curve: o,
        oversample: a,
        ...l
    }) => {
        const u = i.createWaveShaper(),
            f = i.createWaveShaper();
        Un(u, l), Un(f, l);
        const d = n(i, {
                ...l,
                gain: 1
            }),
            p = n(i, {
                ...l,
                gain: -1
            }),
            _ = n(i, {
                ...l,
                gain: 1
            }),
            v = n(i, {
                ...l,
                gain: -1
            });
        let y = null,
            g = !1,
            b = null;
        const O = {
            get bufferSize() {},
            get channelCount() {
                return u.channelCount
            },
            set channelCount(A) {
                d.channelCount = A, p.channelCount = A, u.channelCount = A, _.channelCount = A, f.channelCount = A, v.channelCount = A
            },
            get channelCountMode() {
                return u.channelCountMode
            },
            set channelCountMode(A) {
                d.channelCountMode = A, p.channelCountMode = A, u.channelCountMode = A, _.channelCountMode = A, f.channelCountMode = A, v.channelCountMode = A
            },
            get channelInterpretation() {
                return u.channelInterpretation
            },
            set channelInterpretation(A) {
                d.channelInterpretation = A, p.channelInterpretation = A, u.channelInterpretation = A, _.channelInterpretation = A, f.channelInterpretation = A, v.channelInterpretation = A
            },
            get context() {
                return u.context
            },
            get curve() {
                return b
            },
            set curve(A) {
                if (A !== null && A.length < 2) throw e();
                if (A === null) u.curve = A, f.curve = A;
                else {
                    const x = A.length,
                        D = new Float32Array(x + 2 - x % 2),
                        L = new Float32Array(x + 2 - x % 2);
                    D[0] = A[0], L[0] = -A[x - 1];
                    const q = Math.ceil((x + 1) / 2),
                        ee = (x + 1) / 2 - 1;
                    for (let ae = 1; ae < q; ae += 1) {
                        const Z = ae / q * ee,
                            fe = Math.floor(Z),
                            ge = Math.ceil(Z);
                        D[ae] = fe === ge ? A[fe] : (1 - (Z - fe)) * A[fe] + (1 - (ge - Z)) * A[ge], L[ae] = fe === ge ? -A[x - 1 - fe] : -((1 - (Z - fe)) * A[x - 1 - fe]) - (1 - (ge - Z)) * A[x - 1 - ge]
                    }
                    D[q] = x % 2 === 1 ? A[q - 1] : (A[q - 2] + A[q - 1]) / 2, u.curve = D, f.curve = L
                }
                b = A, g && (r(b) && y === null ? y = t(i, d) : y !== null && (y(), y = null))
            },
            get inputs() {
                return [d]
            },
            get numberOfInputs() {
                return u.numberOfInputs
            },
            get numberOfOutputs() {
                return u.numberOfOutputs
            },
            get oversample() {
                return u.oversample
            },
            set oversample(A) {
                u.oversample = A, f.oversample = A
            },
            addEventListener(...A) {
                return d.addEventListener(A[0], A[1], A[2])
            },
            dispatchEvent(...A) {
                return d.dispatchEvent(A[0])
            },
            removeEventListener(...A) {
                return d.removeEventListener(A[0], A[1], A[2])
            }
        };
        o !== null && (O.curve = o instanceof Float32Array ? o : new Float32Array(o)), a !== O.oversample && (O.oversample = a);
        const N = () => {
                d.connect(u).connect(_), d.connect(p).connect(f).connect(v).connect(_), g = !0, r(b) && (y = t(i, d))
            },
            k = () => {
                d.disconnect(u), u.disconnect(_), d.disconnect(p), p.disconnect(f), f.disconnect(v), v.disconnect(_), g = !1, y !== null && (y(), y = null)
            };
        return s(Du(O, _), N, k)
    },
    Ar = () => new DOMException("", "NotSupportedError"),
    d4e = {
        numberOfChannels: 1
    },
    p4e = (t, e, n, r, s) => class extends t {
        constructor(o, a, l) {
            let u;
            if (typeof o == "number" && a !== void 0 && l !== void 0) u = {
                length: a,
                numberOfChannels: o,
                sampleRate: l
            };
            else if (typeof o == "object") u = o;
            else throw new Error("The given parameters are not valid.");
            const {
                length: f,
                numberOfChannels: d,
                sampleRate: p
            } = {
                ...d4e,
                ...u
            }, _ = r(d, f, p);
            e(nf, () => nf(_)) || _.addEventListener("statechange", (() => {
                let v = 0;
                const y = g => {
                    this._state === "running" && (v > 0 ? (_.removeEventListener("statechange", y), g.stopImmediatePropagation(), this._waitForThePromiseToSettle(g)) : v += 1)
                };
                return y
            })()), super(_, d), this._length = f, this._nativeOfflineAudioContext = _, this._state = null
        }
        get length() {
            return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length
        }
        get state() {
            return this._state === null ? this._nativeOfflineAudioContext.state : this._state
        }
        startRendering() {
            return this._state === "running" ? Promise.reject(n()) : (this._state = "running", s(this.destination, this._nativeOfflineAudioContext).finally(() => {
                this._state = null, UC(this)
            }))
        }
        _waitForThePromiseToSettle(o) {
            this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(o) : setTimeout(() => this._waitForThePromiseToSettle(o))
        }
    },
    m4e = {
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        detune: 0,
        frequency: 440,
        periodicWave: void 0,
        type: "sine"
    },
    g4e = (t, e, n, r, s, i, o) => class extends t {
        constructor(l, u) {
            const f = s(l),
                d = {
                    ...m4e,
                    ...u
                },
                p = n(f, d),
                _ = i(f),
                v = _ ? r() : null,
                y = l.sampleRate / 2;
            super(l, !1, p, v), this._detune = e(this, _, p.detune, 153600, -153600), this._frequency = e(this, _, p.frequency, y, -y), this._nativeOscillatorNode = p, this._onended = null, this._oscillatorNodeRenderer = v, this._oscillatorNodeRenderer !== null && d.periodicWave !== void 0 && (this._oscillatorNodeRenderer.periodicWave = d.periodicWave)
        }
        get detune() {
            return this._detune
        }
        get frequency() {
            return this._frequency
        }
        get onended() {
            return this._onended
        }
        set onended(l) {
            const u = typeof l == "function" ? o(this, l) : null;
            this._nativeOscillatorNode.onended = u;
            const f = this._nativeOscillatorNode.onended;
            this._onended = f !== null && f === u ? l : f
        }
        get type() {
            return this._nativeOscillatorNode.type
        }
        set type(l) {
            this._nativeOscillatorNode.type = l, this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = null)
        }
        setPeriodicWave(l) {
            this._nativeOscillatorNode.setPeriodicWave(l), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = l)
        }
        start(l = 0) {
            if (this._nativeOscillatorNode.start(l), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.start = l), this.context.state !== "closed") {
                tu(this);
                const u = () => {
                    this._nativeOscillatorNode.removeEventListener("ended", u), uo(this) && Zf(this)
                };
                this._nativeOscillatorNode.addEventListener("ended", u)
            }
        }
        stop(l = 0) {
            this._nativeOscillatorNode.stop(l), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.stop = l)
        }
    },
    _4e = (t, e, n, r, s) => () => {
        const i = new WeakMap;
        let o = null,
            a = null,
            l = null;
        const u = async (f, d) => {
            let p = n(f);
            const _ = mr(p, d);
            if (!_) {
                const v = {
                    channelCount: p.channelCount,
                    channelCountMode: p.channelCountMode,
                    channelInterpretation: p.channelInterpretation,
                    detune: p.detune.value,
                    frequency: p.frequency.value,
                    periodicWave: o === null ? void 0 : o,
                    type: p.type
                };
                p = e(d, v), a !== null && p.start(a), l !== null && p.stop(l)
            }
            return i.set(d, p), _ ? (await t(d, f.detune, p.detune), await t(d, f.frequency, p.frequency)) : (await r(d, f.detune, p.detune), await r(d, f.frequency, p.frequency)), await s(f, d, p), p
        };
        return {
            set periodicWave(f) {
                o = f
            },
            set start(f) {
                a = f
            },
            set stop(f) {
                l = f
            },
            render(f, d) {
                const p = i.get(d);
                return p !== void 0 ? Promise.resolve(p) : u(f, d)
            }
        }
    },
    y4e = {
        channelCount: 2,
        channelCountMode: "clamped-max",
        channelInterpretation: "speakers",
        coneInnerAngle: 360,
        coneOuterAngle: 360,
        coneOuterGain: 0,
        distanceModel: "inverse",
        maxDistance: 1e4,
        orientationX: 1,
        orientationY: 0,
        orientationZ: 0,
        panningModel: "equalpower",
        positionX: 0,
        positionY: 0,
        positionZ: 0,
        refDistance: 1,
        rolloffFactor: 1
    },
    v4e = (t, e, n, r, s, i, o) => class extends t {
        constructor(l, u) {
            const f = s(l),
                d = {
                    ...y4e,
                    ...u
                },
                p = n(f, d),
                _ = i(f),
                v = _ ? r() : null;
            super(l, !1, p, v), this._nativePannerNode = p, this._orientationX = e(this, _, p.orientationX, Er, Rr), this._orientationY = e(this, _, p.orientationY, Er, Rr), this._orientationZ = e(this, _, p.orientationZ, Er, Rr), this._positionX = e(this, _, p.positionX, Er, Rr), this._positionY = e(this, _, p.positionY, Er, Rr), this._positionZ = e(this, _, p.positionZ, Er, Rr), o(this, 1)
        }
        get coneInnerAngle() {
            return this._nativePannerNode.coneInnerAngle
        }
        set coneInnerAngle(l) {
            this._nativePannerNode.coneInnerAngle = l
        }
        get coneOuterAngle() {
            return this._nativePannerNode.coneOuterAngle
        }
        set coneOuterAngle(l) {
            this._nativePannerNode.coneOuterAngle = l
        }
        get coneOuterGain() {
            return this._nativePannerNode.coneOuterGain
        }
        set coneOuterGain(l) {
            this._nativePannerNode.coneOuterGain = l
        }
        get distanceModel() {
            return this._nativePannerNode.distanceModel
        }
        set distanceModel(l) {
            this._nativePannerNode.distanceModel = l
        }
        get maxDistance() {
            return this._nativePannerNode.maxDistance
        }
        set maxDistance(l) {
            this._nativePannerNode.maxDistance = l
        }
        get orientationX() {
            return this._orientationX
        }
        get orientationY() {
            return this._orientationY
        }
        get orientationZ() {
            return this._orientationZ
        }
        get panningModel() {
            return this._nativePannerNode.panningModel
        }
        set panningModel(l) {
            this._nativePannerNode.panningModel = l
        }
        get positionX() {
            return this._positionX
        }
        get positionY() {
            return this._positionY
        }
        get positionZ() {
            return this._positionZ
        }
        get refDistance() {
            return this._nativePannerNode.refDistance
        }
        set refDistance(l) {
            this._nativePannerNode.refDistance = l
        }
        get rolloffFactor() {
            return this._nativePannerNode.rolloffFactor
        }
        set rolloffFactor(l) {
            this._nativePannerNode.rolloffFactor = l
        }
    },
    b4e = (t, e, n, r, s, i, o, a, l, u) => () => {
        const f = new WeakMap;
        let d = null;
        const p = async (_, v) => {
            let y = null,
                g = i(_);
            const b = {
                    channelCount: g.channelCount,
                    channelCountMode: g.channelCountMode,
                    channelInterpretation: g.channelInterpretation
                },
                O = {
                    ...b,
                    coneInnerAngle: g.coneInnerAngle,
                    coneOuterAngle: g.coneOuterAngle,
                    coneOuterGain: g.coneOuterGain,
                    distanceModel: g.distanceModel,
                    maxDistance: g.maxDistance,
                    panningModel: g.panningModel,
                    refDistance: g.refDistance,
                    rolloffFactor: g.rolloffFactor
                },
                N = mr(g, v);
            if ("bufferSize" in g) y = r(v, {
                ...b,
                gain: 1
            });
            else if (!N) {
                const k = {
                    ...O,
                    orientationX: g.orientationX.value,
                    orientationY: g.orientationY.value,
                    orientationZ: g.orientationZ.value,
                    positionX: g.positionX.value,
                    positionY: g.positionY.value,
                    positionZ: g.positionZ.value
                };
                g = s(v, k)
            }
            if (f.set(v, y === null ? g : y), y !== null) {
                if (d === null) {
                    if (o === null) throw new Error("Missing the native OfflineAudioContext constructor.");
                    const ae = new o(6, _.context.length, v.sampleRate),
                        Z = e(ae, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "speakers",
                            numberOfInputs: 6
                        });
                    Z.connect(ae.destination), d = (async () => {
                        const fe = await Promise.all([_.orientationX, _.orientationY, _.orientationZ, _.positionX, _.positionY, _.positionZ].map(async (ge, K) => {
                            const Q = n(ae, {
                                channelCount: 1,
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                offset: K === 0 ? 1 : 0
                            });
                            return await a(ae, ge, Q.offset), Q
                        }));
                        for (let ge = 0; ge < 6; ge += 1) fe[ge].connect(Z, 0, ge), fe[ge].start(0);
                        return u(ae)
                    })()
                }
                const k = await d,
                    A = r(v, {
                        ...b,
                        gain: 1
                    });
                await l(_, v, A);
                const x = [];
                for (let ae = 0; ae < k.numberOfChannels; ae += 1) x.push(k.getChannelData(ae));
                let D = [x[0][0], x[1][0], x[2][0]],
                    L = [x[3][0], x[4][0], x[5][0]],
                    q = r(v, {
                        ...b,
                        gain: 1
                    }),
                    ee = s(v, {
                        ...O,
                        orientationX: D[0],
                        orientationY: D[1],
                        orientationZ: D[2],
                        positionX: L[0],
                        positionY: L[1],
                        positionZ: L[2]
                    });
                A.connect(q).connect(ee.inputs[0]), ee.connect(y);
                for (let ae = 128; ae < k.length; ae += 128) {
                    const Z = [x[0][ae], x[1][ae], x[2][ae]],
                        fe = [x[3][ae], x[4][ae], x[5][ae]];
                    if (Z.some((ge, K) => ge !== D[K]) || fe.some((ge, K) => ge !== L[K])) {
                        D = Z, L = fe;
                        const ge = ae / v.sampleRate;
                        q.gain.setValueAtTime(0, ge), q = r(v, {
                            ...b,
                            gain: 0
                        }), ee = s(v, {
                            ...O,
                            orientationX: D[0],
                            orientationY: D[1],
                            orientationZ: D[2],
                            positionX: L[0],
                            positionY: L[1],
                            positionZ: L[2]
                        }), q.gain.setValueAtTime(1, ge), A.connect(q).connect(ee.inputs[0]), ee.connect(y)
                    }
                }
                return y
            }
            return N ? (await t(v, _.orientationX, g.orientationX), await t(v, _.orientationY, g.orientationY), await t(v, _.orientationZ, g.orientationZ), await t(v, _.positionX, g.positionX), await t(v, _.positionY, g.positionY), await t(v, _.positionZ, g.positionZ)) : (await a(v, _.orientationX, g.orientationX), await a(v, _.orientationY, g.orientationY), await a(v, _.orientationZ, g.orientationZ), await a(v, _.positionX, g.positionX), await a(v, _.positionY, g.positionY), await a(v, _.positionZ, g.positionZ)), Mu(g) ? await l(_, v, g.inputs[0]) : await l(_, v, g), g
        };
        return {
            render(_, v) {
                const y = f.get(v);
                return y !== void 0 ? Promise.resolve(y) : p(_, v)
            }
        }
    },
    E4e = {
        disableNormalization: !1
    },
    T4e = (t, e, n, r) => class KC {
        constructor(i, o) {
            const a = e(i),
                l = r({
                    ...E4e,
                    ...o
                }),
                u = t(a, l);
            return n.add(u), u
        }
        static[Symbol.hasInstance](i) {
            return i !== null && typeof i == "object" && Object.getPrototypeOf(i) === KC.prototype || n.has(i)
        }
    },
    S4e = (t, e) => (n, r, s) => (t(r).replay(s), e(r, n, s)),
    w4e = (t, e, n) => async (r, s, i) => {
        const o = t(r);
        await Promise.all(o.activeInputs.map((a, l) => Array.from(a).map(async ([u, f]) => {
            const p = await e(u).render(u, s),
                _ = r.context.destination;
            !n(u) && (r !== _ || !n(r)) && p.connect(i, f, l)
        })).reduce((a, l) => [...a, ...l], []))
    }, A4e = (t, e, n) => async (r, s, i) => {
        const o = e(r);
        await Promise.all(Array.from(o.activeInputs).map(async ([a, l]) => {
            const f = await t(a).render(a, s);
            n(a) || f.connect(i, l)
        }))
    }, O4e = (t, e, n, r) => s => t(nf, () => nf(s)) ? Promise.resolve(t(r, r)).then(i => {
        if (!i) {
            const o = n(s, 512, 0, 1);
            s.oncomplete = () => {
                o.onaudioprocess = null, o.disconnect()
            }, o.onaudioprocess = () => s.currentTime, o.connect(s.destination)
        }
        return s.startRendering()
    }) : new Promise(i => {
        const o = e(s, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            gain: 0
        });
        s.oncomplete = a => {
            o.disconnect(), i(a.renderedBuffer)
        }, o.connect(s.destination), s.startRendering()
    }), C4e = t => (e, n) => {
        t.set(e, n)
    }, k4e = t => (e, n) => t.set(e, n), I4e = (t, e, n, r, s, i, o, a) => (l, u) => n(l).render(l, u).then(() => Promise.all(Array.from(r(u)).map(f => n(f).render(f, u)))).then(() => s(u)).then(f => (typeof f.copyFromChannel != "function" ? (o(f), J3(f)) : e(i, () => i(f)) || a(f), t.add(f), f)), N4e = {
        channelCount: 2,
        channelCountMode: "explicit",
        channelInterpretation: "speakers",
        pan: 0
    }, x4e = (t, e, n, r, s, i) => class extends t {
        constructor(a, l) {
            const u = s(a),
                f = {
                    ...N4e,
                    ...l
                },
                d = n(u, f),
                p = i(u),
                _ = p ? r() : null;
            super(a, !1, d, _), this._pan = e(this, p, d.pan)
        }
        get pan() {
            return this._pan
        }
    }, P4e = (t, e, n, r, s) => () => {
        const i = new WeakMap,
            o = async (a, l) => {
                let u = n(a);
                const f = mr(u, l);
                if (!f) {
                    const d = {
                        channelCount: u.channelCount,
                        channelCountMode: u.channelCountMode,
                        channelInterpretation: u.channelInterpretation,
                        pan: u.pan.value
                    };
                    u = e(l, d)
                }
                return i.set(l, u), f ? await t(l, a.pan, u.pan) : await r(l, a.pan, u.pan), Mu(u) ? await s(a, l, u.inputs[0]) : await s(a, l, u), u
            };
        return {
            render(a, l) {
                const u = i.get(l);
                return u !== void 0 ? Promise.resolve(u) : o(a, l)
            }
        }
    }, R4e = t => () => {
        if (t === null) return !1;
        try {
            new t({
                length: 1,
                sampleRate: 44100
            })
        } catch {
            return !1
        }
        return !0
    }, M4e = (t, e) => async () => {
        if (t === null) return !0;
        if (e === null) return !1;
        const n = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
                type: "application/javascript; charset=utf-8"
            }),
            r = new e(1, 128, 44100),
            s = URL.createObjectURL(n);
        let i = !1,
            o = !1;
        try {
            await r.audioWorklet.addModule(s);
            const a = new t(r, "a", {
                    numberOfOutputs: 0
                }),
                l = r.createOscillator();
            a.port.onmessage = () => i = !0, a.onprocessorerror = () => o = !0, l.connect(a), l.start(0), await r.startRendering()
        } catch {} finally {
            URL.revokeObjectURL(s)
        }
        return i && !o
    }, D4e = (t, e) => () => {
        if (e === null) return Promise.resolve(!1);
        const n = new e(1, 1, 44100),
            r = t(n, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                gain: 0
            });
        return new Promise(s => {
            n.oncomplete = () => {
                r.disconnect(), s(n.currentTime !== 0)
            }, n.startRendering()
        })
    }, $4e = () => new DOMException("", "UnknownError"), L4e = {
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        curve: null,
        oversample: "none"
    }, F4e = (t, e, n, r, s, i, o) => class extends t {
        constructor(l, u) {
            const f = s(l),
                d = {
                    ...L4e,
                    ...u
                },
                p = n(f, d),
                v = i(f) ? r() : null;
            super(l, !0, p, v), this._isCurveNullified = !1, this._nativeWaveShaperNode = p, o(this, 1)
        }
        get curve() {
            return this._isCurveNullified ? null : this._nativeWaveShaperNode.curve
        }
        set curve(l) {
            if (l === null) this._isCurveNullified = !0, this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
            else {
                if (l.length < 2) throw e();
                this._isCurveNullified = !1, this._nativeWaveShaperNode.curve = l
            }
        }
        get oversample() {
            return this._nativeWaveShaperNode.oversample
        }
        set oversample(l) {
            this._nativeWaveShaperNode.oversample = l
        }
    }, U4e = (t, e, n) => () => {
        const r = new WeakMap,
            s = async (i, o) => {
                let a = e(i);
                if (!mr(a, o)) {
                    const u = {
                        channelCount: a.channelCount,
                        channelCountMode: a.channelCountMode,
                        channelInterpretation: a.channelInterpretation,
                        curve: a.curve,
                        oversample: a.oversample
                    };
                    a = t(o, u)
                }
                return r.set(o, a), Mu(a) ? await n(i, o, a.inputs[0]) : await n(i, o, a), a
            };
        return {
            render(i, o) {
                const a = r.get(o);
                return a !== void 0 ? Promise.resolve(a) : s(i, o)
            }
        }
    }, B4e = () => typeof window > "u" ? null : window, q4e = (t, e) => n => {
        n.copyFromChannel = (r, s, i = 0) => {
            const o = t(i),
                a = t(s);
            if (a >= n.numberOfChannels) throw e();
            const l = n.length,
                u = n.getChannelData(a),
                f = r.length;
            for (let d = o < 0 ? -o : 0; d + o < l && d < f; d += 1) r[d] = u[d + o]
        }, n.copyToChannel = (r, s, i = 0) => {
            const o = t(i),
                a = t(s);
            if (a >= n.numberOfChannels) throw e();
            const l = n.length,
                u = n.getChannelData(a),
                f = r.length;
            for (let d = o < 0 ? -o : 0; d + o < l && d < f; d += 1) u[d + o] = r[d]
        }
    }, G4e = t => e => {
        e.copyFromChannel = (n => (r, s, i = 0) => {
            const o = t(i),
                a = t(s);
            if (o < e.length) return n.call(e, r, a, o)
        })(e.copyFromChannel), e.copyToChannel = (n => (r, s, i = 0) => {
            const o = t(i),
                a = t(s);
            if (o < e.length) return n.call(e, r, a, o)
        })(e.copyToChannel)
    }, V4e = t => (e, n) => {
        const r = n.createBuffer(1, 1, 44100);
        e.buffer === null && (e.buffer = r), t(e, "buffer", s => () => {
            const i = s.call(e);
            return i === r ? null : i
        }, s => i => s.call(e, i === null ? r : i))
    }, j4e = (t, e) => (n, r) => {
        r.channelCount = 1, r.channelCountMode = "explicit", Object.defineProperty(r, "channelCount", {
            get: () => 1,
            set: () => {
                throw t()
            }
        }), Object.defineProperty(r, "channelCountMode", {
            get: () => "explicit",
            set: () => {
                throw t()
            }
        });
        const s = n.createBufferSource();
        e(r, () => {
            const a = r.numberOfInputs;
            for (let l = 0; l < a; l += 1) s.connect(r, 0, l)
        }, () => s.disconnect(r))
    }, ZC = (t, e, n) => t.copyFromChannel === void 0 ? t.getChannelData(n)[0] : (t.copyFromChannel(e, n), e[0]), XC = t => {
        if (t === null) return !1;
        const e = t.length;
        return e % 2 !== 0 ? t[Math.floor(e / 2)] !== 0 : t[e / 2 - 1] + t[e / 2] !== 0
    }, td = (t, e, n, r) => {
        let s = t;
        for (; !s.hasOwnProperty(e);) s = Object.getPrototypeOf(s);
        const {
            get: i,
            set: o
        } = Object.getOwnPropertyDescriptor(s, e);
        Object.defineProperty(t, e, {
            get: n(i),
            set: r(o)
        })
    }, W4e = t => ({
        ...t,
        outputChannelCount: t.outputChannelCount !== void 0 ? t.outputChannelCount : t.numberOfInputs === 1 && t.numberOfOutputs === 1 ? [t.channelCount] : Array.from({
            length: t.numberOfOutputs
        }, () => 1)
    }), H4e = t => ({
        ...t,
        channelCount: t.numberOfOutputs
    }), Y4e = t => {
        const {
            imag: e,
            real: n
        } = t;
        return e === void 0 ? n === void 0 ? {
            ...t,
            imag: [0, 0],
            real: [0, 0]
        } : {
            ...t,
            imag: Array.from(n, () => 0),
            real: n
        } : n === void 0 ? {
            ...t,
            imag: e,
            real: Array.from(e, () => 0)
        } : {
            ...t,
            imag: e,
            real: n
        }
    }, QC = (t, e, n) => {
        try {
            t.setValueAtTime(e, n)
        } catch (r) {
            if (r.code !== 9) throw r;
            QC(t, e, n + 1e-7)
        }
    }, z4e = t => {
        const e = t.createBufferSource();
        e.start();
        try {
            e.start()
        } catch {
            return !0
        }
        return !1
    }, K4e = t => {
        const e = t.createBufferSource(),
            n = t.createBuffer(1, 1, 44100);
        e.buffer = n;
        try {
            e.start(0, 1)
        } catch {
            return !1
        }
        return !0
    }, Z4e = t => {
        const e = t.createBufferSource();
        e.start();
        try {
            e.stop()
        } catch {
            return !1
        }
        return !0
    }, sb = t => {
        const e = t.createOscillator();
        try {
            e.start(-1)
        } catch (n) {
            return n instanceof RangeError
        }
        return !1
    }, JC = t => {
        const e = t.createBuffer(1, 1, 44100),
            n = t.createBufferSource();
        n.buffer = e, n.start(), n.stop();
        try {
            return n.stop(), !0
        } catch {
            return !1
        }
    }, ib = t => {
        const e = t.createOscillator();
        try {
            e.stop(-1)
        } catch (n) {
            return n instanceof RangeError
        }
        return !1
    }, X4e = t => {
        const {
            port1: e,
            port2: n
        } = new MessageChannel;
        try {
            e.postMessage(t)
        } finally {
            e.close(), n.close()
        }
    }, Q4e = t => {
        t.start = (e => (n = 0, r = 0, s) => {
            const i = t.buffer,
                o = i === null ? r : Math.min(i.duration, r);
            i !== null && o > i.duration - .5 / t.context.sampleRate ? e.call(t, n, 0, 0) : e.call(t, n, o, s)
        })(t.start)
    }, ek = (t, e) => {
        const n = e.createGain();
        t.connect(n);
        const r = (s => () => {
            s.call(t, n), t.removeEventListener("ended", r)
        })(t.disconnect);
        t.addEventListener("ended", r), Du(t, n), t.stop = (s => {
            let i = !1;
            return (o = 0) => {
                if (i) try {
                    s.call(t, o)
                } catch {
                    n.gain.setValueAtTime(0, o)
                } else s.call(t, o), i = !0
            }
        })(t.stop)
    }, $u = (t, e) => n => {
        const r = {
            value: t
        };
        return Object.defineProperties(n, {
            currentTarget: r,
            target: r
        }), typeof e == "function" ? e.call(t, n) : e.handleEvent.call(t, n)
    }, J4e = v3e(Lc), eEe = A3e(Lc), tEe = Lbe(bg), tk = new WeakMap, nEe = t5e(tk), si = dbe(new Map, new WeakMap), Ci = B4e(), nk = x5e(si, Fi), ob = e5e(Tr), sr = w4e(Tr, ob, Ac), rEe = N3e(nk, on, sr), en = s5e(vg), Eo = s4e(Ci), jt = E5e(Eo), rk = new WeakMap, sk = Ybe($u), nd = D5e(Ci), ab = _5e(nd), cb = y5e(Ci), ik = v5e(Ci), rf = L5e(Ci), In = tbe(b3e(PC), w3e(J4e, eEe, k1, tEe, I1, Tr, nEe, Kf, on, Lc, uo, Ac, Vp), si, f5e(Tv, I1, Tr, on, tf, uo), Fi, Eg, Ar, Rbe(k1, Tv, Tr, on, tf, en, uo, jt), Bbe(rk, Tr, Xs), sk, en, ab, cb, ik, jt, rf), sEe = I3e(In, rEe, Fi, nk, en, jt), lb = new WeakSet, Bw = P5e(Ci), ok = Obe(new Uint32Array(1)), ub = q4e(ok, Fi), hb = G4e(ok), iEe = P3e(lb, si, Ar, Bw, Eo, R4e(Bw), ub, hb), Tg = O3e(qr), ak = A4e(ob, Xf, Ac), Ui = bbe(ak), Lu = M5e(Tg, si, z4e, K4e, Z4e, sb, JC, ib, Q4e, V4e(td), ek), Bi = S4e(n5e(Xf), ak), oEe = D3e(Ui, Lu, on, Bi, sr), ii = nbe(E3e(RC), rk, Q3, rbe, d3e, p3e, m3e, g3e, _3e, vv, NC, nd, QC), aEe = M3e(In, oEe, ii, Hn, Lu, en, jt, $u), cEe = j3e(In, W3e, Fi, Hn, $5e(qr, td), en, jt, sr), lEe = fbe(Ui, YC, on, Bi, sr), Fc = k4e(tk), uEe = hbe(In, ii, lEe, Eg, YC, en, jt, Fc), Ra = I5e(Lc, cb), hEe = j4e(Hn, Ra), Ma = j5e(nd, hEe), fEe = gbe(Ma, on, sr), dEe = mbe(In, fEe, Ma, en, jt), pEe = vbe(Jf, on, sr), mEe = ybe(In, pEe, Jf, en, jt, H4e), gEe = Y5e(Tg, Lu, qr, Ra), Fu = H5e(Tg, si, gEe, sb, ib), _Ee = Abe(Ui, Fu, on, Bi, sr), yEe = wbe(In, ii, _Ee, Fu, en, jt, $u), ck = z5e(Ar, td), vEe = Ibe(ck, on, sr), bEe = kbe(In, vEe, ck, en, jt, Fc), EEe = $be(Ui, zC, on, Bi, sr), TEe = Dbe(In, ii, EEe, zC, en, jt, Fc), lk = K5e(Ar), SEe = jbe(Ui, lk, on, Bi, sr), wEe = Vbe(In, ii, SEe, lk, Ar, en, jt, Fc), AEe = Qbe(Ui, qr, on, Bi, sr), OEe = Xbe(In, ii, AEe, qr, en, jt), CEe = J5e(Eg, Hn, ed, Ar), Sg = O4e(si, qr, ed, D4e(qr, Eo)), kEe = h5e(Lu, on, Eo, sr, Sg), IEe = Z5e(CEe), NEe = l5e(In, IEe, kEe, en, jt, Fc), xEe = H3e(ii, Ma, Fu, ed, Ar, ZC, jt, td), uk = new WeakMap, PEe = k5e(cEe, xEe, sk, jt, uk, $u), hk = i4e(Tg, si, sb, JC, ib, ek), REe = _4e(Ui, hk, on, Bi, sr), MEe = g4e(In, ii, hk, REe, en, jt, $u), fk = Tbe(Lu), DEe = f4e(fk, Hn, qr, XC, Ra), wg = h4e(fk, Hn, DEe, XC, Ra, nd, td), $Ee = a4e(k1, Hn, Ma, qr, ed, wg, Ar, I1, ZC, Ra), dk = o4e($Ee), LEe = b4e(Ui, Ma, Fu, qr, dk, on, Eo, Bi, sr, Sg), FEe = v4e(In, ii, dk, LEe, en, jt, Fc), UEe = c4e(Fi), BEe = T4e(UEe, en, new WeakSet, Y4e), qEe = u4e(Ma, Jf, qr, wg, Ar, Ra), pk = l4e(qEe, Ar), GEe = P4e(Ui, pk, on, Bi, sr), VEe = x4e(In, ii, pk, GEe, en, jt), jEe = U4e(wg, on, sr), WEe = F4e(In, Hn, wg, jEe, en, jt, Fc), mk = T5e(Ci), fb = zbe(Ci), gk = new WeakMap, HEe = i5e(gk, Eo), YEe = mk ? S3e(si, Ar, Hbe(Ci), fb, Kbe(y3e), en, HEe, jt, rf, new WeakMap, new WeakMap, M4e(rf, Eo), Ci) : void 0, zEe = b5e(ab, jt), KEe = Pbe(lb, si, xbe, Wbe, new WeakSet, en, zEe, O1, nf, ub, hb), _k = lbe(YEe, sEe, iEe, aEe, uEe, dEe, mEe, yEe, bEe, KEe, TEe, wEe, OEe, NEe, PEe, MEe, FEe, BEe, VEe, WEe), ZEe = S5e(In, e4e, en, jt), XEe = A5e(In, t4e, en, jt), QEe = O5e(In, n4e, en, jt), JEe = r4e(Hn, jt), eTe = C5e(In, JEe, en), tTe = V3e(_k, Hn, Ar, $4e, ZEe, XEe, QEe, eTe, nd), db = o5e(uk), nTe = C3e(db), yk = Ebe(Fi), rTe = Fbe(db), vk = qbe(Fi), bk = new WeakMap, sTe = Jbe(bk, Xs), iTe = V5e(yk, Fi, Hn, Ma, Jf, Fu, qr, ed, Ar, vk, fb, sTe, Ra), oTe = U5e(Hn, iTe, qr, Ar, Ra), aTe = cbe(Ui, yk, Lu, Ma, Jf, Fu, qr, rTe, vk, fb, on, rf, Eo, Bi, sr, Sg), cTe = r5e(gk), lTe = C4e(bk), qw = mk ? ibe(nTe, In, ii, aTe, oTe, Tr, cTe, en, jt, rf, W4e, lTe, X4e, $u) : void 0, uTe = Nbe(Ar, Eo), hTe = I4e(lb, si, ob, db, Sg, O1, ub, hb), fTe = p4e(_k, si, Hn, uTe, hTe), dTe = d5e(vg, ab), pTe = p5e(X3, cb), mTe = m5e(Q3, ik), gTe = g5e(vg, jt);

function Qe(t, e) {
    if (!t) throw new Error(e)
}

function Qs(t, e, n = 1 / 0) {
    if (!(e <= t && t <= n)) throw new RangeError(`Value must be within [${e}, ${n}], got: ${t}`)
}

function Ek(t) {
    !t.isOffline && t.state !== "running" && pb('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.')
}
let Tk = console;

function _Te(...t) {
    Tk.log(...t)
}

function pb(...t) {
    Tk.warn(...t)
}

function ks(t) {
    return typeof t > "u"
}

function wt(t) {
    return !ks(t)
}

function yTe(t) {
    return typeof t == "function"
}

function po(t) {
    return typeof t == "number"
}

function _c(t) {
    return Object.prototype.toString.call(t) === "[object Object]" && t.constructor === Object
}

function vTe(t) {
    return typeof t == "boolean"
}

function is(t) {
    return Array.isArray(t)
}

function ki(t) {
    return typeof t == "string"
}

function Ip(t) {
    return ki(t) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(t)
}

function bTe(t) {
    return new tTe(t)
}

function ETe(t, e, n) {
    return new fTe(t, e, n)
}
const yc = typeof self == "object" ? self : null,
    TTe = yc && (yc.hasOwnProperty("AudioContext") || yc.hasOwnProperty("webkitAudioContext"));

function STe(t, e, n) {
    return Qe(wt(qw), "This node only works in a secure context (https or localhost)"), new qw(t, e, n)
}

function oi(t, e, n, r) {
    var s = arguments.length,
        i = s < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
        o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") i = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (i = (s < 3 ? o(i) : s > 3 ? o(e, n, i) : o(e, n)) || i);
    return s > 3 && i && Object.defineProperty(e, n, i), i
}

function kn(t, e, n, r) {
    function s(i) {
        return i instanceof n ? i : new n(function(o) {
            o(i)
        })
    }
    return new(n || (n = Promise))(function(i, o) {
        function a(f) {
            try {
                u(r.next(f))
            } catch (d) {
                o(d)
            }
        }

        function l(f) {
            try {
                u(r.throw(f))
            } catch (d) {
                o(d)
            }
        }

        function u(f) {
            f.done ? i(f.value) : s(f.value).then(a, l)
        }
        u((r = r.apply(t, e || [])).next())
    })
}
class wTe {
    constructor(e, n, r) {
        this._callback = e, this._type = n, this._updateInterval = r, this._createClock()
    }
    _createWorker() {
        const e = new Blob([`
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval*1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`], {
                type: "text/javascript"
            }),
            n = URL.createObjectURL(e),
            r = new Worker(n);
        r.onmessage = this._callback.bind(this), this._worker = r
    }
    _createTimeout() {
        this._timeout = setTimeout(() => {
            this._createTimeout(), this._callback()
        }, this._updateInterval * 1e3)
    }
    _createClock() {
        if (this._type === "worker") try {
            this._createWorker()
        } catch {
            this._type = "timeout", this._createClock()
        } else this._type === "timeout" && this._createTimeout()
    }
    _disposeClock() {
        this._timeout && (clearTimeout(this._timeout), this._timeout = 0), this._worker && (this._worker.terminate(), this._worker.onmessage = null)
    }
    get updateInterval() {
        return this._updateInterval
    }
    set updateInterval(e) {
        this._updateInterval = Math.max(e, 128 / 44100), this._type === "worker" && this._worker.postMessage(Math.max(e * 1e3, 1))
    }
    get type() {
        return this._type
    }
    set type(e) {
        this._disposeClock(), this._type = e, this._createClock()
    }
    dispose() {
        this._disposeClock()
    }
}

function Oc(t) {
    return mTe(t)
}

function sa(t) {
    return pTe(t)
}

function jp(t) {
    return gTe(t)
}

function hl(t) {
    return dTe(t)
}

function Sk(t) {
    return t instanceof AudioBuffer
}

function ATe(t, e) {
    return t === "value" || Oc(e) || sa(e) || Sk(e)
}

function Is(t, ...e) {
    if (!e.length) return t;
    const n = e.shift();
    if (_c(t) && _c(n))
        for (const r in n) ATe(r, n[r]) ? t[r] = n[r] : _c(n[r]) ? (t[r] || Object.assign(t, {
            [r]: {}
        }), Is(t[r], n[r])) : Object.assign(t, {
            [r]: n[r]
        });
    return Is(t, ...e)
}

function OTe(t, e) {
    return t.length === e.length && t.every((n, r) => e[r] === n)
}

function re(t, e, n = [], r) {
    const s = {},
        i = Array.from(e);
    if (_c(i[0]) && r && !Reflect.has(i[0], r) && (Object.keys(i[0]).some(a => Reflect.has(t, a)) || (Is(s, {
            [r]: i[0]
        }), n.splice(n.indexOf(r), 1), i.shift())), i.length === 1 && _c(i[0])) Is(s, i[0]);
    else
        for (let o = 0; o < n.length; o++) wt(i[o]) && (s[n[o]] = i[o]);
    return Is(t, s)
}

function CTe(t) {
    return t.constructor.getDefaults()
}

function Ll(t, e) {
    return ks(t) ? e : t
}

function hr(t, e) {
    return e.forEach(n => {
        Reflect.has(t, n) && delete t[n]
    }), t
}
/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */
class To {
    constructor() {
        this.debug = !1, this._wasDisposed = !1
    }
    static getDefaults() {
        return {}
    }
    log(...e) {
        (this.debug || yc && this.toString() === yc.TONE_DEBUG_CLASS) && _Te(this, ...e)
    }
    dispose() {
        return this._wasDisposed = !0, this
    }
    get disposed() {
        return this._wasDisposed
    }
    toString() {
        return this.name
    }
}
To.version = IC;
const mb = 1e-6;

function R1(t, e) {
    return t > e + mb
}

function Cv(t, e) {
    return R1(t, e) || Gs(t, e)
}

function wk(t, e) {
    return t + mb < e
}

function Gs(t, e) {
    return Math.abs(t - e) < mb
}

function kTe(t, e, n) {
    return Math.max(Math.min(t, n), e)
}
let Da = class Ak extends To {
    constructor() {
        super(), this.name = "Timeline", this._timeline = [];
        const e = re(Ak.getDefaults(), arguments, ["memory"]);
        this.memory = e.memory, this.increasing = e.increasing
    }
    static getDefaults() {
        return {
            memory: 1 / 0,
            increasing: !1
        }
    }
    get length() {
        return this._timeline.length
    }
    add(e) {
        if (Qe(Reflect.has(e, "time"), "Timeline: events must have a time attribute"), e.time = e.time.valueOf(), this.increasing && this.length) {
            const n = this._timeline[this.length - 1];
            Qe(Cv(e.time, n.time), "The time must be greater than or equal to the last scheduled time"), this._timeline.push(e)
        } else {
            const n = this._search(e.time);
            this._timeline.splice(n + 1, 0, e)
        }
        if (this.length > this.memory) {
            const n = this.length - this.memory;
            this._timeline.splice(0, n)
        }
        return this
    }
    remove(e) {
        const n = this._timeline.indexOf(e);
        return n !== -1 && this._timeline.splice(n, 1), this
    }
    get(e, n = "time") {
        const r = this._search(e, n);
        return r !== -1 ? this._timeline[r] : null
    }
    peek() {
        return this._timeline[0]
    }
    shift() {
        return this._timeline.shift()
    }
    getAfter(e, n = "time") {
        const r = this._search(e, n);
        return r + 1 < this._timeline.length ? this._timeline[r + 1] : null
    }
    getBefore(e) {
        const n = this._timeline.length;
        if (n > 0 && this._timeline[n - 1].time < e) return this._timeline[n - 1];
        const r = this._search(e);
        return r - 1 >= 0 ? this._timeline[r - 1] : null
    }
    cancel(e) {
        if (this._timeline.length > 1) {
            let n = this._search(e);
            if (n >= 0)
                if (Gs(this._timeline[n].time, e)) {
                    for (let r = n; r >= 0 && Gs(this._timeline[r].time, e); r--) n = r;
                    this._timeline = this._timeline.slice(0, n)
                } else this._timeline = this._timeline.slice(0, n + 1);
            else this._timeline = []
        } else this._timeline.length === 1 && Cv(this._timeline[0].time, e) && (this._timeline = []);
        return this
    }
    cancelBefore(e) {
        const n = this._search(e);
        return n >= 0 && (this._timeline = this._timeline.slice(n + 1)), this
    }
    previousEvent(e) {
        const n = this._timeline.indexOf(e);
        return n > 0 ? this._timeline[n - 1] : null
    }
    _search(e, n = "time") {
        if (this._timeline.length === 0) return -1;
        let r = 0;
        const s = this._timeline.length;
        let i = s;
        if (s > 0 && this._timeline[s - 1][n] <= e) return s - 1;
        for (; r < i;) {
            let o = Math.floor(r + (i - r) / 2);
            const a = this._timeline[o],
                l = this._timeline[o + 1];
            if (Gs(a[n], e)) {
                for (let u = o; u < this._timeline.length; u++) {
                    const f = this._timeline[u];
                    if (Gs(f[n], e)) o = u;
                    else break
                }
                return o
            } else {
                if (wk(a[n], e) && R1(l[n], e)) return o;
                R1(a[n], e) ? i = o : r = o + 1
            }
        }
        return -1
    }
    _iterate(e, n = 0, r = this._timeline.length - 1) {
        this._timeline.slice(n, r + 1).forEach(e)
    }
    forEach(e) {
        return this._iterate(e), this
    }
    forEachBefore(e, n) {
        const r = this._search(e);
        return r !== -1 && this._iterate(n, 0, r), this
    }
    forEachAfter(e, n) {
        const r = this._search(e);
        return this._iterate(n, r + 1), this
    }
    forEachBetween(e, n, r) {
        let s = this._search(e),
            i = this._search(n);
        return s !== -1 && i !== -1 ? (this._timeline[s].time !== e && (s += 1), this._timeline[i].time === n && (i -= 1), this._iterate(r, s, i)) : s === -1 && this._iterate(r, 0, i), this
    }
    forEachFrom(e, n) {
        let r = this._search(e);
        for (; r >= 0 && this._timeline[r].time >= e;) r--;
        return this._iterate(n, r + 1), this
    }
    forEachAtTime(e, n) {
        const r = this._search(e);
        if (r !== -1 && Gs(this._timeline[r].time, e)) {
            let s = r;
            for (let i = r; i >= 0 && Gs(this._timeline[i].time, e); i--) s = i;
            this._iterate(i => {
                n(i)
            }, s, r)
        }
        return this
    }
    dispose() {
        return super.dispose(), this._timeline = [], this
    }
};
const Ok = [];

function Ag(t) {
    Ok.push(t)
}

function ITe(t) {
    Ok.forEach(e => e(t))
}
const Ck = [];

function Og(t) {
    Ck.push(t)
}

function NTe(t) {
    Ck.forEach(e => e(t))
}
class rd extends To {
    constructor() {
        super(...arguments), this.name = "Emitter"
    }
    on(e, n) {
        return e.split(/\W+/).forEach(s => {
            ks(this._events) && (this._events = {}), this._events.hasOwnProperty(s) || (this._events[s] = []), this._events[s].push(n)
        }), this
    }
    once(e, n) {
        const r = (...s) => {
            n(...s), this.off(e, r)
        };
        return this.on(e, r), this
    }
    off(e, n) {
        return e.split(/\W+/).forEach(s => {
            if (ks(this._events) && (this._events = {}), this._events.hasOwnProperty(e))
                if (ks(n)) this._events[e] = [];
                else {
                    const i = this._events[e];
                    for (let o = i.length - 1; o >= 0; o--) i[o] === n && i.splice(o, 1)
                }
        }), this
    }
    emit(e, ...n) {
        if (this._events && this._events.hasOwnProperty(e)) {
            const r = this._events[e].slice(0);
            for (let s = 0, i = r.length; s < i; s++) r[s].apply(this, n)
        }
        return this
    }
    static mixin(e) {
        ["on", "once", "off", "emit"].forEach(n => {
            const r = Object.getOwnPropertyDescriptor(rd.prototype, n);
            Object.defineProperty(e.prototype, n, r)
        })
    }
    dispose() {
        return super.dispose(), this._events = void 0, this
    }
}
class kk extends rd {
    constructor() {
        super(...arguments), this.isOffline = !1
    }
    toJSON() {
        return {}
    }
}
class sd extends kk {
    constructor() {
        super(), this.name = "Context", this._constants = new Map, this._timeouts = new Da, this._timeoutIds = 0, this._initialized = !1, this.isOffline = !1, this._workletModules = new Map;
        const e = re(sd.getDefaults(), arguments, ["context"]);
        e.context ? this._context = e.context : this._context = bTe({
            latencyHint: e.latencyHint
        }), this._ticker = new wTe(this.emit.bind(this, "tick"), e.clockSource, e.updateInterval), this.on("tick", this._timeoutLoop.bind(this)), this._context.onstatechange = () => {
            this.emit("statechange", this.state)
        }, this._setLatencyHint(e.latencyHint), this.lookAhead = e.lookAhead
    }
    static getDefaults() {
        return {
            clockSource: "worker",
            latencyHint: "interactive",
            lookAhead: .1,
            updateInterval: .05
        }
    }
    initialize() {
        return this._initialized || (ITe(this), this._initialized = !0), this
    }
    createAnalyser() {
        return this._context.createAnalyser()
    }
    createOscillator() {
        return this._context.createOscillator()
    }
    createBufferSource() {
        return this._context.createBufferSource()
    }
    createBiquadFilter() {
        return this._context.createBiquadFilter()
    }
    createBuffer(e, n, r) {
        return this._context.createBuffer(e, n, r)
    }
    createChannelMerger(e) {
        return this._context.createChannelMerger(e)
    }
    createChannelSplitter(e) {
        return this._context.createChannelSplitter(e)
    }
    createConstantSource() {
        return this._context.createConstantSource()
    }
    createConvolver() {
        return this._context.createConvolver()
    }
    createDelay(e) {
        return this._context.createDelay(e)
    }
    createDynamicsCompressor() {
        return this._context.createDynamicsCompressor()
    }
    createGain() {
        return this._context.createGain()
    }
    createIIRFilter(e, n) {
        return this._context.createIIRFilter(e, n)
    }
    createPanner() {
        return this._context.createPanner()
    }
    createPeriodicWave(e, n, r) {
        return this._context.createPeriodicWave(e, n, r)
    }
    createStereoPanner() {
        return this._context.createStereoPanner()
    }
    createWaveShaper() {
        return this._context.createWaveShaper()
    }
    createMediaStreamSource(e) {
        return Qe(hl(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamSource(e)
    }
    createMediaElementSource(e) {
        return Qe(hl(this._context), "Not available if OfflineAudioContext"), this._context.createMediaElementSource(e)
    }
    createMediaStreamDestination() {
        return Qe(hl(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamDestination()
    }
    decodeAudioData(e) {
        return this._context.decodeAudioData(e)
    }
    get currentTime() {
        return this._context.currentTime
    }
    get state() {
        return this._context.state
    }
    get sampleRate() {
        return this._context.sampleRate
    }
    get listener() {
        return this.initialize(), this._listener
    }
    set listener(e) {
        Qe(!this._initialized, "The listener cannot be set after initialization."), this._listener = e
    }
    get transport() {
        return this.initialize(), this._transport
    }
    set transport(e) {
        Qe(!this._initialized, "The transport cannot be set after initialization."), this._transport = e
    }
    get draw() {
        return this.initialize(), this._draw
    }
    set draw(e) {
        Qe(!this._initialized, "Draw cannot be set after initialization."), this._draw = e
    }
    get destination() {
        return this.initialize(), this._destination
    }
    set destination(e) {
        Qe(!this._initialized, "The destination cannot be set after initialization."), this._destination = e
    }
    createAudioWorkletNode(e, n) {
        return STe(this.rawContext, e, n)
    }
    addAudioWorkletModule(e, n) {
        return kn(this, void 0, void 0, function*() {
            Qe(wt(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)"), this._workletModules.has(n) || this._workletModules.set(n, this.rawContext.audioWorklet.addModule(e)), yield this._workletModules.get(n)
        })
    }
    workletsAreReady() {
        return kn(this, void 0, void 0, function*() {
            const e = [];
            this._workletModules.forEach(n => e.push(n)), yield Promise.all(e)
        })
    }
    get updateInterval() {
        return this._ticker.updateInterval
    }
    set updateInterval(e) {
        this._ticker.updateInterval = e
    }
    get clockSource() {
        return this._ticker.type
    }
    set clockSource(e) {
        this._ticker.type = e
    }
    get latencyHint() {
        return this._latencyHint
    }
    _setLatencyHint(e) {
        let n = 0;
        if (this._latencyHint = e, ki(e)) switch (e) {
            case "interactive":
                n = .1;
                break;
            case "playback":
                n = .5;
                break;
            case "balanced":
                n = .25;
                break
        }
        this.lookAhead = n, this.updateInterval = n / 2
    }
    get rawContext() {
        return this._context
    }
    now() {
        return this._context.currentTime + this.lookAhead
    }
    immediate() {
        return this._context.currentTime
    }
    resume() {
        return hl(this._context) ? this._context.resume() : Promise.resolve()
    }
    close() {
        return kn(this, void 0, void 0, function*() {
            hl(this._context) && (yield this._context.close()), this._initialized && NTe(this)
        })
    }
    getConstant(e) {
        if (this._constants.has(e)) return this._constants.get(e); {
            const n = this._context.createBuffer(1, 128, this._context.sampleRate),
                r = n.getChannelData(0);
            for (let i = 0; i < r.length; i++) r[i] = e;
            const s = this._context.createBufferSource();
            return s.channelCount = 1, s.channelCountMode = "explicit", s.buffer = n, s.loop = !0, s.start(0), this._constants.set(e, s), s
        }
    }
    dispose() {
        return super.dispose(), this._ticker.dispose(), this._timeouts.dispose(), Object.keys(this._constants).map(e => this._constants[e].disconnect()), this
    }
    _timeoutLoop() {
        const e = this.now();
        let n = this._timeouts.peek();
        for (; this._timeouts.length && n && n.time <= e;) n.callback(), this._timeouts.shift(), n = this._timeouts.peek()
    }
    setTimeout(e, n) {
        this._timeoutIds++;
        const r = this.now();
        return this._timeouts.add({
            callback: e,
            id: this._timeoutIds,
            time: r + n
        }), this._timeoutIds
    }
    clearTimeout(e) {
        return this._timeouts.forEach(n => {
            n.id === e && this._timeouts.remove(n)
        }), this
    }
    clearInterval(e) {
        return this.clearTimeout(e)
    }
    setInterval(e, n) {
        const r = ++this._timeoutIds,
            s = () => {
                const i = this.now();
                this._timeouts.add({
                    callback: () => {
                        e(), s()
                    },
                    id: r,
                    time: i + n
                })
            };
        return s(), r
    }
}
class xTe extends kk {
    constructor() {
        super(...arguments), this.lookAhead = 0, this.latencyHint = 0, this.isOffline = !1
    }
    createAnalyser() {
        return {}
    }
    createOscillator() {
        return {}
    }
    createBufferSource() {
        return {}
    }
    createBiquadFilter() {
        return {}
    }
    createBuffer(e, n, r) {
        return {}
    }
    createChannelMerger(e) {
        return {}
    }
    createChannelSplitter(e) {
        return {}
    }
    createConstantSource() {
        return {}
    }
    createConvolver() {
        return {}
    }
    createDelay(e) {
        return {}
    }
    createDynamicsCompressor() {
        return {}
    }
    createGain() {
        return {}
    }
    createIIRFilter(e, n) {
        return {}
    }
    createPanner() {
        return {}
    }
    createPeriodicWave(e, n, r) {
        return {}
    }
    createStereoPanner() {
        return {}
    }
    createWaveShaper() {
        return {}
    }
    createMediaStreamSource(e) {
        return {}
    }
    createMediaElementSource(e) {
        return {}
    }
    createMediaStreamDestination() {
        return {}
    }
    decodeAudioData(e) {
        return Promise.resolve({})
    }
    createAudioWorkletNode(e, n) {
        return {}
    }
    get rawContext() {
        return {}
    }
    addAudioWorkletModule(e, n) {
        return kn(this, void 0, void 0, function*() {
            return Promise.resolve()
        })
    }
    resume() {
        return Promise.resolve()
    }
    setTimeout(e, n) {
        return 0
    }
    clearTimeout(e) {
        return this
    }
    setInterval(e, n) {
        return 0
    }
    clearInterval(e) {
        return this
    }
    getConstant(e) {
        return {}
    }
    get currentTime() {
        return 0
    }
    get state() {
        return {}
    }
    get sampleRate() {
        return 0
    }
    get listener() {
        return {}
    }
    get transport() {
        return {}
    }
    get draw() {
        return {}
    }
    set draw(e) {}
    get destination() {
        return {}
    }
    set destination(e) {}
    now() {
        return 0
    }
    immediate() {
        return 0
    }
}

function ze(t, e) {
    is(e) ? e.forEach(n => ze(t, n)) : Object.defineProperty(t, e, {
        enumerable: !0,
        writable: !1
    })
}

function id(t, e) {
    is(e) ? e.forEach(n => id(t, n)) : Object.defineProperty(t, e, {
        writable: !0
    })
}
const yt = () => {};
class Pt extends To {
    constructor() {
        super(), this.name = "ToneAudioBuffer", this.onload = yt;
        const e = re(Pt.getDefaults(), arguments, ["url", "onload", "onerror"]);
        this.reverse = e.reverse, this.onload = e.onload, e.url && Sk(e.url) || e.url instanceof Pt ? this.set(e.url) : ki(e.url) && this.load(e.url).catch(e.onerror)
    }
    static getDefaults() {
        return {
            onerror: yt,
            onload: yt,
            reverse: !1
        }
    }
    get sampleRate() {
        return this._buffer ? this._buffer.sampleRate : ws().sampleRate
    }
    set(e) {
        return e instanceof Pt ? e.loaded ? this._buffer = e.get() : e.onload = () => {
            this.set(e), this.onload(this)
        } : this._buffer = e, this._reversed && this._reverse(), this
    }
    get() {
        return this._buffer
    }
    load(e) {
        return kn(this, void 0, void 0, function*() {
            const n = Pt.load(e).then(r => {
                this.set(r), this.onload(this)
            });
            Pt.downloads.push(n);
            try {
                yield n
            } finally {
                const r = Pt.downloads.indexOf(n);
                Pt.downloads.splice(r, 1)
            }
            return this
        })
    }
    dispose() {
        return super.dispose(), this._buffer = void 0, this
    }
    fromArray(e) {
        const n = is(e) && e[0].length > 0,
            r = n ? e.length : 1,
            s = n ? e[0].length : e.length,
            i = ws(),
            o = i.createBuffer(r, s, i.sampleRate),
            a = !n && r === 1 ? [e] : e;
        for (let l = 0; l < r; l++) o.copyToChannel(a[l], l);
        return this._buffer = o, this
    }
    toMono(e) {
        if (po(e)) this.fromArray(this.toArray(e));
        else {
            let n = new Float32Array(this.length);
            const r = this.numberOfChannels;
            for (let s = 0; s < r; s++) {
                const i = this.toArray(s);
                for (let o = 0; o < i.length; o++) n[o] += i[o]
            }
            n = n.map(s => s / r), this.fromArray(n)
        }
        return this
    }
    toArray(e) {
        if (po(e)) return this.getChannelData(e);
        if (this.numberOfChannels === 1) return this.toArray(0); {
            const n = [];
            for (let r = 0; r < this.numberOfChannels; r++) n[r] = this.getChannelData(r);
            return n
        }
    }
    getChannelData(e) {
        return this._buffer ? this._buffer.getChannelData(e) : new Float32Array(0)
    }
    slice(e, n = this.duration) {
        const r = Math.floor(e * this.sampleRate),
            s = Math.floor(n * this.sampleRate);
        Qe(r < s, "The start time must be less than the end time");
        const i = s - r,
            o = ws().createBuffer(this.numberOfChannels, i, this.sampleRate);
        for (let a = 0; a < this.numberOfChannels; a++) o.copyToChannel(this.getChannelData(a).subarray(r, s), a);
        return new Pt(o)
    }
    _reverse() {
        if (this.loaded)
            for (let e = 0; e < this.numberOfChannels; e++) this.getChannelData(e).reverse();
        return this
    }
    get loaded() {
        return this.length > 0
    }
    get duration() {
        return this._buffer ? this._buffer.duration : 0
    }
    get length() {
        return this._buffer ? this._buffer.length : 0
    }
    get numberOfChannels() {
        return this._buffer ? this._buffer.numberOfChannels : 0
    }
    get reverse() {
        return this._reversed
    }
    set reverse(e) {
        this._reversed !== e && (this._reversed = e, this._reverse())
    }
    static fromArray(e) {
        return new Pt().fromArray(e)
    }
    static fromUrl(e) {
        return kn(this, void 0, void 0, function*() {
            return yield new Pt().load(e)
        })
    }
    static load(e) {
        return kn(this, void 0, void 0, function*() {
            const n = e.match(/\[([^\]\[]+\|.+)\]$/);
            if (n) {
                const a = n[1].split("|");
                let l = a[0];
                for (const u of a)
                    if (Pt.supportsType(u)) {
                        l = u;
                        break
                    } e = e.replace(n[0], l)
            }
            const r = Pt.baseUrl === "" || Pt.baseUrl.endsWith("/") ? Pt.baseUrl : Pt.baseUrl + "/",
                s = yield fetch(r + e);
            if (!s.ok) throw new Error(`could not load url: ${e}`);
            const i = yield s.arrayBuffer();
            return yield ws().decodeAudioData(i)
        })
    }
    static supportsType(e) {
        const n = e.split("."),
            r = n[n.length - 1];
        return document.createElement("audio").canPlayType("audio/" + r) !== ""
    }
    static loaded() {
        return kn(this, void 0, void 0, function*() {
            for (yield Promise.resolve(); Pt.downloads.length;) yield Pt.downloads[0]
        })
    }
}
Pt.baseUrl = "";
Pt.downloads = [];
class Cg extends sd {
    constructor() {
        super({
            clockSource: "offline",
            context: jp(arguments[0]) ? arguments[0] : ETe(arguments[0], arguments[1] * arguments[2], arguments[2]),
            lookAhead: 0,
            updateInterval: jp(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
        }), this.name = "OfflineContext", this._currentTime = 0, this.isOffline = !0, this._duration = jp(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1]
    }
    now() {
        return this._currentTime
    }
    get currentTime() {
        return this._currentTime
    }
    _renderClock(e) {
        return kn(this, void 0, void 0, function*() {
            let n = 0;
            for (; this._duration - this._currentTime >= 0;) {
                this.emit("tick"), this._currentTime += 128 / this.sampleRate, n++;
                const r = Math.floor(this.sampleRate / 128);
                e && n % r === 0 && (yield new Promise(s => setTimeout(s, 1)))
            }
        })
    }
    render(e = !0) {
        return kn(this, void 0, void 0, function*() {
            yield this.workletsAreReady(), yield this._renderClock(e);
            const n = yield this._context.startRendering();
            return new Pt(n)
        })
    }
    close() {
        return Promise.resolve()
    }
}
const Ik = new xTe;
let Fl = Ik;

function ws() {
    return Fl === Ik && TTe && PTe(new sd), Fl
}

function PTe(t) {
    hl(t) ? Fl = new sd(t) : jp(t) ? Fl = new Cg(t) : Fl = t
}

function sf() {
    return Fl.resume()
}
if (yc && !yc.TONE_SILENCE_LOGGING) {
    const e = ` * Tone.js v${IC} * `;
    console.log(`%c${e}`, "background: #000; color: #fff")
}

function M1(t) {
    return Math.pow(10, t / 20)
}

function gb(t) {
    return 20 * (Math.log(t) / Math.LN10)
}

function Cc(t) {
    return Math.pow(2, t / 12)
}
let kg = 440;

function RTe() {
    return kg
}

function MTe(t) {
    kg = t
}

function lc(t) {
    return Math.round(Ig(t))
}

function Ig(t) {
    return 69 + 12 * Math.log2(t / kg)
}

function Nk(t) {
    return kg * Math.pow(2, (t - 69) / 12)
}
class _b extends To {
    constructor(e, n, r) {
        super(), this.defaultUnits = "s", this._val = n, this._units = r, this.context = e, this._expressions = this._getExpressions()
    }
    _getExpressions() {
        return {
            hz: {
                method: e => this._frequencyToUnits(parseFloat(e)),
                regexp: /^(\d+(?:\.\d+)?)hz$/i
            },
            i: {
                method: e => this._ticksToUnits(parseInt(e, 10)),
                regexp: /^(\d+)i$/i
            },
            m: {
                method: e => this._beatsToUnits(parseInt(e, 10) * this._getTimeSignature()),
                regexp: /^(\d+)m$/i
            },
            n: {
                method: (e, n) => {
                    const r = parseInt(e, 10),
                        s = n === "." ? 1.5 : 1;
                    return r === 1 ? this._beatsToUnits(this._getTimeSignature()) * s : this._beatsToUnits(4 / r) * s
                },
                regexp: /^(\d+)n(\.?)$/i
            },
            number: {
                method: e => this._expressions[this.defaultUnits].method.call(this, e),
                regexp: /^(\d+(?:\.\d+)?)$/
            },
            s: {
                method: e => this._secondsToUnits(parseFloat(e)),
                regexp: /^(\d+(?:\.\d+)?)s$/
            },
            samples: {
                method: e => parseInt(e, 10) / this.context.sampleRate,
                regexp: /^(\d+)samples$/
            },
            t: {
                method: e => {
                    const n = parseInt(e, 10);
                    return this._beatsToUnits(8 / (Math.floor(n) * 3))
                },
                regexp: /^(\d+)t$/i
            },
            tr: {
                method: (e, n, r) => {
                    let s = 0;
                    return e && e !== "0" && (s += this._beatsToUnits(this._getTimeSignature() * parseFloat(e))), n && n !== "0" && (s += this._beatsToUnits(parseFloat(n))), r && r !== "0" && (s += this._beatsToUnits(parseFloat(r) / 4)), s
                },
                regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
            }
        }
    }
    valueOf() {
        if (this._val instanceof _b && this.fromType(this._val), ks(this._val)) return this._noArg();
        if (ki(this._val) && ks(this._units)) {
            for (const e in this._expressions)
                if (this._expressions[e].regexp.test(this._val.trim())) {
                    this._units = e;
                    break
                }
        } else if (_c(this._val)) {
            let e = 0;
            for (const n in this._val)
                if (wt(this._val[n])) {
                    const r = this._val[n],
                        s = new this.constructor(this.context, n).valueOf() * r;
                    e += s
                } return e
        }
        if (wt(this._units)) {
            const e = this._expressions[this._units],
                n = this._val.toString().trim().match(e.regexp);
            return n ? e.method.apply(this, n.slice(1)) : e.method.call(this, this._val)
        } else return ki(this._val) ? parseFloat(this._val) : this._val
    }
    _frequencyToUnits(e) {
        return 1 / e
    }
    _beatsToUnits(e) {
        return 60 / this._getBpm() * e
    }
    _secondsToUnits(e) {
        return e
    }
    _ticksToUnits(e) {
        return e * this._beatsToUnits(1) / this._getPPQ()
    }
    _noArg() {
        return this._now()
    }
    _getBpm() {
        return this.context.transport.bpm.value
    }
    _getTimeSignature() {
        return this.context.transport.timeSignature
    }
    _getPPQ() {
        return this.context.transport.PPQ
    }
    fromType(e) {
        switch (this._units = void 0, this.defaultUnits) {
            case "s":
                this._val = e.toSeconds();
                break;
            case "i":
                this._val = e.toTicks();
                break;
            case "hz":
                this._val = e.toFrequency();
                break;
            case "midi":
                this._val = e.toMidi();
                break
        }
        return this
    }
    toFrequency() {
        return 1 / this.toSeconds()
    }
    toSamples() {
        return this.toSeconds() * this.context.sampleRate
    }
    toMilliseconds() {
        return this.toSeconds() * 1e3
    }
}
class Ys extends _b {
    constructor() {
        super(...arguments), this.name = "TimeClass"
    }
    _getExpressions() {
        return Object.assign(super._getExpressions(), {
            now: {
                method: e => this._now() + new this.constructor(this.context, e).valueOf(),
                regexp: /^\+(.+)/
            },
            quantize: {
                method: e => {
                    const n = new Ys(this.context, e).valueOf();
                    return this._secondsToUnits(this.context.transport.nextSubdivision(n))
                },
                regexp: /^@(.+)/
            }
        })
    }
    quantize(e, n = 1) {
        const r = new this.constructor(this.context, e).valueOf(),
            s = this.valueOf(),
            a = Math.round(s / r) * r - s;
        return s + a * n
    }
    toNotation() {
        const e = this.toSeconds(),
            n = ["1m"];
        for (let i = 1; i < 9; i++) {
            const o = Math.pow(2, i);
            n.push(o + "n."), n.push(o + "n"), n.push(o + "t")
        }
        n.push("0");
        let r = n[0],
            s = new Ys(this.context, n[0]).toSeconds();
        return n.forEach(i => {
            const o = new Ys(this.context, i).toSeconds();
            Math.abs(o - e) < Math.abs(s - e) && (r = i, s = o)
        }), r
    }
    toBarsBeatsSixteenths() {
        const e = this._beatsToUnits(1);
        let n = this.valueOf() / e;
        n = parseFloat(n.toFixed(4));
        const r = Math.floor(n / this._getTimeSignature());
        let s = n % 1 * 4;
        n = Math.floor(n) % this._getTimeSignature();
        const i = s.toString();
        return i.length > 3 && (s = parseFloat(parseFloat(i).toFixed(3))), [r, n, s].join(":")
    }
    toTicks() {
        const e = this._beatsToUnits(1),
            n = this.valueOf() / e;
        return Math.round(n * this._getPPQ())
    }
    toSeconds() {
        return this.valueOf()
    }
    toMidi() {
        return lc(this.toFrequency())
    }
    _now() {
        return this.context.now()
    }
}
class er extends Ys {
    constructor() {
        super(...arguments), this.name = "Frequency", this.defaultUnits = "hz"
    }
    static get A4() {
        return RTe()
    }
    static set A4(e) {
        MTe(e)
    }
    _getExpressions() {
        return Object.assign({}, super._getExpressions(), {
            midi: {
                regexp: /^(\d+(?:\.\d+)?midi)/,
                method(e) {
                    return this.defaultUnits === "midi" ? e : er.mtof(e)
                }
            },
            note: {
                regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,
                method(e, n) {
                    const s = DTe[e.toLowerCase()] + (parseInt(n, 10) + 1) * 12;
                    return this.defaultUnits === "midi" ? s : er.mtof(s)
                }
            },
            tr: {
                regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
                method(e, n, r) {
                    let s = 1;
                    return e && e !== "0" && (s *= this._beatsToUnits(this._getTimeSignature() * parseFloat(e))), n && n !== "0" && (s *= this._beatsToUnits(parseFloat(n))), r && r !== "0" && (s *= this._beatsToUnits(parseFloat(r) / 4)), s
                }
            }
        })
    }
    transpose(e) {
        return new er(this.context, this.valueOf() * Cc(e))
    }
    harmonize(e) {
        return e.map(n => this.transpose(n))
    }
    toMidi() {
        return lc(this.valueOf())
    }
    toNote() {
        const e = this.toFrequency(),
            n = Math.log2(e / er.A4);
        let r = Math.round(12 * n) + 57;
        const s = Math.floor(r / 12);
        return s < 0 && (r += -12 * s), $Te[r % 12] + s.toString()
    }
    toSeconds() {
        return 1 / super.toSeconds()
    }
    toTicks() {
        const e = this._beatsToUnits(1),
            n = this.valueOf() / e;
        return Math.floor(n * this._getPPQ())
    }
    _noArg() {
        return 0
    }
    _frequencyToUnits(e) {
        return e
    }
    _ticksToUnits(e) {
        return 1 / (e * 60 / (this._getBpm() * this._getPPQ()))
    }
    _beatsToUnits(e) {
        return 1 / super._beatsToUnits(e)
    }
    _secondsToUnits(e) {
        return 1 / e
    }
    static mtof(e) {
        return Nk(e)
    }
    static ftom(e) {
        return lc(e)
    }
}
const DTe = {
        cbb: -2,
        cb: -1,
        c: 0,
        "c#": 1,
        cx: 2,
        dbb: 0,
        db: 1,
        d: 2,
        "d#": 3,
        dx: 4,
        ebb: 2,
        eb: 3,
        e: 4,
        "e#": 5,
        ex: 6,
        fbb: 3,
        fb: 4,
        f: 5,
        "f#": 6,
        fx: 7,
        gbb: 5,
        gb: 6,
        g: 7,
        "g#": 8,
        gx: 9,
        abb: 7,
        ab: 8,
        a: 9,
        "a#": 10,
        ax: 11,
        bbb: 9,
        bb: 10,
        b: 11,
        "b#": 12,
        bx: 13
    },
    $Te = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

function Rh(t, e) {
    return new er(ws(), t, e)
}
class Mh extends Ys {
    constructor() {
        super(...arguments), this.name = "TransportTime"
    }
    _now() {
        return this.context.transport.seconds
    }
}
class Lr extends To {
    constructor() {
        super();
        const e = re(Lr.getDefaults(), arguments, ["context"]);
        this.defaultContext ? this.context = this.defaultContext : this.context = e.context
    }
    static getDefaults() {
        return {
            context: ws()
        }
    }
    now() {
        return this.context.currentTime + this.context.lookAhead
    }
    immediate() {
        return this.context.currentTime
    }
    get sampleTime() {
        return 1 / this.context.sampleRate
    }
    get blockTime() {
        return 128 / this.context.sampleRate
    }
    toSeconds(e) {
        return new Ys(this.context, e).toSeconds()
    }
    toFrequency(e) {
        return new er(this.context, e).toFrequency()
    }
    toTicks(e) {
        return new Mh(this.context, e).toTicks()
    }
    _getPartialProperties(e) {
        const n = this.get();
        return Object.keys(n).forEach(r => {
            ks(e[r]) && delete n[r]
        }), n
    }
    get() {
        const e = CTe(this);
        return Object.keys(e).forEach(n => {
            if (Reflect.has(this, n)) {
                const r = this[n];
                wt(r) && wt(r.value) && wt(r.setValueAtTime) ? e[n] = r.value : r instanceof Lr ? e[n] = r._getPartialProperties(e[n]) : is(r) || po(r) || ki(r) || vTe(r) ? e[n] = r : delete e[n]
            }
        }), e
    }
    set(e) {
        return Object.keys(e).forEach(n => {
            Reflect.has(this, n) && wt(this[n]) && (this[n] && wt(this[n].value) && wt(this[n].setValueAtTime) ? this[n].value !== e[n] && (this[n].value = e[n]) : this[n] instanceof Lr ? this[n].set(e[n]) : this[n] = e[n])
        }), this
    }
}
class yb extends Da {
    constructor(e = "stopped") {
        super(), this.name = "StateTimeline", this._initial = e, this.setStateAtTime(this._initial, 0)
    }
    getValueAtTime(e) {
        const n = this.get(e);
        return n !== null ? n.state : this._initial
    }
    setStateAtTime(e, n, r) {
        return Qs(n, 0), this.add(Object.assign({}, r, {
            state: e,
            time: n
        })), this
    }
    getLastState(e, n) {
        const r = this._search(n);
        for (let s = r; s >= 0; s--) {
            const i = this._timeline[s];
            if (i.state === e) return i
        }
    }
    getNextState(e, n) {
        const r = this._search(n);
        if (r !== -1)
            for (let s = r; s < this._timeline.length; s++) {
                const i = this._timeline[s];
                if (i.state === e) return i
            }
    }
}
class pt extends Lr {
    constructor() {
        super(re(pt.getDefaults(), arguments, ["param", "units", "convert"])), this.name = "Param", this.overridden = !1, this._minOutput = 1e-7;
        const e = re(pt.getDefaults(), arguments, ["param", "units", "convert"]);
        for (Qe(wt(e.param) && (Oc(e.param) || e.param instanceof pt), "param must be an AudioParam"); !Oc(e.param);) e.param = e.param._param;
        this._swappable = wt(e.swappable) ? e.swappable : !1, this._swappable ? (this.input = this.context.createGain(), this._param = e.param, this.input.connect(this._param)) : this._param = this.input = e.param, this._events = new Da(1e3), this._initialValue = this._param.defaultValue, this.units = e.units, this.convert = e.convert, this._minValue = e.minValue, this._maxValue = e.maxValue, wt(e.value) && e.value !== this._toType(this._initialValue) && this.setValueAtTime(e.value, 0)
    }
    static getDefaults() {
        return Object.assign(Lr.getDefaults(), {
            convert: !0,
            units: "number"
        })
    }
    get value() {
        const e = this.now();
        return this.getValueAtTime(e)
    }
    set value(e) {
        this.cancelScheduledValues(this.now()), this.setValueAtTime(e, this.now())
    }
    get minValue() {
        return wt(this._minValue) ? this._minValue : this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples" ? 0 : this.units === "audioRange" ? -1 : this.units === "decibels" ? -1 / 0 : this._param.minValue
    }
    get maxValue() {
        return wt(this._maxValue) ? this._maxValue : this.units === "normalRange" || this.units === "audioRange" ? 1 : this._param.maxValue
    }
    _is(e, n) {
        return this.units === n
    }
    _assertRange(e) {
        return wt(this.maxValue) && wt(this.minValue) && Qs(e, this._fromType(this.minValue), this._fromType(this.maxValue)), e
    }
    _fromType(e) {
        return this.convert && !this.overridden ? this._is(e, "time") ? this.toSeconds(e) : this._is(e, "decibels") ? M1(e) : this._is(e, "frequency") ? this.toFrequency(e) : e : this.overridden ? 0 : e
    }
    _toType(e) {
        return this.convert && this.units === "decibels" ? gb(e) : e
    }
    setValueAtTime(e, n) {
        const r = this.toSeconds(n),
            s = this._fromType(e);
        return Qe(isFinite(s) && isFinite(r), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`), this._assertRange(s), this.log(this.units, "setValueAtTime", e, r), this._events.add({
            time: r,
            type: "setValueAtTime",
            value: s
        }), this._param.setValueAtTime(s, r), this
    }
    getValueAtTime(e) {
        const n = Math.max(this.toSeconds(e), 0),
            r = this._events.getAfter(n),
            s = this._events.get(n);
        let i = this._initialValue;
        if (s === null) i = this._initialValue;
        else if (s.type === "setTargetAtTime" && (r === null || r.type === "setValueAtTime")) {
            const o = this._events.getBefore(s.time);
            let a;
            o === null ? a = this._initialValue : a = o.value, s.type === "setTargetAtTime" && (i = this._exponentialApproach(s.time, a, s.value, s.constant, n))
        } else if (r === null) i = s.value;
        else if (r.type === "linearRampToValueAtTime" || r.type === "exponentialRampToValueAtTime") {
            let o = s.value;
            if (s.type === "setTargetAtTime") {
                const a = this._events.getBefore(s.time);
                a === null ? o = this._initialValue : o = a.value
            }
            r.type === "linearRampToValueAtTime" ? i = this._linearInterpolate(s.time, o, r.time, r.value, n) : i = this._exponentialInterpolate(s.time, o, r.time, r.value, n)
        } else i = s.value;
        return this._toType(i)
    }
    setRampPoint(e) {
        e = this.toSeconds(e);
        let n = this.getValueAtTime(e);
        return this.cancelAndHoldAtTime(e), this._fromType(n) === 0 && (n = this._toType(this._minOutput)), this.setValueAtTime(n, e), this
    }
    linearRampToValueAtTime(e, n) {
        const r = this._fromType(e),
            s = this.toSeconds(n);
        return Qe(isFinite(r) && isFinite(s), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`), this._assertRange(r), this._events.add({
            time: s,
            type: "linearRampToValueAtTime",
            value: r
        }), this.log(this.units, "linearRampToValueAtTime", e, s), this._param.linearRampToValueAtTime(r, s), this
    }
    exponentialRampToValueAtTime(e, n) {
        let r = this._fromType(e);
        r = Gs(r, 0) ? this._minOutput : r, this._assertRange(r);
        const s = this.toSeconds(n);
        return Qe(isFinite(r) && isFinite(s), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`), this._events.add({
            time: s,
            type: "exponentialRampToValueAtTime",
            value: r
        }), this.log(this.units, "exponentialRampToValueAtTime", e, s), this._param.exponentialRampToValueAtTime(r, s), this
    }
    exponentialRampTo(e, n, r) {
        return r = this.toSeconds(r), this.setRampPoint(r), this.exponentialRampToValueAtTime(e, r + this.toSeconds(n)), this
    }
    linearRampTo(e, n, r) {
        return r = this.toSeconds(r), this.setRampPoint(r), this.linearRampToValueAtTime(e, r + this.toSeconds(n)), this
    }
    targetRampTo(e, n, r) {
        return r = this.toSeconds(r), this.setRampPoint(r), this.exponentialApproachValueAtTime(e, r, n), this
    }
    exponentialApproachValueAtTime(e, n, r) {
        n = this.toSeconds(n), r = this.toSeconds(r);
        const s = Math.log(r + 1) / Math.log(200);
        return this.setTargetAtTime(e, n, s), this.cancelAndHoldAtTime(n + r * .9), this.linearRampToValueAtTime(e, n + r), this
    }
    setTargetAtTime(e, n, r) {
        const s = this._fromType(e);
        Qe(isFinite(r) && r > 0, "timeConstant must be a number greater than 0");
        const i = this.toSeconds(n);
        return this._assertRange(s), Qe(isFinite(s) && isFinite(i), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`), this._events.add({
            constant: r,
            time: i,
            type: "setTargetAtTime",
            value: s
        }), this.log(this.units, "setTargetAtTime", e, i, r), this._param.setTargetAtTime(s, i, r), this
    }
    setValueCurveAtTime(e, n, r, s = 1) {
        r = this.toSeconds(r), n = this.toSeconds(n);
        const i = this._fromType(e[0]) * s;
        this.setValueAtTime(this._toType(i), n);
        const o = r / (e.length - 1);
        for (let a = 1; a < e.length; a++) {
            const l = this._fromType(e[a]) * s;
            this.linearRampToValueAtTime(this._toType(l), n + a * o)
        }
        return this
    }
    cancelScheduledValues(e) {
        const n = this.toSeconds(e);
        return Qe(isFinite(n), `Invalid argument to cancelScheduledValues: ${JSON.stringify(e)}`), this._events.cancel(n), this._param.cancelScheduledValues(n), this.log(this.units, "cancelScheduledValues", n), this
    }
    cancelAndHoldAtTime(e) {
        const n = this.toSeconds(e),
            r = this._fromType(this.getValueAtTime(n));
        Qe(isFinite(n), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(e)}`), this.log(this.units, "cancelAndHoldAtTime", n, "value=" + r);
        const s = this._events.get(n),
            i = this._events.getAfter(n);
        return s && Gs(s.time, n) ? i ? (this._param.cancelScheduledValues(i.time), this._events.cancel(i.time)) : (this._param.cancelAndHoldAtTime(n), this._events.cancel(n + this.sampleTime)) : i && (this._param.cancelScheduledValues(i.time), this._events.cancel(i.time), i.type === "linearRampToValueAtTime" ? this.linearRampToValueAtTime(this._toType(r), n) : i.type === "exponentialRampToValueAtTime" && this.exponentialRampToValueAtTime(this._toType(r), n)), this._events.add({
            time: n,
            type: "setValueAtTime",
            value: r
        }), this._param.setValueAtTime(r, n), this
    }
    rampTo(e, n = .1, r) {
        return this.units === "frequency" || this.units === "bpm" || this.units === "decibels" ? this.exponentialRampTo(e, n, r) : this.linearRampTo(e, n, r), this
    }
    apply(e) {
        const n = this.context.currentTime;
        e.setValueAtTime(this.getValueAtTime(n), n);
        const r = this._events.get(n);
        if (r && r.type === "setTargetAtTime") {
            const s = this._events.getAfter(r.time),
                i = s ? s.time : n + 2,
                o = (i - n) / 10;
            for (let a = n; a < i; a += o) e.linearRampToValueAtTime(this.getValueAtTime(a), a)
        }
        return this._events.forEachAfter(this.context.currentTime, s => {
            s.type === "cancelScheduledValues" ? e.cancelScheduledValues(s.time) : s.type === "setTargetAtTime" ? e.setTargetAtTime(s.value, s.time, s.constant) : e[s.type](s.value, s.time)
        }), this
    }
    setParam(e) {
        Qe(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
        const n = this.input;
        return n.disconnect(this._param), this.apply(e), this._param = e, n.connect(this._param), this
    }
    dispose() {
        return super.dispose(), this._events.dispose(), this
    }
    get defaultValue() {
        return this._toType(this._param.defaultValue)
    }
    _exponentialApproach(e, n, r, s, i) {
        return r + (n - r) * Math.exp(-(i - e) / s)
    }
    _linearInterpolate(e, n, r, s, i) {
        return n + (s - n) * ((i - e) / (r - e))
    }
    _exponentialInterpolate(e, n, r, s, i) {
        return n * Math.pow(s / n, (i - e) / (r - e))
    }
}
class Ne extends Lr {
    constructor() {
        super(...arguments), this.name = "ToneAudioNode", this._internalChannels = []
    }
    get numberOfInputs() {
        return wt(this.input) ? Oc(this.input) || this.input instanceof pt ? 1 : this.input.numberOfInputs : 0
    }
    get numberOfOutputs() {
        return wt(this.output) ? this.output.numberOfOutputs : 0
    }
    _isAudioNode(e) {
        return wt(e) && (e instanceof Ne || sa(e))
    }
    _getInternalNodes() {
        const e = this._internalChannels.slice(0);
        return this._isAudioNode(this.input) && e.push(this.input), this._isAudioNode(this.output) && this.input !== this.output && e.push(this.output), e
    }
    _setChannelProperties(e) {
        this._getInternalNodes().forEach(r => {
            r.channelCount = e.channelCount, r.channelCountMode = e.channelCountMode, r.channelInterpretation = e.channelInterpretation
        })
    }
    _getChannelProperties() {
        const e = this._getInternalNodes();
        Qe(e.length > 0, "ToneAudioNode does not have any internal nodes");
        const n = e[0];
        return {
            channelCount: n.channelCount,
            channelCountMode: n.channelCountMode,
            channelInterpretation: n.channelInterpretation
        }
    }
    get channelCount() {
        return this._getChannelProperties().channelCount
    }
    set channelCount(e) {
        const n = this._getChannelProperties();
        this._setChannelProperties(Object.assign(n, {
            channelCount: e
        }))
    }
    get channelCountMode() {
        return this._getChannelProperties().channelCountMode
    }
    set channelCountMode(e) {
        const n = this._getChannelProperties();
        this._setChannelProperties(Object.assign(n, {
            channelCountMode: e
        }))
    }
    get channelInterpretation() {
        return this._getChannelProperties().channelInterpretation
    }
    set channelInterpretation(e) {
        const n = this._getChannelProperties();
        this._setChannelProperties(Object.assign(n, {
            channelInterpretation: e
        }))
    }
    connect(e, n = 0, r = 0) {
        return xs(this, e, n, r), this
    }
    toDestination() {
        return this.connect(this.context.destination), this
    }
    toMaster() {
        return pb("toMaster() has been renamed toDestination()"), this.toDestination()
    }
    disconnect(e, n = 0, r = 0) {
        return xk(this, e, n, r), this
    }
    chain(...e) {
        return Ns(this, ...e), this
    }
    fan(...e) {
        return e.forEach(n => this.connect(n)), this
    }
    dispose() {
        return super.dispose(), wt(this.input) && (this.input instanceof Ne ? this.input.dispose() : sa(this.input) && this.input.disconnect()), wt(this.output) && (this.output instanceof Ne ? this.output.dispose() : sa(this.output) && this.output.disconnect()), this._internalChannels = [], this
    }
}

function Ns(...t) {
    const e = t.shift();
    t.reduce((n, r) => (n instanceof Ne ? n.connect(r) : sa(n) && xs(n, r), r), e)
}

function xs(t, e, n = 0, r = 0) {
    for (Qe(wt(t), "Cannot connect from undefined node"), Qe(wt(e), "Cannot connect to undefined node"), (e instanceof Ne || sa(e)) && Qe(e.numberOfInputs > 0, "Cannot connect to node with no inputs"), Qe(t.numberOfOutputs > 0, "Cannot connect from node with no outputs"); e instanceof Ne || e instanceof pt;) wt(e.input) && (e = e.input);
    for (; t instanceof Ne;) wt(t.output) && (t = t.output);
    Oc(e) ? t.connect(e, n) : t.connect(e, n, r)
}

function xk(t, e, n = 0, r = 0) {
    if (wt(e))
        for (; e instanceof Ne;) e = e.input;
    for (; !sa(t);) wt(t.output) && (t = t.output);
    Oc(e) ? t.disconnect(e, n) : sa(e) ? t.disconnect(e, n, r) : t.disconnect()
}
class Ye extends Ne {
    constructor() {
        super(re(Ye.getDefaults(), arguments, ["gain", "units"])), this.name = "Gain", this._gainNode = this.context.createGain(), this.input = this._gainNode, this.output = this._gainNode;
        const e = re(Ye.getDefaults(), arguments, ["gain", "units"]);
        this.gain = new pt({
            context: this.context,
            convert: e.convert,
            param: this._gainNode.gain,
            units: e.units,
            value: e.gain,
            minValue: e.minValue,
            maxValue: e.maxValue
        }), ze(this, "gain")
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            convert: !0,
            gain: 1,
            units: "gain"
        })
    }
    dispose() {
        return super.dispose(), this._gainNode.disconnect(), this.gain.dispose(), this
    }
}
class nu extends Ne {
    constructor(e) {
        super(e), this.onended = yt, this._startTime = -1, this._stopTime = -1, this._timeout = -1, this.output = new Ye({
            context: this.context,
            gain: 0
        }), this._gainNode = this.output, this.getStateAtTime = function(n) {
            const r = this.toSeconds(n);
            return this._startTime !== -1 && r >= this._startTime && (this._stopTime === -1 || r <= this._stopTime) ? "started" : "stopped"
        }, this._fadeIn = e.fadeIn, this._fadeOut = e.fadeOut, this._curve = e.curve, this.onended = e.onended
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            curve: "linear",
            fadeIn: 0,
            fadeOut: 0,
            onended: yt
        })
    }
    _startGain(e, n = 1) {
        Qe(this._startTime === -1, "Source cannot be started more than once");
        const r = this.toSeconds(this._fadeIn);
        return this._startTime = e + r, this._startTime = Math.max(this._startTime, this.context.currentTime), r > 0 ? (this._gainNode.gain.setValueAtTime(0, e), this._curve === "linear" ? this._gainNode.gain.linearRampToValueAtTime(n, e + r) : this._gainNode.gain.exponentialApproachValueAtTime(n, e, r)) : this._gainNode.gain.setValueAtTime(n, e), this
    }
    stop(e) {
        return this.log("stop", e), this._stopGain(this.toSeconds(e)), this
    }
    _stopGain(e) {
        Qe(this._startTime !== -1, "'start' must be called before 'stop'"), this.cancelStop();
        const n = this.toSeconds(this._fadeOut);
        return this._stopTime = this.toSeconds(e) + n, this._stopTime = Math.max(this._stopTime, this.context.currentTime), n > 0 ? this._curve === "linear" ? this._gainNode.gain.linearRampTo(0, n, e) : this._gainNode.gain.targetRampTo(0, n, e) : (this._gainNode.gain.cancelAndHoldAtTime(e), this._gainNode.gain.setValueAtTime(0, e)), this.context.clearTimeout(this._timeout), this._timeout = this.context.setTimeout(() => {
            const r = this._curve === "exponential" ? n * 2 : 0;
            this._stopSource(this.now() + r), this._onended()
        }, this._stopTime - this.context.currentTime), this
    }
    _onended() {
        if (this.onended !== yt && (this.onended(this), this.onended = yt, !this.context.isOffline)) {
            const e = () => this.dispose();
            typeof window.requestIdleCallback < "u" ? window.requestIdleCallback(e) : setTimeout(e, 1e3)
        }
    }
    get state() {
        return this.getStateAtTime(this.now())
    }
    cancelStop() {
        return this.log("cancelStop"), Qe(this._startTime !== -1, "Source is not started"), this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime), this.context.clearTimeout(this._timeout), this._stopTime = -1, this
    }
    dispose() {
        return super.dispose(), this._gainNode.disconnect(), this
    }
}
class D1 extends nu {
    constructor() {
        super(re(D1.getDefaults(), arguments, ["offset"])), this.name = "ToneConstantSource", this._source = this.context.createConstantSource();
        const e = re(D1.getDefaults(), arguments, ["offset"]);
        xs(this._source, this._gainNode), this.offset = new pt({
            context: this.context,
            convert: e.convert,
            param: this._source.offset,
            units: e.units,
            value: e.offset,
            minValue: e.minValue,
            maxValue: e.maxValue
        })
    }
    static getDefaults() {
        return Object.assign(nu.getDefaults(), {
            convert: !0,
            offset: 1,
            units: "number"
        })
    }
    start(e) {
        const n = this.toSeconds(e);
        return this.log("start", n), this._startGain(n), this._source.start(n), this
    }
    _stopSource(e) {
        this._source.stop(e)
    }
    dispose() {
        return super.dispose(), this.state === "started" && this.stop(), this._source.disconnect(), this.offset.dispose(), this
    }
}
class Je extends Ne {
    constructor() {
        super(re(Je.getDefaults(), arguments, ["value", "units"])), this.name = "Signal", this.override = !0;
        const e = re(Je.getDefaults(), arguments, ["value", "units"]);
        this.output = this._constantSource = new D1({
            context: this.context,
            convert: e.convert,
            offset: e.value,
            units: e.units,
            minValue: e.minValue,
            maxValue: e.maxValue
        }), this._constantSource.start(0), this.input = this._param = this._constantSource.offset
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            convert: !0,
            units: "number",
            value: 0
        })
    }
    connect(e, n = 0, r = 0) {
        return Ng(this, e, n, r), this
    }
    dispose() {
        return super.dispose(), this._param.dispose(), this._constantSource.dispose(), this
    }
    setValueAtTime(e, n) {
        return this._param.setValueAtTime(e, n), this
    }
    getValueAtTime(e) {
        return this._param.getValueAtTime(e)
    }
    setRampPoint(e) {
        return this._param.setRampPoint(e), this
    }
    linearRampToValueAtTime(e, n) {
        return this._param.linearRampToValueAtTime(e, n), this
    }
    exponentialRampToValueAtTime(e, n) {
        return this._param.exponentialRampToValueAtTime(e, n), this
    }
    exponentialRampTo(e, n, r) {
        return this._param.exponentialRampTo(e, n, r), this
    }
    linearRampTo(e, n, r) {
        return this._param.linearRampTo(e, n, r), this
    }
    targetRampTo(e, n, r) {
        return this._param.targetRampTo(e, n, r), this
    }
    exponentialApproachValueAtTime(e, n, r) {
        return this._param.exponentialApproachValueAtTime(e, n, r), this
    }
    setTargetAtTime(e, n, r) {
        return this._param.setTargetAtTime(e, n, r), this
    }
    setValueCurveAtTime(e, n, r, s) {
        return this._param.setValueCurveAtTime(e, n, r, s), this
    }
    cancelScheduledValues(e) {
        return this._param.cancelScheduledValues(e), this
    }
    cancelAndHoldAtTime(e) {
        return this._param.cancelAndHoldAtTime(e), this
    }
    rampTo(e, n, r) {
        return this._param.rampTo(e, n, r), this
    }
    get value() {
        return this._param.value
    }
    set value(e) {
        this._param.value = e
    }
    get convert() {
        return this._param.convert
    }
    set convert(e) {
        this._param.convert = e
    }
    get units() {
        return this._param.units
    }
    get overridden() {
        return this._param.overridden
    }
    set overridden(e) {
        this._param.overridden = e
    }
    get maxValue() {
        return this._param.maxValue
    }
    get minValue() {
        return this._param.minValue
    }
    apply(e) {
        return this._param.apply(e), this
    }
}

function Ng(t, e, n, r) {
    (e instanceof pt || Oc(e) || e instanceof Je && e.override) && (e.cancelScheduledValues(0), e.setValueAtTime(0, 0), e instanceof Je && (e.overridden = !0)), xs(t, e, n, r)
}
class $1 extends pt {
    constructor() {
        super(re($1.getDefaults(), arguments, ["value"])), this.name = "TickParam", this._events = new Da(1 / 0), this._multiplier = 1;
        const e = re($1.getDefaults(), arguments, ["value"]);
        this._multiplier = e.multiplier, this._events.cancel(0), this._events.add({
            ticks: 0,
            time: 0,
            type: "setValueAtTime",
            value: this._fromType(e.value)
        }), this.setValueAtTime(e.value, 0)
    }
    static getDefaults() {
        return Object.assign(pt.getDefaults(), {
            multiplier: 1,
            units: "hertz",
            value: 1
        })
    }
    setTargetAtTime(e, n, r) {
        n = this.toSeconds(n), this.setRampPoint(n);
        const s = this._fromType(e),
            i = this._events.get(n),
            o = Math.round(Math.max(1 / r, 1));
        for (let a = 0; a <= o; a++) {
            const l = r * a + n,
                u = this._exponentialApproach(i.time, i.value, s, r, l);
            this.linearRampToValueAtTime(this._toType(u), l)
        }
        return this
    }
    setValueAtTime(e, n) {
        const r = this.toSeconds(n);
        super.setValueAtTime(e, n);
        const s = this._events.get(r),
            i = this._events.previousEvent(s),
            o = this._getTicksUntilEvent(i, r);
        return s.ticks = Math.max(o, 0), this
    }
    linearRampToValueAtTime(e, n) {
        const r = this.toSeconds(n);
        super.linearRampToValueAtTime(e, n);
        const s = this._events.get(r),
            i = this._events.previousEvent(s),
            o = this._getTicksUntilEvent(i, r);
        return s.ticks = Math.max(o, 0), this
    }
    exponentialRampToValueAtTime(e, n) {
        n = this.toSeconds(n);
        const r = this._fromType(e),
            s = this._events.get(n),
            i = Math.round(Math.max((n - s.time) * 10, 1)),
            o = (n - s.time) / i;
        for (let a = 0; a <= i; a++) {
            const l = o * a + s.time,
                u = this._exponentialInterpolate(s.time, s.value, n, r, l);
            this.linearRampToValueAtTime(this._toType(u), l)
        }
        return this
    }
    _getTicksUntilEvent(e, n) {
        if (e === null) e = {
            ticks: 0,
            time: 0,
            type: "setValueAtTime",
            value: 0
        };
        else if (ks(e.ticks)) {
            const o = this._events.previousEvent(e);
            e.ticks = this._getTicksUntilEvent(o, e.time)
        }
        const r = this._fromType(this.getValueAtTime(e.time));
        let s = this._fromType(this.getValueAtTime(n));
        const i = this._events.get(n);
        return i && i.time === n && i.type === "setValueAtTime" && (s = this._fromType(this.getValueAtTime(n - this.sampleTime))), .5 * (n - e.time) * (r + s) + e.ticks
    }
    getTicksAtTime(e) {
        const n = this.toSeconds(e),
            r = this._events.get(n);
        return Math.max(this._getTicksUntilEvent(r, n), 0)
    }
    getDurationOfTicks(e, n) {
        const r = this.toSeconds(n),
            s = this.getTicksAtTime(n);
        return this.getTimeOfTick(s + e) - r
    }
    getTimeOfTick(e) {
        const n = this._events.get(e, "ticks"),
            r = this._events.getAfter(e, "ticks");
        if (n && n.ticks === e) return n.time;
        if (n && r && r.type === "linearRampToValueAtTime" && n.value !== r.value) {
            const s = this._fromType(this.getValueAtTime(n.time)),
                o = (this._fromType(this.getValueAtTime(r.time)) - s) / (r.time - n.time),
                a = Math.sqrt(Math.pow(s, 2) - 2 * o * (n.ticks - e)),
                l = (-s + a) / o,
                u = (-s - a) / o;
            return (l > 0 ? l : u) + n.time
        } else return n ? n.value === 0 ? 1 / 0 : n.time + (e - n.ticks) / n.value : e / this._initialValue
    }
    ticksToTime(e, n) {
        return this.getDurationOfTicks(e, n)
    }
    timeToTicks(e, n) {
        const r = this.toSeconds(n),
            s = this.toSeconds(e),
            i = this.getTicksAtTime(r);
        return this.getTicksAtTime(r + s) - i
    }
    _fromType(e) {
        return this.units === "bpm" && this.multiplier ? 1 / (60 / e / this.multiplier) : super._fromType(e)
    }
    _toType(e) {
        return this.units === "bpm" && this.multiplier ? e / this.multiplier * 60 : super._toType(e)
    }
    get multiplier() {
        return this._multiplier
    }
    set multiplier(e) {
        const n = this.value;
        this._multiplier = e, this.cancelScheduledValues(0), this.setValueAtTime(n, 0)
    }
}
class L1 extends Je {
    constructor() {
        super(re(L1.getDefaults(), arguments, ["value"])), this.name = "TickSignal";
        const e = re(L1.getDefaults(), arguments, ["value"]);
        this.input = this._param = new $1({
            context: this.context,
            convert: e.convert,
            multiplier: e.multiplier,
            param: this._constantSource.offset,
            units: e.units,
            value: e.value
        })
    }
    static getDefaults() {
        return Object.assign(Je.getDefaults(), {
            multiplier: 1,
            units: "hertz",
            value: 1
        })
    }
    ticksToTime(e, n) {
        return this._param.ticksToTime(e, n)
    }
    timeToTicks(e, n) {
        return this._param.timeToTicks(e, n)
    }
    getTimeOfTick(e) {
        return this._param.getTimeOfTick(e)
    }
    getDurationOfTicks(e, n) {
        return this._param.getDurationOfTicks(e, n)
    }
    getTicksAtTime(e) {
        return this._param.getTicksAtTime(e)
    }
    get multiplier() {
        return this._param.multiplier
    }
    set multiplier(e) {
        this._param.multiplier = e
    }
    dispose() {
        return super.dispose(), this._param.dispose(), this
    }
}
class F1 extends Lr {
    constructor() {
        super(re(F1.getDefaults(), arguments, ["frequency"])), this.name = "TickSource", this._state = new yb, this._tickOffset = new Da;
        const e = re(F1.getDefaults(), arguments, ["frequency"]);
        this.frequency = new L1({
            context: this.context,
            units: e.units,
            value: e.frequency
        }), ze(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.setTicksAtTime(0, 0)
    }
    static getDefaults() {
        return Object.assign({
            frequency: 1,
            units: "hertz"
        }, Lr.getDefaults())
    }
    get state() {
        return this.getStateAtTime(this.now())
    }
    start(e, n) {
        const r = this.toSeconds(e);
        return this._state.getValueAtTime(r) !== "started" && (this._state.setStateAtTime("started", r), wt(n) && this.setTicksAtTime(n, r)), this
    }
    stop(e) {
        const n = this.toSeconds(e);
        if (this._state.getValueAtTime(n) === "stopped") {
            const r = this._state.get(n);
            r && r.time > 0 && (this._tickOffset.cancel(r.time), this._state.cancel(r.time))
        }
        return this._state.cancel(n), this._state.setStateAtTime("stopped", n), this.setTicksAtTime(0, n), this
    }
    pause(e) {
        const n = this.toSeconds(e);
        return this._state.getValueAtTime(n) === "started" && this._state.setStateAtTime("paused", n), this
    }
    cancel(e) {
        return e = this.toSeconds(e), this._state.cancel(e), this._tickOffset.cancel(e), this
    }
    getTicksAtTime(e) {
        const n = this.toSeconds(e),
            r = this._state.getLastState("stopped", n),
            s = {
                state: "paused",
                time: n
            };
        this._state.add(s);
        let i = r,
            o = 0;
        return this._state.forEachBetween(r.time, n + this.sampleTime, a => {
            let l = i.time;
            const u = this._tickOffset.get(a.time);
            u && u.time >= i.time && (o = u.ticks, l = u.time), i.state === "started" && a.state !== "started" && (o += this.frequency.getTicksAtTime(a.time) - this.frequency.getTicksAtTime(l)), i = a
        }), this._state.remove(s), o
    }
    get ticks() {
        return this.getTicksAtTime(this.now())
    }
    set ticks(e) {
        this.setTicksAtTime(e, this.now())
    }
    get seconds() {
        return this.getSecondsAtTime(this.now())
    }
    set seconds(e) {
        const n = this.now(),
            r = this.frequency.timeToTicks(e, n);
        this.setTicksAtTime(r, n)
    }
    getSecondsAtTime(e) {
        e = this.toSeconds(e);
        const n = this._state.getLastState("stopped", e),
            r = {
                state: "paused",
                time: e
            };
        this._state.add(r);
        let s = n,
            i = 0;
        return this._state.forEachBetween(n.time, e + this.sampleTime, o => {
            let a = s.time;
            const l = this._tickOffset.get(o.time);
            l && l.time >= s.time && (i = l.seconds, a = l.time), s.state === "started" && o.state !== "started" && (i += o.time - a), s = o
        }), this._state.remove(r), i
    }
    setTicksAtTime(e, n) {
        return n = this.toSeconds(n), this._tickOffset.cancel(n), this._tickOffset.add({
            seconds: this.frequency.getDurationOfTicks(e, n),
            ticks: e,
            time: n
        }), this
    }
    getStateAtTime(e) {
        return e = this.toSeconds(e), this._state.getValueAtTime(e)
    }
    getTimeOfTick(e, n = this.now()) {
        const r = this._tickOffset.get(n),
            s = this._state.get(n),
            i = Math.max(r.time, s.time),
            o = this.frequency.getTicksAtTime(i) + e - r.ticks;
        return this.frequency.getTimeOfTick(o)
    }
    forEachTickBetween(e, n, r) {
        let s = this._state.get(e);
        this._state.forEachBetween(e, n, o => {
            s && s.state === "started" && o.state !== "started" && this.forEachTickBetween(Math.max(s.time, e), o.time - this.sampleTime, r), s = o
        });
        let i = null;
        if (s && s.state === "started") {
            const o = Math.max(s.time, e),
                a = this.frequency.getTicksAtTime(o),
                l = this.frequency.getTicksAtTime(s.time),
                u = a - l;
            let f = Math.ceil(u) - u;
            f = Gs(f, 1) ? 0 : f;
            let d = this.frequency.getTimeOfTick(a + f);
            for (; d < n;) {
                try {
                    r(d, Math.round(this.getTicksAtTime(d)))
                } catch (p) {
                    i = p;
                    break
                }
                d += this.frequency.getDurationOfTicks(1, d)
            }
        }
        if (i) throw i;
        return this
    }
    dispose() {
        return super.dispose(), this._state.dispose(), this._tickOffset.dispose(), this.frequency.dispose(), this
    }
}
class of extends Lr {
    constructor() {
        super(re(of.getDefaults(), arguments, ["callback", "frequency"])), this.name = "Clock", this.callback = yt, this._lastUpdate = 0, this._state = new yb("stopped"), this._boundLoop = this._loop.bind(this);
        const e = re(of.getDefaults(), arguments, ["callback", "frequency"]);
        this.callback = e.callback, this._tickSource = new F1({
            context: this.context,
            frequency: e.frequency,
            units: e.units
        }), this._lastUpdate = 0, this.frequency = this._tickSource.frequency, ze(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.context.on("tick", this._boundLoop)
    }
    static getDefaults() {
        return Object.assign(Lr.getDefaults(), {
            callback: yt,
            frequency: 1,
            units: "hertz"
        })
    }
    get state() {
        return this._state.getValueAtTime(this.now())
    }
    start(e, n) {
        Ek(this.context);
        const r = this.toSeconds(e);
        return this.log("start", r), this._state.getValueAtTime(r) !== "started" && (this._state.setStateAtTime("started", r), this._tickSource.start(r, n), r < this._lastUpdate && this.emit("start", r, n)), this
    }
    stop(e) {
        const n = this.toSeconds(e);
        return this.log("stop", n), this._state.cancel(n), this._state.setStateAtTime("stopped", n), this._tickSource.stop(n), n < this._lastUpdate && this.emit("stop", n), this
    }
    pause(e) {
        const n = this.toSeconds(e);
        return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n), this._tickSource.pause(n), n < this._lastUpdate && this.emit("pause", n)), this
    }
    get ticks() {
        return Math.ceil(this.getTicksAtTime(this.now()))
    }
    set ticks(e) {
        this._tickSource.ticks = e
    }
    get seconds() {
        return this._tickSource.seconds
    }
    set seconds(e) {
        this._tickSource.seconds = e
    }
    getSecondsAtTime(e) {
        return this._tickSource.getSecondsAtTime(e)
    }
    setTicksAtTime(e, n) {
        return this._tickSource.setTicksAtTime(e, n), this
    }
    getTimeOfTick(e, n = this.now()) {
        return this._tickSource.getTimeOfTick(e, n)
    }
    getTicksAtTime(e) {
        return this._tickSource.getTicksAtTime(e)
    }
    nextTickTime(e, n) {
        const r = this.toSeconds(n),
            s = this.getTicksAtTime(r);
        return this._tickSource.getTimeOfTick(s + e, r)
    }
    _loop() {
        const e = this._lastUpdate,
            n = this.now();
        this._lastUpdate = n, this.log("loop", e, n), e !== n && (this._state.forEachBetween(e, n, r => {
            switch (r.state) {
                case "started":
                    const s = this._tickSource.getTicksAtTime(r.time);
                    this.emit("start", r.time, s);
                    break;
                case "stopped":
                    r.time !== 0 && this.emit("stop", r.time);
                    break;
                case "paused":
                    this.emit("pause", r.time);
                    break
            }
        }), this._tickSource.forEachTickBetween(e, n, (r, s) => {
            this.callback(r, s)
        }))
    }
    getStateAtTime(e) {
        const n = this.toSeconds(e);
        return this._state.getValueAtTime(n)
    }
    dispose() {
        return super.dispose(), this.context.off("tick", this._boundLoop), this._tickSource.dispose(), this._state.dispose(), this
    }
}
rd.mixin(of);
class os extends Ne {
    constructor() {
        super(re(os.getDefaults(), arguments, ["delayTime", "maxDelay"])), this.name = "Delay";
        const e = re(os.getDefaults(), arguments, ["delayTime", "maxDelay"]),
            n = this.toSeconds(e.maxDelay);
        this._maxDelay = Math.max(n, this.toSeconds(e.delayTime)), this._delayNode = this.input = this.output = this.context.createDelay(n), this.delayTime = new pt({
            context: this.context,
            param: this._delayNode.delayTime,
            units: "time",
            value: e.delayTime,
            minValue: 0,
            maxValue: this.maxDelay
        }), ze(this, "delayTime")
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            delayTime: 0,
            maxDelay: 1
        })
    }
    get maxDelay() {
        return this._maxDelay
    }
    dispose() {
        return super.dispose(), this._delayNode.disconnect(), this.delayTime.dispose(), this
    }
}
class od extends To {
    constructor() {
        super(), this.name = "ToneAudioBuffers", this._buffers = new Map, this._loadingCount = 0;
        const e = re(od.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
        this.baseUrl = e.baseUrl, Object.keys(e.urls).forEach(n => {
            this._loadingCount++;
            const r = e.urls[n];
            this.add(n, r, this._bufferLoaded.bind(this, e.onload), e.onerror)
        })
    }
    static getDefaults() {
        return {
            baseUrl: "",
            onerror: yt,
            onload: yt,
            urls: {}
        }
    }
    has(e) {
        return this._buffers.has(e.toString())
    }
    get(e) {
        return Qe(this.has(e), `ToneAudioBuffers has no buffer named: ${e}`), this._buffers.get(e.toString())
    }
    _bufferLoaded(e) {
        this._loadingCount--, this._loadingCount === 0 && e && e()
    }
    get loaded() {
        return Array.from(this._buffers).every(([e, n]) => n.loaded)
    }
    add(e, n, r = yt, s = yt) {
        return ki(n) ? this._buffers.set(e.toString(), new Pt(this.baseUrl + n, r, s)) : this._buffers.set(e.toString(), new Pt(n, r, s)), this
    }
    dispose() {
        return super.dispose(), this._buffers.forEach(e => e.dispose()), this._buffers.clear(), this
    }
}
class U1 extends er {
    constructor() {
        super(...arguments), this.name = "MidiClass", this.defaultUnits = "midi"
    }
    _frequencyToUnits(e) {
        return lc(super._frequencyToUnits(e))
    }
    _ticksToUnits(e) {
        return lc(super._ticksToUnits(e))
    }
    _beatsToUnits(e) {
        return lc(super._beatsToUnits(e))
    }
    _secondsToUnits(e) {
        return lc(super._secondsToUnits(e))
    }
    toMidi() {
        return this.valueOf()
    }
    toFrequency() {
        return Nk(this.toMidi())
    }
    transpose(e) {
        return new U1(this.context, this.toMidi() + e)
    }
}
class so extends Mh {
    constructor() {
        super(...arguments), this.name = "Ticks", this.defaultUnits = "i"
    }
    _now() {
        return this.context.transport.ticks
    }
    _beatsToUnits(e) {
        return this._getPPQ() * e
    }
    _secondsToUnits(e) {
        return Math.floor(e / (60 / this._getBpm()) * this._getPPQ())
    }
    _ticksToUnits(e) {
        return e
    }
    toTicks() {
        return this.valueOf()
    }
    toSeconds() {
        return this.valueOf() / this._getPPQ() * (60 / this._getBpm())
    }
}
class LTe extends Lr {
    constructor() {
        super(...arguments), this.name = "Draw", this.expiration = .25, this.anticipation = .008, this._events = new Da, this._boundDrawLoop = this._drawLoop.bind(this), this._animationFrame = -1
    }
    schedule(e, n) {
        return this._events.add({
            callback: e,
            time: this.toSeconds(n)
        }), this._events.length === 1 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)), this
    }
    cancel(e) {
        return this._events.cancel(this.toSeconds(e)), this
    }
    _drawLoop() {
        const e = this.context.currentTime;
        for (; this._events.length && this._events.peek().time - this.anticipation <= e;) {
            const n = this._events.shift();
            n && e - n.time <= this.expiration && n.callback()
        }
        this._events.length > 0 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop))
    }
    dispose() {
        return super.dispose(), this._events.dispose(), cancelAnimationFrame(this._animationFrame), this
    }
}
Ag(t => {
    t.draw = new LTe({
        context: t
    })
});
Og(t => {
    t.draw.dispose()
});
class FTe extends To {
    constructor() {
        super(...arguments), this.name = "IntervalTimeline", this._root = null, this._length = 0
    }
    add(e) {
        Qe(wt(e.time), "Events must have a time property"), Qe(wt(e.duration), "Events must have a duration parameter"), e.time = e.time.valueOf();
        let n = new UTe(e.time, e.time + e.duration, e);
        for (this._root === null ? this._root = n : this._root.insert(n), this._length++; n !== null;) n.updateHeight(), n.updateMax(), this._rebalance(n), n = n.parent;
        return this
    }
    remove(e) {
        if (this._root !== null) {
            const n = [];
            this._root.search(e.time, n);
            for (const r of n)
                if (r.event === e) {
                    this._removeNode(r), this._length--;
                    break
                }
        }
        return this
    }
    get length() {
        return this._length
    }
    cancel(e) {
        return this.forEachFrom(e, n => this.remove(n)), this
    }
    _setRoot(e) {
        this._root = e, this._root !== null && (this._root.parent = null)
    }
    _replaceNodeInParent(e, n) {
        e.parent !== null ? (e.isLeftChild() ? e.parent.left = n : e.parent.right = n, this._rebalance(e.parent)) : this._setRoot(n)
    }
    _removeNode(e) {
        if (e.left === null && e.right === null) this._replaceNodeInParent(e, null);
        else if (e.right === null) this._replaceNodeInParent(e, e.left);
        else if (e.left === null) this._replaceNodeInParent(e, e.right);
        else {
            const n = e.getBalance();
            let r, s = null;
            if (n > 0)
                if (e.left.right === null) r = e.left, r.right = e.right, s = r;
                else {
                    for (r = e.left.right; r.right !== null;) r = r.right;
                    r.parent && (r.parent.right = r.left, s = r.parent, r.left = e.left, r.right = e.right)
                }
            else if (e.right.left === null) r = e.right, r.left = e.left, s = r;
            else {
                for (r = e.right.left; r.left !== null;) r = r.left;
                r.parent && (r.parent.left = r.right, s = r.parent, r.left = e.left, r.right = e.right)
            }
            e.parent !== null ? e.isLeftChild() ? e.parent.left = r : e.parent.right = r : this._setRoot(r), s && this._rebalance(s)
        }
        e.dispose()
    }
    _rotateLeft(e) {
        const n = e.parent,
            r = e.isLeftChild(),
            s = e.right;
        s && (e.right = s.left, s.left = e), n !== null ? r ? n.left = s : n.right = s : this._setRoot(s)
    }
    _rotateRight(e) {
        const n = e.parent,
            r = e.isLeftChild(),
            s = e.left;
        s && (e.left = s.right, s.right = e), n !== null ? r ? n.left = s : n.right = s : this._setRoot(s)
    }
    _rebalance(e) {
        const n = e.getBalance();
        n > 1 && e.left ? e.left.getBalance() < 0 ? this._rotateLeft(e.left) : this._rotateRight(e) : n < -1 && e.right && (e.right.getBalance() > 0 ? this._rotateRight(e.right) : this._rotateLeft(e))
    }
    get(e) {
        if (this._root !== null) {
            const n = [];
            if (this._root.search(e, n), n.length > 0) {
                let r = n[0];
                for (let s = 1; s < n.length; s++) n[s].low > r.low && (r = n[s]);
                return r.event
            }
        }
        return null
    }
    forEach(e) {
        if (this._root !== null) {
            const n = [];
            this._root.traverse(r => n.push(r)), n.forEach(r => {
                r.event && e(r.event)
            })
        }
        return this
    }
    forEachAtTime(e, n) {
        if (this._root !== null) {
            const r = [];
            this._root.search(e, r), r.forEach(s => {
                s.event && n(s.event)
            })
        }
        return this
    }
    forEachFrom(e, n) {
        if (this._root !== null) {
            const r = [];
            this._root.searchAfter(e, r), r.forEach(s => {
                s.event && n(s.event)
            })
        }
        return this
    }
    dispose() {
        return super.dispose(), this._root !== null && this._root.traverse(e => e.dispose()), this._root = null, this
    }
}
class UTe {
    constructor(e, n, r) {
        this._left = null, this._right = null, this.parent = null, this.height = 0, this.event = r, this.low = e, this.high = n, this.max = this.high
    }
    insert(e) {
        e.low <= this.low ? this.left === null ? this.left = e : this.left.insert(e) : this.right === null ? this.right = e : this.right.insert(e)
    }
    search(e, n) {
        e > this.max || (this.left !== null && this.left.search(e, n), this.low <= e && this.high > e && n.push(this), !(this.low > e) && this.right !== null && this.right.search(e, n))
    }
    searchAfter(e, n) {
        this.low >= e && (n.push(this), this.left !== null && this.left.searchAfter(e, n)), this.right !== null && this.right.searchAfter(e, n)
    }
    traverse(e) {
        e(this), this.left !== null && this.left.traverse(e), this.right !== null && this.right.traverse(e)
    }
    updateHeight() {
        this.left !== null && this.right !== null ? this.height = Math.max(this.left.height, this.right.height) + 1 : this.right !== null ? this.height = this.right.height + 1 : this.left !== null ? this.height = this.left.height + 1 : this.height = 0
    }
    updateMax() {
        this.max = this.high, this.left !== null && (this.max = Math.max(this.max, this.left.max)), this.right !== null && (this.max = Math.max(this.max, this.right.max))
    }
    getBalance() {
        let e = 0;
        return this.left !== null && this.right !== null ? e = this.left.height - this.right.height : this.left !== null ? e = this.left.height + 1 : this.right !== null && (e = -(this.right.height + 1)), e
    }
    isLeftChild() {
        return this.parent !== null && this.parent.left === this
    }
    get left() {
        return this._left
    }
    set left(e) {
        this._left = e, e !== null && (e.parent = this), this.updateHeight(), this.updateMax()
    }
    get right() {
        return this._right
    }
    set right(e) {
        this._right = e, e !== null && (e.parent = this), this.updateHeight(), this.updateMax()
    }
    dispose() {
        this.parent = null, this._left = null, this._right = null, this.event = null
    }
}
class Ii extends Ne {
    constructor() {
        super(re(Ii.getDefaults(), arguments, ["volume"])), this.name = "Volume";
        const e = re(Ii.getDefaults(), arguments, ["volume"]);
        this.input = this.output = new Ye({
            context: this.context,
            gain: e.volume,
            units: "decibels"
        }), this.volume = this.output.gain, ze(this, "volume"), this._unmutedVolume = e.volume, this.mute = e.mute
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            mute: !1,
            volume: 0
        })
    }
    get mute() {
        return this.volume.value === -1 / 0
    }
    set mute(e) {
        !this.mute && e ? (this._unmutedVolume = this.volume.value, this.volume.value = -1 / 0) : this.mute && !e && (this.volume.value = this._unmutedVolume)
    }
    dispose() {
        return super.dispose(), this.input.dispose(), this.volume.dispose(), this
    }
}
class B1 extends Ne {
    constructor() {
        super(re(B1.getDefaults(), arguments)), this.name = "Destination", this.input = new Ii({
            context: this.context
        }), this.output = new Ye({
            context: this.context
        }), this.volume = this.input.volume;
        const e = re(B1.getDefaults(), arguments);
        Ns(this.input, this.output, this.context.rawContext.destination), this.mute = e.mute, this._internalChannels = [this.input, this.context.rawContext.destination, this.output]
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            mute: !1,
            volume: 0
        })
    }
    get mute() {
        return this.input.mute
    }
    set mute(e) {
        this.input.mute = e
    }
    chain(...e) {
        return this.input.disconnect(), e.unshift(this.input), e.push(this.output), Ns(...e), this
    }
    get maxChannelCount() {
        return this.context.rawContext.destination.maxChannelCount
    }
    dispose() {
        return super.dispose(), this.volume.dispose(), this
    }
}
Ag(t => {
    t.destination = new B1({
        context: t
    })
});
Og(t => {
    t.destination.dispose()
});
class BTe extends To {
    constructor(e) {
        super(), this.name = "TimelineValue", this._timeline = new Da({
            memory: 10
        }), this._initialValue = e
    }
    set(e, n) {
        return this._timeline.add({
            value: e,
            time: n
        }), this
    }
    get(e) {
        const n = this._timeline.get(e);
        return n ? n.value : this._initialValue
    }
}
class pa {
    constructor(e, n) {
        this.id = pa._eventId++;
        const r = Object.assign(pa.getDefaults(), n);
        this.transport = e, this.callback = r.callback, this._once = r.once, this.time = r.time
    }
    static getDefaults() {
        return {
            callback: yt,
            once: !1,
            time: 0
        }
    }
    invoke(e) {
        this.callback && (this.callback(e), this._once && this.transport.clear(this.id))
    }
    dispose() {
        return this.callback = void 0, this
    }
}
pa._eventId = 0;
class vb extends pa {
    constructor(e, n) {
        super(e, n), this._currentId = -1, this._nextId = -1, this._nextTick = this.time, this._boundRestart = this._restart.bind(this);
        const r = Object.assign(vb.getDefaults(), n);
        this.duration = new so(e.context, r.duration).valueOf(), this._interval = new so(e.context, r.interval).valueOf(), this._nextTick = r.time, this.transport.on("start", this._boundRestart), this.transport.on("loopStart", this._boundRestart), this.context = this.transport.context, this._restart()
    }
    static getDefaults() {
        return Object.assign({}, pa.getDefaults(), {
            duration: 1 / 0,
            interval: 1,
            once: !1
        })
    }
    invoke(e) {
        this._createEvents(e), super.invoke(e)
    }
    _createEvents(e) {
        const n = this.transport.getTicksAtTime(e);
        n >= this.time && n >= this._nextTick && this._nextTick + this._interval < this.time + this.duration && (this._nextTick += this._interval, this._currentId = this._nextId, this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new so(this.context, this._nextTick).toSeconds()))
    }
    _restart(e) {
        this.transport.clear(this._currentId), this.transport.clear(this._nextId), this._nextTick = this.time;
        const n = this.transport.getTicksAtTime(e);
        n > this.time && (this._nextTick = this.time + Math.ceil((n - this.time) / this._interval) * this._interval), this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new so(this.context, this._nextTick).toSeconds()), this._nextTick += this._interval, this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new so(this.context, this._nextTick).toSeconds())
    }
    dispose() {
        return super.dispose(), this.transport.clear(this._currentId), this.transport.clear(this._nextId), this.transport.off("start", this._boundRestart), this.transport.off("loopStart", this._boundRestart), this
    }
}
class af extends Lr {
    constructor() {
        super(re(af.getDefaults(), arguments)), this.name = "Transport", this._loop = new BTe(!1), this._loopStart = 0, this._loopEnd = 0, this._scheduledEvents = {}, this._timeline = new Da, this._repeatedEvents = new FTe, this._syncedSignals = [], this._swingAmount = 0;
        const e = re(af.getDefaults(), arguments);
        this._ppq = e.ppq, this._clock = new of({
            callback: this._processTick.bind(this),
            context: this.context,
            frequency: 0,
            units: "bpm"
        }), this._bindClockEvents(), this.bpm = this._clock.frequency, this._clock.frequency.multiplier = e.ppq, this.bpm.setValueAtTime(e.bpm, 0), ze(this, "bpm"), this._timeSignature = e.timeSignature, this._swingTicks = e.ppq / 2
    }
    static getDefaults() {
        return Object.assign(Lr.getDefaults(), {
            bpm: 120,
            loopEnd: "4m",
            loopStart: 0,
            ppq: 192,
            swing: 0,
            swingSubdivision: "8n",
            timeSignature: 4
        })
    }
    _processTick(e, n) {
        if (this._loop.get(e) && n >= this._loopEnd && (this.emit("loopEnd", e), this._clock.setTicksAtTime(this._loopStart, e), n = this._loopStart, this.emit("loopStart", e, this._clock.getSecondsAtTime(e)), this.emit("loop", e)), this._swingAmount > 0 && n % this._ppq !== 0 && n % (this._swingTicks * 2) !== 0) {
            const r = n % (this._swingTicks * 2) / (this._swingTicks * 2),
                s = Math.sin(r * Math.PI) * this._swingAmount;
            e += new so(this.context, this._swingTicks * 2 / 3).toSeconds() * s
        }
        this._timeline.forEachAtTime(n, r => r.invoke(e))
    }
    schedule(e, n) {
        const r = new pa(this, {
            callback: e,
            time: new Mh(this.context, n).toTicks()
        });
        return this._addEvent(r, this._timeline)
    }
    scheduleRepeat(e, n, r, s = 1 / 0) {
        const i = new vb(this, {
            callback: e,
            duration: new Ys(this.context, s).toTicks(),
            interval: new Ys(this.context, n).toTicks(),
            time: new Mh(this.context, r).toTicks()
        });
        return this._addEvent(i, this._repeatedEvents)
    }
    scheduleOnce(e, n) {
        const r = new pa(this, {
            callback: e,
            once: !0,
            time: new Mh(this.context, n).toTicks()
        });
        return this._addEvent(r, this._timeline)
    }
    clear(e) {
        if (this._scheduledEvents.hasOwnProperty(e)) {
            const n = this._scheduledEvents[e.toString()];
            n.timeline.remove(n.event), n.event.dispose(), delete this._scheduledEvents[e.toString()]
        }
        return this
    }
    _addEvent(e, n) {
        return this._scheduledEvents[e.id.toString()] = {
            event: e,
            timeline: n
        }, n.add(e), e.id
    }
    cancel(e = 0) {
        const n = this.toTicks(e);
        return this._timeline.forEachFrom(n, r => this.clear(r.id)), this._repeatedEvents.forEachFrom(n, r => this.clear(r.id)), this
    }
    _bindClockEvents() {
        this._clock.on("start", (e, n) => {
            n = new so(this.context, n).toSeconds(), this.emit("start", e, n)
        }), this._clock.on("stop", e => {
            this.emit("stop", e)
        }), this._clock.on("pause", e => {
            this.emit("pause", e)
        })
    }
    get state() {
        return this._clock.getStateAtTime(this.now())
    }
    start(e, n) {
        let r;
        return wt(n) && (r = this.toTicks(n)), this._clock.start(e, r), this
    }
    stop(e) {
        return this._clock.stop(e), this
    }
    pause(e) {
        return this._clock.pause(e), this
    }
    toggle(e) {
        return e = this.toSeconds(e), this._clock.getStateAtTime(e) !== "started" ? this.start(e) : this.stop(e), this
    }
    get timeSignature() {
        return this._timeSignature
    }
    set timeSignature(e) {
        is(e) && (e = e[0] / e[1] * 4), this._timeSignature = e
    }
    get loopStart() {
        return new Ys(this.context, this._loopStart, "i").toSeconds()
    }
    set loopStart(e) {
        this._loopStart = this.toTicks(e)
    }
    get loopEnd() {
        return new Ys(this.context, this._loopEnd, "i").toSeconds()
    }
    set loopEnd(e) {
        this._loopEnd = this.toTicks(e)
    }
    get loop() {
        return this._loop.get(this.now())
    }
    set loop(e) {
        this._loop.set(e, this.now())
    }
    setLoopPoints(e, n) {
        return this.loopStart = e, this.loopEnd = n, this
    }
    get swing() {
        return this._swingAmount
    }
    set swing(e) {
        this._swingAmount = e
    }
    get swingSubdivision() {
        return new so(this.context, this._swingTicks).toNotation()
    }
    set swingSubdivision(e) {
        this._swingTicks = this.toTicks(e)
    }
    get position() {
        const e = this.now(),
            n = this._clock.getTicksAtTime(e);
        return new so(this.context, n).toBarsBeatsSixteenths()
    }
    set position(e) {
        const n = this.toTicks(e);
        this.ticks = n
    }
    get seconds() {
        return this._clock.seconds
    }
    set seconds(e) {
        const n = this.now(),
            r = this._clock.frequency.timeToTicks(e, n);
        this.ticks = r
    }
    get progress() {
        if (this.loop) {
            const e = this.now();
            return (this._clock.getTicksAtTime(e) - this._loopStart) / (this._loopEnd - this._loopStart)
        } else return 0
    }
    get ticks() {
        return this._clock.ticks
    }
    set ticks(e) {
        if (this._clock.ticks !== e) {
            const n = this.now();
            if (this.state === "started") {
                const r = this._clock.getTicksAtTime(n),
                    s = this._clock.frequency.getDurationOfTicks(Math.ceil(r) - r, n),
                    i = n + s;
                this.emit("stop", i), this._clock.setTicksAtTime(e, i), this.emit("start", i, this._clock.getSecondsAtTime(i))
            } else this._clock.setTicksAtTime(e, n)
        }
    }
    getTicksAtTime(e) {
        return Math.round(this._clock.getTicksAtTime(e))
    }
    getSecondsAtTime(e) {
        return this._clock.getSecondsAtTime(e)
    }
    get PPQ() {
        return this._clock.frequency.multiplier
    }
    set PPQ(e) {
        this._clock.frequency.multiplier = e
    }
    nextSubdivision(e) {
        if (e = this.toTicks(e), this.state !== "started") return 0; {
            const n = this.now(),
                r = this.getTicksAtTime(n),
                s = e - r % e;
            return this._clock.nextTickTime(s, n)
        }
    }
    syncSignal(e, n) {
        if (!n) {
            const s = this.now();
            if (e.getValueAtTime(s) !== 0) {
                const o = 1 / (60 / this.bpm.getValueAtTime(s) / this.PPQ);
                n = e.getValueAtTime(s) / o
            } else n = 0
        }
        const r = new Ye(n);
        return this.bpm.connect(r), r.connect(e._param), this._syncedSignals.push({
            initial: e.value,
            ratio: r,
            signal: e
        }), e.value = 0, this
    }
    unsyncSignal(e) {
        for (let n = this._syncedSignals.length - 1; n >= 0; n--) {
            const r = this._syncedSignals[n];
            r.signal === e && (r.ratio.dispose(), r.signal.value = r.initial, this._syncedSignals.splice(n, 1))
        }
        return this
    }
    dispose() {
        return super.dispose(), this._clock.dispose(), id(this, "bpm"), this._timeline.dispose(), this._repeatedEvents.dispose(), this
    }
}
rd.mixin(af);
Ag(t => {
    t.transport = new af({
        context: t
    })
});
Og(t => {
    t.transport.dispose()
});
class Mn extends Ne {
    constructor(e) {
        super(e), this.input = void 0, this._state = new yb("stopped"), this._synced = !1, this._scheduled = [], this._syncedStart = yt, this._syncedStop = yt, this._state.memory = 100, this._state.increasing = !0, this._volume = this.output = new Ii({
            context: this.context,
            mute: e.mute,
            volume: e.volume
        }), this.volume = this._volume.volume, ze(this, "volume"), this.onstop = e.onstop
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            mute: !1,
            onstop: yt,
            volume: 0
        })
    }
    get state() {
        return this._synced ? this.context.transport.state === "started" ? this._state.getValueAtTime(this.context.transport.seconds) : "stopped" : this._state.getValueAtTime(this.now())
    }
    get mute() {
        return this._volume.mute
    }
    set mute(e) {
        this._volume.mute = e
    }
    _clampToCurrentTime(e) {
        return this._synced ? e : Math.max(e, this.context.currentTime)
    }
    start(e, n, r) {
        let s = ks(e) && this._synced ? this.context.transport.seconds : this.toSeconds(e);
        if (s = this._clampToCurrentTime(s), !this._synced && this._state.getValueAtTime(s) === "started") Qe(R1(s, this._state.get(s).time), "Start time must be strictly greater than previous start time"), this._state.cancel(s), this._state.setStateAtTime("started", s), this.log("restart", s), this.restart(s, n, r);
        else if (this.log("start", s), this._state.setStateAtTime("started", s), this._synced) {
            const i = this._state.get(s);
            i && (i.offset = this.toSeconds(Ll(n, 0)), i.duration = r ? this.toSeconds(r) : void 0);
            const o = this.context.transport.schedule(a => {
                this._start(a, n, r)
            }, s);
            this._scheduled.push(o), this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > s && this._syncedStart(this.now(), this.context.transport.seconds)
        } else Ek(this.context), this._start(s, n, r);
        return this
    }
    stop(e) {
        let n = ks(e) && this._synced ? this.context.transport.seconds : this.toSeconds(e);
        if (n = this._clampToCurrentTime(n), this._state.getValueAtTime(n) === "started" || wt(this._state.getNextState("started", n))) {
            if (this.log("stop", n), !this._synced) this._stop(n);
            else {
                const r = this.context.transport.schedule(this._stop.bind(this), n);
                this._scheduled.push(r)
            }
            this._state.cancel(n), this._state.setStateAtTime("stopped", n)
        }
        return this
    }
    restart(e, n, r) {
        return e = this.toSeconds(e), this._state.getValueAtTime(e) === "started" && (this._state.cancel(e), this._restart(e, n, r)), this
    }
    sync() {
        return this._synced || (this._synced = !0, this._syncedStart = (e, n) => {
            if (n > 0) {
                const r = this._state.get(n);
                if (r && r.state === "started" && r.time !== n) {
                    const s = n - this.toSeconds(r.time);
                    let i;
                    r.duration && (i = this.toSeconds(r.duration) - s), this._start(e, this.toSeconds(r.offset) + s, i)
                }
            }
        }, this._syncedStop = e => {
            const n = this.context.transport.getSecondsAtTime(Math.max(e - this.sampleTime, 0));
            this._state.getValueAtTime(n) === "started" && this._stop(e)
        }, this.context.transport.on("start", this._syncedStart), this.context.transport.on("loopStart", this._syncedStart), this.context.transport.on("stop", this._syncedStop), this.context.transport.on("pause", this._syncedStop), this.context.transport.on("loopEnd", this._syncedStop)), this
    }
    unsync() {
        return this._synced && (this.context.transport.off("stop", this._syncedStop), this.context.transport.off("pause", this._syncedStop), this.context.transport.off("loopEnd", this._syncedStop), this.context.transport.off("start", this._syncedStart), this.context.transport.off("loopStart", this._syncedStart)), this._synced = !1, this._scheduled.forEach(e => this.context.transport.clear(e)), this._scheduled = [], this._state.cancel(0), this._stop(0), this
    }
    dispose() {
        return super.dispose(), this.onstop = yt, this.unsync(), this._volume.dispose(), this._state.dispose(), this
    }
}
class Ni extends nu {
    constructor() {
        super(re(Ni.getDefaults(), arguments, ["url", "onload"])), this.name = "ToneBufferSource", this._source = this.context.createBufferSource(), this._internalChannels = [this._source], this._sourceStarted = !1, this._sourceStopped = !1;
        const e = re(Ni.getDefaults(), arguments, ["url", "onload"]);
        xs(this._source, this._gainNode), this._source.onended = () => this._stopSource(), this.playbackRate = new pt({
            context: this.context,
            param: this._source.playbackRate,
            units: "positive",
            value: e.playbackRate
        }), this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this._buffer = new Pt(e.url, e.onload, e.onerror), this._internalChannels.push(this._source)
    }
    static getDefaults() {
        return Object.assign(nu.getDefaults(), {
            url: new Pt,
            loop: !1,
            loopEnd: 0,
            loopStart: 0,
            onload: yt,
            onerror: yt,
            playbackRate: 1
        })
    }
    get fadeIn() {
        return this._fadeIn
    }
    set fadeIn(e) {
        this._fadeIn = e
    }
    get fadeOut() {
        return this._fadeOut
    }
    set fadeOut(e) {
        this._fadeOut = e
    }
    get curve() {
        return this._curve
    }
    set curve(e) {
        this._curve = e
    }
    start(e, n, r, s = 1) {
        Qe(this.buffer.loaded, "buffer is either not set or not loaded");
        const i = this.toSeconds(e);
        this._startGain(i, s), this.loop ? n = Ll(n, this.loopStart) : n = Ll(n, 0);
        let o = Math.max(this.toSeconds(n), 0);
        if (this.loop) {
            const a = this.toSeconds(this.loopEnd) || this.buffer.duration,
                l = this.toSeconds(this.loopStart),
                u = a - l;
            Cv(o, a) && (o = (o - l) % u + l), Gs(o, this.buffer.duration) && (o = 0)
        }
        if (this._source.buffer = this.buffer.get(), this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration, wk(o, this.buffer.duration) && (this._sourceStarted = !0, this._source.start(i, o)), wt(r)) {
            let a = this.toSeconds(r);
            a = Math.max(a, 0), this.stop(i + a)
        }
        return this
    }
    _stopSource(e) {
        !this._sourceStopped && this._sourceStarted && (this._sourceStopped = !0, this._source.stop(this.toSeconds(e)), this._onended())
    }
    get loopStart() {
        return this._source.loopStart
    }
    set loopStart(e) {
        this._source.loopStart = this.toSeconds(e)
    }
    get loopEnd() {
        return this._source.loopEnd
    }
    set loopEnd(e) {
        this._source.loopEnd = this.toSeconds(e)
    }
    get buffer() {
        return this._buffer
    }
    set buffer(e) {
        this._buffer.set(e)
    }
    get loop() {
        return this._source.loop
    }
    set loop(e) {
        this._source.loop = e, this._sourceStarted && this.cancelStop()
    }
    dispose() {
        return super.dispose(), this._source.onended = null, this._source.disconnect(), this._buffer.dispose(), this.playbackRate.dispose(), this
    }
}
class ma extends Mn {
    constructor() {
        super(re(ma.getDefaults(), arguments, ["type"])), this.name = "Noise", this._source = null;
        const e = re(ma.getDefaults(), arguments, ["type"]);
        this._playbackRate = e.playbackRate, this.type = e.type, this._fadeIn = e.fadeIn, this._fadeOut = e.fadeOut
    }
    static getDefaults() {
        return Object.assign(Mn.getDefaults(), {
            fadeIn: 0,
            fadeOut: 0,
            playbackRate: 1,
            type: "white"
        })
    }
    get type() {
        return this._type
    }
    set type(e) {
        if (Qe(e in Gw, "Noise: invalid type: " + e), this._type !== e && (this._type = e, this.state === "started")) {
            const n = this.now();
            this._stop(n), this._start(n)
        }
    }
    get playbackRate() {
        return this._playbackRate
    }
    set playbackRate(e) {
        this._playbackRate = e, this._source && (this._source.playbackRate.value = e)
    }
    _start(e) {
        const n = Gw[this._type];
        this._source = new Ni({
            url: n,
            context: this.context,
            fadeIn: this._fadeIn,
            fadeOut: this._fadeOut,
            loop: !0,
            onended: () => this.onstop(this),
            playbackRate: this._playbackRate
        }).connect(this.output), this._source.start(this.toSeconds(e), Math.random() * (n.duration - .001))
    }
    _stop(e) {
        this._source && (this._source.stop(this.toSeconds(e)), this._source = null)
    }
    get fadeIn() {
        return this._fadeIn
    }
    set fadeIn(e) {
        this._fadeIn = e, this._source && (this._source.fadeIn = this._fadeIn)
    }
    get fadeOut() {
        return this._fadeOut
    }
    set fadeOut(e) {
        this._fadeOut = e, this._source && (this._source.fadeOut = this._fadeOut)
    }
    _restart(e) {
        this._stop(e), this._start(e)
    }
    dispose() {
        return super.dispose(), this._source && this._source.disconnect(), this
    }
}
const al = 44100 * 5,
    Zy = 2,
    Xi = {
        brown: null,
        pink: null,
        white: null
    },
    Gw = {
        get brown() {
            if (!Xi.brown) {
                const t = [];
                for (let e = 0; e < Zy; e++) {
                    const n = new Float32Array(al);
                    t[e] = n;
                    let r = 0;
                    for (let s = 0; s < al; s++) {
                        const i = Math.random() * 2 - 1;
                        n[s] = (r + .02 * i) / 1.02, r = n[s], n[s] *= 3.5
                    }
                }
                Xi.brown = new Pt().fromArray(t)
            }
            return Xi.brown
        },
        get pink() {
            if (!Xi.pink) {
                const t = [];
                for (let e = 0; e < Zy; e++) {
                    const n = new Float32Array(al);
                    t[e] = n;
                    let r, s, i, o, a, l, u;
                    r = s = i = o = a = l = u = 0;
                    for (let f = 0; f < al; f++) {
                        const d = Math.random() * 2 - 1;
                        r = .99886 * r + d * .0555179, s = .99332 * s + d * .0750759, i = .969 * i + d * .153852, o = .8665 * o + d * .3104856, a = .55 * a + d * .5329522, l = -.7616 * l - d * .016898, n[f] = r + s + i + o + a + l + u + d * .5362, n[f] *= .11, u = d * .115926
                    }
                }
                Xi.pink = new Pt().fromArray(t)
            }
            return Xi.pink
        },
        get white() {
            if (!Xi.white) {
                const t = [];
                for (let e = 0; e < Zy; e++) {
                    const n = new Float32Array(al);
                    t[e] = n;
                    for (let r = 0; r < al; r++) n[r] = Math.random() * 2 - 1
                }
                Xi.white = new Pt().fromArray(t)
            }
            return Xi.white
        }
    };

function Uc(t, e) {
    return kn(this, void 0, void 0, function*() {
        const n = e / t.context.sampleRate,
            r = new Cg(1, n, t.context.sampleRate);
        return new t.constructor(Object.assign(t.get(), {
            frequency: 2 / n,
            detune: 0,
            context: r
        })).toDestination().start(0), (yield r.render()).getChannelData(0)
    })
}
class cf extends nu {
    constructor() {
        super(re(cf.getDefaults(), arguments, ["frequency", "type"])), this.name = "ToneOscillatorNode", this._oscillator = this.context.createOscillator(), this._internalChannels = [this._oscillator];
        const e = re(cf.getDefaults(), arguments, ["frequency", "type"]);
        xs(this._oscillator, this._gainNode), this.type = e.type, this.frequency = new pt({
            context: this.context,
            param: this._oscillator.frequency,
            units: "frequency",
            value: e.frequency
        }), this.detune = new pt({
            context: this.context,
            param: this._oscillator.detune,
            units: "cents",
            value: e.detune
        }), ze(this, ["frequency", "detune"])
    }
    static getDefaults() {
        return Object.assign(nu.getDefaults(), {
            detune: 0,
            frequency: 440,
            type: "sine"
        })
    }
    start(e) {
        const n = this.toSeconds(e);
        return this.log("start", n), this._startGain(n), this._oscillator.start(n), this
    }
    _stopSource(e) {
        this._oscillator.stop(e)
    }
    setPeriodicWave(e) {
        return this._oscillator.setPeriodicWave(e), this
    }
    get type() {
        return this._oscillator.type
    }
    set type(e) {
        this._oscillator.type = e
    }
    dispose() {
        return super.dispose(), this.state === "started" && this.stop(), this._oscillator.disconnect(), this.frequency.dispose(), this.detune.dispose(), this
    }
}
class un extends Mn {
    constructor() {
        super(re(un.getDefaults(), arguments, ["frequency", "type"])), this.name = "Oscillator", this._oscillator = null;
        const e = re(un.getDefaults(), arguments, ["frequency", "type"]);
        this.frequency = new Je({
            context: this.context,
            units: "frequency",
            value: e.frequency
        }), ze(this, "frequency"), this.detune = new Je({
            context: this.context,
            units: "cents",
            value: e.detune
        }), ze(this, "detune"), this._partials = e.partials, this._partialCount = e.partialCount, this._type = e.type, e.partialCount && e.type !== "custom" && (this._type = this.baseType + e.partialCount.toString()), this.phase = e.phase
    }
    static getDefaults() {
        return Object.assign(Mn.getDefaults(), {
            detune: 0,
            frequency: 440,
            partialCount: 0,
            partials: [],
            phase: 0,
            type: "sine"
        })
    }
    _start(e) {
        const n = this.toSeconds(e),
            r = new cf({
                context: this.context,
                onended: () => this.onstop(this)
            });
        this._oscillator = r, this._wave ? this._oscillator.setPeriodicWave(this._wave) : this._oscillator.type = this._type, this._oscillator.connect(this.output), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.start(n)
    }
    _stop(e) {
        const n = this.toSeconds(e);
        this._oscillator && this._oscillator.stop(n)
    }
    _restart(e) {
        const n = this.toSeconds(e);
        return this.log("restart", n), this._oscillator && this._oscillator.cancelStop(), this._state.cancel(n), this
    }
    syncFrequency() {
        return this.context.transport.syncSignal(this.frequency), this
    }
    unsyncFrequency() {
        return this.context.transport.unsyncSignal(this.frequency), this
    }
    _getCachedPeriodicWave() {
        if (this._type === "custom") return un._periodicWaveCache.find(n => n.phase === this._phase && OTe(n.partials, this._partials)); {
            const e = un._periodicWaveCache.find(n => n.type === this._type && n.phase === this._phase);
            return this._partialCount = e ? e.partialCount : this._partialCount, e
        }
    }
    get type() {
        return this._type
    }
    set type(e) {
        this._type = e;
        const n = ["sine", "square", "sawtooth", "triangle"].indexOf(e) !== -1;
        if (this._phase === 0 && n) this._wave = void 0, this._partialCount = 0, this._oscillator !== null && (this._oscillator.type = e);
        else {
            const r = this._getCachedPeriodicWave();
            if (wt(r)) {
                const {
                    partials: s,
                    wave: i
                } = r;
                this._wave = i, this._partials = s, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave)
            } else {
                const [s, i] = this._getRealImaginary(e, this._phase), o = this.context.createPeriodicWave(s, i);
                this._wave = o, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave), un._periodicWaveCache.push({
                    imag: i,
                    partialCount: this._partialCount,
                    partials: this._partials,
                    phase: this._phase,
                    real: s,
                    type: this._type,
                    wave: this._wave
                }), un._periodicWaveCache.length > 100 && un._periodicWaveCache.shift()
            }
        }
    }
    get baseType() {
        return this._type.replace(this.partialCount.toString(), "")
    }
    set baseType(e) {
        this.partialCount && this._type !== "custom" && e !== "custom" ? this.type = e + this.partialCount : this.type = e
    }
    get partialCount() {
        return this._partialCount
    }
    set partialCount(e) {
        Qs(e, 0);
        let n = this._type;
        const r = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
        if (r && (n = r[1]), this._type !== "custom") e === 0 ? this.type = n : this.type = n + e.toString();
        else {
            const s = new Float32Array(e);
            this._partials.forEach((i, o) => s[o] = i), this._partials = Array.from(s), this.type = this._type
        }
    }
    _getRealImaginary(e, n) {
        let s = 2048;
        const i = new Float32Array(s),
            o = new Float32Array(s);
        let a = 1;
        if (e === "custom") {
            if (a = this._partials.length + 1, this._partialCount = this._partials.length, s = a, this._partials.length === 0) return [i, o]
        } else {
            const l = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(e);
            l ? (a = parseInt(l[2], 10) + 1, this._partialCount = parseInt(l[2], 10), e = l[1], a = Math.max(a, 2), s = a) : this._partialCount = 0, this._partials = []
        }
        for (let l = 1; l < s; ++l) {
            const u = 2 / (l * Math.PI);
            let f;
            switch (e) {
                case "sine":
                    f = l <= a ? 1 : 0, this._partials[l - 1] = f;
                    break;
                case "square":
                    f = l & 1 ? 2 * u : 0, this._partials[l - 1] = f;
                    break;
                case "sawtooth":
                    f = u * (l & 1 ? 1 : -1), this._partials[l - 1] = f;
                    break;
                case "triangle":
                    l & 1 ? f = 2 * (u * u) * (l - 1 >> 1 & 1 ? -1 : 1) : f = 0, this._partials[l - 1] = f;
                    break;
                case "custom":
                    f = this._partials[l - 1];
                    break;
                default:
                    throw new TypeError("Oscillator: invalid type: " + e)
            }
            f !== 0 ? (i[l] = -f * Math.sin(n * l), o[l] = f * Math.cos(n * l)) : (i[l] = 0, o[l] = 0)
        }
        return [i, o]
    }
    _inverseFFT(e, n, r) {
        let s = 0;
        const i = e.length;
        for (let o = 0; o < i; o++) s += e[o] * Math.cos(o * r) + n[o] * Math.sin(o * r);
        return s
    }
    getInitialValue() {
        const [e, n] = this._getRealImaginary(this._type, 0);
        let r = 0;
        const s = Math.PI * 2,
            i = 32;
        for (let o = 0; o < i; o++) r = Math.max(this._inverseFFT(e, n, o / i * s), r);
        return kTe(-this._inverseFFT(e, n, this._phase) / r, -1, 1)
    }
    get partials() {
        return this._partials.slice(0, this.partialCount)
    }
    set partials(e) {
        this._partials = e, this._partialCount = this._partials.length, e.length && (this.type = "custom")
    }
    get phase() {
        return this._phase * (180 / Math.PI)
    }
    set phase(e) {
        this._phase = e * Math.PI / 180, this.type = this._type
    }
    asArray(e = 1024) {
        return kn(this, void 0, void 0, function*() {
            return Uc(this, e)
        })
    }
    dispose() {
        return super.dispose(), this._oscillator !== null && this._oscillator.dispose(), this._wave = void 0, this.frequency.dispose(), this.detune.dispose(), this
    }
}
un._periodicWaveCache = [];
class ls extends Ne {
    constructor() {
        super(Object.assign(re(ls.getDefaults(), arguments, ["context"])))
    }
    connect(e, n = 0, r = 0) {
        return Ng(this, e, n, r), this
    }
}
class Js extends ls {
    constructor() {
        super(Object.assign(re(Js.getDefaults(), arguments, ["mapping", "length"]))), this.name = "WaveShaper", this._shaper = this.context.createWaveShaper(), this.input = this._shaper, this.output = this._shaper;
        const e = re(Js.getDefaults(), arguments, ["mapping", "length"]);
        is(e.mapping) || e.mapping instanceof Float32Array ? this.curve = Float32Array.from(e.mapping) : yTe(e.mapping) && this.setMap(e.mapping, e.length)
    }
    static getDefaults() {
        return Object.assign(Je.getDefaults(), {
            length: 1024
        })
    }
    setMap(e, n = 1024) {
        const r = new Float32Array(n);
        for (let s = 0, i = n; s < i; s++) {
            const o = s / (i - 1) * 2 - 1;
            r[s] = e(o, s)
        }
        return this.curve = r, this
    }
    get curve() {
        return this._shaper.curve
    }
    set curve(e) {
        this._shaper.curve = e
    }
    get oversample() {
        return this._shaper.oversample
    }
    set oversample(e) {
        const n = ["none", "2x", "4x"].some(r => r.includes(e));
        Qe(n, "oversampling must be either 'none', '2x', or '4x'"), this._shaper.oversample = e
    }
    dispose() {
        return super.dispose(), this._shaper.disconnect(), this
    }
}
class bb extends ls {
    constructor() {
        super(...arguments), this.name = "AudioToGain", this._norm = new Js({
            context: this.context,
            mapping: e => (e + 1) / 2
        }), this.input = this._norm, this.output = this._norm
    }
    dispose() {
        return super.dispose(), this._norm.dispose(), this
    }
}
class fn extends Je {
    constructor() {
        super(Object.assign(re(fn.getDefaults(), arguments, ["value"]))), this.name = "Multiply", this.override = !1;
        const e = re(fn.getDefaults(), arguments, ["value"]);
        this._mult = this.input = this.output = new Ye({
            context: this.context,
            minValue: e.minValue,
            maxValue: e.maxValue
        }), this.factor = this._param = this._mult.gain, this.factor.setValueAtTime(e.value, 0)
    }
    static getDefaults() {
        return Object.assign(Je.getDefaults(), {
            value: 0
        })
    }
    dispose() {
        return super.dispose(), this._mult.dispose(), this
    }
}
class lf extends Mn {
    constructor() {
        super(re(lf.getDefaults(), arguments, ["frequency", "type", "modulationType"])), this.name = "AMOscillator", this._modulationScale = new bb({
            context: this.context
        }), this._modulationNode = new Ye({
            context: this.context
        });
        const e = re(lf.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
        this._carrier = new un({
            context: this.context,
            detune: e.detune,
            frequency: e.frequency,
            onstop: () => this.onstop(this),
            phase: e.phase,
            type: e.type
        }), this.frequency = this._carrier.frequency, this.detune = this._carrier.detune, this._modulator = new un({
            context: this.context,
            phase: e.phase,
            type: e.modulationType
        }), this.harmonicity = new fn({
            context: this.context,
            units: "positive",
            value: e.harmonicity
        }), this.frequency.chain(this.harmonicity, this._modulator.frequency), this._modulator.chain(this._modulationScale, this._modulationNode.gain), this._carrier.chain(this._modulationNode, this.output), ze(this, ["frequency", "detune", "harmonicity"])
    }
    static getDefaults() {
        return Object.assign(un.getDefaults(), {
            harmonicity: 1,
            modulationType: "square"
        })
    }
    _start(e) {
        this._modulator.start(e), this._carrier.start(e)
    }
    _stop(e) {
        this._modulator.stop(e), this._carrier.stop(e)
    }
    _restart(e) {
        this._modulator.restart(e), this._carrier.restart(e)
    }
    get type() {
        return this._carrier.type
    }
    set type(e) {
        this._carrier.type = e
    }
    get baseType() {
        return this._carrier.baseType
    }
    set baseType(e) {
        this._carrier.baseType = e
    }
    get partialCount() {
        return this._carrier.partialCount
    }
    set partialCount(e) {
        this._carrier.partialCount = e
    }
    get modulationType() {
        return this._modulator.type
    }
    set modulationType(e) {
        this._modulator.type = e
    }
    get phase() {
        return this._carrier.phase
    }
    set phase(e) {
        this._carrier.phase = e, this._modulator.phase = e
    }
    get partials() {
        return this._carrier.partials
    }
    set partials(e) {
        this._carrier.partials = e
    }
    asArray(e = 1024) {
        return kn(this, void 0, void 0, function*() {
            return Uc(this, e)
        })
    }
    dispose() {
        return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this._modulationScale.dispose(), this
    }
}
class ru extends Mn {
    constructor() {
        super(re(ru.getDefaults(), arguments, ["frequency", "type", "modulationType"])), this.name = "FMOscillator", this._modulationNode = new Ye({
            context: this.context,
            gain: 0
        });
        const e = re(ru.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
        this._carrier = new un({
            context: this.context,
            detune: e.detune,
            frequency: 0,
            onstop: () => this.onstop(this),
            phase: e.phase,
            type: e.type
        }), this.detune = this._carrier.detune, this.frequency = new Je({
            context: this.context,
            units: "frequency",
            value: e.frequency
        }), this._modulator = new un({
            context: this.context,
            phase: e.phase,
            type: e.modulationType
        }), this.harmonicity = new fn({
            context: this.context,
            units: "positive",
            value: e.harmonicity
        }), this.modulationIndex = new fn({
            context: this.context,
            units: "positive",
            value: e.modulationIndex
        }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.frequency.chain(this.modulationIndex, this._modulationNode), this._modulator.connect(this._modulationNode.gain), this._modulationNode.connect(this._carrier.frequency), this._carrier.connect(this.output), this.detune.connect(this._modulator.detune), ze(this, ["modulationIndex", "frequency", "detune", "harmonicity"])
    }
    static getDefaults() {
        return Object.assign(un.getDefaults(), {
            harmonicity: 1,
            modulationIndex: 2,
            modulationType: "square"
        })
    }
    _start(e) {
        this._modulator.start(e), this._carrier.start(e)
    }
    _stop(e) {
        this._modulator.stop(e), this._carrier.stop(e)
    }
    _restart(e) {
        return this._modulator.restart(e), this._carrier.restart(e), this
    }
    get type() {
        return this._carrier.type
    }
    set type(e) {
        this._carrier.type = e
    }
    get baseType() {
        return this._carrier.baseType
    }
    set baseType(e) {
        this._carrier.baseType = e
    }
    get partialCount() {
        return this._carrier.partialCount
    }
    set partialCount(e) {
        this._carrier.partialCount = e
    }
    get modulationType() {
        return this._modulator.type
    }
    set modulationType(e) {
        this._modulator.type = e
    }
    get phase() {
        return this._carrier.phase
    }
    set phase(e) {
        this._carrier.phase = e, this._modulator.phase = e
    }
    get partials() {
        return this._carrier.partials
    }
    set partials(e) {
        this._carrier.partials = e
    }
    asArray(e = 1024) {
        return kn(this, void 0, void 0, function*() {
            return Uc(this, e)
        })
    }
    dispose() {
        return super.dispose(), this.frequency.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this.modulationIndex.dispose(), this
    }
}
class su extends Mn {
    constructor() {
        super(re(su.getDefaults(), arguments, ["frequency", "width"])), this.name = "PulseOscillator", this._widthGate = new Ye({
            context: this.context,
            gain: 0
        }), this._thresh = new Js({
            context: this.context,
            mapping: n => n <= 0 ? -1 : 1
        });
        const e = re(su.getDefaults(), arguments, ["frequency", "width"]);
        this.width = new Je({
            context: this.context,
            units: "audioRange",
            value: e.width
        }), this._triangle = new un({
            context: this.context,
            detune: e.detune,
            frequency: e.frequency,
            onstop: () => this.onstop(this),
            phase: e.phase,
            type: "triangle"
        }), this.frequency = this._triangle.frequency, this.detune = this._triangle.detune, this._triangle.chain(this._thresh, this.output), this.width.chain(this._widthGate, this._thresh), ze(this, ["width", "frequency", "detune"])
    }
    static getDefaults() {
        return Object.assign(Mn.getDefaults(), {
            detune: 0,
            frequency: 440,
            phase: 0,
            type: "pulse",
            width: .2
        })
    }
    _start(e) {
        e = this.toSeconds(e), this._triangle.start(e), this._widthGate.gain.setValueAtTime(1, e)
    }
    _stop(e) {
        e = this.toSeconds(e), this._triangle.stop(e), this._widthGate.gain.cancelScheduledValues(e), this._widthGate.gain.setValueAtTime(0, e)
    }
    _restart(e) {
        this._triangle.restart(e), this._widthGate.gain.cancelScheduledValues(e), this._widthGate.gain.setValueAtTime(1, e)
    }
    get phase() {
        return this._triangle.phase
    }
    set phase(e) {
        this._triangle.phase = e
    }
    get type() {
        return "pulse"
    }
    get baseType() {
        return "pulse"
    }
    get partials() {
        return []
    }
    get partialCount() {
        return 0
    }
    set carrierType(e) {
        this._triangle.type = e
    }
    asArray(e = 1024) {
        return kn(this, void 0, void 0, function*() {
            return Uc(this, e)
        })
    }
    dispose() {
        return super.dispose(), this._triangle.dispose(), this.width.dispose(), this._widthGate.dispose(), this._thresh.dispose(), this
    }
}
class uf extends Mn {
    constructor() {
        super(re(uf.getDefaults(), arguments, ["frequency", "type", "spread"])), this.name = "FatOscillator", this._oscillators = [];
        const e = re(uf.getDefaults(), arguments, ["frequency", "type", "spread"]);
        this.frequency = new Je({
            context: this.context,
            units: "frequency",
            value: e.frequency
        }), this.detune = new Je({
            context: this.context,
            units: "cents",
            value: e.detune
        }), this._spread = e.spread, this._type = e.type, this._phase = e.phase, this._partials = e.partials, this._partialCount = e.partialCount, this.count = e.count, ze(this, ["frequency", "detune"])
    }
    static getDefaults() {
        return Object.assign(un.getDefaults(), {
            count: 3,
            spread: 20,
            type: "sawtooth"
        })
    }
    _start(e) {
        e = this.toSeconds(e), this._forEach(n => n.start(e))
    }
    _stop(e) {
        e = this.toSeconds(e), this._forEach(n => n.stop(e))
    }
    _restart(e) {
        this._forEach(n => n.restart(e))
    }
    _forEach(e) {
        for (let n = 0; n < this._oscillators.length; n++) e(this._oscillators[n], n)
    }
    get type() {
        return this._type
    }
    set type(e) {
        this._type = e, this._forEach(n => n.type = e)
    }
    get spread() {
        return this._spread
    }
    set spread(e) {
        if (this._spread = e, this._oscillators.length > 1) {
            const n = -e / 2,
                r = e / (this._oscillators.length - 1);
            this._forEach((s, i) => s.detune.value = n + r * i)
        }
    }
    get count() {
        return this._oscillators.length
    }
    set count(e) {
        if (Qs(e, 1), this._oscillators.length !== e) {
            this._forEach(n => n.dispose()), this._oscillators = [];
            for (let n = 0; n < e; n++) {
                const r = new un({
                    context: this.context,
                    volume: -6 - e * 1.1,
                    type: this._type,
                    phase: this._phase + n / e * 360,
                    partialCount: this._partialCount,
                    onstop: n === 0 ? () => this.onstop(this) : yt
                });
                this.type === "custom" && (r.partials = this._partials), this.frequency.connect(r.frequency), this.detune.connect(r.detune), r.detune.overridden = !1, r.connect(this.output), this._oscillators[n] = r
            }
            this.spread = this._spread, this.state === "started" && this._forEach(n => n.start())
        }
    }
    get phase() {
        return this._phase
    }
    set phase(e) {
        this._phase = e, this._forEach((n, r) => n.phase = this._phase + r / this.count * 360)
    }
    get baseType() {
        return this._oscillators[0].baseType
    }
    set baseType(e) {
        this._forEach(n => n.baseType = e), this._type = this._oscillators[0].type
    }
    get partials() {
        return this._oscillators[0].partials
    }
    set partials(e) {
        this._partials = e, this._partialCount = this._partials.length, e.length && (this._type = "custom", this._forEach(n => n.partials = e))
    }
    get partialCount() {
        return this._oscillators[0].partialCount
    }
    set partialCount(e) {
        this._partialCount = e, this._forEach(n => n.partialCount = e), this._type = this._oscillators[0].type
    }
    asArray(e = 1024) {
        return kn(this, void 0, void 0, function*() {
            return Uc(this, e)
        })
    }
    dispose() {
        return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this._forEach(e => e.dispose()), this
    }
}
class hf extends Mn {
    constructor() {
        super(re(hf.getDefaults(), arguments, ["frequency", "modulationFrequency"])), this.name = "PWMOscillator", this.sourceType = "pwm", this._scale = new fn({
            context: this.context,
            value: 2
        });
        const e = re(hf.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
        this._pulse = new su({
            context: this.context,
            frequency: e.modulationFrequency
        }), this._pulse.carrierType = "sine", this.modulationFrequency = this._pulse.frequency, this._modulator = new un({
            context: this.context,
            detune: e.detune,
            frequency: e.frequency,
            onstop: () => this.onstop(this),
            phase: e.phase
        }), this.frequency = this._modulator.frequency, this.detune = this._modulator.detune, this._modulator.chain(this._scale, this._pulse.width), this._pulse.connect(this.output), ze(this, ["modulationFrequency", "frequency", "detune"])
    }
    static getDefaults() {
        return Object.assign(Mn.getDefaults(), {
            detune: 0,
            frequency: 440,
            modulationFrequency: .4,
            phase: 0,
            type: "pwm"
        })
    }
    _start(e) {
        e = this.toSeconds(e), this._modulator.start(e), this._pulse.start(e)
    }
    _stop(e) {
        e = this.toSeconds(e), this._modulator.stop(e), this._pulse.stop(e)
    }
    _restart(e) {
        this._modulator.restart(e), this._pulse.restart(e)
    }
    get type() {
        return "pwm"
    }
    get baseType() {
        return "pwm"
    }
    get partials() {
        return []
    }
    get partialCount() {
        return 0
    }
    get phase() {
        return this._modulator.phase
    }
    set phase(e) {
        this._modulator.phase = e
    }
    asArray(e = 1024) {
        return kn(this, void 0, void 0, function*() {
            return Uc(this, e)
        })
    }
    dispose() {
        return super.dispose(), this._pulse.dispose(), this._scale.dispose(), this._modulator.dispose(), this
    }
}
const Vw = {
    am: lf,
    fat: uf,
    fm: ru,
    oscillator: un,
    pulse: su,
    pwm: hf
};
class Ps extends Mn {
    constructor() {
        super(re(Ps.getDefaults(), arguments, ["frequency", "type"])), this.name = "OmniOscillator";
        const e = re(Ps.getDefaults(), arguments, ["frequency", "type"]);
        this.frequency = new Je({
            context: this.context,
            units: "frequency",
            value: e.frequency
        }), this.detune = new Je({
            context: this.context,
            units: "cents",
            value: e.detune
        }), ze(this, ["frequency", "detune"]), this.set(e)
    }
    static getDefaults() {
        return Object.assign(un.getDefaults(), ru.getDefaults(), lf.getDefaults(), uf.getDefaults(), su.getDefaults(), hf.getDefaults())
    }
    _start(e) {
        this._oscillator.start(e)
    }
    _stop(e) {
        this._oscillator.stop(e)
    }
    _restart(e) {
        return this._oscillator.restart(e), this
    }
    get type() {
        let e = "";
        return ["am", "fm", "fat"].some(n => this._sourceType === n) && (e = this._sourceType), e + this._oscillator.type
    }
    set type(e) {
        e.substr(0, 2) === "fm" ? (this._createNewOscillator("fm"), this._oscillator = this._oscillator, this._oscillator.type = e.substr(2)) : e.substr(0, 2) === "am" ? (this._createNewOscillator("am"), this._oscillator = this._oscillator, this._oscillator.type = e.substr(2)) : e.substr(0, 3) === "fat" ? (this._createNewOscillator("fat"), this._oscillator = this._oscillator, this._oscillator.type = e.substr(3)) : e === "pwm" ? (this._createNewOscillator("pwm"), this._oscillator = this._oscillator) : e === "pulse" ? this._createNewOscillator("pulse") : (this._createNewOscillator("oscillator"), this._oscillator = this._oscillator, this._oscillator.type = e)
    }
    get partials() {
        return this._oscillator.partials
    }
    set partials(e) {
        !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partials = e)
    }
    get partialCount() {
        return this._oscillator.partialCount
    }
    set partialCount(e) {
        !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partialCount = e)
    }
    set(e) {
        return Reflect.has(e, "type") && e.type && (this.type = e.type), super.set(e), this
    }
    _createNewOscillator(e) {
        if (e !== this._sourceType) {
            this._sourceType = e;
            const n = Vw[e],
                r = this.now();
            if (this._oscillator) {
                const s = this._oscillator;
                s.stop(r), this.context.setTimeout(() => s.dispose(), this.blockTime)
            }
            this._oscillator = new n({
                context: this.context
            }), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.connect(this.output), this._oscillator.onstop = () => this.onstop(this), this.state === "started" && this._oscillator.start(r)
        }
    }
    get phase() {
        return this._oscillator.phase
    }
    set phase(e) {
        this._oscillator.phase = e
    }
    get sourceType() {
        return this._sourceType
    }
    set sourceType(e) {
        let n = "sine";
        this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse" && (n = this._oscillator.type), e === "fm" ? this.type = "fm" + n : e === "am" ? this.type = "am" + n : e === "fat" ? this.type = "fat" + n : e === "oscillator" ? this.type = n : e === "pulse" ? this.type = "pulse" : e === "pwm" && (this.type = "pwm")
    }
    _getOscType(e, n) {
        return e instanceof Vw[n]
    }
    get baseType() {
        return this._oscillator.baseType
    }
    set baseType(e) {
        !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && e !== "pulse" && e !== "pwm" && (this._oscillator.baseType = e)
    }
    get width() {
        if (this._getOscType(this._oscillator, "pulse")) return this._oscillator.width
    }
    get count() {
        if (this._getOscType(this._oscillator, "fat")) return this._oscillator.count
    }
    set count(e) {
        this._getOscType(this._oscillator, "fat") && po(e) && (this._oscillator.count = e)
    }
    get spread() {
        if (this._getOscType(this._oscillator, "fat")) return this._oscillator.spread
    }
    set spread(e) {
        this._getOscType(this._oscillator, "fat") && po(e) && (this._oscillator.spread = e)
    }
    get modulationType() {
        if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) return this._oscillator.modulationType
    }
    set modulationType(e) {
        (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && ki(e) && (this._oscillator.modulationType = e)
    }
    get modulationIndex() {
        if (this._getOscType(this._oscillator, "fm")) return this._oscillator.modulationIndex
    }
    get harmonicity() {
        if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) return this._oscillator.harmonicity
    }
    get modulationFrequency() {
        if (this._getOscType(this._oscillator, "pwm")) return this._oscillator.modulationFrequency
    }
    asArray(e = 1024) {
        return kn(this, void 0, void 0, function*() {
            return Uc(this, e)
        })
    }
    dispose() {
        return super.dispose(), this.detune.dispose(), this.frequency.dispose(), this._oscillator.dispose(), this
    }
}
class Uu extends Je {
    constructor() {
        super(Object.assign(re(Uu.getDefaults(), arguments, ["value"]))), this.override = !1, this.name = "Add", this._sum = new Ye({
            context: this.context
        }), this.input = this._sum, this.output = this._sum, this.addend = this._param, Ns(this._constantSource, this._sum)
    }
    static getDefaults() {
        return Object.assign(Je.getDefaults(), {
            value: 0
        })
    }
    dispose() {
        return super.dispose(), this._sum.dispose(), this
    }
}
class mo extends ls {
    constructor() {
        super(Object.assign(re(mo.getDefaults(), arguments, ["min", "max"]))), this.name = "Scale";
        const e = re(mo.getDefaults(), arguments, ["min", "max"]);
        this._mult = this.input = new fn({
            context: this.context,
            value: e.max - e.min
        }), this._add = this.output = new Uu({
            context: this.context,
            value: e.min
        }), this._min = e.min, this._max = e.max, this.input.connect(this.output)
    }
    static getDefaults() {
        return Object.assign(ls.getDefaults(), {
            max: 1,
            min: 0
        })
    }
    get min() {
        return this._min
    }
    set min(e) {
        this._min = e, this._setRange()
    }
    get max() {
        return this._max
    }
    set max(e) {
        this._max = e, this._setRange()
    }
    _setRange() {
        this._add.value = this._min, this._mult.value = this._max - this._min
    }
    dispose() {
        return super.dispose(), this._add.dispose(), this._mult.dispose(), this
    }
}
class Eb extends ls {
    constructor() {
        super(Object.assign(re(Eb.getDefaults(), arguments))), this.name = "Zero", this._gain = new Ye({
            context: this.context
        }), this.output = this._gain, this.input = void 0, xs(this.context.getConstant(0), this._gain)
    }
    dispose() {
        return super.dispose(), xk(this.context.getConstant(0), this._gain), this
    }
}
class Sr extends Ne {
    constructor() {
        super(re(Sr.getDefaults(), arguments, ["frequency", "min", "max"])), this.name = "LFO", this._stoppedValue = 0, this._units = "number", this.convert = !0, this._fromType = pt.prototype._fromType, this._toType = pt.prototype._toType, this._is = pt.prototype._is, this._clampValue = pt.prototype._clampValue;
        const e = re(Sr.getDefaults(), arguments, ["frequency", "min", "max"]);
        this._oscillator = new un(e), this.frequency = this._oscillator.frequency, this._amplitudeGain = new Ye({
            context: this.context,
            gain: e.amplitude,
            units: "normalRange"
        }), this.amplitude = this._amplitudeGain.gain, this._stoppedSignal = new Je({
            context: this.context,
            units: "audioRange",
            value: 0
        }), this._zeros = new Eb({
            context: this.context
        }), this._a2g = new bb({
            context: this.context
        }), this._scaler = this.output = new mo({
            context: this.context,
            max: e.max,
            min: e.min
        }), this.units = e.units, this.min = e.min, this.max = e.max, this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler), this._zeros.connect(this._a2g), this._stoppedSignal.connect(this._a2g), ze(this, ["amplitude", "frequency"]), this.phase = e.phase
    }
    static getDefaults() {
        return Object.assign(un.getDefaults(), {
            amplitude: 1,
            frequency: "4n",
            max: 1,
            min: 0,
            type: "sine",
            units: "number"
        })
    }
    start(e) {
        return e = this.toSeconds(e), this._stoppedSignal.setValueAtTime(0, e), this._oscillator.start(e), this
    }
    stop(e) {
        return e = this.toSeconds(e), this._stoppedSignal.setValueAtTime(this._stoppedValue, e), this._oscillator.stop(e), this
    }
    sync() {
        return this._oscillator.sync(), this._oscillator.syncFrequency(), this
    }
    unsync() {
        return this._oscillator.unsync(), this._oscillator.unsyncFrequency(), this
    }
    _setStoppedValue() {
        this._stoppedValue = this._oscillator.getInitialValue(), this._stoppedSignal.value = this._stoppedValue
    }
    get min() {
        return this._toType(this._scaler.min)
    }
    set min(e) {
        e = this._fromType(e), this._scaler.min = e
    }
    get max() {
        return this._toType(this._scaler.max)
    }
    set max(e) {
        e = this._fromType(e), this._scaler.max = e
    }
    get type() {
        return this._oscillator.type
    }
    set type(e) {
        this._oscillator.type = e, this._setStoppedValue()
    }
    get partials() {
        return this._oscillator.partials
    }
    set partials(e) {
        this._oscillator.partials = e, this._setStoppedValue()
    }
    get phase() {
        return this._oscillator.phase
    }
    set phase(e) {
        this._oscillator.phase = e, this._setStoppedValue()
    }
    get units() {
        return this._units
    }
    set units(e) {
        const n = this.min,
            r = this.max;
        this._units = e, this.min = n, this.max = r
    }
    get state() {
        return this._oscillator.state
    }
    connect(e, n, r) {
        return (e instanceof pt || e instanceof Je) && (this.convert = e.convert, this.units = e.units), Ng(this, e, n, r), this
    }
    dispose() {
        return super.dispose(), this._oscillator.dispose(), this._stoppedSignal.dispose(), this._zeros.dispose(), this._scaler.dispose(), this._a2g.dispose(), this._amplitudeGain.dispose(), this.amplitude.dispose(), this
    }
}

function Pk(t, e = 1 / 0) {
    const n = new WeakMap;
    return function(r, s) {
        Reflect.defineProperty(r, s, {
            configurable: !0,
            enumerable: !0,
            get: function() {
                return n.get(this)
            },
            set: function(i) {
                Qs(i, t, e), n.set(this, i)
            }
        })
    }
}

function So(t, e = 1 / 0) {
    const n = new WeakMap;
    return function(r, s) {
        Reflect.defineProperty(r, s, {
            configurable: !0,
            enumerable: !0,
            get: function() {
                return n.get(this)
            },
            set: function(i) {
                Qs(this.toSeconds(i), t, e), n.set(this, i)
            }
        })
    }
}
class kc extends Mn {
    constructor() {
        super(re(kc.getDefaults(), arguments, ["url", "onload"])), this.name = "Player", this._activeSources = new Set;
        const e = re(kc.getDefaults(), arguments, ["url", "onload"]);
        this._buffer = new Pt({
            onload: this._onload.bind(this, e.onload),
            onerror: e.onerror,
            reverse: e.reverse,
            url: e.url
        }), this.autostart = e.autostart, this._loop = e.loop, this._loopStart = e.loopStart, this._loopEnd = e.loopEnd, this._playbackRate = e.playbackRate, this.fadeIn = e.fadeIn, this.fadeOut = e.fadeOut
    }
    static getDefaults() {
        return Object.assign(Mn.getDefaults(), {
            autostart: !1,
            fadeIn: 0,
            fadeOut: 0,
            loop: !1,
            loopEnd: 0,
            loopStart: 0,
            onload: yt,
            onerror: yt,
            playbackRate: 1,
            reverse: !1
        })
    }
    load(e) {
        return kn(this, void 0, void 0, function*() {
            return yield this._buffer.load(e), this._onload(), this
        })
    }
    _onload(e = yt) {
        e(), this.autostart && this.start()
    }
    _onSourceEnd(e) {
        this.onstop(this), this._activeSources.delete(e), this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started" && (this._state.cancel(this.now()), this._state.setStateAtTime("stopped", this.now()))
    }
    start(e, n, r) {
        return super.start(e, n, r), this
    }
    _start(e, n, r) {
        this._loop ? n = Ll(n, this._loopStart) : n = Ll(n, 0);
        const s = this.toSeconds(n),
            i = r;
        r = Ll(r, Math.max(this._buffer.duration - s, 0));
        let o = this.toSeconds(r);
        o = o / this._playbackRate, e = this.toSeconds(e);
        const a = new Ni({
            url: this._buffer,
            context: this.context,
            fadeIn: this.fadeIn,
            fadeOut: this.fadeOut,
            loop: this._loop,
            loopEnd: this._loopEnd,
            loopStart: this._loopStart,
            onended: this._onSourceEnd.bind(this),
            playbackRate: this._playbackRate
        }).connect(this.output);
        !this._loop && !this._synced && (this._state.cancel(e + o), this._state.setStateAtTime("stopped", e + o, {
            implicitEnd: !0
        })), this._activeSources.add(a), this._loop && ks(i) ? a.start(e, s) : a.start(e, s, o - this.toSeconds(this.fadeOut))
    }
    _stop(e) {
        const n = this.toSeconds(e);
        this._activeSources.forEach(r => r.stop(n))
    }
    restart(e, n, r) {
        return super.restart(e, n, r), this
    }
    _restart(e, n, r) {
        this._stop(e), this._start(e, n, r)
    }
    seek(e, n) {
        const r = this.toSeconds(n);
        if (this._state.getValueAtTime(r) === "started") {
            const s = this.toSeconds(e);
            this._stop(r), this._start(r, s)
        }
        return this
    }
    setLoopPoints(e, n) {
        return this.loopStart = e, this.loopEnd = n, this
    }
    get loopStart() {
        return this._loopStart
    }
    set loopStart(e) {
        this._loopStart = e, this.buffer.loaded && Qs(this.toSeconds(e), 0, this.buffer.duration), this._activeSources.forEach(n => {
            n.loopStart = e
        })
    }
    get loopEnd() {
        return this._loopEnd
    }
    set loopEnd(e) {
        this._loopEnd = e, this.buffer.loaded && Qs(this.toSeconds(e), 0, this.buffer.duration), this._activeSources.forEach(n => {
            n.loopEnd = e
        })
    }
    get buffer() {
        return this._buffer
    }
    set buffer(e) {
        this._buffer.set(e)
    }
    get loop() {
        return this._loop
    }
    set loop(e) {
        if (this._loop !== e && (this._loop = e, this._activeSources.forEach(n => {
                n.loop = e
            }), e)) {
            const n = this._state.getNextState("stopped", this.now());
            n && this._state.cancel(n.time)
        }
    }
    get playbackRate() {
        return this._playbackRate
    }
    set playbackRate(e) {
        this._playbackRate = e;
        const n = this.now(),
            r = this._state.getNextState("stopped", n);
        r && r.implicitEnd && (this._state.cancel(r.time), this._activeSources.forEach(s => s.cancelStop())), this._activeSources.forEach(s => {
            s.playbackRate.setValueAtTime(e, n)
        })
    }
    get reverse() {
        return this._buffer.reverse
    }
    set reverse(e) {
        this._buffer.reverse = e
    }
    get loaded() {
        return this._buffer.loaded
    }
    dispose() {
        return super.dispose(), this._activeSources.forEach(e => e.dispose()), this._activeSources.clear(), this._buffer.dispose(), this
    }
}
oi([So(0)], kc.prototype, "fadeIn", void 0);
oi([So(0)], kc.prototype, "fadeOut", void 0);
class ff extends Ne {
    constructor() {
        super(re(ff.getDefaults(), arguments, ["urls", "onload"], "urls")), this.name = "Players", this.input = void 0, this._players = new Map;
        const e = re(ff.getDefaults(), arguments, ["urls", "onload"], "urls");
        this._volume = this.output = new Ii({
            context: this.context,
            volume: e.volume
        }), this.volume = this._volume.volume, ze(this, "volume"), this._buffers = new od({
            urls: e.urls,
            onload: e.onload,
            baseUrl: e.baseUrl,
            onerror: e.onerror
        }), this.mute = e.mute, this._fadeIn = e.fadeIn, this._fadeOut = e.fadeOut
    }
    static getDefaults() {
        return Object.assign(Mn.getDefaults(), {
            baseUrl: "",
            fadeIn: 0,
            fadeOut: 0,
            mute: !1,
            onload: yt,
            onerror: yt,
            urls: {},
            volume: 0
        })
    }
    get mute() {
        return this._volume.mute
    }
    set mute(e) {
        this._volume.mute = e
    }
    get fadeIn() {
        return this._fadeIn
    }
    set fadeIn(e) {
        this._fadeIn = e, this._players.forEach(n => {
            n.fadeIn = e
        })
    }
    get fadeOut() {
        return this._fadeOut
    }
    set fadeOut(e) {
        this._fadeOut = e, this._players.forEach(n => {
            n.fadeOut = e
        })
    }
    get state() {
        return Array.from(this._players).some(([n, r]) => r.state === "started") ? "started" : "stopped"
    }
    has(e) {
        return this._buffers.has(e)
    }
    player(e) {
        if (Qe(this.has(e), `No Player with the name ${e} exists on this object`), !this._players.has(e)) {
            const n = new kc({
                context: this.context,
                fadeIn: this._fadeIn,
                fadeOut: this._fadeOut,
                url: this._buffers.get(e)
            }).connect(this.output);
            this._players.set(e, n)
        }
        return this._players.get(e)
    }
    get loaded() {
        return this._buffers.loaded
    }
    add(e, n, r) {
        return Qe(!this._buffers.has(e), "A buffer with that name already exists on this object"), this._buffers.add(e, n, r), this
    }
    stopAll(e) {
        return this._players.forEach(n => n.stop(e)), this
    }
    dispose() {
        return super.dispose(), this._volume.dispose(), this.volume.dispose(), this._players.forEach(e => e.dispose()), this._buffers.dispose(), this
    }
}
class qTe extends ls {
    constructor() {
        super(...arguments), this.name = "Abs", this._abs = new Js({
            context: this.context,
            mapping: e => Math.abs(e) < .001 ? 0 : Math.abs(e)
        }), this.input = this._abs, this.output = this._abs
    }
    dispose() {
        return super.dispose(), this._abs.dispose(), this
    }
}
class GTe extends ls {
    constructor() {
        super(...arguments), this.name = "GainToAudio", this._norm = new Js({
            context: this.context,
            mapping: e => Math.abs(e) * 2 - 1
        }), this.input = this._norm, this.output = this._norm
    }
    dispose() {
        return super.dispose(), this._norm.dispose(), this
    }
}
class Rk extends ls {
    constructor() {
        super(...arguments), this.name = "Negate", this._multiply = new fn({
            context: this.context,
            value: -1
        }), this.input = this._multiply, this.output = this._multiply
    }
    dispose() {
        return super.dispose(), this._multiply.dispose(), this
    }
}
class Bu extends Je {
    constructor() {
        super(Object.assign(re(Bu.getDefaults(), arguments, ["value"]))), this.override = !1, this.name = "Subtract", this._sum = new Ye({
            context: this.context
        }), this.input = this._sum, this.output = this._sum, this._neg = new Rk({
            context: this.context
        }), this.subtrahend = this._param, Ns(this._constantSource, this._neg, this._sum)
    }
    static getDefaults() {
        return Object.assign(Je.getDefaults(), {
            value: 0
        })
    }
    dispose() {
        return super.dispose(), this._neg.dispose(), this._sum.dispose(), this
    }
}
class Tb extends ls {
    constructor() {
        super(Object.assign(re(Tb.getDefaults(), arguments))), this.name = "GreaterThanZero", this._thresh = this.output = new Js({
            context: this.context,
            length: 127,
            mapping: e => e <= 0 ? 0 : 1
        }), this._scale = this.input = new fn({
            context: this.context,
            value: 1e4
        }), this._scale.connect(this._thresh)
    }
    dispose() {
        return super.dispose(), this._scale.dispose(), this._thresh.dispose(), this
    }
}
class q1 extends Je {
    constructor() {
        super(Object.assign(re(q1.getDefaults(), arguments, ["value"]))), this.name = "GreaterThan", this.override = !1;
        const e = re(q1.getDefaults(), arguments, ["value"]);
        this._subtract = this.input = new Bu({
            context: this.context,
            value: e.value
        }), this._gtz = this.output = new Tb({
            context: this.context
        }), this.comparator = this._param = this._subtract.subtrahend, ze(this, "comparator"), this._subtract.connect(this._gtz)
    }
    static getDefaults() {
        return Object.assign(Je.getDefaults(), {
            value: 0
        })
    }
    dispose() {
        return super.dispose(), this._gtz.dispose(), this._subtract.dispose(), this.comparator.dispose(), this
    }
}
class df extends ls {
    constructor() {
        super(Object.assign(re(df.getDefaults(), arguments, ["value"]))), this.name = "Pow";
        const e = re(df.getDefaults(), arguments, ["value"]);
        this._exponentScaler = this.input = this.output = new Js({
            context: this.context,
            mapping: this._expFunc(e.value),
            length: 8192
        }), this._exponent = e.value
    }
    static getDefaults() {
        return Object.assign(ls.getDefaults(), {
            value: 1
        })
    }
    _expFunc(e) {
        return n => Math.pow(Math.abs(n), e)
    }
    get value() {
        return this._exponent
    }
    set value(e) {
        this._exponent = e, this._exponentScaler.setMap(this._expFunc(this._exponent))
    }
    dispose() {
        return super.dispose(), this._exponentScaler.dispose(), this
    }
}
class G1 extends mo {
    constructor() {
        super(Object.assign(re(G1.getDefaults(), arguments, ["min", "max", "exponent"]))), this.name = "ScaleExp";
        const e = re(G1.getDefaults(), arguments, ["min", "max", "exponent"]);
        this.input = this._exp = new df({
            context: this.context,
            value: e.exponent
        }), this._exp.connect(this._mult)
    }
    static getDefaults() {
        return Object.assign(mo.getDefaults(), {
            exponent: 1
        })
    }
    get exponent() {
        return this._exp.value
    }
    set exponent(e) {
        this._exp.value = e
    }
    dispose() {
        return super.dispose(), this._exp.dispose(), this
    }
}
class rr extends Ne {
    constructor() {
        super(re(rr.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "Envelope", this._sig = new Je({
            context: this.context,
            value: 0
        }), this.output = this._sig, this.input = void 0;
        const e = re(rr.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
        this.attack = e.attack, this.decay = e.decay, this.sustain = e.sustain, this.release = e.release, this.attackCurve = e.attackCurve, this.releaseCurve = e.releaseCurve, this.decayCurve = e.decayCurve
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            attack: .01,
            attackCurve: "linear",
            decay: .1,
            decayCurve: "exponential",
            release: 1,
            releaseCurve: "exponential",
            sustain: .5
        })
    }
    get value() {
        return this.getValueAtTime(this.now())
    }
    _getCurve(e, n) {
        if (ki(e)) return e; {
            let r;
            for (r in Np)
                if (Np[r][n] === e) return r;
            return e
        }
    }
    _setCurve(e, n, r) {
        if (ki(r) && Reflect.has(Np, r)) {
            const s = Np[r];
            _c(s) ? e !== "_decayCurve" && (this[e] = s[n]) : this[e] = s
        } else if (is(r) && e !== "_decayCurve") this[e] = r;
        else throw new Error("Envelope: invalid curve: " + r)
    }
    get attackCurve() {
        return this._getCurve(this._attackCurve, "In")
    }
    set attackCurve(e) {
        this._setCurve("_attackCurve", "In", e)
    }
    get releaseCurve() {
        return this._getCurve(this._releaseCurve, "Out")
    }
    set releaseCurve(e) {
        this._setCurve("_releaseCurve", "Out", e)
    }
    get decayCurve() {
        return this._decayCurve
    }
    set decayCurve(e) {
        Qe(["linear", "exponential"].some(n => n === e), `Invalid envelope curve: ${e}`), this._decayCurve = e
    }
    triggerAttack(e, n = 1) {
        this.log("triggerAttack", e, n), e = this.toSeconds(e);
        let s = this.toSeconds(this.attack);
        const i = this.toSeconds(this.decay),
            o = this.getValueAtTime(e);
        if (o > 0) {
            const a = 1 / s;
            s = (1 - o) / a
        }
        if (s < this.sampleTime) this._sig.cancelScheduledValues(e), this._sig.setValueAtTime(n, e);
        else if (this._attackCurve === "linear") this._sig.linearRampTo(n, s, e);
        else if (this._attackCurve === "exponential") this._sig.targetRampTo(n, s, e);
        else {
            this._sig.cancelAndHoldAtTime(e);
            let a = this._attackCurve;
            for (let l = 1; l < a.length; l++)
                if (a[l - 1] <= o && o <= a[l]) {
                    a = this._attackCurve.slice(l), a[0] = o;
                    break
                } this._sig.setValueCurveAtTime(a, e, s, n)
        }
        if (i && this.sustain < 1) {
            const a = n * this.sustain,
                l = e + s;
            this.log("decay", l), this._decayCurve === "linear" ? this._sig.linearRampToValueAtTime(a, i + l) : this._sig.exponentialApproachValueAtTime(a, l, i)
        }
        return this
    }
    triggerRelease(e) {
        this.log("triggerRelease", e), e = this.toSeconds(e);
        const n = this.getValueAtTime(e);
        if (n > 0) {
            const r = this.toSeconds(this.release);
            r < this.sampleTime ? this._sig.setValueAtTime(0, e) : this._releaseCurve === "linear" ? this._sig.linearRampTo(0, r, e) : this._releaseCurve === "exponential" ? this._sig.targetRampTo(0, r, e) : (Qe(is(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array"), this._sig.cancelAndHoldAtTime(e), this._sig.setValueCurveAtTime(this._releaseCurve, e, r, n))
        }
        return this
    }
    getValueAtTime(e) {
        return this._sig.getValueAtTime(e)
    }
    triggerAttackRelease(e, n, r = 1) {
        return n = this.toSeconds(n), this.triggerAttack(n, r), this.triggerRelease(n + this.toSeconds(e)), this
    }
    cancel(e) {
        return this._sig.cancelScheduledValues(this.toSeconds(e)), this
    }
    connect(e, n = 0, r = 0) {
        return Ng(this, e, n, r), this
    }
    asArray(e = 1024) {
        return kn(this, void 0, void 0, function*() {
            const n = e / this.context.sampleRate,
                r = new Cg(1, n, this.context.sampleRate),
                s = this.toSeconds(this.attack) + this.toSeconds(this.decay),
                i = s + this.toSeconds(this.release),
                o = i * .1,
                a = i + o,
                l = new this.constructor(Object.assign(this.get(), {
                    attack: n * this.toSeconds(this.attack) / a,
                    decay: n * this.toSeconds(this.decay) / a,
                    release: n * this.toSeconds(this.release) / a,
                    context: r
                }));
            return l._sig.toDestination(), l.triggerAttackRelease(n * (s + o) / a, 0), (yield r.render()).getChannelData(0)
        })
    }
    dispose() {
        return super.dispose(), this._sig.dispose(), this
    }
}
oi([So(0)], rr.prototype, "attack", void 0);
oi([So(0)], rr.prototype, "decay", void 0);
oi([Pk(0, 1)], rr.prototype, "sustain", void 0);
oi([So(0)], rr.prototype, "release", void 0);
const Np = (() => {
    let e, n;
    const r = [];
    for (e = 0; e < 128; e++) r[e] = Math.sin(e / (128 - 1) * (Math.PI / 2));
    const s = [],
        i = 6.4;
    for (e = 0; e < 128 - 1; e++) {
        n = e / (128 - 1);
        const p = Math.sin(n * (Math.PI * 2) * i - Math.PI / 2) + 1;
        s[e] = p / 10 + n * .83
    }
    s[128 - 1] = 1;
    const o = [],
        a = 5;
    for (e = 0; e < 128; e++) o[e] = Math.ceil(e / (128 - 1) * a) / a;
    const l = [];
    for (e = 0; e < 128; e++) n = e / (128 - 1), l[e] = .5 * (1 - Math.cos(Math.PI * n));
    const u = [];
    for (e = 0; e < 128; e++) {
        n = e / (128 - 1);
        const p = Math.pow(n, 3) * 4 + .2,
            _ = Math.cos(p * Math.PI * 2 * n);
        u[e] = Math.abs(_ * (1 - n))
    }

    function f(p) {
        const _ = new Array(p.length);
        for (let v = 0; v < p.length; v++) _[v] = 1 - p[v];
        return _
    }

    function d(p) {
        return p.slice(0).reverse()
    }
    return {
        bounce: {
            In: f(u),
            Out: u
        },
        cosine: {
            In: r,
            Out: d(r)
        },
        exponential: "exponential",
        linear: "linear",
        ripple: {
            In: s,
            Out: f(s)
        },
        sine: {
            In: l,
            Out: f(l)
        },
        step: {
            In: o,
            Out: f(o)
        }
    }
})();
let xi = class kv extends Ne {
    constructor() {
        super(re(kv.getDefaults(), arguments)), this._scheduledEvents = [], this._synced = !1, this._original_triggerAttack = this.triggerAttack, this._original_triggerRelease = this.triggerRelease;
        const e = re(kv.getDefaults(), arguments);
        this._volume = this.output = new Ii({
            context: this.context,
            volume: e.volume
        }), this.volume = this._volume.volume, ze(this, "volume")
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            volume: 0
        })
    }
    sync() {
        return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 0)), this
    }
    _syncState() {
        let e = !1;
        return this._synced || (this._synced = !0, e = !0), e
    }
    _syncMethod(e, n) {
        const r = this["_original_" + e] = this[e];
        this[e] = (...s) => {
            const i = s[n],
                o = this.context.transport.schedule(a => {
                    s[n] = a, r.apply(this, s)
                }, i);
            this._scheduledEvents.push(o)
        }
    }
    unsync() {
        return this._scheduledEvents.forEach(e => this.context.transport.clear(e)), this._scheduledEvents = [], this._synced && (this._synced = !1, this.triggerAttack = this._original_triggerAttack, this.triggerRelease = this._original_triggerRelease), this
    }
    triggerAttackRelease(e, n, r, s) {
        const i = this.toSeconds(r),
            o = this.toSeconds(n);
        return this.triggerAttack(e, i, s), this.triggerRelease(i + o), this
    }
    dispose() {
        return super.dispose(), this._volume.dispose(), this.unsync(), this._scheduledEvents = [], this
    }
};
class tr extends xi {
    constructor() {
        super(re(tr.getDefaults(), arguments));
        const e = re(tr.getDefaults(), arguments);
        this.portamento = e.portamento, this.onsilence = e.onsilence
    }
    static getDefaults() {
        return Object.assign(xi.getDefaults(), {
            detune: 0,
            onsilence: yt,
            portamento: 0
        })
    }
    triggerAttack(e, n, r = 1) {
        this.log("triggerAttack", e, n, r);
        const s = this.toSeconds(n);
        return this._triggerEnvelopeAttack(s, r), this.setNote(e, s), this
    }
    triggerRelease(e) {
        this.log("triggerRelease", e);
        const n = this.toSeconds(e);
        return this._triggerEnvelopeRelease(n), this
    }
    setNote(e, n) {
        const r = this.toSeconds(n),
            s = e instanceof er ? e.toFrequency() : e;
        if (this.portamento > 0 && this.getLevelAtTime(r) > .05) {
            const i = this.toSeconds(this.portamento);
            this.frequency.exponentialRampTo(s, i, r)
        } else this.frequency.setValueAtTime(s, r);
        return this
    }
}
oi([So(0)], tr.prototype, "portamento", void 0);
class ad extends rr {
    constructor() {
        super(re(ad.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "AmplitudeEnvelope", this._gainNode = new Ye({
            context: this.context,
            gain: 0
        }), this.output = this._gainNode, this.input = this._gainNode, this._sig.connect(this._gainNode.gain), this.output = this._gainNode, this.input = this._gainNode
    }
    dispose() {
        return super.dispose(), this._gainNode.dispose(), this
    }
}
class Pi extends tr {
    constructor() {
        super(re(Pi.getDefaults(), arguments)), this.name = "Synth";
        const e = re(Pi.getDefaults(), arguments);
        this.oscillator = new Ps(Object.assign({
            context: this.context,
            detune: e.detune,
            onstop: () => this.onsilence(this)
        }, e.oscillator)), this.frequency = this.oscillator.frequency, this.detune = this.oscillator.detune, this.envelope = new ad(Object.assign({
            context: this.context
        }, e.envelope)), this.oscillator.chain(this.envelope, this.output), ze(this, ["oscillator", "frequency", "detune", "envelope"])
    }
    static getDefaults() {
        return Object.assign(tr.getDefaults(), {
            envelope: Object.assign(hr(rr.getDefaults(), Object.keys(Ne.getDefaults())), {
                attack: .005,
                decay: .1,
                release: 1,
                sustain: .3
            }),
            oscillator: Object.assign(hr(Ps.getDefaults(), [...Object.keys(Mn.getDefaults()), "frequency", "detune"]), {
                type: "triangle"
            })
        })
    }
    _triggerEnvelopeAttack(e, n) {
        if (this.envelope.triggerAttack(e, n), this.oscillator.start(e), this.envelope.sustain === 0) {
            const r = this.toSeconds(this.envelope.attack),
                s = this.toSeconds(this.envelope.decay);
            this.oscillator.stop(e + r + s)
        }
    }
    _triggerEnvelopeRelease(e) {
        this.envelope.triggerRelease(e), this.oscillator.stop(e + this.toSeconds(this.envelope.release))
    }
    getLevelAtTime(e) {
        return e = this.toSeconds(e), this.envelope.getValueAtTime(e)
    }
    dispose() {
        return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this
    }
}
class iu extends tr {
    constructor() {
        super(re(iu.getDefaults(), arguments)), this.name = "ModulationSynth";
        const e = re(iu.getDefaults(), arguments);
        this._carrier = new Pi({
            context: this.context,
            oscillator: e.oscillator,
            envelope: e.envelope,
            onsilence: () => this.onsilence(this),
            volume: -10
        }), this._modulator = new Pi({
            context: this.context,
            oscillator: e.modulation,
            envelope: e.modulationEnvelope,
            volume: -10
        }), this.oscillator = this._carrier.oscillator, this.envelope = this._carrier.envelope, this.modulation = this._modulator.oscillator, this.modulationEnvelope = this._modulator.envelope, this.frequency = new Je({
            context: this.context,
            units: "frequency"
        }), this.detune = new Je({
            context: this.context,
            value: e.detune,
            units: "cents"
        }), this.harmonicity = new fn({
            context: this.context,
            value: e.harmonicity,
            minValue: 0
        }), this._modulationNode = new Ye({
            context: this.context,
            gain: 0
        }), ze(this, ["frequency", "harmonicity", "oscillator", "envelope", "modulation", "modulationEnvelope", "detune"])
    }
    static getDefaults() {
        return Object.assign(tr.getDefaults(), {
            harmonicity: 3,
            oscillator: Object.assign(hr(Ps.getDefaults(), [...Object.keys(Mn.getDefaults()), "frequency", "detune"]), {
                type: "sine"
            }),
            envelope: Object.assign(hr(rr.getDefaults(), Object.keys(Ne.getDefaults())), {
                attack: .01,
                decay: .01,
                sustain: 1,
                release: .5
            }),
            modulation: Object.assign(hr(Ps.getDefaults(), [...Object.keys(Mn.getDefaults()), "frequency", "detune"]), {
                type: "square"
            }),
            modulationEnvelope: Object.assign(hr(rr.getDefaults(), Object.keys(Ne.getDefaults())), {
                attack: .5,
                decay: 0,
                sustain: 1,
                release: .5
            })
        })
    }
    _triggerEnvelopeAttack(e, n) {
        this._carrier._triggerEnvelopeAttack(e, n), this._modulator._triggerEnvelopeAttack(e, n)
    }
    _triggerEnvelopeRelease(e) {
        return this._carrier._triggerEnvelopeRelease(e), this._modulator._triggerEnvelopeRelease(e), this
    }
    getLevelAtTime(e) {
        return e = this.toSeconds(e), this.envelope.getValueAtTime(e)
    }
    dispose() {
        return super.dispose(), this._carrier.dispose(), this._modulator.dispose(), this.frequency.dispose(), this.detune.dispose(), this.harmonicity.dispose(), this._modulationNode.dispose(), this
    }
}
class xg extends iu {
    constructor() {
        super(re(xg.getDefaults(), arguments)), this.name = "AMSynth", this._modulationScale = new bb({
            context: this.context
        }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.detune.fan(this._carrier.detune, this._modulator.detune), this._modulator.chain(this._modulationScale, this._modulationNode.gain), this._carrier.chain(this._modulationNode, this.output)
    }
    dispose() {
        return super.dispose(), this._modulationScale.dispose(), this
    }
}
class pf extends Ne {
    constructor() {
        super(re(pf.getDefaults(), arguments, ["frequency", "type"])), this.name = "BiquadFilter";
        const e = re(pf.getDefaults(), arguments, ["frequency", "type"]);
        this._filter = this.context.createBiquadFilter(), this.input = this.output = this._filter, this.Q = new pt({
            context: this.context,
            units: "number",
            value: e.Q,
            param: this._filter.Q
        }), this.frequency = new pt({
            context: this.context,
            units: "frequency",
            value: e.frequency,
            param: this._filter.frequency
        }), this.detune = new pt({
            context: this.context,
            units: "cents",
            value: e.detune,
            param: this._filter.detune
        }), this.gain = new pt({
            context: this.context,
            units: "decibels",
            convert: !1,
            value: e.gain,
            param: this._filter.gain
        }), this.type = e.type
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            Q: 1,
            type: "lowpass",
            frequency: 350,
            detune: 0,
            gain: 0
        })
    }
    get type() {
        return this._filter.type
    }
    set type(e) {
        Qe(["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass", "peaking"].indexOf(e) !== -1, `Invalid filter type: ${e}`), this._filter.type = e
    }
    getFrequencyResponse(e = 128) {
        const n = new Float32Array(e);
        for (let o = 0; o < e; o++) {
            const l = Math.pow(o / e, 2) * (2e4 - 20) + 20;
            n[o] = l
        }
        const r = new Float32Array(e),
            s = new Float32Array(e),
            i = this.context.createBiquadFilter();
        return i.type = this.type, i.Q.value = this.Q.value, i.frequency.value = this.frequency.value, i.gain.value = this.gain.value, i.getFrequencyResponse(n, r, s), r
    }
    dispose() {
        return super.dispose(), this._filter.disconnect(), this.Q.dispose(), this.frequency.dispose(), this.gain.dispose(), this.detune.dispose(), this
    }
}
class Dr extends Ne {
    constructor() {
        super(re(Dr.getDefaults(), arguments, ["frequency", "type", "rolloff"])), this.name = "Filter", this.input = new Ye({
            context: this.context
        }), this.output = new Ye({
            context: this.context
        }), this._filters = [];
        const e = re(Dr.getDefaults(), arguments, ["frequency", "type", "rolloff"]);
        this._filters = [], this.Q = new Je({
            context: this.context,
            units: "positive",
            value: e.Q
        }), this.frequency = new Je({
            context: this.context,
            units: "frequency",
            value: e.frequency
        }), this.detune = new Je({
            context: this.context,
            units: "cents",
            value: e.detune
        }), this.gain = new Je({
            context: this.context,
            units: "decibels",
            convert: !1,
            value: e.gain
        }), this._type = e.type, this.rolloff = e.rolloff, ze(this, ["detune", "frequency", "gain", "Q"])
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            Q: 1,
            detune: 0,
            frequency: 350,
            gain: 0,
            rolloff: -12,
            type: "lowpass"
        })
    }
    get type() {
        return this._type
    }
    set type(e) {
        Qe(["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass", "peaking"].indexOf(e) !== -1, `Invalid filter type: ${e}`), this._type = e, this._filters.forEach(r => r.type = e)
    }
    get rolloff() {
        return this._rolloff
    }
    set rolloff(e) {
        const n = po(e) ? e : parseInt(e, 10),
            r = [-12, -24, -48, -96];
        let s = r.indexOf(n);
        Qe(s !== -1, `rolloff can only be ${r.join(", ")}`), s += 1, this._rolloff = n, this.input.disconnect(), this._filters.forEach(i => i.disconnect()), this._filters = new Array(s);
        for (let i = 0; i < s; i++) {
            const o = new pf({
                context: this.context
            });
            o.type = this._type, this.frequency.connect(o.frequency), this.detune.connect(o.detune), this.Q.connect(o.Q), this.gain.connect(o.gain), this._filters[i] = o
        }
        this._internalChannels = this._filters, Ns(this.input, ...this._internalChannels, this.output)
    }
    getFrequencyResponse(e = 128) {
        const n = new pf({
                frequency: this.frequency.value,
                gain: this.gain.value,
                Q: this.Q.value,
                type: this._type,
                detune: this.detune.value
            }),
            r = new Float32Array(e).map(() => 1);
        return this._filters.forEach(() => {
            n.getFrequencyResponse(e).forEach((i, o) => r[o] *= i)
        }), n.dispose(), r
    }
    dispose() {
        return super.dispose(), this._filters.forEach(e => {
            e.dispose()
        }), id(this, ["detune", "frequency", "gain", "Q"]), this.frequency.dispose(), this.Q.dispose(), this.detune.dispose(), this.gain.dispose(), this
    }
}
class mf extends rr {
    constructor() {
        super(re(mf.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "FrequencyEnvelope";
        const e = re(mf.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
        this._octaves = e.octaves, this._baseFrequency = this.toFrequency(e.baseFrequency), this._exponent = this.input = new df({
            context: this.context,
            value: e.exponent
        }), this._scale = this.output = new mo({
            context: this.context,
            min: this._baseFrequency,
            max: this._baseFrequency * Math.pow(2, this._octaves)
        }), this._sig.chain(this._exponent, this._scale)
    }
    static getDefaults() {
        return Object.assign(rr.getDefaults(), {
            baseFrequency: 200,
            exponent: 1,
            octaves: 4
        })
    }
    get baseFrequency() {
        return this._baseFrequency
    }
    set baseFrequency(e) {
        const n = this.toFrequency(e);
        Qs(n, 0), this._baseFrequency = n, this._scale.min = this._baseFrequency, this.octaves = this._octaves
    }
    get octaves() {
        return this._octaves
    }
    set octaves(e) {
        this._octaves = e, this._scale.max = this._baseFrequency * Math.pow(2, e)
    }
    get exponent() {
        return this._exponent.value
    }
    set exponent(e) {
        this._exponent.value = e
    }
    dispose() {
        return super.dispose(), this._exponent.dispose(), this._scale.dispose(), this
    }
}
class io extends tr {
    constructor() {
        super(re(io.getDefaults(), arguments)), this.name = "MonoSynth";
        const e = re(io.getDefaults(), arguments);
        this.oscillator = new Ps(Object.assign(e.oscillator, {
            context: this.context,
            detune: e.detune,
            onstop: () => this.onsilence(this)
        })), this.frequency = this.oscillator.frequency, this.detune = this.oscillator.detune, this.filter = new Dr(Object.assign(e.filter, {
            context: this.context
        })), this.filterEnvelope = new mf(Object.assign(e.filterEnvelope, {
            context: this.context
        })), this.envelope = new ad(Object.assign(e.envelope, {
            context: this.context
        })), this.oscillator.chain(this.filter, this.envelope, this.output), this.filterEnvelope.connect(this.filter.frequency), ze(this, ["oscillator", "frequency", "detune", "filter", "filterEnvelope", "envelope"])
    }
    static getDefaults() {
        return Object.assign(tr.getDefaults(), {
            envelope: Object.assign(hr(rr.getDefaults(), Object.keys(Ne.getDefaults())), {
                attack: .005,
                decay: .1,
                release: 1,
                sustain: .9
            }),
            filter: Object.assign(hr(Dr.getDefaults(), Object.keys(Ne.getDefaults())), {
                Q: 1,
                rolloff: -12,
                type: "lowpass"
            }),
            filterEnvelope: Object.assign(hr(mf.getDefaults(), Object.keys(Ne.getDefaults())), {
                attack: .6,
                baseFrequency: 200,
                decay: .2,
                exponent: 2,
                octaves: 3,
                release: 2,
                sustain: .5
            }),
            oscillator: Object.assign(hr(Ps.getDefaults(), Object.keys(Mn.getDefaults())), {
                type: "sawtooth"
            })
        })
    }
    _triggerEnvelopeAttack(e, n = 1) {
        if (this.envelope.triggerAttack(e, n), this.filterEnvelope.triggerAttack(e), this.oscillator.start(e), this.envelope.sustain === 0) {
            const r = this.toSeconds(this.envelope.attack),
                s = this.toSeconds(this.envelope.decay);
            this.oscillator.stop(e + r + s)
        }
    }
    _triggerEnvelopeRelease(e) {
        this.envelope.triggerRelease(e), this.filterEnvelope.triggerRelease(e), this.oscillator.stop(e + this.toSeconds(this.envelope.release))
    }
    getLevelAtTime(e) {
        return e = this.toSeconds(e), this.envelope.getValueAtTime(e)
    }
    dispose() {
        return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this.filterEnvelope.dispose(), this.filter.dispose(), this
    }
}
class V1 extends tr {
    constructor() {
        super(re(V1.getDefaults(), arguments)), this.name = "DuoSynth";
        const e = re(V1.getDefaults(), arguments);
        this.voice0 = new io(Object.assign(e.voice0, {
            context: this.context,
            onsilence: () => this.onsilence(this)
        })), this.voice1 = new io(Object.assign(e.voice1, {
            context: this.context
        })), this.harmonicity = new fn({
            context: this.context,
            units: "positive",
            value: e.harmonicity
        }), this._vibrato = new Sr({
            frequency: e.vibratoRate,
            context: this.context,
            min: -50,
            max: 50
        }), this._vibrato.start(), this.vibratoRate = this._vibrato.frequency, this._vibratoGain = new Ye({
            context: this.context,
            units: "normalRange",
            gain: e.vibratoAmount
        }), this.vibratoAmount = this._vibratoGain.gain, this.frequency = new Je({
            context: this.context,
            units: "frequency",
            value: 440
        }), this.detune = new Je({
            context: this.context,
            units: "cents",
            value: e.detune
        }), this.frequency.connect(this.voice0.frequency), this.frequency.chain(this.harmonicity, this.voice1.frequency), this._vibrato.connect(this._vibratoGain), this._vibratoGain.fan(this.voice0.detune, this.voice1.detune), this.detune.fan(this.voice0.detune, this.voice1.detune), this.voice0.connect(this.output), this.voice1.connect(this.output), ze(this, ["voice0", "voice1", "frequency", "vibratoAmount", "vibratoRate"])
    }
    getLevelAtTime(e) {
        return e = this.toSeconds(e), this.voice0.envelope.getValueAtTime(e) + this.voice1.envelope.getValueAtTime(e)
    }
    static getDefaults() {
        return Is(tr.getDefaults(), {
            vibratoAmount: .5,
            vibratoRate: 5,
            harmonicity: 1.5,
            voice0: Is(hr(io.getDefaults(), Object.keys(tr.getDefaults())), {
                filterEnvelope: {
                    attack: .01,
                    decay: 0,
                    sustain: 1,
                    release: .5
                },
                envelope: {
                    attack: .01,
                    decay: 0,
                    sustain: 1,
                    release: .5
                }
            }),
            voice1: Is(hr(io.getDefaults(), Object.keys(tr.getDefaults())), {
                filterEnvelope: {
                    attack: .01,
                    decay: 0,
                    sustain: 1,
                    release: .5
                },
                envelope: {
                    attack: .01,
                    decay: 0,
                    sustain: 1,
                    release: .5
                }
            })
        })
    }
    _triggerEnvelopeAttack(e, n) {
        this.voice0._triggerEnvelopeAttack(e, n), this.voice1._triggerEnvelopeAttack(e, n)
    }
    _triggerEnvelopeRelease(e) {
        return this.voice0._triggerEnvelopeRelease(e), this.voice1._triggerEnvelopeRelease(e), this
    }
    dispose() {
        return super.dispose(), this.voice0.dispose(), this.voice1.dispose(), this.frequency.dispose(), this.detune.dispose(), this._vibrato.dispose(), this.vibratoRate.dispose(), this._vibratoGain.dispose(), this.harmonicity.dispose(), this
    }
}
class gf extends iu {
    constructor() {
        super(re(gf.getDefaults(), arguments)), this.name = "FMSynth";
        const e = re(gf.getDefaults(), arguments);
        this.modulationIndex = new fn({
            context: this.context,
            value: e.modulationIndex
        }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.frequency.chain(this.modulationIndex, this._modulationNode), this.detune.fan(this._carrier.detune, this._modulator.detune), this._modulator.connect(this._modulationNode.gain), this._modulationNode.connect(this._carrier.frequency), this._carrier.connect(this.output)
    }
    static getDefaults() {
        return Object.assign(iu.getDefaults(), {
            modulationIndex: 10
        })
    }
    dispose() {
        return super.dispose(), this.modulationIndex.dispose(), this
    }
}
const jw = [1, 1.483, 1.932, 2.546, 2.63, 3.897];
class j1 extends tr {
    constructor() {
        super(re(j1.getDefaults(), arguments)), this.name = "MetalSynth", this._oscillators = [], this._freqMultipliers = [];
        const e = re(j1.getDefaults(), arguments);
        this.detune = new Je({
            context: this.context,
            units: "cents",
            value: e.detune
        }), this.frequency = new Je({
            context: this.context,
            units: "frequency"
        }), this._amplitude = new Ye({
            context: this.context,
            gain: 0
        }).connect(this.output), this._highpass = new Dr({
            Q: 0,
            context: this.context,
            type: "highpass"
        }).connect(this._amplitude);
        for (let n = 0; n < jw.length; n++) {
            const r = new ru({
                context: this.context,
                harmonicity: e.harmonicity,
                modulationIndex: e.modulationIndex,
                modulationType: "square",
                onstop: n === 0 ? () => this.onsilence(this) : yt,
                type: "square"
            });
            r.connect(this._highpass), this._oscillators[n] = r;
            const s = new fn({
                context: this.context,
                value: jw[n]
            });
            this._freqMultipliers[n] = s, this.frequency.chain(s, r.frequency), this.detune.connect(r.detune)
        }
        this._filterFreqScaler = new mo({
            context: this.context,
            max: 7e3,
            min: this.toFrequency(e.resonance)
        }), this.envelope = new rr({
            attack: e.envelope.attack,
            attackCurve: "linear",
            context: this.context,
            decay: e.envelope.decay,
            release: e.envelope.release,
            sustain: 0
        }), this.envelope.chain(this._filterFreqScaler, this._highpass.frequency), this.envelope.connect(this._amplitude.gain), this._octaves = e.octaves, this.octaves = e.octaves
    }
    static getDefaults() {
        return Is(tr.getDefaults(), {
            envelope: Object.assign(hr(rr.getDefaults(), Object.keys(Ne.getDefaults())), {
                attack: .001,
                decay: 1.4,
                release: .2
            }),
            harmonicity: 5.1,
            modulationIndex: 32,
            octaves: 1.5,
            resonance: 4e3
        })
    }
    _triggerEnvelopeAttack(e, n = 1) {
        return this.envelope.triggerAttack(e, n), this._oscillators.forEach(r => r.start(e)), this.envelope.sustain === 0 && this._oscillators.forEach(r => {
            r.stop(e + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay))
        }), this
    }
    _triggerEnvelopeRelease(e) {
        return this.envelope.triggerRelease(e), this._oscillators.forEach(n => n.stop(e + this.toSeconds(this.envelope.release))), this
    }
    getLevelAtTime(e) {
        return e = this.toSeconds(e), this.envelope.getValueAtTime(e)
    }
    get modulationIndex() {
        return this._oscillators[0].modulationIndex.value
    }
    set modulationIndex(e) {
        this._oscillators.forEach(n => n.modulationIndex.value = e)
    }
    get harmonicity() {
        return this._oscillators[0].harmonicity.value
    }
    set harmonicity(e) {
        this._oscillators.forEach(n => n.harmonicity.value = e)
    }
    get resonance() {
        return this._filterFreqScaler.min
    }
    set resonance(e) {
        this._filterFreqScaler.min = this.toFrequency(e), this.octaves = this._octaves
    }
    get octaves() {
        return this._octaves
    }
    set octaves(e) {
        this._octaves = e, this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, e)
    }
    dispose() {
        return super.dispose(), this._oscillators.forEach(e => e.dispose()), this._freqMultipliers.forEach(e => e.dispose()), this.frequency.dispose(), this.detune.dispose(), this._filterFreqScaler.dispose(), this._amplitude.dispose(), this.envelope.dispose(), this._highpass.dispose(), this
    }
}
class ou extends Pi {
    constructor() {
        super(re(ou.getDefaults(), arguments)), this.name = "MembraneSynth", this.portamento = 0;
        const e = re(ou.getDefaults(), arguments);
        this.pitchDecay = e.pitchDecay, this.octaves = e.octaves, ze(this, ["oscillator", "envelope"])
    }
    static getDefaults() {
        return Is(tr.getDefaults(), Pi.getDefaults(), {
            envelope: {
                attack: .001,
                attackCurve: "exponential",
                decay: .4,
                release: 1.4,
                sustain: .01
            },
            octaves: 10,
            oscillator: {
                type: "sine"
            },
            pitchDecay: .05
        })
    }
    setNote(e, n) {
        const r = this.toSeconds(n),
            s = this.toFrequency(e instanceof er ? e.toFrequency() : e),
            i = s * this.octaves;
        return this.oscillator.frequency.setValueAtTime(i, r), this.oscillator.frequency.exponentialRampToValueAtTime(s, r + this.toSeconds(this.pitchDecay)), this
    }
    dispose() {
        return super.dispose(), this
    }
}
oi([Pk(0)], ou.prototype, "octaves", void 0);
oi([So(0)], ou.prototype, "pitchDecay", void 0);
class W1 extends xi {
    constructor() {
        super(re(W1.getDefaults(), arguments)), this.name = "NoiseSynth";
        const e = re(W1.getDefaults(), arguments);
        this.noise = new ma(Object.assign({
            context: this.context
        }, e.noise)), this.envelope = new ad(Object.assign({
            context: this.context
        }, e.envelope)), this.noise.chain(this.envelope, this.output)
    }
    static getDefaults() {
        return Object.assign(xi.getDefaults(), {
            envelope: Object.assign(hr(rr.getDefaults(), Object.keys(Ne.getDefaults())), {
                decay: .1,
                sustain: 0
            }),
            noise: Object.assign(hr(ma.getDefaults(), Object.keys(Mn.getDefaults())), {
                type: "white"
            })
        })
    }
    triggerAttack(e, n = 1) {
        return e = this.toSeconds(e), this.envelope.triggerAttack(e, n), this.noise.start(e), this.envelope.sustain === 0 && this.noise.stop(e + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay)), this
    }
    triggerRelease(e) {
        return e = this.toSeconds(e), this.envelope.triggerRelease(e), this.noise.stop(e + this.toSeconds(this.envelope.release)), this
    }
    sync() {
        return this._syncState() && (this._syncMethod("triggerAttack", 0), this._syncMethod("triggerRelease", 0)), this
    }
    triggerAttackRelease(e, n, r = 1) {
        return n = this.toSeconds(n), e = this.toSeconds(e), this.triggerAttack(n, r), this.triggerRelease(n + e), this
    }
    dispose() {
        return super.dispose(), this.noise.dispose(), this.envelope.dispose(), this
    }
}
const Sb = new Set;

function wb(t) {
    Sb.add(t)
}

function Mk(t, e) {
    const n = `registerProcessor("${t}", ${e})`;
    Sb.add(n)
}

function VTe() {
    return Array.from(Sb).join(`
`)
}
class Iv extends Ne {
    constructor(e) {
        super(e), this.name = "ToneAudioWorklet", this.workletOptions = {}, this.onprocessorerror = yt;
        const n = URL.createObjectURL(new Blob([VTe()], {
                type: "text/javascript"
            })),
            r = this._audioWorkletName();
        this._dummyGain = this.context.createGain(), this._dummyParam = this._dummyGain.gain, this.context.addAudioWorkletModule(n, r).then(() => {
            this.disposed || (this._worklet = this.context.createAudioWorkletNode(r, this.workletOptions), this._worklet.onprocessorerror = this.onprocessorerror.bind(this), this.onReady(this._worklet))
        })
    }
    dispose() {
        return super.dispose(), this._dummyGain.disconnect(), this._worklet && (this._worklet.port.postMessage("dispose"), this._worklet.disconnect()), this
    }
}
const jTe = `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`;
wb(jTe);
const WTe = `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;
wb(WTe);
const HTe = `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`;
wb(HTe);
const Dk = "feedback-comb-filter",
    YTe = `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`;
Mk(Dk, YTe);
class _f extends Iv {
    constructor() {
        super(re(_f.getDefaults(), arguments, ["delayTime", "resonance"])), this.name = "FeedbackCombFilter";
        const e = re(_f.getDefaults(), arguments, ["delayTime", "resonance"]);
        this.input = new Ye({
            context: this.context
        }), this.output = new Ye({
            context: this.context
        }), this.delayTime = new pt({
            context: this.context,
            value: e.delayTime,
            units: "time",
            minValue: 0,
            maxValue: 1,
            param: this._dummyParam,
            swappable: !0
        }), this.resonance = new pt({
            context: this.context,
            value: e.resonance,
            units: "normalRange",
            param: this._dummyParam,
            swappable: !0
        }), ze(this, ["resonance", "delayTime"])
    }
    _audioWorkletName() {
        return Dk
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            delayTime: .1,
            resonance: .5
        })
    }
    onReady(e) {
        Ns(this.input, e, this.output);
        const n = e.parameters.get("delayTime");
        this.delayTime.setParam(n);
        const r = e.parameters.get("feedback");
        this.resonance.setParam(r)
    }
    dispose() {
        return super.dispose(), this.input.dispose(), this.output.dispose(), this.delayTime.dispose(), this.resonance.dispose(), this
    }
}
class yf extends Ne {
    constructor() {
        super(re(yf.getDefaults(), arguments, ["frequency", "type"])), this.name = "OnePoleFilter";
        const e = re(yf.getDefaults(), arguments, ["frequency", "type"]);
        this._frequency = e.frequency, this._type = e.type, this.input = new Ye({
            context: this.context
        }), this.output = new Ye({
            context: this.context
        }), this._createFilter()
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            frequency: 880,
            type: "lowpass"
        })
    }
    _createFilter() {
        const e = this._filter,
            n = this.toFrequency(this._frequency),
            r = 1 / (2 * Math.PI * n);
        if (this._type === "lowpass") {
            const s = 1 / (r * this.context.sampleRate),
                i = s - 1;
            this._filter = this.context.createIIRFilter([s, 0], [1, i])
        } else {
            const s = 1 / (r * this.context.sampleRate) - 1;
            this._filter = this.context.createIIRFilter([1, -1], [1, s])
        }
        this.input.chain(this._filter, this.output), e && this.context.setTimeout(() => {
            this.disposed || (this.input.disconnect(e), e.disconnect())
        }, this.blockTime)
    }
    get frequency() {
        return this._frequency
    }
    set frequency(e) {
        this._frequency = e, this._createFilter()
    }
    get type() {
        return this._type
    }
    set type(e) {
        this._type = e, this._createFilter()
    }
    getFrequencyResponse(e = 128) {
        const n = new Float32Array(e);
        for (let i = 0; i < e; i++) {
            const a = Math.pow(i / e, 2) * (2e4 - 20) + 20;
            n[i] = a
        }
        const r = new Float32Array(e),
            s = new Float32Array(e);
        return this._filter.getFrequencyResponse(n, r, s), r
    }
    dispose() {
        return super.dispose(), this.input.dispose(), this.output.dispose(), this._filter.disconnect(), this
    }
}
class vf extends Ne {
    constructor() {
        super(re(vf.getDefaults(), arguments, ["delayTime", "resonance", "dampening"])), this.name = "LowpassCombFilter";
        const e = re(vf.getDefaults(), arguments, ["delayTime", "resonance", "dampening"]);
        this._combFilter = this.output = new _f({
            context: this.context,
            delayTime: e.delayTime,
            resonance: e.resonance
        }), this.delayTime = this._combFilter.delayTime, this.resonance = this._combFilter.resonance, this._lowpass = this.input = new yf({
            context: this.context,
            frequency: e.dampening,
            type: "lowpass"
        }), this._lowpass.connect(this._combFilter)
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            dampening: 3e3,
            delayTime: .1,
            resonance: .5
        })
    }
    get dampening() {
        return this._lowpass.frequency
    }
    set dampening(e) {
        this._lowpass.frequency = e
    }
    dispose() {
        return super.dispose(), this._combFilter.dispose(), this._lowpass.dispose(), this
    }
}
class H1 extends xi {
    constructor() {
        super(re(H1.getDefaults(), arguments)), this.name = "PluckSynth";
        const e = re(H1.getDefaults(), arguments);
        this._noise = new ma({
            context: this.context,
            type: "pink"
        }), this.attackNoise = e.attackNoise, this._lfcf = new vf({
            context: this.context,
            dampening: e.dampening,
            resonance: e.resonance
        }), this.resonance = e.resonance, this.release = e.release, this._noise.connect(this._lfcf), this._lfcf.connect(this.output)
    }
    static getDefaults() {
        return Is(xi.getDefaults(), {
            attackNoise: 1,
            dampening: 4e3,
            resonance: .7,
            release: 1
        })
    }
    get dampening() {
        return this._lfcf.dampening
    }
    set dampening(e) {
        this._lfcf.dampening = e
    }
    triggerAttack(e, n) {
        const r = this.toFrequency(e);
        n = this.toSeconds(n);
        const s = 1 / r;
        return this._lfcf.delayTime.setValueAtTime(s, n), this._noise.start(n), this._noise.stop(n + s * this.attackNoise), this._lfcf.resonance.cancelScheduledValues(n), this._lfcf.resonance.setValueAtTime(this.resonance, n), this
    }
    triggerRelease(e) {
        return this._lfcf.resonance.linearRampTo(0, this.release, e), this
    }
    dispose() {
        return super.dispose(), this._noise.dispose(), this._lfcf.dispose(), this
    }
}
class uc extends xi {
    constructor() {
        super(re(uc.getDefaults(), arguments, ["voice", "options"])), this.name = "PolySynth", this._availableVoices = [], this._activeVoices = [], this._voices = [], this._gcTimeout = -1, this._averageActiveVoices = 0;
        const e = re(uc.getDefaults(), arguments, ["voice", "options"]);
        Qe(!po(e.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
        const n = e.voice.getDefaults();
        this.options = Object.assign(n, e.options), this.voice = e.voice, this.maxPolyphony = e.maxPolyphony, this._dummyVoice = this._getNextAvailableVoice();
        const r = this._voices.indexOf(this._dummyVoice);
        this._voices.splice(r, 1), this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1)
    }
    static getDefaults() {
        return Object.assign(xi.getDefaults(), {
            maxPolyphony: 32,
            options: {},
            voice: Pi
        })
    }
    get activeVoices() {
        return this._activeVoices.length
    }
    _makeVoiceAvailable(e) {
        this._availableVoices.push(e);
        const n = this._activeVoices.findIndex(r => r.voice === e);
        this._activeVoices.splice(n, 1)
    }
    _getNextAvailableVoice() {
        if (this._availableVoices.length) return this._availableVoices.shift();
        if (this._voices.length < this.maxPolyphony) {
            const e = new this.voice(Object.assign(this.options, {
                context: this.context,
                onsilence: this._makeVoiceAvailable.bind(this)
            }));
            return e.connect(this.output), this._voices.push(e), e
        } else pb("Max polyphony exceeded. Note dropped.")
    }
    _collectGarbage() {
        if (this._averageActiveVoices = Math.max(this._averageActiveVoices * .95, this.activeVoices), this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
            const e = this._availableVoices.shift(),
                n = this._voices.indexOf(e);
            this._voices.splice(n, 1), this.context.isOffline || e.dispose()
        }
    }
    _triggerAttack(e, n, r) {
        e.forEach(s => {
            const i = new U1(this.context, s).toMidi(),
                o = this._getNextAvailableVoice();
            o && (o.triggerAttack(s, n, r), this._activeVoices.push({
                midi: i,
                voice: o,
                released: !1
            }), this.log("triggerAttack", s, n))
        })
    }
    _triggerRelease(e, n) {
        e.forEach(r => {
            const s = new U1(this.context, r).toMidi(),
                i = this._activeVoices.find(({
                    midi: o,
                    released: a
                }) => o === s && !a);
            i && (i.voice.triggerRelease(n), i.released = !0, this.log("triggerRelease", r, n))
        })
    }
    _scheduleEvent(e, n, r, s) {
        Qe(!this.disposed, "Synth was already disposed"), r <= this.now() ? e === "attack" ? this._triggerAttack(n, r, s) : this._triggerRelease(n, r) : this.context.setTimeout(() => {
            this._scheduleEvent(e, n, r, s)
        }, r - this.now())
    }
    triggerAttack(e, n, r) {
        Array.isArray(e) || (e = [e]);
        const s = this.toSeconds(n);
        return this._scheduleEvent("attack", e, s, r), this
    }
    triggerRelease(e, n) {
        Array.isArray(e) || (e = [e]);
        const r = this.toSeconds(n);
        return this._scheduleEvent("release", e, r), this
    }
    triggerAttackRelease(e, n, r, s) {
        const i = this.toSeconds(r);
        if (this.triggerAttack(e, i, s), is(n)) {
            Qe(is(e), "If the duration is an array, the notes must also be an array"), e = e;
            for (let o = 0; o < e.length; o++) {
                const a = n[Math.min(o, n.length - 1)],
                    l = this.toSeconds(a);
                Qe(l > 0, "The duration must be greater than 0"), this.triggerRelease(e[o], i + l)
            }
        } else {
            const o = this.toSeconds(n);
            Qe(o > 0, "The duration must be greater than 0"), this.triggerRelease(e, i + o)
        }
        return this
    }
    sync() {
        return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
    }
    set(e) {
        const n = hr(e, ["onsilence", "context"]);
        return this.options = Is(this.options, n), this._voices.forEach(r => r.set(n)), this._dummyVoice.set(n), this
    }
    get() {
        return this._dummyVoice.get()
    }
    releaseAll(e) {
        const n = this.toSeconds(e);
        return this._activeVoices.forEach(({
            voice: r
        }) => {
            r.triggerRelease(n)
        }), this
    }
    dispose() {
        return super.dispose(), this._dummyVoice.dispose(), this._voices.forEach(e => e.dispose()), this._activeVoices = [], this._availableVoices = [], this.context.clearInterval(this._gcTimeout), this
    }
}
class au extends xi {
    constructor() {
        super(re(au.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "Sampler", this._activeSources = new Map;
        const e = re(au.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls"),
            n = {};
        Object.keys(e.urls).forEach(r => {
            const s = parseInt(r, 10);
            if (Qe(Ip(r) || po(s) && isFinite(s), `url key is neither a note or midi pitch: ${r}`), Ip(r)) {
                const i = new er(this.context, r).toMidi();
                n[i] = e.urls[r]
            } else po(s) && isFinite(s) && (n[s] = e.urls[s])
        }), this._buffers = new od({
            urls: n,
            onload: e.onload,
            baseUrl: e.baseUrl,
            onerror: e.onerror
        }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this._buffers.loaded && Promise.resolve().then(e.onload)
    }
    static getDefaults() {
        return Object.assign(xi.getDefaults(), {
            attack: 0,
            baseUrl: "",
            curve: "exponential",
            onload: yt,
            onerror: yt,
            release: .1,
            urls: {}
        })
    }
    _findClosest(e) {
        let r = 0;
        for (; r < 96;) {
            if (this._buffers.has(e + r)) return -r;
            if (this._buffers.has(e - r)) return r;
            r++
        }
        throw new Error(`No available buffers for note: ${e}`)
    }
    triggerAttack(e, n, r = 1) {
        return this.log("triggerAttack", e, n, r), Array.isArray(e) || (e = [e]), e.forEach(s => {
            const i = Ig(new er(this.context, s).toFrequency()),
                o = Math.round(i),
                a = i - o,
                l = this._findClosest(o),
                u = o - l,
                f = this._buffers.get(u),
                d = Cc(l + a),
                p = new Ni({
                    url: f,
                    context: this.context,
                    curve: this.curve,
                    fadeIn: this.attack,
                    fadeOut: this.release,
                    playbackRate: d
                }).connect(this.output);
            p.start(n, 0, f.duration / d, r), is(this._activeSources.get(o)) || this._activeSources.set(o, []), this._activeSources.get(o).push(p), p.onended = () => {
                if (this._activeSources && this._activeSources.has(o)) {
                    const _ = this._activeSources.get(o),
                        v = _.indexOf(p);
                    v !== -1 && _.splice(v, 1)
                }
            }
        }), this
    }
    triggerRelease(e, n) {
        return this.log("triggerRelease", e, n), Array.isArray(e) || (e = [e]), e.forEach(r => {
            const s = new er(this.context, r).toMidi();
            if (this._activeSources.has(s) && this._activeSources.get(s).length) {
                const i = this._activeSources.get(s);
                n = this.toSeconds(n), i.forEach(o => {
                    o.stop(n)
                }), this._activeSources.set(s, [])
            }
        }), this
    }
    releaseAll(e) {
        const n = this.toSeconds(e);
        return this._activeSources.forEach(r => {
            for (; r.length;) r.shift().stop(n)
        }), this
    }
    sync() {
        return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
    }
    triggerAttackRelease(e, n, r, s = 1) {
        const i = this.toSeconds(r);
        return this.triggerAttack(e, i, s), is(n) ? (Qe(is(e), "notes must be an array when duration is array"), e.forEach((o, a) => {
            const l = n[Math.min(a, n.length - 1)];
            this.triggerRelease(o, i + this.toSeconds(l))
        })) : this.triggerRelease(e, i + this.toSeconds(n)), this
    }
    add(e, n, r) {
        if (Qe(Ip(e) || isFinite(e), `note must be a pitch or midi: ${e}`), Ip(e)) {
            const s = new er(this.context, e).toMidi();
            this._buffers.add(s, n, r)
        } else this._buffers.add(e, n, r);
        return this
    }
    get loaded() {
        return this._buffers.loaded
    }
    dispose() {
        return super.dispose(), this._buffers.dispose(), this._activeSources.forEach(e => {
            e.forEach(n => n.dispose())
        }), this._activeSources.clear(), this
    }
}
oi([So(0)], au.prototype, "attack", void 0);
oi([So(0)], au.prototype, "release", void 0);
class cu extends Ne {
    constructor() {
        super(Object.assign(re(cu.getDefaults(), arguments, ["fade"]))), this.name = "CrossFade", this._panner = this.context.createStereoPanner(), this._split = this.context.createChannelSplitter(2), this._g2a = new GTe({
            context: this.context
        }), this.a = new Ye({
            context: this.context,
            gain: 0
        }), this.b = new Ye({
            context: this.context,
            gain: 0
        }), this.output = new Ye({
            context: this.context
        }), this._internalChannels = [this.a, this.b];
        const e = re(cu.getDefaults(), arguments, ["fade"]);
        this.fade = new Je({
            context: this.context,
            units: "normalRange",
            value: e.fade
        }), ze(this, "fade"), this.context.getConstant(1).connect(this._panner), this._panner.connect(this._split), this._panner.channelCount = 1, this._panner.channelCountMode = "explicit", xs(this._split, this.a.gain, 0), xs(this._split, this.b.gain, 1), this.fade.chain(this._g2a, this._panner.pan), this.a.connect(this.output), this.b.connect(this.output)
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            fade: .5
        })
    }
    dispose() {
        return super.dispose(), this.a.dispose(), this.b.dispose(), this.output.dispose(), this.fade.dispose(), this._g2a.dispose(), this._panner.disconnect(), this._split.disconnect(), this
    }
}
class Bn extends Ne {
    constructor(e) {
        super(e), this.name = "Effect", this._dryWet = new cu({
            context: this.context
        }), this.wet = this._dryWet.fade, this.effectSend = new Ye({
            context: this.context
        }), this.effectReturn = new Ye({
            context: this.context
        }), this.input = new Ye({
            context: this.context
        }), this.output = this._dryWet, this.input.fan(this._dryWet.a, this.effectSend), this.effectReturn.connect(this._dryWet.b), this.wet.setValueAtTime(e.wet, 0), this._internalChannels = [this.effectReturn, this.effectSend], ze(this, "wet")
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            wet: 1
        })
    }
    connectEffect(e) {
        return this._internalChannels.push(e), this.effectSend.chain(e, this.effectReturn), this
    }
    dispose() {
        return super.dispose(), this._dryWet.dispose(), this.effectSend.dispose(), this.effectReturn.dispose(), this.wet.dispose(), this
    }
}
class Y1 extends Bn {
    constructor(e) {
        super(e), this.name = "LFOEffect", this._lfo = new Sr({
            context: this.context,
            frequency: e.frequency,
            amplitude: e.depth
        }), this.depth = this._lfo.amplitude, this.frequency = this._lfo.frequency, this.type = e.type, ze(this, ["frequency", "depth"])
    }
    static getDefaults() {
        return Object.assign(Bn.getDefaults(), {
            frequency: 1,
            type: "sine",
            depth: 1
        })
    }
    start(e) {
        return this._lfo.start(e), this
    }
    stop(e) {
        return this._lfo.stop(e), this
    }
    sync() {
        return this._lfo.sync(), this
    }
    unsync() {
        return this._lfo.unsync(), this
    }
    get type() {
        return this._lfo.type
    }
    set type(e) {
        this._lfo.type = e
    }
    dispose() {
        return super.dispose(), this._lfo.dispose(), this.frequency.dispose(), this.depth.dispose(), this
    }
}
class bf extends Y1 {
    constructor() {
        super(re(bf.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"])), this.name = "AutoFilter";
        const e = re(bf.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"]);
        this.filter = new Dr(Object.assign(e.filter, {
            context: this.context
        })), this.connectEffect(this.filter), this._lfo.connect(this.filter.frequency), this.octaves = e.octaves, this.baseFrequency = e.baseFrequency
    }
    static getDefaults() {
        return Object.assign(Y1.getDefaults(), {
            baseFrequency: 200,
            octaves: 2.6,
            filter: {
                type: "lowpass",
                rolloff: -12,
                Q: 1
            }
        })
    }
    get baseFrequency() {
        return this._lfo.min
    }
    set baseFrequency(e) {
        this._lfo.min = this.toFrequency(e), this.octaves = this._octaves
    }
    get octaves() {
        return this._octaves
    }
    set octaves(e) {
        this._octaves = e, this._lfo.max = this._lfo.min * Math.pow(2, e)
    }
    dispose() {
        return super.dispose(), this.filter.dispose(), this
    }
}
class lu extends Ne {
    constructor() {
        super(Object.assign(re(lu.getDefaults(), arguments, ["pan"]))), this.name = "Panner", this._panner = this.context.createStereoPanner(), this.input = this._panner, this.output = this._panner;
        const e = re(lu.getDefaults(), arguments, ["pan"]);
        this.pan = new pt({
            context: this.context,
            param: this._panner.pan,
            value: e.pan,
            minValue: -1,
            maxValue: 1
        }), this._panner.channelCount = e.channelCount, this._panner.channelCountMode = "explicit", ze(this, "pan")
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            pan: 0,
            channelCount: 1
        })
    }
    dispose() {
        return super.dispose(), this._panner.disconnect(), this.pan.dispose(), this
    }
}
class Ef extends Y1 {
    constructor() {
        super(re(Ef.getDefaults(), arguments, ["frequency"])), this.name = "AutoPanner";
        const e = re(Ef.getDefaults(), arguments, ["frequency"]);
        this._panner = new lu({
            context: this.context,
            channelCount: e.channelCount
        }), this.connectEffect(this._panner), this._lfo.connect(this._panner.pan), this._lfo.min = -1, this._lfo.max = 1
    }
    static getDefaults() {
        return Object.assign(Y1.getDefaults(), {
            channelCount: 1
        })
    }
    dispose() {
        return super.dispose(), this._panner.dispose(), this
    }
}
class Tf extends Ne {
    constructor() {
        super(re(Tf.getDefaults(), arguments, ["smoothing"])), this.name = "Follower";
        const e = re(Tf.getDefaults(), arguments, ["smoothing"]);
        this._abs = this.input = new qTe({
            context: this.context
        }), this._lowpass = this.output = new yf({
            context: this.context,
            frequency: 1 / this.toSeconds(e.smoothing),
            type: "lowpass"
        }), this._abs.connect(this._lowpass), this._smoothing = e.smoothing
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            smoothing: .05
        })
    }
    get smoothing() {
        return this._smoothing
    }
    set smoothing(e) {
        this._smoothing = e, this._lowpass.frequency = 1 / this.toSeconds(this.smoothing)
    }
    dispose() {
        return super.dispose(), this._abs.dispose(), this._lowpass.dispose(), this
    }
}
class z1 extends Bn {
    constructor() {
        super(re(z1.getDefaults(), arguments, ["baseFrequency", "octaves", "sensitivity"])), this.name = "AutoWah";
        const e = re(z1.getDefaults(), arguments, ["baseFrequency", "octaves", "sensitivity"]);
        this._follower = new Tf({
            context: this.context,
            smoothing: e.follower
        }), this._sweepRange = new G1({
            context: this.context,
            min: 0,
            max: 1,
            exponent: .5
        }), this._baseFrequency = this.toFrequency(e.baseFrequency), this._octaves = e.octaves, this._inputBoost = new Ye({
            context: this.context
        }), this._bandpass = new Dr({
            context: this.context,
            rolloff: -48,
            frequency: 0,
            Q: e.Q
        }), this._peaking = new Dr({
            context: this.context,
            type: "peaking"
        }), this._peaking.gain.value = e.gain, this.gain = this._peaking.gain, this.Q = this._bandpass.Q, this.effectSend.chain(this._inputBoost, this._follower, this._sweepRange), this._sweepRange.connect(this._bandpass.frequency), this._sweepRange.connect(this._peaking.frequency), this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn), this._setSweepRange(), this.sensitivity = e.sensitivity, ze(this, ["gain", "Q"])
    }
    static getDefaults() {
        return Object.assign(Bn.getDefaults(), {
            baseFrequency: 100,
            octaves: 6,
            sensitivity: 0,
            Q: 2,
            gain: 2,
            follower: .2
        })
    }
    get octaves() {
        return this._octaves
    }
    set octaves(e) {
        this._octaves = e, this._setSweepRange()
    }
    get follower() {
        return this._follower.smoothing
    }
    set follower(e) {
        this._follower.smoothing = e
    }
    get baseFrequency() {
        return this._baseFrequency
    }
    set baseFrequency(e) {
        this._baseFrequency = this.toFrequency(e), this._setSweepRange()
    }
    get sensitivity() {
        return gb(1 / this._inputBoost.gain.value)
    }
    set sensitivity(e) {
        this._inputBoost.gain.value = 1 / M1(e)
    }
    _setSweepRange() {
        this._sweepRange.min = this._baseFrequency, this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2)
    }
    dispose() {
        return super.dispose(), this._follower.dispose(), this._sweepRange.dispose(), this._bandpass.dispose(), this._peaking.dispose(), this._inputBoost.dispose(), this
    }
}
const $k = "bit-crusher",
    zTe = `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;
Mk($k, zTe);
class K1 extends Bn {
    constructor() {
        super(re(K1.getDefaults(), arguments, ["bits"])), this.name = "BitCrusher";
        const e = re(K1.getDefaults(), arguments, ["bits"]);
        this._bitCrusherWorklet = new Z1({
            context: this.context,
            bits: e.bits
        }), this.connectEffect(this._bitCrusherWorklet), this.bits = this._bitCrusherWorklet.bits
    }
    static getDefaults() {
        return Object.assign(Bn.getDefaults(), {
            bits: 4
        })
    }
    dispose() {
        return super.dispose(), this._bitCrusherWorklet.dispose(), this
    }
}
class Z1 extends Iv {
    constructor() {
        super(re(Z1.getDefaults(), arguments)), this.name = "BitCrusherWorklet";
        const e = re(Z1.getDefaults(), arguments);
        this.input = new Ye({
            context: this.context
        }), this.output = new Ye({
            context: this.context
        }), this.bits = new pt({
            context: this.context,
            value: e.bits,
            units: "positive",
            minValue: 1,
            maxValue: 16,
            param: this._dummyParam,
            swappable: !0
        })
    }
    static getDefaults() {
        return Object.assign(Iv.getDefaults(), {
            bits: 12
        })
    }
    _audioWorkletName() {
        return $k
    }
    onReady(e) {
        Ns(this.input, e, this.output);
        const n = e.parameters.get("bits");
        this.bits.setParam(n)
    }
    dispose() {
        return super.dispose(), this.input.dispose(), this.output.dispose(), this.bits.dispose(), this
    }
}
class X1 extends Bn {
    constructor() {
        super(re(X1.getDefaults(), arguments, ["order"])), this.name = "Chebyshev";
        const e = re(X1.getDefaults(), arguments, ["order"]);
        this._shaper = new Js({
            context: this.context,
            length: 4096
        }), this._order = e.order, this.connectEffect(this._shaper), this.order = e.order, this.oversample = e.oversample
    }
    static getDefaults() {
        return Object.assign(Bn.getDefaults(), {
            order: 1,
            oversample: "none"
        })
    }
    _getCoefficient(e, n, r) {
        return r.has(n) || (n === 0 ? r.set(n, 0) : n === 1 ? r.set(n, e) : r.set(n, 2 * e * this._getCoefficient(e, n - 1, r) - this._getCoefficient(e, n - 2, r))), r.get(n)
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e, this._shaper.setMap(n => this._getCoefficient(n, e, new Map))
    }
    get oversample() {
        return this._shaper.oversample
    }
    set oversample(e) {
        this._shaper.oversample = e
    }
    dispose() {
        return super.dispose(), this._shaper.dispose(), this
    }
}
class uu extends Ne {
    constructor() {
        super(re(uu.getDefaults(), arguments, ["channels"])), this.name = "Split";
        const e = re(uu.getDefaults(), arguments, ["channels"]);
        this._splitter = this.input = this.output = this.context.createChannelSplitter(e.channels), this._internalChannels = [this._splitter]
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            channels: 2
        })
    }
    dispose() {
        return super.dispose(), this._splitter.disconnect(), this
    }
}
class Ic extends Ne {
    constructor() {
        super(re(Ic.getDefaults(), arguments, ["channels"])), this.name = "Merge";
        const e = re(Ic.getDefaults(), arguments, ["channels"]);
        this._merger = this.output = this.input = this.context.createChannelMerger(e.channels)
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            channels: 2
        })
    }
    dispose() {
        return super.dispose(), this._merger.disconnect(), this
    }
}
class Ri extends Ne {
    constructor(e) {
        super(e), this.name = "StereoEffect", this.input = new Ye({
            context: this.context
        }), this.input.channelCount = 2, this.input.channelCountMode = "explicit", this._dryWet = this.output = new cu({
            context: this.context,
            fade: e.wet
        }), this.wet = this._dryWet.fade, this._split = new uu({
            context: this.context,
            channels: 2
        }), this._merge = new Ic({
            context: this.context,
            channels: 2
        }), this.input.connect(this._split), this.input.connect(this._dryWet.a), this._merge.connect(this._dryWet.b), ze(this, ["wet"])
    }
    connectEffectLeft(...e) {
        this._split.connect(e[0], 0, 0), Ns(...e), xs(e[e.length - 1], this._merge, 0, 0)
    }
    connectEffectRight(...e) {
        this._split.connect(e[0], 1, 0), Ns(...e), xs(e[e.length - 1], this._merge, 0, 1)
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            wet: 1
        })
    }
    dispose() {
        return super.dispose(), this._dryWet.dispose(), this._split.dispose(), this._merge.dispose(), this
    }
}
class Nv extends Ri {
    constructor(e) {
        super(e), this.feedback = new Je({
            context: this.context,
            value: e.feedback,
            units: "normalRange"
        }), this._feedbackL = new Ye({
            context: this.context
        }), this._feedbackR = new Ye({
            context: this.context
        }), this._feedbackSplit = new uu({
            context: this.context,
            channels: 2
        }), this._feedbackMerge = new Ic({
            context: this.context,
            channels: 2
        }), this._merge.connect(this._feedbackSplit), this._feedbackMerge.connect(this._split), this._feedbackSplit.connect(this._feedbackL, 0, 0), this._feedbackL.connect(this._feedbackMerge, 0, 0), this._feedbackSplit.connect(this._feedbackR, 1, 0), this._feedbackR.connect(this._feedbackMerge, 0, 1), this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain), ze(this, ["feedback"])
    }
    static getDefaults() {
        return Object.assign(Ri.getDefaults(), {
            feedback: .5
        })
    }
    dispose() {
        return super.dispose(), this.feedback.dispose(), this._feedbackL.dispose(), this._feedbackR.dispose(), this._feedbackSplit.dispose(), this._feedbackMerge.dispose(), this
    }
}
class Q1 extends Nv {
    constructor() {
        super(re(Q1.getDefaults(), arguments, ["frequency", "delayTime", "depth"])), this.name = "Chorus";
        const e = re(Q1.getDefaults(), arguments, ["frequency", "delayTime", "depth"]);
        this._depth = e.depth, this._delayTime = e.delayTime / 1e3, this._lfoL = new Sr({
            context: this.context,
            frequency: e.frequency,
            min: 0,
            max: 1
        }), this._lfoR = new Sr({
            context: this.context,
            frequency: e.frequency,
            min: 0,
            max: 1,
            phase: 180
        }), this._delayNodeL = new os({
            context: this.context
        }), this._delayNodeR = new os({
            context: this.context
        }), this.frequency = this._lfoL.frequency, ze(this, ["frequency"]), this._lfoL.frequency.connect(this._lfoR.frequency), this.connectEffectLeft(this._delayNodeL), this.connectEffectRight(this._delayNodeR), this._lfoL.connect(this._delayNodeL.delayTime), this._lfoR.connect(this._delayNodeR.delayTime), this.depth = this._depth, this.type = e.type, this.spread = e.spread
    }
    static getDefaults() {
        return Object.assign(Nv.getDefaults(), {
            frequency: 1.5,
            delayTime: 3.5,
            depth: .7,
            type: "sine",
            spread: 180,
            feedback: 0,
            wet: .5
        })
    }
    get depth() {
        return this._depth
    }
    set depth(e) {
        this._depth = e;
        const n = this._delayTime * e;
        this._lfoL.min = Math.max(this._delayTime - n, 0), this._lfoL.max = this._delayTime + n, this._lfoR.min = Math.max(this._delayTime - n, 0), this._lfoR.max = this._delayTime + n
    }
    get delayTime() {
        return this._delayTime * 1e3
    }
    set delayTime(e) {
        this._delayTime = e / 1e3, this.depth = this._depth
    }
    get type() {
        return this._lfoL.type
    }
    set type(e) {
        this._lfoL.type = e, this._lfoR.type = e
    }
    get spread() {
        return this._lfoR.phase - this._lfoL.phase
    }
    set spread(e) {
        this._lfoL.phase = 90 - e / 2, this._lfoR.phase = e / 2 + 90
    }
    start(e) {
        return this._lfoL.start(e), this._lfoR.start(e), this
    }
    stop(e) {
        return this._lfoL.stop(e), this._lfoR.stop(e), this
    }
    sync() {
        return this._lfoL.sync(), this._lfoR.sync(), this
    }
    unsync() {
        return this._lfoL.unsync(), this._lfoR.unsync(), this
    }
    dispose() {
        return super.dispose(), this._lfoL.dispose(), this._lfoR.dispose(), this._delayNodeL.dispose(), this._delayNodeR.dispose(), this.frequency.dispose(), this
    }
}
class J1 extends Bn {
    constructor() {
        super(re(J1.getDefaults(), arguments, ["distortion"])), this.name = "Distortion";
        const e = re(J1.getDefaults(), arguments, ["distortion"]);
        this._shaper = new Js({
            context: this.context,
            length: 4096
        }), this._distortion = e.distortion, this.connectEffect(this._shaper), this.distortion = e.distortion, this.oversample = e.oversample
    }
    static getDefaults() {
        return Object.assign(Bn.getDefaults(), {
            distortion: .4,
            oversample: "none"
        })
    }
    get distortion() {
        return this._distortion
    }
    set distortion(e) {
        this._distortion = e;
        const n = e * 100,
            r = Math.PI / 180;
        this._shaper.setMap(s => Math.abs(s) < .001 ? 0 : (3 + n) * s * 20 * r / (Math.PI + n * Math.abs(s)))
    }
    get oversample() {
        return this._shaper.oversample
    }
    set oversample(e) {
        this._shaper.oversample = e
    }
    dispose() {
        return super.dispose(), this._shaper.dispose(), this
    }
}
class em extends Bn {
    constructor(e) {
        super(e), this.name = "FeedbackEffect", this._feedbackGain = new Ye({
            context: this.context,
            gain: e.feedback,
            units: "normalRange"
        }), this.feedback = this._feedbackGain.gain, ze(this, "feedback"), this.effectReturn.chain(this._feedbackGain, this.effectSend)
    }
    static getDefaults() {
        return Object.assign(Bn.getDefaults(), {
            feedback: .125
        })
    }
    dispose() {
        return super.dispose(), this._feedbackGain.dispose(), this.feedback.dispose(), this
    }
}
class tm extends em {
    constructor() {
        super(re(tm.getDefaults(), arguments, ["delayTime", "feedback"])), this.name = "FeedbackDelay";
        const e = re(tm.getDefaults(), arguments, ["delayTime", "feedback"]);
        this._delayNode = new os({
            context: this.context,
            delayTime: e.delayTime,
            maxDelay: e.maxDelay
        }), this.delayTime = this._delayNode.delayTime, this.connectEffect(this._delayNode), ze(this, "delayTime")
    }
    static getDefaults() {
        return Object.assign(em.getDefaults(), {
            delayTime: .25,
            maxDelay: 1
        })
    }
    dispose() {
        return super.dispose(), this._delayNode.dispose(), this.delayTime.dispose(), this
    }
}
class KTe extends Ne {
    constructor(e) {
        super(e), this.name = "PhaseShiftAllpass", this.input = new Ye({
            context: this.context
        }), this.output = new Ye({
            context: this.context
        }), this.offset90 = new Ye({
            context: this.context
        });
        const n = [.6923878, .9360654322959, .988229522686, .9987488452737],
            r = [.4021921162426, .856171088242, .9722909545651, .9952884791278];
        this._bank0 = this._createAllPassFilterBank(n), this._bank1 = this._createAllPassFilterBank(r), this._oneSampleDelay = this.context.createIIRFilter([0, 1], [1, 0]), Ns(this.input, ...this._bank0, this._oneSampleDelay, this.output), Ns(this.input, ...this._bank1, this.offset90)
    }
    _createAllPassFilterBank(e) {
        return e.map(r => {
            const s = [
                [r * r, 0, -1],
                [1, 0, -(r * r)]
            ];
            return this.context.createIIRFilter(s[0], s[1])
        })
    }
    dispose() {
        return super.dispose(), this.input.dispose(), this.output.dispose(), this.offset90.dispose(), this._bank0.forEach(e => e.disconnect()), this._bank1.forEach(e => e.disconnect()), this._oneSampleDelay.disconnect(), this
    }
}
class nm extends Bn {
    constructor() {
        super(re(nm.getDefaults(), arguments, ["frequency"])), this.name = "FrequencyShifter";
        const e = re(nm.getDefaults(), arguments, ["frequency"]);
        this.frequency = new Je({
            context: this.context,
            units: "frequency",
            value: e.frequency,
            minValue: -this.context.sampleRate / 2,
            maxValue: this.context.sampleRate / 2
        }), this._sine = new cf({
            context: this.context,
            type: "sine"
        }), this._cosine = new un({
            context: this.context,
            phase: -90,
            type: "sine"
        }), this._sineMultiply = new fn({
            context: this.context
        }), this._cosineMultiply = new fn({
            context: this.context
        }), this._negate = new Rk({
            context: this.context
        }), this._add = new Uu({
            context: this.context
        }), this._phaseShifter = new KTe({
            context: this.context
        }), this.effectSend.connect(this._phaseShifter), this.frequency.fan(this._sine.frequency, this._cosine.frequency), this._phaseShifter.offset90.connect(this._cosineMultiply), this._cosine.connect(this._cosineMultiply.factor), this._phaseShifter.connect(this._sineMultiply), this._sine.connect(this._sineMultiply.factor), this._sineMultiply.connect(this._negate), this._cosineMultiply.connect(this._add), this._negate.connect(this._add.addend), this._add.connect(this.effectReturn);
        const n = this.immediate();
        this._sine.start(n), this._cosine.start(n)
    }
    static getDefaults() {
        return Object.assign(Bn.getDefaults(), {
            frequency: 0
        })
    }
    dispose() {
        return super.dispose(), this.frequency.dispose(), this._add.dispose(), this._cosine.dispose(), this._cosineMultiply.dispose(), this._negate.dispose(), this._phaseShifter.dispose(), this._sine.dispose(), this._sineMultiply.dispose(), this
    }
}
const Ww = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100],
    Hw = [225, 556, 441, 341];
class rm extends Ri {
    constructor() {
        super(re(rm.getDefaults(), arguments, ["roomSize", "dampening"])), this.name = "Freeverb", this._combFilters = [], this._allpassFiltersL = [], this._allpassFiltersR = [];
        const e = re(rm.getDefaults(), arguments, ["roomSize", "dampening"]);
        this.roomSize = new Je({
            context: this.context,
            value: e.roomSize,
            units: "normalRange"
        }), this._allpassFiltersL = Hw.map(n => {
            const r = this.context.createBiquadFilter();
            return r.type = "allpass", r.frequency.value = n, r
        }), this._allpassFiltersR = Hw.map(n => {
            const r = this.context.createBiquadFilter();
            return r.type = "allpass", r.frequency.value = n, r
        }), this._combFilters = Ww.map((n, r) => {
            const s = new vf({
                context: this.context,
                dampening: e.dampening,
                delayTime: n
            });
            return r < Ww.length / 2 ? this.connectEffectLeft(s, ...this._allpassFiltersL) : this.connectEffectRight(s, ...this._allpassFiltersR), this.roomSize.connect(s.resonance), s
        }), ze(this, ["roomSize"])
    }
    static getDefaults() {
        return Object.assign(Ri.getDefaults(), {
            roomSize: .7,
            dampening: 3e3
        })
    }
    get dampening() {
        return this._combFilters[0].dampening
    }
    set dampening(e) {
        this._combFilters.forEach(n => n.dampening = e)
    }
    dispose() {
        return super.dispose(), this._allpassFiltersL.forEach(e => e.disconnect()), this._allpassFiltersR.forEach(e => e.disconnect()), this._combFilters.forEach(e => e.dispose()), this.roomSize.dispose(), this
    }
}
const Yw = [1687 / 25e3, 1601 / 25e3, 2053 / 25e3, 2251 / 25e3],
    ZTe = [.773, .802, .753, .733],
    XTe = [347, 113, 37];
class sm extends Ri {
    constructor() {
        super(re(sm.getDefaults(), arguments, ["roomSize"])), this.name = "JCReverb", this._allpassFilters = [], this._feedbackCombFilters = [];
        const e = re(sm.getDefaults(), arguments, ["roomSize"]);
        this.roomSize = new Je({
            context: this.context,
            value: e.roomSize,
            units: "normalRange"
        }), this._scaleRoomSize = new mo({
            context: this.context,
            min: -.733,
            max: .197
        }), this._allpassFilters = XTe.map(n => {
            const r = this.context.createBiquadFilter();
            return r.type = "allpass", r.frequency.value = n, r
        }), this._feedbackCombFilters = Yw.map((n, r) => {
            const s = new _f({
                context: this.context,
                delayTime: n
            });
            return this._scaleRoomSize.connect(s.resonance), s.resonance.value = ZTe[r], r < Yw.length / 2 ? this.connectEffectLeft(...this._allpassFilters, s) : this.connectEffectRight(...this._allpassFilters, s), s
        }), this.roomSize.connect(this._scaleRoomSize), ze(this, ["roomSize"])
    }
    static getDefaults() {
        return Object.assign(Ri.getDefaults(), {
            roomSize: .5
        })
    }
    dispose() {
        return super.dispose(), this._allpassFilters.forEach(e => e.disconnect()), this._feedbackCombFilters.forEach(e => e.dispose()), this.roomSize.dispose(), this._scaleRoomSize.dispose(), this
    }
}
class zw extends Nv {
    constructor(e) {
        super(e), this._feedbackL.disconnect(), this._feedbackL.connect(this._feedbackMerge, 0, 1), this._feedbackR.disconnect(), this._feedbackR.connect(this._feedbackMerge, 0, 0), ze(this, ["feedback"])
    }
}
class im extends zw {
    constructor() {
        super(re(im.getDefaults(), arguments, ["delayTime", "feedback"])), this.name = "PingPongDelay";
        const e = re(im.getDefaults(), arguments, ["delayTime", "feedback"]);
        this._leftDelay = new os({
            context: this.context,
            maxDelay: e.maxDelay
        }), this._rightDelay = new os({
            context: this.context,
            maxDelay: e.maxDelay
        }), this._rightPreDelay = new os({
            context: this.context,
            maxDelay: e.maxDelay
        }), this.delayTime = new Je({
            context: this.context,
            units: "time",
            value: e.delayTime
        }), this.connectEffectLeft(this._leftDelay), this.connectEffectRight(this._rightPreDelay, this._rightDelay), this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime), this._feedbackL.disconnect(), this._feedbackL.connect(this._rightDelay), ze(this, ["delayTime"])
    }
    static getDefaults() {
        return Object.assign(zw.getDefaults(), {
            delayTime: .25,
            maxDelay: 1
        })
    }
    dispose() {
        return super.dispose(), this._leftDelay.dispose(), this._rightDelay.dispose(), this._rightPreDelay.dispose(), this.delayTime.dispose(), this
    }
}
class om extends em {
    constructor() {
        super(re(om.getDefaults(), arguments, ["pitch"])), this.name = "PitchShift";
        const e = re(om.getDefaults(), arguments, ["pitch"]);
        this._frequency = new Je({
            context: this.context
        }), this._delayA = new os({
            maxDelay: 1,
            context: this.context
        }), this._lfoA = new Sr({
            context: this.context,
            min: 0,
            max: .1,
            type: "sawtooth"
        }).connect(this._delayA.delayTime), this._delayB = new os({
            maxDelay: 1,
            context: this.context
        }), this._lfoB = new Sr({
            context: this.context,
            min: 0,
            max: .1,
            type: "sawtooth",
            phase: 180
        }).connect(this._delayB.delayTime), this._crossFade = new cu({
            context: this.context
        }), this._crossFadeLFO = new Sr({
            context: this.context,
            min: 0,
            max: 1,
            type: "triangle",
            phase: 90
        }).connect(this._crossFade.fade), this._feedbackDelay = new os({
            delayTime: e.delayTime,
            context: this.context
        }), this.delayTime = this._feedbackDelay.delayTime, ze(this, "delayTime"), this._pitch = e.pitch, this._windowSize = e.windowSize, this._delayA.connect(this._crossFade.a), this._delayB.connect(this._crossFade.b), this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency), this.effectSend.fan(this._delayA, this._delayB), this._crossFade.chain(this._feedbackDelay, this.effectReturn);
        const n = this.now();
        this._lfoA.start(n), this._lfoB.start(n), this._crossFadeLFO.start(n), this.windowSize = this._windowSize
    }
    static getDefaults() {
        return Object.assign(em.getDefaults(), {
            pitch: 0,
            windowSize: .1,
            delayTime: 0,
            feedback: 0
        })
    }
    get pitch() {
        return this._pitch
    }
    set pitch(e) {
        this._pitch = e;
        let n = 0;
        e < 0 ? (this._lfoA.min = 0, this._lfoA.max = this._windowSize, this._lfoB.min = 0, this._lfoB.max = this._windowSize, n = Cc(e - 1) + 1) : (this._lfoA.min = this._windowSize, this._lfoA.max = 0, this._lfoB.min = this._windowSize, this._lfoB.max = 0, n = Cc(e) - 1), this._frequency.value = n * (1.2 / this._windowSize)
    }
    get windowSize() {
        return this._windowSize
    }
    set windowSize(e) {
        this._windowSize = this.toSeconds(e), this.pitch = this._pitch
    }
    dispose() {
        return super.dispose(), this._frequency.dispose(), this._delayA.dispose(), this._delayB.dispose(), this._lfoA.dispose(), this._lfoB.dispose(), this._crossFade.dispose(), this._crossFadeLFO.dispose(), this._feedbackDelay.dispose(), this
    }
}
class am extends Ri {
    constructor() {
        super(re(am.getDefaults(), arguments, ["frequency", "octaves", "baseFrequency"])), this.name = "Phaser";
        const e = re(am.getDefaults(), arguments, ["frequency", "octaves", "baseFrequency"]);
        this._lfoL = new Sr({
            context: this.context,
            frequency: e.frequency,
            min: 0,
            max: 1
        }), this._lfoR = new Sr({
            context: this.context,
            frequency: e.frequency,
            min: 0,
            max: 1,
            phase: 180
        }), this._baseFrequency = this.toFrequency(e.baseFrequency), this._octaves = e.octaves, this.Q = new Je({
            context: this.context,
            value: e.Q,
            units: "positive"
        }), this._filtersL = this._makeFilters(e.stages, this._lfoL), this._filtersR = this._makeFilters(e.stages, this._lfoR), this.frequency = this._lfoL.frequency, this.frequency.value = e.frequency, this.connectEffectLeft(...this._filtersL), this.connectEffectRight(...this._filtersR), this._lfoL.frequency.connect(this._lfoR.frequency), this.baseFrequency = e.baseFrequency, this.octaves = e.octaves, this._lfoL.start(), this._lfoR.start(), ze(this, ["frequency", "Q"])
    }
    static getDefaults() {
        return Object.assign(Ri.getDefaults(), {
            frequency: .5,
            octaves: 3,
            stages: 10,
            Q: 10,
            baseFrequency: 350
        })
    }
    _makeFilters(e, n) {
        const r = [];
        for (let s = 0; s < e; s++) {
            const i = this.context.createBiquadFilter();
            i.type = "allpass", this.Q.connect(i.Q), n.connect(i.frequency), r.push(i)
        }
        return r
    }
    get octaves() {
        return this._octaves
    }
    set octaves(e) {
        this._octaves = e;
        const n = this._baseFrequency * Math.pow(2, e);
        this._lfoL.max = n, this._lfoR.max = n
    }
    get baseFrequency() {
        return this._baseFrequency
    }
    set baseFrequency(e) {
        this._baseFrequency = this.toFrequency(e), this._lfoL.min = this._baseFrequency, this._lfoR.min = this._baseFrequency, this.octaves = this._octaves
    }
    dispose() {
        return super.dispose(), this.Q.dispose(), this._lfoL.dispose(), this._lfoR.dispose(), this._filtersL.forEach(e => e.disconnect()), this._filtersR.forEach(e => e.disconnect()), this.frequency.dispose(), this
    }
}
class cm extends Bn {
    constructor() {
        super(re(cm.getDefaults(), arguments, ["decay"])), this.name = "Reverb", this._convolver = this.context.createConvolver(), this.ready = Promise.resolve();
        const e = re(cm.getDefaults(), arguments, ["decay"]);
        this._decay = e.decay, this._preDelay = e.preDelay, this.generate(), this.connectEffect(this._convolver)
    }
    static getDefaults() {
        return Object.assign(Bn.getDefaults(), {
            decay: 1.5,
            preDelay: .01
        })
    }
    get decay() {
        return this._decay
    }
    set decay(e) {
        e = this.toSeconds(e), Qs(e, .001), this._decay = e, this.generate()
    }
    get preDelay() {
        return this._preDelay
    }
    set preDelay(e) {
        e = this.toSeconds(e), Qs(e, 0), this._preDelay = e, this.generate()
    }
    generate() {
        return kn(this, void 0, void 0, function*() {
            const e = this.ready,
                n = new Cg(2, this._decay + this._preDelay, this.context.sampleRate),
                r = new ma({
                    context: n
                }),
                s = new ma({
                    context: n
                }),
                i = new Ic({
                    context: n
                });
            r.connect(i, 0, 0), s.connect(i, 0, 1);
            const o = new Ye({
                context: n
            }).toDestination();
            i.connect(o), r.start(0), s.start(0), o.gain.setValueAtTime(0, 0), o.gain.setValueAtTime(1, this._preDelay), o.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);
            const a = n.render();
            return this.ready = a.then(yt), yield e, this._convolver.buffer = (yield a).get(), this
        })
    }
    dispose() {
        return super.dispose(), this._convolver.disconnect(), this
    }
}
class Ab extends Ne {
    constructor() {
        super(re(Ab.getDefaults(), arguments)), this.name = "MidSideSplit", this._split = this.input = new uu({
            channels: 2,
            context: this.context
        }), this._midAdd = new Uu({
            context: this.context
        }), this.mid = new fn({
            context: this.context,
            value: Math.SQRT1_2
        }), this._sideSubtract = new Bu({
            context: this.context
        }), this.side = new fn({
            context: this.context,
            value: Math.SQRT1_2
        }), this._split.connect(this._midAdd, 0), this._split.connect(this._midAdd.addend, 1), this._split.connect(this._sideSubtract, 0), this._split.connect(this._sideSubtract.subtrahend, 1), this._midAdd.connect(this.mid), this._sideSubtract.connect(this.side)
    }
    dispose() {
        return super.dispose(), this.mid.dispose(), this.side.dispose(), this._midAdd.dispose(), this._sideSubtract.dispose(), this._split.dispose(), this
    }
}
class Ob extends Ne {
    constructor() {
        super(re(Ob.getDefaults(), arguments)), this.name = "MidSideMerge", this.mid = new Ye({
            context: this.context
        }), this.side = new Ye({
            context: this.context
        }), this._left = new Uu({
            context: this.context
        }), this._leftMult = new fn({
            context: this.context,
            value: Math.SQRT1_2
        }), this._right = new Bu({
            context: this.context
        }), this._rightMult = new fn({
            context: this.context,
            value: Math.SQRT1_2
        }), this._merge = this.output = new Ic({
            context: this.context
        }), this.mid.fan(this._left), this.side.connect(this._left.addend), this.mid.connect(this._right), this.side.connect(this._right.subtrahend), this._left.connect(this._leftMult), this._right.connect(this._rightMult), this._leftMult.connect(this._merge, 0, 0), this._rightMult.connect(this._merge, 0, 1)
    }
    dispose() {
        return super.dispose(), this.mid.dispose(), this.side.dispose(), this._leftMult.dispose(), this._rightMult.dispose(), this._left.dispose(), this._right.dispose(), this
    }
}
class Kw extends Bn {
    constructor(e) {
        super(e), this.name = "MidSideEffect", this._midSideMerge = new Ob({
            context: this.context
        }), this._midSideSplit = new Ab({
            context: this.context
        }), this._midSend = this._midSideSplit.mid, this._sideSend = this._midSideSplit.side, this._midReturn = this._midSideMerge.mid, this._sideReturn = this._midSideMerge.side, this.effectSend.connect(this._midSideSplit), this._midSideMerge.connect(this.effectReturn)
    }
    connectEffectMid(...e) {
        this._midSend.chain(...e, this._midReturn)
    }
    connectEffectSide(...e) {
        this._sideSend.chain(...e, this._sideReturn)
    }
    dispose() {
        return super.dispose(), this._midSideSplit.dispose(), this._midSideMerge.dispose(), this._midSend.dispose(), this._sideSend.dispose(), this._midReturn.dispose(), this._sideReturn.dispose(), this
    }
}
class lm extends Kw {
    constructor() {
        super(re(lm.getDefaults(), arguments, ["width"])), this.name = "StereoWidener";
        const e = re(lm.getDefaults(), arguments, ["width"]);
        this.width = new Je({
            context: this.context,
            value: e.width,
            units: "normalRange"
        }), ze(this, ["width"]), this._twoTimesWidthMid = new fn({
            context: this.context,
            value: 2
        }), this._twoTimesWidthSide = new fn({
            context: this.context,
            value: 2
        }), this._midMult = new fn({
            context: this.context
        }), this._twoTimesWidthMid.connect(this._midMult.factor), this.connectEffectMid(this._midMult), this._oneMinusWidth = new Bu({
            context: this.context
        }), this._oneMinusWidth.connect(this._twoTimesWidthMid), xs(this.context.getConstant(1), this._oneMinusWidth), this.width.connect(this._oneMinusWidth.subtrahend), this._sideMult = new fn({
            context: this.context
        }), this.width.connect(this._twoTimesWidthSide), this._twoTimesWidthSide.connect(this._sideMult.factor), this.connectEffectSide(this._sideMult)
    }
    static getDefaults() {
        return Object.assign(Kw.getDefaults(), {
            width: .5
        })
    }
    dispose() {
        return super.dispose(), this.width.dispose(), this._midMult.dispose(), this._sideMult.dispose(), this._twoTimesWidthMid.dispose(), this._twoTimesWidthSide.dispose(), this._oneMinusWidth.dispose(), this
    }
}
class Sf extends Ri {
    constructor() {
        super(re(Sf.getDefaults(), arguments, ["frequency", "depth"])), this.name = "Tremolo";
        const e = re(Sf.getDefaults(), arguments, ["frequency", "depth"]);
        this._lfoL = new Sr({
            context: this.context,
            type: e.type,
            min: 1,
            max: 0
        }), this._lfoR = new Sr({
            context: this.context,
            type: e.type,
            min: 1,
            max: 0
        }), this._amplitudeL = new Ye({
            context: this.context
        }), this._amplitudeR = new Ye({
            context: this.context
        }), this.frequency = new Je({
            context: this.context,
            value: e.frequency,
            units: "frequency"
        }), this.depth = new Je({
            context: this.context,
            value: e.depth,
            units: "normalRange"
        }), ze(this, ["frequency", "depth"]), this.connectEffectLeft(this._amplitudeL), this.connectEffectRight(this._amplitudeR), this._lfoL.connect(this._amplitudeL.gain), this._lfoR.connect(this._amplitudeR.gain), this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency), this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude), this.spread = e.spread
    }
    static getDefaults() {
        return Object.assign(Ri.getDefaults(), {
            frequency: 10,
            type: "sine",
            depth: .5,
            spread: 180
        })
    }
    start(e) {
        return this._lfoL.start(e), this._lfoR.start(e), this
    }
    stop(e) {
        return this._lfoL.stop(e), this._lfoR.stop(e), this
    }
    sync() {
        return this._lfoL.sync(), this._lfoR.sync(), this.context.transport.syncSignal(this.frequency), this
    }
    unsync() {
        return this._lfoL.unsync(), this._lfoR.unsync(), this.context.transport.unsyncSignal(this.frequency), this
    }
    get type() {
        return this._lfoL.type
    }
    set type(e) {
        this._lfoL.type = e, this._lfoR.type = e
    }
    get spread() {
        return this._lfoR.phase - this._lfoL.phase
    }
    set spread(e) {
        this._lfoL.phase = 90 - e / 2, this._lfoR.phase = e / 2 + 90
    }
    dispose() {
        return super.dispose(), this._lfoL.dispose(), this._lfoR.dispose(), this._amplitudeL.dispose(), this._amplitudeR.dispose(), this.frequency.dispose(), this.depth.dispose(), this
    }
}
class um extends Bn {
    constructor() {
        super(re(um.getDefaults(), arguments, ["frequency", "depth"])), this.name = "Vibrato";
        const e = re(um.getDefaults(), arguments, ["frequency", "depth"]);
        this._delayNode = new os({
            context: this.context,
            delayTime: 0,
            maxDelay: e.maxDelay
        }), this._lfo = new Sr({
            context: this.context,
            type: e.type,
            min: 0,
            max: e.maxDelay,
            frequency: e.frequency,
            phase: -90
        }).start().connect(this._delayNode.delayTime), this.frequency = this._lfo.frequency, this.depth = this._lfo.amplitude, this.depth.value = e.depth, ze(this, ["frequency", "depth"]), this.effectSend.chain(this._delayNode, this.effectReturn)
    }
    static getDefaults() {
        return Object.assign(Bn.getDefaults(), {
            maxDelay: .005,
            frequency: 5,
            depth: .1,
            type: "sine"
        })
    }
    get type() {
        return this._lfo.type
    }
    set type(e) {
        this._lfo.type = e
    }
    dispose() {
        return super.dispose(), this._delayNode.dispose(), this._lfo.dispose(), this.frequency.dispose(), this.depth.dispose(), this
    }
}
class An extends Ne {
    constructor() {
        super(re(An.getDefaults(), arguments, ["solo"])), this.name = "Solo";
        const e = re(An.getDefaults(), arguments, ["solo"]);
        this.input = this.output = new Ye({
            context: this.context
        }), An._allSolos.has(this.context) || An._allSolos.set(this.context, new Set), An._allSolos.get(this.context).add(this), this.solo = e.solo
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            solo: !1
        })
    }
    get solo() {
        return this._isSoloed()
    }
    set solo(e) {
        e ? this._addSolo() : this._removeSolo(), An._allSolos.get(this.context).forEach(n => n._updateSolo())
    }
    get muted() {
        return this.input.gain.value === 0
    }
    _addSolo() {
        An._soloed.has(this.context) || An._soloed.set(this.context, new Set), An._soloed.get(this.context).add(this)
    }
    _removeSolo() {
        An._soloed.has(this.context) && An._soloed.get(this.context).delete(this)
    }
    _isSoloed() {
        return An._soloed.has(this.context) && An._soloed.get(this.context).has(this)
    }
    _noSolos() {
        return !An._soloed.has(this.context) || An._soloed.has(this.context) && An._soloed.get(this.context).size === 0
    }
    _updateSolo() {
        this._isSoloed() ? this.input.gain.value = 1 : this._noSolos() ? this.input.gain.value = 1 : this.input.gain.value = 0
    }
    dispose() {
        return super.dispose(), An._allSolos.get(this.context).delete(this), this._removeSolo(), this
    }
}
An._allSolos = new Map;
An._soloed = new Map;
class hu extends Ne {
    constructor() {
        super(re(hu.getDefaults(), arguments, ["pan", "volume"])), this.name = "PanVol";
        const e = re(hu.getDefaults(), arguments, ["pan", "volume"]);
        this._panner = this.input = new lu({
            context: this.context,
            pan: e.pan,
            channelCount: e.channelCount
        }), this.pan = this._panner.pan, this._volume = this.output = new Ii({
            context: this.context,
            volume: e.volume
        }), this.volume = this._volume.volume, this._panner.connect(this._volume), this.mute = e.mute, ze(this, ["pan", "volume"])
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            mute: !1,
            pan: 0,
            volume: 0,
            channelCount: 1
        })
    }
    get mute() {
        return this._volume.mute
    }
    set mute(e) {
        this._volume.mute = e
    }
    dispose() {
        return super.dispose(), this._panner.dispose(), this.pan.dispose(), this._volume.dispose(), this.volume.dispose(), this
    }
}
class ac extends Ne {
    constructor() {
        super(re(ac.getDefaults(), arguments, ["volume", "pan"])), this.name = "Channel";
        const e = re(ac.getDefaults(), arguments, ["volume", "pan"]);
        this._solo = this.input = new An({
            solo: e.solo,
            context: this.context
        }), this._panVol = this.output = new hu({
            context: this.context,
            pan: e.pan,
            volume: e.volume,
            mute: e.mute,
            channelCount: e.channelCount
        }), this.pan = this._panVol.pan, this.volume = this._panVol.volume, this._solo.connect(this._panVol), ze(this, ["pan", "volume"])
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            pan: 0,
            volume: 0,
            mute: !1,
            solo: !1,
            channelCount: 1
        })
    }
    get solo() {
        return this._solo.solo
    }
    set solo(e) {
        this._solo.solo = e
    }
    get muted() {
        return this._solo.muted || this.mute
    }
    get mute() {
        return this._panVol.mute
    }
    set mute(e) {
        this._panVol.mute = e
    }
    _getBus(e) {
        return ac.buses.has(e) || ac.buses.set(e, new Ye({
            context: this.context
        })), ac.buses.get(e)
    }
    send(e, n = 0) {
        const r = this._getBus(e),
            s = new Ye({
                context: this.context,
                units: "decibels",
                gain: n
            });
        return this.connect(s), s.connect(r), s
    }
    receive(e) {
        return this._getBus(e).connect(this), this
    }
    dispose() {
        return super.dispose(), this._panVol.dispose(), this.pan.dispose(), this.volume.dispose(), this._solo.dispose(), this
    }
}
ac.buses = new Map;
class wf extends Ne {
    constructor() {
        super(re(wf.getDefaults(), arguments, ["lowFrequency", "highFrequency"])), this.name = "MultibandSplit", this.input = new Ye({
            context: this.context
        }), this.output = void 0, this.low = new Dr({
            context: this.context,
            frequency: 0,
            type: "lowpass"
        }), this._lowMidFilter = new Dr({
            context: this.context,
            frequency: 0,
            type: "highpass"
        }), this.mid = new Dr({
            context: this.context,
            frequency: 0,
            type: "lowpass"
        }), this.high = new Dr({
            context: this.context,
            frequency: 0,
            type: "highpass"
        }), this._internalChannels = [this.low, this.mid, this.high];
        const e = re(wf.getDefaults(), arguments, ["lowFrequency", "highFrequency"]);
        this.lowFrequency = new Je({
            context: this.context,
            units: "frequency",
            value: e.lowFrequency
        }), this.highFrequency = new Je({
            context: this.context,
            units: "frequency",
            value: e.highFrequency
        }), this.Q = new Je({
            context: this.context,
            units: "positive",
            value: e.Q
        }), this.input.fan(this.low, this.high), this.input.chain(this._lowMidFilter, this.mid), this.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency), this.highFrequency.fan(this.mid.frequency, this.high.frequency), this.Q.connect(this.low.Q), this.Q.connect(this._lowMidFilter.Q), this.Q.connect(this.mid.Q), this.Q.connect(this.high.Q), ze(this, ["high", "mid", "low", "highFrequency", "lowFrequency"])
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            Q: 1,
            highFrequency: 2500,
            lowFrequency: 400
        })
    }
    dispose() {
        return super.dispose(), id(this, ["high", "mid", "low", "highFrequency", "lowFrequency"]), this.low.dispose(), this._lowMidFilter.dispose(), this.mid.dispose(), this.high.dispose(), this.lowFrequency.dispose(), this.highFrequency.dispose(), this.Q.dispose(), this
    }
}
class QTe extends Ne {
    constructor() {
        super(...arguments), this.name = "Listener", this.positionX = new pt({
            context: this.context,
            param: this.context.rawContext.listener.positionX
        }), this.positionY = new pt({
            context: this.context,
            param: this.context.rawContext.listener.positionY
        }), this.positionZ = new pt({
            context: this.context,
            param: this.context.rawContext.listener.positionZ
        }), this.forwardX = new pt({
            context: this.context,
            param: this.context.rawContext.listener.forwardX
        }), this.forwardY = new pt({
            context: this.context,
            param: this.context.rawContext.listener.forwardY
        }), this.forwardZ = new pt({
            context: this.context,
            param: this.context.rawContext.listener.forwardZ
        }), this.upX = new pt({
            context: this.context,
            param: this.context.rawContext.listener.upX
        }), this.upY = new pt({
            context: this.context,
            param: this.context.rawContext.listener.upY
        }), this.upZ = new pt({
            context: this.context,
            param: this.context.rawContext.listener.upZ
        })
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            positionX: 0,
            positionY: 0,
            positionZ: 0,
            forwardX: 0,
            forwardY: 0,
            forwardZ: -1,
            upX: 0,
            upY: 1,
            upZ: 0
        })
    }
    dispose() {
        return super.dispose(), this.positionX.dispose(), this.positionY.dispose(), this.positionZ.dispose(), this.forwardX.dispose(), this.forwardY.dispose(), this.forwardZ.dispose(), this.upX.dispose(), this.upY.dispose(), this.upZ.dispose(), this
    }
}
Ag(t => {
    t.listener = new QTe({
        context: t
    })
});
Og(t => {
    t.listener.dispose()
});
class ia extends Ne {
    constructor() {
        super(re(ia.getDefaults(), arguments, ["threshold", "ratio"])), this.name = "Compressor", this._compressor = this.context.createDynamicsCompressor(), this.input = this._compressor, this.output = this._compressor;
        const e = re(ia.getDefaults(), arguments, ["threshold", "ratio"]);
        this.threshold = new pt({
            minValue: this._compressor.threshold.minValue,
            maxValue: this._compressor.threshold.maxValue,
            context: this.context,
            convert: !1,
            param: this._compressor.threshold,
            units: "decibels",
            value: e.threshold
        }), this.attack = new pt({
            minValue: this._compressor.attack.minValue,
            maxValue: this._compressor.attack.maxValue,
            context: this.context,
            param: this._compressor.attack,
            units: "time",
            value: e.attack
        }), this.release = new pt({
            minValue: this._compressor.release.minValue,
            maxValue: this._compressor.release.maxValue,
            context: this.context,
            param: this._compressor.release,
            units: "time",
            value: e.release
        }), this.knee = new pt({
            minValue: this._compressor.knee.minValue,
            maxValue: this._compressor.knee.maxValue,
            context: this.context,
            convert: !1,
            param: this._compressor.knee,
            units: "decibels",
            value: e.knee
        }), this.ratio = new pt({
            minValue: this._compressor.ratio.minValue,
            maxValue: this._compressor.ratio.maxValue,
            context: this.context,
            convert: !1,
            param: this._compressor.ratio,
            units: "positive",
            value: e.ratio
        }), ze(this, ["knee", "release", "attack", "ratio", "threshold"])
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            attack: .003,
            knee: 30,
            ratio: 12,
            release: .25,
            threshold: -24
        })
    }
    get reduction() {
        return this._compressor.reduction
    }
    dispose() {
        return super.dispose(), this._compressor.disconnect(), this.attack.dispose(), this.release.dispose(), this.threshold.dispose(), this.ratio.dispose(), this.knee.dispose(), this
    }
}
class hm extends Ne {
    constructor() {
        super(Object.assign(re(hm.getDefaults(), arguments, ["threshold", "smoothing"]))), this.name = "Gate";
        const e = re(hm.getDefaults(), arguments, ["threshold", "smoothing"]);
        this._follower = new Tf({
            context: this.context,
            smoothing: e.smoothing
        }), this._gt = new q1({
            context: this.context,
            value: M1(e.threshold)
        }), this.input = new Ye({
            context: this.context
        }), this._gate = this.output = new Ye({
            context: this.context
        }), this.input.connect(this._gate), this.input.chain(this._follower, this._gt, this._gate.gain)
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            smoothing: .1,
            threshold: -40
        })
    }
    get threshold() {
        return gb(this._gt.value)
    }
    set threshold(e) {
        this._gt.value = M1(e)
    }
    get smoothing() {
        return this._follower.smoothing
    }
    set smoothing(e) {
        this._follower.smoothing = e
    }
    dispose() {
        return super.dispose(), this.input.dispose(), this._follower.dispose(), this._gt.dispose(), this._gate.dispose(), this
    }
}
class fm extends Ne {
    constructor() {
        super(Object.assign(re(fm.getDefaults(), arguments, ["threshold"]))), this.name = "Limiter";
        const e = re(fm.getDefaults(), arguments, ["threshold"]);
        this._compressor = this.input = this.output = new ia({
            context: this.context,
            ratio: 20,
            attack: .003,
            release: .01,
            threshold: e.threshold
        }), this.threshold = this._compressor.threshold, ze(this, "threshold")
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            threshold: -12
        })
    }
    get reduction() {
        return this._compressor.reduction
    }
    dispose() {
        return super.dispose(), this._compressor.dispose(), this.threshold.dispose(), this
    }
}
class dm extends Ne {
    constructor() {
        super(Object.assign(re(dm.getDefaults(), arguments))), this.name = "MultibandCompressor";
        const e = re(dm.getDefaults(), arguments);
        this._splitter = this.input = new wf({
            context: this.context,
            lowFrequency: e.lowFrequency,
            highFrequency: e.highFrequency
        }), this.lowFrequency = this._splitter.lowFrequency, this.highFrequency = this._splitter.highFrequency, this.output = new Ye({
            context: this.context
        }), this.low = new ia(Object.assign(e.low, {
            context: this.context
        })), this.mid = new ia(Object.assign(e.mid, {
            context: this.context
        })), this.high = new ia(Object.assign(e.high, {
            context: this.context
        })), this._splitter.low.chain(this.low, this.output), this._splitter.mid.chain(this.mid, this.output), this._splitter.high.chain(this.high, this.output), ze(this, ["high", "mid", "low", "highFrequency", "lowFrequency"])
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            lowFrequency: 250,
            highFrequency: 2e3,
            low: {
                ratio: 6,
                threshold: -30,
                release: .25,
                attack: .03,
                knee: 10
            },
            mid: {
                ratio: 3,
                threshold: -24,
                release: .03,
                attack: .02,
                knee: 16
            },
            high: {
                ratio: 3,
                threshold: -24,
                release: .03,
                attack: .02,
                knee: 16
            }
        })
    }
    dispose() {
        return super.dispose(), this._splitter.dispose(), this.low.dispose(), this.mid.dispose(), this.high.dispose(), this.output.dispose(), this
    }
}
class pm extends Ne {
    constructor() {
        super(re(pm.getDefaults(), arguments, ["low", "mid", "high"])), this.name = "EQ3", this.output = new Ye({
            context: this.context
        }), this._internalChannels = [];
        const e = re(pm.getDefaults(), arguments, ["low", "mid", "high"]);
        this.input = this._multibandSplit = new wf({
            context: this.context,
            highFrequency: e.highFrequency,
            lowFrequency: e.lowFrequency
        }), this._lowGain = new Ye({
            context: this.context,
            gain: e.low,
            units: "decibels"
        }), this._midGain = new Ye({
            context: this.context,
            gain: e.mid,
            units: "decibels"
        }), this._highGain = new Ye({
            context: this.context,
            gain: e.high,
            units: "decibels"
        }), this.low = this._lowGain.gain, this.mid = this._midGain.gain, this.high = this._highGain.gain, this.Q = this._multibandSplit.Q, this.lowFrequency = this._multibandSplit.lowFrequency, this.highFrequency = this._multibandSplit.highFrequency, this._multibandSplit.low.chain(this._lowGain, this.output), this._multibandSplit.mid.chain(this._midGain, this.output), this._multibandSplit.high.chain(this._highGain, this.output), ze(this, ["low", "mid", "high", "lowFrequency", "highFrequency"]), this._internalChannels = [this._multibandSplit]
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            high: 0,
            highFrequency: 2500,
            low: 0,
            lowFrequency: 400,
            mid: 0
        })
    }
    dispose() {
        return super.dispose(), id(this, ["low", "mid", "high", "lowFrequency", "highFrequency"]), this._multibandSplit.dispose(), this.lowFrequency.dispose(), this.highFrequency.dispose(), this._lowGain.dispose(), this._midGain.dispose(), this._highGain.dispose(), this.low.dispose(), this.mid.dispose(), this.high.dispose(), this.Q.dispose(), this
    }
}
ws().transport;
ws().destination;
ws().destination;
ws().listener;
ws().draw;
ws();

function Cb() {
    return Pt.loaded()
}
class JTe {
    constructor(e) {
        this.isPlayable = !0, this.node = new xg(e)
    }
    attack(e) {
        e.length && this.node.triggerAttack(e[0])
    }
    oneShot(e, n = .25) {
        e.length && this.node.triggerAttackRelease(e[0], n)
    }
    update(e) {
        e.length && (this.node.frequency.value = e[0])
    }
    release(e) {
        this.node.triggerRelease()
    }
}
class eSe {
    constructor(e) {
        this.isPlayable = !1;
        const n = new Ps(e.frequency || 440, e.type || "sine"),
            r = new bf(e).start();
        n.connect(r), this.node = r
    }
}
class tSe {
    constructor(e) {
        this.isPlayable = !1;
        const n = new Ps(e.frequency || 440, e.type || "sine"),
            r = new Ef(e).start();
        n.connect(r), this.node = r
    }
}
class ei extends Ne {
    constructor() {
        super(re(ei.getDefaults(), arguments)), this._scheduledEvents = [], this._synced = !1, this._original_triggerAttack = this.triggerAttack, this._original_triggerRelease = this.triggerRelease;
        const e = re(ei.getDefaults(), arguments);
        this._volume = new Ii({
            context: this.context,
            volume: e.volume
        }), this.output = this._volume, this.volume = this._volume.volume, ze(this, "volume")
    }
    static getDefaults() {
        return Object.assign(Ne.getDefaults(), {
            volume: 0
        })
    }
    sync() {
        return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 0)), this
    }
    _syncState() {
        let e = !1;
        return this._synced || (this._synced = !0, e = !0), e
    }
    _syncMethod(e, n) {
        const r = this[e];
        this[`_original_${e}`] = this[e], this[e] = (...s) => {
            const i = s[n],
                o = this.context.transport.schedule(a => {
                    s[n] = a, r.apply(this, s)
                }, i);
            this._scheduledEvents.push(o)
        }
    }
    unsync() {
        return this._scheduledEvents.forEach(e => this.context.transport.clear(e)), this._scheduledEvents = [], this._synced && (this._synced = !1, this.triggerAttack = this._original_triggerAttack, this.triggerRelease = this._original_triggerRelease), this
    }
    triggerAttackRelease(e, n, r, s) {
        const i = this.toSeconds(r),
            o = this.toSeconds(n);
        return this.triggerAttack(e, i, s), this.triggerRelease(i + o), this
    }
    dispose() {
        return super.dispose(), this._volume.dispose(), this.unsync(), this._scheduledEvents = [], this
    }
}
var mm = (t, e) => Array(Math.abs(e) + 1).join(t);

function Lk(t, e, n) {
    return function(...r) {
        return console.warn(`${t} is deprecated. Use ${e}.`), n.apply(this, r)
    }
}

function Fk(t) {
    return t !== null && typeof t == "object" && typeof t.name == "string"
}

function Uk(t) {
    return t !== null && typeof t == "object" && typeof t.step == "number" && typeof t.alt == "number"
}
var Bk = [0, 2, 4, -1, 1, 3, 5],
    qk = Bk.map(t => Math.floor(t * 7 / 12));

function Gk(t) {
    const {
        step: e,
        alt: n,
        oct: r,
        dir: s = 1
    } = t, i = Bk[e] + 7 * n;
    if (r === void 0) return [s * i];
    const o = r - qk[e] - 4 * n;
    return [s * i, s * o]
}
var nSe = [3, 0, 4, 1, 5, 2, 6];

function Vk(t) {
    const [e, n, r] = t, s = nSe[rSe(e)], i = Math.floor((e + 1) / 7);
    if (n === void 0) return {
        step: s,
        alt: i,
        dir: r
    };
    const o = n + 4 * i + qk[s];
    return {
        step: s,
        alt: i,
        oct: o,
        dir: r
    }
}

function rSe(t) {
    const e = (t + 1) % 7;
    return e < 0 ? 7 + e : e
}
var jk = {
        empty: !0,
        name: "",
        pc: "",
        acc: ""
    },
    Zw = new Map,
    sSe = t => "CDEFGAB".charAt(t),
    iSe = t => t < 0 ? mm("b", -t) : mm("#", t),
    oSe = t => t[0] === "b" ? -t.length : t.length;

function zt(t) {
    const e = JSON.stringify(t),
        n = Zw.get(e);
    if (n) return n;
    const r = typeof t == "string" ? uSe(t) : Uk(t) ? zt(hSe(t)) : Fk(t) ? zt(t.name) : jk;
    return Zw.set(e, r), r
}
var aSe = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;

function Wk(t) {
    const e = aSe.exec(t);
    return [e[1].toUpperCase(), e[2].replace(/x/g, "##"), e[3], e[4]]
}

function cSe(t) {
    return zt(Vk(t))
}
var lSe = (t, e) => (t % e + e) % e,
    Xy = [0, 2, 4, 5, 7, 9, 11];

function uSe(t) {
    const e = Wk(t);
    if (e[0] === "" || e[3] !== "") return jk;
    const n = e[0],
        r = e[1],
        s = e[2],
        i = (n.charCodeAt(0) + 3) % 7,
        o = oSe(r),
        a = s.length ? +s : void 0,
        l = Gk({
            step: i,
            alt: o,
            oct: a
        }),
        u = n + r + s,
        f = n + r,
        d = (Xy[i] + o + 120) % 12,
        p = a === void 0 ? lSe(Xy[i] + o, 12) - 12 * 99 : Xy[i] + o + 12 * (a + 1),
        _ = p >= 0 && p <= 127 ? p : null,
        v = a === void 0 ? null : Math.pow(2, (p - 69) / 12) * 440;
    return {
        empty: !1,
        acc: r,
        alt: o,
        chroma: d,
        coord: l,
        freq: v,
        height: p,
        letter: n,
        midi: _,
        name: u,
        oct: a,
        pc: f,
        step: i
    }
}

function hSe(t) {
    const {
        step: e,
        alt: n,
        oct: r
    } = t, s = sSe(e);
    if (!s) return "";
    const i = s + iSe(n);
    return r || r === 0 ? i + r : i
}
var xv = {
        empty: !0,
        name: "",
        acc: ""
    },
    fSe = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})",
    dSe = "(AA|A|P|M|m|d|dd)([-+]?\\d+)",
    pSe = new RegExp("^" + fSe + "|" + dSe + "$");

function mSe(t) {
    const e = pSe.exec(`${t}`);
    return e === null ? ["", ""] : e[1] ? [e[1], e[2]] : [e[4], e[3]]
}
var Xw = {};

function Af(t) {
    return typeof t == "string" ? Xw[t] || (Xw[t] = gSe(t)) : Uk(t) ? Af(vSe(t)) : Fk(t) ? Af(t.name) : xv
}
var Qw = [0, 2, 4, 5, 7, 9, 11],
    Hk = "PMMPPMM";

function gSe(t) {
    const e = mSe(t);
    if (e[0] === "") return xv;
    const n = +e[0],
        r = e[1],
        s = (Math.abs(n) - 1) % 7,
        i = Hk[s];
    if (i === "M" && r === "P") return xv;
    const o = i === "M" ? "majorable" : "perfectable",
        a = "" + n + r,
        l = n < 0 ? -1 : 1,
        u = n === 8 || n === -8 ? n : l * (s + 1),
        f = ySe(o, r),
        d = Math.floor((Math.abs(n) - 1) / 7),
        p = l * (Qw[s] + f + 12 * d),
        _ = (l * (Qw[s] + f) % 12 + 12) % 12,
        v = Gk({
            step: s,
            alt: f,
            oct: d,
            dir: l
        });
    return {
        empty: !1,
        name: a,
        num: n,
        q: r,
        step: s,
        alt: f,
        dir: l,
        type: o,
        simple: u,
        semitones: p,
        chroma: _,
        coord: v,
        oct: d
    }
}

function _Se(t, e) {
    const [n, r = 0] = t, s = n * 7 + r * 12 < 0, i = e || s ? [-n, -r, -1] : [n, r, 1];
    return Af(Vk(i))
}

function ySe(t, e) {
    return e === "M" && t === "majorable" || e === "P" && t === "perfectable" ? 0 : e === "m" && t === "majorable" ? -1 : /^A+$/.test(e) ? e.length : /^d+$/.test(e) ? -1 * (t === "perfectable" ? e.length : e.length + 1) : 0
}

function vSe(t) {
    const {
        step: e,
        alt: n,
        oct: r = 0,
        dir: s
    } = t;
    if (!s) return "";
    const i = e + 1 + 7 * r,
        o = i === 0 ? e + 1 : i,
        a = s < 0 ? "-" : "",
        l = Hk[e] === "M" ? "majorable" : "perfectable";
    return a + o + bSe(l, n)
}

function bSe(t, e) {
    return e === 0 ? t === "majorable" ? "M" : "P" : e === -1 && t === "majorable" ? "m" : e > 0 ? mm("A", e) : mm("d", t === "perfectable" ? e : e + 1)
}

function ga(t, e) {
    const n = zt(t),
        r = Array.isArray(e) ? e : Af(e).coord;
    if (n.empty || !r || r.length < 2) return "";
    const s = n.coord,
        i = s.length === 1 ? [s[0] + r[0]] : [s[0] + r[0], s[1] + r[1]];
    return cSe(i).name
}

function Pg(t, e) {
    const n = t.length;
    return r => {
        if (!e) return "";
        const s = r < 0 ? (n - -r % n) % n : r % n,
            i = Math.floor(r / n),
            o = ga(e, [0, i]);
        return ga(o, t[s])
    }
}

function ESe(t, e) {
    const n = zt(t),
        r = zt(e);
    if (n.empty || r.empty) return "";
    const s = n.coord,
        i = r.coord,
        o = i[0] - s[0],
        a = s.length === 2 && i.length === 2 ? i[1] - s[1] : -Math.floor(o * 7 / 12),
        l = r.height === n.height && r.midi !== null && n.midi !== null && n.step > r.step;
    return _Se([o, a], l).name
}

function TSe(t, e) {
    const n = [];
    for (; e--; n[e] = e + t);
    return n
}

function SSe(t, e) {
    const n = [];
    for (; e--; n[e] = t - e);
    return n
}

function wSe(t, e) {
    return t < e ? TSe(t, e - t + 1) : SSe(t, t - e + 1)
}

function cd(t, e) {
    const n = e.length,
        r = (t % n + n) % n;
    return e.slice(r, n).concat(e.slice(0, r))
}

function ASe(t) {
    return t.filter(e => e === 0 || e)
}
var Nc = {
        empty: !0,
        name: "",
        setNum: 0,
        chroma: "000000000000",
        normalized: "000000000000",
        intervals: []
    },
    Yk = t => Number(t).toString(2),
    Jw = t => parseInt(t, 2),
    OSe = /^[01]{12}$/;

function kb(t) {
    return OSe.test(t)
}
var CSe = t => typeof t == "number" && t >= 0 && t <= 4095,
    kSe = t => t && kb(t.chroma),
    e8 = {
        [Nc.chroma]: Nc
    };

function _a(t) {
    const e = kb(t) ? t : CSe(t) ? Yk(t) : Array.isArray(t) ? MSe(t) : kSe(t) ? t.chroma : Nc.chroma;
    return e8[e] = e8[e] || RSe(e)
}
var ISe = t => _a(t).chroma,
    NSe = ["1P", "2m", "2M", "3m", "3M", "4P", "5d", "5P", "6m", "6M", "7m", "7M"];

function xSe(t) {
    const e = [];
    for (let n = 0; n < 12; n++) t.charAt(n) === "1" && e.push(NSe[n]);
    return e
}

function zk(t, e = !0) {
    const r = _a(t).chroma.split("");
    return ASe(r.map((s, i) => {
        const o = cd(i, r);
        return e && o[0] === "0" ? null : o.join("")
    }))
}

function Ib(t) {
    const e = _a(t).setNum;
    return n => {
        const r = _a(n).setNum;
        return e && e !== r && (r & e) === r
    }
}

function Nb(t) {
    const e = _a(t).setNum;
    return n => {
        const r = _a(n).setNum;
        return e && e !== r && (r | e) === r
    }
}

function PSe(t) {
    const e = t.split("");
    return e.map((n, r) => cd(r, e).join(""))
}

function RSe(t) {
    const e = Jw(t),
        n = PSe(t).map(Jw).filter(i => i >= 2048).sort()[0],
        r = Yk(n),
        s = xSe(t);
    return {
        empty: !1,
        name: "",
        setNum: e,
        chroma: t,
        normalized: r,
        intervals: s
    }
}

function MSe(t) {
    if (t.length === 0) return Nc.chroma;
    let e;
    const n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (let r = 0; r < t.length; r++) e = zt(t[r]), e.empty && (e = Af(t[r])), e.empty || (n[e.chroma] = 1);
    return n.join("")
}
var DSe = [
        ["1P 3M 5P", "major", "M ^  maj"],
        ["1P 3M 5P 7M", "major seventh", "maj7  ma7 M7 Maj7 ^7"],
        ["1P 3M 5P 7M 9M", "major ninth", "maj9 9 ^9"],
        ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
        ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
        ["1P 3M 5P 6M 9M", "sixth/ninth", "6/9 69 M69"],
        ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
        ["1P 3M 5P 7M 11A", "major seventh sharp eleventh", "maj#4 #4 #11 M7#11 ^7#11 maj7#11"],
        ["1P 3m 5P", "minor", "m min -"],
        ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
        ["1P 3m 5P 7M", "minor/major seventh", "m/ma7 m/maj7 mM7 mMaj7 m/M7 -7 m -^7"],
        ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
        ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
        ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
        ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
        ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
        ["1P 3m 5d", "diminished", "dim  o"],
        ["1P 3m 5d 7d", "diminished seventh", "dim7 7 o7"],
        ["1P 3m 5d 7m", "half-diminished", "m7b5  -7b5 h7 h"],
        ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
        ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
        ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
        ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
        ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
        ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
        ["1P 3M 7m 9m", "altered", "alt7"],
        ["1P 4P 5P", "suspended fourth", "sus4 sus"],
        ["1P 2M 5P", "suspended second", "sus2"],
        ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
        ["1P 5P 7m 9M 11P", "eleventh", "11"],
        ["1P 4P 5P 7m 9m", "suspended fourth flat ninth", "b9sus phryg 7b9sus 7b9sus4"],
        ["1P 5P", "fifth", "5"],
        ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
        ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
        ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
        ["1P 3M 5P 7M 9M 11A", "major sharp eleventh (lydian)", "maj9#11 9#11 ^9#11"],
        ["1P 2M 4P 5P", "", "sus24 sus4add9"],
        ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
        ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
        ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
        ["1P 3M 5A 7m 9M", "", "9#5 9+"],
        ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
        ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
        ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
        ["1P 3M 5A 9A", "", "+add#9"],
        ["1P 3M 5A 9M", "", "M#5add9 +add9"],
        ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
        ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
        ["1P 3M 5P 6M 9M 11A", "", "69#11"],
        ["1P 3m 5P 6M 9M", "", "m69 -69"],
        ["1P 3M 5P 6m 7m", "", "7b6"],
        ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
        ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
        ["1P 3M 5P 7M 9m", "", "M7b9"],
        ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
        ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
        ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
        ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
        ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
        ["1P 3M 5P 7m 9A 13M", "", "13#9"],
        ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
        ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
        ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
        ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
        ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
        ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
        ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
        ["1P 3M 5P 7m 9m 13M", "", "13b9"],
        ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
        ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
        ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
        ["1P 3M 5P 9m", "", "Maddb9"],
        ["1P 3M 5d", "", "Mb5"],
        ["1P 3M 5d 6M 7m 9M", "", "13b5"],
        ["1P 3M 5d 7M", "", "M7b5"],
        ["1P 3M 5d 7M 9M", "", "M9b5"],
        ["1P 3M 5d 7m", "", "7b5"],
        ["1P 3M 5d 7m 9M", "", "9b5"],
        ["1P 3M 7m", "", "7no5"],
        ["1P 3M 7m 13m", "", "7b13"],
        ["1P 3M 7m 9M", "", "9no5"],
        ["1P 3M 7m 9M 13M", "", "13no5"],
        ["1P 3M 7m 9M 13m", "", "9b13"],
        ["1P 3m 4P 5P", "", "madd4"],
        ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
        ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
        ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
        ["1P 3m 5P 9M", "", "madd9"],
        ["1P 3m 5d 6M 7M", "", "o7M7"],
        ["1P 3m 5d 7M", "", "oM7"],
        ["1P 3m 6m 7M", "", "mb6M7"],
        ["1P 3m 6m 7m", "", "m7#5"],
        ["1P 3m 6m 7m 9M", "", "m9#5"],
        ["1P 3m 5A 7m 9M 11P", "", "m11A"],
        ["1P 3m 6m 9m", "", "mb6b9"],
        ["1P 2M 3m 5d 7m", "", "m9b5"],
        ["1P 4P 5A 7M", "", "M7#5sus4"],
        ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
        ["1P 4P 5A 7m", "", "7#5sus4"],
        ["1P 4P 5P 7M", "", "M7sus4"],
        ["1P 4P 5P 7M 9M", "", "M9sus4"],
        ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
        ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
        ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
        ["1P 4P 7m 10m", "", "4 quartal"],
        ["1P 5P 7m 9m 11P", "", "11b9"]
    ],
    $Se = DSe,
    LSe = {
        ...Nc,
        name: "",
        quality: "Unknown",
        intervals: [],
        aliases: []
    },
    xb = [],
    Dh = {};

function FSe(t) {
    return Dh[t] || LSe
}

function Rg() {
    return xb.slice()
}

function USe(t, e, n) {
    const r = qSe(t),
        s = {
            ..._a(t),
            name: n || "",
            quality: r,
            intervals: t,
            aliases: e
        };
    xb.push(s), s.name && (Dh[s.name] = s), Dh[s.setNum] = s, Dh[s.chroma] = s, s.aliases.forEach(i => BSe(s, i))
}

function BSe(t, e) {
    Dh[e] = t
}

function qSe(t) {
    const e = n => t.indexOf(n) !== -1;
    return e("5A") ? "Augmented" : e("3M") ? "Major" : e("5d") ? "Diminished" : e("3m") ? "Minor" : "Unknown"
}
$Se.forEach(([t, e, n]) => USe(t.split(" "), n.split(" "), e));
xb.sort((t, e) => t.setNum - e.setNum);
var GSe = t => {
    const e = t.reduce((n, r) => {
        const s = zt(r).chroma;
        return s !== void 0 && (n[s] = n[s] || zt(r).name), n
    }, {});
    return n => e[n]
};

function VSe(t, e = {}) {
    const n = t.map(s => zt(s).pc).filter(s => s);
    return zt.length === 0 ? [] : ZSe(n, 1, e).filter(s => s.weight).sort((s, i) => i.weight - s.weight).map(s => s.name)
}
var Mg = {
        anyThirds: 384,
        perfectFifth: 16,
        nonPerfectFifths: 40,
        anySeventh: 3
    },
    Dg = t => e => !!(e & t),
    jSe = Dg(Mg.anyThirds),
    WSe = Dg(Mg.perfectFifth),
    HSe = Dg(Mg.anySeventh),
    YSe = Dg(Mg.nonPerfectFifths);

function zSe(t) {
    const e = parseInt(t.chroma, 2);
    return jSe(e) && WSe(e) && HSe(e)
}

function KSe(t) {
    const e = parseInt(t, 2);
    return YSe(e) ? t : (e | 16).toString(2)
}

function ZSe(t, e, n) {
    const r = t[0],
        s = zt(r).chroma,
        i = GSe(t),
        o = zk(t, !1),
        a = [];
    return o.forEach((l, u) => {
        const f = n.assumePerfectFifth && KSe(l);
        Rg().filter(p => n.assumePerfectFifth && zSe(p) ? p.chroma === f : p.chroma === l).forEach(p => {
            const _ = p.aliases[0],
                v = i(u);
            u !== s ? a.push({
                weight: .5 * e,
                name: `${v}${_}/${r}`
            }) : a.push({
                weight: 1 * e,
                name: `${v}${_}`
            })
        })
    }), a
}
var XSe = [
        ["1P 2M 3M 5P 6M", "major pentatonic", "pentatonic"],
        ["1P 2M 3M 4P 5P 6M 7M", "major", "ionian"],
        ["1P 2M 3m 4P 5P 6m 7m", "minor", "aeolian"],
        ["1P 2M 3m 3M 5P 6M", "major blues"],
        ["1P 3m 4P 5d 5P 7m", "minor blues", "blues"],
        ["1P 2M 3m 4P 5P 6M 7M", "melodic minor"],
        ["1P 2M 3m 4P 5P 6m 7M", "harmonic minor"],
        ["1P 2M 3M 4P 5P 6M 7m 7M", "bebop"],
        ["1P 2M 3m 4P 5d 6m 6M 7M", "diminished", "whole-half diminished"],
        ["1P 2M 3m 4P 5P 6M 7m", "dorian"],
        ["1P 2M 3M 4A 5P 6M 7M", "lydian"],
        ["1P 2M 3M 4P 5P 6M 7m", "mixolydian", "dominant"],
        ["1P 2m 3m 4P 5P 6m 7m", "phrygian"],
        ["1P 2m 3m 4P 5d 6m 7m", "locrian"],
        ["1P 3M 4P 5P 7M", "ionian pentatonic"],
        ["1P 3M 4P 5P 7m", "mixolydian pentatonic", "indian"],
        ["1P 2M 4P 5P 6M", "ritusen"],
        ["1P 2M 4P 5P 7m", "egyptian"],
        ["1P 3M 4P 5d 7m", "neopolitan major pentatonic"],
        ["1P 3m 4P 5P 6m", "vietnamese 1"],
        ["1P 2m 3m 5P 6m", "pelog"],
        ["1P 2m 4P 5P 6m", "kumoijoshi"],
        ["1P 2M 3m 5P 6m", "hirajoshi"],
        ["1P 2m 4P 5d 7m", "iwato"],
        ["1P 2m 4P 5P 7m", "in-sen"],
        ["1P 3M 4A 5P 7M", "lydian pentatonic", "chinese"],
        ["1P 3m 4P 6m 7m", "malkos raga"],
        ["1P 3m 4P 5d 7m", "locrian pentatonic", "minor seven flat five pentatonic"],
        ["1P 3m 4P 5P 7m", "minor pentatonic", "vietnamese 2"],
        ["1P 3m 4P 5P 6M", "minor six pentatonic"],
        ["1P 2M 3m 5P 6M", "flat three pentatonic", "kumoi"],
        ["1P 2M 3M 5P 6m", "flat six pentatonic"],
        ["1P 2m 3M 5P 6M", "scriabin"],
        ["1P 3M 5d 6m 7m", "whole tone pentatonic"],
        ["1P 3M 4A 5A 7M", "lydian #5P pentatonic"],
        ["1P 3M 4A 5P 7m", "lydian dominant pentatonic"],
        ["1P 3m 4P 5P 7M", "minor #7M pentatonic"],
        ["1P 3m 4d 5d 7m", "super locrian pentatonic"],
        ["1P 2M 3m 4P 5P 7M", "minor hexatonic"],
        ["1P 2A 3M 5P 5A 7M", "augmented"],
        ["1P 2M 4P 5P 6M 7m", "piongio"],
        ["1P 2m 3M 4A 6M 7m", "prometheus neopolitan"],
        ["1P 2M 3M 4A 6M 7m", "prometheus"],
        ["1P 2m 3M 5d 6m 7m", "mystery #1"],
        ["1P 2m 3M 4P 5A 6M", "six tone symmetric"],
        ["1P 2M 3M 4A 5A 6A", "whole tone", "messiaen's mode #1"],
        ["1P 2m 4P 4A 5P 7M", "messiaen's mode #5"],
        ["1P 2M 3M 4P 5d 6m 7m", "locrian major", "arabian"],
        ["1P 2m 3M 4A 5P 6m 7M", "double harmonic lydian"],
        ["1P 2m 2A 3M 4A 6m 7m", "altered", "super locrian", "diminished whole tone", "pomeroy"],
        ["1P 2M 3m 4P 5d 6m 7m", "locrian #2", "half-diminished", "aeolian b5"],
        ["1P 2M 3M 4P 5P 6m 7m", "mixolydian b6", "melodic minor fifth mode", "hindu"],
        ["1P 2M 3M 4A 5P 6M 7m", "lydian dominant", "lydian b7", "overtone"],
        ["1P 2M 3M 4A 5A 6M 7M", "lydian augmented"],
        ["1P 2m 3m 4P 5P 6M 7m", "dorian b2", "phrygian #6", "melodic minor second mode"],
        ["1P 2m 3m 4d 5d 6m 7d", "ultralocrian", "superlocrian bb7", "superlocrian diminished"],
        ["1P 2m 3m 4P 5d 6M 7m", "locrian 6", "locrian natural 6", "locrian sharp 6"],
        ["1P 2A 3M 4P 5P 5A 7M", "augmented heptatonic"],
        ["1P 2M 3m 4A 5P 6M 7m", "dorian #4", "ukrainian dorian", "romanian minor", "altered dorian"],
        ["1P 2M 3m 4A 5P 6M 7M", "lydian diminished"],
        ["1P 2M 3M 4A 5A 7m 7M", "leading whole tone"],
        ["1P 2M 3M 4A 5P 6m 7m", "lydian minor"],
        ["1P 2m 3M 4P 5P 6m 7m", "phrygian dominant", "spanish", "phrygian major"],
        ["1P 2m 3m 4P 5P 6m 7M", "balinese"],
        ["1P 2m 3m 4P 5P 6M 7M", "neopolitan major"],
        ["1P 2M 3M 4P 5P 6m 7M", "harmonic major"],
        ["1P 2m 3M 4P 5P 6m 7M", "double harmonic major", "gypsy"],
        ["1P 2M 3m 4A 5P 6m 7M", "hungarian minor"],
        ["1P 2A 3M 4A 5P 6M 7m", "hungarian major"],
        ["1P 2m 3M 4P 5d 6M 7m", "oriental"],
        ["1P 2m 3m 3M 4A 5P 7m", "flamenco"],
        ["1P 2m 3m 4A 5P 6m 7M", "todi raga"],
        ["1P 2m 3M 4P 5d 6m 7M", "persian"],
        ["1P 2m 3M 5d 6m 7m 7M", "enigmatic"],
        ["1P 2M 3M 4P 5A 6M 7M", "major augmented", "major #5", "ionian augmented", "ionian #5"],
        ["1P 2A 3M 4A 5P 6M 7M", "lydian #9"],
        ["1P 2m 2M 4P 4A 5P 6m 7M", "messiaen's mode #4"],
        ["1P 2m 3M 4P 4A 5P 6m 7M", "purvi raga"],
        ["1P 2m 3m 3M 4P 5P 6m 7m", "spanish heptatonic"],
        ["1P 2M 3m 3M 4P 5P 6M 7m", "bebop minor"],
        ["1P 2M 3M 4P 5P 5A 6M 7M", "bebop major"],
        ["1P 2m 3m 4P 5d 5P 6m 7m", "bebop locrian"],
        ["1P 2M 3m 4P 5P 6m 7m 7M", "minor bebop"],
        ["1P 2M 3M 4P 5d 5P 6M 7M", "ichikosucho"],
        ["1P 2M 3m 4P 5P 6m 6M 7M", "minor six diminished"],
        ["1P 2m 3m 3M 4A 5P 6M 7m", "half-whole diminished", "dominant diminished", "messiaen's mode #2"],
        ["1P 3m 3M 4P 5P 6M 7m 7M", "kafi raga"],
        ["1P 2M 3M 4P 4A 5A 6A 7M", "messiaen's mode #6"],
        ["1P 2M 3m 3M 4P 5d 5P 6M 7m", "composite blues"],
        ["1P 2M 3m 3M 4A 5P 6m 7m 7M", "messiaen's mode #3"],
        ["1P 2m 2M 3m 4P 4A 5P 6m 6M 7M", "messiaen's mode #7"],
        ["1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M", "chromatic"]
    ],
    QSe = XSe,
    JSe = {
        ...Nc,
        intervals: [],
        aliases: []
    },
    Pb = [],
    $h = {};

function e6e() {
    return Pb.map(t => t.name)
}

function Kk(t) {
    return $h[t] || JSe
}

function $g() {
    return Pb.slice()
}

function t6e(t, e, n = []) {
    const r = {
        ..._a(t),
        name: e,
        intervals: t,
        aliases: n
    };
    return Pb.push(r), $h[r.name] = r, $h[r.setNum] = r, $h[r.chroma] = r, r.aliases.forEach(s => n6e(r, s)), r
}

function n6e(t, e) {
    $h[e] = t
}
QSe.forEach(([t, e, ...n]) => t6e(t.split(" "), e, n));
var Pv = {
        empty: !0,
        name: "",
        symbol: "",
        root: "",
        rootDegree: 0,
        type: "",
        tonic: null,
        setNum: NaN,
        quality: "Unknown",
        chroma: "",
        normalized: "",
        aliases: [],
        notes: [],
        intervals: []
    },
    r6e = /^(6|64|7|9|11|13)$/;

function Rb(t) {
    const [e, n, r, s] = Wk(t);
    return e === "" ? ["", t] : e === "A" && s === "ug" ? ["", "aug"] : !s && (r === "4" || r === "5") ? [e + n, r] : r6e.test(r) ? [e + n, r + s] : [e + n + r, s]
}

function Bc(t) {
    if (t === "") return Pv;
    if (Array.isArray(t) && t.length === 2) return Wp(t[1], t[0]); {
        const [e, n] = Rb(t), r = Wp(n, e);
        return r.empty ? Wp(t) : r
    }
}

function Wp(t, e, n) {
    const r = FSe(t),
        s = zt(e || ""),
        i = zt(n || "");
    if (r.empty || e && s.empty || n && i.empty) return Pv;
    const o = ESe(s.pc, i.pc),
        a = r.intervals.indexOf(o) + 1;
    if (!i.empty && !a) return Pv;
    const l = Array.from(r.intervals);
    for (let p = 1; p < a; p++) {
        const _ = l[0][0],
            v = l[0][1],
            y = parseInt(_, 10) + 7;
        l.push(`${y}${v}`), l.shift()
    }
    const u = s.empty ? [] : l.map(p => ga(s, p));
    t = r.aliases.indexOf(t) !== -1 ? t : r.aliases[0];
    const f = `${s.empty?"":s.pc}${t}${i.empty||a<=1?"":"/"+i.pc}`,
        d = `${e?s.pc+" ":""}${r.name}${a>1&&n?" over "+i.pc:""}`;
    return {
        ...r,
        name: d,
        symbol: f,
        type: r.name,
        root: i.name,
        intervals: l,
        rootDegree: a,
        tonic: s.name,
        notes: u
    }
}
var s6e = Lk("Chord.chord", "Chord.get", Bc);

function i6e(t, e) {
    const [n, r] = Rb(t);
    return n ? ga(n, e) + r : t
}

function o6e(t) {
    const e = Bc(t),
        n = Nb(e.chroma);
    return $g().filter(r => n(r.chroma)).map(r => r.name)
}

function a6e(t) {
    const e = Bc(t),
        n = Nb(e.chroma);
    return Rg().filter(r => n(r.chroma)).map(r => e.tonic + r.aliases[0])
}

function c6e(t) {
    const e = Bc(t),
        n = Ib(e.chroma);
    return Rg().filter(r => n(r.chroma)).map(r => e.tonic + r.aliases[0])
}

function l6e(t) {
    const {
        intervals: e,
        tonic: n
    } = Bc(t), r = Pg(e, n);
    return s => s ? r(s > 0 ? s - 1 : s) : ""
}

function u6e(t) {
    const {
        intervals: e,
        tonic: n
    } = Bc(t);
    return Pg(e, n)
}
var Rv = {
    getChord: Wp,
    get: Bc,
    detect: VSe,
    chordScales: o6e,
    extended: a6e,
    reduced: c6e,
    tokenize: Rb,
    transpose: i6e,
    degrees: l6e,
    steps: u6e,
    chord: s6e
};

function Zk(t) {
    return +t >= 0 && +t <= 127
}

function h6e(t) {
    if (Zk(t)) return +t;
    const e = zt(t);
    return e.empty ? null : e.midi
}

function f6e(t, e = 440) {
    return Math.pow(2, (t - 69) / 12) * e
}
var d6e = Math.log(2),
    p6e = Math.log(440);

function Mb(t) {
    const e = 12 * (Math.log(t) - p6e) / d6e + 69;
    return Math.round(e * 100) / 100
}
var m6e = "C C# D D# E F F# G G# A A# B".split(" "),
    g6e = "C Db D Eb E F Gb G Ab A Bb B".split(" ");

function qc(t, e = {}) {
    if (isNaN(t) || t === -1 / 0 || t === 1 / 0) return "";
    t = Math.round(t);
    const r = (e.sharps === !0 ? m6e : g6e)[t % 12];
    if (e.pitchClass) return r;
    const s = Math.floor(t / 12) - 1;
    return r + s
}

function Db(t) {
    return t % 12
}

function _6e(t) {
    return t.split("").reduce((e, n, r) => (r < 12 && n === "1" && e.push(r), e), [])
}

function y6e(t) {
    return t.map(Db).sort((e, n) => e - n).filter((e, n, r) => n === 0 || e !== r[n - 1])
}

function $b(t) {
    return Array.isArray(t) ? y6e(t) : _6e(t)
}

function v6e(t) {
    const e = $b(t);
    return n => {
        const r = Db(n);
        for (let s = 0; s < 12; s++) {
            if (e.includes(r + s)) return n + s;
            if (e.includes(r - s)) return n - s
        }
    }
}

function Xk(t, e) {
    const n = $b(t),
        r = n.length;
    return s => {
        const i = s < 0 ? (r - -s % r) % r : s % r,
            o = Math.floor(s / r);
        return n[i] + o * 12 + e
    }
}

function b6e(t, e) {
    const n = Xk(t, e);
    return r => {
        if (r !== 0) return n(r > 0 ? r - 1 : r)
    }
}
var E6e = {
        chroma: Db,
        freqToMidi: Mb,
        isMidi: Zk,
        midiToFreq: f6e,
        midiToNoteName: qc,
        pcsetNearest: v6e,
        pcset: $b,
        pcsetDegrees: b6e,
        pcsetSteps: Xk,
        toMidi: h6e
    },
    T6e = ["C", "D", "E", "F", "G", "A", "B"],
    Qk = t => t.name,
    Jk = t => t.map(zt).filter(e => !e.empty);

function S6e(t) {
    return t === void 0 ? T6e.slice() : Array.isArray(t) ? Jk(t).map(Qk) : []
}
var ti = zt,
    w6e = t => ti(t).name,
    A6e = t => ti(t).pc,
    O6e = t => ti(t).acc,
    C6e = t => ti(t).oct,
    k6e = t => ti(t).midi,
    I6e = t => ti(t).freq,
    N6e = t => ti(t).chroma;

function eI(t) {
    return qc(t)
}

function x6e(t) {
    return qc(Mb(t))
}

function P6e(t) {
    return qc(Mb(t), {
        sharps: !0
    })
}

function R6e(t) {
    return qc(t, {
        sharps: !0
    })
}
var ld = ga,
    M6e = ga,
    tI = t => e => ld(e, t),
    D6e = tI,
    nI = t => e => ld(t, e),
    $6e = nI;

function rI(t, e) {
    return ld(t, [e, 0])
}
var L6e = rI;

function F6e(t, e) {
    return ld(t, [0, e])
}
var Lb = (t, e) => t.height - e.height,
    U6e = (t, e) => e.height - t.height;

function sI(t, e) {
    return e = e || Lb, Jk(t).sort(e).map(Qk)
}

function iI(t) {
    return sI(t, Lb).filter((e, n, r) => n === 0 || e !== r[n - 1])
}
var B6e = t => {
    const e = ti(t);
    return e.empty ? "" : qc(e.midi || e.chroma, {
        sharps: e.alt > 0,
        pitchClass: e.midi === null
    })
};

function oI(t, e) {
    const n = ti(t);
    if (n.empty) return "";
    const r = ti(e || qc(n.midi || n.chroma, {
        sharps: n.alt < 0,
        pitchClass: !0
    }));
    if (r.empty || r.chroma !== n.chroma) return "";
    if (n.oct === void 0) return r.pc;
    const s = n.chroma - n.alt,
        i = r.chroma - r.alt,
        o = s > 11 || i < 0 ? -1 : s < 0 || i > 11 ? 1 : 0,
        a = n.oct + o;
    return r.pc + a
}
var Mv = {
        names: S6e,
        get: ti,
        name: w6e,
        pitchClass: A6e,
        accidentals: O6e,
        octave: C6e,
        midi: k6e,
        ascending: Lb,
        descending: U6e,
        sortedNames: sI,
        sortedUniqNames: iI,
        fromMidi: eI,
        fromMidiSharps: R6e,
        freq: I6e,
        fromFreq: x6e,
        fromFreqSharps: P6e,
        chroma: N6e,
        transpose: ld,
        tr: M6e,
        transposeBy: tI,
        trBy: D6e,
        transposeFrom: nI,
        trFrom: $6e,
        transposeFifths: rI,
        transposeOctaves: F6e,
        trFifths: L6e,
        simplify: B6e,
        enharmonic: oI
    },
    Fb = [
        [0, 2773, 0, "ionian", "", "Maj7", "major"],
        [1, 2902, 2, "dorian", "m", "m7"],
        [2, 3418, 4, "phrygian", "m", "m7"],
        [3, 2741, -1, "lydian", "", "Maj7"],
        [4, 2774, 1, "mixolydian", "", "7"],
        [5, 2906, 3, "aeolian", "m", "m7", "minor"],
        [6, 3434, 5, "locrian", "dim", "m7b5"]
    ],
    t8 = {
        ...Nc,
        name: "",
        alt: 0,
        modeNum: NaN,
        triad: "",
        seventh: "",
        aliases: []
    },
    q6e = Fb.map(G6e),
    Dv = {};
q6e.forEach(t => {
    Dv[t.name] = t, t.aliases.forEach(e => {
        Dv[e] = t
    })
});

function aI(t) {
    return typeof t == "string" ? Dv[t.toLowerCase()] || t8 : t && t.name ? aI(t.name) : t8
}

function G6e(t) {
    const [e, n, r, s, i, o, a] = t, l = a ? [a] : [], u = Number(n).toString(2);
    return {
        empty: !1,
        intervals: Kk(s).intervals,
        modeNum: e,
        chroma: u,
        normalized: u,
        name: s,
        setNum: n,
        alt: r,
        triad: i,
        seventh: o,
        aliases: l
    }
}

function cI(t) {
    return (e, n) => {
        const r = aI(e);
        if (r.empty) return [];
        const s = cd(r.modeNum, t),
            i = r.intervals.map(o => ga(n, o));
        return s.map((o, a) => i[a] + o)
    }
}
cI(Fb.map(t => t[4]));
cI(Fb.map(t => t[5]));
var V6e = {
    empty: !0,
    name: "",
    type: "",
    tonic: null,
    setNum: NaN,
    chroma: "",
    normalized: "",
    aliases: [],
    notes: [],
    intervals: []
};

function lI(t) {
    if (typeof t != "string") return ["", ""];
    const e = t.indexOf(" "),
        n = zt(t.substring(0, e));
    if (n.empty) {
        const s = zt(t);
        return s.empty ? ["", t] : [s.name, ""]
    }
    const r = t.substring(n.name.length + 1);
    return [n.name, r.length ? r : ""]
}
var j6e = e6e;

function Mi(t) {
    const e = Array.isArray(t) ? t : lI(t),
        n = zt(e[0]).name,
        r = Kk(e[1]);
    if (r.empty) return V6e;
    const s = r.name,
        i = n ? r.intervals.map(a => ga(n, a)) : [],
        o = n ? n + " " + s : s;
    return {
        ...r,
        name: o,
        type: s,
        tonic: n,
        notes: i
    }
}
var W6e = Lk("Scale.scale", "Scale.get", Mi);

function H6e(t, e = {}) {
    const n = ISe(t),
        r = zt(e.tonic ?? t[0] ?? ""),
        s = r.chroma;
    if (s === void 0) return [];
    const i = n.split("");
    i[s] = "1";
    const o = cd(s, i).join(""),
        a = $g().find(u => u.chroma === o),
        l = [];
    return a && l.push(r.name + " " + a.name), e.match === "exact" || uI(o).forEach(u => {
        l.push(r.name + " " + u)
    }), l
}

function Y6e(t) {
    const e = Mi(t),
        n = Ib(e.chroma);
    return Rg().filter(r => n(r.chroma)).map(r => r.aliases[0])
}

function uI(t) {
    const e = kb(t) ? t : Mi(t).chroma,
        n = Nb(e);
    return $g().filter(r => n(r.chroma)).map(r => r.name)
}

function z6e(t) {
    const e = Ib(Mi(t).chroma);
    return $g().filter(n => e(n.chroma)).map(n => n.name)
}

function hI(t) {
    const e = t.map(s => zt(s).pc).filter(s => s),
        n = e[0],
        r = iI(e);
    return cd(r.indexOf(n), r)
}

function K6e(t) {
    const e = Mi(t);
    if (e.empty) return [];
    const n = e.tonic ? e.notes : e.intervals;
    return zk(e.chroma).map((r, s) => {
        const i = Mi(r).name;
        return i ? [n[s], i] : ["", ""]
    }).filter(r => r[0])
}

function Z6e(t) {
    const e = Array.isArray(t) ? hI(t) : Mi(t).notes,
        n = e.map(r => zt(r).chroma);
    return r => {
        const s = zt(typeof r == "number" ? eI(r) : r),
            i = s.height;
        if (i === void 0) return;
        const o = i % 12,
            a = n.indexOf(o);
        if (a !== -1) return oI(s.name, e[a])
    }
}

function X6e(t) {
    const e = Z6e(t);
    return (n, r) => {
        const s = zt(n).height,
            i = zt(r).height;
        return s === void 0 || i === void 0 ? [] : wSe(s, i).map(e).filter(o => o)
    }
}

function Q6e(t) {
    const {
        intervals: e,
        tonic: n
    } = Mi(t), r = Pg(e, n);
    return s => s ? r(s > 0 ? s - 1 : s) : ""
}

function J6e(t) {
    const {
        intervals: e,
        tonic: n
    } = Mi(t);
    return Pg(e, n)
}
var n8 = {
    degrees: Q6e,
    detect: H6e,
    extended: uI,
    get: Mi,
    modeNames: K6e,
    names: j6e,
    rangeOf: X6e,
    reduced: z6e,
    scaleChords: Y6e,
    scaleNotes: hI,
    steps: J6e,
    tokenize: lI,
    scale: W6e
};
class $v {
    static getChordNameFromMidi(e) {
        const n = e.sort().map(r => Mv.fromMidi(r));
        return this.getChordNameFromNotes(n)
    }
    static getChordNameFromFrequencies(e) {
        const n = e.sort().map(r => Mv.fromFreq(r));
        return this.getChordNameFromNotes(n)
    }
    static getChordNameFromNotes(e, n = "Unknown") {
        const r = [],
            s = Rv.detect(e);
        if (!s.length) return [e.join("").replace(/[0-9]/g, "").toLowerCase()];
        r.push(s[0]);
        let i = s[0];
        const o = s[0].split("/");
        o.length > 1 && (i = o[0], r.push(i));
        const a = Rv.get(i);
        if (a.quality === "Major") r.push(`${a.tonic}`);
        else if (a.quality === "Minor") r.push(`${a.tonic}m`);
        else if (a.quality === "Diminished") {
            r.push(`${a.tonic}m`);
            const u = a.intervals.findIndex(f => f.includes("3"));
            u !== -1 && r.push(`${a.notes[u]}m`)
        } else if (a.type === "fifth") r.push(`${a.tonic}m`);
        else if (a.type === "minor augmented") {
            const u = a.intervals.findIndex(f => f.includes("5A"));
            u !== -1 && r.push(`${a.notes[u]}`)
        } else if (a.type === "augmented") {
            const u = a.intervals.findIndex(f => f.includes("3"));
            u !== -1 && r.push(`${a.notes[u]}`)
        }
        return n === "Major" ? r.push(`${a.tonic}`) : n === "Minor" && r.push(`${a.tonic}m`), r.map(u => (u = u.replace(/M/g, "").replace(/\//g, "|").toLowerCase(), this.desharp(u)))
    }
    static desharp(e) {
        const n = e.indexOf("#");
        if (n === -1) return e;
        if (e.indexOf("##") !== -1) switch (e[n - 1]) {
            case "a":
                return e.replace("a##", "b");
            case "b":
                return e.replace("b##", "db");
            case "c":
                return e.replace("c##", "d");
            case "d":
                return e.replace("d##", "e");
            case "e":
                return e.replace("e##", "gb");
            case "f":
                return e.replace("f##", "g");
            case "g":
                return e.replace("g##", "a")
        }
        switch (e[n - 1]) {
            case "a":
                return e.replace("a#", "bb");
            case "b":
                return e.replace("b#", "c");
            case "c":
                return e.replace("c#", "db");
            case "d":
                return e.replace("d#", "eb");
            case "e":
                return e.replace("e#", "f");
            case "f":
                return e.replace("f#", "gb");
            case "g":
                return e.replace("g#", "gb")
        }
        return e
    }
    static getRandomNumber(e, n) {
        return Math.floor(Math.random() * (n - e + 1) + e)
    }
    static getNotesInScale(e, n) {
        const r = n8.get(e);
        return n.map(s => {
            const i = s === 8 ? n8.degrees(r.name)(8) : r.notes[s - 1];
            return E6e.toMidi(i) ?? 60
        })
    }
    static getLimitsOctaveShift(e, n) {
        if (!e.preferredRange || !n.limits || n.type !== "Continuous") return 0;
        let r = 128,
            s = 0;
        if (n.limits.forEach(([a, l, u]) => {
                l < r && (r = l), u > s && (s = u)
            }), r > e.preferredRange[0] && s < e.preferredRange[1]) return 0;
        let i = 0,
            o = 0;
        for (let a = -6; a < 6; a++) {
            const l = e.preferredRange[0] + a,
                u = e.preferredRange[1] + a,
                f = Math.max(l, r),
                p = Math.max(u, s) - f + 1;
            p > o && (i = a, o = p)
        }
        return i
    }
}
class ai {
    constructor(e, n) {
        this.notes = new Set, this.isMidiKeyed = !0, this.rotationType = n.rotationType ?? "serial", n.isHarmonic && (this.isMidiKeyed = !1);
        let r;
        Array.isArray(e) ? (this.isMidiKeyed = !1, r = {
            samples: e
        }) : r = e;
        const s = new Map,
            i = {};
        Object.keys(r).forEach(o => {
            const a = [];
            let l;
            if (this.isMidiKeyed) {
                const u = Rh(o).toMidi();
                this.notes.add(u), l = `${u}`
            } else l = o.toLowerCase();
            r[o].forEach((u, f) => {
                i[`${l}:${f}`] = u, i[`${l}:${f}`] = u, a.push(`${l}:${f}`)
            }), s.set(l, {
                nextIndex: this.rotationType === "serial" ? 0 : $v.getRandomNumber(0, a.length - 1),
                bufferKeys: a
            })
        }), this.groupMap = s, this.buffers = new od({
            urls: i,
            onload: n.onload,
            baseUrl: n.baseUrl,
            onerror: n.onerror
        })
    }
    get loaded() {
        return this.buffers.loaded
    }
    findClosest(e) {
        if (!this.isMidiKeyed) return e;
        const n = 96;
        let r = 0;
        for (; r < n;) {
            if (this.notes.has(e + r)) return -r;
            if (this.notes.has(e - r)) return r;
            r += 1
        }
        return e
    }
    get(e) {
        e === void 0 && (e = "samples"), typeof e == "number" && (e = `${e}`);
        const n = this.groupMap.get(e);
        if (!n) return;
        const r = n.bufferKeys[n.nextIndex];
        return r ? (this.rotationType === "random" ? n.nextIndex = $v.getRandomNumber(0, n.bufferKeys.length - 1) : n.nextIndex = n.nextIndex === n.bufferKeys.length - 1 ? 0 : n.nextIndex + 1, this.buffers.get(r)) : void 0
    }
    keys() {
        return Array.from(this.groupMap.keys())
    }
    has(e) {
        return !this.isMidiKeyed || e === void 0 ? !0 : (typeof e == "number" && (e = `${e}`), this.groupMap.has(e))
    }
    dispose() {
        this.buffers.dispose()
    }
    static transformSampleMap(e) {
        const n = {};
        return Object.keys(e.urls).forEach(r => {
            var s, i;
            (s = e.notes) != null && s.length && !e.notes.includes(r) || (i = e.chords) != null && i.length && !e.chords.includes(r) || (n[r] = e.urls[r].map(o => this.transformUrl(o, e.baseUrl, e.ext)))
        }), n
    }
    static transformSampleObject(e) {
        const n = {};
        return Object.keys(e.urls).forEach(r => {
            e.notes && !e.notes.includes(r) || e.chords && !e.chords.includes(r) || (n[r] = this.transformUrl(e.urls[r], e.baseUrl, e.ext))
        }), n
    }
    static transformSampleArray(e) {
        return e.urls.map(n => this.transformUrl(n, e.baseUrl, e.ext))
    }
    static transformUrl(e, n, r) {
        return r || (r = Pt.supportsType("ogg") ? "ogg" : "mp3"), e.includes(`.${r}`) ? `${n}/${e}` : `${n}/${e}.${r}`
    }
}
class Of extends ei {
    constructor() {
        super(re(Of.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "OneShotSampler", this.activeSources = new Map;
        const e = re(Of.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
        this.buffers = new ai(e.urls, {
            rotationType: e.rotationType,
            baseUrl: e.baseUrl,
            onload: e.onload,
            onerror: e.onerror
        }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this.isPitchLocked = e.pitchLocked ?? !1, this.restrictToSingleNotes = e.restrictToSingleNotes ?? !1, this.buffers.loaded && Promise.resolve().then(e.onload)
    }
    get loaded() {
        return this.buffers.loaded
    }
    static getDefaults() {
        return Object.assign(ei.getDefaults(), {
            attack: 0,
            baseUrl: "",
            curve: "linear",
            onload: yt,
            onerror: yt,
            release: .1,
            isOneShot: !1,
            pitchLocked: !1,
            restrictToSingleNotes: !1,
            rotationType: "serial",
            urls: {}
        })
    }
    triggerAttack(e, n) {
        return Array.isArray(e) || (e = [e]), this.restrictToSingleNotes && e.length > 1 ? this : (e.forEach(r => {
            const s = Ig(new er(this.context, r).toFrequency()),
                i = Math.round(s),
                o = s - i,
                a = this.buffers.findClosest(i);
            if (a === null) return;
            const l = i - a,
                u = Cc(a + o),
                f = this.buffers.get(l);
            if (!f) return;
            const d = new Ni({
                url: f,
                context: this.context,
                curve: this.curve,
                playbackRate: this.isPitchLocked ? 1 : u,
                fadeIn: this.attack,
                fadeOut: this.release,
                onended: () => {
                    this.onSourceEnded(i, d)
                },
                loop: !1
            }).connect(this.output);
            d.start(n, 0);
            const p = this.activeSources.get(i) ?? new Set;
            p.add(d), this.activeSources.set(i, p)
        }), this)
    }
    triggerAttackRelease(e, n, r) {
        const s = this.toSeconds(r);
        return this.triggerAttack(e, s), this.triggerRelease(s + this.toSeconds(n)), this
    }
    triggerRelease(e, n) {
        return Array.isArray(e) || (e = [e]), this.restrictToSingleNotes && e.length > 1 ? this : (e.forEach(r => {
            const s = new er(this.context, r).toMidi(),
                i = this.activeSources.get(s);
            i && (i.forEach(o => {
                n ? o.stop(this.toSeconds(n)) : o.stop(this.now())
            }), this.activeSources.delete(s))
        }), this)
    }
    onSourceEnded(e, n) {
        n.stop(this.now());
        const r = this.activeSources.get(e);
        r && (r.delete(n), r.size || this.activeSources.delete(e))
    }
    sync() {
        return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
    }
    dispose() {
        return super.dispose(), this.buffers.dispose(), this.activeSources.forEach(e => {
            e.forEach(n => n.dispose())
        }), this.activeSources.clear(), this
    }
}
const Ub = class Lv {
    constructor(e, n) {
        this.isPlayable = !0, e.urls = this.convertDrumRackKeys(e.urls), n.baseUrl && (e.urls = ai.transformSampleMap({
            urls: e.urls,
            baseUrl: n.baseUrl,
            ext: n.ext
        })), this.node = new Of(e)
    }
    attack(e) {
        this.node.triggerAttack(e)
    }
    oneShot(e, n) {
        n ? this.node.triggerAttackRelease(e, n) : this.node.triggerAttack(e)
    }
    release(e) {
        this.node.triggerRelease(e)
    }
    convertDrumRackKeys(e) {
        const n = {};
        return Object.keys(e).forEach(r => {
            Lv.keyToNoteMap[r] ? n[Lv.keyToNoteMap[r]] = e[r] : n[r] = e[r]
        }), n
    }
};
Ub.keys = ["kick", "rim", "snare", "sidestick", "rimshot", "pedalhh", "closedhh", "floortom", "mediumhh", "lowtom", "openhh", "midtom", "hitom", "crash", "ride", "click"];
Ub.keyToNoteMap = {
    kick: "c2",
    rim: "db2",
    snare: "d2",
    sidestick: "eb2",
    rimshot: "e2",
    pedalhh: "f2",
    closedhh: "gb2",
    floortom: "g2",
    mediumhh: "ab2",
    lowtom: "a2",
    openhh: "bb2",
    midtom: "b2",
    hitom: "c3",
    crash: "d3",
    ride: "eb3",
    click: "g3"
};
let ewe = Ub;
class twe {
    constructor(e) {
        this.isPlayable = !0, this.node = new V1(e)
    }
    attack(e) {
        e.length && this.node.triggerAttack(e[0])
    }
    oneShot(e, n = .25) {
        e.length && this.node.triggerAttackRelease(e[0], n)
    }
    update(e) {
        e.length && (this.node.frequency.value = e[0])
    }
    release(e) {
        this.node.triggerRelease()
    }
}
class gm extends ei {
    constructor() {
        super(re(gm.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "FlubSampler", this.activeSources = new Set;
        const e = re(gm.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
        this.buffers = new ai(e.urls, {
            rotationType: e.rotationType,
            baseUrl: e.baseUrl,
            onload: e.onload,
            onerror: e.onerror
        }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this.buffers.loaded && Promise.resolve().then(e.onload)
    }
    get loaded() {
        return this.buffers.loaded
    }
    static getDefaults() {
        return Object.assign(ei.getDefaults(), {
            attack: 0,
            baseUrl: "",
            curve: "exponential",
            onload: yt,
            onerror: yt,
            release: .1,
            rotationType: "serial",
            urls: []
        })
    }
    triggerAttack(e) {
        const n = this.buffers.get();
        if (!n) return this;
        const r = new Ni({
            url: n,
            context: this.context,
            curve: this.curve,
            fadeIn: this.attack,
            fadeOut: this.release,
            onended: s => this.activeSources.delete(s)
        }).connect(this.output);
        return r.start(e, 0), this.activeSources.add(r), this
    }
    triggerAttackRelease() {
        return this
    }
    triggerRelease() {
        return this
    }
    sync() {
        return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
    }
    dispose() {
        return super.dispose(), this.buffers.dispose(), this.activeSources.forEach(e => e.dispose()), this.activeSources.clear(), this
    }
}
class nwe {
    constructor(e, n) {
        this.isPlayable = !0, n.baseUrl && (e.urls = ai.transformSampleArray({
            urls: e.urls,
            baseUrl: n.baseUrl,
            ext: n.ext
        })), this.node = new gm(e)
    }
    attack() {
        this.node.triggerAttack()
    }
    oneShot() {
        this.node.triggerAttack()
    }
    release() {
        this.node.triggerRelease()
    }
}
class rwe {
    constructor(e) {
        this.isPlayable = !0, this.node = new gf(e)
    }
    attack(e) {
        e.length && this.node.triggerAttack(e[0])
    }
    oneShot(e, n = .25) {
        e.length && this.node.triggerAttackRelease(e[0], n)
    }
    update(e) {
        e.length && (this.node.frequency.value = e[0])
    }
    release(e) {
        this.node.triggerRelease()
    }
}
class _m extends ei {
    constructor() {
        super(re(_m.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "HarmonicSampler";
        const e = re(_m.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
        this.buffers = new ai(e.urls, {
            isHarmonic: !0,
            rotationType: e.rotationType,
            baseUrl: e.baseUrl,
            onload: e.onload,
            onerror: e.onerror
        }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this.buffers.loaded && Promise.resolve().then(e.onload)
    }
    get loaded() {
        return this.buffers.loaded
    }
    static getDefaults() {
        return Object.assign(ei.getDefaults(), {
            attack: 0,
            baseUrl: "",
            curve: "exponential",
            onload: yt,
            onerror: yt,
            release: .1,
            rotationType: "serial",
            urls: {}
        })
    }
    triggerAttack(e, n) {
        if (!Array.isArray(e)) return this;
        if (e.length < 2) return this;
        let r;
        const s = $v.getChordNameFromFrequencies(e);
        for (let i = 0; i < s.length && (r = this.buffers.get(s[i]), !r); i++);
        if (!r) {
            const i = e.sort().map(o => Mv.fromFreq(o));
            return console.warn("Buffer not found", s, Rv.detect(i), i), this
        }
        return this.activeSource && (this.activeSource.stop(), this.disposeActiveSource()), this.activeSource = new Ni({
            url: r,
            context: this.context,
            curve: this.curve,
            fadeIn: this.attack,
            fadeOut: this.release,
            loop: !1
        }).connect(this.output), this.activeSource.start(n, 0), this
    }
    triggerAttackRelease(e, n, r) {
        const s = this.toSeconds(r);
        return this.triggerAttack(e, s), this.triggerRelease(s + this.toSeconds(n)), this
    }
    triggerRelease(e, n) {
        return Array.isArray(e) ? this.activeSource ? (n ? this.activeSource.stop(this.toSeconds(n)) : this.activeSource.stop(this.now()), delete this.activeSource, this) : this : this
    }
    disposeActiveSource() {
        this.activeSource && (this.activeSource.dispose(), delete this.activeSource)
    }
    sync() {
        return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
    }
    dispose() {
        return super.dispose(), this.buffers.dispose(), this.disposeActiveSource(), this
    }
}
class swe {
    constructor(e, n) {
        this.isPlayable = !0, n.baseUrl && (e.urls = ai.transformSampleMap({
            urls: e.urls,
            baseUrl: n.baseUrl,
            ext: n.ext
        })), this.node = new _m(e)
    }
    attack(e) {
        this.node.triggerAttack(e)
    }
    oneShot(e, n = .25) {
        this.node.triggerAttackRelease(e, n)
    }
    release(e) {
        this.node.triggerRelease(e)
    }
}
class iwe {
    constructor(e) {
        this.isPlayable = !0, this.node = new ou(e)
    }
    attack(e) {
        e.length && this.node.triggerAttack(e[0])
    }
    oneShot(e, n = .25) {
        e.length && this.node.triggerAttackRelease(e[0], n)
    }
    update(e) {
        e.length && (this.node.frequency.value = e[0])
    }
    release(e) {
        this.node.triggerRelease()
    }
}
class owe {
    constructor(e) {
        this.isPlayable = !0, this.node = new j1(e)
    }
    attack(e) {
        e.length && this.node.triggerAttack(e[0])
    }
    oneShot(e, n = .25) {
        e.length && this.node.triggerAttackRelease(e[0], n)
    }
    update(e) {
        e.length && (this.node.frequency.value = e[0])
    }
    release(e) {
        this.node.triggerRelease()
    }
}
class awe {
    constructor(e) {
        this.isPlayable = !0, this.node = new io(e)
    }
    attack(e) {
        e.length && this.node.triggerAttack(e[0])
    }
    oneShot(e, n = .25) {
        e.length && this.node.triggerAttackRelease(e[0], n)
    }
    update(e) {
        e.length && (this.node.frequency.value = e[0])
    }
    release(e) {
        this.node.triggerRelease()
    }
}
class cwe {
    constructor(e) {
        this.isPlayable = !0, this.node = new W1(e)
    }
    attack(e) {
        e.length && this.node.triggerAttack(e[0])
    }
    oneShot(e, n = .25) {
        e.length && this.node.triggerAttackRelease(e[0], n)
    }
    release(e) {
        this.node.triggerRelease()
    }
}
class lwe {
    constructor(e, n) {
        this.isPlayable = !0;
        let r;
        n.notes && (r = n.notes.map(s => Rh(s, "midi").toNote())), n.baseUrl && (e.urls = ai.transformSampleMap({
            urls: e.urls,
            baseUrl: n.baseUrl,
            ext: n.ext,
            notes: r
        })), this.node = new Of(e)
    }
    attack(e) {
        this.node.triggerAttack(e)
    }
    oneShot(e, n) {
        n ? this.node.triggerAttackRelease(e, n) : this.node.triggerAttack(e)
    }
    release(e) {
        this.node.triggerRelease(e)
    }
}
class uwe {
    constructor(e, n) {
        this.isPlayable = !0, n.baseUrl && (e.url = ai.transformUrl(e.url, n.baseUrl, n.ext)), this.node = new kc(e)
    }
    attack(e) {
        this.node.start()
    }
    oneShot(e, n = .25) {
        this.node.start(), window.setTimeout(() => {
            this.node.stop()
        }, n * 1e3)
    }
    release(e) {
        this.node.stop()
    }
}
class hwe {
    constructor(e) {
        this.isPlayable = !0, this.node = new H1(e)
    }
    attack(e) {
        e.length && this.node.triggerAttack(e[0])
    }
    oneShot(e, n = .25) {
        e.length && this.node.triggerAttackRelease(e[0], n)
    }
    release(e) {
        this.node.triggerRelease()
    }
}
class fwe {
    constructor(e) {
        this.isPlayable = !0, this.node = this.getNode(e)
    }
    getNode(e) {
        return e.voice.type === "amSynth" ? new uc({
            voice: xg,
            maxPolyphony: e.maxPolyphony ?? 12,
            options: e.voice.options
        }) : e.voice.type === "fmSynth" ? new uc({
            voice: gf,
            maxPolyphony: e.maxPolyphony ?? 12,
            options: e.voice.options
        }) : e.voice.type === "monoSynth" ? new uc({
            voice: io,
            maxPolyphony: e.maxPolyphony ?? 12,
            options: e.voice.options
        }) : new uc({
            voice: Pi,
            maxPolyphony: e.maxPolyphony ?? 12,
            options: e.voice.options
        })
    }
    attack(e) {
        this.node.triggerAttack(e)
    }
    oneShot(e, n = .25) {
        this.node.triggerAttackRelease(e, n)
    }
    release(e) {
        this.node.triggerRelease(e)
    }
}
class dwe {
    constructor(e, n) {
        this.isPlayable = !0, n.baseUrl && (e.urls = ai.transformSampleObject({
            urls: e.urls,
            baseUrl: n.baseUrl,
            ext: n.ext
        })), this.node = new au(e)
    }
    attack(e) {
        this.node.triggerAttack(e)
    }
    oneShot(e, n = .25) {
        this.node.triggerAttackRelease(e, n)
    }
    release(e) {
        this.node.triggerRelease(e)
    }
}
class pwe {
    constructor(e) {
        this.isPlayable = !1, this.node = this.getNode(e)
    }
    getNode(e) {
        switch (e.type) {
            case "compressor":
                return new ia(e.options);
            case "eq3":
                return new pm(e.options);
            case "filter":
                return new Dr(e.options);
            case "gate":
                return new hm(e.options);
            case "limiter":
                return new fm(e.options);
            case "multibandCompressor":
                return new dm(e.options);
            case "panVol":
                return new hu(e.options);
            case "panner":
                return new lu(e.options);
            case "volume":
                return new Ii(e.options);
            case "autoFilter":
                return new bf(e.options);
            case "autoPanner":
                return new Ef(e.options);
            case "autoWah":
                return new z1(e.options);
            case "bitCrusher":
                return new K1(e.options);
            case "chebyshev":
                return new X1(e.options);
            case "chorus":
                return new Q1(e.options);
            case "distortion":
                return new J1(e.options);
            case "feedbackDelay":
                return new tm(e.options);
            case "freeverb":
                return new rm(e.options);
            case "frequencyShifter":
                return new nm(e.options);
            case "jcReverb":
                return new sm(e.options);
            case "phaser":
                return new am(e.options);
            case "pingPongDelay":
                return new im(e.options);
            case "pitchShift":
                return new om(e.options);
            case "reverb":
                return new cm(e.options);
            case "stereoWidener":
                return new lm(e.options);
            case "tremolo":
                return new Sf(e.options);
            case "vibrato":
                return new um(e.options);
            default:
                throw new Error(`Unknown static node type ${e.type}`)
        }
    }
}
class ym extends ei {
    constructor() {
        super(re(ym.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "SustainSampler";
        const e = re(ym.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
        this.buffers = new ai(e.urls, {
            rotationType: e.rotationType,
            baseUrl: e.baseUrl,
            onload: e.onload,
            onerror: e.onerror
        }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this.legato = e.legato, this.buffers.loaded && Promise.resolve().then(e.onload)
    }
    static getDefaults() {
        return Object.assign(ei.getDefaults(), {
            attack: 0,
            baseUrl: "",
            curve: "exponential",
            legato: !1,
            onload: yt,
            onerror: yt,
            release: .1,
            rotationType: "serial",
            urls: {}
        })
    }
    triggerAttack(e, n) {
        var d;
        const r = Ig(new er(this.context, e).toFrequency());
        if (this.activeSource && this.activeNote && !this.legato) {
            const p = r - this.activeNote,
                _ = this.buffers.findClosest(this.activeNote);
            if (_ === null) return this;
            const v = Cc(_ + p);
            return this.activeSource.playbackRate.value = v, this
        }
        const s = Math.round(r),
            i = r - s,
            o = this.buffers.findClosest(s);
        if (o === null) return this;
        const a = Cc(o + i),
            l = s - o;
        if (this.legato) {
            if (l === this.activeNote) return this;
            (d = this.activeSource) == null || d.stop(this.now())
        }
        const u = this.buffers.get(l);
        if (!u) return this;
        const f = new Ni({
            url: u,
            context: this.context,
            curve: this.curve,
            fadeIn: this.attack,
            fadeOut: this.release,
            loop: !0,
            playbackRate: a
        }).connect(this.output);
        return f.start(n, 0), this.activeSource = f, this.activeNote = l, this
    }
    triggerAttackRelease(e, n, r) {
        return this
    }
    triggerUpdate(e, n) {
        return this.triggerAttack(e, n), this
    }
    triggerRelease(e) {
        return this.activeSource ? (e ? this.activeSource.stop(this.toSeconds(e)) : this.activeSource.stop(this.now()), delete this.activeSource, delete this.activeNote, this) : this
    }
    sync() {
        return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
    }
    dispose() {
        var e;
        return super.dispose(), this.buffers.dispose(), (e = this.activeSource) == null || e.dispose(), this
    }
}
class mwe {
    constructor(e, n) {
        this.isPlayable = !0, n.baseUrl && (e.urls = ai.transformSampleMap({
            urls: e.urls,
            baseUrl: n.baseUrl,
            ext: n.ext
        })), this.node = new ym(e)
    }
    attack(e) {
        e.length && this.node.triggerAttack(e[0])
    }
    oneShot(e, n = .25) {
        e.length && this.node.triggerAttackRelease(e[0], n)
    }
    update(e) {
        e.length && this.node.triggerAttack(e[0])
    }
    release(e) {
        this.node.triggerRelease()
    }
}
class gwe {
    constructor(e) {
        this.isPlayable = !0, this.node = new Pi(e)
    }
    attack(e) {
        e.length && this.node.triggerAttack(e[0])
    }
    oneShot(e, n = .25) {
        e.length && this.node.triggerAttackRelease(e[0], n)
    }
    update(e) {
        e.length && (this.node.frequency.value = e[0])
    }
    release(e) {
        this.node.triggerRelease()
    }
}
class _we {
    constructor(e) {
        this.isPlayable = !1;
        const n = new Ps(e.frequency || 440, e.type || "sine"),
            r = new Sf(e).start();
        n.connect(r), this.node = r
    }
}
class ch {
    constructor(e, n) {
        this.nodes = [], this.duration = n.duration ?? .25, e.forEach(r => {
            if (r.isDisabled) return;
            const s = this.getNode(r, n);
            this.nodes.push(s), this.isPlayableNode(s) && (this.playable = s)
        }), this.connectNodes()
    }
    get inNode() {
        return this.nodes[0]
    }
    get outNode() {
        return this.nodes[this.nodes.length - 1]
    }
    isPlayableNode(e) {
        return e.attack !== void 0
    }
    getNode(e, n) {
        switch (e.type) {
            case "amSynth":
                return new JTe(e.options);
            case "autoFilter":
                return new eSe(e.options);
            case "autoPanner":
                return new tSe(e.options);
            case "drumRackSampler":
                return new ewe(e.options, n);
            case "duoSynth":
                return new twe(e.options);
            case "flubSampler":
                return new nwe(e.options, n);
            case "fmSynth":
                return new rwe(e.options);
            case "harmonicSampler":
                return new swe(e.options, n);
            case "membraneSynth":
                return new iwe(e.options);
            case "metalSynth":
                return new owe(e.options);
            case "monoSynth":
                return new awe(e.options);
            case "noiseSynth":
                return new cwe(e.options);
            case "oneShotSampler":
                return new lwe(e.options, n);
            case "player":
                return new uwe(e.options, n);
            case "pluckSynth":
                return new hwe(e.options);
            case "polySynth":
                return new fwe(e.options);
            case "sampler":
                return new dwe(e.options, n);
            case "sustainSampler":
                return new mwe(e.options, n);
            case "synth":
                return new gwe(e.options);
            case "tremolo":
                return new _we(e.options);
            default:
                return new pwe(e)
        }
    }
    connectNodes() {
        this.nodes.forEach((e, n) => {
            n !== this.nodes.length - 1 && e.node.connect(this.nodes[n + 1].node)
        })
    }
    attack(e) {
        var n;
        if ((n = this.playable) != null && n.attack) try {
            this.playable.attack(e)
        } catch (r) {
            console.warn(r)
        }
    }
    oneShot(e, n) {
        var r;
        if ((r = this.playable) != null && r.oneShot) try {
            this.playable.oneShot(e, n)
        } catch (s) {
            console.warn(s)
        }
    }
    update(e) {
        var n;
        if ((n = this.playable) != null && n.update) try {
            this.playable.update(e)
        } catch (r) {
            console.warn(r)
        }
    }
    release(e) {
        var n;
        if ((n = this.playable) != null && n.release) try {
            this.playable.release(e)
        } catch (r) {
            console.warn(r)
        }
    }
}
class Bb {
    constructor(e = {}) {
        this.attackChains = [], this.mainChains = [], this.releaseChains = [], this.flubChains = [], this.activeFrequency = null, this.activeFrequencies = new Set, this.outNode = new hu, this.settings = {
            baseUrl: null,
            ext: null,
            chords: [],
            config: null,
            notes: [],
            isOneShot: !1,
            noFlubs: !1
        }, this.continuous = {
            attack: (n, r, s) => {
                this.activeFrequency === null && (n = this.normalizeSignal(n), this.activeFrequency = this.signalToFrequency(n, r, s), this.attackChains.forEach(i => i.oneShot([this.activeFrequency], i.duration)), this.mainChains.forEach(i => i.attack([this.activeFrequency])))
            },
            update: (n, r, s) => {
                this.activeFrequency !== null && (n = this.normalizeSignal(n), this.activeFrequency = this.signalToFrequency(n, r, s), this.mainChains.forEach(i => i.update([this.activeFrequency])))
            },
            release: () => {
                this.activeFrequency !== null && (this.releaseChains.forEach(n => n.oneShot([this.activeFrequency], n.duration)), this.mainChains.forEach(n => n.release([this.activeFrequency])), this.activeFrequency = null)
            }
        }, this.discrete = {
            attack: n => {
                n = this.transposeNotesIntoRange(n);
                const r = n.map(s => Rh(s, "midi").toFrequency());
                r.forEach(s => {
                    this.activeFrequencies.has(s) && this.mainChains.forEach(i => i.release([s])), this.activeFrequencies.add(s)
                }), this.attackChains.forEach(s => s.oneShot(r, s.duration)), this.mainChains.forEach(s => {
                    this.isOneShot ? s.oneShot(r) : s.attack(r)
                })
            },
            release: n => {
                n = this.transposeNotesIntoRange(n);
                const r = n.map(s => Rh(s, "midi").toFrequency());
                r.forEach(s => this.activeFrequencies.delete(s)), this.releaseChains.forEach(s => s.oneShot(r, s.duration)), !this.isOneShot && this.mainChains.forEach(s => s.release(r))
            }
        }, this.flub = {
            attack: () => {
                this.flubChains.forEach(n => n.oneShot([60], n.duration))
            }
        }, this.outNode.toDestination(), this.update(e)
    }
    update(e = {}) {
        this.releaseAll();
        const n = JSON.parse(JSON.stringify(e));
        n.baseUrl !== void 0 && (this.settings.baseUrl = n.baseUrl), n.ext !== void 0 && (this.settings.ext = n.ext), n.chords !== void 0 && (this.settings.chords = n.chords), n.notes !== void 0 && (this.settings.notes = this.transposeNotesIntoRange(n.notes.sort())), n.noFlubs !== void 0 && (this.settings.noFlubs = n.noFlubs), n.config !== void 0 && (this.settings.config = n.config), this.settings.config && (this.settings.isOneShot = this.settings.config.capabilities.includes("OneShot"), this.resetChains())
    }
    get baseUrl() {
        return this.settings.baseUrl
    }
    get ext() {
        return this.settings.ext
    }
    get chords() {
        return this.settings.chords
    }
    get notes() {
        return this.settings.notes
    }
    get isOneShot() {
        return this.settings.isOneShot
    }
    get noFlubs() {
        return this.settings.noFlubs
    }
    get config() {
        return this.settings.config
    }
    resetChains() {
        this.clearChains(), this.config && (this.buildChains(), this.connectChains())
    }
    clearChains() {
        const e = [];
        this.attackChains.forEach(n => {
            e.push(...n.nodes)
        }), this.mainChains.forEach(n => {
            e.push(...n.nodes)
        }), this.releaseChains.forEach(n => {
            e.push(...n.nodes)
        }), this.flubChains.forEach(n => {
            e.push(...n.nodes)
        }), this.effectChain && e.push(...this.effectChain.nodes), this.attackChains = [], this.mainChains = [], this.releaseChains = [], this.flubChains = [], delete this.effectChain, e.forEach(n => {
            n.node.disconnect(), n.node.dispose()
        })
    }
    buildChains() {
        this.config && this.config.chains.forEach(e => {
            var r;
            if (this.settings.noFlubs && e.type === "flub" || !e.nodes.length || (r = e.nodes[0]) != null && r.isDisabled && e.type !== "effect") return;
            const n = {};
            this.baseUrl && (n.baseUrl = this.baseUrl), this.chords && (n.chords = this.chords), this.ext && (n.ext = this.ext), this.notes && (n.notes = this.notes), e.type === "effect" ? this.effectChain = new ch(e.nodes, n) : e.type === "main" ? this.mainChains.push(new ch(e.nodes, n)) : (n.duration = e.duration, e.type === "attack" ? this.attackChains.push(new ch(e.nodes, n)) : e.type === "release" ? this.releaseChains.push(new ch(e.nodes, n)) : this.flubChains.push(new ch(e.nodes, n)))
        })
    }
    connectChains() {
        this.effectChain && this.effectChain.outNode.node.connect(this.outNode), [...this.attackChains, ...this.mainChains, ...this.releaseChains, ...this.flubChains].forEach(n => {
            this.effectChain ? n.outNode.node.connect(this.effectChain.inNode.node) : n.outNode.node.connect(this.outNode)
        })
    }
    normalizeSignal(e) {
        return e < 0 ? 0 : e > 1 ? 1 : e
    }
    signalToFrequency(e, n, r) {
        const s = (r - n) * e + n;
        return Rh(s, "midi").toFrequency()
    }
    transposeNotesIntoRange(e) {
        return e.map(this.transposeNoteIntoRange.bind(this))
    }
    transposeNoteIntoRange(e) {
        if (!this.config || !this.config.preferredRange) return e;
        if (e < this.config.preferredRange[0]) {
            for (let n = e; n <= 127; n += 12)
                if (n >= this.config.preferredRange[0]) return n;
            return console.warn(`Unable to transpose note ${e} into range ${this.config.preferredRange}`), e
        }
        if (e > this.config.preferredRange[1]) {
            for (let n = e; n >= 0; n -= 12)
                if (n <= this.config.preferredRange[1]) return n;
            console.warn(`Unable to transpose note ${e} into range ${this.config.preferredRange}`)
        }
        return e
    }
    releaseAll() {
        const e = Array.from(this.activeFrequencies);
        this.discrete.release(e), this.continuous.release()
    }
}
const ywe = st({
    props: {
        beatmap: {
            type: Object,
            required: !0
        },
        instrument: {
            type: Object,
            required: !0
        }
    },
    setup() {
        return {
            instraface: new Bb({
                noFlubs: !0
            })
        }
    },
    data() {
        return {
            isLoading: !0,
            isDown: !1,
            signal: 0
        }
    },
    computed: {
        classes() {
            const t = [ur.categorySlugByKey(this.beatmap.config.category)];
            return this.isLoading && t.push("loading"), t
        },
        limits() {
            const e = 12 + (this.instrument.config.testOctave ?? 3) * 12;
            return [e - 12, e + 12]
        }
    },
    watch: {
        instrument: {
            handler(t, e) {
                e && t.config.slug === e.config.slug || (this.instraface.update({
                    baseUrl: `https://cdn.jackboxgames.com/nopus-opus/instruments/${this.instrument.config.slug}`,
                    config: this.instrument.config
                }), this.instraface.outNode.volume.value = 8, this.waitForLoading())
            },
            immediate: !0
        }
    },
    beforeUnmount() {
        this.instraface.releaseAll(), this.instraface.update({
            config: null
        })
    },
    methods: {
        normalizeSignal(t) {
            return t < 0 ? 0 : t > 1 ? 1 : t
        },
        onPointerBoxStart(t) {
            if (sf(), !this.isLoading) {
                this.isDown = !0, this.signal = this.normalizeSignal(t.detail.percentX);
                try {
                    this.instraface.continuous.attack(this.signal, this.limits[0], this.limits[1])
                } catch {
                    t.detail.cancel(), console.warn("not loaded")
                }
            }
        },
        onPointerBoxMove(t) {
            if (!this.isLoading) {
                this.signal = this.normalizeSignal(t.detail.percentX);
                try {
                    this.instraface.continuous.update(this.signal, this.limits[0], this.limits[1])
                } catch {
                    console.warn("not loaded")
                }
            }
        },
        onPointerBoxEnd() {
            if (!this.isLoading) {
                this.isDown = !1;
                try {
                    this.instraface.continuous.release()
                } catch {
                    console.warn("not loaded")
                }
            }
        },
        async waitForLoading() {
            this.isLoading = !0, await Cb(), this.isLoading = !1
        }
    }
});
const vwe = {
        class: "slider-wrapper"
    },
    bwe = ["disabled"],
    Ewe = {
        key: 0,
        class: "test-it"
    },
    Twe = {
        key: 1,
        class: "test-it"
    };

function Swe(t, e, n, r, s, i) {
    const o = Gt("pointerbox"),
        a = Gt("t");
    return B(), H("div", {
        class: nt(["tester", t.classes])
    }, [U("div", vwe, [$e((B(), H("div", {
        class: "slider",
        disabled: t.isLoading,
        "onPointerbox:start": e[0] || (e[0] = (...l) => t.onPointerBoxStart && t.onPointerBoxStart(...l)),
        "onPointerbox:move": e[1] || (e[1] = (...l) => t.onPointerBoxMove && t.onPointerBoxMove(...l)),
        "onPointerbox:end": e[2] || (e[2] = (...l) => t.onPointerBoxEnd && t.onPointerBoxEnd(...l))
    }, [U("div", {
        class: nt(["indicator", {
            visible: t.isDown
        }]),
        style: sn({
            left: `${t.signal*100}%`
        })
    }, null, 6)], 40, bwe)), [
        [o, void 0, void 0, {
            restrict: !0
        }]
    ])]), t.isLoading ? $e((B(), H("p", Ewe, null, 512)), [
        [a, "MENU.LOADING"]
    ]) : $e((B(), H("p", Twe, null, 512)), [
        [a, "MENU.TEST_IT"]
    ])], 2)
}
const wwe = He(ywe, [
        ["render", Swe],
        ["__scopeId", "data-v-880e284b"]
    ]),
    Awe = [{
        lanes: [],
        hit: 0
    }, {
        lanes: [0, 50, 100],
        hit: 14.5
    }, {
        lanes: [0, 30, 50, 70, 100],
        hit: 14.5
    }, {
        lanes: [0, 22, 35, 50, 65, 78, 100],
        hit: 14.5
    }, {
        lanes: [0, 15, 25, 38.33, 50, 61.66, 75, 85, 100],
        hit: 14.5
    }, {
        lanes: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100],
        hit: 14.5
    }, {
        lanes: [0, 8.33, 16.67, 25, 33.33, 41.5, 50, 58.5, 66.67, 75, 83.33, 91.67, 100],
        hit: 12
    }];

function qb(t) {
    const e = Awe[t];
    if (!e) return null;
    const n = [];
    for (let r = 1; r < e.lanes.length; r += 2) n.push({
        left: e.lanes[r - 1],
        center: e.lanes[r],
        right: e.lanes[r + 1]
    });
    return {
        lanes: n,
        hit: e.hit
    }
}
const Owe = st({
    props: {
        beatmap: {
            type: Object,
            required: !0
        },
        instrument: {
            type: Object,
            required: !0
        }
    },
    setup() {
        return {
            instraface: new Bb({
                noFlubs: !0
            })
        }
    },
    data() {
        return {
            isLoading: !0,
            activeCustomizing: null,
            down: []
        }
    },
    computed: {
        hotkeys() {
            return this.$hotkeyManager.mappings.get(this.laneCount)
        },
        laneCount() {
            return this.beatmap.config.laneCount
        },
        layout() {
            return qb(this.laneCount)
        },
        classes() {
            const t = [ur.categorySlugByKey(this.beatmap.config.category)];
            return this.isLoading && t.push("loading"), t
        },
        isPercussion() {
            for (let t = 0; t < this.instrument.config.capabilities.length; t++)
                if (this.instrument.config.capabilities[t] === "DrumRack" || this.instrument.config.capabilities[t] === "PercRolling" || this.instrument.config.capabilities[t] === "Drums" || this.instrument.config.capabilities[t] === "PercSingle" || this.instrument.config.capabilities[t] === "PercRep" || this.instrument.config.capabilities[t] === "PercPitched") return !0;
            return !1
        },
        notes() {
            if (this.isPercussion) switch (this.beatmap.config.laneCount) {
                case 1:
                    return [36];
                case 2:
                    return [36, 38];
                case 3:
                    return [36, 38, 42];
                case 4:
                    return [36, 38, 42, 50];
                case 5:
                    return [36, 38, 42, 45, 50];
                default:
                    return [36, 38, 42, 45, 48, 50]
            }
            const e = 17 + (this.instrument.config.testOctave ?? 3) * 12;
            switch (this.beatmap.config.laneCount) {
                case 1:
                    return [e];
                case 2:
                    return [e, e + 7];
                case 3:
                    return [e, e + 4, e + 7];
                case 4:
                    return [e, e + 2, e + 4, e + 7];
                case 5:
                    return [e, e + 2, e + 4, e + 7, e + 11];
                default:
                    return [e, e + 2, e + 4, e + 7, e + 11, e + 12]
            }
        },
        hitIndicators() {
            const t = [];
            for (let e = 0; e < this.laneCount; e++) {
                const n = {
                    text: this.hotkeys.keys[e],
                    classes: this.down[e] ? ["down"] : [],
                    styles: {
                        left: `${this.layout.lanes[e].center*100}%`
                    }
                };
                this.activeCustomizing && (e < this.activeCustomizing.length ? n.text = this.activeCustomizing[e] : e === this.activeCustomizing.length ? (n.text = "?", n.classes.push("current-customizing")) : (n.text = "?", n.classes.push("pending-customizing"))), n.text === " " && (n.text = this.$t("MENU.SPACEBAR")), n.text.length > 2 && n.classes.push("long"), t.push(n)
            }
            return t
        }
    },
    watch: {
        instrument: {
            handler(t, e) {
                if (!(e && t.config.slug === e.config.slug)) {
                    this.instraface.update({
                        baseUrl: `https://cdn.jackboxgames.com/nopus-opus/instruments/${this.instrument.config.slug}`,
                        config: this.instrument.config
                    }), this.instraface.outNode.volume.value = 8, this.down = [];
                    for (let n = 0; n < this.beatmap.config.laneCount; n++) this.down.push(!1);
                    this.waitForLoading()
                }
            },
            immediate: !0
        }
    },
    mounted() {
        window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp)
    },
    beforeUnmount() {
        window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp), this.instraface.releaseAll(), this.instraface.update({
            config: null
        })
    },
    methods: {
        onPointerDown(t, e) {
            sf(), this.$hotkeyManager.checkEvent(t), this.onDown(e)
        },
        onPointerUp(t, e) {
            this.$hotkeyManager.checkEvent(t), this.onUp(e)
        },
        onKeyDown(t) {
            if (sf(), this.$hotkeyManager.checkEvent(t), t.repeat) return;
            if (this.activeCustomizing) {
                this.setCustomKey(t);
                return
            }
            const e = t.key.toLowerCase(),
                n = this.hotkeys.keys.indexOf(e);
            n !== -1 && this.onDown(n)
        },
        onKeyUp(t) {
            if (this.$hotkeyManager.checkEvent(t), t.repeat) return;
            const e = t.key.toLowerCase(),
                n = this.hotkeys.keys.indexOf(e);
            n !== -1 && this.onUp(n)
        },
        onDown(t) {
            if (this.isLoading) return;
            const e = this.notes[t];
            this.down[t] = !0;
            try {
                this.instraface.discrete.attack([e])
            } catch {
                console.warn("not loaded")
            }
        },
        onUp(t) {
            if (this.isLoading || !this.down[t]) return;
            const e = this.notes[t];
            this.down[t] = !1;
            try {
                this.instraface.discrete.release([e])
            } catch {
                console.warn("not loaded")
            }
        },
        async waitForLoading() {
            this.isLoading = !0, await Cb(), this.isLoading = !1
        },
        setCustomKey(t) {
            if (!this.activeCustomizing) return;
            const e = this.$hotkeyManager.getKeyFromEvent(t);
            e && (this.activeCustomizing.includes(e) || (this.activeCustomizing.push(e), !(this.activeCustomizing.length < this.laneCount) && (this.$hotkeyManager.set(this.laneCount, this.activeCustomizing), this.activeCustomizing = null)))
        },
        onCancelClick() {
            this.activeCustomizing = null
        },
        onResetClick() {
            this.$hotkeyManager.reset(this.laneCount)
        },
        onCustomizeClick() {
            this.activeCustomizing = []
        }
    }
});
const Cwe = {
        class: "notes"
    },
    kwe = ["onPointerdown", "onPointerleave", "onPointerup"],
    Iwe = {
        class: "hotkey"
    },
    Nwe = {
        key: 0,
        class: "test-it"
    },
    xwe = {
        key: 1,
        class: "test-it"
    };

function Pwe(t, e, n, r, s, i) {
    const o = Gt("t");
    return B(), H("div", {
        class: nt(["tester", t.classes])
    }, [U("div", Cwe, [(B(!0), H(lt, null, gn(t.hitIndicators, (a, l) => (B(), H("div", {
        key: l,
        class: "cell"
    }, [U("button", {
        class: nt(["note", a.classes]),
        onPointerdown: u => t.onPointerDown(u, l),
        onPointerleave: u => t.onPointerUp(u, l),
        onPointerup: u => t.onPointerUp(u, l)
    }, [U("span", Iwe, rt(a.text), 1)], 42, kwe)]))), 128))]), t.isLoading ? $e((B(), H("p", Nwe, null, 512)), [
        [o, "MENU.LOADING"]
    ]) : $e((B(), H("p", xwe, null, 512)), [
        [o, "MENU.TEST_IT"]
    ]), t.activeCustomizing ? $e((B(), H("button", {
        key: 2,
        class: "customize",
        onClick: e[0] || (e[0] = (...a) => t.onCancelClick && t.onCancelClick(...a))
    }, null, 512)), [
        [o, "MENU.CANCEL"]
    ]) : t.hotkeys.isCustom ? $e((B(), H("button", {
        key: 3,
        class: "customize",
        onClick: e[1] || (e[1] = (...a) => t.onResetClick && t.onResetClick(...a))
    }, null, 512)), [
        [o, "MENU.RESET"]
    ]) : $e((B(), H("button", {
        key: 4,
        class: "customize",
        onClick: e[2] || (e[2] = (...a) => t.onCustomizeClick && t.onCustomizeClick(...a))
    }, null, 512)), [
        [o, "MENU.CUSTOMIZE"]
    ])], 2)
}
const Rwe = He(Owe, [
        ["render", Pwe],
        ["__scopeId", "data-v-9f899220"]
    ]),
    Mwe = st({
        props: {
            title: {
                type: String,
                required: !1
            },
            titleKey: {
                type: String,
                required: !1
            }
        },
        emits: {
            didRequestClose: () => !0
        },
        methods: {
            onCloseClick() {
                this.$emit("didRequestClose")
            }
        }
    });
const Dwe = {
        class: "contents"
    },
    $we = {
        class: "title-container"
    },
    Lwe = {
        key: 0,
        class: "title"
    },
    Fwe = {
        key: 1,
        class: "title"
    },
    Uwe = {
        class: "content-container"
    };

function Bwe(t, e, n, r, s, i) {
    const o = Gt("t");
    return B(), At(Ta, {
        name: "modal"
    }, {
        default: $i(() => [U("div", {
            class: "modal",
            onClick: e[0] || (e[0] = Oi((...a) => t.onCloseClick && t.onCloseClick(...a), ["self"])),
            onKeyup: e[1] || (e[1] = E2((...a) => t.onCloseClick && t.onCloseClick(...a), ["esc"]))
        }, [U("div", Dwe, [U("div", $we, [t.title ? (B(), H("h3", Lwe, rt(t.title), 1)) : Pe("", !0), t.titleKey ? $e((B(), H("h3", Fwe, null, 512)), [
            [o, t.titleKey]
        ]) : Pe("", !0)]), U("div", Uwe, [g7(t.$slots, "default", {}, void 0, !0)])])], 32)]),
        _: 3
    })
}
const fI = He(Mwe, [
        ["render", Bwe],
        ["__scopeId", "data-v-3d94c627"]
    ]),
    qwe = st({
        components: {
            AvatarSVG: K3,
            BaseModal: fI
        },
        props: {
            info: {
                type: Object,
                required: !0
            },
            players: {
                type: Object,
                required: !0
            },
            responseKey: {
                type: String,
                required: !0
            }
        },
        emits: {
            didRequestClose: () => !0
        },
        computed: {
            choices() {
                return Object.keys(this.players).filter(t => !(t === `${this.info.id}` || this.info.inSong && this.players[t].inSong === !1)).map(t => {
                    const e = this.players[t];
                    return {
                        avatar: e.avatar,
                        id: parseInt(t, 10),
                        label: e.name
                    }
                })
            }
        },
        methods: {
            onCloseClick() {
                this.$emit("didRequestClose")
            },
            async onChoiceClick(t) {
                try {
                    await this.$ecast.updateObject(this.responseKey, {
                        changeVip: t
                    })
                } catch (e) {
                    this.$handleEcastError(e)
                }
                this.$emit("didRequestClose")
            }
        }
    }),
    Gwe = ["onClick"];

function Vwe(t, e, n, r, s, i) {
    const o = Ge("AvatarSVG"),
        a = Ge("BaseModal"),
        l = Gt("t");
    return B(), At(a, {
        "title-key": "MENU.CHOOSE_HOST"
    }, {
        default: $i(() => [(B(!0), H(lt, null, gn(t.choices, (u, f) => (B(), H("button", {
            key: f,
            class: "choice has-icon",
            onClick: Oi(d => t.onChoiceClick(u.id), ["prevent"])
        }, [mn(rt(u.label) + " ", 1), Ve(o, {
            focusable: "false",
            avatar: u.avatar,
            class: "icon"
        }, null, 8, ["avatar"])], 8, Gwe))), 128)), $e(U("button", {
            class: "secondary close",
            onClick: e[0] || (e[0] = (...u) => t.onCloseClick && t.onCloseClick(...u))
        }, null, 512), [
            [l, "MENU.NEVERMIND"]
        ])]),
        _: 1
    }, 8, ["title-key"])
}
const Gb = He(qwe, [
        ["render", Vwe]
    ]),
    jwe = st({
        props: {
            category: {
                type: String,
                required: !0
            },
            selected: {
                type: Boolean,
                required: !1
            },
            disabled: {
                type: Boolean,
                required: !1
            },
            classes: {
                type: Array,
                required: !1
            }
        },
        computed: {
            iconClasses() {
                const t = this.classes ? [...this.classes] : [];
                return t.push(ur.categorySlugByKey(this.category)), this.selected && t.push("selected"), this.disabled && t.push("disabled"), t
            }
        }
    });
const Wwe = {
        key: 0,
        x: "-3",
        y: "-3",
        width: "36",
        height: "56",
        rx: "15"
    },
    Hwe = {
        key: 1,
        d: "m29.25,8.63l-2.29-5.43-5.14-2.5-14,.59-5.07,1.91L.25,8.77l.21,32.38,2.5,5.07,4.5,2.72c3.63.05,11.05.22,14.64.37,0,0,5.29-2.57,5.29-2.57l2.36-5.36-.5-32.75m-20.21-1.4l1.14-.73,5.86,3.23-5.57,2.86-3.57-.88-3-2.13,5.14-2.35m5.29,9.84l5.64-2.86,5.93,2.86-5.57,3.74c-1.36-1.12-4.41-2.97-6-3.74m5.64,18.94l-5.86-3.45,5.93-2.57,5.43,2.72-5.5,3.3m-3.93-10.72l-5.71,3.3-6.57-3.52,6.5-3.3,5.79,3.52m-11.79,15.57l5.57-2.94,5.29,3.01-4.71,3.6-6.14-3.67Z"
    },
    Ywe = {
        key: 2,
        d: "m29.68,8.48l-2.64-5.51-4.86-2.28-2.64.07.29,37.08-.57,2.79-4.21,1.91-2.14-.44-2.21-1.69L10.39.84h-2.5L3.32,3.27l-2.21,4.77L.32,41.59l2.57,4.99,5.57,2.57,7.29.15h6.21l5.21-2.28,2.21-5.58.29-32.97Z"
    },
    zwe = {
        key: 3,
        d: "m30,24.67c-.25-4.29-.77-17.9-2.14-21.81C24.2,2.19,12.09.65,8.21.15L2.93,3.67,0,8.66c.46,3.96-.7,36.11,2.79,38.55l5.5,2.35,13.79.29,5.21-3.3c2.33-2.9,2.39-18.28,2.71-21.88m-4.29-14.83l.43,2.94-2.57,2.79-3.5-1.54-.21-4.04,2.86-1.62,3,1.47m-7.43,7.71l-5.07-4.99.86-1.32,11.64,9.99-16.21,19.46-1.21-.88,9.14-12.78,5.86-5.58-5-3.89m-12.93,14.83v-3.89l3.64-1.03,2.5,2.28-.64,3.01-2.86,1.84-2.64-2.2m12.29-13l.43,2.79-1.79,2.28-3.57-.29-1-3.16,2.71-3.3,3.21,1.69m-1.21,16.96l1.86,2.42.36,3.16-4,1.25-1.79-1.69.14-3.08,3.43-2.06Z"
    },
    Kwe = {
        key: 4,
        d: "m29.89,9.18l-2-6.46L21.89.22l-13.43.29L2.61,3.23.11,9.1c.35,4.39-1.14,34.72,2.21,37.81l6,2.28c.89.07,6.71.44,7.43.59,0,0,11.43-2.94,11.43-2.94,2.67-3.14,2.36-33.38,2.71-37.67m-5.57-2.35l-.21,5.14h-8.21l.36-4.99c2.06.56,6,.26,8.07-.15M6.61,17.18l7.43-.07c.14.15.1,1.81-.14,4.99l-8.07.15,1-2.79-.21-2.28m-.79,15.86l-.21-4.77,8.5-.37.14,5.58-4.64-1.25-3.79.81m8.29,5.95l-.64,2.72.79,2.72-7.79-.44.14-3.96,7.5-1.03Z"
    },
    Zwe = {
        key: 5,
        d: "m28.86,8.33l-2-5.21-1.57-.81-.43,18.58-1.21,1.98-2.43.29-.79-2.42c.09-1.68-.06-19.16.71-20.19h-4.21l.07,22.47-2.79-.37-1.36-2.13L13.21.48C7.52.2,7.54.35,2.57,2.97-.28,5.94.98,37.56.71,41.74c0,0,2.21,4.48,2.21,4.48l3.21,1.47-.71-18.87.93-1.32,2.43.66.43,20.56,3.86.37c.27-1.82-.44-21.07,1.57-21.88l1.86.59,1,3.01-.64,11.16.5,7.42,4.43.22,5.57-2.72c3.16-3.36,1.28-34.01,1.5-38.55Z"
    },
    Xwe = {
        key: 6,
        d: "m28.96,8.33l-1.79-5.36-4.64-2.2L7.68.4,2.89,3.34.39,9.07l.07,32.01,2.21,4.48,5.57,3.16,6.57.88c6.65-.26,6.68.12,12.5-3.45l2.29-5.43-.64-32.38m-7.79,14.9l-.14.44-3.36,3.74.93,1.84-.21,2.64-3.57,1.54-.93-.66-3.14,4.41.64,3.82-2.43,1.47-3.29-.59-1.79-2.86,2.29-3.08,2.5.07,3.5-4.48-.86-.66.57-3.23,3.79-.59c.23-.32,4.05-5.21,4.07-5.43l-.79-.81.79-2.35-.21-.15-3.43-3.82-1.71.15-2.5-1.54-.29-4.26,3.5-1.47c-.14.22,1.47,1.2,1.86,1.4,0,0,1.57,2.35,1.57,2.35l-.57,2.35,3.86,3.82,2.57-.37,2.07,3.45-2.29,3.16-1.93.81-1.07-1.1Z"
    },
    Qwe = {
        key: 7,
        d: "m29.89,8.74l-2.64-5.51-5.14-3.23-13.93.73L2.32,2.79.11,9.18l.07,32.38,2.57,5.51,5.43,2.94c5.73-.06,13.81-1.07,19.29-2.79,3.22-2.49,2.05-34.59,2.43-38.47m-3.21,13c-1.55.8-3.89,4.5-4.79,5.95l.21,7.49-6.64-2.5-7.64,2.5,1.07-5.58-2.21-4.7-2.86-3.16,3-1.47,4.43-.81,4.07-6.61c.1.24,1.48,2.37,4.14,6.39l7.21,2.5Z"
    };

function Jwe(t, e, n, r, s, i) {
    return B(), H("svg", {
        viewBox: "0 0 30 50",
        class: nt(t.iconClasses)
    }, [t.selected ? (B(), H("rect", Wwe)) : Pe("", !0), t.category === "AuxPercussion" ? (B(), H("path", Hwe)) : t.category === "Bass" ? (B(), H("path", Ywe)) : t.category === "CounterMelody" ? (B(), H("path", zwe)) : t.category === "Drums" ? (B(), H("path", Kwe)) : t.category === "Harmony" ? (B(), H("path", Zwe)) : t.category === "Melody" ? (B(), H("path", Xwe)) : t.category === "Signature" ? (B(), H("path", Qwe)) : Pe("", !0)], 2)
}
const dI = He(jwe, [
        ["render", Jwe],
        ["__scopeId", "data-v-724f8d43"]
    ]),
    e8e = st({
        props: {
            lanes: {
                type: Number,
                required: !1
            }
        },
        computed: {
            viewbox() {
                return this.lanes === 1 ? "0 0 30 150" : this.lanes === 2 ? "0 0 80 150" : this.lanes === 3 ? "0 0 130 150" : this.lanes === 5 ? "0 0 230 150" : this.lanes === 6 ? "0 0 280 150" : "0 0 180 150"
            }
        }
    });
const t8e = ["viewBox"],
    n8e = {
        key: 0,
        width: "30",
        height: "150",
        rx: "8",
        ry: "8"
    },
    r8e = {
        key: 1,
        x: "50",
        width: "30",
        height: "150",
        rx: "8",
        ry: "8"
    },
    s8e = {
        key: 2,
        x: "100",
        width: "30",
        height: "150",
        rx: "8",
        ry: "8"
    },
    i8e = {
        key: 3,
        x: "150",
        width: "30",
        height: "150",
        rx: "8",
        ry: "8"
    },
    o8e = {
        key: 4,
        x: "200",
        width: "30",
        height: "150",
        rx: "8",
        ry: "8"
    },
    a8e = {
        key: 5,
        x: "250",
        width: "30",
        height: "150",
        rx: "8",
        ry: "8"
    },
    c8e = {
        key: 6,
        y: "66",
        width: "180",
        height: "18",
        rx: "9",
        ry: "9"
    },
    l8e = {
        key: 7,
        cx: "40",
        cy: "75",
        r: "25"
    };

function u8e(t, e, n, r, s, i) {
    return B(), H("svg", {
        viewBox: t.viewbox
    }, [t.lanes ? (B(), H("rect", n8e)) : Pe("", !0), t.lanes && t.lanes > 1 ? (B(), H("rect", r8e)) : Pe("", !0), t.lanes && t.lanes > 2 ? (B(), H("rect", s8e)) : Pe("", !0), t.lanes && t.lanes > 3 ? (B(), H("rect", i8e)) : Pe("", !0), t.lanes && t.lanes > 4 ? (B(), H("rect", o8e)) : Pe("", !0), t.lanes && t.lanes > 5 ? (B(), H("rect", a8e)) : Pe("", !0), t.lanes ? Pe("", !0) : (B(), H("rect", c8e)), t.lanes ? Pe("", !0) : (B(), H("circle", l8e))], 8, t8e)
}
const h8e = He(e8e, [
        ["render", u8e],
        ["__scopeId", "data-v-8ddc6f95"]
    ]),
    f8e = {},
    d8e = {
        viewBox: "0 0 65 100"
    },
    p8e = U("path", {
        d: "m65,5.22v89.56c0,4.32-4.68,6.76-7.91,4.13L1.84,53.88c-2.45-2-2.45-5.76,0-7.76L57.09,1.09c3.23-2.63,7.91-.19,7.91,4.13Z"
    }, null, -1),
    m8e = [p8e];

function g8e(t, e) {
    return B(), H("svg", d8e, m8e)
}
const _8e = He(f8e, [
        ["render", g8e]
    ]),
    y8e = st({
        components: {
            ChangeVIP: Gb,
            Choice: n3e,
            ContinuousTester: wwe,
            DiscreteTester: Rwe,
            PlayerHeader: zf,
            CategorySVG: dI,
            LanesSVG: h8e,
            LeftArrowSVG: _8e
        },
        props: {
            beatmaps: {
                type: Object,
                required: !0
            },
            info: {
                type: Object,
                required: !0
            },
            instruments: {
                type: Object,
                required: !0
            },
            players: {
                type: Object,
                required: !0
            },
            player: {
                type: Object,
                required: !0
            }
        },
        data() {
            return {
                audienceId: null,
                showChangeVIP: !1,
                selectedCategory: null
            }
        },
        computed: {
            selectedId() {
                return this.audienceId ? this.audienceId : `${this.info.beatmapSlug}:${this.info.instrumentSlug}`
            },
            selectedChoice() {
                const t = this.standardChoices.find(e => e.isSelected);
                if (t) return t;
                for (let e = 0; e < this.unlockedChoices.length; e++) {
                    const n = this.unlockedChoices[e].choices;
                    for (let r = 0; r < n.length; r++) {
                        const s = n.find(i => i.isSelected);
                        if (s) return s
                    }
                }
                return this.standardChoices[0]
            },
            selectedUnlocked() {
                return !this.unlockedChoices.length || !this.selectedCategory ? null : this.unlockedChoices.find(t => t.category === this.selectedCategory) ?? null
            },
            standardChoices() {
                const t = this.player.instruments.instruments.map((e, n) => {
                    const r = `${e.beatmapSlug}:${e.instrumentSlug}`;
                    return {
                        beatmap: this.beatmaps[e.beatmapSlug],
                        id: r,
                        index: n,
                        instrument: this.instruments[e.instrumentSlug],
                        instrumentSlug: e.instrumentSlug,
                        isSelected: this.selectedId === r,
                        isUnlockable: !1,
                        label: e.instrumentName,
                        players: this.mappedPlayers[r] ?? []
                    }
                });
                return t.sort((e, n) => e.beatmap.config.difficulty === n.beatmap.config.difficulty ? e.beatmap.config.category === n.beatmap.config.category ? e.index - n.index : e.beatmap.config.category < n.beatmap.config.category ? -1 : 1 : e.beatmap.config.difficulty - n.beatmap.config.difficulty), t
            },
            unlockedChoices() {
                return this.player.unlockedInstruments ? Object.keys(this.player.unlockedInstruments).map(n => {
                    const r = this.beatmaps[n].config.category,
                        s = {
                            isSelected: this.selectedCategory === r,
                            sortOrder: ur.categorySortOrderByKey(r),
                            classes: [ur.categorySlugByKey(r)],
                            category: r,
                            choices: []
                        };
                    return s.choices = this.player.unlockedInstruments[n].map((i, o) => {
                        const a = i.response,
                            [l, u] = i.response.split(":");
                        return {
                            beatmap: this.beatmaps[l],
                            id: a,
                            index: o,
                            instrumentSlug: u,
                            isSelected: this.selectedId === a,
                            isUnlockable: !0,
                            label: i.name,
                            players: this.mappedPlayers[a] ?? []
                        }
                    }), s
                }).sort((n, r) => n.sortOrder - r.sortOrder) : []
            },
            mappedPlayers() {
                const t = {};
                return Object.values(this.players).forEach(e => {
                    if (!e.beatmapSlug || !e.instrumentSlug) return;
                    const n = `${e.beatmapSlug}:${e.instrumentSlug}`;
                    t[n] || (t[n] = []), t[n].push(e)
                }), t
            },
            details() {
                const t = this.selectedChoice.beatmap;
                return {
                    beatmap: t,
                    category: {
                        slug: ur.categoryI18ByKey(t.config.category),
                        key: t.config.category,
                        i18n: ur.categoryI18ByKey(t.config.category)
                    },
                    difficulty: {
                        i18n: ur.difficultyI18ByNumber(t.config.difficulty)
                    },
                    instrument: this.selectedChoice.instrument,
                    label: this.selectedChoice.label,
                    laneCount: {
                        icon: t.config.laneCount ?? null,
                        label: t.config.laneCount ?? ""
                    }
                }
            }
        },
        mounted() {
            this.info.isAudience && this.setAudienceChoice(this.standardChoices[0])
        },
        methods: {
            onDidRequestChangeVIP() {
                this.showChangeVIP = !0
            },
            onDidRequestModalClose() {
                this.showChangeVIP = !1
            },
            async onBackClick() {
                if (this.player.responseKey) try {
                    await this.$ecast.updateObject(this.player.responseKey, {
                        backToSongSelect: !0
                    })
                } catch (t) {
                    this.$handleEcastError(t)
                }
            },
            onUnlockedNavClick(t) {
                if (this.selectedCategory === t) {
                    this.selectedCategory = null;
                    return
                }
                this.selectedCategory = t
            },
            async onChoiceClick(t) {
                if (!this.player.responseKey) {
                    this.setAudienceChoice(t);
                    return
                }
                try {
                    await this.$ecast.updateObject(this.player.responseKey, {
                        selectInstrument: {
                            beatmapSlug: t.beatmap.config.slug,
                            instrumentSlug: t.instrumentSlug
                        }
                    })
                } catch (e) {
                    this.$handleEcastError(e)
                }
            },
            setAudienceChoice(t) {
                this.audienceId = t.id, xn.set("audienceId", t.id, "code")
            },
            async onStartClick() {
                if (this.player.responseKey) try {
                    await this.$ecast.updateObject(this.player.responseKey, {
                        startSong: !0
                    })
                } catch (t) {
                    this.$handleEcastError(t)
                }
            }
        }
    });
const v8e = {
        class: "instrument-select"
    },
    b8e = {
        class: "constrain menu has-header"
    },
    E8e = {
        class: "title-wrapper"
    },
    T8e = {
        key: 0,
        class: "title"
    },
    S8e = {
        key: 1,
        class: "title"
    },
    w8e = ["aria-label"],
    A8e = ["aria-label"],
    O8e = {
        class: "choices"
    },
    C8e = {
        key: 0,
        class: "unlocked-nav"
    },
    k8e = {
        key: 0,
        class: "label"
    },
    I8e = ["onClick"],
    N8e = {
        class: "details"
    },
    x8e = {
        class: "info"
    },
    P8e = {
        class: "name"
    },
    R8e = {
        class: "label"
    },
    M8e = {
        class: "value"
    },
    D8e = {
        class: "box difficulty"
    },
    $8e = {
        class: "label"
    },
    L8e = {
        class: "value"
    },
    F8e = {
        class: "box lanes"
    },
    U8e = {
        class: "label"
    },
    B8e = {
        class: "value"
    };

function q8e(t, e, n, r, s, i) {
    const o = Ge("LeftArrowSVG"),
        a = Ge("Choice"),
        l = Ge("CategorySVG"),
        u = Ge("LanesSVG"),
        f = Ge("ContinuousTester"),
        d = Ge("DiscreteTester"),
        p = Ge("PlayerHeader"),
        _ = Ge("ChangeVIP"),
        v = Gt("t");
    return B(), H("div", v8e, [U("div", b8e, [U("div", E8e, [t.selectedUnlocked ? $e((B(), H("h3", T8e, null, 512)), [
        [v, "MENU.UNLOCKED"]
    ]) : $e((B(), H("h3", S8e, null, 512)), [
        [v, "MENU.CHOOSE_INSTRUMENT"]
    ]), t.selectedUnlocked ? (B(), H("button", {
        key: 2,
        "aria-label": t.$t("ACTION.CLOSE"),
        class: "close",
        onClick: e[0] || (e[0] = y => t.onUnlockedNavClick(null))
    }, [Ve(o)], 8, w8e)) : t.info.isVip ? (B(), H("button", {
        key: 3,
        "aria-label": t.$t("ACTION.BACK"),
        class: "back",
        onClick: e[1] || (e[1] = (...y) => t.onBackClick && t.onBackClick(...y))
    }, [Ve(o)], 8, A8e)) : Pe("", !0)]), U("div", {
        class: nt(["choices-wrapper", {
            collapsed: t.selectedUnlocked
        }])
    }, [U("div", O8e, [(B(!0), H(lt, null, gn(t.standardChoices, y => (B(), At(a, {
        key: y.id,
        choice: y,
        onClick: Oi(g => t.onChoiceClick(y), ["prevent"])
    }, null, 8, ["choice", "onClick"]))), 128))])], 2), t.unlockedChoices.length ? (B(), H("div", C8e, [t.selectedUnlocked ? Pe("", !0) : $e((B(), H("p", k8e, null, 512)), [
        [v, "MENU.UNLOCKED"]
    ]), (B(!0), H(lt, null, gn(t.unlockedChoices, y => (B(), H("button", {
        key: y.category,
        class: nt(["unlocked-category", y.classes]),
        onClick: g => t.onUnlockedNavClick(y.category)
    }, [U("span", null, rt(y.choices.length), 1), Ve(l, {
        category: y.category,
        selected: y.isSelected,
        class: "icon"
    }, null, 8, ["category", "selected"])], 10, I8e))), 128))])) : Pe("", !0), U("div", {
        class: nt(["choices-wrapper", {
            collapsed: !t.selectedUnlocked
        }])
    }, [t.selectedUnlocked ? (B(), H("div", {
        key: 0,
        class: nt(["choices unlocked", t.selectedUnlocked.classes])
    }, [(B(!0), H(lt, null, gn(t.selectedUnlocked.choices, y => (B(), At(a, {
        key: y.id,
        choice: y,
        onClick: Oi(g => t.onChoiceClick(y), ["prevent"])
    }, null, 8, ["choice", "onClick"]))), 128))], 2)) : Pe("", !0)], 2), U("div", N8e, [U("div", x8e, [U("p", P8e, rt(t.details.label), 1), U("div", {
        class: nt(["box part", t.details.category.slug])
    }, [Ve(l, {
        category: t.details.category.key,
        class: "icon"
    }, null, 8, ["category"]), $e(U("p", R8e, null, 512), [
        [v, "MENU.SONG_PART"]
    ]), $e(U("p", M8e, null, 512), [
        [v, t.details.category.i18n]
    ])], 2), U("div", D8e, [$e(U("p", $8e, null, 512), [
        [v, "MENU.DIFFICULTY"]
    ]), $e(U("p", L8e, null, 512), [
        [v, t.details.difficulty.i18n]
    ])]), U("div", F8e, [$e(U("p", U8e, null, 512), [
        [v, "MENU.LANES"]
    ]), U("p", B8e, [Ve(u, {
        lanes: t.details.laneCount.icon,
        class: "icon"
    }, null, 8, ["lanes"]), mn(" " + rt(t.details.laneCount.label), 1)])])]), t.details.instrument && t.details.beatmap.config.type === "Continuous" ? (B(), At(f, {
        key: 0,
        beatmap: t.details.beatmap,
        instrument: t.details.instrument
    }, null, 8, ["beatmap", "instrument"])) : t.details.instrument && t.details.beatmap.config.type === "Discrete" ? (B(), At(d, {
        key: 1,
        beatmap: t.details.beatmap,
        instrument: t.details.instrument
    }, null, 8, ["beatmap", "instrument"])) : Pe("", !0)]), t.info.isVip ? $e((B(), H("button", {
        key: 1,
        class: "primary",
        onClick: e[2] || (e[2] = (...y) => t.onStartClick && t.onStartClick(...y))
    }, null, 512)), [
        [v, "MENU.START_SONG"]
    ]) : Pe("", !0)]), Ve(p, {
        info: t.info,
        players: t.players,
        "is-vip": t.info.isVip && !t.info.isSolo,
        "response-key": t.player.responseKey,
        onDidRequestChangeVip: t.onDidRequestChangeVIP
    }, null, 8, ["info", "players", "is-vip", "response-key", "onDidRequestChangeVip"]), t.showChangeVIP && t.player.responseKey ? (B(), At(_, {
        key: 0,
        info: t.info,
        players: t.players,
        "response-key": t.player.responseKey,
        onDidRequestClose: t.onDidRequestModalClose
    }, null, 8, ["info", "players", "response-key", "onDidRequestClose"])) : Pe("", !0)])
}
const G8e = He(y8e, [
        ["render", q8e],
        ["__scopeId", "data-v-1bb00c67"]
    ]),
    V8e = st({
        components: {
            Gallery: mO
        },
        props: {
            artifact: {
                type: Object
            },
            info: {
                type: Object,
                required: !0
            },
            player: {
                type: Object,
                required: !0
            }
        },
        data({
            player: t
        }) {
            return {
                initialKind: t.kind,
                status: "waiting",
                GalleryView: CC
            }
        },
        mounted() {
            this.$pauseEcastUpdates(null, ["didDisconnect", "roomDidExit"]), this.$ecastManager.on("didEmitPausedEvent", this.onDidEmitPausedEvent)
        },
        beforeUnmount() {
            this.$ecastManager.off("didEmitPausedEvent", this.onDidEmitPausedEvent)
        },
        methods: {
            async onBackClick() {
                if (this.player.responseKey) try {
                    await this.$ecast.updateObject(this.player.responseKey, {
                        back: !0
                    })
                } catch (t) {
                    this.$handleEcastError(t)
                }
            },
            onDisconnectedClick() {
                window.location.reload()
            },
            onDidEmitPausedEvent(t) {
                this.status !== "disconnected" && (t !== "didDisconnect" && t !== "roomDidExit" || (this.status = "disconnected"))
            }
        }
    });
const j8e = {
        class: "post-game-actions constrain"
    },
    W8e = {
        class: "message"
    },
    H8e = {
        class: "message"
    };

function Y8e(t, e, n, r, s, i) {
    var l, u;
    const o = Ge("Gallery"),
        a = Gt("t");
    return B(), At(o, {
        view: t.GalleryView,
        "artifact-id": (l = t.artifact) == null ? void 0 : l.artifactId,
        "category-id": (u = t.artifact) == null ? void 0 : u.categoryId,
        context: "postGame"
    }, {
        default: $i(() => [U("div", j8e, [t.info.isVip && t.status === "waiting" ? (B(), H(lt, {
            key: 0
        }, [$e(U("p", W8e, null, 512), [
            [a, "POST_GAME.PLAY_AGAIN"]
        ]), $e(U("button", {
            class: "action button primary",
            onClick: e[0] || (e[0] = (...f) => t.onBackClick && t.onBackClick(...f))
        }, null, 512), [
            [a, "MENU.BACK_TO_MENU"]
        ])], 64)) : (B(), H(lt, {
            key: 1
        }, [$e(U("p", H8e, null, 512), [
            [a, "POST_GAME.THANKS_FOR_PLAYING"]
        ]), $e(U("button", {
            class: "action button primary",
            onClick: e[1] || (e[1] = (...f) => t.onDisconnectedClick && t.onDisconnectedClick(...f))
        }, null, 512), [
            [a, "POST_GAME.BUTTON_GO_TO_JACKBOX"]
        ])], 64))])]),
        _: 1
    }, 8, ["view", "artifact-id", "category-id"])
}
const z8e = He(V8e, [
        ["render", Y8e],
        ["__scopeId", "data-v-69b53ab1"]
    ]),
    K8e = st({
        components: {
            PlayerHeader: zf
        },
        props: {
            info: {
                type: Object,
                required: !0
            },
            player: {
                type: Object,
                required: !0
            }
        }
    });
const Z8e = {
        class: "playback"
    },
    X8e = {
        class: "constrain has-header"
    },
    Q8e = {
        class: "message-wrapper"
    },
    J8e = {
        class: "title"
    },
    e7e = {
        class: "sub"
    };

function t7e(t, e, n, r, s, i) {
    const o = Ge("PlayerHeader"),
        a = Gt("t");
    return B(), H("div", Z8e, [U("div", X8e, [U("div", Q8e, [$e(U("p", J8e, null, 512), [
        [a, "PLAYBACK.SIT_BACK"]
    ]), $e(U("p", e7e, null, 512), [
        [a, "PLAYBACK.LOOK_UP"]
    ])])]), Ve(o, {
        info: t.info
    }, null, 8, ["info"])])
}
const n7e = He(K8e, [
    ["render", t7e],
    ["__scopeId", "data-v-b305fa7a"]
]);
class r7e {
    constructor() {
        ye(this, "idCounter", 1);
        ye(this, "idMap", new Map);
        ye(this, "fnMap", new Map);
        ye(this, "times", [])
    }
    schedule(e, n) {
        const r = this.idCounter,
            s = this.idMap.get(n);
        return s ? s.push(this.idCounter) : (this.idMap.set(n, [r]), this.times.push(n), this.times.sort((i, o) => i - o)), this.fnMap.set(r, e), this.idCounter += 1, r
    }
    cancel(e) {
        this.fnMap.delete(e)
    }
    call(e) {
        const n = this.fnMap.get(e);
        this.fnMap.delete(e), n && n()
    }
    check(e) {
        let n = 0;
        for (let r = 0; r < this.times.length && !(this.times[r] > e); r++) {
            n += 1;
            const s = this.idMap.get(this.times[r]);
            s && s.forEach(i => this.call(i))
        }
        this.times.splice(0, n)
    }
}
class pI {
    constructor(e) {
        ye(this, "criteria");
        ye(this, "difficulty");
        ye(this, "duration");
        ye(this, "guide");
        ye(this, "instraface");
        ye(this, "isAudience");
        ye(this, "isLoaded", ts(!1));
        ye(this, "missThreshold");
        ye(this, "audienceReportAt", 0);
        ye(this, "inputs", new Map);
        ye(this, "manifest", new Map);
        ye(this, "callbackMap", new Map);
        ye(this, "scheduler", new r7e);
        ye(this, "noteQualityScoreFactors");
        ye(this, "scorePerHighestCombo");
        ye(this, "scorePoolPerDifficulty");
        ye(this, "successPercentage");
        ye(this, "minimumDisplayCombo");
        ye(this, "currentCombo", 0);
        ye(this, "accuracy", 0);
        ye(this, "longestCombo", 0);
        ye(this, "pastNotes", 0);
        ye(this, "qualities", [0, 0, 0, 0]);
        ye(this, "appearThreshold", 3e3);
        ye(this, "baseTime");
        ye(this, "disappearThreshold", 1e3);
        ye(this, "hasStarted", !1);
        ye(this, "isComplete", !1);
        ye(this, "isRunning", !1);
        ye(this, "lastTime", 0);
        ye(this, "currentTime", 0);
        ye(this, "progress", 0);
        ye(this, "pendingInputs", []);
        ye(this, "reportInterval");
        ye(this, "responseKey");
        ye(this, "wsClient");
        this.criteria = e.criteria, this.difficulty = e.beatmap.difficulty, this.duration = e.duration, this.guide = e.guide, this.isAudience = e.isAudience, this.missThreshold = e.criteria.time[e.criteria.time.length - 1], this.noteQualityScoreFactors = e.noteQualityScoreFactors, this.scorePerHighestCombo = e.scorePerHighestCombo, this.scorePoolPerDifficulty = e.scorePoolPerDifficulty, this.successPercentage = e.successPercentage, this.minimumDisplayCombo = e.minimumDisplayCombo, this.currentTime = e.offset ?? 0, this.responseKey = e.responseKey, this.wsClient = e.wsClient;
        const n = `https://cdn.jackboxgames.com/nopus-opus/instruments/${e.instrument.slug}`;
        this.instraface = new Bb({
            baseUrl: n,
            config: e.instrument
        }), this.instraface.outNode.volume.value = 8, this.isAudience || (this.reportInterval = window.setInterval(() => {
            this.onReportInterval()
        }, 2e3)), this.parseInputs(e.beatmap), this.awaitForLoaded()
    }
    get now() {
        return this.baseTime ? Math.round(window.performance.now() - this.baseTime) : 0
    }
    get scorePool() {
        return this.scorePoolPerDifficulty[this.difficulty - 1]
    }
    millisecondsToY(e) {
        return e / this.duration
    }
    durationToHeight(e) {
        return e / this.duration
    }
    async awaitForLoaded() {
        await Cb(), this.isLoaded.value = !0
    }
    start(e) {
        this.baseTime = Math.round(window.performance.now()), e !== void 0 && (this.currentTime = e, this.baseTime -= e), this.hasStarted = !0, this.isRunning = !0, window.requestAnimationFrame(this.onRequestAnimationFrame.bind(this))
    }
    stop() {
        this.isRunning = !1
    }
    destroy() {
        var e;
        this.stop(), this.callbackMap.clear(), (e = this.instraface) == null || e.update({
            config: null
        }), delete this.instraface, this.reportInterval && (window.clearInterval(this.reportInterval), delete this.reportInterval)
    }
    schedule(e, n) {
        return this.scheduler.schedule(e, n + this.now)
    }
    on(e, n) {
        const r = this.callbackMap.get(e) ?? new Set;
        r.size || this.callbackMap.set(e, r), r.add(n)
    }
    off(e, n) {
        const r = this.callbackMap.get(e);
        r && r.delete(n)
    }
    emit(e) {
        var n;
        (n = this.callbackMap.get(e.type)) == null || n.forEach(r => r(e))
    }
    scoreInput(e) {
        if (this.pastNotes += 1, e === null) {
            this.qualities[3] += 1, this.currentCombo = 0;
            return
        }
        this.accuracy += this.noteQualityScoreFactors[e], this.currentCombo += 1, this.qualities[e] += 1, this.currentCombo > this.longestCombo && (this.longestCombo = this.currentCombo)
    }
    onRequestAnimationFrame() {
        this.isRunning && (this.onFrame(), window.requestAnimationFrame(this.onRequestAnimationFrame.bind(this)))
    }
    onFrame() {
        const e = this.now;
        this.emit({
            type: "frame",
            now: e
        }), e >= this.duration ? this.onEnd() : (this.currentTime = this.now, this.progress = this.millisecondsToY(this.currentTime));
        for (let n = this.lastTime; n < this.currentTime; n++) this.scheduler.check(n), this.processMillisecond(n);
        this.lastTime = this.currentTime
    }
    addInput(e, n) {
        Object.keys(n).forEach(i => {
            const o = n[i];
            this.manifest.get(o) || this.manifest.set(o, new Map), this.manifest.get(o).get(i) || this.manifest.get(o).set(i, new Set), this.manifest.get(o).get(i).add(e)
        });
        const s = this.inputs.get(n.start) ?? new Set;
        s.add(e), this.inputs.set(n.start, s)
    }
    processMillisecond(e) {
        var r, s, i, o, a;
        e === this.audienceReportAt && (this.saveAudienceScore(), this.reportAudienceAccuracy());
        const n = this.manifest.get(e);
        n && ((r = n.get("appear")) == null || r.forEach(this.inputDidAppear.bind(this)), (s = n.get("disappear")) == null || s.forEach(this.inputDidDisappear.bind(this)), (i = n.get("end")) == null || i.forEach(this.inputDidEnd.bind(this)), (o = n.get("miss")) == null || o.forEach(this.checkForMissedInput.bind(this)), (a = n.get("start")) == null || a.forEach(this.inputDidStart.bind(this)))
    }
    onEnd() {
        this.isRunning = !1, this.isComplete = !0, this.currentTime = this.duration, this.progress = 1, this.stop(), this.emit({
            now: this.currentTime,
            type: "end"
        })
    }
    inputDidAppear(e) {
        e.isVisible = !0
    }
    inputDidDisappear(e) {
        e.isVisible = !1
    }
    inputDidEnd(e) {
        e.isCurrent = !1
    }
    checkForMissedInput(e) {
        e.isHolding || e.isMissed || e.isTaken || this.inputWasMissed(e)
    }
    inputWasMissed(e) {
        this.scoreInput(null), e.isMissed = !0
    }
    inputDidStart(e) {
        e.isCurrent = !0, e.isPassed = !0
    }
    reportInput(e) {
        this.isAudience || this.reportInterval && this.pendingInputs.push(e)
    }
    async onReportInterval() {
        if (this.isAudience || !this.pendingInputs.length) return;
        const e = this.pendingInputs.sort((n, r) => n.start - r.start);
        this.pendingInputs = [];
        try {
            await this.wsClient.updateObject(this.responseKey, {
                input: e
            })
        } catch (n) {
            console.error(n)
        }
    }
    saveAudienceScore() {
        if (!this.isAudience) return;
        const e = this.longestCombo * this.scorePerHighestCombo,
            s = [Math.round(this.scorePool * (this.accuracy / this.pastNotes)) + e, this.longestCombo, this.qualities[0], this.qualities[1], this.qualities[2], this.qualities[3], this.pastNotes];
        xn.set("audienceScore", s.join(":"), "code")
    }
    async reportAudienceAccuracy() {
        if (!this.isAudience) return;
        const e = Math.round(this.accuracy / this.pastNotes * 100);
        if (e !== 0) try {
            await this.wsClient.incrementCountGroupCounter(this.responseKey, `${e}`)
        } catch (n) {
            console.error(n)
        }
    }
}
class s7e extends pI {
    constructor(n) {
        super(n);
        ye(this, "activeAt");
        ye(this, "activeQuality");
        ye(this, "currentInput");
        ye(this, "currentLimits");
        ye(this, "currentPerfect", null);
        ye(this, "currentSignal", null);
        ye(this, "currentQuality", null);
        ye(this, "isActive", !1);
        ye(this, "isFlubbing", !1);
        ye(this, "pointerId");
        ye(this, "trackedSignals");
        ye(this, "feedback", []);
        ye(this, "limitsIndex", new Map);
        ye(this, "perfectIndex", new Map);
        if (this.parseLimits(n.beatmap), this.parsePerfects(n.beatmap), this.currentLimits = this.limitsIndex.get(0), n.isAudience) {
            const r = n.beatmap.inputs[n.beatmap.inputs.length - 1];
            this.audienceReportAt = r.start + r.duration + 50
        }
    }
    roundSignal(n) {
        return Math.round(n * 1e3) / 1e3
    }
    getPathForInput(n) {
        let r = "";
        return n.signal.forEach((s, i) => {
            const o = 1 - s.start / n.duration;
            r += `${i?"L":"M"} ${s.signal} ${o} `
        }), r
    }
    getEndXForInput(n) {
        return n.signal[n.signal.length - 1].signal
    }
    getSignalQuality(n) {
        const r = this.criteria.signal.findIndex(s => n < s);
        return r === -1 ? null : r
    }
    getNoteQuality(n) {
        const r = this.criteria.percentage.findIndex(s => n > s);
        return r === -1 ? null : r
    }
    parseInputs(n) {
        n.inputs.forEach(s => {
            const i = {
                duration: s.duration,
                height: this.durationToHeight(s.duration),
                isAudible: !1,
                isCurrent: !1,
                isPassed: !1,
                isHolding: !1,
                isMissed: !1,
                isTaken: !1,
                isVisible: !0,
                path: this.getPathForInput(s),
                endX: this.getEndXForInput(s),
                signal: s.signal,
                start: s.start,
                y: this.millisecondsToY(s.start)
            };
            (s.start > this.currentTime + this.appearThreshold || s.start < this.currentTime - (i.duration + this.disappearThreshold)) && (i.isVisible = !1), this.addInput(i, {
                appear: i.start - this.appearThreshold,
                disappear: i.start + i.duration + this.disappearThreshold,
                end: i.start + i.duration,
                miss: i.start + i.duration,
                start: i.start
            })
        })
    }
    parseLimits(n) {
        n.limits && n.limits.forEach((r, s) => {
            const i = s ? r[0] : 0;
            this.limitsIndex.set(i, [r[1], r[2]])
        })
    }
    parsePerfects(n) {
        n.inputs.forEach(s => {
            s.signal.forEach(i => {
                this.perfectIndex.set(s.start + i.start, i.signal)
            }), this.perfectIndex.set(s.start + s.duration, null)
        })
    }
    onDown(n, r) {
        if (this.instraface && this.isRunning) {
            if (this.pointerId === r) {
                this.onMove(n, r);
                return
            }
            this.pointerId === void 0 && (n = this.roundSignal(n), console.log(this.currentLimits), this.instraface.continuous.attack(n, this.currentLimits[0], this.currentLimits[1]), this.trackedSignals = [{
                start: 0,
                signal: n
            }], this.currentInput && (this.currentInput.isHolding = !0), this.activeAt = this.now, this.isActive = !0, this.pointerId = r, this.currentSignal = n)
        }
    }
    onMove(n, r) {
        if (!this.instraface || !this.isRunning || this.pointerId !== r || !this.trackedSignals) return;
        n = this.roundSignal(n), this.currentSignal = n, this.instraface.continuous.update(n, this.currentLimits[0], this.currentLimits[1]), this.currentInput && (this.currentInput.isHolding = !0);
        const s = this.now - this.activeAt;
        this.trackedSignals[this.trackedSignals.length - 1].start + 150 > s || this.trackedSignals.push({
            start: s,
            signal: n
        })
    }
    onUp(n) {
        this.instraface && (n && this.pointerId !== n || this.trackedSignals && (this.instraface.continuous.release(), this.currentInput && (this.currentInput.isHolding = !1, this.currentInput.isTaken = !0), this.trackedSignals && this.activeAt && this.reportInput({
            start: this.activeAt,
            duration: this.now - this.activeAt,
            signal: this.trackedSignals
        }), this.isActive = !1, this.currentSignal = null, delete this.trackedSignals, delete this.pointerId, delete this.activeAt))
    }
    processMillisecond(n) {
        super.processMillisecond(n);
        const r = this.limitsIndex.get(n);
        r && (this.currentLimits = r);
        const s = this.perfectIndex.get(n);
        s !== void 0 && (this.currentPerfect = s), this.processSignal()
    }
    inputDidEnd(n) {
        if (super.inputDidEnd(n), !this.currentInput) return;
        const r = this.activeQuality / this.currentInput.duration * 100,
            s = this.getNoteQuality(r);
        this.scoreInput(s), s !== null && this.feedback.push([n.endX, s]), delete this.activeQuality, delete this.currentInput
    }
    onEnd() {
        super.onEnd(), this.pointerId && this.onUp(this.pointerId)
    }
    inputDidStart(n) {
        super.inputDidStart(n), this.activeQuality = 0, this.currentInput = n
    }
    processSignal() {
        if (!this.currentInput || this.currentPerfect === null || this.currentSignal === null) return;
        const n = Math.abs(this.currentSignal - this.currentPerfect),
            r = this.getSignalQuality(n);
        this.currentQuality = r, r !== null && (this.activeQuality += this.criteria.factors[r])
    }
}
const i7e = st({
    props: {
        manager: {
            type: Object,
            required: !0
        }
    },
    methods: {
        normalizeSignal(t) {
            return t < .25 ? 0 : t > .75 ? 1 : (t - .25) * 2
        },
        onPointerBoxStart(t) {
            this.manager.isRunning && this.manager.onDown(this.normalizeSignal(t.detail.percentX), t.detail.id)
        },
        onPointerBoxMove(t) {
            this.manager.isRunning && this.manager.onMove(this.normalizeSignal(t.detail.percentX), t.detail.id)
        },
        onPointerBoxEnd(t) {
            this.manager.onUp(t.detail.id)
        },
        onReleaserUp(t) {
            this.manager.onUp(t.pointerId)
        },
        onContextMenu(t) {
            t.preventDefault(), this.manager.onUp()
        }
    }
});
const o7e = {
    class: "constrainer controls"
};

function a7e(t, e, n, r, s, i) {
    const o = Gt("pointerbox");
    return B(), H(lt, null, [U("div", {
        class: "releaser",
        onPointerup: e[0] || (e[0] = (...a) => t.onReleaserUp && t.onReleaserUp(...a))
    }, null, 32), U("div", o7e, [$e(U("div", {
        class: "hitbox",
        onContextmenu: e[1] || (e[1] = (...a) => t.onContextMenu && t.onContextMenu(...a)),
        "onPointerbox:start": e[2] || (e[2] = (...a) => t.onPointerBoxStart && t.onPointerBoxStart(...a)),
        "onPointerbox:move": e[3] || (e[3] = (...a) => t.onPointerBoxMove && t.onPointerBoxMove(...a)),
        "onPointerbox:end": e[4] || (e[4] = (...a) => t.onPointerBoxEnd && t.onPointerBoxEnd(...a))
    }, null, 544), [
        [o, void 0, void 0, {
            restrict: !0
        }]
    ])])], 64)
}
const c7e = He(i7e, [
        ["render", a7e],
        ["__scopeId", "data-v-2786811b"]
    ]),
    l7e = st({
        props: {
            duration: {
                type: Number,
                required: !0
            },
            guide: {
                type: Array,
                required: !0
            }
        },
        computed: {
            beatLines() {
                const t = this.guide.flat(),
                    e = [];
                for (let n = 0; n < t.length; n += 2) {
                    const r = t[n],
                        i = (t[n + 1] ?? this.duration) - r;
                    e.push({
                        styles: {
                            bottom: `${r/this.duration*100}%`,
                            height: `${i/this.duration*100}%`
                        }
                    })
                }
                return e
            }
        }
    });
const u7e = {
    class: "beat-lines"
};

function h7e(t, e, n, r, s, i) {
    return B(), H("div", u7e, [(B(!0), H(lt, null, gn(t.beatLines, (o, a) => (B(), H("div", {
        key: a,
        class: "beat-line",
        style: sn(o.styles)
    }, null, 4))), 128))])
}
const mI = He(l7e, [
        ["render", h7e],
        ["__scopeId", "data-v-7f81041d"]
    ]),
    f7e = st({
        components: {
            Beatlines: mI
        },
        props: {
            manager: {
                type: Object,
                required: !0
            },
            showCta: {
                type: Boolean,
                required: !0
            }
        },
        data() {
            return {
                textItems: [],
                cleanupInterval: window.setInterval(this.cleanup, 2e3)
            }
        },
        computed: {
            scrollStyles() {
                return {
                    transform: `translateY(${this.manager.progress*100}%)`
                }
            },
            hitIndicator() {
                const t = [];
                return this.manager.isActive && t.push("active"), this.manager.isFlubbing && t.push("flubbing"), {
                    classes: t,
                    styles: {
                        left: `${(this.manager.currentSignal??0)*100}%`
                    }
                }
            },
            homeClasses() {
                return this.showCta ? ["alert"] : this.manager.isFlubbing ? ["flub"] : this.manager.isActive ? this.manager.currentQuality === 0 ? ["perfect"] : this.manager.currentQuality === 1 ? ["good"] : this.manager.currentQuality === 2 ? ["okay"] : [] : []
            },
            inputs() {
                const t = [];
                return this.manager.inputs.forEach(e => {
                    e.forEach(n => {
                        if (!n.isVisible) return;
                        const r = {
                            classes: [],
                            path: n.path,
                            key: n.start,
                            headStyles: {
                                left: `${n.signal[0].signal*100}%`,
                                bottom: `${n.y*100}%`
                            },
                            lineStyles: {
                                height: `${n.height*100}%`,
                                bottom: `${n.y*100}%`
                            }
                        };
                        n.isCurrent && this.manager.isActive && r.classes.push("active"), n.isPassed && r.classes.push("passed"), t.push(r)
                    })
                }), t
            },
            showCombo() {
                return this.manager.currentCombo > this.manager.minimumDisplayCombo
            }
        },
        watch: {
            "manager.feedback": {
                handler: "onFeedbackChange",
                deep: !0
            }
        },
        beforeUnmount() {
            window.clearInterval(this.cleanupInterval)
        },
        methods: {
            onFeedbackChange(t) {
                const e = t[t.length - 1];
                if (e === null) return;
                const n = {
                    left: `${e[0]*100}%`
                };
                e[1] === 0 && this.textItems.push(["QUALITY.PERFECT", "perfect", n, Date.now()]), e[1] === 1 && this.textItems.push(["QUALITY.GREAT", "good", n, Date.now()]), e[1] === 2 && this.textItems.push(["QUALITY.OKAY", "okay", n, Date.now()])
            },
            cleanup() {
                const t = Date.now() - 2e3,
                    e = this.textItems.findIndex(([n, r, s, i]) => i < t);
                this.textItems.splice(e)
            }
        }
    });
const d7e = t => (Gr("data-v-57b6c172"), t = t(), Vr(), t),
    p7e = {
        class: "visuals"
    },
    m7e = {
        class: "scroll-wrapper"
    },
    g7e = Pc('<div class="home" data-v-57b6c172><svg viewBox="0 0 300 54" data-v-57b6c172><g class="outer-group" data-v-57b6c172><line x1="30" y1="-5000" x2="30" y2="0" data-v-57b6c172></line><line x1="90" y1="-5000" x2="90" y2="0" data-v-57b6c172></line><line x1="150" y1="-5000" x2="150" y2="0" data-v-57b6c172></line><line x1="210" y1="-5000" x2="210" y2="0" data-v-57b6c172></line><line x1="270" y1="-5000" x2="270" y2="0" data-v-57b6c172></line><rect class="outer" rx="27" ry="27" width="300" height="54" data-v-57b6c172></rect></g><rect class="middle" rx="27" ry="27" width="300" height="54" data-v-57b6c172></rect><rect class="inner" x="16" y="16" rx="11" ry="11" width="268" height="22" data-v-57b6c172></rect></svg></div>', 1),
    _7e = [g7e],
    y7e = {
        class: "scroll-wrapper clipped"
    },
    v7e = {
        class: "constrainer"
    },
    b7e = ["d"],
    E7e = ["d"],
    T7e = {
        class: "scroll-wrapper"
    },
    S7e = {
        class: "constrainer"
    },
    w7e = d7e(() => U("circle", {
        cx: "55",
        cy: "55",
        r: "53"
    }, null, -1)),
    A7e = [w7e],
    O7e = {
        class: "constrainer"
    },
    C7e = Pc('<svg viewBox="0 0 300 54" class="glow" data-v-57b6c172><defs data-v-57b6c172><linearGradient id="glow-gradient" x1="-4" y1="-42" x2="-4" y2="54" gradientUnits="userSpaceOnUse" data-v-57b6c172><stop class="stop0" offset="0%" data-v-57b6c172></stop><stop class="stop1" offset="100%" data-v-57b6c172></stop></linearGradient></defs><rect x="-4" y="-100" rx="32" ry="32" width="308" height="159" data-v-57b6c172></rect></svg>', 1),
    k7e = [C7e],
    I7e = Pc('<defs data-v-57b6c172><linearGradient id="line-gradient" x1="0" y1="-200" x2="0" y2="0" gradientUnits="userSpaceOnUse" data-v-57b6c172><stop class="stop0" offset="0%" data-v-57b6c172></stop><stop class="stop1" offset="50%" data-v-57b6c172></stop></linearGradient></defs><circle cx="55" cy="55" r="53" data-v-57b6c172></circle><line x1="55" y1="-200" x2="55" y2="0" data-v-57b6c172></line>', 3),
    N7e = [I7e],
    x7e = {
        class: "home"
    },
    P7e = {
        key: 0,
        class: "constrainer"
    },
    R7e = {
        class: "cta-container"
    },
    M7e = {
        class: "cta"
    };

function D7e(t, e, n, r, s, i) {
    const o = Ge("Beatlines"),
        a = Gt("t");
    return B(), H("div", p7e, [U("div", m7e, [Ve(o, {
        class: "scroll-container",
        guide: t.manager.guide,
        duration: t.manager.duration,
        style: sn(t.scrollStyles)
    }, null, 8, ["guide", "duration", "style"])]), U("div", {
        class: nt(["constrainer", t.homeClasses])
    }, _7e, 2), U("div", y7e, [U("div", {
        class: "scroll-container",
        style: sn(t.scrollStyles)
    }, [U("div", v7e, [(B(!0), H(lt, null, gn(t.inputs, l => (B(), H("svg", {
        key: l.key,
        class: nt(["line", l.classes]),
        viewBox: "0 0 1 1",
        preserveAspectRatio: "none",
        style: sn(l.lineStyles)
    }, [U("path", {
        class: "back",
        d: l.path
    }, null, 8, b7e), U("path", {
        class: "front",
        d: l.path
    }, null, 8, E7e)], 6))), 128))])], 4)]), U("div", T7e, [U("div", {
        class: "scroll-container",
        style: sn(t.scrollStyles)
    }, [U("div", S7e, [(B(!0), H(lt, null, gn(t.inputs, l => (B(), H("svg", {
        key: l.key,
        class: nt(["head", l.classes]),
        viewBox: "0 0 110 110",
        style: sn(l.headStyles)
    }, A7e, 6))), 128))])], 4)]), U("div", O7e, [U("div", {
        class: nt(["home", t.homeClasses])
    }, k7e, 2), (B(), H("svg", {
        viewBox: "0 0 110 110",
        class: nt(["indicator", t.hitIndicator.classes]),
        style: sn(t.hitIndicator.styles)
    }, N7e, 6)), U("div", x7e, [(B(!0), H(lt, null, gn(t.textItems, (l, u) => $e((B(), H("p", {
        key: u,
        class: nt(["text-item", l[1]]),
        style: sn(l[2])
    }, null, 6)), [
        [a, l[0]]
    ])), 128))])]), Ve(Ta, {
        name: "cta"
    }, {
        default: $i(() => [t.showCta ? (B(), H("div", P7e, [U("div", R7e, [$e(U("p", M7e, null, 512), [
            [a, "INFO.CONTINUOUS"]
        ])])])) : Pe("", !0)]),
        _: 1
    })])
}
const $7e = He(f7e, [
    ["render", D7e],
    ["__scopeId", "data-v-57b6c172"]
]);
class L7e extends pI {
    constructor(n) {
        super(n);
        ye(this, "lanes", []);
        if (this.parseLanes(n.beatmap.laneCount), n.isAudience) {
            const r = n.beatmap.inputs[n.beatmap.inputs.length - 1];
            this.audienceReportAt = r.start + (r.duration ?? this.missThreshold)
        }
    }
    laneWithPointerId(n) {
        return this.lanes.find(r => r.pointerId === n) ?? null
    }
    getDurationOfNotes(n) {
        return Math.max(...n.map(r => r.start + r.duration))
    }
    getNextInputOnLane(n) {
        const r = this.now;
        for (let s = r - this.missThreshold; s < r + this.missThreshold; s++) {
            const i = n.inputIndex.get(s);
            if (i && !i.isTaken) return i
        }
        return null
    }
    parseInputs(n) {
        n.inputs.forEach(s => {
            const i = this.getDurationOfNotes(s.notes),
                [o, a] = this.parseNoteIndexes(s.notes),
                l = s.lanes.map(d => ({
                    isDown: !1,
                    key: `${s.start}:${d}`,
                    lane: d
                })),
                u = {
                    attackIds: [],
                    attackIndex: o,
                    audioDuration: i,
                    audioHeight: this.durationToHeight(i),
                    indicators: l,
                    isAudible: !1,
                    isCurrent: !1,
                    isPassed: !1,
                    isHold: s.duration !== void 0,
                    isHolding: !1,
                    isMissed: !1,
                    isTaken: !1,
                    isVisible: !0,
                    lanes: s.lanes,
                    notes: s.notes,
                    releaseIds: [],
                    releaseIndex: a,
                    start: s.start,
                    y: this.millisecondsToY(s.start)
                };
            s.duration && (u.duration = s.duration, u.height = this.durationToHeight(u.duration));
            const f = s.duration ?? 0;
            (s.start > this.currentTime + this.appearThreshold || s.start < this.currentTime - (f + this.disappearThreshold)) && (u.isVisible = !1), this.addInput(u, {
                appear: u.start - this.appearThreshold,
                disappear: u.start + f + this.disappearThreshold,
                end: u.start + f,
                miss: u.start + this.missThreshold,
                start: u.start
            })
        })
    }
    parseNoteIndexes(n) {
        const r = new Map,
            s = new Map;
        return n.forEach(i => {
            const o = i.start,
                a = r.get(o) ?? [];
            a.push(i.note), r.set(o, a);
            const l = i.start + i.duration,
                u = s.get(l) ?? [];
            u.push(i.note), s.set(l, u)
        }), [r, s]
    }
    parseLanes(n) {
        for (let r = 0; r < n; r++) {
            const s = {
                feedback: [],
                index: r,
                isActive: !1,
                isAudible: !1,
                inputIndex: new Map
            };
            this.inputs.forEach((i, o) => {
                i.forEach(a => {
                    a.lanes.includes(r) && s.inputIndex.set(o, a)
                })
            }), this.lanes.push(s)
        }
    }
    inputWasMissed(n) {
        super.inputWasMissed(n), n.lanes.forEach(r => this.lanes[r].feedback.push(3))
    }
    onEnd() {
        super.onEnd(), this.lanes.forEach(n => {
            n.pointerId && this.onUp(n.pointerId)
        })
    }
    onDown(n, r) {
        if (!this.isRunning) return;
        const s = this.lanes[n];
        if (!s || s.isActive || this.laneWithPointerId(r)) return;
        s.activeAt = this.now, s.isActive = !0, s.pointerId = r;
        const o = this.getNextInputOnLane(s);
        if (!o) {
            this.flubOnLane(s);
            return
        }
        if (!o.lanes.every(p => this.lanes[p].isActive)) return;
        const u = o.lanes.reduce((p, _) => this.lanes[_].activeAt + p, 0) / o.lanes.length,
            f = Math.abs(u - o.start),
            d = this.criteria.time.findIndex(p => f < p);
        d === void 0 && console.warn("unexpected quality"), o.isHold ? (o.isHolding = !0, o.pendingQuality = d, o.lanes.forEach(p => {
            this.lanes[p].activeInput = o, this.lanes[p].feedback.push(d + 10)
        })) : (o.isTaken = !0, o.lanes.forEach(p => {
            this.lanes[p].feedback.push(d)
        })), this.scoreInput(d), this.attackWithInput(o)
    }
    onUp(n) {
        const r = this.laneWithPointerId(n);
        if (!r) return;
        this.reportInput({
            start: r.activeAt,
            duration: this.now - r.activeAt,
            lane: r.index
        });
        const s = r.activeInput;
        s != null && s.isHold && (s.isTaken = !0, s.isHolding = !1, s.lanes.forEach(i => {
            delete this.lanes[i].activeInput
        }), this.releaseWithInput(s)), delete r.activeAt, r.isActive = !1, delete r.pointerId
    }
    flubOnLane(n) {
        this.instraface && (n.flubEndId && this.scheduler.cancel(n.flubEndId), n.feedback.push(null), this.instraface.flub.attack(), n.flubEndId = this.schedule(() => {
            delete n.flubEndId
        }, 250))
    }
    attackWithInput(n) {
        this.instraface && (n.attackIndex.forEach((r, s) => {
            if (s) {
                const i = this.schedule(() => {
                    this.instraface.discrete.attack(r)
                }, s);
                n.attackIds.push(i);
                return
            }
            this.instraface.discrete.attack(r)
        }), n.releaseIndex.forEach((r, s) => {
            const i = this.schedule(() => {
                this.instraface.discrete.release(r)
            }, s);
            n.releaseIds.push(i)
        }))
    }
    releaseWithInput(n) {
        n.attackIds.forEach(r => this.scheduler.cancel(r)), n.releaseIds.forEach(r => this.scheduler.call(r))
    }
    async onReportInterval() {
        if (this.lanes.some(r => {
                const s = r.activeInput;
                return s == null ? void 0 : s.isHold
            })) {
            console.log(`[reporter] Did not send ${this.pendingInputs.length} because an input is being held`);
            return
        }
        await super.onReportInterval()
    }
}

function no(t) {
    if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t
}

function gI(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
}
/*!
 * GSAP 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var $r = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
            lineHeight: ""
        }
    },
    fu = {
        duration: .5,
        overwrite: !1,
        delay: 0
    },
    Vb, wi = 1e8,
    Bt = 1 / wi,
    Fv = Math.PI * 2,
    F7e = Fv / 4,
    U7e = 0,
    _I = Math.sqrt,
    B7e = Math.cos,
    q7e = Math.sin,
    dr = function(e) {
        return typeof e == "string"
    },
    Wn = function(e) {
        return typeof e == "function"
    },
    go = function(e) {
        return typeof e == "number"
    },
    jb = function(e) {
        return typeof e > "u"
    },
    _o = function(e) {
        return typeof e == "object"
    },
    Fr = function(e) {
        return e !== !1
    },
    yI = function() {
        return typeof window < "u"
    },
    r8 = function(e) {
        return Wn(e) || dr(e)
    },
    vI = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {},
    as = Array.isArray,
    Uv = /(?:-?\.?\d|\.)+/gi,
    bI = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    vl = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    Qy = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    EI = /[+-]=-?[.\d]+/,
    TI = /[^,'"\[\]\s]+/gi,
    G7e = /[\d.+\-=]+(?:e[-+]\d*)*/i,
    pn, gi, Bv, Wb, us = {},
    vm = {},
    SI, wI = function(e) {
        return (vm = pu(e, us)) && Di
    },
    Hb = function(e, n) {
        return console.warn("Invalid property", e, "set to", n, "Missing plugin? gsap.registerPlugin()")
    },
    bm = function(e, n) {
        return !n && console.warn(e)
    },
    AI = function(e, n) {
        return e && (us[e] = n) && vm && (vm[e] = n) || us
    },
    du = function() {
        return 0
    },
    Yb = {},
    oa = [],
    qv = {},
    OI, es = {},
    Jy = {},
    s8 = 30,
    Hp = [],
    zb = "",
    Kb = function(e) {
        var n = e[0],
            r, s;
        if (_o(n) || Wn(n) || (e = [e]), !(r = (n._gsap || {}).harness)) {
            for (s = Hp.length; s-- && !Hp[s].targetTest(n););
            r = Hp[s]
        }
        for (s = e.length; s--;) e[s] && (e[s]._gsap || (e[s]._gsap = new zI(e[s], r))) || e.splice(s, 1);
        return e
    },
    vc = function(e) {
        return e._gsap || Kb(As(e))[0]._gsap
    },
    CI = function(e, n, r) {
        return (r = e[n]) && Wn(r) ? e[n]() : jb(r) && e.getAttribute && e.getAttribute(n) || r
    },
    cs = function(e, n) {
        return (e = e.split(",")).forEach(n) || e
    },
    kt = function(e) {
        return Math.round(e * 1e5) / 1e5 || 0
    },
    V7e = function(e, n) {
        for (var r = n.length, s = 0; e.indexOf(n[s]) < 0 && ++s < r;);
        return s < r
    },
    Em = function() {
        var e = oa.length,
            n = oa.slice(0),
            r, s;
        for (qv = {}, oa.length = 0, r = 0; r < e; r++) s = n[r], s && s._lazy && (s.render(s._lazy[0], s._lazy[1], !0)._lazy = 0)
    },
    kI = function(e, n, r, s) {
        oa.length && Em(), e.render(n, r, s), oa.length && Em()
    },
    II = function(e) {
        var n = parseFloat(e);
        return (n || n === 0) && (e + "").match(TI).length < 2 ? n : dr(e) ? e.trim() : e
    },
    NI = function(e) {
        return e
    },
    Rs = function(e, n) {
        for (var r in n) r in e || (e[r] = n[r]);
        return e
    },
    j7e = function(e, n) {
        for (var r in n) r in e || r === "duration" || r === "ease" || (e[r] = n[r])
    },
    pu = function(e, n) {
        for (var r in n) e[r] = n[r];
        return e
    },
    i8 = function t(e, n) {
        for (var r in n) r !== "__proto__" && r !== "constructor" && r !== "prototype" && (e[r] = _o(n[r]) ? t(e[r] || (e[r] = {}), n[r]) : n[r]);
        return e
    },
    Gv = function(e, n) {
        var r = {},
            s;
        for (s in e) s in n || (r[s] = e[s]);
        return r
    },
    Yp = function(e) {
        var n = e.parent || pn,
            r = e.keyframes ? j7e : Rs;
        if (Fr(e.inherit))
            for (; n;) r(e, n.vars.defaults), n = n.parent || n._dp;
        return e
    },
    W7e = function(e, n) {
        for (var r = e.length, s = r === n.length; s && r-- && e[r] === n[r];);
        return r < 0
    },
    H7e = function(e, n, r, s, i) {
        r === void 0 && (r = "_first"), s === void 0 && (s = "_last");
        var o = e[s],
            a;
        if (i)
            for (a = n[i]; o && o[i] > a;) o = o._prev;
        return o ? (n._next = o._next, o._next = n) : (n._next = e[r], e[r] = n), n._next ? n._next._prev = n : e[s] = n, n._prev = o, n.parent = n._dp = e, n
    },
    Lg = function(e, n, r, s) {
        r === void 0 && (r = "_first"), s === void 0 && (s = "_last");
        var i = n._prev,
            o = n._next;
        i ? i._next = o : e[r] === n && (e[r] = o), o ? o._prev = i : e[s] === n && (e[s] = i), n._next = n._prev = n.parent = null
    },
    ya = function(e, n) {
        e.parent && (!n || e.parent.autoRemoveChildren) && e.parent.remove(e), e._act = 0
    },
    bc = function(e, n) {
        if (e && (!n || n._end > e._dur || n._start < 0))
            for (var r = e; r;) r._dirty = 1, r = r.parent;
        return e
    },
    Y7e = function(e) {
        for (var n = e.parent; n && n.parent;) n._dirty = 1, n.totalDuration(), n = n.parent;
        return e
    },
    z7e = function t(e) {
        return !e || e._ts && t(e.parent)
    },
    o8 = function(e) {
        return e._repeat ? mu(e._tTime, e = e.duration() + e._rDelay) * e : 0
    },
    mu = function(e, n) {
        var r = Math.floor(e /= n);
        return e && r === e ? r - 1 : r
    },
    Tm = function(e, n) {
        return (e - n._start) * n._ts + (n._ts >= 0 ? 0 : n._dirty ? n.totalDuration() : n._tDur)
    },
    Zb = function(e) {
        return e._end = kt(e._start + (e._tDur / Math.abs(e._ts || e._rts || Bt) || 0))
    },
    xI = function(e, n) {
        var r = e._dp;
        return r && r.smoothChildTiming && e._ts && (e._start = kt(r._time - (e._ts > 0 ? n / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - n) / -e._ts)), Zb(e), r._dirty || bc(r, e)), e
    },
    PI = function(e, n) {
        var r;
        if ((n._time || n._initted && !n._dur) && (r = Tm(e.rawTime(), n), (!n._dur || ud(0, n.totalDuration(), r) - n._tTime > Bt) && n.render(r, !0)), bc(e, n)._dp && e._initted && e._time >= e._dur && e._ts) {
            if (e._dur < e.duration())
                for (r = e; r._dp;) r.rawTime() >= 0 && r.totalTime(r._tTime), r = r._dp;
            e._zTime = -Bt
        }
    },
    Ti = function(e, n, r, s) {
        return n.parent && ya(n), n._start = kt((go(r) ? r : r || e !== pn ? Es(e, r, n) : e._time) + n._delay), n._end = kt(n._start + (n.totalDuration() / Math.abs(n.timeScale()) || 0)), H7e(e, n, "_first", "_last", e._sort ? "_start" : 0), Vv(n) || (e._recent = n), s || PI(e, n), e
    },
    RI = function(e, n) {
        return (us.ScrollTrigger || Hb("scrollTrigger", n)) && us.ScrollTrigger.create(n, e)
    },
    MI = function(e, n, r, s) {
        if (_9e(e, n), !e._initted) return 1;
        if (!r && e._pt && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && OI !== Ss.frame) return oa.push(e), e._lazy = [n, s], 1
    },
    K7e = function t(e) {
        var n = e.parent;
        return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
    },
    Vv = function(e) {
        var n = e.data;
        return n === "isFromStart" || n === "isStart"
    },
    Z7e = function(e, n, r, s) {
        var i = e.ratio,
            o = n < 0 || !n && (!e._start && K7e(e) && !(!e._initted && Vv(e)) || (e._ts < 0 || e._dp._ts < 0) && !Vv(e)) ? 0 : 1,
            a = e._rDelay,
            l = 0,
            u, f, d;
        if (a && e._repeat && (l = ud(0, e._tDur, n), f = mu(l, a), d = mu(e._tTime, a), e._yoyo && f & 1 && (o = 1 - o), f !== d && (i = 1 - o, e.vars.repeatRefresh && e._initted && e.invalidate())), o !== i || s || e._zTime === Bt || !n && e._zTime) {
            if (!e._initted && MI(e, n, s, r)) return;
            for (d = e._zTime, e._zTime = n || (r ? Bt : 0), r || (r = n && !d), e.ratio = o, e._from && (o = 1 - o), e._time = 0, e._tTime = l, u = e._pt; u;) u.r(o, u.d), u = u._next;
            e._startAt && n < 0 && e._startAt.render(n, !0, !0), e._onUpdate && !r && rs(e, "onUpdate"), l && e._repeat && !r && e.parent && rs(e, "onRepeat"), (n >= e._tDur || n < 0) && e.ratio === o && (o && ya(e, 1), r || (rs(e, o ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
        } else e._zTime || (e._zTime = n)
    },
    X7e = function(e, n, r) {
        var s;
        if (r > n)
            for (s = e._first; s && s._start <= r;) {
                if (!s._dur && s.data === "isPause" && s._start > n) return s;
                s = s._next
            } else
                for (s = e._last; s && s._start >= r;) {
                    if (!s._dur && s.data === "isPause" && s._start < n) return s;
                    s = s._prev
                }
    },
    gu = function(e, n, r, s) {
        var i = e._repeat,
            o = kt(n) || 0,
            a = e._tTime / e._tDur;
        return a && !s && (e._time *= o / e._dur), e._dur = o, e._tDur = i ? i < 0 ? 1e10 : kt(o * (i + 1) + e._rDelay * i) : o, a && !s ? xI(e, e._tTime = e._tDur * a) : e.parent && Zb(e), r || bc(e.parent, e), e
    },
    a8 = function(e) {
        return e instanceof Mr ? bc(e) : gu(e, e._dur)
    },
    Q7e = {
        _start: 0,
        endTime: du,
        totalDuration: du
    },
    Es = function t(e, n, r) {
        var s = e.labels,
            i = e._recent || Q7e,
            o = e.duration() >= wi ? i.endTime(!1) : e._dur,
            a, l, u;
        return dr(n) && (isNaN(n) || n in s) ? (l = n.charAt(0), u = n.substr(-1) === "%", a = n.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (n = n.replace(/=/, "")), (l === "<" ? i._start : i.endTime(i._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (u ? (a < 0 ? i : r).totalDuration() / 100 : 1)) : a < 0 ? (n in s || (s[n] = o), s[n]) : (l = parseFloat(n.charAt(a - 1) + n.substr(a + 1)), u && r && (l = l / 100 * (as(r) ? r[0] : r).totalDuration()), a > 1 ? t(e, n.substr(0, a - 1), r) + l : o + l)) : n == null ? o : +n
    },
    Lh = function(e, n, r) {
        var s = go(n[1]),
            i = (s ? 2 : 1) + (e < 2 ? 0 : 1),
            o = n[i],
            a, l;
        if (s && (o.duration = n[1]), o.parent = r, e) {
            for (a = o, l = r; l && !("immediateRender" in a);) a = l.vars.defaults || {}, l = Fr(l.vars.inherit) && l.parent;
            o.immediateRender = Fr(a.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = n[i - 1]
        }
        return new Vn(n[0], o, n[i + 1])
    },
    $a = function(e, n) {
        return e || e === 0 ? n(e) : n
    },
    ud = function(e, n, r) {
        return r < e ? e : r > n ? n : r
    },
    ss = function(e) {
        if (typeof e != "string") return "";
        var n = G7e.exec(e);
        return n ? e.substr(n.index + n[0].length) : ""
    },
    J7e = function(e, n, r) {
        return $a(r, function(s) {
            return ud(e, n, s)
        })
    },
    jv = [].slice,
    DI = function(e, n) {
        return e && _o(e) && "length" in e && (!n && !e.length || e.length - 1 in e && _o(e[0])) && !e.nodeType && e !== gi
    },
    e9e = function(e, n, r) {
        return r === void 0 && (r = []), e.forEach(function(s) {
            var i;
            return dr(s) && !n || DI(s, 1) ? (i = r).push.apply(i, As(s)) : r.push(s)
        }) || r
    },
    As = function(e, n, r) {
        return dr(e) && !r && (Bv || !_u()) ? jv.call((n || Wb).querySelectorAll(e), 0) : as(e) ? e9e(e, r) : DI(e) ? jv.call(e, 0) : e ? [e] : []
    },
    t9e = function(e) {
        return e = As(e)[0] || bm("Invalid scope") || {},
            function(n) {
                var r = e.current || e.nativeElement || e;
                return As(n, r.querySelectorAll ? r : r === e ? bm("Invalid scope") || Wb.createElement("div") : e)
            }
    },
    $I = function(e) {
        return e.sort(function() {
            return .5 - Math.random()
        })
    },
    LI = function(e) {
        if (Wn(e)) return e;
        var n = _o(e) ? e : {
                each: e
            },
            r = Ul(n.ease),
            s = n.from || 0,
            i = parseFloat(n.base) || 0,
            o = {},
            a = s > 0 && s < 1,
            l = isNaN(s) || a,
            u = n.axis,
            f = s,
            d = s;
        return dr(s) ? f = d = {
                center: .5,
                edges: .5,
                end: 1
            } [s] || 0 : !a && l && (f = s[0], d = s[1]),
            function(p, _, v) {
                var y = (v || n).length,
                    g = o[y],
                    b, O, N, k, A, x, D, L, q;
                if (!g) {
                    if (q = n.grid === "auto" ? 0 : (n.grid || [1, wi])[1], !q) {
                        for (D = -wi; D < (D = v[q++].getBoundingClientRect().left) && q < y;);
                        q--
                    }
                    for (g = o[y] = [], b = l ? Math.min(q, y) * f - .5 : s % q, O = l ? y * d / q - .5 : s / q | 0, D = 0, L = wi, x = 0; x < y; x++) N = x % q - b, k = O - (x / q | 0), g[x] = A = u ? Math.abs(u === "y" ? k : N) : _I(N * N + k * k), A > D && (D = A), A < L && (L = A);
                    s === "random" && $I(g), g.max = D - L, g.min = L, g.v = y = (parseFloat(n.amount) || parseFloat(n.each) * (q > y ? y - 1 : u ? u === "y" ? y / q : q : Math.max(q, y / q)) || 0) * (s === "edges" ? -1 : 1), g.b = y < 0 ? i - y : i, g.u = ss(n.amount || n.each) || 0, r = r && y < 0 ? WI(r) : r
                }
                return y = (g[p] - g.min) / g.max || 0, kt(g.b + (r ? r(y) : y) * g.v) + g.u
            }
    },
    Wv = function(e) {
        var n = e < 1 ? Math.pow(10, (e + "").length - 2) : 1;
        return function(r) {
            var s = Math.round(parseFloat(r) / e) * e * n;
            return (s - s % 1) / n + (go(r) ? 0 : ss(r))
        }
    },
    FI = function(e, n) {
        var r = as(e),
            s, i;
        return !r && _o(e) && (s = r = e.radius || wi, e.values ? (e = As(e.values), (i = !go(e[0])) && (s *= s)) : e = Wv(e.increment)), $a(n, r ? Wn(e) ? function(o) {
            return i = e(o), Math.abs(i - o) <= s ? i : o
        } : function(o) {
            for (var a = parseFloat(i ? o.x : o), l = parseFloat(i ? o.y : 0), u = wi, f = 0, d = e.length, p, _; d--;) i ? (p = e[d].x - a, _ = e[d].y - l, p = p * p + _ * _) : p = Math.abs(e[d] - a), p < u && (u = p, f = d);
            return f = !s || u <= s ? e[f] : o, i || f === o || go(o) ? f : f + ss(o)
        } : Wv(e))
    },
    UI = function(e, n, r, s) {
        return $a(as(e) ? !n : r === !0 ? !!(r = 0) : !s, function() {
            return as(e) ? e[~~(Math.random() * e.length)] : (r = r || 1e-5) && (s = r < 1 ? Math.pow(10, (r + "").length - 2) : 1) && Math.floor(Math.round((e - r / 2 + Math.random() * (n - e + r * .99)) / r) * r * s) / s
        })
    },
    n9e = function() {
        for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
        return function(s) {
            return n.reduce(function(i, o) {
                return o(i)
            }, s)
        }
    },
    r9e = function(e, n) {
        return function(r) {
            return e(parseFloat(r)) + (n || ss(r))
        }
    },
    s9e = function(e, n, r) {
        return qI(e, n, 0, 1, r)
    },
    BI = function(e, n, r) {
        return $a(r, function(s) {
            return e[~~n(s)]
        })
    },
    i9e = function t(e, n, r) {
        var s = n - e;
        return as(e) ? BI(e, t(0, e.length), n) : $a(r, function(i) {
            return (s + (i - e) % s) % s + e
        })
    },
    o9e = function t(e, n, r) {
        var s = n - e,
            i = s * 2;
        return as(e) ? BI(e, t(0, e.length - 1), n) : $a(r, function(o) {
            return o = (i + (o - e) % i) % i || 0, e + (o > s ? i - o : o)
        })
    },
    Fg = function(e) {
        for (var n = 0, r = "", s, i, o, a; ~(s = e.indexOf("random(", n));) o = e.indexOf(")", s), a = e.charAt(s + 7) === "[", i = e.substr(s + 7, o - s - 7).match(a ? TI : Uv), r += e.substr(n, s - n) + UI(a ? i : +i[0], a ? 0 : +i[1], +i[2] || 1e-5), n = o + 1;
        return r + e.substr(n, e.length - n)
    },
    qI = function(e, n, r, s, i) {
        var o = n - e,
            a = s - r;
        return $a(i, function(l) {
            return r + ((l - e) / o * a || 0)
        })
    },
    a9e = function t(e, n, r, s) {
        var i = isNaN(e + n) ? 0 : function(_) {
            return (1 - _) * e + _ * n
        };
        if (!i) {
            var o = dr(e),
                a = {},
                l, u, f, d, p;
            if (r === !0 && (s = 1) && (r = null), o) e = {
                p: e
            }, n = {
                p: n
            };
            else if (as(e) && !as(n)) {
                for (f = [], d = e.length, p = d - 2, u = 1; u < d; u++) f.push(t(e[u - 1], e[u]));
                d--, i = function(v) {
                    v *= d;
                    var y = Math.min(p, ~~v);
                    return f[y](v - y)
                }, r = n
            } else s || (e = pu(as(e) ? [] : {}, e));
            if (!f) {
                for (l in n) Xb.call(a, e, l, "get", n[l]);
                i = function(v) {
                    return e5(v, a) || (o ? e.p : e)
                }
            }
        }
        return $a(r, i)
    },
    c8 = function(e, n, r) {
        var s = e.labels,
            i = wi,
            o, a, l;
        for (o in s) a = s[o] - n, a < 0 == !!r && a && i > (a = Math.abs(a)) && (l = o, i = a);
        return l
    },
    rs = function(e, n, r) {
        var s = e.vars,
            i = s[n],
            o, a;
        if (i) return o = s[n + "Params"], a = s.callbackScope || e, r && oa.length && Em(), o ? i.apply(a, o) : i.call(a)
    },
    mh = function(e) {
        return ya(e), e.scrollTrigger && e.scrollTrigger.kill(!1), e.progress() < 1 && rs(e, "onInterrupt"), e
    },
    bl, c9e = function(e) {
        e = !e.name && e.default || e;
        var n = e.name,
            r = Wn(e),
            s = n && !r && e.init ? function() {
                this._props = []
            } : e,
            i = {
                init: du,
                render: e5,
                add: Xb,
                kill: w9e,
                modifier: S9e,
                rawVars: 0
            },
            o = {
                targetTest: 0,
                get: 0,
                getSetter: Jb,
                aliases: {},
                register: 0
            };
        if (_u(), e !== s) {
            if (es[n]) return;
            Rs(s, Rs(Gv(e, i), o)), pu(s.prototype, pu(i, Gv(e, o))), es[s.prop = n] = s, e.targetTest && (Hp.push(s), Yb[n] = 1), n = (n === "css" ? "CSS" : n.charAt(0).toUpperCase() + n.substr(1)) + "Plugin"
        }
        AI(n, s), e.register && e.register(Di, s, Ur)
    },
    Ht = 255,
    gh = {
        aqua: [0, Ht, Ht],
        lime: [0, Ht, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, Ht],
        navy: [0, 0, 128],
        white: [Ht, Ht, Ht],
        olive: [128, 128, 0],
        yellow: [Ht, Ht, 0],
        orange: [Ht, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [Ht, 0, 0],
        pink: [Ht, 192, 203],
        cyan: [0, Ht, Ht],
        transparent: [Ht, Ht, Ht, 0]
    },
    e0 = function(e, n, r) {
        return e = e < 0 ? e + 1 : e > 1 ? e - 1 : e, (e * 6 < 1 ? n + (r - n) * e * 6 : e < .5 ? r : e * 3 < 2 ? n + (r - n) * (2 / 3 - e) * 6 : n) * Ht + .5 | 0
    },
    GI = function(e, n, r) {
        var s = e ? go(e) ? [e >> 16, e >> 8 & Ht, e & Ht] : 0 : gh.black,
            i, o, a, l, u, f, d, p, _, v;
        if (!s) {
            if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), gh[e]) s = gh[e];
            else if (e.charAt(0) === "#") {
                if (e.length < 6 && (i = e.charAt(1), o = e.charAt(2), a = e.charAt(3), e = "#" + i + i + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return s = parseInt(e.substr(1, 6), 16), [s >> 16, s >> 8 & Ht, s & Ht, parseInt(e.substr(7), 16) / 255];
                e = parseInt(e.substr(1), 16), s = [e >> 16, e >> 8 & Ht, e & Ht]
            } else if (e.substr(0, 3) === "hsl") {
                if (s = v = e.match(Uv), !n) l = +s[0] % 360 / 360, u = +s[1] / 100, f = +s[2] / 100, o = f <= .5 ? f * (u + 1) : f + u - f * u, i = f * 2 - o, s.length > 3 && (s[3] *= 1), s[0] = e0(l + 1 / 3, i, o), s[1] = e0(l, i, o), s[2] = e0(l - 1 / 3, i, o);
                else if (~e.indexOf("=")) return s = e.match(bI), r && s.length < 4 && (s[3] = 1), s
            } else s = e.match(Uv) || gh.transparent;
            s = s.map(Number)
        }
        return n && !v && (i = s[0] / Ht, o = s[1] / Ht, a = s[2] / Ht, d = Math.max(i, o, a), p = Math.min(i, o, a), f = (d + p) / 2, d === p ? l = u = 0 : (_ = d - p, u = f > .5 ? _ / (2 - d - p) : _ / (d + p), l = d === i ? (o - a) / _ + (o < a ? 6 : 0) : d === o ? (a - i) / _ + 2 : (i - o) / _ + 4, l *= 60), s[0] = ~~(l + .5), s[1] = ~~(u * 100 + .5), s[2] = ~~(f * 100 + .5)), r && s.length < 4 && (s[3] = 1), s
    },
    VI = function(e) {
        var n = [],
            r = [],
            s = -1;
        return e.split(aa).forEach(function(i) {
            var o = i.match(vl) || [];
            n.push.apply(n, o), r.push(s += o.length + 1)
        }), n.c = r, n
    },
    l8 = function(e, n, r) {
        var s = "",
            i = (e + s).match(aa),
            o = n ? "hsla(" : "rgba(",
            a = 0,
            l, u, f, d;
        if (!i) return e;
        if (i = i.map(function(p) {
                return (p = GI(p, n, 1)) && o + (n ? p[0] + "," + p[1] + "%," + p[2] + "%," + p[3] : p.join(",")) + ")"
            }), r && (f = VI(e), l = r.c, l.join(s) !== f.c.join(s)))
            for (u = e.replace(aa, "1").split(vl), d = u.length - 1; a < d; a++) s += u[a] + (~l.indexOf(a) ? i.shift() || o + "0,0,0,0)" : (f.length ? f : i.length ? i : r).shift());
        if (!u)
            for (u = e.split(aa), d = u.length - 1; a < d; a++) s += u[a] + i[a];
        return s + u[d]
    },
    aa = function() {
        var t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
            e;
        for (e in gh) t += "|" + e + "\\b";
        return new RegExp(t + ")", "gi")
    }(),
    l9e = /hsl[a]?\(/,
    jI = function(e) {
        var n = e.join(" "),
            r;
        if (aa.lastIndex = 0, aa.test(n)) return r = l9e.test(n), e[1] = l8(e[1], r), e[0] = l8(e[0], r, VI(e[1])), !0
    },
    Sm, Ss = function() {
        var t = Date.now,
            e = 500,
            n = 33,
            r = t(),
            s = r,
            i = 1e3 / 240,
            o = i,
            a = [],
            l, u, f, d, p, _, v = function y(g) {
                var b = t() - s,
                    O = g === !0,
                    N, k, A, x;
                if (b > e && (r += b - n), s += b, A = s - r, N = A - o, (N > 0 || O) && (x = ++d.frame, p = A - d.time * 1e3, d.time = A = A / 1e3, o += N + (N >= i ? 4 : i - N), k = 1), O || (l = u(y)), k)
                    for (_ = 0; _ < a.length; _++) a[_](A, p, x, g)
            };
        return d = {
            time: 0,
            frame: 0,
            tick: function() {
                v(!0)
            },
            deltaRatio: function(g) {
                return p / (1e3 / (g || 60))
            },
            wake: function() {
                SI && (!Bv && yI() && (gi = Bv = window, Wb = gi.document || {}, us.gsap = Di, (gi.gsapVersions || (gi.gsapVersions = [])).push(Di.version), wI(vm || gi.GreenSockGlobals || !gi.gsap && gi || {}), f = gi.requestAnimationFrame), l && d.sleep(), u = f || function(g) {
                    return setTimeout(g, o - d.time * 1e3 + 1 | 0)
                }, Sm = 1, v(2))
            },
            sleep: function() {
                (f ? gi.cancelAnimationFrame : clearTimeout)(l), Sm = 0, u = du
            },
            lagSmoothing: function(g, b) {
                e = g || 1 / Bt, n = Math.min(b, e, 0)
            },
            fps: function(g) {
                i = 1e3 / (g || 240), o = d.time * 1e3 + i
            },
            add: function(g) {
                a.indexOf(g) < 0 && a.push(g), _u()
            },
            remove: function(g) {
                var b;
                ~(b = a.indexOf(g)) && a.splice(b, 1) && _ >= b && _--
            },
            _listeners: a
        }, d
    }(),
    _u = function() {
        return !Sm && Ss.wake()
    },
    xt = {},
    u9e = /^[\d.\-M][\d.\-,\s]/,
    h9e = /["']/g,
    f9e = function(e) {
        for (var n = {}, r = e.substr(1, e.length - 3).split(":"), s = r[0], i = 1, o = r.length, a, l, u; i < o; i++) l = r[i], a = i !== o - 1 ? l.lastIndexOf(",") : l.length, u = l.substr(0, a), n[s] = isNaN(u) ? u.replace(h9e, "").trim() : +u, s = l.substr(a + 1).trim();
        return n
    },
    d9e = function(e) {
        var n = e.indexOf("(") + 1,
            r = e.indexOf(")"),
            s = e.indexOf("(", n);
        return e.substring(n, ~s && s < r ? e.indexOf(")", r + 1) : r)
    },
    p9e = function(e) {
        var n = (e + "").split("("),
            r = xt[n[0]];
        return r && n.length > 1 && r.config ? r.config.apply(null, ~e.indexOf("{") ? [f9e(n[1])] : d9e(e).split(",").map(II)) : xt._CE && u9e.test(e) ? xt._CE("", e) : r
    },
    WI = function(e) {
        return function(n) {
            return 1 - e(1 - n)
        }
    },
    HI = function t(e, n) {
        for (var r = e._first, s; r;) r instanceof Mr ? t(r, n) : r.vars.yoyoEase && (!r._yoyo || !r._repeat) && r._yoyo !== n && (r.timeline ? t(r.timeline, n) : (s = r._ease, r._ease = r._yEase, r._yEase = s, r._yoyo = n)), r = r._next
    },
    Ul = function(e, n) {
        return e && (Wn(e) ? e : xt[e] || p9e(e)) || n
    },
    Gc = function(e, n, r, s) {
        r === void 0 && (r = function(l) {
            return 1 - n(1 - l)
        }), s === void 0 && (s = function(l) {
            return l < .5 ? n(l * 2) / 2 : 1 - n((1 - l) * 2) / 2
        });
        var i = {
                easeIn: n,
                easeOut: r,
                easeInOut: s
            },
            o;
        return cs(e, function(a) {
            xt[a] = us[a] = i, xt[o = a.toLowerCase()] = r;
            for (var l in i) xt[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = xt[a + "." + l] = i[l]
        }), i
    },
    YI = function(e) {
        return function(n) {
            return n < .5 ? (1 - e(1 - n * 2)) / 2 : .5 + e((n - .5) * 2) / 2
        }
    },
    t0 = function t(e, n, r) {
        var s = n >= 1 ? n : 1,
            i = (r || (e ? .3 : .45)) / (n < 1 ? n : 1),
            o = i / Fv * (Math.asin(1 / s) || 0),
            a = function(f) {
                return f === 1 ? 1 : s * Math.pow(2, -10 * f) * q7e((f - o) * i) + 1
            },
            l = e === "out" ? a : e === "in" ? function(u) {
                return 1 - a(1 - u)
            } : YI(a);
        return i = Fv / i, l.config = function(u, f) {
            return t(e, u, f)
        }, l
    },
    n0 = function t(e, n) {
        n === void 0 && (n = 1.70158);
        var r = function(o) {
                return o ? --o * o * ((n + 1) * o + n) + 1 : 0
            },
            s = e === "out" ? r : e === "in" ? function(i) {
                return 1 - r(1 - i)
            } : YI(r);
        return s.config = function(i) {
            return t(e, i)
        }, s
    };
cs("Linear,Quad,Cubic,Quart,Quint,Strong", function(t, e) {
    var n = e < 5 ? e + 1 : e;
    Gc(t + ",Power" + (n - 1), e ? function(r) {
        return Math.pow(r, n)
    } : function(r) {
        return r
    }, function(r) {
        return 1 - Math.pow(1 - r, n)
    }, function(r) {
        return r < .5 ? Math.pow(r * 2, n) / 2 : 1 - Math.pow((1 - r) * 2, n) / 2
    })
});
xt.Linear.easeNone = xt.none = xt.Linear.easeIn;
Gc("Elastic", t0("in"), t0("out"), t0());
(function(t, e) {
    var n = 1 / e,
        r = 2 * n,
        s = 2.5 * n,
        i = function(a) {
            return a < n ? t * a * a : a < r ? t * Math.pow(a - 1.5 / e, 2) + .75 : a < s ? t * (a -= 2.25 / e) * a + .9375 : t * Math.pow(a - 2.625 / e, 2) + .984375
        };
    Gc("Bounce", function(o) {
        return 1 - i(1 - o)
    }, i)
})(7.5625, 2.75);
Gc("Expo", function(t) {
    return t ? Math.pow(2, 10 * (t - 1)) : 0
});
Gc("Circ", function(t) {
    return -(_I(1 - t * t) - 1)
});
Gc("Sine", function(t) {
    return t === 1 ? 1 : -B7e(t * F7e) + 1
});
Gc("Back", n0("in"), n0("out"), n0());
xt.SteppedEase = xt.steps = us.SteppedEase = {
    config: function(e, n) {
        e === void 0 && (e = 1);
        var r = 1 / e,
            s = e + (n ? 0 : 1),
            i = n ? 1 : 0,
            o = 1 - Bt;
        return function(a) {
            return ((s * ud(0, o, a) | 0) + i) * r
        }
    }
};
fu.ease = xt["quad.out"];
cs("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(t) {
    return zb += t + "," + t + "Params,"
});
var zI = function(e, n) {
        this.id = U7e++, e._gsap = this, this.target = e, this.harness = n, this.get = n ? n.get : CI, this.set = n ? n.getSetter : Jb
    },
    Cf = function() {
        function t(n) {
            this.vars = n, this._delay = +n.delay || 0, (this._repeat = n.repeat === 1 / 0 ? -2 : n.repeat || 0) && (this._rDelay = n.repeatDelay || 0, this._yoyo = !!n.yoyo || !!n.yoyoEase), this._ts = 1, gu(this, +n.duration, 1, 1), this.data = n.data, Sm || Ss.wake()
        }
        var e = t.prototype;
        return e.delay = function(r) {
            return r || r === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + r - this._delay), this._delay = r, this) : this._delay
        }, e.duration = function(r) {
            return arguments.length ? this.totalDuration(this._repeat > 0 ? r + (r + this._rDelay) * this._repeat : r) : this.totalDuration() && this._dur
        }, e.totalDuration = function(r) {
            return arguments.length ? (this._dirty = 0, gu(this, this._repeat < 0 ? r : (r - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }, e.totalTime = function(r, s) {
            if (_u(), !arguments.length) return this._tTime;
            var i = this._dp;
            if (i && i.smoothChildTiming && this._ts) {
                for (xI(this, r), !i._dp || i.parent || PI(i, this); i.parent;) i.parent._time !== i._start + (i._ts >= 0 ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0), i = i.parent;
                !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && r < this._tDur || this._ts < 0 && r > 0 || !this._tDur && !r) && Ti(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== r || !this._dur && !s || this._initted && Math.abs(this._zTime) === Bt || !r && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = r), kI(this, r, s)), this
        }, e.time = function(r, s) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), r + o8(this)) % this._dur || (r ? this._dur : 0), s) : this._time
        }, e.totalProgress = function(r, s) {
            return arguments.length ? this.totalTime(this.totalDuration() * r, s) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
        }, e.progress = function(r, s) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - r : r) + o8(this), s) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
        }, e.iteration = function(r, s) {
            var i = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (r - 1) * i, s) : this._repeat ? mu(this._tTime, i) + 1 : 1
        }, e.timeScale = function(r) {
            if (!arguments.length) return this._rts === -Bt ? 0 : this._rts;
            if (this._rts === r) return this;
            var s = this.parent && this._ts ? Tm(this.parent._time, this) : this._tTime;
            return this._rts = +r || 0, this._ts = this._ps || r === -Bt ? 0 : this._rts, Y7e(this.totalTime(ud(-this._delay, this._tDur, s), !0))
        }, e.paused = function(r) {
            return arguments.length ? (this._ps !== r && (this._ps = r, r ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (_u(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && (this._tTime -= Bt) && Math.abs(this._zTime) !== Bt))), this) : this._ps
        }, e.startTime = function(r) {
            if (arguments.length) {
                this._start = r;
                var s = this.parent || this._dp;
                return s && (s._sort || !this.parent) && Ti(s, this, r - this._delay), this
            }
            return this._start
        }, e.endTime = function(r) {
            return this._start + (Fr(r) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
        }, e.rawTime = function(r) {
            var s = this.parent || this._dp;
            return s ? r && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Tm(s.rawTime(r), this) : this._tTime : this._tTime
        }, e.globalTime = function(r) {
            for (var s = this, i = arguments.length ? r : s.rawTime(); s;) i = s._start + i / (s._ts || 1), s = s._dp;
            return i
        }, e.repeat = function(r) {
            return arguments.length ? (this._repeat = r === 1 / 0 ? -2 : r, a8(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
        }, e.repeatDelay = function(r) {
            return arguments.length ? (this._rDelay = r, a8(this)) : this._rDelay
        }, e.yoyo = function(r) {
            return arguments.length ? (this._yoyo = r, this) : this._yoyo
        }, e.seek = function(r, s) {
            return this.totalTime(Es(this, r), Fr(s))
        }, e.restart = function(r, s) {
            return this.play().totalTime(r ? -this._delay : 0, Fr(s))
        }, e.play = function(r, s) {
            return r != null && this.seek(r, s), this.reversed(!1).paused(!1)
        }, e.reverse = function(r, s) {
            return r != null && this.seek(r || this.totalDuration(), s), this.reversed(!0).paused(!1)
        }, e.pause = function(r, s) {
            return r != null && this.seek(r, s), this.paused(!0)
        }, e.resume = function() {
            return this.paused(!1)
        }, e.reversed = function(r) {
            return arguments.length ? (!!r !== this.reversed() && this.timeScale(-this._rts || (r ? -Bt : 0)), this) : this._rts < 0
        }, e.invalidate = function() {
            return this._initted = this._act = 0, this._zTime = -Bt, this
        }, e.isActive = function() {
            var r = this.parent || this._dp,
                s = this._start,
                i;
            return !!(!r || this._ts && this._initted && r.isActive() && (i = r.rawTime(!0)) >= s && i < this.endTime(!0) - Bt)
        }, e.eventCallback = function(r, s, i) {
            var o = this.vars;
            return arguments.length > 1 ? (s ? (o[r] = s, i && (o[r + "Params"] = i), r === "onUpdate" && (this._onUpdate = s)) : delete o[r], this) : o[r]
        }, e.then = function(r) {
            var s = this;
            return new Promise(function(i) {
                var o = Wn(r) ? r : NI,
                    a = function() {
                        var u = s.then;
                        s.then = null, Wn(o) && (o = o(s)) && (o.then || o === s) && (s.then = u), i(o), s.then = u
                    };
                s._initted && s.totalProgress() === 1 && s._ts >= 0 || !s._tTime && s._ts < 0 ? a() : s._prom = a
            })
        }, e.kill = function() {
            mh(this)
        }, t
    }();
Rs(Cf.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -Bt,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var Mr = function(t) {
    gI(e, t);

    function e(r, s) {
        var i;
        return r === void 0 && (r = {}), i = t.call(this, r) || this, i.labels = {}, i.smoothChildTiming = !!r.smoothChildTiming, i.autoRemoveChildren = !!r.autoRemoveChildren, i._sort = Fr(r.sortChildren), pn && Ti(r.parent || pn, no(i), s), r.reversed && i.reverse(), r.paused && i.paused(!0), r.scrollTrigger && RI(no(i), r.scrollTrigger), i
    }
    var n = e.prototype;
    return n.to = function(s, i, o) {
        return Lh(0, arguments, this), this
    }, n.from = function(s, i, o) {
        return Lh(1, arguments, this), this
    }, n.fromTo = function(s, i, o, a) {
        return Lh(2, arguments, this), this
    }, n.set = function(s, i, o) {
        return i.duration = 0, i.parent = this, Yp(i).repeatDelay || (i.repeat = 0), i.immediateRender = !!i.immediateRender, new Vn(s, i, Es(this, o), 1), this
    }, n.call = function(s, i, o) {
        return Ti(this, Vn.delayedCall(0, s, i), o)
    }, n.staggerTo = function(s, i, o, a, l, u, f) {
        return o.duration = i, o.stagger = o.stagger || a, o.onComplete = u, o.onCompleteParams = f, o.parent = this, new Vn(s, o, Es(this, l)), this
    }, n.staggerFrom = function(s, i, o, a, l, u, f) {
        return o.runBackwards = 1, Yp(o).immediateRender = Fr(o.immediateRender), this.staggerTo(s, i, o, a, l, u, f)
    }, n.staggerFromTo = function(s, i, o, a, l, u, f, d) {
        return a.startAt = o, Yp(a).immediateRender = Fr(a.immediateRender), this.staggerTo(s, i, a, l, u, f, d)
    }, n.render = function(s, i, o) {
        var a = this._time,
            l = this._dirty ? this.totalDuration() : this._tDur,
            u = this._dur,
            f = this !== pn && s > l - Bt && s >= 0 ? l : s < Bt ? 0 : s,
            d = this._zTime < 0 != s < 0 && (this._initted || !u),
            p, _, v, y, g, b, O, N, k, A, x, D;
        if (f !== this._tTime || o || d) {
            if (a !== this._time && u && (f += this._time - a, s += this._time - a), p = f, k = this._start, N = this._ts, b = !N, d && (u || (a = this._zTime), (s || !i) && (this._zTime = s)), this._repeat) {
                if (x = this._yoyo, g = u + this._rDelay, this._repeat < -1 && s < 0) return this.totalTime(g * 100 + s, i, o);
                if (p = kt(f % g), f === l ? (y = this._repeat, p = u) : (y = ~~(f / g), y && y === f / g && (p = u, y--), p > u && (p = u)), A = mu(this._tTime, g), !a && this._tTime && A !== y && (A = y), x && y & 1 && (p = u - p, D = 1), y !== A && !this._lock) {
                    var L = x && A & 1,
                        q = L === (x && y & 1);
                    if (y < A && (L = !L), a = L ? 0 : u, this._lock = 1, this.render(a || (D ? 0 : kt(y * g)), i, !u)._lock = 0, this._tTime = f, !i && this.parent && rs(this, "onRepeat"), this.vars.repeatRefresh && !D && (this.invalidate()._lock = 1), a && a !== this._time || b !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                    if (u = this._dur, l = this._tDur, q && (this._lock = 2, a = L ? u : -1e-4, this.render(a, !0), this.vars.repeatRefresh && !D && this.invalidate()), this._lock = 0, !this._ts && !b) return this;
                    HI(this, D)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (O = X7e(this, kt(a), kt(p)), O && (f -= p - (p = O._start))), this._tTime = f, this._time = p, this._act = !N, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = s, a = 0), !a && p && !i && (rs(this, "onStart"), this._tTime !== f)) return this;
            if (p >= a && s >= 0)
                for (_ = this._first; _;) {
                    if (v = _._next, (_._act || p >= _._start) && _._ts && O !== _) {
                        if (_.parent !== this) return this.render(s, i, o);
                        if (_.render(_._ts > 0 ? (p - _._start) * _._ts : (_._dirty ? _.totalDuration() : _._tDur) + (p - _._start) * _._ts, i, o), p !== this._time || !this._ts && !b) {
                            O = 0, v && (f += this._zTime = -Bt);
                            break
                        }
                    }
                    _ = v
                } else {
                    _ = this._last;
                    for (var ee = s < 0 ? s : p; _;) {
                        if (v = _._prev, (_._act || ee <= _._end) && _._ts && O !== _) {
                            if (_.parent !== this) return this.render(s, i, o);
                            if (_.render(_._ts > 0 ? (ee - _._start) * _._ts : (_._dirty ? _.totalDuration() : _._tDur) + (ee - _._start) * _._ts, i, o), p !== this._time || !this._ts && !b) {
                                O = 0, v && (f += this._zTime = ee ? -Bt : Bt);
                                break
                            }
                        }
                        _ = v
                    }
                }
            if (O && !i && (this.pause(), O.render(p >= a ? 0 : -Bt)._zTime = p >= a ? 1 : -1, this._ts)) return this._start = k, Zb(this), this.render(s, i, o);
            this._onUpdate && !i && rs(this, "onUpdate", !0), (f === l && l >= this.totalDuration() || !f && a) && (k === this._start || Math.abs(N) !== Math.abs(this._ts)) && (this._lock || ((s || !u) && (f === l && this._ts > 0 || !f && this._ts < 0) && ya(this, 1), !i && !(s < 0 && !a) && (f || a || !l) && (rs(this, f === l && s >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(f < l && this.timeScale() > 0) && this._prom())))
        }
        return this
    }, n.add = function(s, i) {
        var o = this;
        if (go(i) || (i = Es(this, i, s)), !(s instanceof Cf)) {
            if (as(s)) return s.forEach(function(a) {
                return o.add(a, i)
            }), this;
            if (dr(s)) return this.addLabel(s, i);
            if (Wn(s)) s = Vn.delayedCall(0, s);
            else return this
        }
        return this !== s ? Ti(this, s, i) : this
    }, n.getChildren = function(s, i, o, a) {
        s === void 0 && (s = !0), i === void 0 && (i = !0), o === void 0 && (o = !0), a === void 0 && (a = -wi);
        for (var l = [], u = this._first; u;) u._start >= a && (u instanceof Vn ? i && l.push(u) : (o && l.push(u), s && l.push.apply(l, u.getChildren(!0, i, o)))), u = u._next;
        return l
    }, n.getById = function(s) {
        for (var i = this.getChildren(1, 1, 1), o = i.length; o--;)
            if (i[o].vars.id === s) return i[o]
    }, n.remove = function(s) {
        return dr(s) ? this.removeLabel(s) : Wn(s) ? this.killTweensOf(s) : (Lg(this, s), s === this._recent && (this._recent = this._last), bc(this))
    }, n.totalTime = function(s, i) {
        return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = kt(Ss.time - (this._ts > 0 ? s / this._ts : (this.totalDuration() - s) / -this._ts))), t.prototype.totalTime.call(this, s, i), this._forcing = 0, this) : this._tTime
    }, n.addLabel = function(s, i) {
        return this.labels[s] = Es(this, i), this
    }, n.removeLabel = function(s) {
        return delete this.labels[s], this
    }, n.addPause = function(s, i, o) {
        var a = Vn.delayedCall(0, i || du, o);
        return a.data = "isPause", this._hasPause = 1, Ti(this, a, Es(this, s))
    }, n.removePause = function(s) {
        var i = this._first;
        for (s = Es(this, s); i;) i._start === s && i.data === "isPause" && ya(i), i = i._next
    }, n.killTweensOf = function(s, i, o) {
        for (var a = this.getTweensOf(s, o), l = a.length; l--;) Ko !== a[l] && a[l].kill(s, i);
        return this
    }, n.getTweensOf = function(s, i) {
        for (var o = [], a = As(s), l = this._first, u = go(i), f; l;) l instanceof Vn ? V7e(l._targets, a) && (u ? (!Ko || l._initted && l._ts) && l.globalTime(0) <= i && l.globalTime(l.totalDuration()) > i : !i || l.isActive()) && o.push(l) : (f = l.getTweensOf(a, i)).length && o.push.apply(o, f), l = l._next;
        return o
    }, n.tweenTo = function(s, i) {
        i = i || {};
        var o = this,
            a = Es(o, s),
            l = i,
            u = l.startAt,
            f = l.onStart,
            d = l.onStartParams,
            p = l.immediateRender,
            _, v = Vn.to(o, Rs({
                ease: i.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: a,
                overwrite: "auto",
                duration: i.duration || Math.abs((a - (u && "time" in u ? u.time : o._time)) / o.timeScale()) || Bt,
                onStart: function() {
                    if (o.pause(), !_) {
                        var g = i.duration || Math.abs((a - (u && "time" in u ? u.time : o._time)) / o.timeScale());
                        v._dur !== g && gu(v, g, 0, 1).render(v._time, !0, !0), _ = 1
                    }
                    f && f.apply(v, d || [])
                }
            }, i));
        return p ? v.render(0) : v
    }, n.tweenFromTo = function(s, i, o) {
        return this.tweenTo(i, Rs({
            startAt: {
                time: Es(this, s)
            }
        }, o))
    }, n.recent = function() {
        return this._recent
    }, n.nextLabel = function(s) {
        return s === void 0 && (s = this._time), c8(this, Es(this, s))
    }, n.previousLabel = function(s) {
        return s === void 0 && (s = this._time), c8(this, Es(this, s), 1)
    }, n.currentLabel = function(s) {
        return arguments.length ? this.seek(s, !0) : this.previousLabel(this._time + Bt)
    }, n.shiftChildren = function(s, i, o) {
        o === void 0 && (o = 0);
        for (var a = this._first, l = this.labels, u; a;) a._start >= o && (a._start += s, a._end += s), a = a._next;
        if (i)
            for (u in l) l[u] >= o && (l[u] += s);
        return bc(this)
    }, n.invalidate = function() {
        var s = this._first;
        for (this._lock = 0; s;) s.invalidate(), s = s._next;
        return t.prototype.invalidate.call(this)
    }, n.clear = function(s) {
        s === void 0 && (s = !0);
        for (var i = this._first, o; i;) o = i._next, this.remove(i), i = o;
        return this._dp && (this._time = this._tTime = this._pTime = 0), s && (this.labels = {}), bc(this)
    }, n.totalDuration = function(s) {
        var i = 0,
            o = this,
            a = o._last,
            l = wi,
            u, f, d;
        if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -s : s));
        if (o._dirty) {
            for (d = o.parent; a;) u = a._prev, a._dirty && a.totalDuration(), f = a._start, f > l && o._sort && a._ts && !o._lock ? (o._lock = 1, Ti(o, a, f - a._delay, 1)._lock = 0) : l = f, f < 0 && a._ts && (i -= f, (!d && !o._dp || d && d.smoothChildTiming) && (o._start += f / o._ts, o._time -= f, o._tTime -= f), o.shiftChildren(-f, !1, -1 / 0), l = 0), a._end > i && a._ts && (i = a._end), a = u;
            gu(o, o === pn && o._time > i ? o._time : i, 1, 1), o._dirty = 0
        }
        return o._tDur
    }, e.updateRoot = function(s) {
        if (pn._ts && (kI(pn, Tm(s, pn)), OI = Ss.frame), Ss.frame >= s8) {
            s8 += $r.autoSleep || 120;
            var i = pn._first;
            if ((!i || !i._ts) && $r.autoSleep && Ss._listeners.length < 2) {
                for (; i && !i._ts;) i = i._next;
                i || Ss.sleep()
            }
        }
    }, e
}(Cf);
Rs(Mr.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var m9e = function(e, n, r, s, i, o, a) {
        var l = new Ur(this._pt, e, n, 0, 1, JI, null, i),
            u = 0,
            f = 0,
            d, p, _, v, y, g, b, O;
        for (l.b = r, l.e = s, r += "", s += "", (b = ~s.indexOf("random(")) && (s = Fg(s)), o && (O = [r, s], o(O, e, n), r = O[0], s = O[1]), p = r.match(Qy) || []; d = Qy.exec(s);) v = d[0], y = s.substring(u, d.index), _ ? _ = (_ + 1) % 5 : y.substr(-5) === "rgba(" && (_ = 1), v !== p[f++] && (g = parseFloat(p[f - 1]) || 0, l._pt = {
            _next: l._pt,
            p: y || f === 1 ? y : ",",
            s: g,
            c: v.charAt(1) === "=" ? parseFloat(v.substr(2)) * (v.charAt(0) === "-" ? -1 : 1) : parseFloat(v) - g,
            m: _ && _ < 4 ? Math.round : 0
        }, u = Qy.lastIndex);
        return l.c = u < s.length ? s.substring(u, s.length) : "", l.fp = a, (EI.test(s) || b) && (l.e = 0), this._pt = l, l
    },
    Xb = function(e, n, r, s, i, o, a, l, u) {
        Wn(s) && (s = s(i || 0, e, o));
        var f = e[n],
            d = r !== "get" ? r : Wn(f) ? u ? e[n.indexOf("set") || !Wn(e["get" + n.substr(3)]) ? n : "get" + n.substr(3)](u) : e[n]() : f,
            p = Wn(f) ? u ? b9e : XI : Qb,
            _;
        if (dr(s) && (~s.indexOf("random(") && (s = Fg(s)), s.charAt(1) === "=" && (_ = parseFloat(d) + parseFloat(s.substr(2)) * (s.charAt(0) === "-" ? -1 : 1) + (ss(d) || 0), (_ || _ === 0) && (s = _))), d !== s) return !isNaN(d * s) && s !== "" ? (_ = new Ur(this._pt, e, n, +d || 0, s - (d || 0), typeof f == "boolean" ? T9e : QI, 0, p), u && (_.fp = u), a && _.modifier(a, this, e), this._pt = _) : (!f && !(n in e) && Hb(n, s), m9e.call(this, e, n, d, s, p, l || $r.stringFilter, u))
    },
    g9e = function(e, n, r, s, i) {
        if (Wn(e) && (e = Fh(e, i, n, r, s)), !_o(e) || e.style && e.nodeType || as(e) || vI(e)) return dr(e) ? Fh(e, i, n, r, s) : e;
        var o = {},
            a;
        for (a in e) o[a] = Fh(e[a], i, n, r, s);
        return o
    },
    KI = function(e, n, r, s, i, o) {
        var a, l, u, f;
        if (es[e] && (a = new es[e]).init(i, a.rawVars ? n[e] : g9e(n[e], s, i, o, r), r, s, o) !== !1 && (r._pt = l = new Ur(r._pt, i, e, 0, 1, a.render, a, 0, a.priority), r !== bl))
            for (u = r._ptLookup[r._targets.indexOf(i)], f = a._props.length; f--;) u[a._props[f]] = l;
        return a
    },
    Ko, _9e = function t(e, n) {
        var r = e.vars,
            s = r.ease,
            i = r.startAt,
            o = r.immediateRender,
            a = r.lazy,
            l = r.onUpdate,
            u = r.onUpdateParams,
            f = r.callbackScope,
            d = r.runBackwards,
            p = r.yoyoEase,
            _ = r.keyframes,
            v = r.autoRevert,
            y = e._dur,
            g = e._startAt,
            b = e._targets,
            O = e.parent,
            N = O && O.data === "nested" ? O.parent._targets : b,
            k = e._overwrite === "auto" && !Vb,
            A = e.timeline,
            x, D, L, q, ee, ae, Z, fe, ge, K, Q, ue, _e;
        if (A && (!_ || !s) && (s = "none"), e._ease = Ul(s, fu.ease), e._yEase = p ? WI(Ul(p === !0 ? s : p, fu.ease)) : 0, p && e._yoyo && !e._repeat && (p = e._yEase, e._yEase = e._ease, e._ease = p), e._from = !A && !!r.runBackwards, !A) {
            if (fe = b[0] ? vc(b[0]).harness : 0, ue = fe && r[fe.prop], x = Gv(r, Yb), g && g.render(-1, !0).kill(), i)
                if (ya(e._startAt = Vn.set(b, Rs({
                        data: "isStart",
                        overwrite: !1,
                        parent: O,
                        immediateRender: !0,
                        lazy: Fr(a),
                        startAt: null,
                        delay: 0,
                        onUpdate: l,
                        onUpdateParams: u,
                        callbackScope: f,
                        stagger: 0
                    }, i))), n < 0 && !o && !v && e._startAt.render(-1, !0), o) {
                    if (n > 0 && !v && (e._startAt = 0), y && n <= 0) {
                        n && (e._zTime = n);
                        return
                    }
                } else v === !1 && (e._startAt = 0);
            else if (d && y) {
                if (g) !v && (e._startAt = 0);
                else if (n && (o = !1), L = Rs({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: o && Fr(a),
                        immediateRender: o,
                        stagger: 0,
                        parent: O
                    }, x), ue && (L[fe.prop] = ue), ya(e._startAt = Vn.set(b, L)), n < 0 && e._startAt.render(-1, !0), !o) t(e._startAt, Bt);
                else if (!n) return
            }
            for (e._pt = 0, a = y && Fr(a) || a && !y, D = 0; D < b.length; D++) {
                if (ee = b[D], Z = ee._gsap || Kb(b)[D]._gsap, e._ptLookup[D] = K = {}, qv[Z.id] && oa.length && Em(), Q = N === b ? D : N.indexOf(ee), fe && (ge = new fe).init(ee, ue || x, e, Q, N) !== !1 && (e._pt = q = new Ur(e._pt, ee, ge.name, 0, 1, ge.render, ge, 0, ge.priority), ge._props.forEach(function(Oe) {
                        K[Oe] = q
                    }), ge.priority && (ae = 1)), !fe || ue)
                    for (L in x) es[L] && (ge = KI(L, x, e, Q, ee, N)) ? ge.priority && (ae = 1) : K[L] = q = Xb.call(e, ee, L, "get", x[L], Q, N, 0, r.stringFilter);
                e._op && e._op[D] && e.kill(ee, e._op[D]), k && e._pt && (Ko = e, pn.killTweensOf(ee, K, e.globalTime(0)), _e = !e.parent, Ko = 0), e._pt && a && (qv[Z.id] = 1)
            }
            ae && eN(e), e._onInit && e._onInit(e)
        }
        e._onUpdate = l, e._initted = (!e._op || e._pt) && !_e
    },
    y9e = function(e, n) {
        var r = e[0] ? vc(e[0]).harness : 0,
            s = r && r.aliases,
            i, o, a, l;
        if (!s) return n;
        i = pu({}, n);
        for (o in s)
            if (o in i)
                for (l = s[o].split(","), a = l.length; a--;) i[l[a]] = i[o];
        return i
    },
    Fh = function(e, n, r, s, i) {
        return Wn(e) ? e.call(n, r, s, i) : dr(e) && ~e.indexOf("random(") ? Fg(e) : e
    },
    ZI = zb + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
    v9e = (ZI + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
    Vn = function(t) {
        gI(e, t);

        function e(r, s, i, o) {
            var a;
            typeof s == "number" && (i.duration = s, s = i, i = null), a = t.call(this, o ? s : Yp(s)) || this;
            var l = a.vars,
                u = l.duration,
                f = l.delay,
                d = l.immediateRender,
                p = l.stagger,
                _ = l.overwrite,
                v = l.keyframes,
                y = l.defaults,
                g = l.scrollTrigger,
                b = l.yoyoEase,
                O = s.parent || pn,
                N = (as(r) || vI(r) ? go(r[0]) : "length" in s) ? [r] : As(r),
                k, A, x, D, L, q, ee, ae;
            if (a._targets = N.length ? Kb(N) : bm("GSAP target " + r + " not found. https://greensock.com", !$r.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = _, v || p || r8(u) || r8(f)) {
                if (s = a.vars, k = a.timeline = new Mr({
                        data: "nested",
                        defaults: y || {}
                    }), k.kill(), k.parent = k._dp = no(a), k._start = 0, v) Rs(k.vars.defaults, {
                    ease: "none"
                }), p ? N.forEach(function(Z, fe) {
                    return v.forEach(function(ge, K) {
                        return k.to(Z, ge, K ? ">" : fe * p)
                    })
                }) : v.forEach(function(Z) {
                    return k.to(N, Z, ">")
                });
                else {
                    if (D = N.length, ee = p ? LI(p) : du, _o(p))
                        for (L in p) ~ZI.indexOf(L) && (ae || (ae = {}), ae[L] = p[L]);
                    for (A = 0; A < D; A++) {
                        x = {};
                        for (L in s) v9e.indexOf(L) < 0 && (x[L] = s[L]);
                        x.stagger = 0, b && (x.yoyoEase = b), ae && pu(x, ae), q = N[A], x.duration = +Fh(u, no(a), A, q, N), x.delay = (+Fh(f, no(a), A, q, N) || 0) - a._delay, !p && D === 1 && x.delay && (a._delay = f = x.delay, a._start += f, x.delay = 0), k.to(q, x, ee(A, q, N))
                    }
                    k.duration() ? u = f = 0 : a.timeline = 0
                }
                u || a.duration(u = k.duration())
            } else a.timeline = 0;
            return _ === !0 && !Vb && (Ko = no(a), pn.killTweensOf(N), Ko = 0), Ti(O, no(a), i), s.reversed && a.reverse(), s.paused && a.paused(!0), (d || !u && !v && a._start === kt(O._time) && Fr(d) && z7e(no(a)) && O.data !== "nested") && (a._tTime = -Bt, a.render(Math.max(0, -f))), g && RI(no(a), g), a
        }
        var n = e.prototype;
        return n.render = function(s, i, o) {
            var a = this._time,
                l = this._tDur,
                u = this._dur,
                f = s > l - Bt && s >= 0 ? l : s < Bt ? 0 : s,
                d, p, _, v, y, g, b, O, N;
            if (!u) Z7e(this, s, i, o);
            else if (f !== this._tTime || !s || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 != s < 0) {
                if (d = f, O = this.timeline, this._repeat) {
                    if (v = u + this._rDelay, this._repeat < -1 && s < 0) return this.totalTime(v * 100 + s, i, o);
                    if (d = kt(f % v), f === l ? (_ = this._repeat, d = u) : (_ = ~~(f / v), _ && _ === f / v && (d = u, _--), d > u && (d = u)), g = this._yoyo && _ & 1, g && (N = this._yEase, d = u - d), y = mu(this._tTime, v), d === a && !o && this._initted) return this;
                    _ !== y && (O && this._yEase && HI(O, g), this.vars.repeatRefresh && !g && !this._lock && (this._lock = o = 1, this.render(kt(v * _), !0).invalidate()._lock = 0))
                }
                if (!this._initted) {
                    if (MI(this, s < 0 ? s : d, o, i)) return this._tTime = 0, this;
                    if (u !== this._dur) return this.render(s, i, o)
                }
                if (this._tTime = f, this._time = d, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = b = (N || this._ease)(d / u), this._from && (this.ratio = b = 1 - b), d && !a && !i && rs(this, "onStart"), d && !a && !i && (rs(this, "onStart"), this._tTime !== f)) return this;
                for (p = this._pt; p;) p.r(b, p.d), p = p._next;
                O && O.render(s < 0 ? s : !d && g ? -Bt : O._dur * b, i, o) || this._startAt && (this._zTime = s), this._onUpdate && !i && (s < 0 && this._startAt && this._startAt.render(s, !0, o), rs(this, "onUpdate")), this._repeat && _ !== y && this.vars.onRepeat && !i && this.parent && rs(this, "onRepeat"), (f === this._tDur || !f) && this._tTime === f && (s < 0 && this._startAt && !this._onUpdate && this._startAt.render(s, !0, !0), (s || !u) && (f === this._tDur && this._ts > 0 || !f && this._ts < 0) && ya(this, 1), !i && !(s < 0 && !a) && (f || a) && (rs(this, f === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(f < l && this.timeScale() > 0) && this._prom()))
            }
            return this
        }, n.targets = function() {
            return this._targets
        }, n.invalidate = function() {
            return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
        }, n.kill = function(s, i) {
            if (i === void 0 && (i = "all"), !s && (!i || i === "all")) return this._lazy = this._pt = 0, this.parent ? mh(this) : this;
            if (this.timeline) {
                var o = this.timeline.totalDuration();
                return this.timeline.killTweensOf(s, i, Ko && Ko.vars.overwrite !== !0)._first || mh(this), this.parent && o !== this.timeline.totalDuration() && gu(this, this._dur * this.timeline._tDur / o, 0, 1), this
            }
            var a = this._targets,
                l = s ? As(s) : a,
                u = this._ptLookup,
                f = this._pt,
                d, p, _, v, y, g, b;
            if ((!i || i === "all") && W7e(a, l)) return i === "all" && (this._pt = 0), mh(this);
            for (d = this._op = this._op || [], i !== "all" && (dr(i) && (y = {}, cs(i, function(O) {
                    return y[O] = 1
                }), i = y), i = y9e(a, i)), b = a.length; b--;)
                if (~l.indexOf(a[b])) {
                    p = u[b], i === "all" ? (d[b] = i, v = p, _ = {}) : (_ = d[b] = d[b] || {}, v = i);
                    for (y in v) g = p && p[y], g && ((!("kill" in g.d) || g.d.kill(y) === !0) && Lg(this, g, "_pt"), delete p[y]), _ !== "all" && (_[y] = 1)
                } return this._initted && !this._pt && f && mh(this), this
        }, e.to = function(s, i) {
            return new e(s, i, arguments[2])
        }, e.from = function(s, i) {
            return Lh(1, arguments)
        }, e.delayedCall = function(s, i, o, a) {
            return new e(i, 0, {
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: s,
                onComplete: i,
                onReverseComplete: i,
                onCompleteParams: o,
                onReverseCompleteParams: o,
                callbackScope: a
            })
        }, e.fromTo = function(s, i, o) {
            return Lh(2, arguments)
        }, e.set = function(s, i) {
            return i.duration = 0, i.repeatDelay || (i.repeat = 0), new e(s, i)
        }, e.killTweensOf = function(s, i, o) {
            return pn.killTweensOf(s, i, o)
        }, e
    }(Cf);
Rs(Vn.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
cs("staggerTo,staggerFrom,staggerFromTo", function(t) {
    Vn[t] = function() {
        var e = new Mr,
            n = jv.call(arguments, 0);
        return n.splice(t === "staggerFromTo" ? 5 : 4, 0, 0), e[t].apply(e, n)
    }
});
var Qb = function(e, n, r) {
        return e[n] = r
    },
    XI = function(e, n, r) {
        return e[n](r)
    },
    b9e = function(e, n, r, s) {
        return e[n](s.fp, r)
    },
    E9e = function(e, n, r) {
        return e.setAttribute(n, r)
    },
    Jb = function(e, n) {
        return Wn(e[n]) ? XI : jb(e[n]) && e.setAttribute ? E9e : Qb
    },
    QI = function(e, n) {
        return n.set(n.t, n.p, Math.round((n.s + n.c * e) * 1e6) / 1e6, n)
    },
    T9e = function(e, n) {
        return n.set(n.t, n.p, !!(n.s + n.c * e), n)
    },
    JI = function(e, n) {
        var r = n._pt,
            s = "";
        if (!e && n.b) s = n.b;
        else if (e === 1 && n.e) s = n.e;
        else {
            for (; r;) s = r.p + (r.m ? r.m(r.s + r.c * e) : Math.round((r.s + r.c * e) * 1e4) / 1e4) + s, r = r._next;
            s += n.c
        }
        n.set(n.t, n.p, s, n)
    },
    e5 = function(e, n) {
        for (var r = n._pt; r;) r.r(e, r.d), r = r._next
    },
    S9e = function(e, n, r, s) {
        for (var i = this._pt, o; i;) o = i._next, i.p === s && i.modifier(e, n, r), i = o
    },
    w9e = function(e) {
        for (var n = this._pt, r, s; n;) s = n._next, n.p === e && !n.op || n.op === e ? Lg(this, n, "_pt") : n.dep || (r = 1), n = s;
        return !r
    },
    A9e = function(e, n, r, s) {
        s.mSet(e, n, s.m.call(s.tween, r, s.mt), s)
    },
    eN = function(e) {
        for (var n = e._pt, r, s, i, o; n;) {
            for (r = n._next, s = i; s && s.pr > n.pr;) s = s._next;
            (n._prev = s ? s._prev : o) ? n._prev._next = n: i = n, (n._next = s) ? s._prev = n : o = n, n = r
        }
        e._pt = i
    },
    Ur = function() {
        function t(n, r, s, i, o, a, l, u, f) {
            this.t = r, this.s = i, this.c = o, this.p = s, this.r = a || QI, this.d = l || this, this.set = u || Qb, this.pr = f || 0, this._next = n, n && (n._prev = this)
        }
        var e = t.prototype;
        return e.modifier = function(r, s, i) {
            this.mSet = this.mSet || this.set, this.set = A9e, this.m = r, this.mt = i, this.tween = s
        }, t
    }();
cs(zb + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(t) {
    return Yb[t] = 1
});
us.TweenMax = us.TweenLite = Vn;
us.TimelineLite = us.TimelineMax = Mr;
pn = new Mr({
    sortChildren: !1,
    defaults: fu,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
$r.stringFilter = jI;
var wm = {
    registerPlugin: function() {
        for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
        n.forEach(function(s) {
            return c9e(s)
        })
    },
    timeline: function(e) {
        return new Mr(e)
    },
    getTweensOf: function(e, n) {
        return pn.getTweensOf(e, n)
    },
    getProperty: function(e, n, r, s) {
        dr(e) && (e = As(e)[0]);
        var i = vc(e || {}).get,
            o = r ? NI : II;
        return r === "native" && (r = ""), e && (n ? o((es[n] && es[n].get || i)(e, n, r, s)) : function(a, l, u) {
            return o((es[a] && es[a].get || i)(e, a, l, u))
        })
    },
    quickSetter: function(e, n, r) {
        if (e = As(e), e.length > 1) {
            var s = e.map(function(f) {
                    return Di.quickSetter(f, n, r)
                }),
                i = s.length;
            return function(f) {
                for (var d = i; d--;) s[d](f)
            }
        }
        e = e[0] || {};
        var o = es[n],
            a = vc(e),
            l = a.harness && (a.harness.aliases || {})[n] || n,
            u = o ? function(f) {
                var d = new o;
                bl._pt = 0, d.init(e, r ? f + r : f, bl, 0, [e]), d.render(1, d), bl._pt && e5(1, bl)
            } : a.set(e, l);
        return o ? u : function(f) {
            return u(e, l, r ? f + r : f, a, 1)
        }
    },
    isTweening: function(e) {
        return pn.getTweensOf(e, !0).length > 0
    },
    defaults: function(e) {
        return e && e.ease && (e.ease = Ul(e.ease, fu.ease)), i8(fu, e || {})
    },
    config: function(e) {
        return i8($r, e || {})
    },
    registerEffect: function(e) {
        var n = e.name,
            r = e.effect,
            s = e.plugins,
            i = e.defaults,
            o = e.extendTimeline;
        (s || "").split(",").forEach(function(a) {
            return a && !es[a] && !us[a] && bm(n + " effect requires " + a + " plugin.")
        }), Jy[n] = function(a, l, u) {
            return r(As(a), Rs(l || {}, i), u)
        }, o && (Mr.prototype[n] = function(a, l, u) {
            return this.add(Jy[n](a, _o(l) ? l : (u = l) && {}, this), u)
        })
    },
    registerEase: function(e, n) {
        xt[e] = Ul(n)
    },
    parseEase: function(e, n) {
        return arguments.length ? Ul(e, n) : xt
    },
    getById: function(e) {
        return pn.getById(e)
    },
    exportRoot: function(e, n) {
        e === void 0 && (e = {});
        var r = new Mr(e),
            s, i;
        for (r.smoothChildTiming = Fr(e.smoothChildTiming), pn.remove(r), r._dp = 0, r._time = r._tTime = pn._time, s = pn._first; s;) i = s._next, (n || !(!s._dur && s instanceof Vn && s.vars.onComplete === s._targets[0])) && Ti(r, s, s._start - s._delay), s = i;
        return Ti(pn, r, 0), r
    },
    utils: {
        wrap: i9e,
        wrapYoyo: o9e,
        distribute: LI,
        random: UI,
        snap: FI,
        normalize: s9e,
        getUnit: ss,
        clamp: J7e,
        splitColor: GI,
        toArray: As,
        selector: t9e,
        mapRange: qI,
        pipe: n9e,
        unitize: r9e,
        interpolate: a9e,
        shuffle: $I
    },
    install: wI,
    effects: Jy,
    ticker: Ss,
    updateRoot: Mr.updateRoot,
    plugins: es,
    globalTimeline: pn,
    core: {
        PropTween: Ur,
        globals: AI,
        Tween: Vn,
        Timeline: Mr,
        Animation: Cf,
        getCache: vc,
        _removeLinkedListItem: Lg,
        suppressOverwrites: function(e) {
            return Vb = e
        }
    }
};
cs("to,from,fromTo,delayedCall,set,killTweensOf", function(t) {
    return wm[t] = Vn[t]
});
Ss.add(Mr.updateRoot);
bl = wm.to({}, {
    duration: 0
});
var O9e = function(e, n) {
        for (var r = e._pt; r && r.p !== n && r.op !== n && r.fp !== n;) r = r._next;
        return r
    },
    C9e = function(e, n) {
        var r = e._targets,
            s, i, o;
        for (s in n)
            for (i = r.length; i--;) o = e._ptLookup[i][s], o && (o = o.d) && (o._pt && (o = O9e(o, s)), o && o.modifier && o.modifier(n[s], e, r[i], s))
    },
    r0 = function(e, n) {
        return {
            name: e,
            rawVars: 1,
            init: function(s, i, o) {
                o._onInit = function(a) {
                    var l, u;
                    if (dr(i) && (l = {}, cs(i, function(f) {
                            return l[f] = 1
                        }), i = l), n) {
                        l = {};
                        for (u in i) l[u] = n(i[u]);
                        i = l
                    }
                    C9e(a, i)
                }
            }
        }
    },
    Di = wm.registerPlugin({
        name: "attr",
        init: function(e, n, r, s, i) {
            var o, a;
            for (o in n) a = this.add(e, "setAttribute", (e.getAttribute(o) || 0) + "", n[o], s, i, 0, 0, o), a && (a.op = o), this._props.push(o)
        }
    }, {
        name: "endArray",
        init: function(e, n) {
            for (var r = n.length; r--;) this.add(e, r, e[r] || 0, n[r])
        }
    }, r0("roundProps", Wv), r0("modifiers"), r0("snap", FI)) || wm;
Vn.version = Mr.version = Di.version = "3.7.0";
SI = 1;
yI() && _u();
xt.Power0;
xt.Power1;
xt.Power2;
xt.Power3;
xt.Power4;
xt.Linear;
xt.Quad;
xt.Cubic;
xt.Quart;
xt.Quint;
xt.Strong;
xt.Elastic;
xt.Back;
xt.SteppedEase;
xt.Bounce;
xt.Sine;
xt.Expo;
xt.Circ;
/*!
 * CSSPlugin 3.7.0
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var u8, Zo, Bl, t5, hc, h8, k9e = function() {
        return typeof window < "u"
    },
    va = {},
    ec = 180 / Math.PI,
    ql = Math.PI / 180,
    cl = Math.atan2,
    f8 = 1e8,
    tN = /([A-Z])/g,
    I9e = /(?:left|right|width|margin|padding|x)/i,
    N9e = /[\s,\(]\S/,
    Xo = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
    },
    nN = function(e, n) {
        return n.set(n.t, n.p, Math.round((n.s + n.c * e) * 1e4) / 1e4 + n.u, n)
    },
    x9e = function(e, n) {
        return n.set(n.t, n.p, e === 1 ? n.e : Math.round((n.s + n.c * e) * 1e4) / 1e4 + n.u, n)
    },
    P9e = function(e, n) {
        return n.set(n.t, n.p, e ? Math.round((n.s + n.c * e) * 1e4) / 1e4 + n.u : n.b, n)
    },
    R9e = function(e, n) {
        var r = n.s + n.c * e;
        n.set(n.t, n.p, ~~(r + (r < 0 ? -.5 : .5)) + n.u, n)
    },
    rN = function(e, n) {
        return n.set(n.t, n.p, e ? n.e : n.b, n)
    },
    sN = function(e, n) {
        return n.set(n.t, n.p, e !== 1 ? n.b : n.e, n)
    },
    M9e = function(e, n, r) {
        return e.style[n] = r
    },
    D9e = function(e, n, r) {
        return e.style.setProperty(n, r)
    },
    $9e = function(e, n, r) {
        return e._gsap[n] = r
    },
    L9e = function(e, n, r) {
        return e._gsap.scaleX = e._gsap.scaleY = r
    },
    F9e = function(e, n, r, s, i) {
        var o = e._gsap;
        o.scaleX = o.scaleY = r, o.renderTransform(i, o)
    },
    U9e = function(e, n, r, s, i) {
        var o = e._gsap;
        o[n] = r, o.renderTransform(i, o)
    },
    Zn = "transform",
    ba = Zn + "Origin",
    iN, Hv = function(e, n) {
        var r = Zo.createElementNS ? Zo.createElementNS((n || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Zo.createElement(e);
        return r.style ? r : Zo.createElement(e)
    },
    ho = function t(e, n, r) {
        var s = getComputedStyle(e);
        return s[n] || s.getPropertyValue(n.replace(tN, "-$1").toLowerCase()) || s.getPropertyValue(n) || !r && t(e, yu(n) || n, 1) || ""
    },
    d8 = "O,Moz,ms,Ms,Webkit".split(","),
    yu = function(e, n, r) {
        var s = n || hc,
            i = s.style,
            o = 5;
        if (e in i && !r) return e;
        for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(d8[o] + e in i););
        return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? d8[o] : "") + e
    },
    Yv = function() {
        k9e() && window.document && (u8 = window, Zo = u8.document, Bl = Zo.documentElement, hc = Hv("div") || {
            style: {}
        }, Hv("div"), Zn = yu(Zn), ba = Zn + "Origin", hc.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", iN = !!yu("perspective"), t5 = 1)
    },
    s0 = function t(e) {
        var n = Hv("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
            r = this.parentNode,
            s = this.nextSibling,
            i = this.style.cssText,
            o;
        if (Bl.appendChild(n), n.appendChild(this), this.style.display = "block", e) try {
            o = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
        } catch {} else this._gsapBBox && (o = this._gsapBBox());
        return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), Bl.removeChild(n), this.style.cssText = i, o
    },
    p8 = function(e, n) {
        for (var r = n.length; r--;)
            if (e.hasAttribute(n[r])) return e.getAttribute(n[r])
    },
    oN = function(e) {
        var n;
        try {
            n = e.getBBox()
        } catch {
            n = s0.call(e, !0)
        }
        return n && (n.width || n.height) || e.getBBox === s0 || (n = s0.call(e, !0)), n && !n.width && !n.x && !n.y ? {
            x: +p8(e, ["x", "cx", "x1"]) || 0,
            y: +p8(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0
        } : n
    },
    aN = function(e) {
        return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && oN(e))
    },
    kf = function(e, n) {
        if (n) {
            var r = e.style;
            n in va && n !== ba && (n = Zn), r.removeProperty ? ((n.substr(0, 2) === "ms" || n.substr(0, 6) === "webkit") && (n = "-" + n), r.removeProperty(n.replace(tN, "-$1").toLowerCase())) : r.removeAttribute(n)
        }
    },
    Qo = function(e, n, r, s, i, o) {
        var a = new Ur(e._pt, n, r, 0, 1, o ? sN : rN);
        return e._pt = a, a.b = s, a.e = i, e._props.push(r), a
    },
    m8 = {
        deg: 1,
        rad: 1,
        turn: 1
    },
    Ea = function t(e, n, r, s) {
        var i = parseFloat(r) || 0,
            o = (r + "").trim().substr((i + "").length) || "px",
            a = hc.style,
            l = I9e.test(n),
            u = e.tagName.toLowerCase() === "svg",
            f = (u ? "client" : "offset") + (l ? "Width" : "Height"),
            d = 100,
            p = s === "px",
            _ = s === "%",
            v, y, g, b;
        return s === o || !i || m8[s] || m8[o] ? i : (o !== "px" && !p && (i = t(e, n, r, "px")), b = e.getCTM && aN(e), (_ || o === "%") && (va[n] || ~n.indexOf("adius")) ? (v = b ? e.getBBox()[l ? "width" : "height"] : e[f], kt(_ ? i / v * d : i / 100 * v)) : (a[l ? "width" : "height"] = d + (p ? o : s), y = ~n.indexOf("adius") || s === "em" && e.appendChild && !u ? e : e.parentNode, b && (y = (e.ownerSVGElement || {}).parentNode), (!y || y === Zo || !y.appendChild) && (y = Zo.body), g = y._gsap, g && _ && g.width && l && g.time === Ss.time ? kt(i / g.width * d) : ((_ || o === "%") && (a.position = ho(e, "position")), y === e && (a.position = "static"), y.appendChild(hc), v = hc[f], y.removeChild(hc), a.position = "absolute", l && _ && (g = vc(y), g.time = Ss.time, g.width = y[f]), kt(p ? v * i / d : v && i ? d / v * i : 0))))
    },
    fl = function(e, n, r, s) {
        var i;
        return t5 || Yv(), n in Xo && n !== "transform" && (n = Xo[n], ~n.indexOf(",") && (n = n.split(",")[0])), va[n] && n !== "transform" ? (i = Nf(e, s), i = n !== "transformOrigin" ? i[n] : i.svg ? i.origin : Om(ho(e, ba)) + " " + i.zOrigin + "px") : (i = e.style[n], (!i || i === "auto" || s || ~(i + "").indexOf("calc(")) && (i = Am[n] && Am[n](e, n, r) || ho(e, n) || CI(e, n) || (n === "opacity" ? 1 : 0))), r && !~(i + "").trim().indexOf(" ") ? Ea(e, n, i, r) + r : i
    },
    B9e = function(e, n, r, s) {
        if (!r || r === "none") {
            var i = yu(n, e, 1),
                o = i && ho(e, i, 1);
            o && o !== r ? (n = i, r = o) : n === "borderColor" && (r = ho(e, "borderTopColor"))
        }
        var a = new Ur(this._pt, e.style, n, 0, 1, JI),
            l = 0,
            u = 0,
            f, d, p, _, v, y, g, b, O, N, k, A, x;
        if (a.b = r, a.e = s, r += "", s += "", s === "auto" && (e.style[n] = s, s = ho(e, n) || s, e.style[n] = r), f = [r, s], jI(f), r = f[0], s = f[1], p = r.match(vl) || [], x = s.match(vl) || [], x.length) {
            for (; d = vl.exec(s);) g = d[0], O = s.substring(l, d.index), v ? v = (v + 1) % 5 : (O.substr(-5) === "rgba(" || O.substr(-5) === "hsla(") && (v = 1), g !== (y = p[u++] || "") && (_ = parseFloat(y) || 0, k = y.substr((_ + "").length), A = g.charAt(1) === "=" ? +(g.charAt(0) + "1") : 0, A && (g = g.substr(2)), b = parseFloat(g), N = g.substr((b + "").length), l = vl.lastIndex - N.length, N || (N = N || $r.units[n] || k, l === s.length && (s += N, a.e += N)), k !== N && (_ = Ea(e, n, y, N) || 0), a._pt = {
                _next: a._pt,
                p: O || u === 1 ? O : ",",
                s: _,
                c: A ? A * b : b - _,
                m: v && v < 4 || n === "zIndex" ? Math.round : 0
            });
            a.c = l < s.length ? s.substring(l, s.length) : ""
        } else a.r = n === "display" && s === "none" ? sN : rN;
        return EI.test(s) && (a.e = 0), this._pt = a, a
    },
    g8 = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
    },
    q9e = function(e) {
        var n = e.split(" "),
            r = n[0],
            s = n[1] || "50%";
        return (r === "top" || r === "bottom" || s === "left" || s === "right") && (e = r, r = s, s = e), n[0] = g8[r] || r, n[1] = g8[s] || s, n.join(" ")
    },
    G9e = function(e, n) {
        if (n.tween && n.tween._time === n.tween._dur) {
            var r = n.t,
                s = r.style,
                i = n.u,
                o = r._gsap,
                a, l, u;
            if (i === "all" || i === !0) s.cssText = "", l = 1;
            else
                for (i = i.split(","), u = i.length; --u > -1;) a = i[u], va[a] && (l = 1, a = a === "transformOrigin" ? ba : Zn), kf(r, a);
            l && (kf(r, Zn), o && (o.svg && r.removeAttribute("transform"), Nf(r, 1), o.uncache = 1))
        }
    },
    Am = {
        clearProps: function(e, n, r, s, i) {
            if (i.data !== "isFromStart") {
                var o = e._pt = new Ur(e._pt, n, r, 0, 0, G9e);
                return o.u = s, o.pr = -10, o.tween = i, e._props.push(r), 1
            }
        }
    },
    If = [1, 0, 0, 1, 0, 0],
    cN = {},
    lN = function(e) {
        return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
    },
    _8 = function(e) {
        var n = ho(e, Zn);
        return lN(n) ? If : n.substr(7).match(bI).map(kt)
    },
    n5 = function(e, n) {
        var r = e._gsap || vc(e),
            s = e.style,
            i = _8(e),
            o, a, l, u;
        return r.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, i = [l.a, l.b, l.c, l.d, l.e, l.f], i.join(",") === "1,0,0,1,0,0" ? If : i) : (i === If && !e.offsetParent && e !== Bl && !r.svg && (l = s.display, s.display = "block", o = e.parentNode, (!o || !e.offsetParent) && (u = 1, a = e.nextSibling, Bl.appendChild(e)), i = _8(e), l ? s.display = l : kf(e, "display"), u && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Bl.removeChild(e))), n && i.length > 6 ? [i[0], i[1], i[4], i[5], i[12], i[13]] : i)
    },
    zv = function(e, n, r, s, i, o) {
        var a = e._gsap,
            l = i || n5(e, !0),
            u = a.xOrigin || 0,
            f = a.yOrigin || 0,
            d = a.xOffset || 0,
            p = a.yOffset || 0,
            _ = l[0],
            v = l[1],
            y = l[2],
            g = l[3],
            b = l[4],
            O = l[5],
            N = n.split(" "),
            k = parseFloat(N[0]) || 0,
            A = parseFloat(N[1]) || 0,
            x, D, L, q;
        r ? l !== If && (D = _ * g - v * y) && (L = k * (g / D) + A * (-y / D) + (y * O - g * b) / D, q = k * (-v / D) + A * (_ / D) - (_ * O - v * b) / D, k = L, A = q) : (x = oN(e), k = x.x + (~N[0].indexOf("%") ? k / 100 * x.width : k), A = x.y + (~(N[1] || N[0]).indexOf("%") ? A / 100 * x.height : A)), s || s !== !1 && a.smooth ? (b = k - u, O = A - f, a.xOffset = d + (b * _ + O * y) - b, a.yOffset = p + (b * v + O * g) - O) : a.xOffset = a.yOffset = 0, a.xOrigin = k, a.yOrigin = A, a.smooth = !!s, a.origin = n, a.originIsAbsolute = !!r, e.style[ba] = "0px 0px", o && (Qo(o, a, "xOrigin", u, k), Qo(o, a, "yOrigin", f, A), Qo(o, a, "xOffset", d, a.xOffset), Qo(o, a, "yOffset", p, a.yOffset)), e.setAttribute("data-svg-origin", k + " " + A)
    },
    Nf = function(e, n) {
        var r = e._gsap || new zI(e);
        if ("x" in r && !n && !r.uncache) return r;
        var s = e.style,
            i = r.scaleX < 0,
            o = "px",
            a = "deg",
            l = ho(e, ba) || "0",
            u, f, d, p, _, v, y, g, b, O, N, k, A, x, D, L, q, ee, ae, Z, fe, ge, K, Q, ue, _e, Oe, Ee, Ce, De, Ue, ot;
        return u = f = d = v = y = g = b = O = N = 0, p = _ = 1, r.svg = !!(e.getCTM && aN(e)), x = n5(e, r.svg), r.svg && (Q = (!r.uncache || l === "0px 0px") && !n && e.getAttribute("data-svg-origin"), zv(e, Q || l, !!Q || r.originIsAbsolute, r.smooth !== !1, x)), k = r.xOrigin || 0, A = r.yOrigin || 0, x !== If && (ee = x[0], ae = x[1], Z = x[2], fe = x[3], u = ge = x[4], f = K = x[5], x.length === 6 ? (p = Math.sqrt(ee * ee + ae * ae), _ = Math.sqrt(fe * fe + Z * Z), v = ee || ae ? cl(ae, ee) * ec : 0, b = Z || fe ? cl(Z, fe) * ec + v : 0, b && (_ *= Math.abs(Math.cos(b * ql))), r.svg && (u -= k - (k * ee + A * Z), f -= A - (k * ae + A * fe))) : (ot = x[6], De = x[7], Oe = x[8], Ee = x[9], Ce = x[10], Ue = x[11], u = x[12], f = x[13], d = x[14], D = cl(ot, Ce), y = D * ec, D && (L = Math.cos(-D), q = Math.sin(-D), Q = ge * L + Oe * q, ue = K * L + Ee * q, _e = ot * L + Ce * q, Oe = ge * -q + Oe * L, Ee = K * -q + Ee * L, Ce = ot * -q + Ce * L, Ue = De * -q + Ue * L, ge = Q, K = ue, ot = _e), D = cl(-Z, Ce), g = D * ec, D && (L = Math.cos(-D), q = Math.sin(-D), Q = ee * L - Oe * q, ue = ae * L - Ee * q, _e = Z * L - Ce * q, Ue = fe * q + Ue * L, ee = Q, ae = ue, Z = _e), D = cl(ae, ee), v = D * ec, D && (L = Math.cos(D), q = Math.sin(D), Q = ee * L + ae * q, ue = ge * L + K * q, ae = ae * L - ee * q, K = K * L - ge * q, ee = Q, ge = ue), y && Math.abs(y) + Math.abs(v) > 359.9 && (y = v = 0, g = 180 - g), p = kt(Math.sqrt(ee * ee + ae * ae + Z * Z)), _ = kt(Math.sqrt(K * K + ot * ot)), D = cl(ge, K), b = Math.abs(D) > 2e-4 ? D * ec : 0, N = Ue ? 1 / (Ue < 0 ? -Ue : Ue) : 0), r.svg && (Q = e.getAttribute("transform"), r.forceCSS = e.setAttribute("transform", "") || !lN(ho(e, Zn)), Q && e.setAttribute("transform", Q))), Math.abs(b) > 90 && Math.abs(b) < 270 && (i ? (p *= -1, b += v <= 0 ? 180 : -180, v += v <= 0 ? 180 : -180) : (_ *= -1, b += b <= 0 ? 180 : -180)), r.x = u - ((r.xPercent = u && (r.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetWidth * r.xPercent / 100 : 0) + o, r.y = f - ((r.yPercent = f && (r.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-f) ? -50 : 0))) ? e.offsetHeight * r.yPercent / 100 : 0) + o, r.z = d + o, r.scaleX = kt(p), r.scaleY = kt(_), r.rotation = kt(v) + a, r.rotationX = kt(y) + a, r.rotationY = kt(g) + a, r.skewX = b + a, r.skewY = O + a, r.transformPerspective = N + o, (r.zOrigin = parseFloat(l.split(" ")[2]) || 0) && (s[ba] = Om(l)), r.xOffset = r.yOffset = 0, r.force3D = $r.force3D, r.renderTransform = r.svg ? j9e : iN ? uN : V9e, r.uncache = 0, r
    },
    Om = function(e) {
        return (e = e.split(" "))[0] + " " + e[1]
    },
    i0 = function(e, n, r) {
        var s = ss(n);
        return kt(parseFloat(n) + parseFloat(Ea(e, "x", r + "px", s))) + s
    },
    V9e = function(e, n) {
        n.z = "0px", n.rotationY = n.rotationX = "0deg", n.force3D = 0, uN(e, n)
    },
    Xa = "0deg",
    lh = "0px",
    Qa = ") ",
    uN = function(e, n) {
        var r = n || this,
            s = r.xPercent,
            i = r.yPercent,
            o = r.x,
            a = r.y,
            l = r.z,
            u = r.rotation,
            f = r.rotationY,
            d = r.rotationX,
            p = r.skewX,
            _ = r.skewY,
            v = r.scaleX,
            y = r.scaleY,
            g = r.transformPerspective,
            b = r.force3D,
            O = r.target,
            N = r.zOrigin,
            k = "",
            A = b === "auto" && e && e !== 1 || b === !0;
        if (N && (d !== Xa || f !== Xa)) {
            var x = parseFloat(f) * ql,
                D = Math.sin(x),
                L = Math.cos(x),
                q;
            x = parseFloat(d) * ql, q = Math.cos(x), o = i0(O, o, D * q * -N), a = i0(O, a, -Math.sin(x) * -N), l = i0(O, l, L * q * -N + N)
        }
        g !== lh && (k += "perspective(" + g + Qa), (s || i) && (k += "translate(" + s + "%, " + i + "%) "), (A || o !== lh || a !== lh || l !== lh) && (k += l !== lh || A ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + Qa), u !== Xa && (k += "rotate(" + u + Qa), f !== Xa && (k += "rotateY(" + f + Qa), d !== Xa && (k += "rotateX(" + d + Qa), (p !== Xa || _ !== Xa) && (k += "skew(" + p + ", " + _ + Qa), (v !== 1 || y !== 1) && (k += "scale(" + v + ", " + y + Qa), O.style[Zn] = k || "translate(0, 0)"
    },
    j9e = function(e, n) {
        var r = n || this,
            s = r.xPercent,
            i = r.yPercent,
            o = r.x,
            a = r.y,
            l = r.rotation,
            u = r.skewX,
            f = r.skewY,
            d = r.scaleX,
            p = r.scaleY,
            _ = r.target,
            v = r.xOrigin,
            y = r.yOrigin,
            g = r.xOffset,
            b = r.yOffset,
            O = r.forceCSS,
            N = parseFloat(o),
            k = parseFloat(a),
            A, x, D, L, q;
        l = parseFloat(l), u = parseFloat(u), f = parseFloat(f), f && (f = parseFloat(f), u += f, l += f), l || u ? (l *= ql, u *= ql, A = Math.cos(l) * d, x = Math.sin(l) * d, D = Math.sin(l - u) * -p, L = Math.cos(l - u) * p, u && (f *= ql, q = Math.tan(u - f), q = Math.sqrt(1 + q * q), D *= q, L *= q, f && (q = Math.tan(f), q = Math.sqrt(1 + q * q), A *= q, x *= q)), A = kt(A), x = kt(x), D = kt(D), L = kt(L)) : (A = d, L = p, x = D = 0), (N && !~(o + "").indexOf("px") || k && !~(a + "").indexOf("px")) && (N = Ea(_, "x", o, "px"), k = Ea(_, "y", a, "px")), (v || y || g || b) && (N = kt(N + v - (v * A + y * D) + g), k = kt(k + y - (v * x + y * L) + b)), (s || i) && (q = _.getBBox(), N = kt(N + s / 100 * q.width), k = kt(k + i / 100 * q.height)), q = "matrix(" + A + "," + x + "," + D + "," + L + "," + N + "," + k + ")", _.setAttribute("transform", q), O && (_.style[Zn] = q)
    },
    W9e = function(e, n, r, s, i, o) {
        var a = 360,
            l = dr(i),
            u = parseFloat(i) * (l && ~i.indexOf("rad") ? ec : 1),
            f = o ? u * o : u - s,
            d = s + f + "deg",
            p, _;
        return l && (p = i.split("_")[1], p === "short" && (f %= a, f !== f % (a / 2) && (f += f < 0 ? a : -a)), p === "cw" && f < 0 ? f = (f + a * f8) % a - ~~(f / a) * a : p === "ccw" && f > 0 && (f = (f - a * f8) % a - ~~(f / a) * a)), e._pt = _ = new Ur(e._pt, n, r, s, f, x9e), _.e = d, _.u = "deg", e._props.push(r), _
    },
    y8 = function(e, n) {
        for (var r in n) e[r] = n[r];
        return e
    },
    H9e = function(e, n, r) {
        var s = y8({}, r._gsap),
            i = "perspective,force3D,transformOrigin,svgOrigin",
            o = r.style,
            a, l, u, f, d, p, _, v;
        s.svg ? (u = r.getAttribute("transform"), r.setAttribute("transform", ""), o[Zn] = n, a = Nf(r, 1), kf(r, Zn), r.setAttribute("transform", u)) : (u = getComputedStyle(r)[Zn], o[Zn] = n, a = Nf(r, 1), o[Zn] = u);
        for (l in va) u = s[l], f = a[l], u !== f && i.indexOf(l) < 0 && (_ = ss(u), v = ss(f), d = _ !== v ? Ea(r, l, u, v) : parseFloat(u), p = parseFloat(f), e._pt = new Ur(e._pt, a, l, d, p - d, nN), e._pt.u = v || 0, e._props.push(l));
        y8(a, s)
    };
cs("padding,margin,Width,Radius", function(t, e) {
    var n = "Top",
        r = "Right",
        s = "Bottom",
        i = "Left",
        o = (e < 3 ? [n, r, s, i] : [n + i, n + r, s + r, s + i]).map(function(a) {
            return e < 2 ? t + a : "border" + a + t
        });
    Am[e > 1 ? "border" + t : t] = function(a, l, u, f, d) {
        var p, _;
        if (arguments.length < 4) return p = o.map(function(v) {
            return fl(a, v, u)
        }), _ = p.join(" "), _.split(p[0]).length === 5 ? p[0] : _;
        p = (f + "").split(" "), _ = {}, o.forEach(function(v, y) {
            return _[v] = p[y] = p[y] || p[(y - 1) / 2 | 0]
        }), a.init(l, _, d)
    }
});
var hN = {
    name: "css",
    register: Yv,
    targetTest: function(e) {
        return e.style && e.nodeType
    },
    init: function(e, n, r, s, i) {
        var o = this._props,
            a = e.style,
            l = r.vars.startAt,
            u, f, d, p, _, v, y, g, b, O, N, k, A, x, D;
        t5 || Yv();
        for (y in n)
            if (y !== "autoRound" && (f = n[y], !(es[y] && KI(y, n, r, s, e, i)))) {
                if (_ = typeof f, v = Am[y], _ === "function" && (f = f.call(r, s, e, i), _ = typeof f), _ === "string" && ~f.indexOf("random(") && (f = Fg(f)), v) v(this, e, y, f, r) && (D = 1);
                else if (y.substr(0, 2) === "--") u = (getComputedStyle(e).getPropertyValue(y) + "").trim(), f += "", aa.lastIndex = 0, aa.test(u) || (g = ss(u), b = ss(f)), b ? g !== b && (u = Ea(e, y, u, b) + b) : g && (f += g), this.add(a, "setProperty", u, f, s, i, 0, 0, y), o.push(y);
                else if (_ !== "undefined") {
                    if (l && y in l ? (u = typeof l[y] == "function" ? l[y].call(r, s, e, i) : l[y], y in $r.units && !ss(u) && (u += $r.units[y]), (u + "").charAt(1) === "=" && (u = fl(e, y))) : u = fl(e, y), p = parseFloat(u), O = _ === "string" && f.charAt(1) === "=" ? +(f.charAt(0) + "1") : 0, O && (f = f.substr(2)), d = parseFloat(f), y in Xo && (y === "autoAlpha" && (p === 1 && fl(e, "visibility") === "hidden" && d && (p = 0), Qo(this, a, "visibility", p ? "inherit" : "hidden", d ? "inherit" : "hidden", !d)), y !== "scale" && y !== "transform" && (y = Xo[y], ~y.indexOf(",") && (y = y.split(",")[0]))), N = y in va, N) {
                        if (k || (A = e._gsap, A.renderTransform && !n.parseTransform || Nf(e, n.parseTransform), x = n.smoothOrigin !== !1 && A.smooth, k = this._pt = new Ur(this._pt, a, Zn, 0, 1, A.renderTransform, A, 0, -1), k.dep = 1), y === "scale") this._pt = new Ur(this._pt, A, "scaleY", A.scaleY, (O ? O * d : d - A.scaleY) || 0), o.push("scaleY", y), y += "X";
                        else if (y === "transformOrigin") {
                            f = q9e(f), A.svg ? zv(e, f, 0, x, 0, this) : (b = parseFloat(f.split(" ")[2]) || 0, b !== A.zOrigin && Qo(this, A, "zOrigin", A.zOrigin, b), Qo(this, a, y, Om(u), Om(f)));
                            continue
                        } else if (y === "svgOrigin") {
                            zv(e, f, 1, x, 0, this);
                            continue
                        } else if (y in cN) {
                            W9e(this, A, y, p, f, O);
                            continue
                        } else if (y === "smoothOrigin") {
                            Qo(this, A, "smooth", A.smooth, f);
                            continue
                        } else if (y === "force3D") {
                            A[y] = f;
                            continue
                        } else if (y === "transform") {
                            H9e(this, f, e);
                            continue
                        }
                    } else y in a || (y = yu(y) || y);
                    if (N || (d || d === 0) && (p || p === 0) && !N9e.test(f) && y in a) g = (u + "").substr((p + "").length), d || (d = 0), b = ss(f) || (y in $r.units ? $r.units[y] : g), g !== b && (p = Ea(e, y, u, b)), this._pt = new Ur(this._pt, N ? A : a, y, p, O ? O * d : d - p, !N && (b === "px" || y === "zIndex") && n.autoRound !== !1 ? R9e : nN), this._pt.u = b || 0, g !== b && (this._pt.b = u, this._pt.r = P9e);
                    else if (y in a) B9e.call(this, e, y, u, f);
                    else if (y in e) this.add(e, y, u || e[y], f, s, i);
                    else {
                        Hb(y, f);
                        continue
                    }
                    o.push(y)
                }
            } D && eN(this)
    },
    get: fl,
    aliases: Xo,
    getSetter: function(e, n, r) {
        var s = Xo[n];
        return s && s.indexOf(",") < 0 && (n = s), n in va && n !== ba && (e._gsap.x || fl(e, "x")) ? r && h8 === r ? n === "scale" ? L9e : $9e : (h8 = r || {}) && (n === "scale" ? F9e : U9e) : e.style && !jb(e.style[n]) ? M9e : ~n.indexOf("-") ? D9e : Jb(e, n)
    },
    core: {
        _removeProperty: kf,
        _getMatrix: n5
    }
};
Di.utils.checkPrefix = yu;
(function(t, e, n, r) {
    var s = cs(t + "," + e + "," + n, function(i) {
        va[i] = 1
    });
    cs(e, function(i) {
        $r.units[i] = "deg", cN[i] = 1
    }), Xo[s[13]] = t + "," + e, cs(r, function(i) {
        var o = i.split(":");
        Xo[o[1]] = s[o[0]]
    })
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
cs("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(t) {
    $r.units[t] = "px"
});
Di.registerPlugin(hN);
var r5 = Di.registerPlugin(hN) || Di;
r5.core.Tween;
/*!
 * paths 3.7.0
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var Y9e = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
    z9e = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
    K9e = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
    Z9e = /(^[#\.][a-z]|[a-y][a-z])/i,
    X9e = Math.PI / 180,
    xp = Math.sin,
    Pp = Math.cos,
    Uh = Math.abs,
    uh = Math.sqrt,
    v8 = function(e) {
        return typeof e == "string"
    },
    fN = function(e) {
        return typeof e == "number"
    },
    b8 = 1e5,
    Uo = function(e) {
        return Math.round(e * b8) / b8 || 0
    };

function Q9e(t) {
    t = v8(t) && Z9e.test(t) && document.querySelector(t) || t;
    var e = t.getAttribute ? t : 0,
        n;
    return e && (t = t.getAttribute("d")) ? (e._gsPath || (e._gsPath = {}), n = e._gsPath[t], n && !n._dirty ? n : e._gsPath[t] = ca(t)) : t ? v8(t) ? ca(t) : fN(t[0]) ? [t] : t : console.warn("Expecting a <path> element or an SVG path data string")
}

function _h(t) {
    var e = 0,
        n;
    for (t.reverse(); e < t.length; e += 2) n = t[e], t[e] = t[e + 1], t[e + 1] = n;
    t.reversed = !t.reversed
}
var J9e = function(e, n) {
        var r = document.createElementNS("http://www.w3.org/2000/svg", "path"),
            s = [].slice.call(e.attributes),
            i = s.length,
            o;
        for (n = "," + n + ","; --i > -1;) o = s[i].nodeName.toLowerCase(), n.indexOf("," + o + ",") < 0 && r.setAttributeNS(null, o, s[i].nodeValue);
        return r
    },
    eAe = {
        rect: "rx,ry,x,y,width,height",
        circle: "r,cx,cy",
        ellipse: "rx,ry,cx,cy",
        line: "x1,x2,y1,y2"
    },
    tAe = function(e, n) {
        for (var r = n ? n.split(",") : [], s = {}, i = r.length; --i > -1;) s[r[i]] = +e.getAttribute(r[i]) || 0;
        return s
    };

function dN(t, e) {
    var n = t.tagName.toLowerCase(),
        r = .552284749831,
        s, i, o, a, l, u, f, d, p, _, v, y, g, b, O, N, k, A, x, D, L, q;
    return n === "path" || !t.getBBox ? t : (u = J9e(t, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), q = tAe(t, eAe[n]), n === "rect" ? (a = q.rx, l = q.ry || a, i = q.x, o = q.y, _ = q.width - a * 2, v = q.height - l * 2, a || l ? (y = i + a * (1 - r), g = i + a, b = g + _, O = b + a * r, N = b + a, k = o + l * (1 - r), A = o + l, x = A + v, D = x + l * r, L = x + l, s = "M" + N + "," + A + " V" + x + " C" + [N, D, O, L, b, L, b - (b - g) / 3, L, g + (b - g) / 3, L, g, L, y, L, i, D, i, x, i, x - (x - A) / 3, i, A + (x - A) / 3, i, A, i, k, y, o, g, o, g + (b - g) / 3, o, b - (b - g) / 3, o, b, o, O, o, N, k, N, A].join(",") + "z") : s = "M" + (i + _) + "," + o + " v" + v + " h" + -_ + " v" + -v + " h" + _ + "z") : n === "circle" || n === "ellipse" ? (n === "circle" ? (a = l = q.r, d = a * r) : (a = q.rx, l = q.ry, d = l * r), i = q.cx, o = q.cy, f = a * r, s = "M" + (i + a) + "," + o + " C" + [i + a, o + d, i + f, o + l, i, o + l, i - f, o + l, i - a, o + d, i - a, o, i - a, o - d, i - f, o - l, i, o - l, i + f, o - l, i + a, o - d, i + a, o].join(",") + "z") : n === "line" ? s = "M" + q.x1 + "," + q.y1 + " L" + q.x2 + "," + q.y2 : (n === "polyline" || n === "polygon") && (p = (t.getAttribute("points") + "").match(z9e) || [], i = p.shift(), o = p.shift(), s = "M" + i + "," + o + " L" + p.join(","), n === "polygon" && (s += "," + i + "," + o + "z")), u.setAttribute("d", Gl(u._gsRawPath = ca(s))), e && t.parentNode && (t.parentNode.insertBefore(u, t), t.parentNode.removeChild(t)), u)
}

function nAe(t, e, n, r, s, i, o, a, l) {
    if (!(t === a && e === l)) {
        n = Uh(n), r = Uh(r);
        var u = s % 360 * X9e,
            f = Pp(u),
            d = xp(u),
            p = Math.PI,
            _ = p * 2,
            v = (t - a) / 2,
            y = (e - l) / 2,
            g = f * v + d * y,
            b = -d * v + f * y,
            O = g * g,
            N = b * b,
            k = O / (n * n) + N / (r * r);
        k > 1 && (n = uh(k) * n, r = uh(k) * r);
        var A = n * n,
            x = r * r,
            D = (A * x - A * N - x * O) / (A * N + x * O);
        D < 0 && (D = 0);
        var L = (i === o ? -1 : 1) * uh(D),
            q = L * (n * b / r),
            ee = L * -(r * g / n),
            ae = (t + a) / 2,
            Z = (e + l) / 2,
            fe = ae + (f * q - d * ee),
            ge = Z + (d * q + f * ee),
            K = (g - q) / n,
            Q = (b - ee) / r,
            ue = (-g - q) / n,
            _e = (-b - ee) / r,
            Oe = K * K + Q * Q,
            Ee = (Q < 0 ? -1 : 1) * Math.acos(K / uh(Oe)),
            Ce = (K * _e - Q * ue < 0 ? -1 : 1) * Math.acos((K * ue + Q * _e) / uh(Oe * (ue * ue + _e * _e)));
        isNaN(Ce) && (Ce = p), !o && Ce > 0 ? Ce -= _ : o && Ce < 0 && (Ce += _), Ee %= _, Ce %= _;
        var De = Math.ceil(Uh(Ce) / (_ / 4)),
            Ue = [],
            ot = Ce / De,
            je = 4 / 3 * xp(ot / 2) / (1 + Pp(ot / 2)),
            Ze = f * n,
            it = d * n,
            w = d * -r,
            M = f * r,
            Y;
        for (Y = 0; Y < De; Y++) s = Ee + Y * ot, g = Pp(s), b = xp(s), K = Pp(s += ot), Q = xp(s), Ue.push(g - je * b, b + je * g, K + je * Q, Q - je * K, K, Q);
        for (Y = 0; Y < Ue.length; Y += 2) g = Ue[Y], b = Ue[Y + 1], Ue[Y] = g * Ze + b * w + fe, Ue[Y + 1] = g * it + b * M + ge;
        return Ue[Y - 2] = a, Ue[Y - 1] = l, Ue
    }
}

function ca(t) {
    var e = (t + "").replace(K9e, function(q) {
            var ee = +q;
            return ee < 1e-4 && ee > -1e-4 ? 0 : ee
        }).match(Y9e) || [],
        n = [],
        r = 0,
        s = 0,
        i = 2 / 3,
        o = e.length,
        a = 0,
        l = "ERROR: malformed path: " + t,
        u, f, d, p, _, v, y, g, b, O, N, k, A, x, D, L = function(ee, ae, Z, fe) {
            O = (Z - ee) / 3, N = (fe - ae) / 3, y.push(ee + O, ae + N, Z - O, fe - N, Z, fe)
        };
    if (!t || !isNaN(e[0]) || isNaN(e[1])) return console.log(l), n;
    for (u = 0; u < o; u++)
        if (A = _, isNaN(e[u]) ? (_ = e[u].toUpperCase(), v = _ !== e[u]) : u--, d = +e[u + 1], p = +e[u + 2], v && (d += r, p += s), u || (g = d, b = p), _ === "M") y && (y.length < 8 ? n.length -= 1 : a += y.length), r = g = d, s = b = p, y = [d, p], n.push(y), u += 2, _ = "L";
        else if (_ === "C") y || (y = [0, 0]), v || (r = s = 0), y.push(d, p, r + e[u + 3] * 1, s + e[u + 4] * 1, r += e[u + 5] * 1, s += e[u + 6] * 1), u += 6;
    else if (_ === "S") O = r, N = s, (A === "C" || A === "S") && (O += r - y[y.length - 4], N += s - y[y.length - 3]), v || (r = s = 0), y.push(O, N, d, p, r += e[u + 3] * 1, s += e[u + 4] * 1), u += 4;
    else if (_ === "Q") O = r + (d - r) * i, N = s + (p - s) * i, v || (r = s = 0), r += e[u + 3] * 1, s += e[u + 4] * 1, y.push(O, N, r + (d - r) * i, s + (p - s) * i, r, s), u += 4;
    else if (_ === "T") O = r - y[y.length - 4], N = s - y[y.length - 3], y.push(r + O, s + N, d + (r + O * 1.5 - d) * i, p + (s + N * 1.5 - p) * i, r = d, s = p), u += 2;
    else if (_ === "H") L(r, s, r = d, s), u += 1;
    else if (_ === "V") L(r, s, r, s = d + (v ? s - r : 0)), u += 1;
    else if (_ === "L" || _ === "Z") _ === "Z" && (d = g, p = b, y.closed = !0), (_ === "L" || Uh(r - d) > .5 || Uh(s - p) > .5) && (L(r, s, d, p), _ === "L" && (u += 2)), r = d, s = p;
    else if (_ === "A") {
        if (x = e[u + 4], D = e[u + 5], O = e[u + 6], N = e[u + 7], f = 7, x.length > 1 && (x.length < 3 ? (N = O, O = D, f--) : (N = D, O = x.substr(2), f -= 2), D = x.charAt(1), x = x.charAt(0)), k = nAe(r, s, +e[u + 1], +e[u + 2], +e[u + 3], +x, +D, (v ? r : 0) + O * 1, (v ? s : 0) + N * 1), u += f, k)
            for (f = 0; f < k.length; f++) y.push(k[f]);
        r = y[y.length - 2], s = y[y.length - 1]
    } else console.log(l);
    return u = y.length, u < 6 ? (n.pop(), u = 0) : y[0] === y[u - 2] && y[1] === y[u - 1] && (y.closed = !0), n.totalPoints = a + u, n
}

function Gl(t) {
    fN(t[0]) && (t = [t]);
    var e = "",
        n = t.length,
        r, s, i, o;
    for (s = 0; s < n; s++) {
        for (o = t[s], e += "M" + Uo(o[0]) + "," + Uo(o[1]) + " C", r = o.length, i = 2; i < r; i++) e += Uo(o[i++]) + "," + Uo(o[i++]) + " " + Uo(o[i++]) + "," + Uo(o[i++]) + " " + Uo(o[i++]) + "," + Uo(o[i]) + " ";
        o.closed && (e += "z")
    }
    return e
}
/*!
 * MorphSVGPlugin 3.7.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var Ws, s5, yh, pN, vh, mN = function() {
        return Ws || typeof window < "u" && (Ws = window.gsap) && Ws.registerPlugin && Ws
    },
    o0 = function(e) {
        return typeof e == "function"
    },
    fc = Math.atan2,
    E8 = Math.cos,
    T8 = Math.sin,
    oo = Math.sqrt,
    Ug = Math.PI,
    S8 = Ug * 2,
    rAe = Ug * .3,
    sAe = Ug * .7,
    gN = 1e20,
    xf = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
    iAe = /(^[#\.][a-z]|[a-y][a-z])/i,
    oAe = /[achlmqstvz]/i,
    Jo = function(e) {
        return console && console.warn(e)
    },
    aAe = 1,
    w8 = function(e) {
        var n = e.length,
            r = 0,
            s = 0,
            i;
        for (i = 0; i < n; i++) r += e[i++], s += e[i];
        return [r / (n / 2), s / (n / 2)]
    },
    Vl = function(e) {
        var n = e.length,
            r = e[0],
            s = r,
            i = e[1],
            o = i,
            a, l, u;
        for (u = 6; u < n; u += 6) a = e[u], l = e[u + 1], a > r ? r = a : a < s && (s = a), l > i ? i = l : l < o && (o = l);
        return e.centerX = (r + s) / 2, e.centerY = (i + o) / 2, e.size = (r - s) * (i - o)
    },
    Bh = function(e, n) {
        n === void 0 && (n = 3);
        for (var r = e.length, s = e[0][0], i = s, o = e[0][1], a = o, l = 1 / n, u, f, d, p, _, v, y, g, b, O, N, k, A, x, D, L; --r > -1;)
            for (_ = e[r], u = _.length, p = 6; p < u; p += 6)
                for (b = _[p], O = _[p + 1], N = _[p + 2] - b, x = _[p + 3] - O, k = _[p + 4] - b, D = _[p + 5] - O, A = _[p + 6] - b, L = _[p + 7] - O, v = n; --v > -1;) y = l * v, g = 1 - y, f = (y * y * A + 3 * g * (y * k + g * N)) * y + b, d = (y * y * L + 3 * g * (y * D + g * x)) * y + O, f > s ? s = f : f < i && (i = f), d > o ? o = d : d < a && (a = d);
        return e.centerX = (s + i) / 2, e.centerY = (o + a) / 2, e.left = i, e.width = s - i, e.top = a, e.height = o - a, e.size = (s - i) * (o - a)
    },
    cAe = function(e, n) {
        return n.length - e.length
    },
    A8 = function(e, n) {
        var r = e.size || Vl(e),
            s = n.size || Vl(n);
        return Math.abs(s - r) < (r + s) / 20 ? n.centerX - e.centerX || n.centerY - e.centerY : s - r
    },
    O8 = function(e, n) {
        var r = e.slice(0),
            s = e.length,
            i = s - 2,
            o, a;
        for (n = n | 0, o = 0; o < s; o++) a = (o + n) % i, e[o++] = r[a], e[o] = r[a + 1]
    },
    a0 = function(e, n, r, s, i) {
        var o = e.length,
            a = 0,
            l = o - 2,
            u, f, d, p;
        for (r *= 6, f = 0; f < o; f += 6) u = (f + r) % l, p = e[u] - (n[f] - s), d = e[u + 1] - (n[f + 1] - i), a += oo(d * d + p * p);
        return a
    },
    lAe = function(e, n, r) {
        var s = e.length,
            i = w8(e),
            o = w8(n),
            a = o[0] - i[0],
            l = o[1] - i[1],
            u = a0(e, n, 0, a, l),
            f = 0,
            d, p, _;
        for (_ = 6; _ < s; _ += 6) p = a0(e, n, _ / 6, a, l), p < u && (u = p, f = _);
        if (r)
            for (d = e.slice(0), _h(d), _ = 6; _ < s; _ += 6) p = a0(d, n, _ / 6, a, l), p < u && (u = p, f = -_);
        return f / 6
    },
    uAe = function(e, n, r) {
        for (var s = e.length, i = gN, o = 0, a = 0, l, u, f, d, p, _; --s > -1;)
            for (l = e[s], _ = l.length, p = 0; p < _; p += 6) u = l[p] - n, f = l[p + 1] - r, d = oo(u * u + f * f), d < i && (i = d, o = l[p], a = l[p + 1]);
        return [o, a]
    },
    hAe = function(e, n, r, s, i, o) {
        var a = n.length,
            l = 0,
            u = Math.min(e.size || Vl(e), n[r].size || Vl(n[r])) * s,
            f = gN,
            d = e.centerX + i,
            p = e.centerY + o,
            _, v, y, g, b;
        for (v = r; v < a && (_ = n[v].size || Vl(n[v]), !(_ < u)); v++) y = n[v].centerX - d, g = n[v].centerY - p, b = oo(y * y + g * g), b < f && (l = v, f = b);
        return b = n[l], n.splice(l, 1), b
    },
    c0 = function(e, n) {
        var r = 0,
            s = .999999,
            i = e.length,
            o = n / ((i - 2) / 6),
            a, l, u, f, d, p, _, v, y, g, b, O, N, k;
        for (N = 2; N < i; N += 6)
            for (r += o; r > s;) a = e[N - 2], l = e[N - 1], u = e[N], f = e[N + 1], d = e[N + 2], p = e[N + 3], _ = e[N + 4], v = e[N + 5], k = 1 / ((Math.floor(r) || 1) + 1), y = a + (u - a) * k, b = u + (d - u) * k, y += (b - y) * k, b += (d + (_ - d) * k - b) * k, g = l + (f - l) * k, O = f + (p - f) * k, g += (O - g) * k, O += (p + (v - p) * k - O) * k, e.splice(N, 4, a + (u - a) * k, l + (f - l) * k, y, g, y + (b - y) * k, g + (O - g) * k, b, O, d + (_ - d) * k, p + (v - p) * k), N += 6, i += 6, r--;
        return e
    },
    Kv = function(e, n, r, s, i) {
        var o = n.length - e.length,
            a = o > 0 ? n : e,
            l = o > 0 ? e : n,
            u = 0,
            f = s === "complexity" ? cAe : A8,
            d = s === "position" ? 0 : typeof s == "number" ? s : .8,
            p = l.length,
            _ = typeof r == "object" && r.push ? r.slice(0) : [r],
            v = _[0] === "reverse" || _[0] < 0,
            y = r === "log",
            g, b, O, N, k, A, x;
        if (l[0]) {
            if (a.length > 1 && (e.sort(f), n.sort(f), A = a.size || Bh(a), A = l.size || Bh(l), A = a.centerX - l.centerX, x = a.centerY - l.centerY, f === A8))
                for (p = 0; p < l.length; p++) a.splice(p, 0, hAe(l[p], a, p, d, A, x));
            if (o)
                for (o < 0 && (o = -o), a[0].length > l[0].length && c0(l[0], (a[0].length - l[0].length) / 6 | 0), p = l.length; u < o;) N = a[p].size || Vl(a[p]), O = uAe(l, a[p].centerX, a[p].centerY), N = O[0], k = O[1], l[p++] = [N, k, N, k, N, k, N, k], l.totalPoints += 8, u++;
            for (p = 0; p < e.length; p++) g = n[p], b = e[p], o = g.length - b.length, o < 0 ? c0(g, -o / 6 | 0) : o > 0 && c0(b, o / 6 | 0), v && i !== !1 && !b.reversed && _h(b), r = _[p] || _[p] === 0 ? _[p] : "auto", r && (b.closed || Math.abs(b[0] - b[b.length - 2]) < .5 && Math.abs(b[1] - b[b.length - 1]) < .5 ? r === "auto" || r === "log" ? (_[p] = r = lAe(b, g, !p || i === !1), r < 0 && (v = !0, _h(b), r = -r), O8(b, r * 6)) : r !== "reverse" && (p && r < 0 && _h(b), O8(b, (r < 0 ? -r : r) * 6)) : !v && (r === "auto" && Math.abs(g[0] - b[0]) + Math.abs(g[1] - b[1]) + Math.abs(g[g.length - 2] - b[b.length - 2]) + Math.abs(g[g.length - 1] - b[b.length - 1]) > Math.abs(g[0] - b[b.length - 2]) + Math.abs(g[1] - b[b.length - 1]) + Math.abs(g[g.length - 2] - b[0]) + Math.abs(g[g.length - 1] - b[1]) || r % 2) ? (_h(b), _[p] = -1, v = !0) : r === "auto" ? _[p] = 0 : r === "reverse" && (_[p] = -1), b.closed !== g.closed && (b.closed = g.closed = !1));
            return y && Jo("shapeIndex:[" + _.join(",") + "]"), e.shapeIndex = _, _
        }
    },
    C8 = function(e, n, r, s, i) {
        var o = ca(e[0]),
            a = ca(e[1]);
        Kv(o, a, n || n === 0 ? n : "auto", r, i) && (e[0] = Gl(o), e[1] = Gl(a), (s === "log" || s === !0) && Jo('precompile:["' + e[0] + '","' + e[1] + '"]'))
    },
    fAe = function(e, n) {
        if (!n) return e;
        var r = e.match(xf) || [],
            s = r.length,
            i = "",
            o, a, l;
        for (n === "reverse" ? (a = s - 1, o = -2) : (a = ((parseInt(n, 10) || 0) * 2 + 1 + s * 100) % s, o = 2), l = 0; l < s; l += 2) i += r[a - 1] + "," + r[a] + " ", a = (a + o) % s;
        return i
    },
    k8 = function(e, n) {
        var r = 0,
            s = parseFloat(e[0]),
            i = parseFloat(e[1]),
            o = s + "," + i + " ",
            a = .999999,
            l, u, f, d, p, _, v;
        for (f = e.length, l = n * .5 / (f * .5 - 1), u = 0; u < f - 2; u += 2) {
            if (r += l, _ = parseFloat(e[u + 2]), v = parseFloat(e[u + 3]), r > a)
                for (p = 1 / (Math.floor(r) + 1), d = 1; r > a;) o += (s + (_ - s) * p * d).toFixed(2) + "," + (i + (v - i) * p * d).toFixed(2) + " ", r--, d++;
            o += _ + "," + v + " ", s = _, i = v
        }
        return o
    },
    Zv = function(e) {
        var n = e[0].match(xf) || [],
            r = e[1].match(xf) || [],
            s = r.length - n.length;
        s > 0 ? e[0] = k8(n, s) : e[1] = k8(r, -s)
    },
    dAe = function(e) {
        return isNaN(e) ? Zv : function(n) {
            Zv(n), n[1] = fAe(n[1], parseInt(e, 10))
        }
    },
    pAe = function(e, n, r) {
        var s = typeof e == "string",
            i, o;
        return (!s || iAe.test(e) || (e.match(xf) || []).length < 3) && (i = s5(e)[0], i ? (o = (i.nodeName + "").toUpperCase(), n && o !== "PATH" && (i = dN(i, !1), o = "PATH"), e = i.getAttribute(o === "PATH" ? "d" : "points") || "", i === r && (e = i.getAttributeNS(null, "data-original") || e)) : (Jo("WARNING: invalid morph to: " + e), e = !1)), e
    },
    I8 = function(e, n) {
        for (var r = e.length, s = .2 * (n || 1), i, o, a, l, u, f, d, p, _, v, y, g; --r > -1;) {
            for (o = e[r], y = o.isSmooth = o.isSmooth || [0, 0, 0, 0], g = o.smoothData = o.smoothData || [0, 0, 0, 0], y.length = 4, p = o.length - 2, d = 6; d < p; d += 6) a = o[d] - o[d - 2], l = o[d + 1] - o[d - 1], u = o[d + 2] - o[d], f = o[d + 3] - o[d + 1], _ = fc(l, a), v = fc(f, u), i = Math.abs(_ - v) < s, i && (g[d - 2] = _, g[d + 2] = v, g[d - 1] = oo(a * a + l * l), g[d + 3] = oo(u * u + f * f)), y.push(i, i, 0, 0, i, i);
            o[p] === o[0] && o[p + 1] === o[1] && (a = o[0] - o[p - 2], l = o[1] - o[p - 1], u = o[2] - o[0], f = o[3] - o[1], _ = fc(l, a), v = fc(f, u), Math.abs(_ - v) < s && (g[p - 2] = _, g[2] = v, g[p - 1] = oo(a * a + l * l), g[3] = oo(u * u + f * f), y[p - 2] = y[p - 1] = !0))
        }
        return e
    },
    N8 = function(e) {
        var n = e.trim().split(" "),
            r = ~e.indexOf("left") ? 0 : ~e.indexOf("right") ? 100 : isNaN(parseFloat(n[0])) ? 50 : parseFloat(n[0]),
            s = ~e.indexOf("top") ? 0 : ~e.indexOf("bottom") ? 100 : isNaN(parseFloat(n[1])) ? 50 : parseFloat(n[1]);
        return {
            x: r / 100,
            y: s / 100
        }
    },
    mAe = function(e) {
        return e !== e % Ug ? e + (e < 0 ? S8 : -S8) : e
    },
    x8 = "Use MorphSVGPlugin.convertToPath() to convert to a path before morphing.",
    gAe = function(e, n, r, s) {
        var i = this._origin,
            o = this._eOrigin,
            a = e[r] - i.x,
            l = e[r + 1] - i.y,
            u = oo(a * a + l * l),
            f = fc(l, a),
            d, p;
        return a = n[r] - o.x, l = n[r + 1] - o.y, d = fc(l, a) - f, p = mAe(d), !s && yh && Math.abs(p + yh.ca) < rAe && (s = yh), this._anchorPT = yh = {
            _next: this._anchorPT,
            t: e,
            sa: f,
            ca: s && p * s.ca < 0 && Math.abs(p) > sAe ? d : p,
            sl: u,
            cl: oo(a * a + l * l) - u,
            i: r
        }
    },
    P8 = function(e) {
        Ws = mN(), vh = vh || Ws && Ws.plugins.morphSVG, Ws && vh ? (s5 = Ws.utils.toArray, vh.prototype._tweenRotation = gAe, pN = 1) : e && Jo("Please gsap.registerPlugin(MorphSVGPlugin)")
    },
    El = {
        version: "3.7.0",
        name: "morphSVG",
        rawVars: 1,
        register: function(e, n) {
            Ws = e, vh = n, P8()
        },
        init: function(e, n, r, s, i) {
            if (pN || P8(1), !n) return Jo("invalid shape"), !1;
            o0(n) && (n = n.call(r, s, e, i));
            var o, a, l, u, f, d, p, _, v, y, g, b, O, N, k, A, x, D, L, q, ee, ae;
            if (typeof n == "string" || n.getBBox || n[0]) n = {
                shape: n
            };
            else if (typeof n == "object") {
                o = {};
                for (a in n) o[a] = o0(n[a]) && a !== "render" ? n[a].call(r, s, e, i) : n[a];
                n = o
            }
            var Z = e.nodeType ? window.getComputedStyle(e) : {},
                fe = Z.fill + "",
                ge = !(fe === "none" || (fe.match(xf) || [])[3] === "0" || Z.fillRule === "evenodd"),
                K = (n.origin || "50 50").split(",");
            if (o = (e.nodeName + "").toUpperCase(), f = o === "POLYLINE" || o === "POLYGON", o !== "PATH" && !f && !n.prop) return Jo("Cannot morph a <" + o + "> element. " + x8), !1;
            if (a = o === "PATH" ? "d" : "points", !n.prop && !o0(e.setAttribute)) return !1;
            if (u = pAe(n.shape || n.d || n.points || "", a === "d", e), f && oAe.test(u)) return Jo("A <" + o + "> cannot accept path data. " + x8), !1;
            if (d = n.shapeIndex || n.shapeIndex === 0 ? n.shapeIndex : "auto", p = n.map || El.defaultMap, this._prop = n.prop, this._render = n.render || El.defaultRender, this._apply = "updateTarget" in n ? n.updateTarget : El.defaultUpdateTarget, this._rnd = Math.pow(10, isNaN(n.precision) ? 2 : +n.precision), this._tween = r, u) {
                if (this._target = e, x = typeof n.precompile == "object", y = this._prop ? e[this._prop] : e.getAttribute(a), !this._prop && !e.getAttributeNS(null, "data-original") && e.setAttributeNS(null, "data-original", y), a === "d" || this._prop) {
                    if (y = ca(x ? n.precompile[0] : y), g = ca(x ? n.precompile[1] : u), !x && !Kv(y, g, d, p, ge)) return !1;
                    for ((n.precompile === "log" || n.precompile === !0) && Jo('precompile:["' + Gl(y) + '","' + Gl(g) + '"]'), ee = (n.type || El.defaultType) !== "linear", ee && (y = I8(y, n.smoothTolerance), g = I8(g, n.smoothTolerance), y.size || Bh(y), g.size || Bh(g), q = N8(K[0]), this._origin = y.origin = {
                            x: y.left + q.x * y.width,
                            y: y.top + q.y * y.height
                        }, K[1] && (q = N8(K[1])), this._eOrigin = {
                            x: g.left + q.x * g.width,
                            y: g.top + q.y * g.height
                        }), this._rawPath = e._gsRawPath = y, O = y.length; --O > -1;)
                        for (k = y[O], A = g[O], _ = k.isSmooth || [], v = A.isSmooth || [], N = k.length, yh = 0, b = 0; b < N; b += 2)(A[b] !== k[b] || A[b + 1] !== k[b + 1]) && (ee ? _[b] && v[b] ? (D = k.smoothData, L = A.smoothData, ae = b + (b === N - 4 ? 7 - N : 5), this._controlPT = {
                            _next: this._controlPT,
                            i: b,
                            j: O,
                            l1s: D[b + 1],
                            l1c: L[b + 1] - D[b + 1],
                            l2s: D[ae],
                            l2c: L[ae] - D[ae]
                        }, l = this._tweenRotation(k, A, b + 2), this._tweenRotation(k, A, b, l), this._tweenRotation(k, A, ae - 1, l), b += 4) : this._tweenRotation(k, A, b) : (l = this.add(k, b, k[b], A[b]), l = this.add(k, b + 1, k[b + 1], A[b + 1]) || l))
                } else l = this.add(e, "setAttribute", e.getAttribute(a) + "", u + "", s, i, 0, dAe(d), a);
                ee && (this.add(this._origin, "x", this._origin.x, this._eOrigin.x), l = this.add(this._origin, "y", this._origin.y, this._eOrigin.y)), l && (this._props.push("morphSVG"), l.end = u, l.endProp = a)
            }
            return aAe
        },
        render: function(e, n) {
            for (var r = n._rawPath, s = n._controlPT, i = n._anchorPT, o = n._rnd, a = n._target, l = n._pt, u, f, d, p, _, v, y, g, b, O, N, k, A; l;) l.r(e, l.d), l = l._next;
            if (e === 1 && n._apply)
                for (l = n._pt; l;) l.end && (n._prop ? a[n._prop] = l.end : a.setAttribute(l.endProp, l.end)), l = l._next;
            else if (r) {
                for (; i;) v = i.sa + e * i.ca, _ = i.sl + e * i.cl, i.t[i.i] = n._origin.x + E8(v) * _, i.t[i.i + 1] = n._origin.y + T8(v) * _, i = i._next;
                for (d = e < .5 ? 2 * e * e : (4 - 2 * e) * e - 1; s;) y = s.i, p = r[s.j], A = y + (y === p.length - 4 ? 7 - p.length : 5), v = fc(p[A] - p[y + 1], p[A - 1] - p[y]), N = T8(v), k = E8(v), b = p[y + 2], O = p[y + 3], _ = s.l1s + d * s.l1c, p[y] = b - k * _, p[y + 1] = O - N * _, _ = s.l2s + d * s.l2c, p[A - 1] = b + k * _, p[A] = O + N * _, s = s._next;
                if (a._gsRawPath = r, n._apply) {
                    for (u = "", f = " ", g = 0; g < r.length; g++)
                        for (p = r[g], _ = p.length, u += "M" + (p[0] * o | 0) / o + f + (p[1] * o | 0) / o + " C", y = 2; y < _; y++) u += (p[y] * o | 0) / o + f;
                    n._prop ? a[n._prop] = u : a.setAttribute("d", u)
                }
            }
            n._render && r && n._render.call(n._tween, r, a)
        },
        kill: function(e) {
            this._pt = this._rawPath = 0
        },
        getRawPath: Q9e,
        stringToRawPath: ca,
        rawPathToString: Gl,
        normalizeStrings: function(e, n, r) {
            var s = r.shapeIndex,
                i = r.map,
                o = [e, n];
            return C8(o, s, i), o
        },
        pathFilter: C8,
        pointsFilter: Zv,
        getTotalSize: Bh,
        equalizeSegmentQuantity: Kv,
        convertToPath: function(e, n) {
            return s5(e).map(function(r) {
                return dN(r, n !== !1)
            })
        },
        defaultType: "linear",
        defaultUpdateTarget: !0,
        defaultMap: "size"
    };
mN() && Ws.registerPlugin(El);
const _Ae = "#ffcd00",
    yAe = "#b16b00",
    vAe = "#643d00",
    bAe = "#e9852d",
    EAe = "#9c500e",
    TAe = "#6b3ad8",
    SAe = "#3c188c",
    wAe = "#d83cb4",
    AAe = "#8c1972",
    OAe = "#e12929",
    CAe = "#940c0c",
    kAe = "#1ec88d",
    IAe = "#038155",
    NAe = "#287ce7",
    xAe = "#0b4b9c",
    PAe = "#fed141",
    RAe = "#ad8916",
    mi = {
        perfect: _Ae,
        good: yAe,
        okay: vAe,
        aux: bAe,
        auxDark: EAe,
        bass: TAe,
        bassDark: SAe,
        counter: wAe,
        counterDark: AAe,
        drums: OAe,
        drumsDark: CAe,
        harmony: kAe,
        harmonyDark: IAe,
        melody: NAe,
        melodyDark: xAe,
        signature: PAe,
        signatureDark: RAe
    };
r5.registerPlugin(El);
class _N {
    constructor() {
        ye(this, "timeline", r5.timeline());
        ye(this, "colors");
        this.timeline.pause()
    }
    getParkVars(e) {
        return {
            glow: {
                opacity: 0,
                scale: 1.5,
                ease: "power2.out"
            },
            lightBottom: {
                stopColor: mi.okay,
                stopOpacity: 0,
                attr: {
                    offset: "100%"
                }
            },
            lightTop: {
                stopColor: mi.okay,
                attr: {
                    offset: "80%"
                }
            },
            outer: {
                stroke: this.colors.categoryDark,
                strokeWidth: 8
            },
            straight: {
                morphSVG: e.straight,
                stroke: this.colors.categoryDark,
                strokeOpacity: 1,
                strokeWidth: 8
            }
        }
    }
    getStateVars(e) {
        return {
            perfect: {
                glow: {
                    opacity: 1,
                    scale: 1
                },
                lightBottom: {
                    stopColor: mi.perfect,
                    stopOpacity: .5,
                    attr: {
                        offset: "50%"
                    }
                },
                lightTop: {
                    stopColor: mi.perfect,
                    attr: {
                        offset: "0%"
                    }
                },
                outer: {
                    stroke: mi.perfect,
                    strokeWidth: 16
                },
                straight: {
                    morphSVG: e.smooth,
                    stroke: mi.perfect,
                    strokeWidth: 16
                }
            },
            good: {
                glow: {
                    opacity: 1,
                    scale: 1
                },
                lightBottom: {
                    stopColor: mi.good,
                    stopOpacity: .5,
                    attr: {
                        offset: "66%"
                    }
                },
                lightTop: {
                    stopColor: mi.good,
                    attr: {
                        offset: "33%"
                    }
                },
                outer: {
                    stroke: mi.good,
                    strokeWidth: 14
                },
                straight: {
                    morphSVG: e.sharp,
                    strokeWidth: 14
                }
            },
            okay: {
                glow: {
                    opacity: 1,
                    scale: 1
                },
                lightBottom: {
                    stopOpacity: .5,
                    attr: {
                        offset: "70%"
                    }
                },
                lightTop: {
                    attr: {
                        offset: "50%"
                    }
                },
                outer: {
                    stroke: mi.okay,
                    strokeWidth: 10
                },
                straight: {
                    morphSVG: e.sharp,
                    strokeWidth: 10
                }
            },
            miss: {
                lightBottom: {
                    stopOpacity: 0
                },
                outer: {
                    stroke: this.colors.categoryDark
                },
                straight: {
                    strokeOpacity: .2,
                    strokeWidth: 20
                }
            },
            flub: {
                lightBottom: {
                    stopOpacity: 0
                },
                outer: {
                    stroke: "#000"
                },
                straight: {
                    stroke: "#000"
                }
            }
        }
    }
    setup(e, n) {
        this.colors = n;
        const r = this.getParkVars(e),
            s = this.getStateVars(e),
            i = Object.keys(s),
            o = 1,
            a = .4,
            l = .6;
        i.forEach((d, p) => {
            const _ = Object.keys(s[d]),
                v = p * 2 * o;
            if (this.timeline.addLabel(d, v), this.timeline.addPause(`${d}+=${l}`), _.forEach(b => {
                    if (b === "straight") {
                        this.timeline.set(e[b], s[d][b], d);
                        const O = {
                            ...r[b],
                            duration: l
                        };
                        this.timeline.to(e[b], O, d)
                    } else {
                        const O = {
                            ...r[b],
                            duration: a
                        };
                        this.timeline.fromTo(e[b], s[d][b], O, d)
                    }
                }), d === "flub" || d === "miss") return;
            const y = `${d}Hold`,
                g = v + o;
            this.timeline.addLabel(y, g), this.timeline.addPause(`${y}+=${l}`), _.forEach(b => {
                const O = b === "lightBottom" || b === "lightTop" ? {
                    ...s[d][b],
                    duration: a
                } : {
                    ...r[b],
                    duration: a
                };
                this.timeline.fromTo(e[b], s[d][b], O, y)
            })
        });
        const u = Object.keys(r),
            f = i.length * 2 * o;
        this.timeline.addLabel("park", f), u.forEach(d => {
            this.timeline.set(e[d], r[d], "park")
        }), this.timeline.seek("park")
    }
    park() {
        this.timeline.seek("park")
    }
    play(e, n) {
        n ? this.timeline.play(`${e}Hold`) : this.timeline.play(e)
    }
}
const MAe = st({
    props: {
        feedback: {
            type: Array,
            required: !0
        },
        index: {
            type: Number,
            required: !0
        },
        isActive: {
            type: Boolean,
            required: !0
        },
        isHolding: {
            type: Boolean,
            required: !0
        }
    },
    setup() {
        return {
            timelineManager: new _N
        }
    },
    watch: {
        feedback: {
            handler: "onFeedbackChange",
            deep: !0
        },
        isHolding: "onIsHoldingChange"
    },
    mounted() {
        this.timelineManager.setup(this.$refs, {
            category: getComputedStyle(this.$refs.root).getPropertyValue("--category-color"),
            categoryDark: getComputedStyle(this.$refs.root).getPropertyValue("--category-color-dark")
        })
    },
    methods: {
        onFeedbackChange(t) {
            const e = t[t.length - 1];
            if (e === 0 || e === 10) {
                this.timelineManager.play("perfect", e === 10);
                return
            }
            if (e === 1 || e === 11) {
                this.timelineManager.play("good", e === 11);
                return
            }
            if (e === 2 || e === 12) {
                this.timelineManager.play("okay", e === 12);
                return
            }
            if (e === 3) {
                this.timelineManager.play("miss", !1);
                return
            }
            this.timelineManager.play("flub", !1)
        },
        onIsHoldingChange(t) {
            t || this.timelineManager.park()
        }
    }
});
const DAe = {
        viewBox: "0 0 110 5000",
        class: "line"
    },
    $Ae = {
        ref: "smooth",
        class: "smooth",
        d: "M45,0c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.16c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.16s20,48.08,20,96.16c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.16c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.16c0,48.08,20,48.08,20,96.16c0,48.08-20,48.08-20,96.16c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.16c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.15c0,48.07-20,48.07-20,96.15c0,48.07,20,48.07,20,96.15c0,48.07-20,48.07-20,96.15c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.16c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.16s20,48.08,20,96.16c0,48.08-20,48.08-20,96.15c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.16c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.16c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.16c0,48.08,20,48.08,20,96.15c0,48.08-20,48.08-20,96.16c0,48.08,20,48.08,20,96.16c0,48.08-20,48.08-20,96.16"
    },
    LAe = {
        ref: "sharp",
        class: "sharp",
        d: "M35 0L75 96.15L35 192.3L75 288.46L35 384.61L75 480.76L35 576.91L75 673.07L35 769.22L75 865.37L35 961.53L75 1057.68L35 1153.84L75 1249.99L35 1346.15L75 1442.3L35 1538.45L75 1634.61L35 1730.76L75 1826.92L35 1923.07L75 2019.23L35 2115.39L75 2211.54L35 2307.69L75 2403.84L35 2499.99L75 2596.14L35 2692.29L75 2788.44L35 2884.59L75 2980.75L35 3076.9L75 3173.05L35 3269.2L75 3365.36L35 3461.51L75 3557.66L35 3653.82L75 3749.97L35 3846.13L75 3942.28L35 4038.44L75 4134.59L35 4230.75L75 4326.9L35 4423.05L75 4519.21L35 4615.36L75 4711.52L35 4807.68L75 4903.84L35 5000"
    },
    FAe = {
        ref: "straight",
        class: "base straight",
        d: "M55,-10000 L55,10000"
    };

function UAe(t, e, n, r, s, i) {
    return B(), H("div", {
        ref: "root",
        class: nt(["lane", {
            active: t.isActive,
            holding: t.isHolding
        }])
    }, [(B(), H("svg", DAe, [U("path", $Ae, null, 512), U("path", LAe, null, 512), U("path", FAe, null, 512)]))], 2)
}
const BAe = He(MAe, [
        ["render", UAe],
        ["__scopeId", "data-v-e8de279d"]
    ]),
    qAe = st({
        props: {
            feedback: {
                type: Array,
                required: !0
            },
            hotkey: {
                type: String,
                required: !0
            },
            index: {
                type: Number,
                required: !0
            },
            isActive: {
                type: Boolean,
                required: !0
            },
            isHolding: {
                type: Boolean,
                required: !0
            }
        },
        setup() {
            return {
                timelineManager: new _N
            }
        },
        computed: {
            classes() {
                const t = [];
                return this.isActive && t.push("active"), this.isHolding && t.push("holding"), this.text.length > 1 && t.push("long"), t
            },
            text() {
                return this.hotkey === " " ? this.$t("MENU.SPACEBAR") : this.hotkey
            }
        },
        watch: {
            feedback: {
                handler: "onFeedbackChange",
                deep: !0
            },
            isHolding: "onIsHoldingChange"
        },
        mounted() {
            this.timelineManager.setup(this.$refs, {
                category: getComputedStyle(this.$refs.root).getPropertyValue("--category-color"),
                categoryDark: getComputedStyle(this.$refs.root).getPropertyValue("--category-color-dark")
            })
        },
        methods: {
            onFeedbackChange(t) {
                const e = t[t.length - 1];
                if (e === 0 || e === 10) {
                    this.timelineManager.play("perfect", e === 10);
                    return
                }
                if (e === 1 || e === 11) {
                    this.timelineManager.play("good", e === 11);
                    return
                }
                if (e === 2 || e === 12) {
                    this.timelineManager.play("okay", e === 12);
                    return
                }
                if (e === 3) {
                    this.timelineManager.play("miss", !1);
                    return
                }
                this.timelineManager.play("flub", !1)
            },
            onIsHoldingChange(t) {
                t || this.timelineManager.park()
            }
        }
    });
const i5 = t => (Gr("data-v-91f80890"), t = t(), Vr(), t),
    GAe = {
        viewBox: "0 0 110 110",
        class: "ring"
    },
    VAe = ["id"],
    jAe = {
        ref: "lightTop",
        class: "stop-top",
        offset: "80%"
    },
    WAe = {
        ref: "lightBottom",
        offset: "100%"
    },
    HAe = {
        ref: "glow",
        class: "glow",
        cx: "55",
        cy: "55",
        r: "55"
    },
    YAe = i5(() => U("circle", {
        class: "back",
        cx: "55",
        cy: "55",
        r: "55"
    }, null, -1)),
    zAe = i5(() => U("circle", {
        class: "inner",
        cx: "55",
        cy: "55",
        r: "25"
    }, null, -1)),
    KAe = {
        ref: "outer",
        class: "outer",
        cx: "55",
        cy: "55",
        r: "55"
    },
    ZAe = {
        class: "hotkey",
        "text-anchor": "middle",
        x: "55",
        y: "70"
    },
    XAe = i5(() => U("circle", {
        class: "head",
        cx: "55",
        cy: "55",
        r: "53"
    }, null, -1)),
    QAe = ["fill"];

function JAe(t, e, n, r, s, i) {
    return B(), H("div", {
        ref: "root",
        class: nt(["lane", t.classes])
    }, [(B(), H("svg", GAe, [U("linearGradient", {
        id: `light-gradient-${t.index}`,
        class: "light-gradient",
        x1: "0%",
        y1: "0%",
        x2: "0%",
        y2: "100%",
        gradientUnits: "objectBoundingBox"
    }, [U("stop", jAe, null, 512), U("stop", WAe, null, 512)], 8, VAe), U("circle", HAe, null, 512), YAe, zAe, U("circle", KAe, null, 512), U("text", ZAe, rt(t.text), 1), XAe, U("path", {
        class: "light",
        fill: `url(#light-gradient-${t.index})`,
        d: "M114,55c0,32.58-26.42,59-59,59S-4,87.58-4,55v-315h118V55z"
    }, null, 8, QAe)]))], 2)
}
const eOe = He(qAe, [
        ["render", JAe],
        ["__scopeId", "data-v-91f80890"]
    ]),
    tOe = st({
        props: {
            feedback: {
                type: Array,
                required: !0
            }
        },
        data() {
            return {
                textItems: [],
                cleanupInterval: window.setInterval(this.cleanup, 2e3)
            }
        },
        watch: {
            feedback: {
                handler: "onFeedbackChange",
                deep: !0
            }
        },
        beforeUnmount() {
            window.clearInterval(this.cleanupInterval)
        },
        methods: {
            onFeedbackChange(t) {
                const e = t[t.length - 1];
                e !== null && ((e === 0 || e === 10) && this.textItems.push(["QUALITY.PERFECT", "perfect", Date.now()]), (e === 1 || e === 11) && this.textItems.push(["QUALITY.GREAT", "good", Date.now()]), (e === 2 || e === 12) && this.textItems.push(["QUALITY.OKAY", "okay", Date.now()]))
            },
            cleanup() {
                const t = Date.now() - 2e3,
                    e = this.textItems.findIndex(([n, r, s]) => s < t);
                this.textItems.splice(e)
            }
        }
    });
const nOe = {
        class: "lane"
    },
    rOe = {
        class: "text"
    };

function sOe(t, e, n, r, s, i) {
    const o = Gt("t");
    return B(), H("div", nOe, [U("div", rOe, [(B(!0), H(lt, null, gn(t.textItems, a => $e((B(), H("p", {
        key: a[2],
        class: nt(["text-item", a[1]])
    }, null, 2)), [
        [o, a[0]]
    ])), 128))])])
}
const iOe = He(tOe, [
        ["render", sOe],
        ["__scopeId", "data-v-bdf36f11"]
    ]),
    oOe = st({
        components: {
            Beatlines: mI,
            LaneLine: BAe,
            LaneRing: eOe,
            LaneText: iOe
        },
        props: {
            manager: {
                type: Object,
                required: !0
            },
            showCta: {
                type: Boolean,
                required: !0
            }
        },
        computed: {
            hotkeys() {
                return this.$hotkeyManager.mappings.get(this.manager.lanes.length)
            },
            layout() {
                return qb(this.manager.lanes.length)
            },
            lanes() {
                return this.manager.lanes.map((t, e) => ({
                    isActive: t.isActive,
                    isHolding: t.activeInput !== void 0,
                    feedback: t.feedback,
                    hotkey: this.hotkeys.keys[e],
                    styles: {
                        width: `${this.layout.hit}%`,
                        left: `${this.layout.lanes[e].center}%`
                    }
                }))
            },
            scrollStyles() {
                return {
                    transform: `translateY(${this.manager.progress*100}%)`
                }
            },
            showCombo() {
                return this.manager.currentCombo > this.manager.minimumDisplayCombo
            },
            homeClasses() {
                return this.showCta ? ["alert"] : []
            },
            inputs() {
                const t = [];
                return this.manager.inputs.forEach(e => {
                    e.forEach(n => {
                        n.isVisible && n.indicators.forEach(r => {
                            const s = this.layout.lanes[r.lane];
                            if (s === void 0) {
                                console.warn("unrenderable lane", r.lane);
                                return
                            }
                            const i = {
                                classes: [],
                                key: r.key,
                                headStyles: {
                                    left: `${s.center}%`,
                                    width: `${this.layout.hit}%`,
                                    bottom: `${n.y*100}%`
                                }
                            };
                            n.isHolding && i.classes.push("holding"), n.isMissed && i.classes.push("missed"), n.isTaken && i.classes.push("taken"), n.isHold && n.height && (i.holdStyles = {
                                left: i.headStyles.left,
                                width: `${this.layout.hit*.65}%`,
                                bottom: i.headStyles.bottom,
                                height: `${n.height*100}%`
                            }), t.push(i)
                        })
                    })
                }), t
            }
        }
    });
const yN = t => (Gr("data-v-546beebe"), t = t(), Vr(), t),
    aOe = {
        class: "visuals"
    },
    cOe = {
        class: "scroll-wrapper"
    },
    lOe = {
        key: 0,
        class: "combo"
    },
    uOe = yN(() => U("div", {
        class: "home"
    }, null, -1)),
    hOe = {
        class: "scroll-wrapper clipped"
    },
    fOe = {
        class: "constrainer"
    },
    dOe = {
        class: "constrainer"
    },
    pOe = {
        class: "scroll-wrapper"
    },
    mOe = {
        class: "constrainer"
    },
    gOe = yN(() => U("circle", {
        cx: "55",
        cy: "55",
        r: "53"
    }, null, -1)),
    _Oe = [gOe],
    yOe = {
        class: "constrainer"
    },
    vOe = {
        key: 0,
        class: "constrainer"
    },
    bOe = {
        class: "cta-container"
    },
    EOe = {
        class: "cta"
    };

function TOe(t, e, n, r, s, i) {
    const o = Ge("Beatlines"),
        a = Ge("LaneLine"),
        l = Ge("LaneRing"),
        u = Ge("LaneText"),
        f = Gt("t");
    return B(), H("div", aOe, [U("div", cOe, [Ve(o, {
        class: "scroll-container",
        guide: t.manager.guide,
        duration: t.manager.duration,
        style: sn(t.scrollStyles)
    }, null, 8, ["guide", "duration", "style"])]), t.showCombo ? (B(), H("div", lOe)) : Pe("", !0), U("div", {
        class: nt(["constrainer", t.homeClasses])
    }, [uOe, (B(!0), H(lt, null, gn(t.lanes, (d, p) => (B(), At(a, {
        key: p,
        style: sn(d.styles),
        feedback: d.feedback,
        index: p,
        "is-active": d.isActive,
        "is-holding": d.isHolding
    }, null, 8, ["style", "feedback", "index", "is-active", "is-holding"]))), 128))], 2), U("div", hOe, [U("div", {
        class: "scroll-container",
        style: sn(t.scrollStyles)
    }, [U("div", fOe, [(B(!0), H(lt, null, gn(t.inputs, d => (B(), H(lt, {
        key: d.key
    }, [d.holdStyles ? (B(), H("div", {
        key: 0,
        class: nt(["hold", d.classes]),
        style: sn(d.holdStyles)
    }, null, 6)) : Pe("", !0)], 64))), 128))])], 4)]), U("div", dOe, [(B(!0), H(lt, null, gn(t.lanes, (d, p) => (B(), At(l, {
        key: p,
        style: sn(d.styles),
        feedback: d.feedback,
        hotkey: d.hotkey,
        index: p,
        "is-active": d.isActive,
        "is-holding": d.isHolding
    }, null, 8, ["style", "feedback", "hotkey", "index", "is-active", "is-holding"]))), 128))]), U("div", pOe, [U("div", {
        class: "scroll-container",
        style: sn(t.scrollStyles)
    }, [U("div", mOe, [(B(!0), H(lt, null, gn(t.inputs, d => (B(), H("svg", {
        key: d.key,
        class: nt(["head", d.classes]),
        viewBox: "0 0 110 110",
        style: sn(d.headStyles)
    }, _Oe, 6))), 128))])], 4)]), U("div", yOe, [(B(!0), H(lt, null, gn(t.lanes, (d, p) => (B(), At(u, {
        key: p,
        style: sn(d.styles),
        feedback: d.feedback
    }, null, 8, ["style", "feedback"]))), 128))]), Ve(Ta, {
        name: "cta"
    }, {
        default: $i(() => [t.showCta ? (B(), H("div", vOe, [U("div", bOe, [$e(U("p", EOe, null, 512), [
            [f, "INFO.DISCRETE"]
        ])])])) : Pe("", !0)]),
        _: 1
    })])
}
const SOe = He(oOe, [
        ["render", TOe],
        ["__scopeId", "data-v-546beebe"]
    ]),
    wOe = st({
        props: {
            manager: {
                type: Object,
                required: !0
            }
        },
        emits: {
            didProveAsDesktop: () => !0
        },
        computed: {
            hotkeys() {
                return this.$hotkeyManager.mappings.get(this.manager.lanes.length).keys
            },
            layout() {
                return qb(this.manager.lanes.length)
            }
        },
        mounted() {
            window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp)
        },
        beforeUnmount() {
            window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp)
        },
        methods: {
            onPointerBoxStart(t) {
                if (t.detail.type === "mouse" && this.$emit("didProveAsDesktop"), !this.manager.isRunning) return;
                const e = t.detail.percentX * 100;
                if (e < 0 || e > 100) return;
                const n = this.layout.lanes.findIndex(r => e >= r.left && e <= r.right);
                n !== -1 && this.manager.onDown(n, t.detail.id)
            },
            onPointerBoxEnd(t) {
                this.manager.onUp(t.detail.id)
            },
            onKeyDown(t) {
                if (this.$emit("didProveAsDesktop"), t.repeat || !this.manager.isRunning) return;
                const e = t.key.toLowerCase(),
                    n = this.hotkeys.indexOf(e);
                n !== -1 && this.manager.onDown(n, e)
            },
            onKeyUp(t) {
                if (t.repeat) return;
                const e = t.key.toLowerCase();
                this.manager.onUp(e)
            },
            onContextMenu(t) {
                return t.preventDefault(), !1
            }
        }
    });

function AOe(t, e, n, r, s, i) {
    const o = Gt("pointerbox");
    return $e((B(), H("div", {
        class: "constrainer controls",
        onContextmenu: e[0] || (e[0] = (...a) => t.onContextMenu && t.onContextMenu(...a)),
        "onPointerbox:start": e[1] || (e[1] = (...a) => t.onPointerBoxStart && t.onPointerBoxStart(...a)),
        "onPointerbox:end": e[2] || (e[2] = (...a) => t.onPointerBoxEnd && t.onPointerBoxEnd(...a))
    }, null, 544)), [
        [o, void 0, void 0, {
            multi: !0,
            restrict: !0
        }]
    ])
}
const OOe = He(wOe, [
        ["render", AOe]
    ]),
    COe = st({
        components: {
            ContinuousControls: c7e,
            ContinuousVisuals: $7e,
            DiscreteControls: OOe,
            DiscreteVisuals: SOe,
            InstrumentSVG: kC
        },
        props: {
            beatmap: {
                type: Object,
                required: !0
            },
            countInOffset: {
                type: Number,
                required: !0
            },
            instrument: {
                type: Object,
                required: !0
            },
            isAudience: {
                type: Boolean,
                required: !0
            },
            player: {
                type: Object,
                required: !0
            },
            shouldRun: {
                type: Boolean,
                required: !0
            }
        },
        data({
            beatmap: t,
            instrument: e,
            player: n
        }) {
            const r = {
                beatmap: t.config,
                criteria: {
                    time: n.recordingInfo.discreteCriteria,
                    factors: n.recordingInfo.continuousCriteriaFactors,
                    percentage: n.recordingInfo.continuousPercentageCriteria,
                    signal: n.recordingInfo.continuousSignalCriteria
                },
                duration: n.recordingInfo.duration,
                guide: n.guide.guide,
                instrument: e.config,
                isAudience: this.isAudience,
                minimumDisplayCombo: n.recordingInfo.minDisplayCombo,
                noteQualityScoreFactors: n.recordingInfo.noteQualityScoreFactors,
                offset: n.recordingInfo.position,
                responseKey: n.responseEntity,
                scorePerHighestCombo: n.recordingInfo.scorePerHighestCombo,
                scorePoolPerDifficulty: n.recordingInfo.scorePoolPerDifficulty,
                successPercentage: n.recordingInfo.successPercentage,
                wsClient: this.$ecast
            };
            return {
                manager: t.config.type === "Continuous" ? new s7e(r) : new L7e(r),
                showCTA: !1
            }
        },
        computed: {
            classes() {
                const t = [];
                return this.beatmap.config.type === "Continuous" ? t.push("continuous") : t.push("discrete"), t
            },
            categoryKey() {
                return ur.categoryI18ByKey(this.beatmap.config.category)
            }
        },
        watch: {
            shouldRun: {
                immediate: !0,
                handler: "onShouldRunChange"
            }
        },
        beforeUnmount() {
            var t;
            (t = this.manager) == null || t.destroy(), this.manager = null
        },
        methods: {
            onShouldRunChange(t, e) {
                var n;
                if (t && !e) {
                    let r = this.countInOffset;
                    this.player.recordingInfo.position ? r += this.player.recordingInfo.timeAfterCountInDuringSong : (r += this.player.recordingInfo.timeAfterCountInBeforeSong, this.showCTA = !0, window.setTimeout(() => {
                        this.showCTA = !1
                    }, r + 1e3)), window.setTimeout(() => {
                        var s;
                        (s = this.manager) == null || s.start(this.player.recordingInfo.position)
                    }, r)
                }!t && e && ((n = this.manager) == null || n.stop())
            }
        }
    });
const kOe = {
        class: "footer-wrapper constrainer"
    },
    IOe = {
        class: "footer"
    },
    NOe = {
        class: "icon-wrapper"
    },
    xOe = {
        class: "text-wrapper"
    },
    POe = {
        class: "instrument-name"
    },
    ROe = {
        class: "instrument-category"
    };

function MOe(t, e, n, r, s, i) {
    const o = Ge("ContinuousVisuals"),
        a = Ge("ContinuousControls"),
        l = Ge("DiscreteVisuals"),
        u = Ge("DiscreteControls"),
        f = Ge("InstrumentSVG"),
        d = Gt("t");
    return t.manager ? (B(), H("div", {
        key: 0,
        class: nt([t.classes, "beatmap"])
    }, [t.beatmap.config.type === "Continuous" ? (B(), H(lt, {
        key: 0
    }, [Ve(o, {
        manager: t.manager,
        "show-cta": t.showCTA
    }, null, 8, ["manager", "show-cta"]), t.manager.isLoaded ? (B(), At(a, {
        key: 0,
        manager: t.manager
    }, null, 8, ["manager"])) : Pe("", !0)], 64)) : (B(), H(lt, {
        key: 1
    }, [Ve(l, {
        manager: t.manager,
        "show-cta": t.showCTA
    }, null, 8, ["manager", "show-cta"]), t.manager.isLoaded ? (B(), At(u, {
        key: 0,
        manager: t.manager
    }, null, 8, ["manager"])) : Pe("", !0)], 64)), U("div", kOe, [U("div", IOe, [U("div", NOe, [Ve(f, {
        category: t.beatmap.config.category,
        slug: t.instrument.config.slug,
        class: "icon"
    }, null, 8, ["category", "slug"])]), U("div", xOe, [U("p", POe, rt(t.instrument.name), 1), $e(U("p", ROe, null, 512), [
        [d, t.categoryKey]
    ])])])])], 2)) : Pe("", !0)
}
const DOe = He(COe, [
        ["render", MOe]
    ]),
    $Oe = "main/pp10/nopus-opus/assets/50849cf6.mp3",
    LOe = "main/pp10/nopus-opus/assets/9431923a.ogg",
    FOe = "main/pp10/nopus-opus/assets/2188b01d.mp3",
    UOe = "main/pp10/nopus-opus/assets/9f40765c.ogg",
    BOe = "main/pp10/nopus-opus/assets/20141192.mp3",
    qOe = "main/pp10/nopus-opus/assets/8e80ea3f.ogg",
    GOe = st({
        props: {
            state: {
                type: String,
                required: !0
            },
            keys: {
                type: Array,
                required: !0
            }
        },
        emits: {
            didCountIn: t => !0
        },
        setup() {
            const t = Pt.supportsType("ogg") ? "ogg" : "mp3";
            return {
                players: new ff({
                    one: new URL(Object.assign({
                        "../../assets/tap1.mp3": $Oe,
                        "../../assets/tap1.ogg": LOe
                    })[`../../assets/tap1.${t}`], self.location).href,
                    two: new URL(Object.assign({
                        "../../assets/tap2.mp3": FOe,
                        "../../assets/tap2.ogg": UOe
                    })[`../../assets/tap2.${t}`], self.location).href,
                    three: new URL(Object.assign({
                        "../../assets/tap3.mp3": BOe,
                        "../../assets/tap3.ogg": qOe
                    })[`../../assets/tap3.${t}`], self.location).href
                }).toDestination()
            }
        },
        data() {
            return {
                taps: 3,
                count: 0,
                timeoutDuration: 2500,
                timeout: null
            }
        },
        computed: {
            titleKey() {
                return this.state === "Inactive" ? "COUNT_IN.WAIT" : null
            },
            infoKey() {
                return this.state === "Inactive" ? "COUNT_IN.TAP_ALONG" : this.count === 0 ? "COUNT_IN.GET_READY" : "COUNT_IN.SYNCING"
            },
            buttonKey() {
                return this.state === "Inactive" ? "COUNT_IN.TAP_HERE" : this.count === this.taps ? "COUNT_IN.SYNCED" : "COUNT_IN.TAP"
            },
            classes() {
                const t = [];
                return this.state !== "Inactive" && this.state !== "CountIn" && t.push("resync"), this.state === "Inactive" ? t.push("inactive") : (t.push("tap-0"), this.count >= 1 && t.push("tap-1"), this.count >= 2 && t.push("tap-2"), this.count >= 3 && t.push("tap-3", "synced")), t
            }
        },
        mounted() {
            window.addEventListener("keydown", this.onKeyDown)
        },
        beforeUnmount() {
            window.removeEventListener("keydown", this.onKeyDown)
        },
        methods: {
            onKeyDown(t) {
                this.$hotkeyManager.checkEvent(t), this.keys.includes(t.key) && this.state !== "Inactive" && this.onCount()
            },
            onPointerDown(t) {
                this.$hotkeyManager.checkEvent(t), this.state !== "Inactive" && this.onCount()
            },
            onTimeout() {
                this.count = this.taps, this.$emit("didCountIn", this.timeoutDuration)
            },
            async onCount() {
                this.count += 1, this.$vibrate(), this.timeout && (window.clearTimeout(this.timeout), this.timeout = null);
                try {
                    await sf(), this.count === 1 && this.players.player("one").start(0, .01), this.count === 2 && this.players.player("two").start(0, .01), this.count === 3 && this.players.player("three").start(0, .01)
                } catch (t) {
                    console.warn(t)
                }
                if (this.count === this.taps) {
                    this.$emit("didCountIn", 0);
                    return
                }
                this.timeout = window.setTimeout(() => {
                    this.onTimeout()
                }, this.timeoutDuration)
            }
        }
    });
const VOe = {
        class: "constrain"
    },
    jOe = {
        class: "info-wrapper"
    },
    WOe = Pc('<div class="pips" data-v-37be8aae><svg viewBox="0 0 500 420" data-v-37be8aae><path class="off" d="m412.04,321.58c48.43-52.01,47.19-149.17-8.36-195.23-36.19-24.05-68.2-31.14-96.45-26.38-2.21-30.37-4.01-58.37-19.63-83.11-14.7-22.41-42.96-1.41-32.98,20.67,10.82,19.51,41.7,46.16,44.96,64.06-68.54,17.11-114.06,104.55-142.89,183.89-35.21-42.2-64.47-84.61-80.59-120.44-12.49,44.6-3.62,96.45,23.74,133.67-13.53-7.22-26.44-15.24-38.69-23.74,7.19,36.02,42.04,64.14,76.51,75.63l-1.76-.88c31.9,13.71,69.86,22.37,108.4,24.18,1.05,8.9-5.57,39.76,7.23,38.7,11.91.71,6.31-29.14,6.83-38.34,9.55.03,19.09-.38,28.55-1.25.92,9.95-6.32,49.68,12.11,37.39,4.17-1.53,2.12-32.1,2.18-39.08,42.1-6.06,81.57-21.76,110.83-49.73Z" data-v-37be8aae></path><path class="on" d="m353.31,299.96c-4.8,3.26-9.49,6.61-14.34,9.7-12.51,7.99-26.41,12.64-40.56,16.82-15.18,4.48-30.68,6.87-46.4,8.27-1.13.1-2.63,2.07-3.01,3.43-1.03,3.66-1.46,7.48-2.3,11.19-1.48,6.64-6.29,9.67-12.34,7.9-5.1-1.49-7.45-7.08-5.69-13.11.87-2.97,1.42-6.03,2.24-9.61-7.34,0-14.23.28-21.08-.06-11.61-.58-23.19-1.58-34.79-2.34-9.15-.6-18.36-.73-27.46-1.75-30.11-3.38-58.82-10.32-80.53-33.67-.52-.56-.98-1.16-1.15-2.73,12.49,1.86,24.97,3.73,37.46,5.59.26-.51.52-1.03.78-1.54-16.51-11.59-31.63-24.54-42.78-41.47-10.97-16.65-19.52-34.23-22.52-55.22,2.19,1.16,3.79,1.73,5.04,2.72,27.34,21.58,56.67,40.05,87.79,55.75,6.22,3.14,12.39,6.37,18.59,9.55,1.82-2.11,2.58-22.48,1.17-31.83-3.9.46-7.79,1.06-11.71,1.34-9.32.67-18.3-1.53-26.65-5.05-14.06-5.92-26.84-14.05-36.95-25.75-1.61-1.86-2.95-3.96-4.3-6.02-5.36-8.22-.25-11.72,7.03-12.57,4.75-.56,9.57-.55,14.36-.87,1-.07,1.97-.47,4.07-1.01-2.41-1.75-3.9-3.01-5.56-3.99-7.35-4.36-15.02-8.24-22.04-13.07-5.73-3.94-11.13-8.58-15.91-13.63-5.56-5.88-4.06-12.05,3.31-15.64,2.65-1.29,5.72-2.27,8.63-2.36,8.63-.25,17.31-.43,25.91.2,8.07.6,16.09,2.05,24.06,3.52,13.35,2.48,25.89,7.24,37.61,14.08,3.1,1.81,4.34.3,5.24-2.65,2.39-7.79,4.44-15.74,7.65-23.2,7.69-17.92,18.64-33.41,34.93-44.93,10.48-7.42,22.1-12.21,33.98-16.57,17.16-6.3,35.14-8.26,53.13-6.67,25.05,2.22,47.3,11.92,65.58,29.44,7.32,7.02,13.89,14.8,20.6,22.02,9.09-5.48,18.49-11.59,28.31-16.96,13.93-7.61,28.88-12.7,44.53-15.49,4.02-.72,8.3-.61,12.39-.22,6.51.63,12.35,6.87,8.27,14.55-6.49,12.23-16.62,21.09-26.33,30.43-3.03,2.92-6.19,5.7-9.12,9.45,4.11-.32,8.22-.64,12.33-.95,3.82-.28,7.65-.68,11.48-.76,3.23-.07,5.07,2.11,4.79,4.97-.36,3.6-.98,7.45-2.63,10.6-10.49,19.98-26.18,34.43-47.43,42.64-3.71,1.43-7.64,2.32-11.34,3.77-1.05.41-2.27,1.83-2.41,2.91-1.43,11.18-2.15,22.47-4.05,33.56-3.72,21.75-13.64,40.61-28.87,56.63-2.12,2.23-2.37,3.68.07,5.52,10.22,7.69,20.4,15.42,30.66,23.06,2.31,1.72,4.98,2.97,7.25,4.75,3.51,2.75,4.36,6.85,2.44,10.24-1.99,3.53-6.45,5.46-10.36,3.57-3.91-1.89-7.76-4.32-10.92-7.27-9.64-9.04-18.93-18.44-28.35-27.7-.48-.47-1.01-.9-1.78-1.58Z" data-v-37be8aae></path></svg><svg viewBox="0 0 500 420" data-v-37be8aae><path class="off" d="m412.04,321.58c48.43-52.01,47.19-149.17-8.36-195.23-36.19-24.05-68.2-31.14-96.45-26.38-2.21-30.37-4.01-58.37-19.63-83.11-14.7-22.41-42.96-1.41-32.98,20.67,10.82,19.51,41.7,46.16,44.96,64.06-68.54,17.11-114.06,104.55-142.89,183.89-35.21-42.2-64.47-84.61-80.59-120.44-12.49,44.6-3.62,96.45,23.74,133.67-13.53-7.22-26.44-15.24-38.69-23.74,7.19,36.02,42.04,64.14,76.51,75.63l-1.76-.88c31.9,13.71,69.86,22.37,108.4,24.18,1.05,8.9-5.57,39.76,7.23,38.7,11.91.71,6.31-29.14,6.83-38.34,9.55.03,19.09-.38,28.55-1.25.92,9.95-6.32,49.68,12.11,37.39,4.17-1.53,2.12-32.1,2.18-39.08,42.1-6.06,81.57-21.76,110.83-49.73Z" data-v-37be8aae></path><path class="on" d="m260.59,361.54c-.48,1.56-.49,3.63-1.54,4.54-1.48,1.3-3.83,2.6-5.6,2.37-3.18-.41-4.73-3.07-4.73-6.32,0-11.51.06-23.03.09-34.54-.01-.55-.02-1.09-.03-1.64-2.31-3.3-5.33-.62-7.86-.62-6.24,0-12.48.89-18.72,1.49-.6.06-1.16.54-1.74.82-.23.82-.45,1.63-.68,2.45-.06,9.72-.13,19.45-.17,29.17-.02,5.81-2.17,9.54-5.59,9.57-3.46.03-5.9-3.48-6.3-9.04,0-.3-.01-.6-.02-.91.03-8.77.07-17.53.1-26.3.02-.3.03-.6.05-.9-.36-1.25-.71-2.5-1.08-3.79-2.91,0-5.75,0-8.59,0-.36.02-.72.05-1.09.07-.75,0-1.5.02-2.25.02-3.11-.01-6.22-.02-9.33-.03-.76-.03-1.51-.06-2.27-.09-.34-.03-.69-.06-1.03-.09-8.09-.33-16.21-.45-24.28-1.08-5.11-.4-10.25-1.21-15.22-2.45-11.02-2.74-22.12-5.36-32.87-8.97-15.31-5.13-27.76-14.77-38.5-26.63-.57-.63-.78-1.6-1.7-3.57,4.49.52,8.11.65,11.59,1.41,7.1,1.53,14.11,3.45,21.18,5.08,1.01.23,2.18-.24,3.28-.38-.48-1-.72-2.24-1.47-2.96-7.47-7.1-15.48-13.71-22.46-21.25-12.02-12.97-19.96-28.45-26.34-44.85-3.56-9.16-5.85-18.54-7.32-28.18-.22-1.44-.03-2.94-.03-5.63,28.37,26.71,58.97,48.6,91.7,67.53.55-.35,1.1-.7,1.65-1.05-.73-4.2-1.51-8.4-2.18-12.61-.88-5.59-1.56-11.2-2.58-16.76-.19-1.02-1.39-2.29-2.41-2.68-26.61-9.97-51.02-23.77-73.28-41.34-9.52-7.51-19.2-14.83-28.45-22.65-5.63-4.76-11.36-7.66-19.05-6.87-7.32-.99-13.49-1.99-13.42-8.02.05-4.26.29-4.35-.02-8.58-.25-3.42,8.51-6.28,11.58-6.42,3.26-.15,6.52-.8,9.71-1.54,1.15-.27,2.43-1.23,3.08-2.24,3.63-5.6,6.76-11.54,10.68-16.92,4.15-5.69,4.44-8.14-1.31-12.19-8.16-5.75-14.15-13.05-17.09-22.47-1.55-4.97-2.21-10.29-2.64-15.51-.16-1.99.89-5.19,2.37-5.96,2.54-1.31,5.72-1.26,8.41,1.13,10.61,9.42,21.33,18.71,32.03,28.02,15.59,13.56,31.25,27.04,46.79,40.64,8.6,7.53,17.01,15.27,25.57,22.85.91.8,2.27,1.11,3.42,1.64.53-1.15,1.32-2.24,1.55-3.44,1.93-10.07,4.53-19.92,9.6-28.94,2.16-3.83,3.09-7.36,1.75-11.97-1.72-5.95-2.14-12.27-3-18.45-.61-4.36,1.81-7.35,5.59-8.48,7.13-2.14,14.39-4.16,21.73-5.28,9.16-1.4,18.54-1.43,27.7-2.83,6.21-.95,12.15-3.59,18.33-4.84,7.03-1.43,14.19-2.29,21.33-3.14,4.49-.53,9.03-.88,13.55-.8,14.07.23,27.52,3.46,40.71,8.24,3.6,1.31,7.77,1.04,11.66,1.58,9.68,1.35,19.38,2.64,29.03,4.19,2.94.47,5.83,1.48,8.61,2.59,4.52,1.79,6.01,6.09,4.79,12.26-.94,4.76-1.79,9.54-2.37,14.36-.19,1.62.05,3.72.97,4.97,6.81,9.26,11.59,19.51,15.64,30.16.33.86.83,1.66,1.62,3.22,1.92-1.55,3.6-2.81,5.18-4.19,31-27.1,62-54.21,92.99-81.32.72-.63,1.42-1.6,2.25-1.76,2.22-.42,4.8-1.19,6.67-.44,1.26.5,2.12,3.33,2.21,5.16.47,10.26-2.01,19.94-7.96,28.3-2.8,3.92-6.93,6.97-10.72,10.11-6.09,5.05-6.16,6.81-1.65,13.03,3.83,5.27,6.82,11.13,10.41,16.59.84,1.28,2.47,2.59,3.93,2.85,9.82,1.77,19.71,3.19,29.54,4.9,2.61.45,5.7.76,6.36,4.18.73,3.76-.74,6.69-3.9,8.82-6.11,4.12-13.16,6.16-20.24,5.9-9.6-.35-17.39,1.82-24.91,8.21-12.37,10.5-25.61,19.98-38.64,29.7-14.74,11-31.07,19.32-47.49,27.48-2.22,1.1-4.65,3.28-5.44,5.5-5.09,14.37-11.05,28.32-19.5,41.05-12.93,19.48-28.24,36.71-49.75,47.15-7.98,3.87-16.65,6.31-24.98,9.47-2.03.77-4.99.45-5.12,3.8-.05,1.18-.1,2.37-.16,3.55.09,10.64.19,21.27.28,31.91-.06.64-.12,1.27-.18,1.91ZM148.63,102.21c.5.16,1,.32,1.51.47.59-1.24,1.6-2.46,1.65-3.72.07-1.86.13-4.41-3.56-3.35.13,2.2.27,4.4.4,6.59Z" data-v-37be8aae></path></svg><svg viewBox="0 0 500 420" data-v-37be8aae><path class="off" d="m412.04,321.58c48.43-52.01,47.19-149.17-8.36-195.23-36.19-24.05-68.2-31.14-96.45-26.38-2.21-30.37-4.01-58.37-19.63-83.11-14.7-22.41-42.96-1.41-32.98,20.67,10.82,19.51,41.7,46.16,44.96,64.06-68.54,17.11-114.06,104.55-142.89,183.89-35.21-42.2-64.47-84.61-80.59-120.44-12.49,44.6-3.62,96.45,23.74,133.67-13.53-7.22-26.44-15.24-38.69-23.74,7.19,36.02,42.04,64.14,76.51,75.63l-1.76-.88c31.9,13.71,69.86,22.37,108.4,24.18,1.05,8.9-5.57,39.76,7.23,38.7,11.91.71,6.31-29.14,6.83-38.34,9.55.03,19.09-.38,28.55-1.25.92,9.95-6.32,49.68,12.11,37.39,4.17-1.53,2.12-32.1,2.18-39.08,42.1-6.06,81.57-21.76,110.83-49.73Z" data-v-37be8aae></path><path class="on" d="m382.51,346.63c.79.02,1.58.05,2.37.07.32,0,.64.02.96.03.78,0,1.56,0,2.34.01.32,0,.65,0,.97,0,2.99,0,5.98.02,8.97.02.33,0,.65.02.98.03.78,0,1.57,0,2.35-.01.59,0,1.19,0,1.78,0,.52,0,1.03,0,1.55,0,.86-.05,1.72-.11,2.58-.16h5.75c-1.31,1.82-1.93,3.19-2.97,4.04-12.2,10.08-26.1,17.08-41.72,19.44-11.72,1.77-23.73,1.63-35.61,2.34-.37-.05-.74-.11-1.12-.16-7.56-1.36-15.12-2.72-23.86-4.29,0,8.93.01,17.78,0,26.64-.01,5.63.1,11.27-.16,16.89-.25,5.45-3.4,8.64-7.7,8.33-3.57-.26-6.16-2.79-6.19-6.39-.08-10.3-.17-20.61,0-30.91.08-5,.71-9.99,1.16-15.81-2.52.57-4.23.78-5.81,1.35-11.1,4.06-22.65,6.76-34.36,6.93-9.9.14-19.81-2.25-28.84-6.78-3.78-1.9-4.83-.63-6.06,2.86-4.48,12.78-9.21,25.47-14.05,38.12-2.34,6.12-5.56,11.56-13.96,10.66-4.23-3.52-.67-7.46.67-11.02,5.76-15.25,11.86-30.37,17.78-45.57,1.01-2.59.65-4.89-1.44-7.16-11.9-12.95-21.14-27.74-29.62-43.04-.77-1.4-1.74-2.69-3.04-4.69-2.51,2.49-4.61,4.56-6.7,6.65-16.05,16-34.37,28.11-56.84,33.33-24.39,5.66-51.37-11.01-56.93-31.15-2.2-7.95-3.89-16.15-4.71-24.35-.97-9.77-1.08-19.66-.9-29.49.12-6.31.92-12.71,2.36-18.85,2.17-9.22,9.16-15.13,17.04-19.22,9.82-5.09,20.09-9.49,30.54-13.13,10.8-3.76,22.34,1.56,27.15,11.92,2.62,5.66,4.24,11.78,6.21,17.73.38,1.14.62,2.56.29,3.66-1.49,5.05-1.3,9.73,1.09,14.62.74,1.51-.38,4.65-1.66,6.27-2.86,3.63-6.04,7.17-9.69,9.99-2.84,2.2-4.38,4.36-3.85,7.88.52,3.43.28,7.18,1.65,10.22,2,4.42,6.18,5.28,11.06,4.54,8.85-1.33,16.65-4.72,23.55-10.29,7.28-5.87,7.38-7.27,4.51-16.28-4.63-14.53-9.22-29.04-10.28-44.48-1.47-21.35,1.03-41.86,10.35-61.34,6.01-12.56,14.85-22.92,26.07-30.94,8.68-6.2,17.74-12.4,27.53-16.43,9.71-4,20.5-5.56,30.92-7.68,5.46-1.12,11.13-1.48,16.73-1.63,14.14-.38,27.71,2.14,41.01,7.22,15.64,5.97,29.09,14.84,40.58,26.81,1.8,1.87,3.3,4.04,4.8,6.17,1.85,2.62,3.23,2.19,4.31-.52,4.47-11.29,8.91-22.59,13.37-33.89,2.44-6.17,4.89-12.34,7.36-18.51,6.31-15.77,12.62-31.55,18.95-47.31,5.73-14.26,11.5-28.51,17.25-42.76,2.19-5.43,6.07-7.67,12.05-7.11,3.17.3,4.34,1.83,4.99,4.43,2.4,9.68-.42,18.57-4.05,27.39-3.29,7.99-6.37,16.07-9.56,24.1-1.06,2.67-.54,4.71,2.88,6.5,2.47-4.73,5.01-9.22,7.2-13.87,4.67-9.9,9.07-19.92,13.78-29.8,1.28-2.69,3.03-5.26,5.01-7.51,2.83-3.22,8.57-3.98,12.21-2.06,3.73,1.96,5.23,4.96,3.32,10.25-3.19,8.85-7.03,17.48-10.88,26.08-3.19,7.1-6.7,14.06-10.25,21-1.14,2.22-.16,2.81,1.5,4.12,3.68,2.92,7.55,5.96,10.2,9.74,5.21,7.44,2.66,15.01-1.82,21.77-18.61,28.07-37.4,56.03-56.2,83.98-3.91,5.82-7.72,11.78-12.29,17.06-4.55,5.26-3.28,10.93-3.13,16.82.27,10.36.24,20.73,0,31.09-.24,10.55-2.6,20.76-6,30.74-1.35,3.96-2.72,7.91-4.43,12.85,2.76-.61,4.97-.82,6.98-1.57,26.24-9.8,51.35-21.98,75.68-35.77,2.27-1.29,4.41-2.83,6.71-4.06.67-.36,1.7-.07,2.56-.08,0,.88.24,1.84-.02,2.63-4.62,13.7-11.57,26.14-20.09,37.82-13.91,19.06-30.71,34.86-51.66,46.07-2.53,1.35-5.29,2.26-7.93,3.42-1.01.44-1.97,1-2.95,1.51.07.45.14.89.21,1.34,2.73.17,5.46.35,8.19.52.31.01.62.02.93.03Z" data-v-37be8aae></path></svg></div>', 1),
    HOe = {
        class: "instructions"
    },
    YOe = {
        key: 0,
        class: "title"
    },
    zOe = {
        key: 1,
        class: "sub"
    },
    KOe = {
        class: "tap-wrapper"
    },
    ZOe = ["disabled"];

function XOe(t, e, n, r, s, i) {
    const o = Gt("t"),
        a = Gt("bb");
    return B(), H("div", {
        class: nt(["count-in", t.classes])
    }, [U("div", VOe, [U("div", jOe, [WOe, U("div", HOe, [t.titleKey ? $e((B(), H("p", YOe, null, 512)), [
        [o, t.titleKey]
    ]) : Pe("", !0), t.infoKey ? $e((B(), H("p", zOe, null, 512)), [
        [o, t.infoKey]
    ]) : Pe("", !0)])]), U("div", KOe, [$e(U("button", {
        class: "tap",
        disabled: t.state === "Inactive",
        onPointerdown: e[0] || (e[0] = (...l) => t.onPointerDown && t.onPointerDown(...l))
    }, null, 40, ZOe), [
        [a, t.$t(t.buttonKey)]
    ])])])], 2)
}
const QOe = He(GOe, [
        ["render", XOe],
        ["__scopeId", "data-v-37be8aae"]
    ]),
    JOe = st({
        props: {
            messageKey: {
                type: String,
                required: !0
            }
        }
    });
const eCe = {
        class: "interruption"
    },
    tCe = {
        class: "constrain"
    };

function nCe(t, e, n, r, s, i) {
    const o = Gt("t");
    return B(), H("div", eCe, [U("div", tCe, [$e(U("p", null, null, 512), [
        [o, t.messageKey]
    ])])])
}
const rCe = He(JOe, [
        ["render", nCe],
        ["__scopeId", "data-v-1d7561d6"]
    ]),
    sCe = st({
        components: {
            Beatmap: DOe,
            CountIn: QOe,
            Interruption: rCe
        },
        props: {
            beatmap: {
                type: Object,
                required: !0
            },
            hostIsPaused: {
                type: Boolean,
                required: !0
            },
            info: {
                type: Object,
                required: !0
            },
            instrument: {
                type: Object,
                required: !0
            },
            player: {
                type: Object,
                required: !0
            }
        },
        data({
            player: t
        }) {
            const e = !t.recordingInfo.isTesting && t.recordingInfo.recordingState === "Playing",
                n = t.recordingInfo.isTesting ?? !1,
                r = !t.recordingInfo.isTesting;
            return {
                runBeatmap: n,
                showCountIn: r,
                countInOffset: 0,
                wasJoinedInProgress: e,
                isDesktop: !1
            }
        },
        computed: {
            classes() {
                return [ur.categorySlugByKey(this.beatmap.config.category)]
            },
            drawDistance() {
                return `${this.player.recordingInfo.duration*.05}%`
            },
            hotkeys() {
                return this.$hotkeyManager.getCountInKeys(this.beatmap.config.laneCount ?? null)
            }
        },
        watch: {
            hostIsPaused: {
                handler: "onPauseChanged",
                immediate: !0
            }
        },
        methods: {
            onPauseChanged(t) {
                if (!this.player.recordingInfo.isTesting) {
                    if (t) {
                        this.runBeatmap = !1, this.showCountIn = !1, this.wasJoinedInProgress = !1;
                        return
                    }
                    this.showCountIn = !0
                }
            },
            onDidCountIn(t) {
                this.countInOffset = t, this.runBeatmap = !0, window.setTimeout(() => {
                    this.showCountIn = !1
                }, 1e3)
            }
        }
    });

function iCe(t, e, n, r, s, i) {
    const o = Ge("Beatmap"),
        a = Ge("CountIn"),
        l = Ge("Interruption");
    return B(), H("div", {
        class: nt(["recording", t.classes]),
        style: sn({
            "--draw-distance": t.drawDistance
        })
    }, [t.wasJoinedInProgress ? Pe("", !0) : (B(), At(o, {
        key: t.instrument.name,
        beatmap: t.beatmap,
        "count-in-offset": t.countInOffset,
        instrument: t.instrument,
        "is-audience": t.info.isAudience ?? !1,
        player: t.player,
        "should-run": t.runBeatmap
    }, null, 8, ["beatmap", "count-in-offset", "instrument", "is-audience", "player", "should-run"])), !t.wasJoinedInProgress && t.showCountIn ? (B(), At(a, {
        key: 1,
        state: t.player.recordingInfo.recordingState,
        keys: t.hotkeys,
        onDidCountIn: t.onDidCountIn
    }, null, 8, ["state", "keys", "onDidCountIn"])) : Pe("", !0), t.hostIsPaused ? (B(), At(l, {
        key: 2,
        "message-key": "INFO.PAUSED"
    }, null, 8, ["message-key"])) : t.wasJoinedInProgress ? (B(), At(l, {
        key: 3,
        "message-key": "INFO.IN_PROGRESS"
    }, null, 8, ["message-key"])) : Pe("", !0)], 6)
}
const oCe = He(sCe, [
        ["render", iCe],
        ["__scopeId", "data-v-4fd176f1"]
    ]),
    aCe = st({
        props: {
            combo: {
                type: Number,
                required: !0
            }
        }
    });
const cCe = t => (Gr("data-v-fcc722b8"), t = t(), Vr(), t),
    lCe = {
        viewBox: "0 0 100 100",
        class: "combo"
    },
    uCe = cCe(() => U("path", {
        d: "m46,2L80,0l-15,20,5,7,7-12,17,39-8,30-25,16-35-7-19-28,5-31L46,2Z"
    }, null, -1)),
    hCe = {
        x: "50",
        y: "78",
        "text-anchor": "middle"
    };

function fCe(t, e, n, r, s, i) {
    return B(), H("svg", lCe, [uCe, U("text", hCe, rt(t.combo), 1)])
}
const dCe = He(aCe, [
        ["render", fCe],
        ["__scopeId", "data-v-fcc722b8"]
    ]),
    pCe = st({
        components: {
            ChangeVIP: Gb,
            PlayerHeader: zf,
            ComboSVG: dCe,
            NoteSVG: z3
        },
        props: {
            beatmap: {
                type: Object,
                required: !1
            },
            info: {
                type: Object,
                required: !0
            },
            instrument: {
                type: Object,
                required: !1
            },
            player: {
                type: Object,
                required: !0
            },
            players: {
                type: Object,
                required: !0
            },
            render: {
                type: Object,
                required: !0
            }
        },
        data() {
            return {
                showChangeVIP: !1
            }
        },
        computed: {
            classes() {
                const t = [this.theme];
                return this.info.isAudience && t.push("is-audience"), t
            },
            theme() {
                return this.info.isAudience && this.render.audienceSurvived !== void 0 ? this.render.audienceSurvived ? "survived" : "eaten" : this.render.survived ? "survived" : "eaten"
            },
            meterData() {
                if (!this.scoreData) return null;
                const t = this.scoreData.perfect,
                    e = t + this.scoreData.great,
                    n = e + this.scoreData.okay;
                return {
                    perfect: `${t/this.scoreData.total*100}%`,
                    great: `${e/this.scoreData.total*100}%`,
                    okay: `${n/this.scoreData.total*100}%`
                }
            },
            scoreData() {
                if (this.info.isAudience) {
                    const e = xn.get("audienceScore", "code");
                    if (!e) return null;
                    const [n, r, s, i, o, a, l] = e.split(":");
                    return {
                        score: parseInt(n, 10),
                        combo: parseInt(r, 10),
                        perfect: parseInt(s, 10),
                        great: parseInt(i, 10),
                        okay: parseInt(o, 10),
                        miss: parseInt(a, 10),
                        total: parseInt(l, 10)
                    }
                }
                const t = this.player.scoreboardInfo[this.info.id];
                return {
                    score: Math.round(t.grade.score),
                    combo: t.grade.longestCombo,
                    perfect: t.grade.perfectNotes,
                    great: t.grade.greatNotes,
                    okay: t.grade.okayNotes,
                    miss: t.grade.missedNotes,
                    total: t.grade.totalNotes
                }
            }
        },
        methods: {
            onDidRequestChangeVIP() {
                this.showChangeVIP = !0
            },
            onDidRequestModalClose() {
                this.showChangeVIP = !1
            },
            async onChoiceClick(t) {
                if (this.player.responseKey) try {
                    await this.$ecast.updateObject(this.player.responseKey, {
                        [t]: !0
                    })
                } catch (e) {
                    this.$handleEcastError(e)
                }
            }
        }
    });
const mCe = {
        class: "scoreboard"
    },
    gCe = {
        class: "result-wrapper"
    },
    _Ce = {
        viewBox: "0 0 300 115"
    },
    yCe = {
        key: 0,
        points: "0 115 1.79 107.95 11.03 92.55 27.84 86.05 25.99 70.5 32.98 52.45 45.79 39.18 62.85 31.16 78.78 34.53 86.54 17.83 101.22 7.1 117.96 2.51 137.31 4.98 149.14 14.79 162.6 4.95 181.36 2.51 198 7.07 213.97 17.93 219.85 34.82 236.82 31.16 253.88 39.07 266 50.12 274.75 67.28 271.73 85.73 287.31 92.54 298.71 107.8 300 115 0 115"
    },
    vCe = {
        key: 1,
        d: "m293.04,115l-.77-4.3-9.31-12.47-15.34-6.7-12.23,3.54,9.49-9.87,2.74-16.76-7.12-13.96-10.41-9.5-14.06-6.52-15.52,3.35-10.23,8.94,2.92-14.15-4.93-14.15-13.15-8.94-14.24-3.91-15.7,2.05-12.23,8.94-2.74,16.01-4.93-16.01-10.77-8.94-16.07-2.05-14.24,3.91-12.23,8.94-6.57,14.15,3.83,14.15-9.68-8.94-15.89-3.35-13.88,6.52-10.96,11.36-5.84,15.08,1.64,13.78,11.5,11.54-13.15-5.21-17.35,6.7-7.49,12.47-1.09,4.3h285.98Z"
    },
    bCe = {
        key: 2,
        d: "m27.36,23.44c6.68-30.85,36.07-32.67,68.58,3.06,6.2-24.59,98.15-23.2,105.99-3.06,25.47-29.49,62.79-30.4,71.25-6.35,8.51,24.87-25.2,109.28-45.79,76.48-23.44,32.1-48.64,25.53-77.48-2.45-22.38,26.13-57.77,30.15-76.27,2.45C56.16,129.2,16.32,54.27,27.36,23.44Z"
    },
    ECe = {
        class: "text"
    },
    TCe = {
        key: 0,
        class: "audience"
    },
    SCe = {
        class: "result"
    },
    wCe = {
        class: "details-wrapper"
    },
    ACe = {
        key: 0,
        class: "details"
    },
    OCe = {
        class: "name"
    },
    CCe = {
        class: "info"
    },
    kCe = {
        class: "score"
    },
    ICe = {
        key: 0,
        class: "meter"
    },
    NCe = {
        class: "notes"
    },
    xCe = {
        class: "perfect"
    },
    PCe = {
        class: "great"
    },
    RCe = {
        class: "okay"
    },
    MCe = {
        class: "miss"
    },
    DCe = {
        key: 0,
        class: "vip-wrapper"
    },
    $Ce = {
        class: "vip"
    };

function LCe(t, e, n, r, s, i) {
    var d;
    const o = Ge("NoteSVG"),
        a = Ge("ComboSVG"),
        l = Ge("PlayerHeader"),
        u = Ge("ChangeVIP"),
        f = Gt("t");
    return B(), H("div", mCe, [U("div", {
        class: nt(["constrain menu has-header", t.classes])
    }, [U("div", gCe, [(B(), H("svg", _Ce, [t.theme === "survived" ? (B(), H("polygon", yCe)) : Pe("", !0), t.theme === "survived" ? (B(), H("path", vCe)) : (B(), H("path", bCe))])), U("div", ECe, [t.info.isAudience ? $e((B(), H("p", TCe, null, 512)), [
        [f, "RESULTS.AUDIENCE"]
    ]) : Pe("", !0), $e(U("h3", SCe, null, 512), [
        [f, t.render.survived ? "RESULTS.SURVIVED" : "RESULTS.EATEN"]
    ])])]), U("div", wCe, [t.scoreData ? (B(), H("div", ACe, [U("p", OCe, [Ve(o, {
        class: "icon"
    }), mn(" " + rt((d = t.render) == null ? void 0 : d.title), 1)]), U("div", CCe, [U("p", kCe, [mn(rt(t.scoreData.score.toLocaleString()) + " ", 1), Ve(a, {
        combo: t.scoreData.combo
    }, null, 8, ["combo"])]), t.meterData ? (B(), H("div", ICe, [U("div", {
        class: "segment okay",
        style: sn({
            width: t.meterData.okay
        })
    }, null, 4), U("div", {
        class: "segment great",
        style: sn({
            width: t.meterData.great
        })
    }, null, 4), U("div", {
        class: "segment perfect",
        style: sn({
            width: t.meterData.perfect
        })
    }, null, 4)])) : Pe("", !0), U("div", NCe, [U("p", xCe, [mn(rt(t.$t("QUALITY.PERFECT")), 1), U("span", null, rt(t.scoreData.perfect.toLocaleString()), 1)]), U("p", PCe, [mn(rt(t.$t("QUALITY.GREAT")), 1), U("span", null, rt(t.scoreData.great.toLocaleString()), 1)]), U("p", RCe, [mn(rt(t.$t("QUALITY.OKAY")), 1), U("span", null, rt(t.scoreData.okay.toLocaleString()), 1)]), U("p", MCe, [mn(rt(t.$t("QUALITY.MISS")), 1), U("span", null, rt(t.scoreData.miss.toLocaleString()), 1)])])])])) : Pe("", !0)]), t.info.isVip ? (B(), H("div", DCe, [U("div", $Ce, [$e(U("button", {
        class: "primary",
        onClick: e[0] || (e[0] = p => t.onChoiceClick("retry"))
    }, null, 512), [
        [f, "MENU.RETRY_SONG"]
    ]), $e(U("button", {
        class: "primary",
        onClick: e[1] || (e[1] = p => t.onChoiceClick("newSong"))
    }, null, 512), [
        [f, "MENU.NEW_SONG"]
    ]), $e(U("button", {
        class: "secondary",
        onClick: e[2] || (e[2] = p => t.onChoiceClick("endSession"))
    }, null, 512), [
        [f, "MENU.END_SESSION"]
    ])])])) : Pe("", !0)], 2), Ve(l, {
        info: t.info,
        "is-vip": t.info.isVip && !t.info.isSolo,
        players: t.players,
        "response-key": t.player.responseKey,
        onDidRequestChangeVip: t.onDidRequestChangeVIP
    }, null, 8, ["info", "is-vip", "players", "response-key", "onDidRequestChangeVip"]), t.showChangeVIP ? (B(), At(u, {
        key: 0,
        info: t.info,
        players: t.players,
        "response-key": t.player.responseKey,
        onDidRequestClose: t.onDidRequestModalClose
    }, null, 8, ["info", "players", "response-key", "onDidRequestClose"])) : Pe("", !0)])
}
const FCe = He(pCe, [
        ["render", LCe],
        ["__scopeId", "data-v-eb34fc55"]
    ]),
    UCe = st({
        props: {
            rating: {
                type: Number,
                required: !0
            }
        },
        computed: {
            classes() {
                const t = [];
                return this.rating === 8 ? t.push("gold") : this.rating === 7 ? t.push("silver") : this.rating === 6 ? t.push("bronze") : this.rating === 5 && t.push("full"), this.rating === -1 ? t.push("locked") : this.rating === 0 ? t.push("rating-0") : this.rating === 1 ? t.push("rating-1") : this.rating === 2 ? t.push("rating-2") : this.rating === 3 ? t.push("rating-3") : this.rating === 4 ? t.push("rating-4") : t.push("rating-5"), t
            }
        }
    });
const BCe = {
        key: 0,
        class: "bg-stroke",
        points: "64.76 11.33 49.22 0 35.24 12.09 31.16 28.2 13.35 26.73 0 38.26 5.39 56.27 19.81 64.16 13.23 80.33 18.75 96.75 27.77 99.87 41 95.61 49.34 86.31 60.59 96.27 73.35 100 81.19 96.31 86.58 79.82 79.87 64.16 93.73 55.82 100 37.81 84.95 26.16 67.65 27.94 64.76 11.33"
    },
    qCe = Pc('<polygon class="bg" points="64.76 11.33 49.22 0 35.24 12.09 31.16 28.2 13.35 26.73 0 38.26 5.39 56.27 19.81 64.16 13.23 80.33 18.75 96.75 27.77 99.87 41 95.61 49.34 86.31 60.59 96.27 73.35 100 81.19 96.31 86.58 79.82 79.87 64.16 93.73 55.82 100 37.81 84.95 26.16 67.65 27.94 64.76 11.33" data-v-ef5e8998></polygon><polygon class="petal p5" points="6.02 40.04 9.72 51.11 20.82 59.07 33.04 59.07 44.64 52.45 38.75 41.82 29.84 33.99 16.18 32.08 6.02 40.04" data-v-ef5e8998></polygon><polygon class="petal p4" points="33.35 61.62 23.51 69.7 19.37 80.97 23.7 92.74 27.65 93.7 37.81 89.69 44.26 82.75 47.77 72.44 46.02 59.96 33.35 61.62" data-v-ef5e8998></polygon><polygon class="petal p3" points="75.24 67.92 64.2 60.6 52.98 59.83 52.73 71.8 55.61 83.51 62.76 90.83 72.23 93.83 77.49 91.28 80.5 79.19 75.24 67.92" data-v-ef5e8998></polygon><polygon class="petal p2" points="69.59 33.99 60.69 42.27 55.42 52.9 64.33 57.48 76.24 59.2 89.09 51.75 93.04 39.72 82.95 32.59 69.59 33.99" data-v-ef5e8998></polygon><polygon class="petal p1" points="62.45 29.41 60 15.47 49.34 7.57 39.56 15.47 36.68 28.2 41 38.89 49.53 47.87 57.62 40.04 62.45 29.41" data-v-ef5e8998></polygon>', 6);

function GCe(t, e, n, r, s, i) {
    return B(), H("svg", {
        viewBox: "0 0 100 100",
        class: nt(t.classes)
    }, [t.rating > 5 ? (B(), H("polygon", BCe)) : Pe("", !0), qCe], 2)
}
const VCe = He(UCe, [
        ["render", GCe],
        ["__scopeId", "data-v-ef5e8998"]
    ]),
    jCe = {},
    WCe = {
        viewBox: "0 0 75 100"
    },
    HCe = U("path", {
        d: "m22,21l13-10,20,11v19l17,1-2-26L31,0,11,15,3,40h18l1-19Zm51,24L1,47l-1,46,40,7,35-5-2-50Zm-31,36h-9l-1-17,6-4,5,6-1,15Z"
    }, null, -1),
    YCe = [HCe];

function zCe(t, e) {
    return B(), H("svg", WCe, YCe)
}
const KCe = He(jCe, [
        ["render", zCe]
    ]),
    ZCe = {},
    XCe = {
        viewBox: "0 0 100 65"
    },
    QCe = U("path", {
        d: "m94.78,65H5.22c-4.32,0-6.76-4.68-4.13-7.91L46.12,1.84c2-2.45,5.76-2.45,7.76,0l45.03,55.25c2.63,3.23.19,7.91-4.13,7.91Z"
    }, null, -1),
    JCe = [QCe];

function eke(t, e) {
    return B(), H("svg", XCe, JCe)
}
const tke = He(ZCe, [
        ["render", eke]
    ]),
    nke = st({
        components: {
            ChangeVIP: Gb,
            PlayerHeader: zf,
            CategorySVG: dI,
            FlowerSVG: VCe,
            LockSVG: KCe,
            NoteSVG: z3,
            UpArrowSVG: tke
        },
        props: {
            info: {
                type: Object,
                required: !0
            },
            players: {
                type: Object,
                required: !0
            },
            player: {
                type: Object,
                required: !0
            }
        },
        data() {
            return {
                showChangeVIP: !1,
                localSelectedIndex: null
            }
        },
        computed: {
            selectedIndex() {
                return this.choices.findIndex(t => t.isSelected) ?? null
            },
            selectedChoice() {
                return this.selectedIndex === null ? null : this.choices[this.selectedIndex] ?? null
            },
            upChoice() {
                return this.selectedIndex === null ? null : this.selectedIndex === 0 ? this.choices[this.choices.length - 1] : this.choices[this.selectedIndex - 1]
            },
            downChoice() {
                return this.selectedIndex === null ? null : this.selectedIndex === this.choices.length - 1 ? this.choices[0] : this.choices[this.selectedIndex + 1]
            },
            choices() {
                const t = [];
                return this.player.songs.songs.forEach((e, n) => {
                    if (!this.info.isVip && e.isLocked) return;
                    const r = [];
                    e.isSelected && r.push("on-screen"), e.isLocked && r.push("locked"), n === this.localSelectedIndex && r.push("nominated"), t.push({
                        classes: r,
                        name: e.isLocked ? this.$t("MENU.LOCKED") : e.name,
                        slug: e.slug,
                        highestRating: e.highestRating,
                        categories: e.beatmapProgress,
                        isSelected: e.isSelected,
                        isLocked: e.isLocked
                    })
                }), t
            }
        },
        mounted() {
            document.addEventListener("keydown", this.onKeyDown)
        },
        beforeUnmount() {
            document.removeEventListener("keydown", this.onKeyDown)
        },
        methods: {
            onDidRequestChangeVIP() {
                this.showChangeVIP = !0
            },
            onDidRequestModalClose() {
                this.showChangeVIP = !1
            },
            onKeyDown(t) {
                this.$hotkeyManager.checkEvent(t), t.key === "ArrowDown" && this.sendDirection("down"), t.key === "ArrowUp" && this.sendDirection("up")
            },
            onDirectionClick(t) {
                this.sendDirection(t)
            },
            async sendDirection(t) {
                if (this.info.isVip) try {
                    await this.$ecast.updateObject(this.player.responseKey, {
                        scrollSong: t
                    })
                } catch (e) {
                    this.$handleEcastError(e)
                }
            },
            async onSelectClick() {
                if (this.selectedChoice) try {
                    await this.$ecast.updateObject(this.player.responseKey, {
                        selectSong: !0
                    })
                } catch (t) {
                    this.$handleEcastError(t)
                }
            },
            async onVoteClick(t) {
                this.localSelectedIndex = null, window.setTimeout(() => {
                    this.localSelectedIndex = t
                }, 50);
                try {
                    await this.$ecast.updateObject(this.player.responseKey, {
                        voteSong: this.choices[t].slug
                    })
                } catch (e) {
                    this.$handleEcastError(e)
                }
            }
        }
    });
const rke = {
        class: "song-select"
    },
    ske = {
        class: "constrain menu has-header"
    },
    ike = {
        class: "title-wrapper"
    },
    oke = {
        key: 0,
        class: "title"
    },
    ake = {
        key: 1,
        class: "title"
    },
    cke = {
        key: 0,
        class: "choices"
    },
    lke = ["aria-label"],
    uke = ["aria-label"],
    hke = {
        key: 1,
        class: "choices"
    },
    fke = ["onClick"],
    dke = {
        class: "info"
    },
    pke = {
        class: "name"
    },
    mke = {
        class: "box score"
    },
    gke = {
        class: "box parts"
    },
    _ke = {
        class: "label"
    },
    yke = {
        class: "value indicators"
    },
    vke = ["aria-label", "disabled"];

function bke(t, e, n, r, s, i) {
    var v, y, g, b;
    const o = Ge("UpArrowSVG"),
        a = Ge("NoteSVG"),
        l = Ge("LockSVG"),
        u = Ge("FlowerSVG"),
        f = Ge("CategorySVG"),
        d = Ge("PlayerHeader"),
        p = Ge("ChangeVIP"),
        _ = Gt("t");
    return B(), H("div", rke, [U("div", ske, [U("div", ike, [t.info.isVip ? $e((B(), H("h3", oke, null, 512)), [
        [_, "MENU.CHOOSE_SONG"]
    ]) : $e((B(), H("h3", ake, null, 512)), [
        [_, "MENU.VOTE_SONG"]
    ])]), U("div", {
        class: nt(["choices-wrapper", {
            "is-choosing": t.info.isVip
        }])
    }, [t.info.isVip ? (B(), H("div", cke, [U("button", {
        class: "direction",
        "aria-label": t.$t("ARIA.SONG_UP", {
            songName: ((v = t.upChoice) == null ? void 0 : v.name) ?? ""
        }),
        onClick: e[0] || (e[0] = O => t.onDirectionClick("up"))
    }, [Ve(o)], 8, lke), U("button", {
        class: "direction",
        "aria-label": t.$t("ARIA.SONG_DOWN", {
            songName: ((y = t.downChoice) == null ? void 0 : y.name) ?? ""
        }),
        onClick: e[1] || (e[1] = O => t.onDirectionClick("down"))
    }, [Ve(o)], 8, uke)])) : (B(), H("div", hke, [(B(!0), H(lt, null, gn(t.choices, (O, N) => (B(), H("button", {
        key: N,
        class: nt([O.classes, "choice has-icon"]),
        onClick: Oi(k => t.onVoteClick(N), ["prevent"])
    }, [O === t.selectedChoice ? (B(), At(a, {
        key: 0,
        class: "icon note"
    })) : Pe("", !0), mn(" " + rt(O.name), 1)], 10, fke))), 128))]))], 2), t.info.isVip && t.selectedChoice ? (B(), H("div", {
        key: 0,
        class: nt(["details", {
            locked: t.selectedChoice.isLocked
        }])
    }, [U("div", dke, [U("p", pke, [t.selectedChoice.isLocked ? (B(), At(l, {
        key: 0,
        class: "icon"
    })) : (B(), At(a, {
        key: 1,
        class: "icon"
    })), mn(" " + rt(t.selectedChoice.name), 1)]), U("div", mke, [Ve(u, {
        class: "icon",
        rating: t.selectedChoice.isLocked ? -1 : t.selectedChoice.highestRating
    }, null, 8, ["rating"])]), U("div", gke, [$e(U("p", _ke, null, 512), [
        [_, "MENU.COMPLETED_PARTS"]
    ]), U("div", yke, [(B(!0), H(lt, null, gn(t.selectedChoice.categories, (O, N) => (B(), At(f, {
        key: N,
        category: O.category,
        class: nt(["icon", {
            perfected: O.isPerfected,
            incomplete: !O.isSurvived
        }])
    }, null, 8, ["category", "class"]))), 128))])])])], 2)) : Pe("", !0), t.info.isVip ? $e((B(), H("button", {
        key: 1,
        "aria-label": t.$t("ARIA.SELECT_SONG", {
            songName: ((g = t.selectedChoice) == null ? void 0 : g.name) ?? ""
        }),
        class: "primary",
        disabled: (b = t.selectedChoice) == null ? void 0 : b.isLocked,
        onClick: e[2] || (e[2] = (...O) => t.onSelectClick && t.onSelectClick(...O))
    }, null, 8, vke)), [
        [_, "MENU.SELECT_SONG"]
    ]) : Pe("", !0)]), Ve(d, {
        info: t.info,
        players: t.players,
        "is-vip": t.info.isVip && !t.info.isSolo,
        "response-key": t.player.responseKey,
        onDidRequestChangeVip: t.onDidRequestChangeVIP
    }, null, 8, ["info", "players", "is-vip", "response-key", "onDidRequestChangeVip"]), Ve(Ta, {
        name: "modal"
    }, {
        default: $i(() => [t.showChangeVIP ? (B(), At(p, {
            key: 0,
            info: t.info,
            players: t.players,
            "response-key": t.player.responseKey,
            onDidRequestClose: t.onDidRequestModalClose
        }, null, 8, ["info", "players", "response-key", "onDidRequestClose"])) : Pe("", !0)]),
        _: 1
    })])
}
const Eke = He(nke, [
        ["render", bke],
        ["__scopeId", "data-v-047d557a"]
    ]),
    Tke = st({
        components: {
            PlayerHeader: zf,
            LogoSVG: OC
        },
        props: {
            info: {
                type: Object,
                required: !0
            },
            player: {
                type: Object,
                required: !1
            },
            players: {
                type: Object,
                required: !1
            }
        },
        computed: {
            message() {
                var t;
                if (!((t = this.player) != null && t.category)) return null;
                if (this.player.category === "processing") return this.$t("INFO.PROCESSING");
                if (this.player.category === "songSelect") {
                    if (!this.players) return null;
                    const n = Object.keys(this.players).find(s => this.players[s].isVip);
                    if (!n) return null;
                    const r = this.players[n];
                    return this.$t("MENU.WAITING_FOR_SONG", {
                        vipName: r.name
                    })
                }
                return null
            }
        }
    });
const Ske = {
        class: "waiting"
    },
    wke = {
        class: "constrain menu has-header"
    },
    Ake = {
        key: 0
    };

function Oke(t, e, n, r, s, i) {
    const o = Ge("LogoSVG"),
        a = Ge("PlayerHeader");
    return B(), H("div", Ske, [U("div", wke, [Ve(o, {
        class: "logo"
    }), t.message ? (B(), H("p", Ake, rt(t.message), 1)) : Pe("", !0)]), Ve(a, {
        info: t.info
    }, null, 8, ["info"])])
}
const Cke = He(Tke, [
        ["render", Oke],
        ["__scopeId", "data-v-08490565"]
    ]),
    kke = "main/pp10/nopus-opus/assets/0523d60f.mp3",
    Ike = "main/pp10/nopus-opus/assets/6048b084.ogg",
    Nke = "main/pp10/nopus-opus/assets/a4c32d49.mp3",
    xke = "main/pp10/nopus-opus/assets/7a6eefbc.ogg",
    Pke = "main/pp10/nopus-opus/assets/23af5ef9.mp3",
    Rke = "main/pp10/nopus-opus/assets/47782f89.ogg";
var Xv = {
    exports: {}
};
(function(t, e) {
    (function() {
        var n = this,
            r = n._,
            s = Array.prototype,
            i = Object.prototype,
            o = Function.prototype,
            a = s.push,
            l = s.slice,
            u = i.toString,
            f = i.hasOwnProperty,
            d = Array.isArray,
            p = Object.keys,
            _ = o.bind,
            v = Object.create,
            y = function() {},
            g = function(w) {
                if (w instanceof g) return w;
                if (!(this instanceof g)) return new g(w);
                this._wrapped = w
            };
        t.exports && (e = t.exports = g), e._ = g, g.VERSION = "1.8.3";
        var b = function(w, M, Y) {
                if (M === void 0) return w;
                switch (Y ?? 3) {
                    case 1:
                        return function(X) {
                            return w.call(M, X)
                        };
                    case 2:
                        return function(X, I) {
                            return w.call(M, X, I)
                        };
                    case 3:
                        return function(X, I, T) {
                            return w.call(M, X, I, T)
                        };
                    case 4:
                        return function(X, I, T, S) {
                            return w.call(M, X, I, T, S)
                        }
                }
                return function() {
                    return w.apply(M, arguments)
                }
            },
            O = function(w, M, Y) {
                return w == null ? g.identity : g.isFunction(w) ? b(w, M, Y) : g.isObject(w) ? g.matcher(w) : g.property(w)
            };
        g.iteratee = function(w, M) {
            return O(w, M, 1 / 0)
        };
        var N = function(w, M) {
                return function(Y) {
                    var X = arguments.length;
                    if (X < 2 || Y == null) return Y;
                    for (var I = 1; I < X; I++)
                        for (var T = arguments[I], S = w(T), P = S.length, G = 0; G < P; G++) {
                            var te = S[G];
                            (!M || Y[te] === void 0) && (Y[te] = T[te])
                        }
                    return Y
                }
            },
            k = function(w) {
                if (!g.isObject(w)) return {};
                if (v) return v(w);
                y.prototype = w;
                var M = new y;
                return y.prototype = null, M
            },
            A = function(w) {
                return function(M) {
                    return M == null ? void 0 : M[w]
                }
            },
            x = Math.pow(2, 53) - 1,
            D = A("length"),
            L = function(w) {
                var M = D(w);
                return typeof M == "number" && M >= 0 && M <= x
            };
        g.each = g.forEach = function(w, M, Y) {
            M = b(M, Y);
            var X, I;
            if (L(w))
                for (X = 0, I = w.length; X < I; X++) M(w[X], X, w);
            else {
                var T = g.keys(w);
                for (X = 0, I = T.length; X < I; X++) M(w[T[X]], T[X], w)
            }
            return w
        }, g.map = g.collect = function(w, M, Y) {
            M = O(M, Y);
            for (var X = !L(w) && g.keys(w), I = (X || w).length, T = Array(I), S = 0; S < I; S++) {
                var P = X ? X[S] : S;
                T[S] = M(w[P], P, w)
            }
            return T
        };

        function q(w) {
            function M(Y, X, I, T, S, P) {
                for (; S >= 0 && S < P; S += w) {
                    var G = T ? T[S] : S;
                    I = X(I, Y[G], G, Y)
                }
                return I
            }
            return function(Y, X, I, T) {
                X = b(X, T, 4);
                var S = !L(Y) && g.keys(Y),
                    P = (S || Y).length,
                    G = w > 0 ? 0 : P - 1;
                return arguments.length < 3 && (I = Y[S ? S[G] : G], G += w), M(Y, X, I, S, G, P)
            }
        }
        g.reduce = g.foldl = g.inject = q(1), g.reduceRight = g.foldr = q(-1), g.find = g.detect = function(w, M, Y) {
            var X;
            if (L(w) ? X = g.findIndex(w, M, Y) : X = g.findKey(w, M, Y), X !== void 0 && X !== -1) return w[X]
        }, g.filter = g.select = function(w, M, Y) {
            var X = [];
            return M = O(M, Y), g.each(w, function(I, T, S) {
                M(I, T, S) && X.push(I)
            }), X
        }, g.reject = function(w, M, Y) {
            return g.filter(w, g.negate(O(M)), Y)
        }, g.every = g.all = function(w, M, Y) {
            M = O(M, Y);
            for (var X = !L(w) && g.keys(w), I = (X || w).length, T = 0; T < I; T++) {
                var S = X ? X[T] : T;
                if (!M(w[S], S, w)) return !1
            }
            return !0
        }, g.some = g.any = function(w, M, Y) {
            M = O(M, Y);
            for (var X = !L(w) && g.keys(w), I = (X || w).length, T = 0; T < I; T++) {
                var S = X ? X[T] : T;
                if (M(w[S], S, w)) return !0
            }
            return !1
        }, g.contains = g.includes = g.include = function(w, M, Y, X) {
            return L(w) || (w = g.values(w)), (typeof Y != "number" || X) && (Y = 0), g.indexOf(w, M, Y) >= 0
        }, g.invoke = function(w, M) {
            var Y = l.call(arguments, 2),
                X = g.isFunction(M);
            return g.map(w, function(I) {
                var T = X ? M : I[M];
                return T == null ? T : T.apply(I, Y)
            })
        }, g.pluck = function(w, M) {
            return g.map(w, g.property(M))
        }, g.where = function(w, M) {
            return g.filter(w, g.matcher(M))
        }, g.findWhere = function(w, M) {
            return g.find(w, g.matcher(M))
        }, g.max = function(w, M, Y) {
            var X = -1 / 0,
                I = -1 / 0,
                T, S;
            if (M == null && w != null) {
                w = L(w) ? w : g.values(w);
                for (var P = 0, G = w.length; P < G; P++) T = w[P], T > X && (X = T)
            } else M = O(M, Y), g.each(w, function(te, le, me) {
                S = M(te, le, me), (S > I || S === -1 / 0 && X === -1 / 0) && (X = te, I = S)
            });
            return X
        }, g.min = function(w, M, Y) {
            var X = 1 / 0,
                I = 1 / 0,
                T, S;
            if (M == null && w != null) {
                w = L(w) ? w : g.values(w);
                for (var P = 0, G = w.length; P < G; P++) T = w[P], T < X && (X = T)
            } else M = O(M, Y), g.each(w, function(te, le, me) {
                S = M(te, le, me), (S < I || S === 1 / 0 && X === 1 / 0) && (X = te, I = S)
            });
            return X
        }, g.shuffle = function(w) {
            for (var M = L(w) ? w : g.values(w), Y = M.length, X = Array(Y), I = 0, T; I < Y; I++) T = g.random(0, I), T !== I && (X[I] = X[T]), X[T] = M[I];
            return X
        }, g.sample = function(w, M, Y) {
            return M == null || Y ? (L(w) || (w = g.values(w)), w[g.random(w.length - 1)]) : g.shuffle(w).slice(0, Math.max(0, M))
        }, g.sortBy = function(w, M, Y) {
            return M = O(M, Y), g.pluck(g.map(w, function(X, I, T) {
                return {
                    value: X,
                    index: I,
                    criteria: M(X, I, T)
                }
            }).sort(function(X, I) {
                var T = X.criteria,
                    S = I.criteria;
                if (T !== S) {
                    if (T > S || T === void 0) return 1;
                    if (T < S || S === void 0) return -1
                }
                return X.index - I.index
            }), "value")
        };
        var ee = function(w) {
            return function(M, Y, X) {
                var I = {};
                return Y = O(Y, X), g.each(M, function(T, S) {
                    var P = Y(T, S, M);
                    w(I, T, P)
                }), I
            }
        };
        g.groupBy = ee(function(w, M, Y) {
            g.has(w, Y) ? w[Y].push(M) : w[Y] = [M]
        }), g.indexBy = ee(function(w, M, Y) {
            w[Y] = M
        }), g.countBy = ee(function(w, M, Y) {
            g.has(w, Y) ? w[Y]++ : w[Y] = 1
        }), g.toArray = function(w) {
            return w ? g.isArray(w) ? l.call(w) : L(w) ? g.map(w, g.identity) : g.values(w) : []
        }, g.size = function(w) {
            return w == null ? 0 : L(w) ? w.length : g.keys(w).length
        }, g.partition = function(w, M, Y) {
            M = O(M, Y);
            var X = [],
                I = [];
            return g.each(w, function(T, S, P) {
                (M(T, S, P) ? X : I).push(T)
            }), [X, I]
        }, g.first = g.head = g.take = function(w, M, Y) {
            if (w != null) return M == null || Y ? w[0] : g.initial(w, w.length - M)
        }, g.initial = function(w, M, Y) {
            return l.call(w, 0, Math.max(0, w.length - (M == null || Y ? 1 : M)))
        }, g.last = function(w, M, Y) {
            if (w != null) return M == null || Y ? w[w.length - 1] : g.rest(w, Math.max(0, w.length - M))
        }, g.rest = g.tail = g.drop = function(w, M, Y) {
            return l.call(w, M == null || Y ? 1 : M)
        }, g.compact = function(w) {
            return g.filter(w, g.identity)
        };
        var ae = function(w, M, Y, X) {
            for (var I = [], T = 0, S = X || 0, P = D(w); S < P; S++) {
                var G = w[S];
                if (L(G) && (g.isArray(G) || g.isArguments(G))) {
                    M || (G = ae(G, M, Y));
                    var te = 0,
                        le = G.length;
                    for (I.length += le; te < le;) I[T++] = G[te++]
                } else Y || (I[T++] = G)
            }
            return I
        };
        g.flatten = function(w, M) {
            return ae(w, M, !1)
        }, g.without = function(w) {
            return g.difference(w, l.call(arguments, 1))
        }, g.uniq = g.unique = function(w, M, Y, X) {
            g.isBoolean(M) || (X = Y, Y = M, M = !1), Y != null && (Y = O(Y, X));
            for (var I = [], T = [], S = 0, P = D(w); S < P; S++) {
                var G = w[S],
                    te = Y ? Y(G, S, w) : G;
                M ? ((!S || T !== te) && I.push(G), T = te) : Y ? g.contains(T, te) || (T.push(te), I.push(G)) : g.contains(I, G) || I.push(G)
            }
            return I
        }, g.union = function() {
            return g.uniq(ae(arguments, !0, !0))
        }, g.intersection = function(w) {
            for (var M = [], Y = arguments.length, X = 0, I = D(w); X < I; X++) {
                var T = w[X];
                if (!g.contains(M, T)) {
                    for (var S = 1; S < Y && g.contains(arguments[S], T); S++);
                    S === Y && M.push(T)
                }
            }
            return M
        }, g.difference = function(w) {
            var M = ae(arguments, !0, !0, 1);
            return g.filter(w, function(Y) {
                return !g.contains(M, Y)
            })
        }, g.zip = function() {
            return g.unzip(arguments)
        }, g.unzip = function(w) {
            for (var M = w && g.max(w, D).length || 0, Y = Array(M), X = 0; X < M; X++) Y[X] = g.pluck(w, X);
            return Y
        }, g.object = function(w, M) {
            for (var Y = {}, X = 0, I = D(w); X < I; X++) M ? Y[w[X]] = M[X] : Y[w[X][0]] = w[X][1];
            return Y
        };

        function Z(w) {
            return function(M, Y, X) {
                Y = O(Y, X);
                for (var I = D(M), T = w > 0 ? 0 : I - 1; T >= 0 && T < I; T += w)
                    if (Y(M[T], T, M)) return T;
                return -1
            }
        }
        g.findIndex = Z(1), g.findLastIndex = Z(-1), g.sortedIndex = function(w, M, Y, X) {
            Y = O(Y, X, 1);
            for (var I = Y(M), T = 0, S = D(w); T < S;) {
                var P = Math.floor((T + S) / 2);
                Y(w[P]) < I ? T = P + 1 : S = P
            }
            return T
        };

        function fe(w, M, Y) {
            return function(X, I, T) {
                var S = 0,
                    P = D(X);
                if (typeof T == "number") w > 0 ? S = T >= 0 ? T : Math.max(T + P, S) : P = T >= 0 ? Math.min(T + 1, P) : T + P + 1;
                else if (Y && T && P) return T = Y(X, I), X[T] === I ? T : -1;
                if (I !== I) return T = M(l.call(X, S, P), g.isNaN), T >= 0 ? T + S : -1;
                for (T = w > 0 ? S : P - 1; T >= 0 && T < P; T += w)
                    if (X[T] === I) return T;
                return -1
            }
        }
        g.indexOf = fe(1, g.findIndex, g.sortedIndex), g.lastIndexOf = fe(-1, g.findLastIndex), g.range = function(w, M, Y) {
            M == null && (M = w || 0, w = 0), Y = Y || 1;
            for (var X = Math.max(Math.ceil((M - w) / Y), 0), I = Array(X), T = 0; T < X; T++, w += Y) I[T] = w;
            return I
        };
        var ge = function(w, M, Y, X, I) {
            if (!(X instanceof M)) return w.apply(Y, I);
            var T = k(w.prototype),
                S = w.apply(T, I);
            return g.isObject(S) ? S : T
        };
        g.bind = function(w, M) {
            if (_ && w.bind === _) return _.apply(w, l.call(arguments, 1));
            if (!g.isFunction(w)) throw new TypeError("Bind must be called on a function");
            var Y = l.call(arguments, 2),
                X = function() {
                    return ge(w, X, M, this, Y.concat(l.call(arguments)))
                };
            return X
        }, g.partial = function(w) {
            var M = l.call(arguments, 1),
                Y = function() {
                    for (var X = 0, I = M.length, T = Array(I), S = 0; S < I; S++) T[S] = M[S] === g ? arguments[X++] : M[S];
                    for (; X < arguments.length;) T.push(arguments[X++]);
                    return ge(w, Y, this, this, T)
                };
            return Y
        }, g.bindAll = function(w) {
            var M, Y = arguments.length,
                X;
            if (Y <= 1) throw new Error("bindAll must be passed function names");
            for (M = 1; M < Y; M++) X = arguments[M], w[X] = g.bind(w[X], w);
            return w
        }, g.memoize = function(w, M) {
            var Y = function(X) {
                var I = Y.cache,
                    T = "" + (M ? M.apply(this, arguments) : X);
                return g.has(I, T) || (I[T] = w.apply(this, arguments)), I[T]
            };
            return Y.cache = {}, Y
        }, g.delay = function(w, M) {
            var Y = l.call(arguments, 2);
            return setTimeout(function() {
                return w.apply(null, Y)
            }, M)
        }, g.defer = g.partial(g.delay, g, 1), g.throttle = function(w, M, Y) {
            var X, I, T, S = null,
                P = 0;
            Y || (Y = {});
            var G = function() {
                P = Y.leading === !1 ? 0 : g.now(), S = null, T = w.apply(X, I), S || (X = I = null)
            };
            return function() {
                var te = g.now();
                !P && Y.leading === !1 && (P = te);
                var le = M - (te - P);
                return X = this, I = arguments, le <= 0 || le > M ? (S && (clearTimeout(S), S = null), P = te, T = w.apply(X, I), S || (X = I = null)) : !S && Y.trailing !== !1 && (S = setTimeout(G, le)), T
            }
        }, g.debounce = function(w, M, Y) {
            var X, I, T, S, P, G = function() {
                var te = g.now() - S;
                te < M && te >= 0 ? X = setTimeout(G, M - te) : (X = null, Y || (P = w.apply(T, I), X || (T = I = null)))
            };
            return function() {
                T = this, I = arguments, S = g.now();
                var te = Y && !X;
                return X || (X = setTimeout(G, M)), te && (P = w.apply(T, I), T = I = null), P
            }
        }, g.wrap = function(w, M) {
            return g.partial(M, w)
        }, g.negate = function(w) {
            return function() {
                return !w.apply(this, arguments)
            }
        }, g.compose = function() {
            var w = arguments,
                M = w.length - 1;
            return function() {
                for (var Y = M, X = w[M].apply(this, arguments); Y--;) X = w[Y].call(this, X);
                return X
            }
        }, g.after = function(w, M) {
            return function() {
                if (--w < 1) return M.apply(this, arguments)
            }
        }, g.before = function(w, M) {
            var Y;
            return function() {
                return --w > 0 && (Y = M.apply(this, arguments)), w <= 1 && (M = null), Y
            }
        }, g.once = g.partial(g.before, 2);
        var K = !{
                toString: null
            }.propertyIsEnumerable("toString"),
            Q = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];

        function ue(w, M) {
            var Y = Q.length,
                X = w.constructor,
                I = g.isFunction(X) && X.prototype || i,
                T = "constructor";
            for (g.has(w, T) && !g.contains(M, T) && M.push(T); Y--;) T = Q[Y], T in w && w[T] !== I[T] && !g.contains(M, T) && M.push(T)
        }
        g.keys = function(w) {
            if (!g.isObject(w)) return [];
            if (p) return p(w);
            var M = [];
            for (var Y in w) g.has(w, Y) && M.push(Y);
            return K && ue(w, M), M
        }, g.allKeys = function(w) {
            if (!g.isObject(w)) return [];
            var M = [];
            for (var Y in w) M.push(Y);
            return K && ue(w, M), M
        }, g.values = function(w) {
            for (var M = g.keys(w), Y = M.length, X = Array(Y), I = 0; I < Y; I++) X[I] = w[M[I]];
            return X
        }, g.mapObject = function(w, M, Y) {
            M = O(M, Y);
            for (var X = g.keys(w), I = X.length, T = {}, S, P = 0; P < I; P++) S = X[P], T[S] = M(w[S], S, w);
            return T
        }, g.pairs = function(w) {
            for (var M = g.keys(w), Y = M.length, X = Array(Y), I = 0; I < Y; I++) X[I] = [M[I], w[M[I]]];
            return X
        }, g.invert = function(w) {
            for (var M = {}, Y = g.keys(w), X = 0, I = Y.length; X < I; X++) M[w[Y[X]]] = Y[X];
            return M
        }, g.functions = g.methods = function(w) {
            var M = [];
            for (var Y in w) g.isFunction(w[Y]) && M.push(Y);
            return M.sort()
        }, g.extend = N(g.allKeys), g.extendOwn = g.assign = N(g.keys), g.findKey = function(w, M, Y) {
            M = O(M, Y);
            for (var X = g.keys(w), I, T = 0, S = X.length; T < S; T++)
                if (I = X[T], M(w[I], I, w)) return I
        }, g.pick = function(w, M, Y) {
            var X = {},
                I = w,
                T, S;
            if (I == null) return X;
            g.isFunction(M) ? (S = g.allKeys(I), T = b(M, Y)) : (S = ae(arguments, !1, !1, 1), T = function(me, ve, de) {
                return ve in de
            }, I = Object(I));
            for (var P = 0, G = S.length; P < G; P++) {
                var te = S[P],
                    le = I[te];
                T(le, te, I) && (X[te] = le)
            }
            return X
        }, g.omit = function(w, M, Y) {
            if (g.isFunction(M)) M = g.negate(M);
            else {
                var X = g.map(ae(arguments, !1, !1, 1), String);
                M = function(I, T) {
                    return !g.contains(X, T)
                }
            }
            return g.pick(w, M, Y)
        }, g.defaults = N(g.allKeys, !0), g.create = function(w, M) {
            var Y = k(w);
            return M && g.extendOwn(Y, M), Y
        }, g.clone = function(w) {
            return g.isObject(w) ? g.isArray(w) ? w.slice() : g.extend({}, w) : w
        }, g.tap = function(w, M) {
            return M(w), w
        }, g.isMatch = function(w, M) {
            var Y = g.keys(M),
                X = Y.length;
            if (w == null) return !X;
            for (var I = Object(w), T = 0; T < X; T++) {
                var S = Y[T];
                if (M[S] !== I[S] || !(S in I)) return !1
            }
            return !0
        };
        var _e = function(w, M, Y, X) {
            if (w === M) return w !== 0 || 1 / w === 1 / M;
            if (w == null || M == null) return w === M;
            w instanceof g && (w = w._wrapped), M instanceof g && (M = M._wrapped);
            var I = u.call(w);
            if (I !== u.call(M)) return !1;
            switch (I) {
                case "[object RegExp]":
                case "[object String]":
                    return "" + w == "" + M;
                case "[object Number]":
                    return +w != +w ? +M != +M : +w == 0 ? 1 / +w === 1 / M : +w == +M;
                case "[object Date]":
                case "[object Boolean]":
                    return +w == +M
            }
            var T = I === "[object Array]";
            if (!T) {
                if (typeof w != "object" || typeof M != "object") return !1;
                var S = w.constructor,
                    P = M.constructor;
                if (S !== P && !(g.isFunction(S) && S instanceof S && g.isFunction(P) && P instanceof P) && "constructor" in w && "constructor" in M) return !1
            }
            Y = Y || [], X = X || [];
            for (var G = Y.length; G--;)
                if (Y[G] === w) return X[G] === M;
            if (Y.push(w), X.push(M), T) {
                if (G = w.length, G !== M.length) return !1;
                for (; G--;)
                    if (!_e(w[G], M[G], Y, X)) return !1
            } else {
                var te = g.keys(w),
                    le;
                if (G = te.length, g.keys(M).length !== G) return !1;
                for (; G--;)
                    if (le = te[G], !(g.has(M, le) && _e(w[le], M[le], Y, X))) return !1
            }
            return Y.pop(), X.pop(), !0
        };
        g.isEqual = function(w, M) {
            return _e(w, M)
        }, g.isEmpty = function(w) {
            return w == null ? !0 : L(w) && (g.isArray(w) || g.isString(w) || g.isArguments(w)) ? w.length === 0 : g.keys(w).length === 0
        }, g.isElement = function(w) {
            return !!(w && w.nodeType === 1)
        }, g.isArray = d || function(w) {
            return u.call(w) === "[object Array]"
        }, g.isObject = function(w) {
            var M = typeof w;
            return M === "function" || M === "object" && !!w
        }, g.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error"], function(w) {
            g["is" + w] = function(M) {
                return u.call(M) === "[object " + w + "]"
            }
        }), g.isArguments(arguments) || (g.isArguments = function(w) {
            return g.has(w, "callee")
        }), typeof /./ != "function" && typeof Int8Array != "object" && (g.isFunction = function(w) {
            return typeof w == "function" || !1
        }), g.isFinite = function(w) {
            return isFinite(w) && !isNaN(parseFloat(w))
        }, g.isNaN = function(w) {
            return g.isNumber(w) && w !== +w
        }, g.isBoolean = function(w) {
            return w === !0 || w === !1 || u.call(w) === "[object Boolean]"
        }, g.isNull = function(w) {
            return w === null
        }, g.isUndefined = function(w) {
            return w === void 0
        }, g.has = function(w, M) {
            return w != null && f.call(w, M)
        }, g.noConflict = function() {
            return n._ = r, this
        }, g.identity = function(w) {
            return w
        }, g.constant = function(w) {
            return function() {
                return w
            }
        }, g.noop = function() {}, g.property = A, g.propertyOf = function(w) {
            return w == null ? function() {} : function(M) {
                return w[M]
            }
        }, g.matcher = g.matches = function(w) {
            return w = g.extendOwn({}, w),
                function(M) {
                    return g.isMatch(M, w)
                }
        }, g.times = function(w, M, Y) {
            var X = Array(Math.max(0, w));
            M = b(M, Y, 1);
            for (var I = 0; I < w; I++) X[I] = M(I);
            return X
        }, g.random = function(w, M) {
            return M == null && (M = w, w = 0), w + Math.floor(Math.random() * (M - w + 1))
        }, g.now = Date.now || function() {
            return new Date().getTime()
        };
        var Oe = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#x27;",
                "`": "&#x60;"
            },
            Ee = g.invert(Oe),
            Ce = function(w) {
                var M = function(T) {
                        return w[T]
                    },
                    Y = "(?:" + g.keys(w).join("|") + ")",
                    X = RegExp(Y),
                    I = RegExp(Y, "g");
                return function(T) {
                    return T = T == null ? "" : "" + T, X.test(T) ? T.replace(I, M) : T
                }
            };
        g.escape = Ce(Oe), g.unescape = Ce(Ee), g.result = function(w, M, Y) {
            var X = w == null ? void 0 : w[M];
            return X === void 0 && (X = Y), g.isFunction(X) ? X.call(w) : X
        };
        var De = 0;
        g.uniqueId = function(w) {
            var M = ++De + "";
            return w ? w + M : M
        }, g.templateSettings = {
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: /<%=([\s\S]+?)%>/g,
            escape: /<%-([\s\S]+?)%>/g
        };
        var Ue = /(.)^/,
            ot = {
                "'": "'",
                "\\": "\\",
                "\r": "r",
                "\n": "n",
                "\u2028": "u2028",
                "\u2029": "u2029"
            },
            je = /\\|'|\r|\n|\u2028|\u2029/g,
            Ze = function(w) {
                return "\\" + ot[w]
            };
        g.template = function(w, M, Y) {
            !M && Y && (M = Y), M = g.defaults({}, M, g.templateSettings);
            var X = RegExp([(M.escape || Ue).source, (M.interpolate || Ue).source, (M.evaluate || Ue).source].join("|") + "|$", "g"),
                I = 0,
                T = "__p+='";
            w.replace(X, function(te, le, me, ve, de) {
                return T += w.slice(I, de).replace(je, Ze), I = de + te.length, le ? T += `'+
((__t=(` + le + `))==null?'':_.escape(__t))+
'` : me ? T += `'+
((__t=(` + me + `))==null?'':__t)+
'` : ve && (T += `';
` + ve + `
__p+='`), te
            }), T += `';
`, M.variable || (T = `with(obj||{}){
` + T + `}
`), T = `var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
` + T + `return __p;
`;
            try {
                var S = new Function(M.variable || "obj", "_", T)
            } catch (te) {
                throw te.source = T, te
            }
            var P = function(te) {
                    return S.call(this, te, g)
                },
                G = M.variable || "obj";
            return P.source = "function(" + G + `){
` + T + "}", P
        }, g.chain = function(w) {
            var M = g(w);
            return M._chain = !0, M
        };
        var it = function(w, M) {
            return w._chain ? g(M).chain() : M
        };
        g.mixin = function(w) {
            g.each(g.functions(w), function(M) {
                var Y = g[M] = w[M];
                g.prototype[M] = function() {
                    var X = [this._wrapped];
                    return a.apply(X, arguments), it(this, Y.apply(g, X))
                }
            })
        }, g.mixin(g), g.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(w) {
            var M = s[w];
            g.prototype[w] = function() {
                var Y = this._wrapped;
                return M.apply(Y, arguments), (w === "shift" || w === "splice") && Y.length === 0 && delete Y[0], it(this, Y)
            }
        }), g.each(["concat", "join", "slice"], function(w) {
            var M = s[w];
            g.prototype[w] = function() {
                return it(this, M.apply(this._wrapped, arguments))
            }
        }), g.prototype.value = function() {
            return this._wrapped
        }, g.prototype.valueOf = g.prototype.toJSON = g.prototype.value, g.prototype.toString = function() {
            return "" + this._wrapped
        }
    }).call(_n)
})(Xv, Xv.exports);
var Mke = Xv.exports;
const Dke = st({
    components: {
        BaseModal: fI
    },
    setup() {
        const t = Pt.supportsType("ogg") ? "ogg" : "mp3",
            e = new ff({
                welcome1: new URL(Object.assign({
                    "../../assets/welcome1.mp3": kke,
                    "../../assets/welcome1.ogg": Ike
                })[`../../assets/welcome1.${t}`], self.location).href,
                welcome2: new URL(Object.assign({
                    "../../assets/welcome2.mp3": Nke,
                    "../../assets/welcome2.ogg": xke
                })[`../../assets/welcome2.${t}`], self.location).href,
                welcome3: new URL(Object.assign({
                    "../../assets/welcome3.mp3": Pke,
                    "../../assets/welcome3.ogg": Rke
                })[`../../assets/welcome3.${t}`], self.location).href
            }).toDestination();
        return e.volume.value = -3, {
            players: e
        }
    },
    methods: {
        onCloseClick() {
            this.$emit("didRequestClose")
        },
        async onTestClick() {
            const t = ["welcome1", "welcome2", "welcome3"];
            try {
                await sf(), this.players.player(Mke.sample(t)).start(0, .01)
            } catch (e) {
                console.warn(e)
            }
        }
    }
});
const $ke = t => (Gr("data-v-bd67b09f"), t = t(), Vr(), t),
    Lke = {
        class: "test-audio"
    },
    Fke = $ke(() => U("svg", {
        viewBox: "0 0 100 100"
    }, [U("circle", {
        cx: "50",
        cy: "50",
        r: "50"
    }), U("polygon", {
        points: "32,25 75,50 32,75"
    })], -1)),
    Uke = {
        class: "question"
    },
    Bke = {
        class: "check"
    };

function qke(t, e, n, r, s, i) {
    const o = Ge("BaseModal"),
        a = Gt("t");
    return B(), At(o, {
        "title-key": "WELCOME.AUDIO_CHECK"
    }, {
        default: $i(() => [U("div", Lke, [U("button", {
            onClick: e[0] || (e[0] = (...l) => t.onTestClick && t.onTestClick(...l))
        }, [Fke, mn(" " + rt(t.$t("WELCOME.TEST")), 1)])]), $e(U("p", Uke, null, 512), [
            [a, "WELCOME.NOT_HEARING"]
        ]), $e(U("p", Bke, null, 512), [
            [a, "WELCOME.CHECK_SETTINGS"]
        ]), U("dl", null, [$e(U("dt", null, null, 512), [
            [a, "WELCOME.SILENT"]
        ]), $e(U("dd", null, null, 512), [
            [a, "WELCOME.OFF"]
        ]), $e(U("dt", null, null, 512), [
            [a, "WELCOME.POWER_SAVER"]
        ]), $e(U("dd", null, null, 512), [
            [a, "WELCOME.OFF"]
        ]), $e(U("dt", null, null, 512), [
            [a, "WELCOME.VOLUME"]
        ]), $e(U("dd", null, null, 512), [
            [a, "WELCOME.UP"]
        ])]), $e(U("button", {
            class: "secondary close",
            onClick: e[1] || (e[1] = (...l) => t.onCloseClick && t.onCloseClick(...l))
        }, null, 512), [
            [a, "WELCOME.CONFIRM"]
        ])]),
        _: 1
    }, 8, ["title-key"])
}
const Gke = He(Dke, [
        ["render", qke],
        ["__scopeId", "data-v-bd67b09f"]
    ]),
    Vke = st({
        components: {
            InstrumentSelect: G8e,
            PostGame: z8e,
            Playback: n7e,
            Recording: oCe,
            Scoreboard: FCe,
            SongSelect: Eke,
            Waiting: Cke,
            Welcome: Gke
        },
        bb: {
            break: () => "<br />",
            info: (t, e) => `<span class="sub">${e}</span>`
        },
        ecastKeys: {
            audience: "audiencePlayer",
            player: ({
                id: t
            }) => `player:${t}`,
            players: "connectedPlayers",
            scoreboardInfo: "scoreboardInfo"
        },
        ecastProviders: {
            artifact: t => {
                if (t.artifact) return t.artifact;
                let e = 0,
                    n;
                for (; t[`artifact:${e}`];) n = t[`artifact:${e}`], e += 1;
                return n
            },
            beatmaps: t => {
                const e = {};
                return Object.keys(t).forEach(n => {
                    const [r, s] = n.split(":");
                    r === "beatmap" && (e[s] = t[n])
                }), e
            },
            hostIsPaused: t => {
                var e;
                return ((e = t.hostIsPaused) == null ? void 0 : e.hostIsPaused) ?? !1
            },
            info: (t, {
                id: e
            }) => {
                if (!t.connectedPlayers) return;
                const n = t.connectedPlayers[e];
                return t.audiencePlayer || !n ? {
                    name: "",
                    id: e,
                    avatar: 99,
                    isAudience: !0
                } : (Object.keys(t.connectedPlayers).length === 1 && (n.isSolo = !0), n)
            },
            instruments: t => {
                const e = {};
                return Object.keys(t).forEach(n => {
                    const [r, s] = n.split(":");
                    r === "instrument" && (e[s] = t[n])
                }), e
            },
            renders: t => t.songData ? t.songData.songs : []
        },
        props: {
            artifact: Object,
            audience: Object,
            beatmaps: Object,
            hostIsPaused: Boolean,
            info: Object,
            instruments: Object,
            player: Object,
            players: Object,
            renders: Array,
            scoreboardInfo: Object
        },
        themeColor: "#000",
        data() {
            return {
                showWelcome: !1,
                themeClass: "theme-green"
            }
        },
        computed: {
            classes() {
                const t = [this.themeClass];
                return this.$hotkeyManager.isDesktop.value && t.push("desktop"), t
            },
            isReady() {
                return !(!this.player && !this.audience || this.player && !this.info)
            },
            lastRender() {
                var t;
                return (t = this.renders) != null && t.length ? this.renders[this.renders.length - 1] : null
            },
            screen() {
                var r, s, i;
                const t = ((r = this.player) == null ? void 0 : r.kind) ?? ((s = this.audience) == null ? void 0 : s.kind),
                    e = this.getBeatmapAndInstrument(),
                    n = {
                        info: this.info,
                        player: this.player ?? this.audience
                    };
                if ((i = this.info) != null && i.isAudience && this.scoreboardInfo) return n.players = this.players, n.render = this.lastRender, ["Scoreboard", n];
                switch (t) {
                    case "credits":
                        return n.artifact = this.artifact, n.renders = this.renders, ["PostGame", n];
                    case "playback":
                        return ["Playback", n];
                    case "audienceRecording":
                    case "recording":
                        return e ? (n.hostIsPaused = this.hostIsPaused, n.beatmap = e[0], n.instrument = e[1], ["Recording", n]) : ["Waiting", n];
                    case "instrumentSelect":
                        return n.beatmaps = this.beatmaps, n.instruments = this.instruments, n.players = this.players, ["InstrumentSelect", n];
                    case "scoreboard":
                        return n.players = this.players, n.render = this.lastRender, ["Scoreboard", n];
                    case "songSelect":
                        return n.players = this.players, ["SongSelect", n]
                }
                return n.players = this.players, ["Waiting", n]
            }
        },
        watch: {
            "player.kind": "updateColors",
            "audience.kind": "updateColors"
        },
        mounted() {
            var t, e;
            this.updateColors(((t = this.player) == null ? void 0 : t.kind) ?? ((e = this.audience) == null ? void 0 : e.kind) ?? "", !0), document.body.classList.add("disabled-debug"), setTimeout(() => {
                var r;
                !xn.get("welcome", "code") && ((r = this.info) == null ? void 0 : r.name) !== "CARTOGRAPHER" && (this.showWelcome = !0, xn.set("welcome", "true", "code"))
            }, 500)
        },
        methods: {
            onDidRequestModalClose() {
                this.showWelcome = !1
            },
            getBeatmapAndInstrument() {
                if (!this.info || !this.beatmaps || !this.instruments) return null;
                let t = this.info.beatmapSlug,
                    e = this.info.instrumentSlug;
                if (this.info.isAudience) {
                    const s = xn.get("audienceId", "code");
                    if (!s) return null;
                    [t, e] = s.split(":")
                }
                if (!t || !e) return null;
                const n = this.beatmaps[t],
                    r = this.instruments[e];
                return !n || !r ? null : [n, r]
            },
            updateColors(t, e = !1) {
                if (t === "audienceRecording") {
                    this.themeClass = "theme-purple", this.$setThemeColor("#1b0330");
                    return
                }
                if (t === "credits") {
                    this.themeClass = "theme-purple", this.$setThemeColor("#000000");
                    return
                }
                if (t === "instrumentSelect") {
                    this.themeClass = "theme-purple", this.$setThemeColor("#000000");
                    return
                }
                if (t === "playback") {
                    this.themeClass = "theme-purple", this.$setThemeColor("#000000");
                    return
                }
                if (t === "recording") {
                    this.themeClass = "theme-purple", this.$setThemeColor("#1b0330");
                    return
                }
                if (t === "scoreboard") {
                    if (!this.lastRender || !this.info) return;
                    let n = this.lastRender.survived ? "theme-green" : "theme-purple";
                    this.info.isAudience && this.lastRender.audienceSurvived !== void 0 && (n = this.lastRender.audienceSurvived ? "theme-green" : "theme-purple"), this.themeClass = n, this.$setThemeColor("#000000");
                    return
                }
                if (t === "songSelect") {
                    this.themeClass = "theme-green", this.$setThemeColor("#000000");
                    return
                }
                e === !0 && (this.themeClass = "theme-green", this.$setThemeColor("#000000"))
            }
        }
    });

function jke(t, e, n, r, s, i) {
    const o = Ge("Welcome");
    return t.isReady ? (B(), H("div", {
        key: 0,
        class: nt(["nopus", t.classes])
    }, [t.screen ? (B(), At(Fm(t.screen[0]), Mf({
        key: 0,
        role: "main"
    }, t.screen[1]), null, 16)) : Pe("", !0), t.showWelcome ? (B(), At(o, {
        key: 1,
        onDidRequestClose: t.onDidRequestModalClose
    }, null, 8, ["onDidRequestClose"])) : Pe("", !0)], 2)) : Pe("", !0)
}
const Wke = He(Vke, [
    ["render", jke]
]);
n_e({
    MainView: Wke,
    GalleryView: CC,
    messages: Kye,
    plugins: [s_e, nme]
});
export {
    P7 as c
};
//# sourceMappingURL=f56a178f.js.map