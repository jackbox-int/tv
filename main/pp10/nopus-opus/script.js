var uR = Object.defineProperty;
var hR = (t, e, n) => e in t ? uR(t, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : t[e] = n;
var fR = (t, e) => () => (e || t((e = {
    exports: {}
}).exports, e), e.exports);
var Se = (t, e, n) => (hR(t, typeof e != "symbol" ? e + "" : e, n), n);
var xwe = fR((H3e, R6) => {
    (function() {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s);
        new MutationObserver(s => {
            for (const i of s)
                if (i.type === "childList")
                    for (const a of i.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a)
        }).observe(document, {
            childList: !0,
            subtree: !0
        });

        function n(s) {
            const i = {};
            return s.integrity && (i.integrity = s.integrity), s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i
        }

        function r(s) {
            if (s.ep) return;
            s.ep = !0;
            const i = n(s);
            fetch(s.href, i)
        }
    })();

    function Ty(t, e) {
        const n = Object.create(null),
            r = t.split(",");
        for (let s = 0; s < r.length; s++) n[r[s]] = !0;
        return e ? s => !!n[s.toLowerCase()] : s => !!n[s]
    }
    const Jt = {},
        pc = [],
        Ts = () => {},
        dR = () => !1,
        pR = /^on[^a-z]/,
        kp = t => pR.test(t),
        Sy = t => t.startsWith("onUpdate:"),
        wn = Object.assign,
        wy = (t, e) => {
            const n = t.indexOf(e);
            n > -1 && t.splice(n, 1)
        },
        mR = Object.prototype.hasOwnProperty,
        At = (t, e) => mR.call(t, e),
        qe = Array.isArray,
        mc = t => Wu(t) === "[object Map]",
        Ip = t => Wu(t) === "[object Set]",
        LE = t => Wu(t) === "[object Date]",
        lt = t => typeof t == "function",
        vn = t => typeof t == "string",
        cu = t => typeof t == "symbol",
        qt = t => t !== null && typeof t == "object",
        s5 = t => qt(t) && lt(t.then) && lt(t.catch),
        i5 = Object.prototype.toString,
        Wu = t => i5.call(t),
        gR = t => Wu(t).slice(8, -1),
        o5 = t => Wu(t) === "[object Object]",
        Oy = t => vn(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t,
        jf = Ty(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
        Np = t => {
            const e = Object.create(null);
            return n => e[n] || (e[n] = t(n))
        },
        _R = /-(\w)/g,
        zs = Np(t => t.replace(_R, (e, n) => n ? n.toUpperCase() : "")),
        yR = /\B([A-Z])/g,
        Ia = Np(t => t.replace(yR, "-$1").toLowerCase()),
        xp = Np(t => t.charAt(0).toUpperCase() + t.slice(1)),
        Zg = Np(t => t ? `on${xp(t)}` : ""),
        lu = (t, e) => !Object.is(t, e),
        Vf = (t, e) => {
            for (let n = 0; n < t.length; n++) t[n](e)
        },
        td = (t, e, n) => {
            Object.defineProperty(t, e, {
                configurable: !0,
                enumerable: !1,
                value: n
            })
        },
        z_ = t => {
            const e = parseFloat(t);
            return isNaN(e) ? t : e
        },
        vR = t => {
            const e = vn(t) ? Number(t) : NaN;
            return isNaN(e) ? t : e
        };
    let FE;
    const Z_ = () => FE || (FE = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

    function Tn(t) {
        if (qe(t)) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const r = t[n],
                    s = vn(r) ? SR(r) : Tn(r);
                if (s)
                    for (const i in s) e[i] = s[i]
            }
            return e
        } else {
            if (vn(t)) return t;
            if (qt(t)) return t
        }
    }
    const bR = /;(?![^(]*\))/g,
        ER = /:([^]+)/,
        TR = /\/\*[^]*?\*\//g;

    function SR(t) {
        const e = {};
        return t.replace(TR, "").split(bR).forEach(n => {
            if (n) {
                const r = n.split(ER);
                r.length > 1 && (e[r[0].trim()] = r[1].trim())
            }
        }), e
    }

    function Xe(t) {
        let e = "";
        if (vn(t)) e = t;
        else if (qe(t))
            for (let n = 0; n < t.length; n++) {
                const r = Xe(t[n]);
                r && (e += r + " ")
            } else if (qt(t))
                for (const n in t) t[n] && (e += n + " ");
        return e.trim()
    }
    const wR = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
        OR = Ty(wR);

    function a5(t) {
        return !!t || t === ""
    }

    function AR(t, e) {
        if (t.length !== e.length) return !1;
        let n = !0;
        for (let r = 0; n && r < t.length; r++) n = Pp(t[r], e[r]);
        return n
    }

    function Pp(t, e) {
        if (t === e) return !0;
        let n = LE(t),
            r = LE(e);
        if (n || r) return n && r ? t.getTime() === e.getTime() : !1;
        if (n = cu(t), r = cu(e), n || r) return t === e;
        if (n = qe(t), r = qe(e), n || r) return n && r ? AR(t, e) : !1;
        if (n = qt(t), r = qt(e), n || r) {
            if (!n || !r) return !1;
            const s = Object.keys(t).length,
                i = Object.keys(e).length;
            if (s !== i) return !1;
            for (const a in t) {
                const c = t.hasOwnProperty(a),
                    u = e.hasOwnProperty(a);
                if (c && !u || !c && u || !Pp(t[a], e[a])) return !1
            }
        }
        return String(t) === String(e)
    }

    function c5(t, e) {
        return t.findIndex(n => Pp(n, e))
    }
    const vt = t => vn(t) ? t : t == null ? "" : qe(t) || qt(t) && (t.toString === i5 || !lt(t.toString)) ? JSON.stringify(t, l5, 2) : String(t),
        l5 = (t, e) => e && e.__v_isRef ? l5(t, e.value) : mc(e) ? {
            [`Map(${e.size})`]: [...e.entries()].reduce((n, [r, s]) => (n[`${r} =>`] = s, n), {})
        } : Ip(e) ? {
            [`Set(${e.size})`]: [...e.values()]
        } : qt(e) && !qe(e) && !o5(e) ? String(e) : e;
    let ds;
    class u5 {
        constructor(e = !1) {
            this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = ds, !e && ds && (this.index = (ds.scopes || (ds.scopes = [])).push(this) - 1)
        }
        get active() {
            return this._active
        }
        run(e) {
            if (this._active) {
                const n = ds;
                try {
                    return ds = this, e()
                } finally {
                    ds = n
                }
            }
        }
        on() {
            ds = this
        }
        off() {
            ds = this.parent
        }
        stop(e) {
            if (this._active) {
                let n, r;
                for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop();
                for (n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]();
                if (this.scopes)
                    for (n = 0, r = this.scopes.length; n < r; n++) this.scopes[n].stop(!0);
                if (!this.detached && this.parent && !e) {
                    const s = this.parent.scopes.pop();
                    s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index)
                }
                this.parent = void 0, this._active = !1
            }
        }
    }

    function CR(t) {
        return new u5(t)
    }

    function kR(t, e = ds) {
        e && e.active && e.effects.push(t)
    }

    function IR() {
        return ds
    }
    const Ay = t => {
            const e = new Set(t);
            return e.w = 0, e.n = 0, e
        },
        h5 = t => (t.w & bo) > 0,
        f5 = t => (t.n & bo) > 0,
        NR = ({
            deps: t
        }) => {
            if (t.length)
                for (let e = 0; e < t.length; e++) t[e].w |= bo
        },
        xR = t => {
            const {
                deps: e
            } = t;
            if (e.length) {
                let n = 0;
                for (let r = 0; r < e.length; r++) {
                    const s = e[r];
                    h5(s) && !f5(s) ? s.delete(t) : e[n++] = s, s.w &= ~bo, s.n &= ~bo
                }
                e.length = n
            }
        },
        X_ = new WeakMap;
    let Vl = 0,
        bo = 1;
    const J_ = 30;
    let ys;
    const pa = Symbol(""),
        Q_ = Symbol("");
    class Cy {
        constructor(e, n = null, r) {
            this.fn = e, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, kR(this, r)
        }
        run() {
            if (!this.active) return this.fn();
            let e = ys,
                n = fo;
            for (; e;) {
                if (e === this) return;
                e = e.parent
            }
            try {
                return this.parent = ys, ys = this, fo = !0, bo = 1 << ++Vl, Vl <= J_ ? NR(this) : UE(this), this.fn()
            } finally {
                Vl <= J_ && xR(this), bo = 1 << --Vl, ys = this.parent, fo = n, this.parent = void 0, this.deferStop && this.stop()
            }
        }
        stop() {
            ys === this ? this.deferStop = !0 : this.active && (UE(this), this.onStop && this.onStop(), this.active = !1)
        }
    }

    function UE(t) {
        const {
            deps: e
        } = t;
        if (e.length) {
            for (let n = 0; n < e.length; n++) e[n].delete(t);
            e.length = 0
        }
    }
    let fo = !0;
    const d5 = [];

    function Jc() {
        d5.push(fo), fo = !1
    }

    function Qc() {
        const t = d5.pop();
        fo = t === void 0 ? !0 : t
    }

    function Ar(t, e, n) {
        if (fo && ys) {
            let r = X_.get(t);
            r || X_.set(t, r = new Map);
            let s = r.get(n);
            s || r.set(n, s = Ay()), p5(s)
        }
    }

    function p5(t, e) {
        let n = !1;
        Vl <= J_ ? f5(t) || (t.n |= bo, n = !h5(t)) : n = !t.has(ys), n && (t.add(ys), ys.deps.push(t))
    }

    function xi(t, e, n, r, s, i) {
        const a = X_.get(t);
        if (!a) return;
        let c = [];
        if (e === "clear") c = [...a.values()];
        else if (n === "length" && qe(t)) {
            const u = Number(r);
            a.forEach((h, d) => {
                (d === "length" || d >= u) && c.push(h)
            })
        } else switch (n !== void 0 && c.push(a.get(n)), e) {
            case "add":
                qe(t) ? Oy(n) && c.push(a.get("length")) : (c.push(a.get(pa)), mc(t) && c.push(a.get(Q_)));
                break;
            case "delete":
                qe(t) || (c.push(a.get(pa)), mc(t) && c.push(a.get(Q_)));
                break;
            case "set":
                mc(t) && c.push(a.get(pa));
                break
        }
        if (c.length === 1) c[0] && e1(c[0]);
        else {
            const u = [];
            for (const h of c) h && u.push(...h);
            e1(Ay(u))
        }
    }

    function e1(t, e) {
        const n = qe(t) ? t : [...t];
        for (const r of n) r.computed && BE(r);
        for (const r of n) r.computed || BE(r)
    }

    function BE(t, e) {
        (t !== ys || t.allowRecurse) && (t.scheduler ? t.scheduler() : t.run())
    }
    const PR = Ty("__proto__,__v_isRef,__isVue"),
        m5 = new Set(Object.getOwnPropertyNames(Symbol).filter(t => t !== "arguments" && t !== "caller").map(t => Symbol[t]).filter(cu)),
        RR = ky(),
        MR = ky(!1, !0),
        DR = ky(!0),
        qE = $R();

    function $R() {
        const t = {};
        return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
            t[e] = function(...n) {
                const r = kt(this);
                for (let i = 0, a = this.length; i < a; i++) Ar(r, "get", i + "");
                const s = r[e](...n);
                return s === -1 || s === !1 ? r[e](...n.map(kt)) : s
            }
        }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
            t[e] = function(...n) {
                Jc();
                const r = kt(this)[e].apply(this, n);
                return Qc(), r
            }
        }), t
    }

    function LR(t) {
        const e = kt(this);
        return Ar(e, "has", t), e.hasOwnProperty(t)
    }

    function ky(t = !1, e = !1) {
        return function(r, s, i) {
            if (s === "__v_isReactive") return !t;
            if (s === "__v_isReadonly") return t;
            if (s === "__v_isShallow") return e;
            if (s === "__v_raw" && i === (t ? e ? QR : b5 : e ? v5 : y5).get(r)) return r;
            const a = qe(r);
            if (!t) {
                if (a && At(qE, s)) return Reflect.get(qE, s, i);
                if (s === "hasOwnProperty") return LR
            }
            const c = Reflect.get(r, s, i);
            return (cu(s) ? m5.has(s) : PR(s)) || (t || Ar(r, "get", s), e) ? c : jn(c) ? a && Oy(s) ? c : c.value : qt(c) ? t ? E5(c) : Nc(c) : c
        }
    }
    const FR = g5(),
        UR = g5(!0);

    function g5(t = !1) {
        return function(n, r, s, i) {
            let a = n[r];
            if (xc(a) && jn(a) && !jn(s)) return !1;
            if (!t && (!nd(s) && !xc(s) && (a = kt(a), s = kt(s)), !qe(n) && jn(a) && !jn(s))) return a.value = s, !0;
            const c = qe(n) && Oy(r) ? Number(r) < n.length : At(n, r),
                u = Reflect.set(n, r, s, i);
            return n === kt(i) && (c ? lu(s, a) && xi(n, "set", r, s) : xi(n, "add", r, s)), u
        }
    }

    function BR(t, e) {
        const n = At(t, e);
        t[e];
        const r = Reflect.deleteProperty(t, e);
        return r && n && xi(t, "delete", e, void 0), r
    }

    function qR(t, e) {
        const n = Reflect.has(t, e);
        return (!cu(e) || !m5.has(e)) && Ar(t, "has", e), n
    }

    function jR(t) {
        return Ar(t, "iterate", qe(t) ? "length" : pa), Reflect.ownKeys(t)
    }
    const _5 = {
            get: RR,
            set: FR,
            deleteProperty: BR,
            has: qR,
            ownKeys: jR
        },
        VR = {
            get: DR,
            set(t, e) {
                return !0
            },
            deleteProperty(t, e) {
                return !0
            }
        },
        GR = wn({}, _5, {
            get: MR,
            set: UR
        }),
        Iy = t => t,
        Rp = t => Reflect.getPrototypeOf(t);

    function ff(t, e, n = !1, r = !1) {
        t = t.__v_raw;
        const s = kt(t),
            i = kt(e);
        n || (e !== i && Ar(s, "get", e), Ar(s, "get", i));
        const {
            has: a
        } = Rp(s), c = r ? Iy : n ? Py : uu;
        if (a.call(s, e)) return c(t.get(e));
        if (a.call(s, i)) return c(t.get(i));
        t !== s && t.get(e)
    }

    function df(t, e = !1) {
        const n = this.__v_raw,
            r = kt(n),
            s = kt(t);
        return e || (t !== s && Ar(r, "has", t), Ar(r, "has", s)), t === s ? n.has(t) : n.has(t) || n.has(s)
    }

    function pf(t, e = !1) {
        return t = t.__v_raw, !e && Ar(kt(t), "iterate", pa), Reflect.get(t, "size", t)
    }

    function jE(t) {
        t = kt(t);
        const e = kt(this);
        return Rp(e).has.call(e, t) || (e.add(t), xi(e, "add", t, t)), this
    }

    function VE(t, e) {
        e = kt(e);
        const n = kt(this),
            {
                has: r,
                get: s
            } = Rp(n);
        let i = r.call(n, t);
        i || (t = kt(t), i = r.call(n, t));
        const a = s.call(n, t);
        return n.set(t, e), i ? lu(e, a) && xi(n, "set", t, e) : xi(n, "add", t, e), this
    }

    function GE(t) {
        const e = kt(this),
            {
                has: n,
                get: r
            } = Rp(e);
        let s = n.call(e, t);
        s || (t = kt(t), s = n.call(e, t)), r && r.call(e, t);
        const i = e.delete(t);
        return s && xi(e, "delete", t, void 0), i
    }

    function WE() {
        const t = kt(this),
            e = t.size !== 0,
            n = t.clear();
        return e && xi(t, "clear", void 0, void 0), n
    }

    function mf(t, e) {
        return function(r, s) {
            const i = this,
                a = i.__v_raw,
                c = kt(a),
                u = e ? Iy : t ? Py : uu;
            return !t && Ar(c, "iterate", pa), a.forEach((h, d) => r.call(s, u(h), u(d), i))
        }
    }

    function gf(t, e, n) {
        return function(...r) {
            const s = this.__v_raw,
                i = kt(s),
                a = mc(i),
                c = t === "entries" || t === Symbol.iterator && a,
                u = t === "keys" && a,
                h = s[t](...r),
                d = n ? Iy : e ? Py : uu;
            return !e && Ar(i, "iterate", u ? Q_ : pa), {
                next() {
                    const {
                        value: p,
                        done: m
                    } = h.next();
                    return m ? {
                        value: p,
                        done: m
                    } : {
                        value: c ? [d(p[0]), d(p[1])] : d(p),
                        done: m
                    }
                },
                [Symbol.iterator]() {
                    return this
                }
            }
        }
    }

    function Ji(t) {
        return function(...e) {
            return t === "delete" ? !1 : this
        }
    }

    function WR() {
        const t = {
                get(i) {
                    return ff(this, i)
                },
                get size() {
                    return pf(this)
                },
                has: df,
                add: jE,
                set: VE,
                delete: GE,
                clear: WE,
                forEach: mf(!1, !1)
            },
            e = {
                get(i) {
                    return ff(this, i, !1, !0)
                },
                get size() {
                    return pf(this)
                },
                has: df,
                add: jE,
                set: VE,
                delete: GE,
                clear: WE,
                forEach: mf(!1, !0)
            },
            n = {
                get(i) {
                    return ff(this, i, !0)
                },
                get size() {
                    return pf(this, !0)
                },
                has(i) {
                    return df.call(this, i, !0)
                },
                add: Ji("add"),
                set: Ji("set"),
                delete: Ji("delete"),
                clear: Ji("clear"),
                forEach: mf(!0, !1)
            },
            r = {
                get(i) {
                    return ff(this, i, !0, !0)
                },
                get size() {
                    return pf(this, !0)
                },
                has(i) {
                    return df.call(this, i, !0)
                },
                add: Ji("add"),
                set: Ji("set"),
                delete: Ji("delete"),
                clear: Ji("clear"),
                forEach: mf(!0, !0)
            };
        return ["keys", "values", "entries", Symbol.iterator].forEach(i => {
            t[i] = gf(i, !1, !1), n[i] = gf(i, !0, !1), e[i] = gf(i, !1, !0), r[i] = gf(i, !0, !0)
        }), [t, n, e, r]
    }
    const [HR, KR, YR, zR] = WR();

    function Ny(t, e) {
        const n = e ? t ? zR : YR : t ? KR : HR;
        return (r, s, i) => s === "__v_isReactive" ? !t : s === "__v_isReadonly" ? t : s === "__v_raw" ? r : Reflect.get(At(n, s) && s in r ? n : r, s, i)
    }
    const ZR = {
            get: Ny(!1, !1)
        },
        XR = {
            get: Ny(!1, !0)
        },
        JR = {
            get: Ny(!0, !1)
        },
        y5 = new WeakMap,
        v5 = new WeakMap,
        b5 = new WeakMap,
        QR = new WeakMap;

    function eM(t) {
        switch (t) {
            case "Object":
            case "Array":
                return 1;
            case "Map":
            case "Set":
            case "WeakMap":
            case "WeakSet":
                return 2;
            default:
                return 0
        }
    }

    function tM(t) {
        return t.__v_skip || !Object.isExtensible(t) ? 0 : eM(gR(t))
    }

    function Nc(t) {
        return xc(t) ? t : xy(t, !1, _5, ZR, y5)
    }

    function nM(t) {
        return xy(t, !1, GR, XR, v5)
    }

    function E5(t) {
        return xy(t, !0, VR, JR, b5)
    }

    function xy(t, e, n, r, s) {
        if (!qt(t) || t.__v_raw && !(e && t.__v_isReactive)) return t;
        const i = s.get(t);
        if (i) return i;
        const a = tM(t);
        if (a === 0) return t;
        const c = new Proxy(t, a === 2 ? r : n);
        return s.set(t, c), c
    }

    function gc(t) {
        return xc(t) ? gc(t.__v_raw) : !!(t && t.__v_isReactive)
    }

    function xc(t) {
        return !!(t && t.__v_isReadonly)
    }

    function nd(t) {
        return !!(t && t.__v_isShallow)
    }

    function T5(t) {
        return gc(t) || xc(t)
    }

    function kt(t) {
        const e = t && t.__v_raw;
        return e ? kt(e) : t
    }

    function S5(t) {
        return td(t, "__v_skip", !0), t
    }
    const uu = t => qt(t) ? Nc(t) : t,
        Py = t => qt(t) ? E5(t) : t;

    function w5(t) {
        fo && ys && (t = kt(t), p5(t.dep || (t.dep = Ay())))
    }

    function O5(t, e) {
        t = kt(t);
        const n = t.dep;
        n && e1(n)
    }

    function jn(t) {
        return !!(t && t.__v_isRef === !0)
    }

    function Jr(t) {
        return A5(t, !1)
    }

    function rM(t) {
        return A5(t, !0)
    }

    function A5(t, e) {
        return jn(t) ? t : new sM(t, e)
    }
    class sM {
        constructor(e, n) {
            this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : kt(e), this._value = n ? e : uu(e)
        }
        get value() {
            return w5(this), this._value
        }
        set value(e) {
            const n = this.__v_isShallow || nd(e) || xc(e);
            e = n ? e : kt(e), lu(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : uu(e), O5(this))
        }
    }

    function iM(t) {
        return jn(t) ? t.value : t
    }
    const oM = {
        get: (t, e, n) => iM(Reflect.get(t, e, n)),
        set: (t, e, n, r) => {
            const s = t[e];
            return jn(s) && !jn(n) ? (s.value = n, !0) : Reflect.set(t, e, n, r)
        }
    };

    function C5(t) {
        return gc(t) ? t : new Proxy(t, oM)
    }
    class aM {
        constructor(e, n, r, s) {
            this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new Cy(e, () => {
                this._dirty || (this._dirty = !0, O5(this))
            }), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = r
        }
        get value() {
            const e = kt(this);
            return w5(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value
        }
        set value(e) {
            this._setter(e)
        }
    }

    function cM(t, e, n = !1) {
        let r, s;
        const i = lt(t);
        return i ? (r = t, s = Ts) : (r = t.get, s = t.set), new aM(r, s, i || !s, n)
    }

    function po(t, e, n, r) {
        let s;
        try {
            s = r ? t(...r) : t()
        } catch (i) {
            Mp(i, e, n)
        }
        return s
    }

    function ts(t, e, n, r) {
        if (lt(t)) {
            const i = po(t, e, n, r);
            return i && s5(i) && i.catch(a => {
                Mp(a, e, n)
            }), i
        }
        const s = [];
        for (let i = 0; i < t.length; i++) s.push(ts(t[i], e, n, r));
        return s
    }

    function Mp(t, e, n, r = !0) {
        const s = e ? e.vnode : null;
        if (e) {
            let i = e.parent;
            const a = e.proxy,
                c = n;
            for (; i;) {
                const h = i.ec;
                if (h) {
                    for (let d = 0; d < h.length; d++)
                        if (h[d](t, a, c) === !1) return
                }
                i = i.parent
            }
            const u = e.appContext.config.errorHandler;
            if (u) {
                po(u, null, 10, [t, a, c]);
                return
            }
        }
        lM(t, n, s, r)
    }

    function lM(t, e, n, r = !0) {
        console.error(t)
    }
    let hu = !1,
        t1 = !1;
    const er = [];
    let Ys = 0;
    const _c = [];
    let Ti = null,
        sa = 0;
    const k5 = Promise.resolve();
    let Ry = null;

    function uM(t) {
        const e = Ry || k5;
        return t ? e.then(this ? t.bind(this) : t) : e
    }

    function hM(t) {
        let e = Ys + 1,
            n = er.length;
        for (; e < n;) {
            const r = e + n >>> 1;
            fu(er[r]) < t ? e = r + 1 : n = r
        }
        return e
    }

    function My(t) {
        (!er.length || !er.includes(t, hu && t.allowRecurse ? Ys + 1 : Ys)) && (t.id == null ? er.push(t) : er.splice(hM(t.id), 0, t), I5())
    }

    function I5() {
        !hu && !t1 && (t1 = !0, Ry = k5.then(x5))
    }

    function fM(t) {
        const e = er.indexOf(t);
        e > Ys && er.splice(e, 1)
    }

    function dM(t) {
        qe(t) ? _c.push(...t) : (!Ti || !Ti.includes(t, t.allowRecurse ? sa + 1 : sa)) && _c.push(t), I5()
    }

    function HE(t, e = hu ? Ys + 1 : 0) {
        for (; e < er.length; e++) {
            const n = er[e];
            n && n.pre && (er.splice(e, 1), e--, n())
        }
    }

    function N5(t) {
        if (_c.length) {
            const e = [...new Set(_c)];
            if (_c.length = 0, Ti) {
                Ti.push(...e);
                return
            }
            for (Ti = e, Ti.sort((n, r) => fu(n) - fu(r)), sa = 0; sa < Ti.length; sa++) Ti[sa]();
            Ti = null, sa = 0
        }
    }
    const fu = t => t.id == null ? 1 / 0 : t.id,
        pM = (t, e) => {
            const n = fu(t) - fu(e);
            if (n === 0) {
                if (t.pre && !e.pre) return -1;
                if (e.pre && !t.pre) return 1
            }
            return n
        };

    function x5(t) {
        t1 = !1, hu = !0, er.sort(pM);
        const e = Ts;
        try {
            for (Ys = 0; Ys < er.length; Ys++) {
                const n = er[Ys];
                n && n.active !== !1 && po(n, null, 14)
            }
        } finally {
            Ys = 0, er.length = 0, N5(), hu = !1, Ry = null, (er.length || _c.length) && x5()
        }
    }

    function mM(t, e, ...n) {
        if (t.isUnmounted) return;
        const r = t.vnode.props || Jt;
        let s = n;
        const i = e.startsWith("update:"),
            a = i && e.slice(7);
        if (a && a in r) {
            const d = `${a==="modelValue"?"model":a}Modifiers`,
                {
                    number: p,
                    trim: m
                } = r[d] || Jt;
            m && (s = n.map(_ => vn(_) ? _.trim() : _)), p && (s = n.map(z_))
        }
        let c, u = r[c = Zg(e)] || r[c = Zg(zs(e))];
        !u && i && (u = r[c = Zg(Ia(e))]), u && ts(u, t, 6, s);
        const h = r[c + "Once"];
        if (h) {
            if (!t.emitted) t.emitted = {};
            else if (t.emitted[c]) return;
            t.emitted[c] = !0, ts(h, t, 6, s)
        }
    }

    function P5(t, e, n = !1) {
        const r = e.emitsCache,
            s = r.get(t);
        if (s !== void 0) return s;
        const i = t.emits;
        let a = {},
            c = !1;
        if (!lt(t)) {
            const u = h => {
                const d = P5(h, e, !0);
                d && (c = !0, wn(a, d))
            };
            !n && e.mixins.length && e.mixins.forEach(u), t.extends && u(t.extends), t.mixins && t.mixins.forEach(u)
        }
        return !i && !c ? (qt(t) && r.set(t, null), null) : (qe(i) ? i.forEach(u => a[u] = null) : wn(a, i), qt(t) && r.set(t, a), a)
    }

    function Dp(t, e) {
        return !t || !kp(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), At(t, e[0].toLowerCase() + e.slice(1)) || At(t, Ia(e)) || At(t, e))
    }
    let Vn = null,
        $p = null;

    function rd(t) {
        const e = Vn;
        return Vn = t, $p = t && t.type.__scopeId || null, e
    }

    function Ns(t) {
        $p = t
    }

    function xs() {
        $p = null
    }

    function si(t, e = Vn, n) {
        if (!e || t._n) return t;
        const r = (...s) => {
            r._d && sT(-1);
            const i = rd(e);
            let a;
            try {
                a = t(...s)
            } finally {
                rd(i), r._d && sT(1)
            }
            return a
        };
        return r._n = !0, r._c = !0, r._d = !0, r
    }

    function Xg(t) {
        const {
            type: e,
            vnode: n,
            proxy: r,
            withProxy: s,
            props: i,
            propsOptions: [a],
            slots: c,
            attrs: u,
            emit: h,
            render: d,
            renderCache: p,
            data: m,
            setupState: _,
            ctx: y,
            inheritAttrs: v
        } = t;
        let w, b;
        const I = rd(t);
        try {
            if (n.shapeFlag & 4) {
                const x = s || r;
                w = Hs(d.call(x, x, p, i, _, m, y)), b = u
            } else {
                const x = e;
                w = Hs(x.length > 1 ? x(i, {
                    attrs: u,
                    slots: c,
                    emit: h
                }) : x(i, null)), b = e.props ? u : gM(u)
            }
        } catch (x) {
            zl.length = 0, Mp(x, t, 1), w = Je(ns)
        }
        let F = w;
        if (b && v !== !1) {
            const x = Object.keys(b),
                {
                    shapeFlag: O
                } = F;
            x.length && O & 7 && (a && x.some(Sy) && (b = _M(b, a)), F = Eo(F, b))
        }
        return n.dirs && (F = Eo(F), F.dirs = F.dirs ? F.dirs.concat(n.dirs) : n.dirs), n.transition && (F.transition = n.transition), w = F, rd(I), w
    }
    const gM = t => {
            let e;
            for (const n in t)(n === "class" || n === "style" || kp(n)) && ((e || (e = {}))[n] = t[n]);
            return e
        },
        _M = (t, e) => {
            const n = {};
            for (const r in t)(!Sy(r) || !(r.slice(9) in e)) && (n[r] = t[r]);
            return n
        };

    function yM(t, e, n) {
        const {
            props: r,
            children: s,
            component: i
        } = t, {
            props: a,
            children: c,
            patchFlag: u
        } = e, h = i.emitsOptions;
        if (e.dirs || e.transition) return !0;
        if (n && u >= 0) {
            if (u & 1024) return !0;
            if (u & 16) return r ? KE(r, a, h) : !!a;
            if (u & 8) {
                const d = e.dynamicProps;
                for (let p = 0; p < d.length; p++) {
                    const m = d[p];
                    if (a[m] !== r[m] && !Dp(h, m)) return !0
                }
            }
        } else return (s || c) && (!c || !c.$stable) ? !0 : r === a ? !1 : r ? a ? KE(r, a, h) : !0 : !!a;
        return !1
    }

    function KE(t, e, n) {
        const r = Object.keys(e);
        if (r.length !== Object.keys(t).length) return !0;
        for (let s = 0; s < r.length; s++) {
            const i = r[s];
            if (e[i] !== t[i] && !Dp(n, i)) return !0
        }
        return !1
    }

    function vM({
        vnode: t,
        parent: e
    }, n) {
        for (; e && e.subTree === t;)(t = e.vnode).el = n, e = e.parent
    }
    const bM = t => t.__isSuspense;

    function EM(t, e) {
        e && e.pendingBranch ? qe(t) ? e.effects.push(...t) : e.effects.push(t) : dM(t)
    }
    const _f = {};

    function ma(t, e, n) {
        return R5(t, e, n)
    }

    function R5(t, e, {
        immediate: n,
        deep: r,
        flush: s,
        onTrack: i,
        onTrigger: a
    } = Jt) {
        var c;
        const u = IR() === ((c = Ln) == null ? void 0 : c.scope) ? Ln : null;
        let h, d = !1,
            p = !1;
        if (jn(t) ? (h = () => t.value, d = nd(t)) : gc(t) ? (h = () => t, r = !0) : qe(t) ? (p = !0, d = t.some(x => gc(x) || nd(x)), h = () => t.map(x => {
                if (jn(x)) return x.value;
                if (gc(x)) return ha(x);
                if (lt(x)) return po(x, u, 2)
            })) : lt(t) ? e ? h = () => po(t, u, 2) : h = () => {
                if (!(u && u.isUnmounted)) return m && m(), ts(t, u, 3, [_])
            } : h = Ts, e && r) {
            const x = h;
            h = () => ha(x())
        }
        let m, _ = x => {
                m = I.onStop = () => {
                    po(x, u, 4)
                }
            },
            y;
        if (mu)
            if (_ = Ts, e ? n && ts(e, u, 3, [h(), p ? [] : void 0, _]) : h(), s === "sync") {
                const x = pD();
                y = x.__watcherHandles || (x.__watcherHandles = [])
            } else return Ts;
        let v = p ? new Array(t.length).fill(_f) : _f;
        const w = () => {
            if (I.active)
                if (e) {
                    const x = I.run();
                    (r || d || (p ? x.some((O, M) => lu(O, v[M])) : lu(x, v))) && (m && m(), ts(e, u, 3, [x, v === _f ? void 0 : p && v[0] === _f ? [] : v, _]), v = x)
                } else I.run()
        };
        w.allowRecurse = !!e;
        let b;
        s === "sync" ? b = w : s === "post" ? b = () => Er(w, u && u.suspense) : (w.pre = !0, u && (w.id = u.uid), b = () => My(w));
        const I = new Cy(h, b);
        e ? n ? w() : v = I.run() : s === "post" ? Er(I.run.bind(I), u && u.suspense) : I.run();
        const F = () => {
            I.stop(), u && u.scope && wy(u.scope.effects, I)
        };
        return y && y.push(F), F
    }

    function TM(t, e, n) {
        const r = this.proxy,
            s = vn(t) ? t.includes(".") ? M5(r, t) : () => r[t] : t.bind(r, r);
        let i;
        lt(e) ? i = e : (i = e.handler, n = e);
        const a = Ln;
        Pc(this);
        const c = R5(s, i.bind(r), n);
        return a ? Pc(a) : ga(), c
    }

    function M5(t, e) {
        const n = e.split(".");
        return () => {
            let r = t;
            for (let s = 0; s < n.length && r; s++) r = r[n[s]];
            return r
        }
    }

    function ha(t, e) {
        if (!qt(t) || t.__v_skip || (e = e || new Set, e.has(t))) return t;
        if (e.add(t), jn(t)) ha(t.value, e);
        else if (qe(t))
            for (let n = 0; n < t.length; n++) ha(t[n], e);
        else if (Ip(t) || mc(t)) t.forEach(n => {
            ha(n, e)
        });
        else if (o5(t))
            for (const n in t) ha(t[n], e);
        return t
    }

    function Ke(t, e) {
        const n = Vn;
        if (n === null) return t;
        const r = qp(n) || n.proxy,
            s = t.dirs || (t.dirs = []);
        for (let i = 0; i < e.length; i++) {
            let [a, c, u, h = Jt] = e[i];
            a && (lt(a) && (a = {
                mounted: a,
                updated: a
            }), a.deep && ha(c), s.push({
                dir: a,
                instance: r,
                value: c,
                oldValue: void 0,
                arg: u,
                modifiers: h
            }))
        }
        return t
    }

    function Jo(t, e, n, r) {
        const s = t.dirs,
            i = e && e.dirs;
        for (let a = 0; a < s.length; a++) {
            const c = s[a];
            i && (c.oldValue = i[a].value);
            let u = c.dir[r];
            u && (Jc(), ts(u, n, 8, [t.el, c, t, e]), Qc())
        }
    }

    function SM() {
        const t = {
            isMounted: !1,
            isLeaving: !1,
            isUnmounting: !1,
            leavingVNodes: new Map
        };
        return Dy(() => {
            t.isMounted = !0
        }), B5(() => {
            t.isUnmounting = !0
        }), t
    }
    const Zr = [Function, Array],
        D5 = {
            mode: String,
            appear: Boolean,
            persisted: Boolean,
            onBeforeEnter: Zr,
            onEnter: Zr,
            onAfterEnter: Zr,
            onEnterCancelled: Zr,
            onBeforeLeave: Zr,
            onLeave: Zr,
            onAfterLeave: Zr,
            onLeaveCancelled: Zr,
            onBeforeAppear: Zr,
            onAppear: Zr,
            onAfterAppear: Zr,
            onAppearCancelled: Zr
        },
        wM = {
            name: "BaseTransition",
            props: D5,
            setup(t, {
                slots: e
            }) {
                const n = pu(),
                    r = SM();
                let s;
                return () => {
                    const i = e.default && L5(e.default(), !0);
                    if (!i || !i.length) return;
                    let a = i[0];
                    if (i.length > 1) {
                        for (const v of i)
                            if (v.type !== ns) {
                                a = v;
                                break
                            }
                    }
                    const c = kt(t),
                        {
                            mode: u
                        } = c;
                    if (r.isLeaving) return Jg(a);
                    const h = YE(a);
                    if (!h) return Jg(a);
                    const d = n1(h, c, r, n);
                    r1(h, d);
                    const p = n.subTree,
                        m = p && YE(p);
                    let _ = !1;
                    const {
                        getTransitionKey: y
                    } = h.type;
                    if (y) {
                        const v = y();
                        s === void 0 ? s = v : v !== s && (s = v, _ = !0)
                    }
                    if (m && m.type !== ns && (!ia(h, m) || _)) {
                        const v = n1(m, c, r, n);
                        if (r1(m, v), u === "out-in") return r.isLeaving = !0, v.afterLeave = () => {
                            r.isLeaving = !1, n.update.active !== !1 && n.update()
                        }, Jg(a);
                        u === "in-out" && h.type !== ns && (v.delayLeave = (w, b, I) => {
                            const F = $5(r, m);
                            F[String(m.key)] = m, w._leaveCb = () => {
                                b(), w._leaveCb = void 0, delete d.delayedLeave
                            }, d.delayedLeave = I
                        })
                    }
                    return a
                }
            }
        },
        OM = wM;

    function $5(t, e) {
        const {
            leavingVNodes: n
        } = t;
        let r = n.get(e.type);
        return r || (r = Object.create(null), n.set(e.type, r)), r
    }

    function n1(t, e, n, r) {
        const {
            appear: s,
            mode: i,
            persisted: a = !1,
            onBeforeEnter: c,
            onEnter: u,
            onAfterEnter: h,
            onEnterCancelled: d,
            onBeforeLeave: p,
            onLeave: m,
            onAfterLeave: _,
            onLeaveCancelled: y,
            onBeforeAppear: v,
            onAppear: w,
            onAfterAppear: b,
            onAppearCancelled: I
        } = e, F = String(t.key), x = $5(n, t), O = (j, ee) => {
            j && ts(j, r, 9, ee)
        }, M = (j, ee) => {
            const se = ee[1];
            O(j, ee), qe(j) ? j.every(oe => oe.length <= 1) && se() : j.length <= 1 && se()
        }, $ = {
            mode: i,
            persisted: a,
            beforeEnter(j) {
                let ee = c;
                if (!n.isMounted)
                    if (s) ee = v || c;
                    else return;
                j._leaveCb && j._leaveCb(!0);
                const se = x[F];
                se && ia(t, se) && se.el._leaveCb && se.el._leaveCb(), O(ee, [j])
            },
            enter(j) {
                let ee = u,
                    se = h,
                    oe = d;
                if (!n.isMounted)
                    if (s) ee = w || u, se = b || h, oe = I || d;
                    else return;
                let Z = !1;
                const de = j._enterCb = q => {
                    Z || (Z = !0, q ? O(oe, [j]) : O(se, [j]), $.delayedLeave && $.delayedLeave(), j._enterCb = void 0)
                };
                ee ? M(ee, [j, de]) : de()
            },
            leave(j, ee) {
                const se = String(t.key);
                if (j._enterCb && j._enterCb(!0), n.isUnmounting) return ee();
                O(p, [j]);
                let oe = !1;
                const Z = j._leaveCb = de => {
                    oe || (oe = !0, ee(), de ? O(y, [j]) : O(_, [j]), j._leaveCb = void 0, x[se] === t && delete x[se])
                };
                x[se] = t, m ? M(m, [j, Z]) : Z()
            },
            clone(j) {
                return n1(j, e, n, r)
            }
        };
        return $
    }

    function Jg(t) {
        if (Lp(t)) return t = Eo(t), t.children = null, t
    }

    function YE(t) {
        return Lp(t) ? t.children ? t.children[0] : void 0 : t
    }

    function r1(t, e) {
        t.shapeFlag & 6 && t.component ? r1(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e
    }

    function L5(t, e = !1, n) {
        let r = [],
            s = 0;
        for (let i = 0; i < t.length; i++) {
            let a = t[i];
            const c = n == null ? a.key : String(n) + String(a.key != null ? a.key : i);
            a.type === Tt ? (a.patchFlag & 128 && s++, r = r.concat(L5(a.children, e, c))) : (e || a.type !== ns) && r.push(c != null ? Eo(a, {
                key: c
            }) : a)
        }
        if (s > 1)
            for (let i = 0; i < r.length; i++) r[i].patchFlag = -2;
        return r
    }

    function mt(t, e) {
        return lt(t) ? (() => wn({
            name: t.name
        }, e, {
            setup: t
        }))() : t
    }
    const Kl = t => !!t.type.__asyncLoader,
        Lp = t => t.type.__isKeepAlive;

    function AM(t, e) {
        F5(t, "a", e)
    }

    function CM(t, e) {
        F5(t, "da", e)
    }

    function F5(t, e, n = Ln) {
        const r = t.__wdc || (t.__wdc = () => {
            let s = n;
            for (; s;) {
                if (s.isDeactivated) return;
                s = s.parent
            }
            return t()
        });
        if (Fp(e, r, n), n) {
            let s = n.parent;
            for (; s && s.parent;) Lp(s.parent.vnode) && kM(r, e, n, s), s = s.parent
        }
    }

    function kM(t, e, n, r) {
        const s = Fp(e, t, r, !0);
        $y(() => {
            wy(r[e], s)
        }, n)
    }

    function Fp(t, e, n = Ln, r = !1) {
        if (n) {
            const s = n[t] || (n[t] = []),
                i = e.__weh || (e.__weh = (...a) => {
                    if (n.isUnmounted) return;
                    Jc(), Pc(n);
                    const c = ts(e, n, t, a);
                    return ga(), Qc(), c
                });
            return r ? s.unshift(i) : s.push(i), i
        }
    }
    const $i = t => (e, n = Ln) => (!mu || t === "sp") && Fp(t, (...r) => e(...r), n),
        U5 = $i("bm"),
        Dy = $i("m"),
        IM = $i("bu"),
        NM = $i("u"),
        B5 = $i("bum"),
        $y = $i("um"),
        xM = $i("sp"),
        PM = $i("rtg"),
        RM = $i("rtc");

    function MM(t, e = Ln) {
        Fp("ec", t, e)
    }
    const Ly = "components",
        DM = "directives";

    function st(t, e) {
        return Uy(Ly, t, !0, e) || t
    }
    const q5 = Symbol.for("v-ndc");

    function Fy(t) {
        return vn(t) ? Uy(Ly, t, !1) || t : t || q5
    }

    function On(t) {
        return Uy(DM, t)
    }

    function Uy(t, e, n = !0, r = !1) {
        const s = Vn || Ln;
        if (s) {
            const i = s.type;
            if (t === Ly) {
                const c = hD(i, !1);
                if (c && (c === e || c === zs(e) || c === xp(zs(e)))) return i
            }
            const a = zE(s[t] || i[t], e) || zE(s.appContext[t], e);
            return !a && r ? i : a
        }
    }

    function zE(t, e) {
        return t && (t[e] || t[zs(e)] || t[xp(zs(e))])
    }

    function $n(t, e, n, r) {
        let s;
        const i = n && n[r];
        if (qe(t) || vn(t)) {
            s = new Array(t.length);
            for (let a = 0, c = t.length; a < c; a++) s[a] = e(t[a], a, void 0, i && i[a])
        } else if (typeof t == "number") {
            s = new Array(t);
            for (let a = 0; a < t; a++) s[a] = e(a + 1, a, void 0, i && i[a])
        } else if (qt(t))
            if (t[Symbol.iterator]) s = Array.from(t, (a, c) => e(a, c, void 0, i && i[c]));
            else {
                const a = Object.keys(t);
                s = new Array(a.length);
                for (let c = 0, u = a.length; c < u; c++) {
                    const h = a[c];
                    s[c] = e(t[h], h, c, i && i[c])
                }
            }
        else s = [];
        return n && (n[r] = s), s
    }

    function $M(t, e, n = {}, r, s) {
        if (Vn.isCE || Vn.parent && Kl(Vn.parent) && Vn.parent.isCE) return e !== "default" && (n.name = e), Je("slot", n, r && r());
        let i = t[e];
        i && i._c && (i._d = !1), G();
        const a = i && j5(i(n)),
            c = Ut(Tt, {
                key: n.key || a && a.key || `_${e}`
            }, a || (r ? r() : []), a && t._ === 1 ? 64 : -2);
        return !s && c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), i && i._c && (i._d = !0), c
    }

    function j5(t) {
        return t.some(e => od(e) ? !(e.type === ns || e.type === Tt && !j5(e.children)) : !0) ? t : null
    }
    const s1 = t => t ? e4(t) ? qp(t) || t.proxy : s1(t.parent) : null,
        Yl = wn(Object.create(null), {
            $: t => t,
            $el: t => t.vnode.el,
            $data: t => t.data,
            $props: t => t.props,
            $attrs: t => t.attrs,
            $slots: t => t.slots,
            $refs: t => t.refs,
            $parent: t => s1(t.parent),
            $root: t => s1(t.root),
            $emit: t => t.emit,
            $options: t => By(t),
            $forceUpdate: t => t.f || (t.f = () => My(t.update)),
            $nextTick: t => t.n || (t.n = uM.bind(t.proxy)),
            $watch: t => TM.bind(t)
        }),
        Qg = (t, e) => t !== Jt && !t.__isScriptSetup && At(t, e),
        LM = {
            get({
                _: t
            }, e) {
                const {
                    ctx: n,
                    setupState: r,
                    data: s,
                    props: i,
                    accessCache: a,
                    type: c,
                    appContext: u
                } = t;
                let h;
                if (e[0] !== "$") {
                    const _ = a[e];
                    if (_ !== void 0) switch (_) {
                        case 1:
                            return r[e];
                        case 2:
                            return s[e];
                        case 4:
                            return n[e];
                        case 3:
                            return i[e]
                    } else {
                        if (Qg(r, e)) return a[e] = 1, r[e];
                        if (s !== Jt && At(s, e)) return a[e] = 2, s[e];
                        if ((h = t.propsOptions[0]) && At(h, e)) return a[e] = 3, i[e];
                        if (n !== Jt && At(n, e)) return a[e] = 4, n[e];
                        i1 && (a[e] = 0)
                    }
                }
                const d = Yl[e];
                let p, m;
                if (d) return e === "$attrs" && Ar(t, "get", e), d(t);
                if ((p = c.__cssModules) && (p = p[e])) return p;
                if (n !== Jt && At(n, e)) return a[e] = 4, n[e];
                if (m = u.config.globalProperties, At(m, e)) return m[e]
            },
            set({
                _: t
            }, e, n) {
                const {
                    data: r,
                    setupState: s,
                    ctx: i
                } = t;
                return Qg(s, e) ? (s[e] = n, !0) : r !== Jt && At(r, e) ? (r[e] = n, !0) : At(t.props, e) || e[0] === "$" && e.slice(1) in t ? !1 : (i[e] = n, !0)
            },
            has({
                _: {
                    data: t,
                    setupState: e,
                    accessCache: n,
                    ctx: r,
                    appContext: s,
                    propsOptions: i
                }
            }, a) {
                let c;
                return !!n[a] || t !== Jt && At(t, a) || Qg(e, a) || (c = i[0]) && At(c, a) || At(r, a) || At(Yl, a) || At(s.config.globalProperties, a)
            },
            defineProperty(t, e, n) {
                return n.get != null ? t._.accessCache[e] = 0 : At(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n)
            }
        };

    function ZE(t) {
        return qe(t) ? t.reduce((e, n) => (e[n] = null, e), {}) : t
    }
    let i1 = !0;

    function FM(t) {
        const e = By(t),
            n = t.proxy,
            r = t.ctx;
        i1 = !1, e.beforeCreate && XE(e.beforeCreate, t, "bc");
        const {
            data: s,
            computed: i,
            methods: a,
            watch: c,
            provide: u,
            inject: h,
            created: d,
            beforeMount: p,
            mounted: m,
            beforeUpdate: _,
            updated: y,
            activated: v,
            deactivated: w,
            beforeDestroy: b,
            beforeUnmount: I,
            destroyed: F,
            unmounted: x,
            render: O,
            renderTracked: M,
            renderTriggered: $,
            errorCaptured: j,
            serverPrefetch: ee,
            expose: se,
            inheritAttrs: oe,
            components: Z,
            directives: de,
            filters: q
        } = e;
        if (h && UM(h, r, null), a)
            for (const he in a) {
                const ve = a[he];
                lt(ve) && (r[he] = ve.bind(n))
            }
        if (s) {
            const he = s.call(n, n);
            qt(he) && (t.data = Nc(he))
        }
        if (i1 = !0, i)
            for (const he in i) {
                const ve = i[he],
                    be = lt(ve) ? ve.bind(n, n) : lt(ve.get) ? ve.get.bind(n, n) : Ts,
                    Ae = !lt(ve) && lt(ve.set) ? ve.set.bind(n) : Ts,
                    we = Lr({
                        get: be,
                        set: Ae
                    });
                Object.defineProperty(r, he, {
                    enumerable: !0,
                    configurable: !0,
                    get: () => we.value,
                    set: Me => we.value = Me
                })
            }
        if (c)
            for (const he in c) V5(c[he], r, n, he);
        if (u) {
            const he = lt(u) ? u.call(n) : u;
            Reflect.ownKeys(he).forEach(ve => {
                WM(ve, he[ve])
            })
        }
        d && XE(d, t, "c");

        function ae(he, ve) {
            qe(ve) ? ve.forEach(be => he(be.bind(n))) : ve && he(ve.bind(n))
        }
        if (ae(U5, p), ae(Dy, m), ae(IM, _), ae(NM, y), ae(AM, v), ae(CM, w), ae(MM, j), ae(RM, M), ae(PM, $), ae(B5, I), ae($y, x), ae(xM, ee), qe(se))
            if (se.length) {
                const he = t.exposed || (t.exposed = {});
                se.forEach(ve => {
                    Object.defineProperty(he, ve, {
                        get: () => n[ve],
                        set: be => n[ve] = be
                    })
                })
            } else t.exposed || (t.exposed = {});
        O && t.render === Ts && (t.render = O), oe != null && (t.inheritAttrs = oe), Z && (t.components = Z), de && (t.directives = de)
    }

    function UM(t, e, n = Ts) {
        qe(t) && (t = o1(t));
        for (const r in t) {
            const s = t[r];
            let i;
            qt(s) ? "default" in s ? i = mo(s.from || r, s.default, !0) : i = mo(s.from || r) : i = mo(s), jn(i) ? Object.defineProperty(e, r, {
                enumerable: !0,
                configurable: !0,
                get: () => i.value,
                set: a => i.value = a
            }) : e[r] = i
        }
    }

    function XE(t, e, n) {
        ts(qe(t) ? t.map(r => r.bind(e.proxy)) : t.bind(e.proxy), e, n)
    }

    function V5(t, e, n, r) {
        const s = r.includes(".") ? M5(n, r) : () => n[r];
        if (vn(t)) {
            const i = e[t];
            lt(i) && ma(s, i)
        } else if (lt(t)) ma(s, t.bind(n));
        else if (qt(t))
            if (qe(t)) t.forEach(i => V5(i, e, n, r));
            else {
                const i = lt(t.handler) ? t.handler.bind(n) : e[t.handler];
                lt(i) && ma(s, i, t)
            }
    }

    function By(t) {
        const e = t.type,
            {
                mixins: n,
                extends: r
            } = e,
            {
                mixins: s,
                optionsCache: i,
                config: {
                    optionMergeStrategies: a
                }
            } = t.appContext,
            c = i.get(e);
        let u;
        return c ? u = c : !s.length && !n && !r ? u = e : (u = {}, s.length && s.forEach(h => sd(u, h, a, !0)), sd(u, e, a)), qt(e) && i.set(e, u), u
    }

    function sd(t, e, n, r = !1) {
        const {
            mixins: s,
            extends: i
        } = e;
        i && sd(t, i, n, !0), s && s.forEach(a => sd(t, a, n, !0));
        for (const a in e)
            if (!(r && a === "expose")) {
                const c = BM[a] || n && n[a];
                t[a] = c ? c(t[a], e[a]) : e[a]
            } return t
    }
    const BM = {
        data: JE,
        props: QE,
        emits: QE,
        methods: Gl,
        computed: Gl,
        beforeCreate: lr,
        created: lr,
        beforeMount: lr,
        mounted: lr,
        beforeUpdate: lr,
        updated: lr,
        beforeDestroy: lr,
        beforeUnmount: lr,
        destroyed: lr,
        unmounted: lr,
        activated: lr,
        deactivated: lr,
        errorCaptured: lr,
        serverPrefetch: lr,
        components: Gl,
        directives: Gl,
        watch: jM,
        provide: JE,
        inject: qM
    };

    function JE(t, e) {
        return e ? t ? function() {
            return wn(lt(t) ? t.call(this, this) : t, lt(e) ? e.call(this, this) : e)
        } : e : t
    }

    function qM(t, e) {
        return Gl(o1(t), o1(e))
    }

    function o1(t) {
        if (qe(t)) {
            const e = {};
            for (let n = 0; n < t.length; n++) e[t[n]] = t[n];
            return e
        }
        return t
    }

    function lr(t, e) {
        return t ? [...new Set([].concat(t, e))] : e
    }

    function Gl(t, e) {
        return t ? wn(Object.create(null), t, e) : e
    }

    function QE(t, e) {
        return t ? qe(t) && qe(e) ? [...new Set([...t, ...e])] : wn(Object.create(null), ZE(t), ZE(e ?? {})) : e
    }

    function jM(t, e) {
        if (!t) return e;
        if (!e) return t;
        const n = wn(Object.create(null), t);
        for (const r in e) n[r] = lr(t[r], e[r]);
        return n
    }

    function G5() {
        return {
            app: null,
            config: {
                isNativeTag: dR,
                performance: !1,
                globalProperties: {},
                optionMergeStrategies: {},
                errorHandler: void 0,
                warnHandler: void 0,
                compilerOptions: {}
            },
            mixins: [],
            components: {},
            directives: {},
            provides: Object.create(null),
            optionsCache: new WeakMap,
            propsCache: new WeakMap,
            emitsCache: new WeakMap
        }
    }
    let VM = 0;

    function GM(t, e) {
        return function(r, s = null) {
            lt(r) || (r = wn({}, r)), s != null && !qt(s) && (s = null);
            const i = G5(),
                a = new Set;
            let c = !1;
            const u = i.app = {
                _uid: VM++,
                _component: r,
                _props: s,
                _container: null,
                _context: i,
                _instance: null,
                version: mD,
                get config() {
                    return i.config
                },
                set config(h) {},
                use(h, ...d) {
                    return a.has(h) || (h && lt(h.install) ? (a.add(h), h.install(u, ...d)) : lt(h) && (a.add(h), h(u, ...d))), u
                },
                mixin(h) {
                    return i.mixins.includes(h) || i.mixins.push(h), u
                },
                component(h, d) {
                    return d ? (i.components[h] = d, u) : i.components[h]
                },
                directive(h, d) {
                    return d ? (i.directives[h] = d, u) : i.directives[h]
                },
                mount(h, d, p) {
                    if (!c) {
                        const m = Je(r, s);
                        return m.appContext = i, d && e ? e(m, h) : t(m, h, p), c = !0, u._container = h, h.__vue_app__ = u, qp(m.component) || m.component.proxy
                    }
                },
                unmount() {
                    c && (t(null, u._container), delete u._container.__vue_app__)
                },
                provide(h, d) {
                    return i.provides[h] = d, u
                },
                runWithContext(h) {
                    id = u;
                    try {
                        return h()
                    } finally {
                        id = null
                    }
                }
            };
            return u
        }
    }
    let id = null;

    function WM(t, e) {
        if (Ln) {
            let n = Ln.provides;
            const r = Ln.parent && Ln.parent.provides;
            r === n && (n = Ln.provides = Object.create(r)), n[t] = e
        }
    }

    function mo(t, e, n = !1) {
        const r = Ln || Vn;
        if (r || id) {
            const s = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : id._context.provides;
            if (s && t in s) return s[t];
            if (arguments.length > 1) return n && lt(e) ? e.call(r && r.proxy) : e
        }
    }

    function HM(t, e, n, r = !1) {
        const s = {},
            i = {};
        td(i, Up, 1), t.propsDefaults = Object.create(null), W5(t, e, s, i);
        for (const a in t.propsOptions[0]) a in s || (s[a] = void 0);
        n ? t.props = r ? s : nM(s) : t.type.props ? t.props = s : t.props = i, t.attrs = i
    }

    function KM(t, e, n, r) {
        const {
            props: s,
            attrs: i,
            vnode: {
                patchFlag: a
            }
        } = t, c = kt(s), [u] = t.propsOptions;
        let h = !1;
        if ((r || a > 0) && !(a & 16)) {
            if (a & 8) {
                const d = t.vnode.dynamicProps;
                for (let p = 0; p < d.length; p++) {
                    let m = d[p];
                    if (Dp(t.emitsOptions, m)) continue;
                    const _ = e[m];
                    if (u)
                        if (At(i, m)) _ !== i[m] && (i[m] = _, h = !0);
                        else {
                            const y = zs(m);
                            s[y] = a1(u, c, y, _, t, !1)
                        }
                    else _ !== i[m] && (i[m] = _, h = !0)
                }
            }
        } else {
            W5(t, e, s, i) && (h = !0);
            let d;
            for (const p in c)(!e || !At(e, p) && ((d = Ia(p)) === p || !At(e, d))) && (u ? n && (n[p] !== void 0 || n[d] !== void 0) && (s[p] = a1(u, c, p, void 0, t, !0)) : delete s[p]);
            if (i !== c)
                for (const p in i)(!e || !At(e, p)) && (delete i[p], h = !0)
        }
        h && xi(t, "set", "$attrs")
    }

    function W5(t, e, n, r) {
        const [s, i] = t.propsOptions;
        let a = !1,
            c;
        if (e)
            for (let u in e) {
                if (jf(u)) continue;
                const h = e[u];
                let d;
                s && At(s, d = zs(u)) ? !i || !i.includes(d) ? n[d] = h : (c || (c = {}))[d] = h : Dp(t.emitsOptions, u) || (!(u in r) || h !== r[u]) && (r[u] = h, a = !0)
            }
        if (i) {
            const u = kt(n),
                h = c || Jt;
            for (let d = 0; d < i.length; d++) {
                const p = i[d];
                n[p] = a1(s, u, p, h[p], t, !At(h, p))
            }
        }
        return a
    }

    function a1(t, e, n, r, s, i) {
        const a = t[n];
        if (a != null) {
            const c = At(a, "default");
            if (c && r === void 0) {
                const u = a.default;
                if (a.type !== Function && !a.skipFactory && lt(u)) {
                    const {
                        propsDefaults: h
                    } = s;
                    n in h ? r = h[n] : (Pc(s), r = h[n] = u.call(null, e), ga())
                } else r = u
            }
            a[0] && (i && !c ? r = !1 : a[1] && (r === "" || r === Ia(n)) && (r = !0))
        }
        return r
    }

    function H5(t, e, n = !1) {
        const r = e.propsCache,
            s = r.get(t);
        if (s) return s;
        const i = t.props,
            a = {},
            c = [];
        let u = !1;
        if (!lt(t)) {
            const d = p => {
                u = !0;
                const [m, _] = H5(p, e, !0);
                wn(a, m), _ && c.push(..._)
            };
            !n && e.mixins.length && e.mixins.forEach(d), t.extends && d(t.extends), t.mixins && t.mixins.forEach(d)
        }
        if (!i && !u) return qt(t) && r.set(t, pc), pc;
        if (qe(i))
            for (let d = 0; d < i.length; d++) {
                const p = zs(i[d]);
                eT(p) && (a[p] = Jt)
            } else if (i)
                for (const d in i) {
                    const p = zs(d);
                    if (eT(p)) {
                        const m = i[d],
                            _ = a[p] = qe(m) || lt(m) ? {
                                type: m
                            } : wn({}, m);
                        if (_) {
                            const y = rT(Boolean, _.type),
                                v = rT(String, _.type);
                            _[0] = y > -1, _[1] = v < 0 || y < v, (y > -1 || At(_, "default")) && c.push(p)
                        }
                    }
                }
        const h = [a, c];
        return qt(t) && r.set(t, h), h
    }

    function eT(t) {
        return t[0] !== "$"
    }

    function tT(t) {
        const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
        return e ? e[2] : t === null ? "null" : ""
    }

    function nT(t, e) {
        return tT(t) === tT(e)
    }

    function rT(t, e) {
        return qe(e) ? e.findIndex(n => nT(n, t)) : lt(e) && nT(e, t) ? 0 : -1
    }
    const K5 = t => t[0] === "_" || t === "$stable",
        qy = t => qe(t) ? t.map(Hs) : [Hs(t)],
        YM = (t, e, n) => {
            if (e._n) return e;
            const r = si((...s) => qy(e(...s)), n);
            return r._c = !1, r
        },
        Y5 = (t, e, n) => {
            const r = t._ctx;
            for (const s in t) {
                if (K5(s)) continue;
                const i = t[s];
                if (lt(i)) e[s] = YM(s, i, r);
                else if (i != null) {
                    const a = qy(i);
                    e[s] = () => a
                }
            }
        },
        z5 = (t, e) => {
            const n = qy(e);
            t.slots.default = () => n
        },
        zM = (t, e) => {
            if (t.vnode.shapeFlag & 32) {
                const n = e._;
                n ? (t.slots = kt(e), td(e, "_", n)) : Y5(e, t.slots = {})
            } else t.slots = {}, e && z5(t, e);
            td(t.slots, Up, 1)
        },
        ZM = (t, e, n) => {
            const {
                vnode: r,
                slots: s
            } = t;
            let i = !0,
                a = Jt;
            if (r.shapeFlag & 32) {
                const c = e._;
                c ? n && c === 1 ? i = !1 : (wn(s, e), !n && c === 1 && delete s._) : (i = !e.$stable, Y5(e, s)), a = e
            } else e && (z5(t, e), a = {
                default: 1
            });
            if (i)
                for (const c in s) !K5(c) && !(c in a) && delete s[c]
        };

    function c1(t, e, n, r, s = !1) {
        if (qe(t)) {
            t.forEach((m, _) => c1(m, e && (qe(e) ? e[_] : e), n, r, s));
            return
        }
        if (Kl(r) && !s) return;
        const i = r.shapeFlag & 4 ? qp(r.component) || r.component.proxy : r.el,
            a = s ? null : i,
            {
                i: c,
                r: u
            } = t,
            h = e && e.r,
            d = c.refs === Jt ? c.refs = {} : c.refs,
            p = c.setupState;
        if (h != null && h !== u && (vn(h) ? (d[h] = null, At(p, h) && (p[h] = null)) : jn(h) && (h.value = null)), lt(u)) po(u, c, 12, [a, d]);
        else {
            const m = vn(u),
                _ = jn(u);
            if (m || _) {
                const y = () => {
                    if (t.f) {
                        const v = m ? At(p, u) ? p[u] : d[u] : u.value;
                        s ? qe(v) && wy(v, i) : qe(v) ? v.includes(i) || v.push(i) : m ? (d[u] = [i], At(p, u) && (p[u] = d[u])) : (u.value = [i], t.k && (d[t.k] = u.value))
                    } else m ? (d[u] = a, At(p, u) && (p[u] = a)) : _ && (u.value = a, t.k && (d[t.k] = a))
                };
                a ? (y.id = -1, Er(y, n)) : y()
            }
        }
    }
    const Er = EM;

    function XM(t) {
        return JM(t)
    }

    function JM(t, e) {
        const n = Z_();
        n.__VUE__ = !0;
        const {
            insert: r,
            remove: s,
            patchProp: i,
            createElement: a,
            createText: c,
            createComment: u,
            setText: h,
            setElementText: d,
            parentNode: p,
            nextSibling: m,
            setScopeId: _ = Ts,
            insertStaticContent: y
        } = t, v = (U, T, S, N = null, V = null, te = null, re = !1, ue = null, pe = !!T.dynamicChildren) => {
            if (U === T) return;
            U && !ia(U, T) && (N = at(U), Me(U, V, te, !0), U = null), T.patchFlag === -2 && (pe = !1, T.dynamicChildren = null);
            const {
                type: ce,
                ref: J,
                shapeFlag: ne
            } = T;
            switch (ce) {
                case Hu:
                    w(U, T, S, N);
                    break;
                case ns:
                    b(U, T, S, N);
                    break;
                case Gf:
                    U == null && I(T, S, N, re);
                    break;
                case Tt:
                    Z(U, T, S, N, V, te, re, ue, pe);
                    break;
                default:
                    ne & 1 ? O(U, T, S, N, V, te, re, ue, pe) : ne & 6 ? de(U, T, S, N, V, te, re, ue, pe) : (ne & 64 || ne & 128) && ce.process(U, T, S, N, V, te, re, ue, pe, rt)
            }
            J != null && V && c1(J, U && U.ref, te, T || U, !T)
        }, w = (U, T, S, N) => {
            if (U == null) r(T.el = c(T.children), S, N);
            else {
                const V = T.el = U.el;
                T.children !== U.children && h(V, T.children)
            }
        }, b = (U, T, S, N) => {
            U == null ? r(T.el = u(T.children || ""), S, N) : T.el = U.el
        }, I = (U, T, S, N) => {
            [U.el, U.anchor] = y(U.children, T, S, N, U.el, U.anchor)
        }, F = ({
            el: U,
            anchor: T
        }, S, N) => {
            let V;
            for (; U && U !== T;) V = m(U), r(U, S, N), U = V;
            r(T, S, N)
        }, x = ({
            el: U,
            anchor: T
        }) => {
            let S;
            for (; U && U !== T;) S = m(U), s(U), U = S;
            s(T)
        }, O = (U, T, S, N, V, te, re, ue, pe) => {
            re = re || T.type === "svg", U == null ? M(T, S, N, V, te, re, ue, pe) : ee(U, T, V, te, re, ue, pe)
        }, M = (U, T, S, N, V, te, re, ue) => {
            let pe, ce;
            const {
                type: J,
                props: ne,
                shapeFlag: Ne,
                transition: Pe,
                dirs: ze
            } = U;
            if (pe = U.el = a(U.type, te, ne && ne.is, ne), Ne & 8 ? d(pe, U.children) : Ne & 16 && j(U.children, pe, null, N, V, te && J !== "foreignObject", re, ue), ze && Jo(U, null, N, "created"), $(pe, U, U.scopeId, re, N), ne) {
                for (const D in ne) D !== "value" && !jf(D) && i(pe, D, null, ne[D], te, U.children, N, V, Ye);
                "value" in ne && i(pe, "value", null, ne.value), (ce = ne.onVnodeBeforeMount) && qs(ce, N, U)
            }
            ze && Jo(U, null, N, "beforeMount");
            const ft = (!V || V && !V.pendingBranch) && Pe && !Pe.persisted;
            ft && Pe.beforeEnter(pe), r(pe, T, S), ((ce = ne && ne.onVnodeMounted) || ft || ze) && Er(() => {
                ce && qs(ce, N, U), ft && Pe.enter(pe), ze && Jo(U, null, N, "mounted")
            }, V)
        }, $ = (U, T, S, N, V) => {
            if (S && _(U, S), N)
                for (let te = 0; te < N.length; te++) _(U, N[te]);
            if (V) {
                let te = V.subTree;
                if (T === te) {
                    const re = V.vnode;
                    $(U, re, re.scopeId, re.slotScopeIds, V.parent)
                }
            }
        }, j = (U, T, S, N, V, te, re, ue, pe = 0) => {
            for (let ce = pe; ce < U.length; ce++) {
                const J = U[ce] = ue ? so(U[ce]) : Hs(U[ce]);
                v(null, J, T, S, N, V, te, re, ue)
            }
        }, ee = (U, T, S, N, V, te, re) => {
            const ue = T.el = U.el;
            let {
                patchFlag: pe,
                dynamicChildren: ce,
                dirs: J
            } = T;
            pe |= U.patchFlag & 16;
            const ne = U.props || Jt,
                Ne = T.props || Jt;
            let Pe;
            S && Qo(S, !1), (Pe = Ne.onVnodeBeforeUpdate) && qs(Pe, S, T, U), J && Jo(T, U, S, "beforeUpdate"), S && Qo(S, !0);
            const ze = V && T.type !== "foreignObject";
            if (ce ? se(U.dynamicChildren, ce, ue, S, N, ze, te) : re || ve(U, T, ue, null, S, N, ze, te, !1), pe > 0) {
                if (pe & 16) oe(ue, T, ne, Ne, S, N, V);
                else if (pe & 2 && ne.class !== Ne.class && i(ue, "class", null, Ne.class, V), pe & 4 && i(ue, "style", ne.style, Ne.style, V), pe & 8) {
                    const ft = T.dynamicProps;
                    for (let D = 0; D < ft.length; D++) {
                        const P = ft[D],
                            z = ne[P],
                            R = Ne[P];
                        (R !== z || P === "value") && i(ue, P, z, R, V, U.children, S, N, Ye)
                    }
                }
                pe & 1 && U.children !== T.children && d(ue, T.children)
            } else !re && ce == null && oe(ue, T, ne, Ne, S, N, V);
            ((Pe = Ne.onVnodeUpdated) || J) && Er(() => {
                Pe && qs(Pe, S, T, U), J && Jo(T, U, S, "updated")
            }, N)
        }, se = (U, T, S, N, V, te, re) => {
            for (let ue = 0; ue < T.length; ue++) {
                const pe = U[ue],
                    ce = T[ue],
                    J = pe.el && (pe.type === Tt || !ia(pe, ce) || pe.shapeFlag & 70) ? p(pe.el) : S;
                v(pe, ce, J, null, N, V, te, re, !0)
            }
        }, oe = (U, T, S, N, V, te, re) => {
            if (S !== N) {
                if (S !== Jt)
                    for (const ue in S) !jf(ue) && !(ue in N) && i(U, ue, S[ue], null, re, T.children, V, te, Ye);
                for (const ue in N) {
                    if (jf(ue)) continue;
                    const pe = N[ue],
                        ce = S[ue];
                    pe !== ce && ue !== "value" && i(U, ue, ce, pe, re, T.children, V, te, Ye)
                }
                "value" in N && i(U, "value", S.value, N.value)
            }
        }, Z = (U, T, S, N, V, te, re, ue, pe) => {
            const ce = T.el = U ? U.el : c(""),
                J = T.anchor = U ? U.anchor : c("");
            let {
                patchFlag: ne,
                dynamicChildren: Ne,
                slotScopeIds: Pe
            } = T;
            Pe && (ue = ue ? ue.concat(Pe) : Pe), U == null ? (r(ce, S, N), r(J, S, N), j(T.children, S, J, V, te, re, ue, pe)) : ne > 0 && ne & 64 && Ne && U.dynamicChildren ? (se(U.dynamicChildren, Ne, S, V, te, re, ue), (T.key != null || V && T === V.subTree) && Z5(U, T, !0)) : ve(U, T, S, J, V, te, re, ue, pe)
        }, de = (U, T, S, N, V, te, re, ue, pe) => {
            T.slotScopeIds = ue, U == null ? T.shapeFlag & 512 ? V.ctx.activate(T, S, N, re, pe) : q(T, S, N, V, te, re, pe) : ie(U, T, pe)
        }, q = (U, T, S, N, V, te, re) => {
            const ue = U.component = oD(U, N, V);
            if (Lp(U) && (ue.ctx.renderer = rt), aD(ue), ue.asyncDep) {
                if (V && V.registerDep(ue, ae), !U.el) {
                    const pe = ue.subTree = Je(ns);
                    b(null, pe, T, S)
                }
                return
            }
            ae(ue, U, T, S, V, te, re)
        }, ie = (U, T, S) => {
            const N = T.component = U.component;
            if (yM(U, T, S))
                if (N.asyncDep && !N.asyncResolved) {
                    he(N, T, S);
                    return
                } else N.next = T, fM(N.update), N.update();
            else T.el = U.el, N.vnode = T
        }, ae = (U, T, S, N, V, te, re) => {
            const ue = () => {
                    if (U.isMounted) {
                        let {
                            next: J,
                            bu: ne,
                            u: Ne,
                            parent: Pe,
                            vnode: ze
                        } = U, ft = J, D;
                        Qo(U, !1), J ? (J.el = ze.el, he(U, J, re)) : J = ze, ne && Vf(ne), (D = J.props && J.props.onVnodeBeforeUpdate) && qs(D, Pe, J, ze), Qo(U, !0);
                        const P = Xg(U),
                            z = U.subTree;
                        U.subTree = P, v(z, P, p(z.el), at(z), U, V, te), J.el = P.el, ft === null && vM(U, P.el), Ne && Er(Ne, V), (D = J.props && J.props.onVnodeUpdated) && Er(() => qs(D, Pe, J, ze), V)
                    } else {
                        let J;
                        const {
                            el: ne,
                            props: Ne
                        } = T, {
                            bm: Pe,
                            m: ze,
                            parent: ft
                        } = U, D = Kl(T);
                        if (Qo(U, !1), Pe && Vf(Pe), !D && (J = Ne && Ne.onVnodeBeforeMount) && qs(J, ft, T), Qo(U, !0), ne && zt) {
                            const P = () => {
                                U.subTree = Xg(U), zt(ne, U.subTree, U, V, null)
                            };
                            D ? T.type.__asyncLoader().then(() => !U.isUnmounted && P()) : P()
                        } else {
                            const P = U.subTree = Xg(U);
                            v(null, P, S, N, U, V, te), T.el = P.el
                        }
                        if (ze && Er(ze, V), !D && (J = Ne && Ne.onVnodeMounted)) {
                            const P = T;
                            Er(() => qs(J, ft, P), V)
                        }(T.shapeFlag & 256 || ft && Kl(ft.vnode) && ft.vnode.shapeFlag & 256) && U.a && Er(U.a, V), U.isMounted = !0, T = S = N = null
                    }
                },
                pe = U.effect = new Cy(ue, () => My(ce), U.scope),
                ce = U.update = () => pe.run();
            ce.id = U.uid, Qo(U, !0), ce()
        }, he = (U, T, S) => {
            T.component = U;
            const N = U.vnode.props;
            U.vnode = T, U.next = null, KM(U, T.props, N, S), ZM(U, T.children, S), Jc(), HE(), Qc()
        }, ve = (U, T, S, N, V, te, re, ue, pe = !1) => {
            const ce = U && U.children,
                J = U ? U.shapeFlag : 0,
                ne = T.children,
                {
                    patchFlag: Ne,
                    shapeFlag: Pe
                } = T;
            if (Ne > 0) {
                if (Ne & 128) {
                    Ae(ce, ne, S, N, V, te, re, ue, pe);
                    return
                } else if (Ne & 256) {
                    be(ce, ne, S, N, V, te, re, ue, pe);
                    return
                }
            }
            Pe & 8 ? (J & 16 && Ye(ce, V, te), ne !== ce && d(S, ne)) : J & 16 ? Pe & 16 ? Ae(ce, ne, S, N, V, te, re, ue, pe) : Ye(ce, V, te, !0) : (J & 8 && d(S, ""), Pe & 16 && j(ne, S, N, V, te, re, ue, pe))
        }, be = (U, T, S, N, V, te, re, ue, pe) => {
            U = U || pc, T = T || pc;
            const ce = U.length,
                J = T.length,
                ne = Math.min(ce, J);
            let Ne;
            for (Ne = 0; Ne < ne; Ne++) {
                const Pe = T[Ne] = pe ? so(T[Ne]) : Hs(T[Ne]);
                v(U[Ne], Pe, S, null, V, te, re, ue, pe)
            }
            ce > J ? Ye(U, V, te, !0, !1, ne) : j(T, S, N, V, te, re, ue, pe, ne)
        }, Ae = (U, T, S, N, V, te, re, ue, pe) => {
            let ce = 0;
            const J = T.length;
            let ne = U.length - 1,
                Ne = J - 1;
            for (; ce <= ne && ce <= Ne;) {
                const Pe = U[ce],
                    ze = T[ce] = pe ? so(T[ce]) : Hs(T[ce]);
                if (ia(Pe, ze)) v(Pe, ze, S, null, V, te, re, ue, pe);
                else break;
                ce++
            }
            for (; ce <= ne && ce <= Ne;) {
                const Pe = U[ne],
                    ze = T[Ne] = pe ? so(T[Ne]) : Hs(T[Ne]);
                if (ia(Pe, ze)) v(Pe, ze, S, null, V, te, re, ue, pe);
                else break;
                ne--, Ne--
            }
            if (ce > ne) {
                if (ce <= Ne) {
                    const Pe = Ne + 1,
                        ze = Pe < J ? T[Pe].el : N;
                    for (; ce <= Ne;) v(null, T[ce] = pe ? so(T[ce]) : Hs(T[ce]), S, ze, V, te, re, ue, pe), ce++
                }
            } else if (ce > Ne)
                for (; ce <= ne;) Me(U[ce], V, te, !0), ce++;
            else {
                const Pe = ce,
                    ze = ce,
                    ft = new Map;
                for (ce = ze; ce <= Ne; ce++) {
                    const Ce = T[ce] = pe ? so(T[ce]) : Hs(T[ce]);
                    Ce.key != null && ft.set(Ce.key, ce)
                }
                let D, P = 0;
                const z = Ne - ze + 1;
                let R = !1,
                    K = 0;
                const me = new Array(z);
                for (ce = 0; ce < z; ce++) me[ce] = 0;
                for (ce = Pe; ce <= ne; ce++) {
                    const Ce = U[ce];
                    if (P >= z) {
                        Me(Ce, V, te, !0);
                        continue
                    }
                    let De;
                    if (Ce.key != null) De = ft.get(Ce.key);
                    else
                        for (D = ze; D <= Ne; D++)
                            if (me[D - ze] === 0 && ia(Ce, T[D])) {
                                De = D;
                                break
                            } De === void 0 ? Me(Ce, V, te, !0) : (me[De - ze] = ce + 1, De >= K ? K = De : R = !0, v(Ce, T[De], S, null, V, te, re, ue, pe), P++)
                }
                const Ee = R ? QM(me) : pc;
                for (D = Ee.length - 1, ce = z - 1; ce >= 0; ce--) {
                    const Ce = ze + ce,
                        De = T[Ce],
                        hn = Ce + 1 < J ? T[Ce + 1].el : N;
                    me[ce] === 0 ? v(null, De, S, hn, V, te, re, ue, pe) : R && (D < 0 || ce !== Ee[D] ? we(De, S, hn, 2) : D--)
                }
            }
        }, we = (U, T, S, N, V = null) => {
            const {
                el: te,
                type: re,
                transition: ue,
                children: pe,
                shapeFlag: ce
            } = U;
            if (ce & 6) {
                we(U.component.subTree, T, S, N);
                return
            }
            if (ce & 128) {
                U.suspense.move(T, S, N);
                return
            }
            if (ce & 64) {
                re.move(U, T, S, rt);
                return
            }
            if (re === Tt) {
                r(te, T, S);
                for (let ne = 0; ne < pe.length; ne++) we(pe[ne], T, S, N);
                r(U.anchor, T, S);
                return
            }
            if (re === Gf) {
                F(U, T, S);
                return
            }
            if (N !== 2 && ce & 1 && ue)
                if (N === 0) ue.beforeEnter(te), r(te, T, S), Er(() => ue.enter(te), V);
                else {
                    const {
                        leave: ne,
                        delayLeave: Ne,
                        afterLeave: Pe
                    } = ue, ze = () => r(te, T, S), ft = () => {
                        ne(te, () => {
                            ze(), Pe && Pe()
                        })
                    };
                    Ne ? Ne(te, ze, ft) : ft()
                }
            else r(te, T, S)
        }, Me = (U, T, S, N = !1, V = !1) => {
            const {
                type: te,
                props: re,
                ref: ue,
                children: pe,
                dynamicChildren: ce,
                shapeFlag: J,
                patchFlag: ne,
                dirs: Ne
            } = U;
            if (ue != null && c1(ue, null, S, U, !0), J & 256) {
                T.ctx.deactivate(U);
                return
            }
            const Pe = J & 1 && Ne,
                ze = !Kl(U);
            let ft;
            if (ze && (ft = re && re.onVnodeBeforeUnmount) && qs(ft, T, U), J & 6) Ue(U.component, S, N);
            else {
                if (J & 128) {
                    U.suspense.unmount(S, N);
                    return
                }
                Pe && Jo(U, null, T, "beforeUnmount"), J & 64 ? U.type.remove(U, T, S, V, rt, N) : ce && (te !== Tt || ne > 0 && ne & 64) ? Ye(ce, T, S, !1, !0) : (te === Tt && ne & 384 || !V && J & 16) && Ye(pe, T, S), N && Nt(U)
            }(ze && (ft = re && re.onVnodeUnmounted) || Pe) && Er(() => {
                ft && qs(ft, T, U), Pe && Jo(U, null, T, "unmounted")
            }, S)
        }, Nt = U => {
            const {
                type: T,
                el: S,
                anchor: N,
                transition: V
            } = U;
            if (T === Tt) {
                jt(S, N);
                return
            }
            if (T === Gf) {
                x(U);
                return
            }
            const te = () => {
                s(S), V && !V.persisted && V.afterLeave && V.afterLeave()
            };
            if (U.shapeFlag & 1 && V && !V.persisted) {
                const {
                    leave: re,
                    delayLeave: ue
                } = V, pe = () => re(S, te);
                ue ? ue(U.el, te, pe) : pe()
            } else te()
        }, jt = (U, T) => {
            let S;
            for (; U !== T;) S = m(U), s(U), U = S;
            s(T)
        }, Ue = (U, T, S) => {
            const {
                bum: N,
                scope: V,
                update: te,
                subTree: re,
                um: ue
            } = U;
            N && Vf(N), V.stop(), te && (te.active = !1, Me(re, U, T, S)), ue && Er(ue, T), Er(() => {
                U.isUnmounted = !0
            }, T), T && T.pendingBranch && !T.isUnmounted && U.asyncDep && !U.asyncResolved && U.suspenseId === T.pendingId && (T.deps--, T.deps === 0 && T.resolve())
        }, Ye = (U, T, S, N = !1, V = !1, te = 0) => {
            for (let re = te; re < U.length; re++) Me(U[re], T, S, N, V)
        }, at = U => U.shapeFlag & 6 ? at(U.component.subTree) : U.shapeFlag & 128 ? U.suspense.next() : m(U.anchor || U.el), ke = (U, T, S) => {
            U == null ? T._vnode && Me(T._vnode, null, null, !0) : v(T._vnode || null, U, T, null, null, null, S), HE(), N5(), T._vnode = U
        }, rt = {
            p: v,
            um: Me,
            m: we,
            r: Nt,
            mt: q,
            mc: j,
            pc: ve,
            pbc: se,
            n: at,
            o: t
        };
        let Yt, zt;
        return e && ([Yt, zt] = e(rt)), {
            render: ke,
            hydrate: Yt,
            createApp: GM(ke, Yt)
        }
    }

    function Qo({
        effect: t,
        update: e
    }, n) {
        t.allowRecurse = e.allowRecurse = n
    }

    function Z5(t, e, n = !1) {
        const r = t.children,
            s = e.children;
        if (qe(r) && qe(s))
            for (let i = 0; i < r.length; i++) {
                const a = r[i];
                let c = s[i];
                c.shapeFlag & 1 && !c.dynamicChildren && ((c.patchFlag <= 0 || c.patchFlag === 32) && (c = s[i] = so(s[i]), c.el = a.el), n || Z5(a, c)), c.type === Hu && (c.el = a.el)
            }
    }

    function QM(t) {
        const e = t.slice(),
            n = [0];
        let r, s, i, a, c;
        const u = t.length;
        for (r = 0; r < u; r++) {
            const h = t[r];
            if (h !== 0) {
                if (s = n[n.length - 1], t[s] < h) {
                    e[r] = s, n.push(r);
                    continue
                }
                for (i = 0, a = n.length - 1; i < a;) c = i + a >> 1, t[n[c]] < h ? i = c + 1 : a = c;
                h < t[n[i]] && (i > 0 && (e[r] = n[i - 1]), n[i] = r)
            }
        }
        for (i = n.length, a = n[i - 1]; i-- > 0;) n[i] = a, a = e[a];
        return n
    }
    const eD = t => t.__isTeleport,
        Tt = Symbol.for("v-fgt"),
        Hu = Symbol.for("v-txt"),
        ns = Symbol.for("v-cmt"),
        Gf = Symbol.for("v-stc"),
        zl = [];
    let bs = null;

    function G(t = !1) {
        zl.push(bs = t ? null : [])
    }

    function tD() {
        zl.pop(), bs = zl[zl.length - 1] || null
    }
    let du = 1;

    function sT(t) {
        du += t
    }

    function X5(t) {
        return t.dynamicChildren = du > 0 ? bs || pc : null, tD(), du > 0 && bs && bs.push(t), t
    }

    function H(t, e, n, r, s, i) {
        return X5(B(t, e, n, r, s, i, !0))
    }

    function Ut(t, e, n, r, s) {
        return X5(Je(t, e, n, r, s, !0))
    }

    function od(t) {
        return t ? t.__v_isVNode === !0 : !1
    }

    function ia(t, e) {
        return t.type === e.type && t.key === e.key
    }
    const Up = "__vInternal",
        J5 = ({
            key: t
        }) => t ?? null,
        Wf = ({
            ref: t,
            ref_key: e,
            ref_for: n
        }) => (typeof t == "number" && (t = "" + t), t != null ? vn(t) || jn(t) || lt(t) ? {
            i: Vn,
            r: t,
            k: e,
            f: !!n
        } : t : null);

    function B(t, e = null, n = null, r = 0, s = null, i = t === Tt ? 0 : 1, a = !1, c = !1) {
        const u = {
            __v_isVNode: !0,
            __v_skip: !0,
            type: t,
            props: e,
            key: e && J5(e),
            ref: e && Wf(e),
            scopeId: $p,
            slotScopeIds: null,
            children: n,
            component: null,
            suspense: null,
            ssContent: null,
            ssFallback: null,
            dirs: null,
            transition: null,
            el: null,
            anchor: null,
            target: null,
            targetAnchor: null,
            staticCount: 0,
            shapeFlag: i,
            patchFlag: r,
            dynamicProps: s,
            dynamicChildren: null,
            appContext: null,
            ctx: Vn
        };
        return c ? (jy(u, n), i & 128 && t.normalize(u)) : n && (u.shapeFlag |= vn(n) ? 8 : 16), du > 0 && !a && bs && (u.patchFlag > 0 || i & 6) && u.patchFlag !== 32 && bs.push(u), u
    }
    const Je = nD;

    function nD(t, e = null, n = null, r = 0, s = null, i = !1) {
        if ((!t || t === q5) && (t = ns), od(t)) {
            const c = Eo(t, e, !0);
            return n && jy(c, n), du > 0 && !i && bs && (c.shapeFlag & 6 ? bs[bs.indexOf(t)] = c : bs.push(c)), c.patchFlag |= -2, c
        }
        if (fD(t) && (t = t.__vccOpts), e) {
            e = rD(e);
            let {
                class: c,
                style: u
            } = e;
            c && !vn(c) && (e.class = Xe(c)), qt(u) && (T5(u) && !qe(u) && (u = wn({}, u)), e.style = Tn(u))
        }
        const a = vn(t) ? 1 : bM(t) ? 128 : eD(t) ? 64 : qt(t) ? 4 : lt(t) ? 2 : 0;
        return B(t, e, n, r, s, a, i, !0)
    }

    function rD(t) {
        return t ? T5(t) || Up in t ? wn({}, t) : t : null
    }

    function Eo(t, e, n = !1) {
        const {
            props: r,
            ref: s,
            patchFlag: i,
            children: a
        } = t, c = e ? Bp(r || {}, e) : r;
        return {
            __v_isVNode: !0,
            __v_skip: !0,
            type: t.type,
            props: c,
            key: c && J5(c),
            ref: e && e.ref ? n && s ? qe(s) ? s.concat(Wf(e)) : [s, Wf(e)] : Wf(e) : s,
            scopeId: t.scopeId,
            slotScopeIds: t.slotScopeIds,
            children: a,
            target: t.target,
            targetAnchor: t.targetAnchor,
            staticCount: t.staticCount,
            shapeFlag: t.shapeFlag,
            patchFlag: e && t.type !== Tt ? i === -1 ? 16 : i | 16 : i,
            dynamicProps: t.dynamicProps,
            dynamicChildren: t.dynamicChildren,
            appContext: t.appContext,
            dirs: t.dirs,
            transition: t.transition,
            component: t.component,
            suspense: t.suspense,
            ssContent: t.ssContent && Eo(t.ssContent),
            ssFallback: t.ssFallback && Eo(t.ssFallback),
            el: t.el,
            anchor: t.anchor,
            ctx: t.ctx,
            ce: t.ce
        }
    }

    function Nn(t = " ", e = 0) {
        return Je(Hu, null, t, e)
    }

    function Q5(t, e) {
        const n = Je(Gf, null, t);
        return n.staticCount = e, n
    }

    function Be(t = "", e = !1) {
        return e ? (G(), Ut(ns, null, t)) : Je(ns, null, t)
    }

    function Hs(t) {
        return t == null || typeof t == "boolean" ? Je(ns) : qe(t) ? Je(Tt, null, t.slice()) : typeof t == "object" ? so(t) : Je(Hu, null, String(t))
    }

    function so(t) {
        return t.el === null && t.patchFlag !== -1 || t.memo ? t : Eo(t)
    }

    function jy(t, e) {
        let n = 0;
        const {
            shapeFlag: r
        } = t;
        if (e == null) e = null;
        else if (qe(e)) n = 16;
        else if (typeof e == "object")
            if (r & 65) {
                const s = e.default;
                s && (s._c && (s._d = !1), jy(t, s()), s._c && (s._d = !0));
                return
            } else {
                n = 32;
                const s = e._;
                !s && !(Up in e) ? e._ctx = Vn : s === 3 && Vn && (Vn.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024))
            }
        else lt(e) ? (e = {
            default: e,
            _ctx: Vn
        }, n = 32) : (e = String(e), r & 64 ? (n = 16, e = [Nn(e)]) : n = 8);
        t.children = e, t.shapeFlag |= n
    }

    function Bp(...t) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const r = t[n];
            for (const s in r)
                if (s === "class") e.class !== r.class && (e.class = Xe([e.class, r.class]));
                else if (s === "style") e.style = Tn([e.style, r.style]);
            else if (kp(s)) {
                const i = e[s],
                    a = r[s];
                a && i !== a && !(qe(i) && i.includes(a)) && (e[s] = i ? [].concat(i, a) : a)
            } else s !== "" && (e[s] = r[s])
        }
        return e
    }

    function qs(t, e, n, r = null) {
        ts(t, e, 7, [n, r])
    }
    const sD = G5();
    let iD = 0;

    function oD(t, e, n) {
        const r = t.type,
            s = (e ? e.appContext : t.appContext) || sD,
            i = {
                uid: iD++,
                vnode: t,
                type: r,
                parent: e,
                appContext: s,
                root: null,
                next: null,
                subTree: null,
                effect: null,
                update: null,
                scope: new u5(!0),
                render: null,
                proxy: null,
                exposed: null,
                exposeProxy: null,
                withProxy: null,
                provides: e ? e.provides : Object.create(s.provides),
                accessCache: null,
                renderCache: [],
                components: null,
                directives: null,
                propsOptions: H5(r, s),
                emitsOptions: P5(r, s),
                emit: null,
                emitted: null,
                propsDefaults: Jt,
                inheritAttrs: r.inheritAttrs,
                ctx: Jt,
                data: Jt,
                props: Jt,
                attrs: Jt,
                slots: Jt,
                refs: Jt,
                setupState: Jt,
                setupContext: null,
                attrsProxy: null,
                slotsProxy: null,
                suspense: n,
                suspenseId: n ? n.pendingId : 0,
                asyncDep: null,
                asyncResolved: !1,
                isMounted: !1,
                isUnmounted: !1,
                isDeactivated: !1,
                bc: null,
                c: null,
                bm: null,
                m: null,
                bu: null,
                u: null,
                um: null,
                bum: null,
                da: null,
                a: null,
                rtg: null,
                rtc: null,
                ec: null,
                sp: null
            };
        return i.ctx = {
            _: i
        }, i.root = e ? e.root : i, i.emit = mM.bind(null, i), t.ce && t.ce(i), i
    }
    let Ln = null;
    const pu = () => Ln || Vn;
    let Vy, Ja, iT = "__VUE_INSTANCE_SETTERS__";
    (Ja = Z_()[iT]) || (Ja = Z_()[iT] = []), Ja.push(t => Ln = t), Vy = t => {
        Ja.length > 1 ? Ja.forEach(e => e(t)) : Ja[0](t)
    };
    const Pc = t => {
            Vy(t), t.scope.on()
        },
        ga = () => {
            Ln && Ln.scope.off(), Vy(null)
        };

    function e4(t) {
        return t.vnode.shapeFlag & 4
    }
    let mu = !1;

    function aD(t, e = !1) {
        mu = e;
        const {
            props: n,
            children: r
        } = t.vnode, s = e4(t);
        HM(t, n, s, e), zM(t, r);
        const i = s ? cD(t, e) : void 0;
        return mu = !1, i
    }

    function cD(t, e) {
        const n = t.type;
        t.accessCache = Object.create(null), t.proxy = S5(new Proxy(t.ctx, LM));
        const {
            setup: r
        } = n;
        if (r) {
            const s = t.setupContext = r.length > 1 ? uD(t) : null;
            Pc(t), Jc();
            const i = po(r, t, 0, [t.props, s]);
            if (Qc(), ga(), s5(i)) {
                if (i.then(ga, ga), e) return i.then(a => {
                    oT(t, a, e)
                }).catch(a => {
                    Mp(a, t, 0)
                });
                t.asyncDep = i
            } else oT(t, i, e)
        } else t4(t, e)
    }

    function oT(t, e, n) {
        lt(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : qt(e) && (t.setupState = C5(e)), t4(t, n)
    }
    let aT;

    function t4(t, e, n) {
        const r = t.type;
        if (!t.render) {
            if (!e && aT && !r.render) {
                const s = r.template || By(t).template;
                if (s) {
                    const {
                        isCustomElement: i,
                        compilerOptions: a
                    } = t.appContext.config, {
                        delimiters: c,
                        compilerOptions: u
                    } = r, h = wn(wn({
                        isCustomElement: i,
                        delimiters: c
                    }, a), u);
                    r.render = aT(s, h)
                }
            }
            t.render = r.render || Ts
        }
        Pc(t), Jc(), FM(t), Qc(), ga()
    }

    function lD(t) {
        return t.attrsProxy || (t.attrsProxy = new Proxy(t.attrs, {
            get(e, n) {
                return Ar(t, "get", "$attrs"), e[n]
            }
        }))
    }

    function uD(t) {
        const e = n => {
            t.exposed = n || {}
        };
        return {
            get attrs() {
                return lD(t)
            },
            slots: t.slots,
            emit: t.emit,
            expose: e
        }
    }

    function qp(t) {
        if (t.exposed) return t.exposeProxy || (t.exposeProxy = new Proxy(C5(S5(t.exposed)), {
            get(e, n) {
                if (n in e) return e[n];
                if (n in Yl) return Yl[n](t)
            },
            has(e, n) {
                return n in e || n in Yl
            }
        }))
    }

    function hD(t, e = !0) {
        return lt(t) ? t.displayName || t.name : t.name || e && t.__name
    }

    function fD(t) {
        return lt(t) && "__vccOpts" in t
    }
    const Lr = (t, e) => cM(t, e, mu);

    function Gy(t, e, n) {
        const r = arguments.length;
        return r === 2 ? qt(e) && !qe(e) ? od(e) ? Je(t, null, [e]) : Je(t, e) : Je(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && od(n) && (n = [n]), Je(t, e, n))
    }
    const dD = Symbol.for("v-scx"),
        pD = () => mo(dD),
        mD = "3.3.4",
        gD = "http://www.w3.org/2000/svg",
        oa = typeof document < "u" ? document : null,
        cT = oa && oa.createElement("template"),
        _D = {
            insert: (t, e, n) => {
                e.insertBefore(t, n || null)
            },
            remove: t => {
                const e = t.parentNode;
                e && e.removeChild(t)
            },
            createElement: (t, e, n, r) => {
                const s = e ? oa.createElementNS(gD, t) : oa.createElement(t, n ? {
                    is: n
                } : void 0);
                return t === "select" && r && r.multiple != null && s.setAttribute("multiple", r.multiple), s
            },
            createText: t => oa.createTextNode(t),
            createComment: t => oa.createComment(t),
            setText: (t, e) => {
                t.nodeValue = e
            },
            setElementText: (t, e) => {
                t.textContent = e
            },
            parentNode: t => t.parentNode,
            nextSibling: t => t.nextSibling,
            querySelector: t => oa.querySelector(t),
            setScopeId(t, e) {
                t.setAttribute(e, "")
            },
            insertStaticContent(t, e, n, r, s, i) {
                const a = n ? n.previousSibling : e.lastChild;
                if (s && (s === i || s.nextSibling))
                    for (; e.insertBefore(s.cloneNode(!0), n), !(s === i || !(s = s.nextSibling)););
                else {
                    cT.innerHTML = r ? `<svg>${t}</svg>` : t;
                    const c = cT.content;
                    if (r) {
                        const u = c.firstChild;
                        for (; u.firstChild;) c.appendChild(u.firstChild);
                        c.removeChild(u)
                    }
                    e.insertBefore(c, n)
                }
                return [a ? a.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
            }
        };

    function yD(t, e, n) {
        const r = t._vtc;
        r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e
    }

    function vD(t, e, n) {
        const r = t.style,
            s = vn(n);
        if (n && !s) {
            if (e && !vn(e))
                for (const i in e) n[i] == null && l1(r, i, "");
            for (const i in n) l1(r, i, n[i])
        } else {
            const i = r.display;
            s ? e !== n && (r.cssText = n) : e && t.removeAttribute("style"), "_vod" in t && (r.display = i)
        }
    }
    const lT = /\s*!important$/;

    function l1(t, e, n) {
        if (qe(n)) n.forEach(r => l1(t, e, r));
        else if (n == null && (n = ""), e.startsWith("--")) t.setProperty(e, n);
        else {
            const r = bD(t, e);
            lT.test(n) ? t.setProperty(Ia(r), n.replace(lT, ""), "important") : t[r] = n
        }
    }
    const uT = ["Webkit", "Moz", "ms"],
        e_ = {};

    function bD(t, e) {
        const n = e_[e];
        if (n) return n;
        let r = zs(e);
        if (r !== "filter" && r in t) return e_[e] = r;
        r = xp(r);
        for (let s = 0; s < uT.length; s++) {
            const i = uT[s] + r;
            if (i in t) return e_[e] = i
        }
        return e
    }
    const hT = "http://www.w3.org/1999/xlink";

    function ED(t, e, n, r, s) {
        if (r && e.startsWith("xlink:")) n == null ? t.removeAttributeNS(hT, e.slice(6, e.length)) : t.setAttributeNS(hT, e, n);
        else {
            const i = OR(e);
            n == null || i && !a5(n) ? t.removeAttribute(e) : t.setAttribute(e, i ? "" : n)
        }
    }

    function TD(t, e, n, r, s, i, a) {
        if (e === "innerHTML" || e === "textContent") {
            r && a(r, s, i), t[e] = n ?? "";
            return
        }
        const c = t.tagName;
        if (e === "value" && c !== "PROGRESS" && !c.includes("-")) {
            t._value = n;
            const h = c === "OPTION" ? t.getAttribute("value") : t.value,
                d = n ?? "";
            h !== d && (t.value = d), n == null && t.removeAttribute(e);
            return
        }
        let u = !1;
        if (n === "" || n == null) {
            const h = typeof t[e];
            h === "boolean" ? n = a5(n) : n == null && h === "string" ? (n = "", u = !0) : h === "number" && (n = 0, u = !0)
        }
        try {
            t[e] = n
        } catch {}
        u && t.removeAttribute(e)
    }

    function aa(t, e, n, r) {
        t.addEventListener(e, n, r)
    }

    function SD(t, e, n, r) {
        t.removeEventListener(e, n, r)
    }

    function wD(t, e, n, r, s = null) {
        const i = t._vei || (t._vei = {}),
            a = i[e];
        if (r && a) a.value = r;
        else {
            const [c, u] = OD(e);
            if (r) {
                const h = i[e] = kD(r, s);
                aa(t, c, h, u)
            } else a && (SD(t, c, a, u), i[e] = void 0)
        }
    }
    const fT = /(?:Once|Passive|Capture)$/;

    function OD(t) {
        let e;
        if (fT.test(t)) {
            e = {};
            let r;
            for (; r = t.match(fT);) t = t.slice(0, t.length - r[0].length), e[r[0].toLowerCase()] = !0
        }
        return [t[2] === ":" ? t.slice(3) : Ia(t.slice(2)), e]
    }
    let t_ = 0;
    const AD = Promise.resolve(),
        CD = () => t_ || (AD.then(() => t_ = 0), t_ = Date.now());

    function kD(t, e) {
        const n = r => {
            if (!r._vts) r._vts = Date.now();
            else if (r._vts <= n.attached) return;
            ts(ID(r, n.value), e, 5, [r])
        };
        return n.value = t, n.attached = CD(), n
    }

    function ID(t, e) {
        if (qe(e)) {
            const n = t.stopImmediatePropagation;
            return t.stopImmediatePropagation = () => {
                n.call(t), t._stopped = !0
            }, e.map(r => s => !s._stopped && r && r(s))
        } else return e
    }
    const dT = /^on[a-z]/,
        ND = (t, e, n, r, s = !1, i, a, c, u) => {
            e === "class" ? yD(t, r, s) : e === "style" ? vD(t, n, r) : kp(e) ? Sy(e) || wD(t, e, n, r, a) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : xD(t, e, r, s)) ? TD(t, e, r, i, a, c, u) : (e === "true-value" ? t._trueValue = r : e === "false-value" && (t._falseValue = r), ED(t, e, r, s))
        };

    function xD(t, e, n, r) {
        return r ? !!(e === "innerHTML" || e === "textContent" || e in t && dT.test(e) && lt(n)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || dT.test(e) && vn(n) ? !1 : e in t
    }
    const Qi = "transition",
        $l = "animation",
        Li = (t, {
            slots: e
        }) => Gy(OM, PD(t), e);
    Li.displayName = "Transition";
    const n4 = {
        name: String,
        type: String,
        css: {
            type: Boolean,
            default: !0
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
    };
    Li.props = wn({}, D5, n4);
    const ea = (t, e = []) => {
            qe(t) ? t.forEach(n => n(...e)) : t && t(...e)
        },
        pT = t => t ? qe(t) ? t.some(e => e.length > 1) : t.length > 1 : !1;

    function PD(t) {
        const e = {};
        for (const Z in t) Z in n4 || (e[Z] = t[Z]);
        if (t.css === !1) return e;
        const {
            name: n = "v",
            type: r,
            duration: s,
            enterFromClass: i = `${n}-enter-from`,
            enterActiveClass: a = `${n}-enter-active`,
            enterToClass: c = `${n}-enter-to`,
            appearFromClass: u = i,
            appearActiveClass: h = a,
            appearToClass: d = c,
            leaveFromClass: p = `${n}-leave-from`,
            leaveActiveClass: m = `${n}-leave-active`,
            leaveToClass: _ = `${n}-leave-to`
        } = t, y = RD(s), v = y && y[0], w = y && y[1], {
            onBeforeEnter: b,
            onEnter: I,
            onEnterCancelled: F,
            onLeave: x,
            onLeaveCancelled: O,
            onBeforeAppear: M = b,
            onAppear: $ = I,
            onAppearCancelled: j = F
        } = e, ee = (Z, de, q) => {
            ta(Z, de ? d : c), ta(Z, de ? h : a), q && q()
        }, se = (Z, de) => {
            Z._isLeaving = !1, ta(Z, p), ta(Z, _), ta(Z, m), de && de()
        }, oe = Z => (de, q) => {
            const ie = Z ? $ : I,
                ae = () => ee(de, Z, q);
            ea(ie, [de, ae]), mT(() => {
                ta(de, Z ? u : i), eo(de, Z ? d : c), pT(ie) || gT(de, r, v, ae)
            })
        };
        return wn(e, {
            onBeforeEnter(Z) {
                ea(b, [Z]), eo(Z, i), eo(Z, a)
            },
            onBeforeAppear(Z) {
                ea(M, [Z]), eo(Z, u), eo(Z, h)
            },
            onEnter: oe(!1),
            onAppear: oe(!0),
            onLeave(Z, de) {
                Z._isLeaving = !0;
                const q = () => se(Z, de);
                eo(Z, p), $D(), eo(Z, m), mT(() => {
                    Z._isLeaving && (ta(Z, p), eo(Z, _), pT(x) || gT(Z, r, w, q))
                }), ea(x, [Z, q])
            },
            onEnterCancelled(Z) {
                ee(Z, !1), ea(F, [Z])
            },
            onAppearCancelled(Z) {
                ee(Z, !0), ea(j, [Z])
            },
            onLeaveCancelled(Z) {
                se(Z), ea(O, [Z])
            }
        })
    }

    function RD(t) {
        if (t == null) return null;
        if (qt(t)) return [n_(t.enter), n_(t.leave)]; {
            const e = n_(t);
            return [e, e]
        }
    }

    function n_(t) {
        return vR(t)
    }

    function eo(t, e) {
        e.split(/\s+/).forEach(n => n && t.classList.add(n)), (t._vtc || (t._vtc = new Set)).add(e)
    }

    function ta(t, e) {
        e.split(/\s+/).forEach(r => r && t.classList.remove(r));
        const {
            _vtc: n
        } = t;
        n && (n.delete(e), n.size || (t._vtc = void 0))
    }

    function mT(t) {
        requestAnimationFrame(() => {
            requestAnimationFrame(t)
        })
    }
    let MD = 0;

    function gT(t, e, n, r) {
        const s = t._endId = ++MD,
            i = () => {
                s === t._endId && r()
            };
        if (n) return setTimeout(i, n);
        const {
            type: a,
            timeout: c,
            propCount: u
        } = DD(t, e);
        if (!a) return r();
        const h = a + "end";
        let d = 0;
        const p = () => {
                t.removeEventListener(h, m), i()
            },
            m = _ => {
                _.target === t && ++d >= u && p()
            };
        setTimeout(() => {
            d < u && p()
        }, c + 1), t.addEventListener(h, m)
    }

    function DD(t, e) {
        const n = window.getComputedStyle(t),
            r = y => (n[y] || "").split(", "),
            s = r(`${Qi}Delay`),
            i = r(`${Qi}Duration`),
            a = _T(s, i),
            c = r(`${$l}Delay`),
            u = r(`${$l}Duration`),
            h = _T(c, u);
        let d = null,
            p = 0,
            m = 0;
        e === Qi ? a > 0 && (d = Qi, p = a, m = i.length) : e === $l ? h > 0 && (d = $l, p = h, m = u.length) : (p = Math.max(a, h), d = p > 0 ? a > h ? Qi : $l : null, m = d ? d === Qi ? i.length : u.length : 0);
        const _ = d === Qi && /\b(transform|all)(,|$)/.test(r(`${Qi}Property`).toString());
        return {
            type: d,
            timeout: p,
            propCount: m,
            hasTransform: _
        }
    }

    function _T(t, e) {
        for (; t.length < e.length;) t = t.concat(t);
        return Math.max(...e.map((n, r) => yT(n) + yT(t[r])))
    }

    function yT(t) {
        return Number(t.slice(0, -1).replace(",", ".")) * 1e3
    }

    function $D() {
        return document.body.offsetHeight
    }
    const ad = t => {
        const e = t.props["onUpdate:modelValue"] || !1;
        return qe(e) ? n => Vf(e, n) : e
    };

    function LD(t) {
        t.target.composing = !0
    }

    function vT(t) {
        const e = t.target;
        e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")))
    }
    const bT = {
            created(t, {
                modifiers: {
                    lazy: e,
                    trim: n,
                    number: r
                }
            }, s) {
                t._assign = ad(s);
                const i = r || s.props && s.props.type === "number";
                aa(t, e ? "change" : "input", a => {
                    if (a.target.composing) return;
                    let c = t.value;
                    n && (c = c.trim()), i && (c = z_(c)), t._assign(c)
                }), n && aa(t, "change", () => {
                    t.value = t.value.trim()
                }), e || (aa(t, "compositionstart", LD), aa(t, "compositionend", vT), aa(t, "change", vT))
            },
            mounted(t, {
                value: e
            }) {
                t.value = e ?? ""
            },
            beforeUpdate(t, {
                value: e,
                modifiers: {
                    lazy: n,
                    trim: r,
                    number: s
                }
            }, i) {
                if (t._assign = ad(i), t.composing || document.activeElement === t && t.type !== "range" && (n || r && t.value.trim() === e || (s || t.type === "number") && z_(t.value) === e)) return;
                const a = e ?? "";
                t.value !== a && (t.value = a)
            }
        },
        FD = {
            deep: !0,
            created(t, e, n) {
                t._assign = ad(n), aa(t, "change", () => {
                    const r = t._modelValue,
                        s = UD(t),
                        i = t.checked,
                        a = t._assign;
                    if (qe(r)) {
                        const c = c5(r, s),
                            u = c !== -1;
                        if (i && !u) a(r.concat(s));
                        else if (!i && u) {
                            const h = [...r];
                            h.splice(c, 1), a(h)
                        }
                    } else if (Ip(r)) {
                        const c = new Set(r);
                        i ? c.add(s) : c.delete(s), a(c)
                    } else a(r4(t, i))
                })
            },
            mounted: ET,
            beforeUpdate(t, e, n) {
                t._assign = ad(n), ET(t, e, n)
            }
        };

    function ET(t, {
        value: e,
        oldValue: n
    }, r) {
        t._modelValue = e, qe(e) ? t.checked = c5(e, r.props.value) > -1 : Ip(e) ? t.checked = e.has(r.props.value) : e !== n && (t.checked = Pp(e, r4(t, !0)))
    }

    function UD(t) {
        return "_value" in t ? t._value : t.value
    }

    function r4(t, e) {
        const n = e ? "_trueValue" : "_falseValue";
        return n in t ? t[n] : e
    }
    const BD = ["ctrl", "shift", "alt", "meta"],
        qD = {
            stop: t => t.stopPropagation(),
            prevent: t => t.preventDefault(),
            self: t => t.target !== t.currentTarget,
            ctrl: t => !t.ctrlKey,
            shift: t => !t.shiftKey,
            alt: t => !t.altKey,
            meta: t => !t.metaKey,
            left: t => "button" in t && t.button !== 0,
            middle: t => "button" in t && t.button !== 1,
            right: t => "button" in t && t.button !== 2,
            exact: (t, e) => BD.some(n => t[`${n}Key`] && !e.includes(n))
        },
        Pi = (t, e) => (n, ...r) => {
            for (let s = 0; s < e.length; s++) {
                const i = qD[e[s]];
                if (i && i(n, e)) return
            }
            return t(n, ...r)
        },
        jD = {
            esc: "escape",
            space: " ",
            up: "arrow-up",
            left: "arrow-left",
            right: "arrow-right",
            down: "arrow-down",
            delete: "backspace"
        },
        Wy = (t, e) => n => {
            if (!("key" in n)) return;
            const r = Ia(n.key);
            if (e.some(s => s === r || jD[s] === r)) return t(n)
        },
        VD = wn({
            patchProp: ND
        }, _D);
    let TT;

    function GD() {
        return TT || (TT = XM(VD))
    }
    const WD = (...t) => {
        const e = GD().createApp(...t),
            {
                mount: n
            } = e;
        return e.mount = r => {
            const s = HD(r);
            if (!s) return;
            const i = e._component;
            !lt(i) && !i.render && !i.template && (i.template = s.innerHTML), s.innerHTML = "";
            const a = n(s, !1, s instanceof SVGElement);
            return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), a
        }, e
    };

    function HD(t) {
        return vn(t) ? document.querySelector(t) : t
    }
    const ot = (t, e) => {
        const n = t.__vccOpts || t;
        for (const [r, s] of e) n[r] = s;
        return n
    };
    var gn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

    function el(t) {
        return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
    }

    function KD(t) {
        if (t.__esModule) return t;
        var e = t.default;
        if (typeof e == "function") {
            var n = function r() {
                return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
            };
            n.prototype = e.prototype
        } else n = {};
        return Object.defineProperty(n, "__esModule", {
            value: !0
        }), Object.keys(t).forEach(function(r) {
            var s = Object.getOwnPropertyDescriptor(t, r);
            Object.defineProperty(n, r, s.get ? s : {
                enumerable: !0,
                get: function() {
                    return t[r]
                }
            })
        }), n
    }
    var go = {
            DEBUG: !1,
            LIB_VERSION: "2.45.0"
        },
        nr;
    if (typeof window > "u") {
        var ST = {
            hostname: ""
        };
        nr = {
            navigator: {
                userAgent: ""
            },
            document: {
                location: ST,
                referrer: ""
            },
            screen: {
                width: 0,
                height: 0
            },
            location: ST
        }
    } else nr = window;
    var jp = Array.prototype,
        YD = Function.prototype,
        s4 = Object.prototype,
        uo = jp.slice,
        Ku = s4.toString,
        Vp = s4.hasOwnProperty,
        En = nr.console,
        Ai = nr.navigator,
        Ft = nr.document,
        Ll = nr.opera,
        cd = nr.screen,
        ps = Ai.userAgent,
        r_ = YD.bind,
        wT = jp.forEach,
        OT = jp.indexOf,
        AT = jp.map,
        zD = Array.isArray,
        u1 = {},
        C = {
            trim: function(t) {
                return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
            }
        },
        Mt = {
            log: function() {
                if (go.DEBUG && !C.isUndefined(En) && En) try {
                    En.log.apply(En, arguments)
                } catch {
                    C.each(arguments, function(e) {
                        En.log(e)
                    })
                }
            },
            warn: function() {
                if (go.DEBUG && !C.isUndefined(En) && En) {
                    var t = ["Mixpanel warning:"].concat(C.toArray(arguments));
                    try {
                        En.warn.apply(En, t)
                    } catch {
                        C.each(t, function(n) {
                            En.warn(n)
                        })
                    }
                }
            },
            error: function() {
                if (go.DEBUG && !C.isUndefined(En) && En) {
                    var t = ["Mixpanel error:"].concat(C.toArray(arguments));
                    try {
                        En.error.apply(En, t)
                    } catch {
                        C.each(t, function(n) {
                            En.error(n)
                        })
                    }
                }
            },
            critical: function() {
                if (!C.isUndefined(En) && En) {
                    var t = ["Mixpanel error:"].concat(C.toArray(arguments));
                    try {
                        En.error.apply(En, t)
                    } catch {
                        C.each(t, function(n) {
                            En.error(n)
                        })
                    }
                }
            }
        },
        s_ = function(t, e) {
            return function() {
                return arguments[0] = "[" + e + "] " + arguments[0], t.apply(Mt, arguments)
            }
        },
        Hy = function(t) {
            return {
                log: s_(Mt.log, t),
                error: s_(Mt.error, t),
                critical: s_(Mt.critical, t)
            }
        };
    C.bind = function(t, e) {
        var n, r;
        if (r_ && t.bind === r_) return r_.apply(t, uo.call(arguments, 1));
        if (!C.isFunction(t)) throw new TypeError;
        return n = uo.call(arguments, 2), r = function() {
            if (!(this instanceof r)) return t.apply(e, n.concat(uo.call(arguments)));
            var s = {};
            s.prototype = t.prototype;
            var i = new s;
            s.prototype = null;
            var a = t.apply(i, n.concat(uo.call(arguments)));
            return Object(a) === a ? a : i
        }, r
    };
    C.each = function(t, e, n) {
        if (t != null) {
            if (wT && t.forEach === wT) t.forEach(e, n);
            else if (t.length === +t.length) {
                for (var r = 0, s = t.length; r < s; r++)
                    if (r in t && e.call(n, t[r], r, t) === u1) return
            } else
                for (var i in t)
                    if (Vp.call(t, i) && e.call(n, t[i], i, t) === u1) return
        }
    };
    C.extend = function(t) {
        return C.each(uo.call(arguments, 1), function(e) {
            for (var n in e) e[n] !== void 0 && (t[n] = e[n])
        }), t
    };
    C.isArray = zD || function(t) {
        return Ku.call(t) === "[object Array]"
    };
    C.isFunction = function(t) {
        try {
            return /^\s*\bfunction\b/.test(t)
        } catch {
            return !1
        }
    };
    C.isArguments = function(t) {
        return !!(t && Vp.call(t, "callee"))
    };
    C.toArray = function(t) {
        return t ? t.toArray ? t.toArray() : C.isArray(t) || C.isArguments(t) ? uo.call(t) : C.values(t) : []
    };
    C.map = function(t, e, n) {
        if (AT && t.map === AT) return t.map(e, n);
        var r = [];
        return C.each(t, function(s) {
            r.push(e.call(n, s))
        }), r
    };
    C.keys = function(t) {
        var e = [];
        return t === null || C.each(t, function(n, r) {
            e[e.length] = r
        }), e
    };
    C.values = function(t) {
        var e = [];
        return t === null || C.each(t, function(n) {
            e[e.length] = n
        }), e
    };
    C.include = function(t, e) {
        var n = !1;
        return t === null ? n : OT && t.indexOf === OT ? t.indexOf(e) != -1 : (C.each(t, function(r) {
            if (n || (n = r === e)) return u1
        }), n)
    };
    C.includes = function(t, e) {
        return t.indexOf(e) !== -1
    };
    C.inherit = function(t, e) {
        return t.prototype = new e, t.prototype.constructor = t, t.superclass = e.prototype, t
    };
    C.isObject = function(t) {
        return t === Object(t) && !C.isArray(t)
    };
    C.isEmptyObject = function(t) {
        if (C.isObject(t)) {
            for (var e in t)
                if (Vp.call(t, e)) return !1;
            return !0
        }
        return !1
    };
    C.isUndefined = function(t) {
        return t === void 0
    };
    C.isString = function(t) {
        return Ku.call(t) == "[object String]"
    };
    C.isDate = function(t) {
        return Ku.call(t) == "[object Date]"
    };
    C.isNumber = function(t) {
        return Ku.call(t) == "[object Number]"
    };
    C.isElement = function(t) {
        return !!(t && t.nodeType === 1)
    };
    C.encodeDates = function(t) {
        return C.each(t, function(e, n) {
            C.isDate(e) ? t[n] = C.formatDate(e) : C.isObject(e) && (t[n] = C.encodeDates(e))
        }), t
    };
    C.timestamp = function() {
        return Date.now = Date.now || function() {
            return +new Date
        }, Date.now()
    };
    C.formatDate = function(t) {
        function e(n) {
            return n < 10 ? "0" + n : n
        }
        return t.getUTCFullYear() + "-" + e(t.getUTCMonth() + 1) + "-" + e(t.getUTCDate()) + "T" + e(t.getUTCHours()) + ":" + e(t.getUTCMinutes()) + ":" + e(t.getUTCSeconds())
    };
    C.strip_empty_properties = function(t) {
        var e = {};
        return C.each(t, function(n, r) {
            C.isString(n) && n.length > 0 && (e[r] = n)
        }), e
    };
    C.truncate = function(t, e) {
        var n;
        return typeof t == "string" ? n = t.slice(0, e) : C.isArray(t) ? (n = [], C.each(t, function(r) {
            n.push(C.truncate(r, e))
        })) : C.isObject(t) ? (n = {}, C.each(t, function(r, s) {
            n[s] = C.truncate(r, e)
        })) : n = t, n
    };
    C.JSONEncode = function() {
        return function(t) {
            var e = t,
                n = function(s) {
                    var i = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                        a = {
                            "\b": "\\b",
                            "	": "\\t",
                            "\n": "\\n",
                            "\f": "\\f",
                            "\r": "\\r",
                            '"': '\\"',
                            "\\": "\\\\"
                        };
                    return i.lastIndex = 0, i.test(s) ? '"' + s.replace(i, function(c) {
                        var u = a[c];
                        return typeof u == "string" ? u : "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4)
                    }) + '"' : '"' + s + '"'
                },
                r = function(s, i) {
                    var a = "",
                        c = "    ",
                        u = 0,
                        h = "",
                        d = "",
                        p = 0,
                        m = a,
                        _ = [],
                        y = i[s];
                    switch (y && typeof y == "object" && typeof y.toJSON == "function" && (y = y.toJSON(s)), typeof y) {
                        case "string":
                            return n(y);
                        case "number":
                            return isFinite(y) ? String(y) : "null";
                        case "boolean":
                        case "null":
                            return String(y);
                        case "object":
                            if (!y) return "null";
                            if (a += c, _ = [], Ku.apply(y) === "[object Array]") {
                                for (p = y.length, u = 0; u < p; u += 1) _[u] = r(u, y) || "null";
                                return d = _.length === 0 ? "[]" : a ? `[
` + a + _.join(`,
` + a) + `
` + m + "]" : "[" + _.join(",") + "]", a = m, d
                            }
                            for (h in y) Vp.call(y, h) && (d = r(h, y), d && _.push(n(h) + (a ? ": " : ":") + d));
                            return d = _.length === 0 ? "{}" : a ? "{" + _.join(",") + m + "}" : "{" + _.join(",") + "}", a = m, d
                    }
                };
            return r("", {
                "": e
            })
        }
    }();
    C.JSONDecode = function() {
        var t, e, n = {
                '"': '"',
                "\\": "\\",
                "/": "/",
                b: "\b",
                f: "\f",
                n: `
`,
                r: "\r",
                t: "	"
            },
            r, s = function(_) {
                var y = new SyntaxError(_);
                throw y.at = t, y.text = r, y
            },
            i = function(_) {
                return _ && _ !== e && s("Expected '" + _ + "' instead of '" + e + "'"), e = r.charAt(t), t += 1, e
            },
            a = function() {
                var _, y = "";
                for (e === "-" && (y = "-", i("-")); e >= "0" && e <= "9";) y += e, i();
                if (e === ".")
                    for (y += "."; i() && e >= "0" && e <= "9";) y += e;
                if (e === "e" || e === "E")
                    for (y += e, i(), (e === "-" || e === "+") && (y += e, i()); e >= "0" && e <= "9";) y += e, i();
                if (_ = +y, !isFinite(_)) s("Bad number");
                else return _
            },
            c = function() {
                var _, y, v = "",
                    w;
                if (e === '"')
                    for (; i();) {
                        if (e === '"') return i(), v;
                        if (e === "\\")
                            if (i(), e === "u") {
                                for (w = 0, y = 0; y < 4 && (_ = parseInt(i(), 16), !!isFinite(_)); y += 1) w = w * 16 + _;
                                v += String.fromCharCode(w)
                            } else if (typeof n[e] == "string") v += n[e];
                        else break;
                        else v += e
                    }
                s("Bad string")
            },
            u = function() {
                for (; e && e <= " ";) i()
            },
            h = function() {
                switch (e) {
                    case "t":
                        return i("t"), i("r"), i("u"), i("e"), !0;
                    case "f":
                        return i("f"), i("a"), i("l"), i("s"), i("e"), !1;
                    case "n":
                        return i("n"), i("u"), i("l"), i("l"), null
                }
                s('Unexpected "' + e + '"')
            },
            d, p = function() {
                var _ = [];
                if (e === "[") {
                    if (i("["), u(), e === "]") return i("]"), _;
                    for (; e;) {
                        if (_.push(d()), u(), e === "]") return i("]"), _;
                        i(","), u()
                    }
                }
                s("Bad array")
            },
            m = function() {
                var _, y = {};
                if (e === "{") {
                    if (i("{"), u(), e === "}") return i("}"), y;
                    for (; e;) {
                        if (_ = c(), u(), i(":"), Object.hasOwnProperty.call(y, _) && s('Duplicate key "' + _ + '"'), y[_] = d(), u(), e === "}") return i("}"), y;
                        i(","), u()
                    }
                }
                s("Bad object")
            };
        return d = function() {
                switch (u(), e) {
                    case "{":
                        return m();
                    case "[":
                        return p();
                    case '"':
                        return c();
                    case "-":
                        return a();
                    default:
                        return e >= "0" && e <= "9" ? a() : h()
                }
            },
            function(_) {
                var y;
                return r = _, t = 0, e = " ", y = d(), u(), e && s("Syntax error"), y
            }
    }();
    C.base64Encode = function(t) {
        var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            n, r, s, i, a, c, u, h, d = 0,
            p = 0,
            m = "",
            _ = [];
        if (!t) return t;
        t = C.utf8Encode(t);
        do n = t.charCodeAt(d++), r = t.charCodeAt(d++), s = t.charCodeAt(d++), h = n << 16 | r << 8 | s, i = h >> 18 & 63, a = h >> 12 & 63, c = h >> 6 & 63, u = h & 63, _[p++] = e.charAt(i) + e.charAt(a) + e.charAt(c) + e.charAt(u); while (d < t.length);
        switch (m = _.join(""), t.length % 3) {
            case 1:
                m = m.slice(0, -2) + "==";
                break;
            case 2:
                m = m.slice(0, -1) + "=";
                break
        }
        return m
    };
    C.utf8Encode = function(t) {
        t = (t + "").replace(/\r\n/g, `
`).replace(/\r/g, `
`);
        var e = "",
            n, r, s = 0,
            i;
        for (n = r = 0, s = t.length, i = 0; i < s; i++) {
            var a = t.charCodeAt(i),
                c = null;
            a < 128 ? r++ : a > 127 && a < 2048 ? c = String.fromCharCode(a >> 6 | 192, a & 63 | 128) : c = String.fromCharCode(a >> 12 | 224, a >> 6 & 63 | 128, a & 63 | 128), c !== null && (r > n && (e += t.substring(n, r)), e += c, n = r = i + 1)
        }
        return r > n && (e += t.substring(n, t.length)), e
    };
    C.UUID = function() {
        var t = function() {
                for (var r = 1 * new Date, s = 0; r == 1 * new Date;) s++;
                return r.toString(16) + s.toString(16)
            },
            e = function() {
                return Math.random().toString(16).replace(".", "")
            },
            n = function() {
                var r = ps,
                    s, i, a = [],
                    c = 0;

                function u(h, d) {
                    var p, m = 0;
                    for (p = 0; p < d.length; p++) m |= a[p] << p * 8;
                    return h ^ m
                }
                for (s = 0; s < r.length; s++) i = r.charCodeAt(s), a.unshift(i & 255), a.length >= 4 && (c = u(c, a), a = []);
                return a.length > 0 && (c = u(c, a)), c.toString(16)
            };
        return function() {
            var r = (cd.height * cd.width).toString(16);
            return t() + "-" + e() + "-" + n() + "-" + r + "-" + t()
        }
    }();
    var CT = ["ahrefsbot", "baiduspider", "bingbot", "bingpreview", "facebookexternal", "petalbot", "pinterest", "screaming frog", "yahoo! slurp", "yandexbot", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google"];
    C.isBlockedUA = function(t) {
        var e;
        for (t = t.toLowerCase(), e = 0; e < CT.length; e++)
            if (t.indexOf(CT[e]) !== -1) return !0;
        return !1
    };
    C.HTTPBuildQuery = function(t, e) {
        var n, r, s = [];
        return C.isUndefined(e) && (e = "&"), C.each(t, function(i, a) {
            n = encodeURIComponent(i.toString()), r = encodeURIComponent(a), s[s.length] = r + "=" + n
        }), s.join(e)
    };
    C.getQueryParam = function(t, e) {
        e = e.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
        var n = "[\\?&]" + e + "=([^&#]*)",
            r = new RegExp(n),
            s = r.exec(t);
        if (s === null || s && typeof s[1] != "string" && s[1].length) return "";
        var i = s[1];
        try {
            i = decodeURIComponent(i)
        } catch {
            Mt.error("Skipping decoding for malformed query param: " + i)
        }
        return i.replace(/\+/g, " ")
    };
    C.cookie = {
        get: function(t) {
            for (var e = t + "=", n = Ft.cookie.split(";"), r = 0; r < n.length; r++) {
                for (var s = n[r]; s.charAt(0) == " ";) s = s.substring(1, s.length);
                if (s.indexOf(e) === 0) return decodeURIComponent(s.substring(e.length, s.length))
            }
            return null
        },
        parse: function(t) {
            var e;
            try {
                e = C.JSONDecode(C.cookie.get(t)) || {}
            } catch {}
            return e
        },
        set_seconds: function(t, e, n, r, s, i, a) {
            var c = "",
                u = "",
                h = "";
            if (a) c = "; domain=" + a;
            else if (r) {
                var d = kT(Ft.location.hostname);
                c = d ? "; domain=." + d : ""
            }
            if (n) {
                var p = new Date;
                p.setTime(p.getTime() + n * 1e3), u = "; expires=" + p.toGMTString()
            }
            i && (s = !0, h = "; SameSite=None"), s && (h += "; secure"), Ft.cookie = t + "=" + encodeURIComponent(e) + u + "; path=/" + c + h
        },
        set: function(t, e, n, r, s, i, a) {
            var c = "",
                u = "",
                h = "";
            if (a) c = "; domain=" + a;
            else if (r) {
                var d = kT(Ft.location.hostname);
                c = d ? "; domain=." + d : ""
            }
            if (n) {
                var p = new Date;
                p.setTime(p.getTime() + n * 24 * 60 * 60 * 1e3), u = "; expires=" + p.toGMTString()
            }
            i && (s = !0, h = "; SameSite=None"), s && (h += "; secure");
            var m = t + "=" + encodeURIComponent(e) + u + "; path=/" + c + h;
            return Ft.cookie = m, m
        },
        remove: function(t, e, n) {
            C.cookie.set(t, "", -1, e, !1, !1, n)
        }
    };
    var i_ = null,
        ld = function(t, e) {
            if (i_ !== null && !e) return i_;
            var n = !0;
            try {
                t = t || window.localStorage;
                var r = "__mplss_" + Ky(8),
                    s = "xyz";
                t.setItem(r, s), t.getItem(r) !== s && (n = !1), t.removeItem(r)
            } catch {
                n = !1
            }
            return i_ = n, n
        };
    C.localStorage = {
        is_supported: function(t) {
            var e = ld(null, t);
            return e || Mt.error("localStorage unsupported; falling back to cookie store"), e
        },
        error: function(t) {
            Mt.error("localStorage error: " + t)
        },
        get: function(t) {
            try {
                return window.localStorage.getItem(t)
            } catch (e) {
                C.localStorage.error(e)
            }
            return null
        },
        parse: function(t) {
            try {
                return C.JSONDecode(C.localStorage.get(t)) || {}
            } catch {}
            return null
        },
        set: function(t, e) {
            try {
                window.localStorage.setItem(t, e)
            } catch (n) {
                C.localStorage.error(n)
            }
        },
        remove: function(t) {
            try {
                window.localStorage.removeItem(t)
            } catch (e) {
                C.localStorage.error(e)
            }
        }
    };
    C.register_event = function() {
        var t = function(r, s, i, a, c) {
            if (!r) {
                Mt.error("No valid element provided to register_event");
                return
            }
            if (r.addEventListener && !a) r.addEventListener(s, i, !!c);
            else {
                var u = "on" + s,
                    h = r[u];
                r[u] = e(r, i, h)
            }
        };

        function e(r, s, i) {
            var a = function(c) {
                if (c = c || n(window.event), !!c) {
                    var u = !0,
                        h, d;
                    return C.isFunction(i) && (h = i(c)), d = s.call(r, c), (h === !1 || d === !1) && (u = !1), u
                }
            };
            return a
        }

        function n(r) {
            return r && (r.preventDefault = n.preventDefault, r.stopPropagation = n.stopPropagation), r
        }
        return n.preventDefault = function() {
            this.returnValue = !1
        }, n.stopPropagation = function() {
            this.cancelBubble = !0
        }, t
    }();
    var ZD = new RegExp('^(\\w*)\\[(\\w+)([=~\\|\\^\\$\\*]?)=?"?([^\\]"]*)"?\\]$');
    C.dom_query = function() {
        function t(s) {
            return s.all ? s.all : s.getElementsByTagName("*")
        }
        var e = /[\t\r\n]/g;

        function n(s, i) {
            var a = " " + i + " ";
            return (" " + s.className + " ").replace(e, " ").indexOf(a) >= 0
        }

        function r(s) {
            if (!Ft.getElementsByTagName) return [];
            var i = s.split(" "),
                a, c, u, h, d, p, m, _, y, v, w = [Ft];
            for (p = 0; p < i.length; p++) {
                if (a = i[p].replace(/^\s+/, "").replace(/\s+$/, ""), a.indexOf("#") > -1) {
                    c = a.split("#"), u = c[0];
                    var b = c[1],
                        I = Ft.getElementById(b);
                    if (!I || u && I.nodeName.toLowerCase() != u) return [];
                    w = [I];
                    continue
                }
                if (a.indexOf(".") > -1) {
                    c = a.split("."), u = c[0];
                    var F = c[1];
                    for (u || (u = "*"), h = [], d = 0, m = 0; m < w.length; m++)
                        for (u == "*" ? y = t(w[m]) : y = w[m].getElementsByTagName(u), _ = 0; _ < y.length; _++) h[d++] = y[_];
                    for (w = [], v = 0, m = 0; m < h.length; m++) h[m].className && C.isString(h[m].className) && n(h[m], F) && (w[v++] = h[m]);
                    continue
                }
                var x = a.match(ZD);
                if (x) {
                    u = x[1];
                    var O = x[2],
                        M = x[3],
                        $ = x[4];
                    for (u || (u = "*"), h = [], d = 0, m = 0; m < w.length; m++)
                        for (u == "*" ? y = t(w[m]) : y = w[m].getElementsByTagName(u), _ = 0; _ < y.length; _++) h[d++] = y[_];
                    w = [], v = 0;
                    var j;
                    switch (M) {
                        case "=":
                            j = function(ee) {
                                return ee.getAttribute(O) == $
                            };
                            break;
                        case "~":
                            j = function(ee) {
                                return ee.getAttribute(O).match(new RegExp("\\b" + $ + "\\b"))
                            };
                            break;
                        case "|":
                            j = function(ee) {
                                return ee.getAttribute(O).match(new RegExp("^" + $ + "-?"))
                            };
                            break;
                        case "^":
                            j = function(ee) {
                                return ee.getAttribute(O).indexOf($) === 0
                            };
                            break;
                        case "$":
                            j = function(ee) {
                                return ee.getAttribute(O).lastIndexOf($) == ee.getAttribute(O).length - $.length
                            };
                            break;
                        case "*":
                            j = function(ee) {
                                return ee.getAttribute(O).indexOf($) > -1
                            };
                            break;
                        default:
                            j = function(ee) {
                                return ee.getAttribute(O)
                            }
                    }
                    for (w = [], v = 0, m = 0; m < h.length; m++) j(h[m]) && (w[v++] = h[m]);
                    continue
                }
                for (u = a, h = [], d = 0, m = 0; m < w.length; m++)
                    for (y = w[m].getElementsByTagName(u), _ = 0; _ < y.length; _++) h[d++] = y[_];
                w = h
            }
            return w
        }
        return function(s) {
            return C.isElement(s) ? [s] : C.isObject(s) && !C.isUndefined(s.length) ? s : r.call(this, s)
        }
    }();
    C.info = {
        campaignParams: function() {
            var t = "utm_source utm_medium utm_campaign utm_content utm_term".split(" "),
                e = "",
                n = {};
            return C.each(t, function(r) {
                e = C.getQueryParam(Ft.URL, r), e.length && (n[r] = e)
            }), n
        },
        searchEngine: function(t) {
            return t.search("https?://(.*)google.([^/?]*)") === 0 ? "google" : t.search("https?://(.*)bing.com") === 0 ? "bing" : t.search("https?://(.*)yahoo.com") === 0 ? "yahoo" : t.search("https?://(.*)duckduckgo.com") === 0 ? "duckduckgo" : null
        },
        searchInfo: function(t) {
            var e = C.info.searchEngine(t),
                n = e != "yahoo" ? "q" : "p",
                r = {};
            if (e !== null) {
                r.$search_engine = e;
                var s = C.getQueryParam(t, n);
                s.length && (r.mp_keyword = s)
            }
            return r
        },
        browser: function(t, e, n) {
            return e = e || "", n || C.includes(t, " OPR/") ? C.includes(t, "Mini") ? "Opera Mini" : "Opera" : /(BlackBerry|PlayBook|BB10)/i.test(t) ? "BlackBerry" : C.includes(t, "IEMobile") || C.includes(t, "WPDesktop") ? "Internet Explorer Mobile" : C.includes(t, "SamsungBrowser/") ? "Samsung Internet" : C.includes(t, "Edge") || C.includes(t, "Edg/") ? "Microsoft Edge" : C.includes(t, "FBIOS") ? "Facebook Mobile" : C.includes(t, "Chrome") ? "Chrome" : C.includes(t, "CriOS") ? "Chrome iOS" : C.includes(t, "UCWEB") || C.includes(t, "UCBrowser") ? "UC Browser" : C.includes(t, "FxiOS") ? "Firefox iOS" : C.includes(e, "Apple") ? C.includes(t, "Mobile") ? "Mobile Safari" : "Safari" : C.includes(t, "Android") ? "Android Mobile" : C.includes(t, "Konqueror") ? "Konqueror" : C.includes(t, "Firefox") ? "Firefox" : C.includes(t, "MSIE") || C.includes(t, "Trident/") ? "Internet Explorer" : C.includes(t, "Gecko") ? "Mozilla" : ""
        },
        browserVersion: function(t, e, n) {
            var r = C.info.browser(t, e, n),
                s = {
                    "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
                    "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/,
                    Chrome: /Chrome\/(\d+(\.\d+)?)/,
                    "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
                    "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
                    Safari: /Version\/(\d+(\.\d+)?)/,
                    "Mobile Safari": /Version\/(\d+(\.\d+)?)/,
                    Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/,
                    Firefox: /Firefox\/(\d+(\.\d+)?)/,
                    "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
                    Konqueror: /Konqueror:(\d+(\.\d+)?)/,
                    BlackBerry: /BlackBerry (\d+(\.\d+)?)/,
                    "Android Mobile": /android\s(\d+(\.\d+)?)/,
                    "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/,
                    "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
                    Mozilla: /rv:(\d+(\.\d+)?)/
                },
                i = s[r];
            if (i === void 0) return null;
            var a = t.match(i);
            return a ? parseFloat(a[a.length - 2]) : null
        },
        os: function() {
            var t = ps;
            return /Windows/i.test(t) ? /Phone/.test(t) || /WPDesktop/.test(t) ? "Windows Phone" : "Windows" : /(iPhone|iPad|iPod)/.test(t) ? "iOS" : /Android/.test(t) ? "Android" : /(BlackBerry|PlayBook|BB10)/i.test(t) ? "BlackBerry" : /Mac/i.test(t) ? "Mac OS X" : /Linux/.test(t) ? "Linux" : /CrOS/.test(t) ? "Chrome OS" : ""
        },
        device: function(t) {
            return /Windows Phone/i.test(t) || /WPDesktop/.test(t) ? "Windows Phone" : /iPad/.test(t) ? "iPad" : /iPod/.test(t) ? "iPod Touch" : /iPhone/.test(t) ? "iPhone" : /(BlackBerry|PlayBook|BB10)/i.test(t) ? "BlackBerry" : /Android/.test(t) ? "Android" : ""
        },
        referringDomain: function(t) {
            var e = t.split("/");
            return e.length >= 3 ? e[2] : ""
        },
        properties: function() {
            return C.extend(C.strip_empty_properties({
                $os: C.info.os(),
                $browser: C.info.browser(ps, Ai.vendor, Ll),
                $referrer: Ft.referrer,
                $referring_domain: C.info.referringDomain(Ft.referrer),
                $device: C.info.device(ps)
            }), {
                $current_url: nr.location.href,
                $browser_version: C.info.browserVersion(ps, Ai.vendor, Ll),
                $screen_height: cd.height,
                $screen_width: cd.width,
                mp_lib: "web",
                $lib_version: go.LIB_VERSION,
                $insert_id: Ky(),
                time: C.timestamp() / 1e3
            })
        },
        people_properties: function() {
            return C.extend(C.strip_empty_properties({
                $os: C.info.os(),
                $browser: C.info.browser(ps, Ai.vendor, Ll)
            }), {
                $browser_version: C.info.browserVersion(ps, Ai.vendor, Ll)
            })
        },
        pageviewInfo: function(t) {
            return C.strip_empty_properties({
                mp_page: t,
                mp_referrer: Ft.referrer,
                mp_browser: C.info.browser(ps, Ai.vendor, Ll),
                mp_platform: C.info.os()
            })
        }
    };
    var Ky = function(t) {
            var e = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);
            return t ? e.substring(0, t) : e
        },
        XD = /[a-z0-9][a-z0-9-]*\.[a-z]+$/i,
        JD = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i,
        kT = function(t) {
            var e = JD,
                n = t.split("."),
                r = n[n.length - 1];
            (r.length > 4 || r === "com" || r === "org") && (e = XD);
            var s = t.match(e);
            return s ? s[0] : ""
        },
        ud = null,
        hd = null;
    typeof JSON < "u" && (ud = JSON.stringify, hd = JSON.parse);
    ud = ud || C.JSONEncode;
    hd = hd || C.JSONDecode;
    C.toArray = C.toArray;
    C.isObject = C.isObject;
    C.JSONEncode = C.JSONEncode;
    C.JSONDecode = C.JSONDecode;
    C.isBlockedUA = C.isBlockedUA;
    C.isEmptyObject = C.isEmptyObject;
    C.info = C.info;
    C.info.device = C.info.device;
    C.info.browser = C.info.browser;
    C.info.browserVersion = C.info.browserVersion;
    C.info.properties = C.info.properties;
    var Fi = function() {};
    Fi.prototype.create_properties = function() {};
    Fi.prototype.event_handler = function() {};
    Fi.prototype.after_track_handler = function() {};
    Fi.prototype.init = function(t) {
        return this.mp = t, this
    };
    Fi.prototype.track = function(t, e, n, r) {
        var s = this,
            i = C.dom_query(t);
        if (i.length === 0) {
            Mt.error("The DOM query (" + t + ") returned 0 elements");
            return
        }
        return C.each(i, function(a) {
            C.register_event(a, this.override_event, function(c) {
                var u = {},
                    h = s.create_properties(n, this),
                    d = s.mp.get_config("track_links_timeout");
                s.event_handler(c, this, u), window.setTimeout(s.track_callback(r, h, u, !0), d), s.mp.track(e, h, s.track_callback(r, h, u))
            })
        }, this), !0
    };
    Fi.prototype.track_callback = function(t, e, n, r) {
        r = r || !1;
        var s = this;
        return function() {
            n.callback_fired || (n.callback_fired = !0, !(t && t(r, e) === !1) && s.after_track_handler(e, n, r))
        }
    };
    Fi.prototype.create_properties = function(t, e) {
        var n;
        return typeof t == "function" ? n = t(e) : n = C.extend({}, t), n
    };
    var Rc = function() {
        this.override_event = "click"
    };
    C.inherit(Rc, Fi);
    Rc.prototype.create_properties = function(t, e) {
        var n = Rc.superclass.create_properties.apply(this, arguments);
        return e.href && (n.url = e.href), n
    };
    Rc.prototype.event_handler = function(t, e, n) {
        n.new_tab = t.which === 2 || t.metaKey || t.ctrlKey || e.target === "_blank", n.href = e.href, n.new_tab || t.preventDefault()
    };
    Rc.prototype.after_track_handler = function(t, e) {
        e.new_tab || setTimeout(function() {
            window.location = e.href
        }, 0)
    };
    var Gp = function() {
        this.override_event = "submit"
    };
    C.inherit(Gp, Fi);
    Gp.prototype.event_handler = function(t, e, n) {
        n.element = e, t.preventDefault()
    };
    Gp.prototype.after_track_handler = function(t, e) {
        setTimeout(function() {
            e.element.submit()
        }, 0)
    };
    var QD = Hy("lock"),
        i4 = function(t, e) {
            e = e || {}, this.storageKey = t, this.storage = e.storage || window.localStorage, this.pollIntervalMS = e.pollIntervalMS || 100, this.timeoutMS = e.timeoutMS || 2e3
        };
    i4.prototype.withLock = function(t, e, n) {
        !n && typeof e != "function" && (n = e, e = null);
        var r = n || new Date().getTime() + "|" + Math.random(),
            s = new Date().getTime(),
            i = this.storageKey,
            a = this.pollIntervalMS,
            c = this.timeoutMS,
            u = this.storage,
            h = i + ":X",
            d = i + ":Y",
            p = i + ":Z",
            m = function(I) {
                e && e(I)
            },
            _ = function(I) {
                if (new Date().getTime() - s > c) {
                    QD.error("Timeout waiting for mutex on " + i + "; clearing lock. [" + r + "]"), u.removeItem(p), u.removeItem(d), w();
                    return
                }
                setTimeout(function() {
                    try {
                        I()
                    } catch (F) {
                        m(F)
                    }
                }, a * (Math.random() + .1))
            },
            y = function(I, F) {
                I() ? F() : _(function() {
                    y(I, F)
                })
            },
            v = function() {
                var I = u.getItem(d);
                if (I && I !== r) return !1;
                if (u.setItem(d, r), u.getItem(d) === r) return !0;
                if (!ld(u, !0)) throw new Error("localStorage support dropped while acquiring lock");
                return !1
            },
            w = function() {
                u.setItem(h, r), y(v, function() {
                    if (u.getItem(h) === r) {
                        b();
                        return
                    }
                    _(function() {
                        if (u.getItem(d) !== r) {
                            w();
                            return
                        }
                        y(function() {
                            return !u.getItem(p)
                        }, b)
                    })
                })
            },
            b = function() {
                u.setItem(p, "1");
                try {
                    t()
                } finally {
                    u.removeItem(p), u.getItem(d) === r && u.removeItem(d), u.getItem(h) === r && u.removeItem(h)
                }
            };
        try {
            if (ld(u, !0)) w();
            else throw new Error("localStorage support check failed")
        } catch (I) {
            m(I)
        }
    };
    var IT = Hy("batch"),
        xo = function(t, e) {
            e = e || {}, this.storageKey = t, this.storage = e.storage || window.localStorage, this.reportError = e.errorReporter || C.bind(IT.error, IT), this.lock = new i4(t, {
                storage: this.storage
            }), this.pid = e.pid || null, this.memQueue = []
        };
    xo.prototype.enqueue = function(t, e, n) {
        var r = {
            id: Ky(),
            flushAfter: new Date().getTime() + e * 2,
            payload: t
        };
        this.lock.withLock(C.bind(function() {
            var i;
            try {
                var a = this.readFromStorage();
                a.push(r), i = this.saveToStorage(a), i && this.memQueue.push(r)
            } catch {
                this.reportError("Error enqueueing item", t), i = !1
            }
            n && n(i)
        }, this), C.bind(function(i) {
            this.reportError("Error acquiring storage lock", i), n && n(!1)
        }, this), this.pid)
    };
    xo.prototype.fillBatch = function(t) {
        var e = this.memQueue.slice(0, t);
        if (e.length < t) {
            var n = this.readFromStorage();
            if (n.length) {
                var r = {};
                C.each(e, function(a) {
                    r[a.id] = !0
                });
                for (var s = 0; s < n.length; s++) {
                    var i = n[s];
                    if (new Date().getTime() > i.flushAfter && !r[i.id] && (i.orphaned = !0, e.push(i), e.length >= t)) break
                }
            }
        }
        return e
    };
    var NT = function(t, e) {
        var n = [];
        return C.each(t, function(r) {
            r.id && !e[r.id] && n.push(r)
        }), n
    };
    xo.prototype.removeItemsByID = function(t, e) {
        var n = {};
        C.each(t, function(s) {
            n[s] = !0
        }), this.memQueue = NT(this.memQueue, n);
        var r = C.bind(function() {
            var s;
            try {
                var i = this.readFromStorage();
                if (i = NT(i, n), s = this.saveToStorage(i), s) {
                    i = this.readFromStorage();
                    for (var a = 0; a < i.length; a++) {
                        var c = i[a];
                        if (c.id && n[c.id]) return this.reportError("Item not removed from storage"), !1
                    }
                }
            } catch {
                this.reportError("Error removing items", t), s = !1
            }
            return s
        }, this);
        this.lock.withLock(function() {
            var i = r();
            e && e(i)
        }, C.bind(function(i) {
            var a = !1;
            if (this.reportError("Error acquiring storage lock", i), !ld(this.storage, !0) && (a = r(), !a)) try {
                this.storage.removeItem(this.storageKey)
            } catch (c) {
                this.reportError("Error clearing queue", c)
            }
            e && e(a)
        }, this), this.pid)
    };
    var xT = function(t, e) {
        var n = [];
        return C.each(t, function(r) {
            var s = r.id;
            if (s in e) {
                var i = e[s];
                i !== null && (r.payload = i, n.push(r))
            } else n.push(r)
        }), n
    };
    xo.prototype.updatePayloads = function(t, e) {
        this.memQueue = xT(this.memQueue, t), this.lock.withLock(C.bind(function() {
            var r;
            try {
                var s = this.readFromStorage();
                s = xT(s, t), r = this.saveToStorage(s)
            } catch {
                this.reportError("Error updating items", t), r = !1
            }
            e && e(r)
        }, this), C.bind(function(r) {
            this.reportError("Error acquiring storage lock", r), e && e(!1)
        }, this), this.pid)
    };
    xo.prototype.readFromStorage = function() {
        var t;
        try {
            t = this.storage.getItem(this.storageKey), t && (t = hd(t), C.isArray(t) || (this.reportError("Invalid storage entry:", t), t = null))
        } catch (e) {
            this.reportError("Error retrieving queue", e), t = null
        }
        return t || []
    };
    xo.prototype.saveToStorage = function(t) {
        try {
            return this.storage.setItem(this.storageKey, ud(t)), !0
        } catch (e) {
            return this.reportError("Error saving queue", e), !1
        }
    };
    xo.prototype.clear = function() {
        this.memQueue = [], this.storage.removeItem(this.storageKey)
    };
    var e$ = 10 * 60 * 1e3,
        Zl = Hy("batch"),
        ii = function(t, e) {
            this.errorReporter = e.errorReporter, this.queue = new xo(t, {
                errorReporter: C.bind(this.reportError, this),
                storage: e.storage
            }), this.libConfig = e.libConfig, this.sendRequest = e.sendRequestFunc, this.beforeSendHook = e.beforeSendHook, this.stopAllBatching = e.stopAllBatchingFunc, this.batchSize = this.libConfig.batch_size, this.flushInterval = this.libConfig.batch_flush_interval_ms, this.stopped = !this.libConfig.batch_autostart, this.consecutiveRemovalFailures = 0
        };
    ii.prototype.enqueue = function(t, e) {
        this.queue.enqueue(t, this.flushInterval, e)
    };
    ii.prototype.start = function() {
        this.stopped = !1, this.consecutiveRemovalFailures = 0, this.flush()
    };
    ii.prototype.stop = function() {
        this.stopped = !0, this.timeoutID && (clearTimeout(this.timeoutID), this.timeoutID = null)
    };
    ii.prototype.clear = function() {
        this.queue.clear()
    };
    ii.prototype.resetBatchSize = function() {
        this.batchSize = this.libConfig.batch_size
    };
    ii.prototype.resetFlush = function() {
        this.scheduleFlush(this.libConfig.batch_flush_interval_ms)
    };
    ii.prototype.scheduleFlush = function(t) {
        this.flushInterval = t, this.stopped || (this.timeoutID = setTimeout(C.bind(this.flush, this), this.flushInterval))
    };
    ii.prototype.flush = function(t) {
        try {
            if (this.requestInProgress) {
                Zl.log("Flush: Request already in progress");
                return
            }
            t = t || {};
            var e = this.libConfig.batch_request_timeout_ms,
                n = new Date().getTime(),
                r = this.batchSize,
                s = this.queue.fillBatch(r),
                i = [],
                a = {};
            if (C.each(s, function(h) {
                    var d = h.payload;
                    this.beforeSendHook && !h.orphaned && (d = this.beforeSendHook(d)), d && i.push(d), a[h.id] = d
                }, this), i.length < 1) {
                this.resetFlush();
                return
            }
            this.requestInProgress = !0;
            var c = C.bind(function(h) {
                    this.requestInProgress = !1;
                    try {
                        var d = !1;
                        if (t.unloading) this.queue.updatePayloads(a);
                        else if (C.isObject(h) && h.error === "timeout" && new Date().getTime() - n >= e) this.reportError("Network timeout; retrying"), this.flush();
                        else if (C.isObject(h) && h.xhr_req && (h.xhr_req.status >= 500 || h.xhr_req.status === 429 || h.error === "timeout")) {
                            var p = this.flushInterval * 2,
                                m = h.xhr_req.responseHeaders;
                            if (m) {
                                var _ = m["Retry-After"];
                                _ && (p = parseInt(_, 10) * 1e3 || p)
                            }
                            p = Math.min(e$, p), this.reportError("Error; retry in " + p + " ms"), this.scheduleFlush(p)
                        } else if (C.isObject(h) && h.xhr_req && h.xhr_req.status === 413)
                            if (s.length > 1) {
                                var y = Math.max(1, Math.floor(r / 2));
                                this.batchSize = Math.min(this.batchSize, y, s.length - 1), this.reportError("413 response; reducing batch size to " + this.batchSize), this.resetFlush()
                            } else this.reportError("Single-event request too large; dropping", s), this.resetBatchSize(), d = !0;
                        else d = !0;
                        d && this.queue.removeItemsByID(C.map(s, function(v) {
                            return v.id
                        }), C.bind(function(v) {
                            v ? (this.consecutiveRemovalFailures = 0, this.flush()) : (this.reportError("Failed to remove items from queue"), ++this.consecutiveRemovalFailures > 5 ? (this.reportError("Too many queue failures; disabling batching system."), this.stopAllBatching()) : this.resetFlush())
                        }, this))
                    } catch (v) {
                        this.reportError("Error handling API response", v), this.resetFlush()
                    }
                }, this),
                u = {
                    method: "POST",
                    verbose: !0,
                    ignore_json_errors: !0,
                    timeout_ms: e
                };
            t.unloading && (u.transport = "sendBeacon"), Zl.log("MIXPANEL REQUEST:", i), this.sendRequest(i, u, c)
        } catch (h) {
            this.reportError("Error flushing request queue", h), this.resetFlush()
        }
    };
    ii.prototype.reportError = function(t, e) {
        if (Zl.error.apply(Zl.error, arguments), this.errorReporter) try {
            e instanceof Error || (e = new Error(t)), this.errorReporter(t, e)
        } catch (n) {
            Zl.error(n)
        }
    };
    var t$ = "__mp_opt_in_out_";

    function n$(t, e) {
        c4(!0, t, e)
    }

    function r$(t, e) {
        c4(!1, t, e)
    }

    function s$(t, e) {
        return a4(t, e) === "1"
    }

    function o4(t, e) {
        if (o$(e)) return Mt.warn('This browser has "Do Not Track" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the "Do Not Track" browser setting, initialize the Mixpanel instance with the config "ignore_dnt: true"'), !0;
        var n = a4(t, e) === "0";
        return n && Mt.warn("You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data."), n
    }

    function Yu(t) {
        return Zy(t, function(e) {
            return this.get_config(e)
        })
    }

    function Po(t) {
        return Zy(t, function(e) {
            return this._get_config(e)
        })
    }

    function tl(t) {
        return Zy(t, function(e) {
            return this._get_config(e)
        })
    }

    function i$(t, e) {
        e = e || {}, Yy(e).remove(zy(t, e), !!e.crossSubdomainCookie, e.cookieDomain)
    }

    function Yy(t) {
        return t = t || {}, t.persistenceType === "localStorage" ? C.localStorage : C.cookie
    }

    function zy(t, e) {
        return e = e || {}, (e.persistencePrefix || t$) + t
    }

    function a4(t, e) {
        return Yy(e).get(zy(t, e))
    }

    function o$(t) {
        if (t && t.ignoreDnt) return !1;
        var e = t && t.window || nr,
            n = e.navigator || {},
            r = !1;
        return C.each([n.doNotTrack, n.msDoNotTrack, e.doNotTrack], function(s) {
            C.includes([!0, 1, "1", "yes"], s) && (r = !0)
        }), r
    }

    function c4(t, e, n) {
        if (!C.isString(e) || !e.length) {
            Mt.error("gdpr." + (t ? "optIn" : "optOut") + " called with an invalid token");
            return
        }
        n = n || {}, Yy(n).set(zy(e, n), t ? 1 : 0, C.isNumber(n.cookieExpiration) ? n.cookieExpiration : null, !!n.crossSubdomainCookie, !!n.secureCookie, !!n.crossSiteCookie, n.cookieDomain), n.track && t && n.track(n.trackEventName || "$opt_in", n.trackProperties, {
            send_immediately: !0
        })
    }

    function Zy(t, e) {
        return function() {
            var n = !1;
            try {
                var r = e.call(this, "token"),
                    s = e.call(this, "ignore_dnt"),
                    i = e.call(this, "opt_out_tracking_persistence_type"),
                    a = e.call(this, "opt_out_tracking_cookie_prefix"),
                    c = e.call(this, "window");
                r && (n = o4(r, {
                    ignoreDnt: s,
                    persistenceType: i,
                    persistencePrefix: a,
                    window: c
                }))
            } catch (h) {
                Mt.error("Unexpected error when checking tracking opt-out status: " + h)
            }
            if (!n) return t.apply(this, arguments);
            var u = arguments[arguments.length - 1];
            typeof u == "function" && u(0)
        }
    }
    var To = "$set",
        Mc = "$set_once",
        ms = "$unset",
        Ea = "$add",
        Ri = "$append",
        Ta = "$union",
        So = "$remove",
        a$ = "$delete",
        l4 = {
            set_action: function(t, e) {
                var n = {},
                    r = {};
                return C.isObject(t) ? C.each(t, function(s, i) {
                    this._is_reserved_property(i) || (r[i] = s)
                }, this) : r[t] = e, n[To] = r, n
            },
            unset_action: function(t) {
                var e = {},
                    n = [];
                return C.isArray(t) || (t = [t]), C.each(t, function(r) {
                    this._is_reserved_property(r) || n.push(r)
                }, this), e[ms] = n, e
            },
            set_once_action: function(t, e) {
                var n = {},
                    r = {};
                return C.isObject(t) ? C.each(t, function(s, i) {
                    this._is_reserved_property(i) || (r[i] = s)
                }, this) : r[t] = e, n[Mc] = r, n
            },
            union_action: function(t, e) {
                var n = {},
                    r = {};
                return C.isObject(t) ? C.each(t, function(s, i) {
                    this._is_reserved_property(i) || (r[i] = C.isArray(s) ? s : [s])
                }, this) : r[t] = C.isArray(e) ? e : [e], n[Ta] = r, n
            },
            append_action: function(t, e) {
                var n = {},
                    r = {};
                return C.isObject(t) ? C.each(t, function(s, i) {
                    this._is_reserved_property(i) || (r[i] = s)
                }, this) : r[t] = e, n[Ri] = r, n
            },
            remove_action: function(t, e) {
                var n = {},
                    r = {};
                return C.isObject(t) ? C.each(t, function(s, i) {
                    this._is_reserved_property(i) || (r[i] = s)
                }, this) : r[t] = e, n[So] = r, n
            },
            delete_action: function() {
                var t = {};
                return t[a$] = "", t
            }
        },
        en = function() {};
    C.extend(en.prototype, l4);
    en.prototype._init = function(t, e, n) {
        this._mixpanel = t, this._group_key = e, this._group_id = n
    };
    en.prototype.set = tl(function(t, e, n) {
        var r = this.set_action(t, e);
        return C.isObject(t) && (n = e), this._send_request(r, n)
    });
    en.prototype.set_once = tl(function(t, e, n) {
        var r = this.set_once_action(t, e);
        return C.isObject(t) && (n = e), this._send_request(r, n)
    });
    en.prototype.unset = tl(function(t, e) {
        var n = this.unset_action(t);
        return this._send_request(n, e)
    });
    en.prototype.union = tl(function(t, e, n) {
        C.isObject(t) && (n = e);
        var r = this.union_action(t, e);
        return this._send_request(r, n)
    });
    en.prototype.delete = tl(function(t) {
        var e = this.delete_action();
        return this._send_request(e, t)
    });
    en.prototype.remove = tl(function(t, e, n) {
        var r = this.remove_action(t, e);
        return this._send_request(r, n)
    });
    en.prototype._send_request = function(t, e) {
        t.$group_key = this._group_key, t.$group_id = this._group_id, t.$token = this._get_config("token");
        var n = C.encodeDates(t);
        return this._mixpanel._track_or_batch({
            type: "groups",
            data: n,
            endpoint: this._get_config("api_host") + "/groups/",
            batcher: this._mixpanel.request_batchers.groups
        }, e)
    };
    en.prototype._is_reserved_property = function(t) {
        return t === "$group_key" || t === "$group_id"
    };
    en.prototype._get_config = function(t) {
        return this._mixpanel.get_config(t)
    };
    en.prototype.toString = function() {
        return this._mixpanel.toString() + ".group." + this._group_key + "." + this._group_id
    };
    en.prototype.remove = en.prototype.remove;
    en.prototype.set = en.prototype.set;
    en.prototype.set_once = en.prototype.set_once;
    en.prototype.union = en.prototype.union;
    en.prototype.unset = en.prototype.unset;
    en.prototype.toString = en.prototype.toString;
    var nt = function() {};
    C.extend(nt.prototype, l4);
    nt.prototype._init = function(t) {
        this._mixpanel = t
    };
    nt.prototype.set = Po(function(t, e, n) {
        var r = this.set_action(t, e);
        return C.isObject(t) && (n = e), this._get_config("save_referrer") && this._mixpanel.persistence.update_referrer_info(document.referrer), r[To] = C.extend({}, C.info.people_properties(), this._mixpanel.persistence.get_referrer_info(), r[To]), this._send_request(r, n)
    });
    nt.prototype.set_once = Po(function(t, e, n) {
        var r = this.set_once_action(t, e);
        return C.isObject(t) && (n = e), this._send_request(r, n)
    });
    nt.prototype.unset = Po(function(t, e) {
        var n = this.unset_action(t);
        return this._send_request(n, e)
    });
    nt.prototype.increment = Po(function(t, e, n) {
        var r = {},
            s = {};
        return C.isObject(t) ? (C.each(t, function(i, a) {
            if (!this._is_reserved_property(a))
                if (isNaN(parseFloat(i))) {
                    Mt.error("Invalid increment value passed to mixpanel.people.increment - must be a number");
                    return
                } else s[a] = i
        }, this), n = e) : (C.isUndefined(e) && (e = 1), s[t] = e), r[Ea] = s, this._send_request(r, n)
    });
    nt.prototype.append = Po(function(t, e, n) {
        C.isObject(t) && (n = e);
        var r = this.append_action(t, e);
        return this._send_request(r, n)
    });
    nt.prototype.remove = Po(function(t, e, n) {
        C.isObject(t) && (n = e);
        var r = this.remove_action(t, e);
        return this._send_request(r, n)
    });
    nt.prototype.union = Po(function(t, e, n) {
        C.isObject(t) && (n = e);
        var r = this.union_action(t, e);
        return this._send_request(r, n)
    });
    nt.prototype.track_charge = Po(function(t, e, n) {
        if (!C.isNumber(t) && (t = parseFloat(t), isNaN(t))) {
            Mt.error("Invalid value passed to mixpanel.people.track_charge - must be a number");
            return
        }
        return this.append("$transactions", C.extend({
            $amount: t
        }, e), n)
    });
    nt.prototype.clear_charges = function(t) {
        return this.set("$transactions", [], t)
    };
    nt.prototype.delete_user = function() {
        if (!this._identify_called()) {
            Mt.error("mixpanel.people.delete_user() requires you to call identify() first");
            return
        }
        var t = {
            $delete: this._mixpanel.get_distinct_id()
        };
        return this._send_request(t)
    };
    nt.prototype.toString = function() {
        return this._mixpanel.toString() + ".people"
    };
    nt.prototype._send_request = function(t, e) {
        t.$token = this._get_config("token"), t.$distinct_id = this._mixpanel.get_distinct_id();
        var n = this._mixpanel.get_property("$device_id"),
            r = this._mixpanel.get_property("$user_id"),
            s = this._mixpanel.get_property("$had_persisted_distinct_id");
        n && (t.$device_id = n), r && (t.$user_id = r), s && (t.$had_persisted_distinct_id = s);
        var i = C.encodeDates(t);
        return this._identify_called() ? this._mixpanel._track_or_batch({
            type: "people",
            data: i,
            endpoint: this._get_config("api_host") + "/engage/",
            batcher: this._mixpanel.request_batchers.people
        }, e) : (this._enqueue(t), C.isUndefined(e) || (this._get_config("verbose") ? e({
            status: -1,
            error: null
        }) : e(-1)), C.truncate(i, 255))
    };
    nt.prototype._get_config = function(t) {
        return this._mixpanel.get_config(t)
    };
    nt.prototype._identify_called = function() {
        return this._mixpanel._flags.identify_called === !0
    };
    nt.prototype._enqueue = function(t) {
        To in t ? this._mixpanel.persistence._add_to_people_queue(To, t) : Mc in t ? this._mixpanel.persistence._add_to_people_queue(Mc, t) : ms in t ? this._mixpanel.persistence._add_to_people_queue(ms, t) : Ea in t ? this._mixpanel.persistence._add_to_people_queue(Ea, t) : Ri in t ? this._mixpanel.persistence._add_to_people_queue(Ri, t) : So in t ? this._mixpanel.persistence._add_to_people_queue(So, t) : Ta in t ? this._mixpanel.persistence._add_to_people_queue(Ta, t) : Mt.error("Invalid call to _enqueue():", t)
    };
    nt.prototype._flush_one_queue = function(t, e, n, r) {
        var s = this,
            i = C.extend({}, this._mixpanel.persistence._get_queue(t)),
            a = i;
        !C.isUndefined(i) && C.isObject(i) && !C.isEmptyObject(i) && (s._mixpanel.persistence._pop_from_people_queue(t, i), r && (a = r(i)), e.call(s, a, function(c, u) {
            c === 0 && s._mixpanel.persistence._add_to_people_queue(t, i), C.isUndefined(n) || n(c, u)
        }))
    };
    nt.prototype._flush = function(t, e, n, r, s, i, a) {
        var c = this,
            u = this._mixpanel.persistence._get_queue(Ri),
            h = this._mixpanel.persistence._get_queue(So);
        if (this._flush_one_queue(To, this.set, t), this._flush_one_queue(Mc, this.set_once, r), this._flush_one_queue(ms, this.unset, i, function(w) {
                return C.keys(w)
            }), this._flush_one_queue(Ea, this.increment, e), this._flush_one_queue(Ta, this.union, s), !C.isUndefined(u) && C.isArray(u) && u.length) {
            for (var d, p = function(w, b) {
                    w === 0 && c._mixpanel.persistence._add_to_people_queue(Ri, d), C.isUndefined(n) || n(w, b)
                }, m = u.length - 1; m >= 0; m--) d = u.pop(), C.isEmptyObject(d) || c.append(d, p);
            c._mixpanel.persistence.save()
        }
        if (!C.isUndefined(h) && C.isArray(h) && h.length) {
            for (var _, y = function(w, b) {
                    w === 0 && c._mixpanel.persistence._add_to_people_queue(So, _), C.isUndefined(a) || a(w, b)
                }, v = h.length - 1; v >= 0; v--) _ = h.pop(), C.isEmptyObject(_) || c.remove(_, y);
            c._mixpanel.persistence.save()
        }
    };
    nt.prototype._is_reserved_property = function(t) {
        return t === "$distinct_id" || t === "$token" || t === "$device_id" || t === "$user_id" || t === "$had_persisted_distinct_id"
    };
    nt.prototype.set = nt.prototype.set;
    nt.prototype.set_once = nt.prototype.set_once;
    nt.prototype.unset = nt.prototype.unset;
    nt.prototype.increment = nt.prototype.increment;
    nt.prototype.append = nt.prototype.append;
    nt.prototype.remove = nt.prototype.remove;
    nt.prototype.union = nt.prototype.union;
    nt.prototype.track_charge = nt.prototype.track_charge;
    nt.prototype.clear_charges = nt.prototype.clear_charges;
    nt.prototype.delete_user = nt.prototype.delete_user;
    nt.prototype.toString = nt.prototype.toString;
    var Xy = "__mps",
        Jy = "__mpso",
        Qy = "__mpus",
        ev = "__mpa",
        tv = "__mpap",
        nv = "__mpr",
        rv = "__mpu",
        u4 = "$people_distinct_id",
        fd = "__alias",
        gu = "__timers",
        c$ = [Xy, Jy, Qy, ev, tv, nv, rv, u4, fd, gu],
        pt = function(t) {
            this.props = {}, this.campaign_params_saved = !1, t.persistence_name ? this.name = "mp_" + t.persistence_name : this.name = "mp_" + t.token + "_mixpanel";
            var e = t.persistence;
            e !== "cookie" && e !== "localStorage" && (Mt.critical("Unknown persistence type " + e + "; falling back to cookie"), e = t.persistence = "cookie"), e === "localStorage" && C.localStorage.is_supported() ? this.storage = C.localStorage : this.storage = C.cookie, this.load(), this.update_config(t), this.upgrade(t), this.save()
        };
    pt.prototype.properties = function() {
        var t = {};
        return C.each(this.props, function(e, n) {
            C.include(c$, n) || (t[n] = e)
        }), t
    };
    pt.prototype.load = function() {
        if (!this.disabled) {
            var t = this.storage.parse(this.name);
            t && (this.props = C.extend({}, t))
        }
    };
    pt.prototype.upgrade = function(t) {
        var e = t.upgrade,
            n, r;
        e && (n = "mp_super_properties", typeof e == "string" && (n = e), r = this.storage.parse(n), this.storage.remove(n), this.storage.remove(n, !0), r && (this.props = C.extend(this.props, r.all, r.events))), !t.cookie_name && t.name !== "mixpanel" && (n = "mp_" + t.token + "_" + t.name, r = this.storage.parse(n), r && (this.storage.remove(n), this.storage.remove(n, !0), this.register_once(r))), this.storage === C.localStorage && (r = C.cookie.parse(this.name), C.cookie.remove(this.name), C.cookie.remove(this.name, !0), r && this.register_once(r))
    };
    pt.prototype.save = function() {
        this.disabled || this.storage.set(this.name, C.JSONEncode(this.props), this.expire_days, this.cross_subdomain, this.secure, this.cross_site, this.cookie_domain)
    };
    pt.prototype.remove = function() {
        this.storage.remove(this.name, !1, this.cookie_domain), this.storage.remove(this.name, !0, this.cookie_domain)
    };
    pt.prototype.clear = function() {
        this.remove(), this.props = {}
    };
    pt.prototype.register_once = function(t, e, n) {
        return C.isObject(t) ? (typeof e > "u" && (e = "None"), this.expire_days = typeof n > "u" ? this.default_expiry : n, C.each(t, function(r, s) {
            (!this.props.hasOwnProperty(s) || this.props[s] === e) && (this.props[s] = r)
        }, this), this.save(), !0) : !1
    };
    pt.prototype.register = function(t, e) {
        return C.isObject(t) ? (this.expire_days = typeof e > "u" ? this.default_expiry : e, C.extend(this.props, t), this.save(), !0) : !1
    };
    pt.prototype.unregister = function(t) {
        t in this.props && (delete this.props[t], this.save())
    };
    pt.prototype.update_campaign_params = function() {
        this.campaign_params_saved || (this.register_once(C.info.campaignParams()), this.campaign_params_saved = !0)
    };
    pt.prototype.update_search_keyword = function(t) {
        this.register(C.info.searchInfo(t))
    };
    pt.prototype.update_referrer_info = function(t) {
        this.register_once({
            $initial_referrer: t || "$direct",
            $initial_referring_domain: C.info.referringDomain(t) || "$direct"
        }, "")
    };
    pt.prototype.get_referrer_info = function() {
        return C.strip_empty_properties({
            $initial_referrer: this.props.$initial_referrer,
            $initial_referring_domain: this.props.$initial_referring_domain
        })
    };
    pt.prototype.safe_merge = function(t) {
        return C.each(this.props, function(e, n) {
            n in t || (t[n] = e)
        }), t
    };
    pt.prototype.update_config = function(t) {
        this.default_expiry = this.expire_days = t.cookie_expiration, this.set_disabled(t.disable_persistence), this.set_cookie_domain(t.cookie_domain), this.set_cross_site(t.cross_site_cookie), this.set_cross_subdomain(t.cross_subdomain_cookie), this.set_secure(t.secure_cookie)
    };
    pt.prototype.set_disabled = function(t) {
        this.disabled = t, this.disabled ? this.remove() : this.save()
    };
    pt.prototype.set_cookie_domain = function(t) {
        t !== this.cookie_domain && (this.remove(), this.cookie_domain = t, this.save())
    };
    pt.prototype.set_cross_site = function(t) {
        t !== this.cross_site && (this.cross_site = t, this.remove(), this.save())
    };
    pt.prototype.set_cross_subdomain = function(t) {
        t !== this.cross_subdomain && (this.cross_subdomain = t, this.remove(), this.save())
    };
    pt.prototype.get_cross_subdomain = function() {
        return this.cross_subdomain
    };
    pt.prototype.set_secure = function(t) {
        t !== this.secure && (this.secure = !!t, this.remove(), this.save())
    };
    pt.prototype._add_to_people_queue = function(t, e) {
        var n = this._get_queue_key(t),
            r = e[t],
            s = this._get_or_create_queue(To),
            i = this._get_or_create_queue(Mc),
            a = this._get_or_create_queue(ms),
            c = this._get_or_create_queue(Ea),
            u = this._get_or_create_queue(Ta),
            h = this._get_or_create_queue(So, []),
            d = this._get_or_create_queue(Ri, []);
        n === Xy ? (C.extend(s, r), this._pop_from_people_queue(Ea, r), this._pop_from_people_queue(Ta, r), this._pop_from_people_queue(ms, r)) : n === Jy ? (C.each(r, function(p, m) {
            m in i || (i[m] = p)
        }), this._pop_from_people_queue(ms, r)) : n === Qy ? C.each(r, function(p) {
            C.each([s, i, c, u], function(m) {
                p in m && delete m[p]
            }), C.each(d, function(m) {
                p in m && delete m[p]
            }), a[p] = !0
        }) : n === ev ? (C.each(r, function(p, m) {
            m in s ? s[m] += p : (m in c || (c[m] = 0), c[m] += p)
        }, this), this._pop_from_people_queue(ms, r)) : n === rv ? (C.each(r, function(p, m) {
            C.isArray(p) && (m in u || (u[m] = []), u[m] = u[m].concat(p))
        }), this._pop_from_people_queue(ms, r)) : n === nv ? (h.push(r), this._pop_from_people_queue(Ri, r)) : n === tv && (d.push(r), this._pop_from_people_queue(ms, r)), Mt.log("MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):"), Mt.log(e), this.save()
    };
    pt.prototype._pop_from_people_queue = function(t, e) {
        var n = this._get_queue(t);
        C.isUndefined(n) || (C.each(e, function(r, s) {
            t === Ri || t === So ? C.each(n, function(i) {
                i[s] === r && delete i[s]
            }) : delete n[s]
        }, this), this.save())
    };
    pt.prototype._get_queue_key = function(t) {
        if (t === To) return Xy;
        if (t === Mc) return Jy;
        if (t === ms) return Qy;
        if (t === Ea) return ev;
        if (t === Ri) return tv;
        if (t === So) return nv;
        if (t === Ta) return rv;
        Mt.error("Invalid queue:", t)
    };
    pt.prototype._get_queue = function(t) {
        return this.props[this._get_queue_key(t)]
    };
    pt.prototype._get_or_create_queue = function(t, e) {
        var n = this._get_queue_key(t);
        return e = C.isUndefined(e) ? {} : e, this.props[n] || (this.props[n] = e)
    };
    pt.prototype.set_event_timer = function(t, e) {
        var n = this.props[gu] || {};
        n[t] = e, this.props[gu] = n, this.save()
    };
    pt.prototype.remove_event_timer = function(t) {
        var e = this.props[gu] || {},
            n = e[t];
        return C.isUndefined(n) || (delete this.props[gu][t], this.save()), n
    };
    var sv, Qn, h4 = 0,
        l$ = 1,
        u$ = function(t) {
            return t
        },
        _u = function() {},
        Qr = "mixpanel",
        f4 = "base64",
        h$ = "json",
        yc = nr.XMLHttpRequest && "withCredentials" in new XMLHttpRequest,
        d4 = !yc && ps.indexOf("MSIE") === -1 && ps.indexOf("Mozilla") === -1,
        dd = null;
    Ai.sendBeacon && (dd = function() {
        return Ai.sendBeacon.apply(Ai, arguments)
    });
    var PT = {
            api_host: "https://api-js.mixpanel.com",
            api_method: "POST",
            api_transport: "XHR",
            api_payload_format: f4,
            app_host: "https://mixpanel.com",
            cdn: "https://cdn.mxpnl.com",
            cross_site_cookie: !1,
            cross_subdomain_cookie: !0,
            error_reporter: _u,
            persistence: "cookie",
            persistence_name: "",
            cookie_domain: "",
            cookie_name: "",
            loaded: _u,
            store_google: !0,
            save_referrer: !0,
            test: !1,
            verbose: !1,
            img: !1,
            debug: !1,
            track_links_timeout: 300,
            cookie_expiration: 365,
            upgrade: !1,
            disable_persistence: !1,
            disable_cookie: !1,
            secure_cookie: !1,
            ip: !0,
            opt_out_tracking_by_default: !1,
            opt_out_persistence_by_default: !1,
            opt_out_tracking_persistence_type: "localStorage",
            opt_out_tracking_cookie_prefix: null,
            property_blacklist: [],
            xhr_headers: {},
            ignore_dnt: !1,
            batch_requests: !0,
            batch_size: 50,
            batch_flush_interval_ms: 5e3,
            batch_request_timeout_ms: 9e4,
            batch_autostart: !0,
            hooks: {}
        },
        p4 = !1,
        ge = function() {},
        h1 = function(t, e, n) {
            var r, s = n === Qr ? Qn : Qn[n];
            if (s && sv === h4) r = s;
            else {
                if (s && !C.isArray(s)) {
                    Mt.error("You have already initialized " + n);
                    return
                }
                r = new ge
            }
            return r._cached_groups = {}, r._init(t, e, n), r.people = new nt, r.people._init(r), go.DEBUG = go.DEBUG || r.get_config("debug"), !C.isUndefined(s) && C.isArray(s) && (r._execute_array.call(r.people, s.people), r._execute_array(s)), r
        };
    ge.prototype.init = function(t, e, n) {
        if (C.isUndefined(n)) {
            this.report_error("You must name your new library: init(token, config, name)");
            return
        }
        if (n === Qr) {
            this.report_error("You must initialize the main mixpanel object right after you include the Mixpanel js snippet");
            return
        }
        var r = h1(t, e, n);
        return Qn[n] = r, r._loaded(), r
    };
    ge.prototype._init = function(t, e, n) {
        e = e || {}, this.__loaded = !0, this.config = {};
        var r = {};
        if (!("api_payload_format" in e)) {
            var s = e.api_host || PT.api_host;
            s.match(/\.mixpanel\.com$/) && (r.api_payload_format = h$)
        }
        if (this.set_config(C.extend({}, PT, r, e, {
                name: n,
                token: t,
                callback_fn: (n === Qr ? n : Qr + "." + n) + "._jsc"
            })), this._jsc = _u, this.__dom_loaded_queue = [], this.__request_queue = [], this.__disabled_events = [], this._flags = {
                disable_all_events: !1,
                identify_called: !1
            }, this.request_batchers = {}, this._batch_requests = this.get_config("batch_requests"), this._batch_requests) {
            if (!C.localStorage.is_supported(!0) || !yc) this._batch_requests = !1, Mt.log("Turning off Mixpanel request-queueing; needs XHR and localStorage support");
            else if (this.init_batchers(), dd && nr.addEventListener) {
                var i = C.bind(function() {
                    this.request_batchers.events.stopped || this.request_batchers.events.flush({
                        unloading: !0
                    })
                }, this);
                nr.addEventListener("pagehide", function(c) {
                    c.persisted && i()
                }), nr.addEventListener("visibilitychange", function() {
                    Ft.visibilityState === "hidden" && i()
                })
            }
        }
        this.persistence = this.cookie = new pt(this.config), this.unpersisted_superprops = {}, this._gdpr_init();
        var a = C.UUID();
        this.get_distinct_id() || this.register_once({
            distinct_id: a,
            $device_id: a
        }, "")
    };
    ge.prototype._loaded = function() {
        this.get_config("loaded")(this), this._set_default_superprops()
    };
    ge.prototype._set_default_superprops = function() {
        this.persistence.update_search_keyword(Ft.referrer), this.get_config("store_google") && this.persistence.update_campaign_params(), this.get_config("save_referrer") && this.persistence.update_referrer_info(Ft.referrer)
    };
    ge.prototype._dom_loaded = function() {
        C.each(this.__dom_loaded_queue, function(t) {
            this._track_dom.apply(this, t)
        }, this), this.has_opted_out_tracking() || C.each(this.__request_queue, function(t) {
            this._send_request.apply(this, t)
        }, this), delete this.__dom_loaded_queue, delete this.__request_queue
    };
    ge.prototype._track_dom = function(t, e) {
        if (this.get_config("img")) return this.report_error("You can't use DOM tracking functions with img = true."), !1;
        if (!p4) return this.__dom_loaded_queue.push([t, e]), !1;
        var n = new t().init(this);
        return n.track.apply(n, e)
    };
    ge.prototype._prepare_callback = function(t, e) {
        if (C.isUndefined(t)) return null;
        if (yc) {
            var n = function(a) {
                t(a, e)
            };
            return n
        } else {
            var r = this._jsc,
                s = "" + Math.floor(Math.random() * 1e8),
                i = this.get_config("callback_fn") + "[" + s + "]";
            return r[s] = function(a) {
                delete r[s], t(a, e)
            }, i
        }
    };
    ge.prototype._send_request = function(t, e, n, r) {
        var s = !0;
        if (d4) return this.__request_queue.push(arguments), s;
        var i = {
                method: this.get_config("api_method"),
                transport: this.get_config("api_transport"),
                verbose: this.get_config("verbose")
            },
            a = null;
        !r && (C.isFunction(n) || typeof n == "string") && (r = n, n = null), n = C.extend(i, n || {}), yc || (n.method = "GET");
        var c = n.method === "POST",
            u = dd && c && n.transport.toLowerCase() === "sendbeacon",
            h = n.verbose;
        e.verbose && (h = !0), this.get_config("test") && (e.test = 1), h && (e.verbose = 1), this.get_config("img") && (e.img = 1), yc || (r ? e.callback = r : (h || this.get_config("test")) && (e.callback = "(function(){})")), e.ip = this.get_config("ip") ? 1 : 0, e._ = new Date().getTime().toString(), c && (a = "data=" + encodeURIComponent(e.data), delete e.data), t += "?" + C.HTTPBuildQuery(e);
        var d = this;
        if ("img" in e) {
            var p = Ft.createElement("img");
            p.src = t, Ft.body.appendChild(p)
        } else if (u) {
            try {
                s = dd(t, a)
            } catch (b) {
                d.report_error(b), s = !1
            }
            try {
                r && r(s ? 1 : 0)
            } catch (b) {
                d.report_error(b)
            }
        } else if (yc) try {
            var m = new XMLHttpRequest;
            m.open(n.method, t, !0);
            var _ = this.get_config("xhr_headers");
            if (c && (_["Content-Type"] = "application/x-www-form-urlencoded"), C.each(_, function(b, I) {
                    m.setRequestHeader(I, b)
                }), n.timeout_ms && typeof m.timeout < "u") {
                m.timeout = n.timeout_ms;
                var y = new Date().getTime()
            }
            m.withCredentials = !0, m.onreadystatechange = function() {
                if (m.readyState === 4)
                    if (m.status === 200) {
                        if (r)
                            if (h) {
                                var b;
                                try {
                                    b = C.JSONDecode(m.responseText)
                                } catch (F) {
                                    if (d.report_error(F), n.ignore_json_errors) b = m.responseText;
                                    else return
                                }
                                r(b)
                            } else r(Number(m.responseText))
                    } else {
                        var I;
                        m.timeout && !m.status && new Date().getTime() - y >= m.timeout ? I = "timeout" : I = "Bad HTTP status: " + m.status + " " + m.statusText, d.report_error(I), r && r(h ? {
                            status: 0,
                            error: I,
                            xhr_req: m
                        } : 0)
                    }
            }, m.send(a)
        } catch (b) {
            d.report_error(b), s = !1
        } else {
            var v = Ft.createElement("script");
            v.type = "text/javascript", v.async = !0, v.defer = !0, v.src = t;
            var w = Ft.getElementsByTagName("script")[0];
            w.parentNode.insertBefore(v, w)
        }
        return s
    };
    ge.prototype._execute_array = function(t) {
        var e, n = [],
            r = [],
            s = [];
        C.each(t, function(a) {
            a && (e = a[0], C.isArray(e) ? s.push(a) : typeof a == "function" ? a.call(this) : C.isArray(a) && e === "alias" ? n.push(a) : C.isArray(a) && e.indexOf("track") !== -1 && typeof this[e] == "function" ? s.push(a) : r.push(a))
        }, this);
        var i = function(a, c) {
            C.each(a, function(u) {
                if (C.isArray(u[0])) {
                    var h = c;
                    C.each(u, function(d) {
                        h = h[d[0]].apply(h, d.slice(1))
                    })
                } else this[u[0]].apply(this, u.slice(1))
            }, c)
        };
        i(n, this), i(r, this), i(s, this)
    };
    ge.prototype.are_batchers_initialized = function() {
        return !!this.request_batchers.events
    };
    ge.prototype.init_batchers = function() {
        var t = this.get_config("token");
        if (!this.are_batchers_initialized()) {
            var e = C.bind(function(n) {
                return new ii("__mpq_" + t + n.queue_suffix, {
                    libConfig: this.config,
                    sendRequestFunc: C.bind(function(r, s, i) {
                        this._send_request(this.get_config("api_host") + n.endpoint, this._encode_data_for_request(r), s, this._prepare_callback(i, r))
                    }, this),
                    beforeSendHook: C.bind(function(r) {
                        return this._run_hook("before_send_" + n.type, r)
                    }, this),
                    errorReporter: this.get_config("error_reporter"),
                    stopAllBatchingFunc: C.bind(this.stop_batch_senders, this)
                })
            }, this);
            this.request_batchers = {
                events: e({
                    type: "events",
                    endpoint: "/track/",
                    queue_suffix: "_ev"
                }),
                people: e({
                    type: "people",
                    endpoint: "/engage/",
                    queue_suffix: "_pp"
                }),
                groups: e({
                    type: "groups",
                    endpoint: "/groups/",
                    queue_suffix: "_gr"
                })
            }
        }
        this.get_config("batch_autostart") && this.start_batch_senders()
    };
    ge.prototype.start_batch_senders = function() {
        this.are_batchers_initialized() && (this._batch_requests = !0, C.each(this.request_batchers, function(t) {
            t.start()
        }))
    };
    ge.prototype.stop_batch_senders = function() {
        this._batch_requests = !1, C.each(this.request_batchers, function(t) {
            t.stop(), t.clear()
        })
    };
    ge.prototype.push = function(t) {
        this._execute_array([t])
    };
    ge.prototype.disable = function(t) {
        typeof t > "u" ? this._flags.disable_all_events = !0 : this.__disabled_events = this.__disabled_events.concat(t)
    };
    ge.prototype._encode_data_for_request = function(t) {
        var e = C.JSONEncode(t);
        return this.get_config("api_payload_format") === f4 && (e = C.base64Encode(e)), {
            data: e
        }
    };
    ge.prototype._track_or_batch = function(t, e) {
        var n = C.truncate(t.data, 255),
            r = t.endpoint,
            s = t.batcher,
            i = t.should_send_immediately,
            a = t.send_request_options || {};
        e = e || _u;
        var c = !0,
            u = C.bind(function() {
                return a.skip_hooks || (n = this._run_hook("before_send_" + t.type, n)), n ? (Mt.log("MIXPANEL REQUEST:"), Mt.log(n), this._send_request(r, this._encode_data_for_request(n), a, this._prepare_callback(e, n))) : null
            }, this);
        return this._batch_requests && !i ? s.enqueue(n, function(h) {
            h ? e(1, n) : u()
        }) : c = u(), c && n
    };
    ge.prototype.track = Yu(function(t, e, n, r) {
        !r && typeof n == "function" && (r = n, n = null), n = n || {};
        var s = n.transport;
        s && (n.transport = s);
        var i = n.send_immediately;
        if (typeof r != "function" && (r = _u), C.isUndefined(t)) {
            this.report_error("No event name provided to mixpanel.track");
            return
        }
        if (this._event_is_disabled(t)) {
            r(0);
            return
        }
        e = e || {}, e.token = this.get_config("token");
        var a = this.persistence.remove_event_timer(t);
        if (!C.isUndefined(a)) {
            var c = new Date().getTime() - a;
            e.$duration = parseFloat((c / 1e3).toFixed(3))
        }
        this._set_default_superprops(), e = C.extend({}, C.info.properties(), this.persistence.properties(), this.unpersisted_superprops, e);
        var u = this.get_config("property_blacklist");
        C.isArray(u) ? C.each(u, function(p) {
            delete e[p]
        }) : this.report_error("Invalid value for property_blacklist config: " + u);
        var h = {
                event: t,
                properties: e
            },
            d = this._track_or_batch({
                type: "events",
                data: h,
                endpoint: this.get_config("api_host") + "/track/",
                batcher: this.request_batchers.events,
                should_send_immediately: i,
                send_request_options: n
            }, r);
        return d
    });
    ge.prototype.set_group = Yu(function(t, e, n) {
        C.isArray(e) || (e = [e]);
        var r = {};
        return r[t] = e, this.register(r), this.people.set(t, e, n)
    });
    ge.prototype.add_group = Yu(function(t, e, n) {
        var r = this.get_property(t);
        if (r === void 0) {
            var s = {};
            s[t] = [e], this.register(s)
        } else r.indexOf(e) === -1 && (r.push(e), this.register(s));
        return this.people.union(t, e, n)
    });
    ge.prototype.remove_group = Yu(function(t, e, n) {
        var r = this.get_property(t);
        if (r !== void 0) {
            var s = r.indexOf(e);
            s > -1 && (r.splice(s, 1), this.register({
                group_key: r
            })), r.length === 0 && this.unregister(t)
        }
        return this.people.remove(t, e, n)
    });
    ge.prototype.track_with_groups = Yu(function(t, e, n, r) {
        var s = C.extend({}, e || {});
        return C.each(n, function(i, a) {
            i != null && (s[a] = i)
        }), this.track(t, s, r)
    });
    ge.prototype._create_map_key = function(t, e) {
        return t + "_" + JSON.stringify(e)
    };
    ge.prototype._remove_group_from_cache = function(t, e) {
        delete this._cached_groups[this._create_map_key(t, e)]
    };
    ge.prototype.get_group = function(t, e) {
        var n = this._create_map_key(t, e),
            r = this._cached_groups[n];
        return (r === void 0 || r._group_key !== t || r._group_id !== e) && (r = new en, r._init(this, t, e), this._cached_groups[n] = r), r
    };
    ge.prototype.track_pageview = function(t) {
        C.isUndefined(t) && (t = Ft.location.href), this.track("mp_page_view", C.info.pageviewInfo(t))
    };
    ge.prototype.track_links = function() {
        return this._track_dom.call(this, Rc, arguments)
    };
    ge.prototype.track_forms = function() {
        return this._track_dom.call(this, Gp, arguments)
    };
    ge.prototype.time_event = function(t) {
        if (C.isUndefined(t)) {
            this.report_error("No event name provided to mixpanel.time_event");
            return
        }
        this._event_is_disabled(t) || this.persistence.set_event_timer(t, new Date().getTime())
    };
    var f$ = {
            persistent: !0
        },
        iv = function(t) {
            var e;
            return C.isObject(t) ? e = t : C.isUndefined(t) ? e = {} : e = {
                days: t
            }, C.extend({}, f$, e)
        };
    ge.prototype.register = function(t, e) {
        var n = iv(e);
        n.persistent ? this.persistence.register(t, n.days) : C.extend(this.unpersisted_superprops, t)
    };
    ge.prototype.register_once = function(t, e, n) {
        var r = iv(n);
        r.persistent ? this.persistence.register_once(t, e, r.days) : (typeof e > "u" && (e = "None"), C.each(t, function(s, i) {
            (!this.unpersisted_superprops.hasOwnProperty(i) || this.unpersisted_superprops[i] === e) && (this.unpersisted_superprops[i] = s)
        }, this))
    };
    ge.prototype.unregister = function(t, e) {
        e = iv(e), e.persistent ? this.persistence.unregister(t) : delete this.unpersisted_superprops[t]
    };
    ge.prototype._register_single = function(t, e) {
        var n = {};
        n[t] = e, this.register(n)
    };
    ge.prototype.identify = function(t, e, n, r, s, i, a, c) {
        var u = this.get_distinct_id();
        if (this.register({
                $user_id: t
            }), !this.get_property("$device_id")) {
            var h = u;
            this.register_once({
                $had_persisted_distinct_id: !0,
                $device_id: h
            }, "")
        }
        t !== u && t !== this.get_property(fd) && (this.unregister(fd), this.register({
            distinct_id: t
        })), this._flags.identify_called = !0, this.people._flush(e, n, r, s, i, a, c), t !== u && this.track("$identify", {
            distinct_id: t,
            $anon_distinct_id: u
        }, {
            skip_hooks: !0
        })
    };
    ge.prototype.reset = function() {
        this.persistence.clear(), this._flags.identify_called = !1;
        var t = C.UUID();
        this.register_once({
            distinct_id: t,
            $device_id: t
        }, "")
    };
    ge.prototype.get_distinct_id = function() {
        return this.get_property("distinct_id")
    };
    ge.prototype.alias = function(t, e) {
        if (t === this.get_property(u4)) return this.report_error("Attempting to create alias for existing People user - aborting."), -2;
        var n = this;
        return C.isUndefined(e) && (e = this.get_distinct_id()), t !== e ? (this._register_single(fd, t), this.track("$create_alias", {
            alias: t,
            distinct_id: e
        }, {
            skip_hooks: !0
        }, function() {
            n.identify(t)
        })) : (this.report_error("alias matches current distinct_id - skipping api call."), this.identify(t), -1)
    };
    ge.prototype.name_tag = function(t) {
        this._register_single("mp_name_tag", t)
    };
    ge.prototype.set_config = function(t) {
        if (C.isObject(t)) {
            C.extend(this.config, t);
            var e = t.batch_size;
            e && C.each(this.request_batchers, function(n) {
                n.resetBatchSize()
            }), this.get_config("persistence_name") || (this.config.persistence_name = this.config.cookie_name), this.get_config("disable_persistence") || (this.config.disable_persistence = this.config.disable_cookie), this.persistence && this.persistence.update_config(this.config), go.DEBUG = go.DEBUG || this.get_config("debug")
        }
    };
    ge.prototype.get_config = function(t) {
        return this.config[t]
    };
    ge.prototype._run_hook = function(t) {
        var e = (this.config.hooks[t] || u$).apply(this, uo.call(arguments, 1));
        return typeof e > "u" && (this.report_error(t + " hook did not return a value"), e = null), e
    };
    ge.prototype.get_property = function(t) {
        return this.persistence.props[t]
    };
    ge.prototype.toString = function() {
        var t = this.get_config("name");
        return t !== Qr && (t = Qr + "." + t), t
    };
    ge.prototype._event_is_disabled = function(t) {
        return C.isBlockedUA(ps) || this._flags.disable_all_events || C.include(this.__disabled_events, t)
    };
    ge.prototype._gdpr_init = function() {
        var t = this.get_config("opt_out_tracking_persistence_type") === "localStorage";
        t && C.localStorage.is_supported() && (!this.has_opted_in_tracking() && this.has_opted_in_tracking({
            persistence_type: "cookie"
        }) && this.opt_in_tracking({
            enable_persistence: !1
        }), !this.has_opted_out_tracking() && this.has_opted_out_tracking({
            persistence_type: "cookie"
        }) && this.opt_out_tracking({
            clear_persistence: !1
        }), this.clear_opt_in_out_tracking({
            persistence_type: "cookie",
            enable_persistence: !1
        })), this.has_opted_out_tracking() ? this._gdpr_update_persistence({
            clear_persistence: !0
        }) : !this.has_opted_in_tracking() && (this.get_config("opt_out_tracking_by_default") || C.cookie.get("mp_optout")) && (C.cookie.remove("mp_optout"), this.opt_out_tracking({
            clear_persistence: this.get_config("opt_out_persistence_by_default")
        }))
    };
    ge.prototype._gdpr_update_persistence = function(t) {
        var e;
        if (t && t.clear_persistence) e = !0;
        else if (t && t.enable_persistence) e = !1;
        else return;
        !this.get_config("disable_persistence") && this.persistence.disabled !== e && this.persistence.set_disabled(e), e && C.each(this.request_batchers, function(n) {
            n.clear()
        })
    };
    ge.prototype._gdpr_call_func = function(t, e) {
        return e = C.extend({
            track: C.bind(this.track, this),
            persistence_type: this.get_config("opt_out_tracking_persistence_type"),
            cookie_prefix: this.get_config("opt_out_tracking_cookie_prefix"),
            cookie_expiration: this.get_config("cookie_expiration"),
            cross_site_cookie: this.get_config("cross_site_cookie"),
            cross_subdomain_cookie: this.get_config("cross_subdomain_cookie"),
            cookie_domain: this.get_config("cookie_domain"),
            secure_cookie: this.get_config("secure_cookie"),
            ignore_dnt: this.get_config("ignore_dnt")
        }, e), C.localStorage.is_supported() || (e.persistence_type = "cookie"), t(this.get_config("token"), {
            track: e.track,
            trackEventName: e.track_event_name,
            trackProperties: e.track_properties,
            persistenceType: e.persistence_type,
            persistencePrefix: e.cookie_prefix,
            cookieDomain: e.cookie_domain,
            cookieExpiration: e.cookie_expiration,
            crossSiteCookie: e.cross_site_cookie,
            crossSubdomainCookie: e.cross_subdomain_cookie,
            secureCookie: e.secure_cookie,
            ignoreDnt: e.ignore_dnt
        })
    };
    ge.prototype.opt_in_tracking = function(t) {
        t = C.extend({
            enable_persistence: !0
        }, t), this._gdpr_call_func(n$, t), this._gdpr_update_persistence(t)
    };
    ge.prototype.opt_out_tracking = function(t) {
        t = C.extend({
            clear_persistence: !0,
            delete_user: !0
        }, t), t.delete_user && this.people && this.people._identify_called() && (this.people.delete_user(), this.people.clear_charges()), this._gdpr_call_func(r$, t), this._gdpr_update_persistence(t)
    };
    ge.prototype.has_opted_in_tracking = function(t) {
        return this._gdpr_call_func(s$, t)
    };
    ge.prototype.has_opted_out_tracking = function(t) {
        return this._gdpr_call_func(o4, t)
    };
    ge.prototype.clear_opt_in_out_tracking = function(t) {
        t = C.extend({
            enable_persistence: !0
        }, t), this._gdpr_call_func(i$, t), this._gdpr_update_persistence(t)
    };
    ge.prototype.report_error = function(t, e) {
        Mt.error.apply(Mt.error, arguments);
        try {
            !e && !(t instanceof Error) && (t = new Error(t)), this.get_config("error_reporter")(t, e)
        } catch (n) {
            Mt.error(n)
        }
    };
    ge.prototype.init = ge.prototype.init;
    ge.prototype.reset = ge.prototype.reset;
    ge.prototype.disable = ge.prototype.disable;
    ge.prototype.time_event = ge.prototype.time_event;
    ge.prototype.track = ge.prototype.track;
    ge.prototype.track_links = ge.prototype.track_links;
    ge.prototype.track_forms = ge.prototype.track_forms;
    ge.prototype.track_pageview = ge.prototype.track_pageview;
    ge.prototype.register = ge.prototype.register;
    ge.prototype.register_once = ge.prototype.register_once;
    ge.prototype.unregister = ge.prototype.unregister;
    ge.prototype.identify = ge.prototype.identify;
    ge.prototype.alias = ge.prototype.alias;
    ge.prototype.name_tag = ge.prototype.name_tag;
    ge.prototype.set_config = ge.prototype.set_config;
    ge.prototype.get_config = ge.prototype.get_config;
    ge.prototype.get_property = ge.prototype.get_property;
    ge.prototype.get_distinct_id = ge.prototype.get_distinct_id;
    ge.prototype.toString = ge.prototype.toString;
    ge.prototype.opt_out_tracking = ge.prototype.opt_out_tracking;
    ge.prototype.opt_in_tracking = ge.prototype.opt_in_tracking;
    ge.prototype.has_opted_out_tracking = ge.prototype.has_opted_out_tracking;
    ge.prototype.has_opted_in_tracking = ge.prototype.has_opted_in_tracking;
    ge.prototype.clear_opt_in_out_tracking = ge.prototype.clear_opt_in_out_tracking;
    ge.prototype.get_group = ge.prototype.get_group;
    ge.prototype.set_group = ge.prototype.set_group;
    ge.prototype.add_group = ge.prototype.add_group;
    ge.prototype.remove_group = ge.prototype.remove_group;
    ge.prototype.track_with_groups = ge.prototype.track_with_groups;
    ge.prototype.start_batch_senders = ge.prototype.start_batch_senders;
    ge.prototype.stop_batch_senders = ge.prototype.stop_batch_senders;
    pt.prototype.properties = pt.prototype.properties;
    pt.prototype.update_search_keyword = pt.prototype.update_search_keyword;
    pt.prototype.update_referrer_info = pt.prototype.update_referrer_info;
    pt.prototype.get_cross_subdomain = pt.prototype.get_cross_subdomain;
    pt.prototype.clear = pt.prototype.clear;
    var oc = {},
        d$ = function() {
            C.each(oc, function(t, e) {
                e !== Qr && (Qn[e] = t)
            }), Qn._ = C
        },
        p$ = function() {
            Qn.init = function(t, e, n) {
                if (n) return Qn[n] || (Qn[n] = oc[n] = h1(t, e, n), Qn[n]._loaded()), Qn[n];
                var r = Qn;
                oc[Qr] ? r = oc[Qr] : t && (r = h1(t, e, Qr), r._loaded(), oc[Qr] = r), Qn = r, sv === l$ && (nr[Qr] = Qn), d$()
            }
        },
        m$ = function() {
            function t() {
                t.done || (t.done = !0, p4 = !0, d4 = !1, C.each(oc, function(r) {
                    r._dom_loaded()
                }))
            }

            function e() {
                try {
                    Ft.documentElement.doScroll("left")
                } catch {
                    setTimeout(e, 1);
                    return
                }
                t()
            }
            if (Ft.addEventListener) Ft.readyState === "complete" ? t() : Ft.addEventListener("DOMContentLoaded", t, !1);
            else if (Ft.attachEvent) {
                Ft.attachEvent("onreadystatechange", t);
                var n = !1;
                try {
                    n = nr.frameElement === null
                } catch {}
                Ft.documentElement.doScroll && n && e()
            }
            C.register_event(nr, "load", t, !0)
        };

    function g$() {
        return sv = h4, Qn = new ge, p$(), Qn.init(), m$(), Qn
    }
    g$();

    function _$() {
        this.__data__ = [], this.size = 0
    }
    var y$ = _$;

    function v$(t, e) {
        return t === e || t !== t && e !== e
    }
    var Wp = v$,
        b$ = Wp;

    function E$(t, e) {
        for (var n = t.length; n--;)
            if (b$(t[n][0], e)) return n;
        return -1
    }
    var Hp = E$,
        T$ = Hp,
        S$ = Array.prototype,
        w$ = S$.splice;

    function O$(t) {
        var e = this.__data__,
            n = T$(e, t);
        if (n < 0) return !1;
        var r = e.length - 1;
        return n == r ? e.pop() : w$.call(e, n, 1), --this.size, !0
    }
    var A$ = O$,
        C$ = Hp;

    function k$(t) {
        var e = this.__data__,
            n = C$(e, t);
        return n < 0 ? void 0 : e[n][1]
    }
    var I$ = k$,
        N$ = Hp;

    function x$(t) {
        return N$(this.__data__, t) > -1
    }
    var P$ = x$,
        R$ = Hp;

    function M$(t, e) {
        var n = this.__data__,
            r = R$(n, t);
        return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
    }
    var D$ = M$,
        $$ = y$,
        L$ = A$,
        F$ = I$,
        U$ = P$,
        B$ = D$;

    function nl(t) {
        var e = -1,
            n = t == null ? 0 : t.length;
        for (this.clear(); ++e < n;) {
            var r = t[e];
            this.set(r[0], r[1])
        }
    }
    nl.prototype.clear = $$;
    nl.prototype.delete = L$;
    nl.prototype.get = F$;
    nl.prototype.has = U$;
    nl.prototype.set = B$;
    var Kp = nl,
        q$ = Kp;

    function j$() {
        this.__data__ = new q$, this.size = 0
    }
    var V$ = j$;

    function G$(t) {
        var e = this.__data__,
            n = e.delete(t);
        return this.size = e.size, n
    }
    var W$ = G$;

    function H$(t) {
        return this.__data__.get(t)
    }
    var K$ = H$;

    function Y$(t) {
        return this.__data__.has(t)
    }
    var z$ = Y$,
        Z$ = typeof gn == "object" && gn && gn.Object === Object && gn,
        m4 = Z$,
        X$ = m4,
        J$ = typeof self == "object" && self && self.Object === Object && self,
        Q$ = X$ || J$ || Function("return this")(),
        Ps = Q$,
        eL = Ps,
        tL = eL.Symbol,
        Yp = tL,
        RT = Yp,
        g4 = Object.prototype,
        nL = g4.hasOwnProperty,
        rL = g4.toString,
        Fl = RT ? RT.toStringTag : void 0;

    function sL(t) {
        var e = nL.call(t, Fl),
            n = t[Fl];
        try {
            t[Fl] = void 0;
            var r = !0
        } catch {}
        var s = rL.call(t);
        return r && (e ? t[Fl] = n : delete t[Fl]), s
    }
    var iL = sL,
        oL = Object.prototype,
        aL = oL.toString;

    function cL(t) {
        return aL.call(t)
    }
    var lL = cL,
        MT = Yp,
        uL = iL,
        hL = lL,
        fL = "[object Null]",
        dL = "[object Undefined]",
        DT = MT ? MT.toStringTag : void 0;

    function pL(t) {
        return t == null ? t === void 0 ? dL : fL : DT && DT in Object(t) ? uL(t) : hL(t)
    }
    var rl = pL;

    function mL(t) {
        var e = typeof t;
        return t != null && (e == "object" || e == "function")
    }
    var Rs = mL,
        gL = rl,
        _L = Rs,
        yL = "[object AsyncFunction]",
        vL = "[object Function]",
        bL = "[object GeneratorFunction]",
        EL = "[object Proxy]";

    function TL(t) {
        if (!_L(t)) return !1;
        var e = gL(t);
        return e == vL || e == bL || e == yL || e == EL
    }
    var ov = TL,
        SL = Ps,
        wL = SL["__core-js_shared__"],
        OL = wL,
        o_ = OL,
        $T = function() {
            var t = /[^.]+$/.exec(o_ && o_.keys && o_.keys.IE_PROTO || "");
            return t ? "Symbol(src)_1." + t : ""
        }();

    function AL(t) {
        return !!$T && $T in t
    }
    var CL = AL,
        kL = Function.prototype,
        IL = kL.toString;

    function NL(t) {
        if (t != null) {
            try {
                return IL.call(t)
            } catch {}
            try {
                return t + ""
            } catch {}
        }
        return ""
    }
    var _4 = NL,
        xL = ov,
        PL = CL,
        RL = Rs,
        ML = _4,
        DL = /[\\^$.*+?()[\]{}|]/g,
        $L = /^\[object .+?Constructor\]$/,
        LL = Function.prototype,
        FL = Object.prototype,
        UL = LL.toString,
        BL = FL.hasOwnProperty,
        qL = RegExp("^" + UL.call(BL).replace(DL, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

    function jL(t) {
        if (!RL(t) || PL(t)) return !1;
        var e = xL(t) ? qL : $L;
        return e.test(ML(t))
    }
    var VL = jL;

    function GL(t, e) {
        return t == null ? void 0 : t[e]
    }
    var WL = GL,
        HL = VL,
        KL = WL;

    function YL(t, e) {
        var n = KL(t, e);
        return HL(n) ? n : void 0
    }
    var Na = YL,
        zL = Na,
        ZL = Ps,
        XL = zL(ZL, "Map"),
        av = XL,
        JL = Na,
        QL = JL(Object, "create"),
        zp = QL,
        LT = zp;

    function eF() {
        this.__data__ = LT ? LT(null) : {}, this.size = 0
    }
    var tF = eF;

    function nF(t) {
        var e = this.has(t) && delete this.__data__[t];
        return this.size -= e ? 1 : 0, e
    }
    var rF = nF,
        sF = zp,
        iF = "__lodash_hash_undefined__",
        oF = Object.prototype,
        aF = oF.hasOwnProperty;

    function cF(t) {
        var e = this.__data__;
        if (sF) {
            var n = e[t];
            return n === iF ? void 0 : n
        }
        return aF.call(e, t) ? e[t] : void 0
    }
    var lF = cF,
        uF = zp,
        hF = Object.prototype,
        fF = hF.hasOwnProperty;

    function dF(t) {
        var e = this.__data__;
        return uF ? e[t] !== void 0 : fF.call(e, t)
    }
    var pF = dF,
        mF = zp,
        gF = "__lodash_hash_undefined__";

    function _F(t, e) {
        var n = this.__data__;
        return this.size += this.has(t) ? 0 : 1, n[t] = mF && e === void 0 ? gF : e, this
    }
    var yF = _F,
        vF = tF,
        bF = rF,
        EF = lF,
        TF = pF,
        SF = yF;

    function sl(t) {
        var e = -1,
            n = t == null ? 0 : t.length;
        for (this.clear(); ++e < n;) {
            var r = t[e];
            this.set(r[0], r[1])
        }
    }
    sl.prototype.clear = vF;
    sl.prototype.delete = bF;
    sl.prototype.get = EF;
    sl.prototype.has = TF;
    sl.prototype.set = SF;
    var wF = sl,
        FT = wF,
        OF = Kp,
        AF = av;

    function CF() {
        this.size = 0, this.__data__ = {
            hash: new FT,
            map: new(AF || OF),
            string: new FT
        }
    }
    var kF = CF;

    function IF(t) {
        var e = typeof t;
        return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
    }
    var NF = IF,
        xF = NF;

    function PF(t, e) {
        var n = t.__data__;
        return xF(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
    }
    var Zp = PF,
        RF = Zp;

    function MF(t) {
        var e = RF(this, t).delete(t);
        return this.size -= e ? 1 : 0, e
    }
    var DF = MF,
        $F = Zp;

    function LF(t) {
        return $F(this, t).get(t)
    }
    var FF = LF,
        UF = Zp;

    function BF(t) {
        return UF(this, t).has(t)
    }
    var qF = BF,
        jF = Zp;

    function VF(t, e) {
        var n = jF(this, t),
            r = n.size;
        return n.set(t, e), this.size += n.size == r ? 0 : 1, this
    }
    var GF = VF,
        WF = kF,
        HF = DF,
        KF = FF,
        YF = qF,
        zF = GF;

    function il(t) {
        var e = -1,
            n = t == null ? 0 : t.length;
        for (this.clear(); ++e < n;) {
            var r = t[e];
            this.set(r[0], r[1])
        }
    }
    il.prototype.clear = WF;
    il.prototype.delete = HF;
    il.prototype.get = KF;
    il.prototype.has = YF;
    il.prototype.set = zF;
    var y4 = il,
        ZF = Kp,
        XF = av,
        JF = y4,
        QF = 200;

    function eU(t, e) {
        var n = this.__data__;
        if (n instanceof ZF) {
            var r = n.__data__;
            if (!XF || r.length < QF - 1) return r.push([t, e]), this.size = ++n.size, this;
            n = this.__data__ = new JF(r)
        }
        return n.set(t, e), this.size = n.size, this
    }
    var tU = eU,
        nU = Kp,
        rU = V$,
        sU = W$,
        iU = K$,
        oU = z$,
        aU = tU;

    function ol(t) {
        var e = this.__data__ = new nU(t);
        this.size = e.size
    }
    ol.prototype.clear = rU;
    ol.prototype.delete = sU;
    ol.prototype.get = iU;
    ol.prototype.has = oU;
    ol.prototype.set = aU;
    var v4 = ol,
        cU = Na,
        lU = function() {
            try {
                var t = cU(Object, "defineProperty");
                return t({}, "", {}), t
            } catch {}
        }(),
        b4 = lU,
        UT = b4;

    function uU(t, e, n) {
        e == "__proto__" && UT ? UT(t, e, {
            configurable: !0,
            enumerable: !0,
            value: n,
            writable: !0
        }) : t[e] = n
    }
    var cv = uU,
        hU = cv,
        fU = Wp;

    function dU(t, e, n) {
        (n !== void 0 && !fU(t[e], n) || n === void 0 && !(e in t)) && hU(t, e, n)
    }
    var E4 = dU;

    function pU(t) {
        return function(e, n, r) {
            for (var s = -1, i = Object(e), a = r(e), c = a.length; c--;) {
                var u = a[t ? c : ++s];
                if (n(i[u], u, i) === !1) break
            }
            return e
        }
    }
    var mU = pU,
        gU = mU,
        _U = gU(),
        yU = _U,
        pd = {
            exports: {}
        };
    pd.exports;
    (function(t, e) {
        var n = Ps,
            r = e && !e.nodeType && e,
            s = r && !0 && t && !t.nodeType && t,
            i = s && s.exports === r,
            a = i ? n.Buffer : void 0,
            c = a ? a.allocUnsafe : void 0;

        function u(h, d) {
            if (d) return h.slice();
            var p = h.length,
                m = c ? c(p) : new h.constructor(p);
            return h.copy(m), m
        }
        t.exports = u
    })(pd, pd.exports);
    var T4 = pd.exports,
        vU = Ps,
        bU = vU.Uint8Array,
        EU = bU,
        BT = EU;

    function TU(t) {
        var e = new t.constructor(t.byteLength);
        return new BT(e).set(new BT(t)), e
    }
    var lv = TU,
        SU = lv;

    function wU(t, e) {
        var n = e ? SU(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.length)
    }
    var S4 = wU;

    function OU(t, e) {
        var n = -1,
            r = t.length;
        for (e || (e = Array(r)); ++n < r;) e[n] = t[n];
        return e
    }
    var w4 = OU,
        AU = Rs,
        qT = Object.create,
        CU = function() {
            function t() {}
            return function(e) {
                if (!AU(e)) return {};
                if (qT) return qT(e);
                t.prototype = e;
                var n = new t;
                return t.prototype = void 0, n
            }
        }(),
        kU = CU;

    function IU(t, e) {
        return function(n) {
            return t(e(n))
        }
    }
    var O4 = IU,
        NU = O4,
        xU = NU(Object.getPrototypeOf, Object),
        uv = xU,
        PU = Object.prototype;

    function RU(t) {
        var e = t && t.constructor,
            n = typeof e == "function" && e.prototype || PU;
        return t === n
    }
    var hv = RU,
        MU = kU,
        DU = uv,
        $U = hv;

    function LU(t) {
        return typeof t.constructor == "function" && !$U(t) ? MU(DU(t)) : {}
    }
    var A4 = LU;

    function FU(t) {
        return t != null && typeof t == "object"
    }
    var Ro = FU,
        UU = rl,
        BU = Ro,
        qU = "[object Arguments]";

    function jU(t) {
        return BU(t) && UU(t) == qU
    }
    var VU = jU,
        jT = VU,
        GU = Ro,
        C4 = Object.prototype,
        WU = C4.hasOwnProperty,
        HU = C4.propertyIsEnumerable,
        KU = jT(function() {
            return arguments
        }()) ? jT : function(t) {
            return GU(t) && WU.call(t, "callee") && !HU.call(t, "callee")
        },
        k4 = KU,
        YU = Array.isArray,
        Mo = YU,
        zU = 9007199254740991;

    function ZU(t) {
        return typeof t == "number" && t > -1 && t % 1 == 0 && t <= zU
    }
    var I4 = ZU,
        XU = ov,
        JU = I4;

    function QU(t) {
        return t != null && JU(t.length) && !XU(t)
    }
    var Xp = QU,
        eB = Xp,
        tB = Ro;

    function nB(t) {
        return tB(t) && eB(t)
    }
    var rB = nB,
        md = {
            exports: {}
        };

    function sB() {
        return !1
    }
    var iB = sB;
    md.exports;
    (function(t, e) {
        var n = Ps,
            r = iB,
            s = e && !e.nodeType && e,
            i = s && !0 && t && !t.nodeType && t,
            a = i && i.exports === s,
            c = a ? n.Buffer : void 0,
            u = c ? c.isBuffer : void 0,
            h = u || r;
        t.exports = h
    })(md, md.exports);
    var fv = md.exports,
        oB = rl,
        aB = uv,
        cB = Ro,
        lB = "[object Object]",
        uB = Function.prototype,
        hB = Object.prototype,
        N4 = uB.toString,
        fB = hB.hasOwnProperty,
        dB = N4.call(Object);

    function pB(t) {
        if (!cB(t) || oB(t) != lB) return !1;
        var e = aB(t);
        if (e === null) return !0;
        var n = fB.call(e, "constructor") && e.constructor;
        return typeof n == "function" && n instanceof n && N4.call(n) == dB
    }
    var mB = pB,
        gB = rl,
        _B = I4,
        yB = Ro,
        vB = "[object Arguments]",
        bB = "[object Array]",
        EB = "[object Boolean]",
        TB = "[object Date]",
        SB = "[object Error]",
        wB = "[object Function]",
        OB = "[object Map]",
        AB = "[object Number]",
        CB = "[object Object]",
        kB = "[object RegExp]",
        IB = "[object Set]",
        NB = "[object String]",
        xB = "[object WeakMap]",
        PB = "[object ArrayBuffer]",
        RB = "[object DataView]",
        MB = "[object Float32Array]",
        DB = "[object Float64Array]",
        $B = "[object Int8Array]",
        LB = "[object Int16Array]",
        FB = "[object Int32Array]",
        UB = "[object Uint8Array]",
        BB = "[object Uint8ClampedArray]",
        qB = "[object Uint16Array]",
        jB = "[object Uint32Array]",
        Xt = {};
    Xt[MB] = Xt[DB] = Xt[$B] = Xt[LB] = Xt[FB] = Xt[UB] = Xt[BB] = Xt[qB] = Xt[jB] = !0;
    Xt[vB] = Xt[bB] = Xt[PB] = Xt[EB] = Xt[RB] = Xt[TB] = Xt[SB] = Xt[wB] = Xt[OB] = Xt[AB] = Xt[CB] = Xt[kB] = Xt[IB] = Xt[NB] = Xt[xB] = !1;

    function VB(t) {
        return yB(t) && _B(t.length) && !!Xt[gB(t)]
    }
    var GB = VB;

    function WB(t) {
        return function(e) {
            return t(e)
        }
    }
    var dv = WB,
        gd = {
            exports: {}
        };
    gd.exports;
    (function(t, e) {
        var n = m4,
            r = e && !e.nodeType && e,
            s = r && !0 && t && !t.nodeType && t,
            i = s && s.exports === r,
            a = i && n.process,
            c = function() {
                try {
                    var u = s && s.require && s.require("util").types;
                    return u || a && a.binding && a.binding("util")
                } catch {}
            }();
        t.exports = c
    })(gd, gd.exports);
    var pv = gd.exports,
        HB = GB,
        KB = dv,
        VT = pv,
        GT = VT && VT.isTypedArray,
        YB = GT ? KB(GT) : HB,
        x4 = YB;

    function zB(t, e) {
        if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__") return t[e]
    }
    var P4 = zB,
        ZB = cv,
        XB = Wp,
        JB = Object.prototype,
        QB = JB.hasOwnProperty;

    function eq(t, e, n) {
        var r = t[e];
        (!(QB.call(t, e) && XB(r, n)) || n === void 0 && !(e in t)) && ZB(t, e, n)
    }
    var mv = eq,
        tq = mv,
        nq = cv;

    function rq(t, e, n, r) {
        var s = !n;
        n || (n = {});
        for (var i = -1, a = e.length; ++i < a;) {
            var c = e[i],
                u = r ? r(n[c], t[c], c, n, t) : void 0;
            u === void 0 && (u = t[c]), s ? nq(n, c, u) : tq(n, c, u)
        }
        return n
    }
    var zu = rq;

    function sq(t, e) {
        for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
        return r
    }
    var iq = sq,
        oq = 9007199254740991,
        aq = /^(?:0|[1-9]\d*)$/;

    function cq(t, e) {
        var n = typeof t;
        return e = e ?? oq, !!e && (n == "number" || n != "symbol" && aq.test(t)) && t > -1 && t % 1 == 0 && t < e
    }
    var gv = cq,
        lq = iq,
        uq = k4,
        hq = Mo,
        fq = fv,
        dq = gv,
        pq = x4,
        mq = Object.prototype,
        gq = mq.hasOwnProperty;

    function _q(t, e) {
        var n = hq(t),
            r = !n && uq(t),
            s = !n && !r && fq(t),
            i = !n && !r && !s && pq(t),
            a = n || r || s || i,
            c = a ? lq(t.length, String) : [],
            u = c.length;
        for (var h in t)(e || gq.call(t, h)) && !(a && (h == "length" || s && (h == "offset" || h == "parent") || i && (h == "buffer" || h == "byteLength" || h == "byteOffset") || dq(h, u))) && c.push(h);
        return c
    }
    var R4 = _q;

    function yq(t) {
        var e = [];
        if (t != null)
            for (var n in Object(t)) e.push(n);
        return e
    }
    var vq = yq,
        bq = Rs,
        Eq = hv,
        Tq = vq,
        Sq = Object.prototype,
        wq = Sq.hasOwnProperty;

    function Oq(t) {
        if (!bq(t)) return Tq(t);
        var e = Eq(t),
            n = [];
        for (var r in t) r == "constructor" && (e || !wq.call(t, r)) || n.push(r);
        return n
    }
    var Aq = Oq,
        Cq = R4,
        kq = Aq,
        Iq = Xp;

    function Nq(t) {
        return Iq(t) ? Cq(t, !0) : kq(t)
    }
    var Zu = Nq,
        xq = zu,
        Pq = Zu;

    function Rq(t) {
        return xq(t, Pq(t))
    }
    var Mq = Rq,
        WT = E4,
        Dq = T4,
        $q = S4,
        Lq = w4,
        Fq = A4,
        HT = k4,
        KT = Mo,
        Uq = rB,
        Bq = fv,
        qq = ov,
        jq = Rs,
        Vq = mB,
        Gq = x4,
        YT = P4,
        Wq = Mq;

    function Hq(t, e, n, r, s, i, a) {
        var c = YT(t, n),
            u = YT(e, n),
            h = a.get(u);
        if (h) {
            WT(t, n, h);
            return
        }
        var d = i ? i(c, u, n + "", t, e, a) : void 0,
            p = d === void 0;
        if (p) {
            var m = KT(u),
                _ = !m && Bq(u),
                y = !m && !_ && Gq(u);
            d = u, m || _ || y ? KT(c) ? d = c : Uq(c) ? d = Lq(c) : _ ? (p = !1, d = Dq(u, !0)) : y ? (p = !1, d = $q(u, !0)) : d = [] : Vq(u) || HT(u) ? (d = c, HT(c) ? d = Wq(c) : (!jq(c) || qq(c)) && (d = Fq(u))) : p = !1
        }
        p && (a.set(u, d), s(d, u, r, i, a), a.delete(u)), WT(t, n, d)
    }
    var Kq = Hq,
        Yq = v4,
        zq = E4,
        Zq = yU,
        Xq = Kq,
        Jq = Rs,
        Qq = Zu,
        ej = P4;

    function M4(t, e, n, r, s) {
        t !== e && Zq(e, function(i, a) {
            if (s || (s = new Yq), Jq(i)) Xq(t, e, a, n, M4, r, s);
            else {
                var c = r ? r(ej(t, a), i, a + "", t, e, s) : void 0;
                c === void 0 && (c = i), zq(t, a, c)
            }
        }, Qq)
    }
    var tj = M4;

    function nj(t) {
        return t
    }
    var D4 = nj;

    function rj(t, e, n) {
        switch (n.length) {
            case 0:
                return t.call(e);
            case 1:
                return t.call(e, n[0]);
            case 2:
                return t.call(e, n[0], n[1]);
            case 3:
                return t.call(e, n[0], n[1], n[2])
        }
        return t.apply(e, n)
    }
    var sj = rj,
        ij = sj,
        zT = Math.max;

    function oj(t, e, n) {
        return e = zT(e === void 0 ? t.length - 1 : e, 0),
            function() {
                for (var r = arguments, s = -1, i = zT(r.length - e, 0), a = Array(i); ++s < i;) a[s] = r[e + s];
                s = -1;
                for (var c = Array(e + 1); ++s < e;) c[s] = r[s];
                return c[e] = n(a), ij(t, this, c)
            }
    }
    var aj = oj;

    function cj(t) {
        return function() {
            return t
        }
    }
    var lj = cj,
        uj = lj,
        ZT = b4,
        hj = D4,
        fj = ZT ? function(t, e) {
            return ZT(t, "toString", {
                configurable: !0,
                enumerable: !1,
                value: uj(e),
                writable: !0
            })
        } : hj,
        dj = fj,
        pj = 800,
        mj = 16,
        gj = Date.now;

    function _j(t) {
        var e = 0,
            n = 0;
        return function() {
            var r = gj(),
                s = mj - (r - n);
            if (n = r, s > 0) {
                if (++e >= pj) return arguments[0]
            } else e = 0;
            return t.apply(void 0, arguments)
        }
    }
    var yj = _j,
        vj = dj,
        bj = yj,
        Ej = bj(vj),
        Tj = Ej,
        Sj = D4,
        wj = aj,
        Oj = Tj;

    function Aj(t, e) {
        return Oj(wj(t, e, Sj), t + "")
    }
    var Cj = Aj,
        kj = Wp,
        Ij = Xp,
        Nj = gv,
        xj = Rs;

    function Pj(t, e, n) {
        if (!xj(n)) return !1;
        var r = typeof e;
        return (r == "number" ? Ij(n) && Nj(e, n.length) : r == "string" && e in n) ? kj(n[e], t) : !1
    }
    var Rj = Pj,
        Mj = Cj,
        Dj = Rj;

    function $j(t) {
        return Mj(function(e, n) {
            var r = -1,
                s = n.length,
                i = s > 1 ? n[s - 1] : void 0,
                a = s > 2 ? n[2] : void 0;
            for (i = t.length > 3 && typeof i == "function" ? (s--, i) : void 0, a && Dj(n[0], n[1], a) && (i = s < 3 ? void 0 : i, s = 1), e = Object(e); ++r < s;) {
                var c = n[r];
                c && t(e, c, r, i)
            }
            return e
        })
    }
    var Lj = $j,
        Fj = tj,
        Uj = Lj,
        Bj = Uj(function(t, e, n) {
            Fj(t, e, n)
        }),
        qj = Bj;
    const jj = el(qj);
    class vc {
        static set(e) {
            if (e && this.isSupported(e)) {
                this.locale = e;
                return
            }
            this.locale = this.getPreferredDeviceLocale()
        }
        static getPreferredDeviceLocale() {
            const e = navigator.languages;
            for (let n = 0; n < e.length; n++)
                if (this.isSupported(e[n])) return e[n];
            return this.supported[0]
        }
        static isSupported(e) {
            return Object.values(this.supported).includes(e)
        }
        static mergeMessages(...e) {
            return jj(e[0], ...e)
        }
    }
    Se(vc, "locale"), Se(vc, "supported", ["en", "fr", "it", "de", "es", "es-XL"]);
    var lo;
    let vs = (lo = class {
        static get serverUrl() {
            const e = this.getQueryParam("server") ?? this.getQueryParam("s");
            return !e || e === "live" ? "ecast.jackboxgames.com" : e === "local" ? "https://localhost" : e.includes("localhost") ? e : `${e}.jackboxgames.com`
        }
        static get isCanvasSupported() {
            const e = document.createElement("canvas");
            return !!(e.getContext && e.getContext("2d"))
        }
        static toPrecision(e, n) {
            const r = 10 ** n;
            return Math.round((e + Number.EPSILON) * r) / r
        }
        static isProduction() {
            return window.location.hostname === "jackbox.tv"
        }
        static htmlUnescape(e) {
            return String(e).replace(/&quot;/gi, '"').replace(/&#39;/gi, "'").replace(/&lt;/gi, "<").replace(/&gt;/gi, ">").replace(/&amp;/gi, "&")
        }
        static htmlEscape(e) {
            return String(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
        }
        static sanitize(e) {
            const n = this.sanitizeInput(e).replace(/'/g, "");
            return this.htmlEscape(n).trim()
        }
        static sanitizeName(e) {
            return e.replace(/[^A-Z0-9\u00A1\u0020-\u002F\u00BF-\u00FF\u2026!?*$+\-'_ .,]/gi, "").replace(/'/g, "")
        }
        static sanitizeInput(e) {
            return e = e.replace("", "..."), e.replace(/[^\u00A1\u0020-\u007E\u00BF-\u00FF]/gi, "")
        }
        static sanitizeEmoji(e) {
            return e.replace(/(\u00a9|\u00ae|[\u2000-\u2017]|[\u2020-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/, "")
        }
        static safeText(e) {
            const n = document.createElement("div");
            return n.textContent = e, n.innerHTML
        }
        static htmlTagsToBBCode(e, n) {
            if (!n.length) throw new Error("[Utils.htmlTagsToBBCode] No tag pairs were passed in");
            return n.reduce((r, s) => (r.replaceAll(`<${s[0]}>`, `[${s[1]}]`), r.replaceAll(`</${s[0]}>`, `</${s[1]}>`), r), e)
        }
        static hexToRgb(e) {
            const n = new ArrayBuffer(4);
            new DataView(n).setUint32(0, parseInt(e.replace("#", ""), 16), !1);
            const s = new Uint8Array(n);
            return `${s[1]},${s[2]},${s[3]}`
        }
        static adjustColor(e, n) {
            let r = !1,
                s = e;
            s[0] === "#" && (s = s.slice(1), r = !0);
            const i = parseInt(s, 16),
                a = Math.min(Math.max(0, (i >> 16) * n), 255),
                c = Math.min(Math.max(0, (i >> 8 & 255) * n), 255);
            let h = (Math.min(Math.max(0, (i & 255) * n), 255) | c << 8 | a << 16).toString(16);
            for (; h.length < s.length;) h = `0${h}`;
            return (r ? "#" : "") + h
        }
        static isInTolerance(e, n, r) {
            return !(Math.abs(e.x - n.x) < r || Math.abs(e.y - n.y) > r)
        }
        static getDistanceBetweenPoints(e, n) {
            const r = [e.x - n.x, e.y - n.y],
                s = Math.hypot(...r);
            return Math.round(s * 100) / 100
        }
        static getMidpoint(e, n) {
            return {
                x: (e.x + n.x) / 2,
                y: (e.y + n.y) / 2
            }
        }
        static getAngleBetweenPoints(e, n) {
            let s = Math.atan2(n.y - e.y, n.x - e.x) * (180 / Math.PI);
            return s < 0 && (s += 360), 360 - s
        }
        static getAngularDistance(e, n) {
            let r = (n - e) % 360;
            const s = r < 0 ? 1 : -1;
            return r = Math.abs(r), r > 180 ? s * (360 - r) : s * r
        }
        static getVelocity(e, n, r, s) {
            return this.getDistanceBetweenPoints(e, r) / (s - n)
        }
        static isInsideElement(e, n) {
            const r = n.getBoundingClientRect();
            return !(e.x < r.left || e.x > r.left + r.width || e.y < r.top || e.y > r.top + r.height)
        }
        static cyrb128(e) {
            let n = 1779033703,
                r = 3144134277,
                s = 1013904242,
                i = 2773480762;
            for (let a = 0, c; a < e.length; a++) c = e.charCodeAt(a), n = r ^ Math.imul(n ^ c, 597399067), r = s ^ Math.imul(r ^ c, 2869860233), s = i ^ Math.imul(s ^ c, 951274213), i = n ^ Math.imul(i ^ c, 2716044179);
            return n = Math.imul(s ^ n >>> 18, 597399067), r = Math.imul(i ^ r >>> 22, 2869860233), s = Math.imul(n ^ s >>> 17, 951274213), i = Math.imul(r ^ i >>> 19, 2716044179), [(n ^ r ^ s ^ i) >>> 0, (r ^ n) >>> 0, (s ^ n) >>> 0, (i ^ n) >>> 0]
        }
        static sfc32(e, n, r, s) {
            return function() {
                e >>>= 0, n >>>= 0, r >>>= 0, s >>>= 0;
                let a = e + n | 0;
                return e = n ^ n >>> 9, n = r + (r << 3) | 0, r = r << 21 | r >>> 11, s = s + 1 | 0, a = a + s | 0, r = r + a | 0, (a >>> 0) / 4294967296
            }
        }
    }, Se(lo, "queryParams", new URLSearchParams(window.location.search)), Se(lo, "getQueryParam", e => lo.queryParams.get(e)), Se(lo, "sleep", e => new Promise(n => {
        window.setTimeout(n, e)
    })), lo);
    class ln {
        static get namespace() {
            var e;
            return ((e = window.tv.storage) == null ? void 0 : e.namespace) ?? this.defaultNamespace
        }
        static get isDisabled() {
            var e;
            return ((e = window.tv.storage) == null ? void 0 : e.isDisabled) ?? !1
        }
        static get tag() {
            var e;
            return (e = window.tv.storage) == null ? void 0 : e.tag
        }
        static get code() {
            var e;
            return (e = window.tv.storage) == null ? void 0 : e.code
        }
        static get isSupported() {
            if (this.isDisabled) return !1;
            try {
                return window.localStorage ? (window.localStorage.setItem("support-check", "1"), window.localStorage.removeItem("support-check"), !0) : !1
            } catch {
                return !1
            }
        }
        static setup(e, n) {
            delete window.tv.storage, window.tv.storage = {
                namespace: vs.getQueryParam("namespace") ?? vs.getQueryParam("ns") ?? this.defaultNamespace,
                isDisabled: vs.queryParams.has("incognito") || vs.queryParams.has("nc")
            }, e && (window.tv.storage.tag = e), n && (window.tv.storage.code = n.toLowerCase(), this.clearCodeScopedKeys(window.tv.storage.code))
        }
        static get(e, n) {
            return this.isSupported ? window.localStorage.getItem(this.getScopedKey(e, n)) : null
        }
        static set(e, n, r = "none") {
            if (this.isSupported) return window.localStorage.setItem(this.getScopedSetKey(e, r), n)
        }
        static remove(e, n) {
            if (this.isSupported) return window.localStorage.removeItem(this.getScopedKey(e, n))
        }
        static setTag(e) {
            const n = e.toLowerCase(),
                r = this.get("tags") ?? "[]",
                s = n.split("-")[0];
            let i = JSON.parse(r);
            i = i.filter(a => {
                const c = a.split("-")[0];
                return s !== c
            }), i.push(n), this.set("tags", JSON.stringify(i))
        }
        static getScopedKey(e, n) {
            const r = `${this.namespace}:${e}`,
                s = this.tag ? `${this.namespace}:${e}:tag:${this.tag}` : null,
                i = this.code ? `${this.namespace}:${e}:code:${this.code}` : null;
            if (n === "none") return r;
            if (n === "tag") {
                if (!s) throw new Error('[Storage] requested "tag" scope but tv.storage.tag is undefined');
                return s
            }
            if (n === "code") {
                if (!i) throw new Error('[Storage] requested "code" scope but tv.storage.code is undefined');
                return i
            }
            return i && window.localStorage.getItem(i) !== null ? i : s && window.localStorage.getItem(s) !== null ? s : r
        }
        static getScopedSetKey(e, n = "none") {
            if (n === "tag") {
                if (!this.tag) throw new Error('[Storage] requested "room" scope but tv.storage.tag is undefined');
                return `${this.namespace}:${e}:tag:${this.tag}`
            }
            if (n === "code") {
                if (!this.code) throw new Error('[Storage] requested "code" scope but tv.storage.code is undefined');
                return `${this.namespace}:${e}:code:${this.code}`
            }
            return `${this.namespace}:${e}`
        }
        static clearCodeScopedKeys(e) {
            this.isSupported && Object.keys(window.localStorage).forEach(n => {
                const r = n.split(":code:");
                r.length <= 1 || r[1] !== e && window.localStorage.removeItem(n)
            })
        }
    }
    Se(ln, "defaultNamespace", "tv");
    class _d {
        constructor() {
            Se(this, "artifacts");
            this.artifacts = this.list()
        }
        get hasUnviewed() {
            return this.artifacts.some(e => !e.viewed)
        }
        add(e, n) {
            _d.add(e, n), this.artifacts = this.list()
        }
        static add(e, n) {
            if (!ln.isSupported) return;
            const r = this.isTestArtifact(e) ? "http" : "https",
                s = this.isTestArtifact(e) ? "games-test.jackbox.tv" : "games.jackbox.tv",
                i = `${r}://${s}/artifact/${e.categoryId}/${e.artifactId}/`,
                a = ln.get("galleries") || "[]";
            try {
                const c = JSON.parse(a) || [];
                if (c.some(u => u.url === i)) return;
                c.unshift({
                    url: i,
                    time: new Date().getTime(),
                    categoryId: e.categoryId,
                    viewed: !1
                }), ln.set("galleries", JSON.stringify(c.slice(0, 40)))
            } catch {
                console.warn("[Artifacts] Unable to add artifact to local storage")
            }
        }
        remove(e) {
            if (!ln.isSupported) return;
            const n = ln.get("galleries") || "[]";
            try {
                const r = JSON.parse(n) || [];
                r.splice(e, 1), ln.set("galleries", JSON.stringify(r)), this.artifacts = this.list()
            } catch {
                console.warn("[Artifacts] Unable to remove artifact")
            }
        }
        setAsViewed(e) {
            _d.setAsViewed(e), this.artifacts = this.list()
        }
        static setAsViewed(e) {
            if (!ln.isSupported) return;
            const n = ln.get("galleries") || "[]";
            try {
                const r = JSON.parse(n) || [];
                r.length && (r[e].viewed = !0), ln.set("galleries", JSON.stringify(r))
            } catch {
                console.warn(`[Artifacts] Unable to mark artifact ${e} as viewed`)
            }
        }
        static isTestArtifact(e) {
            var n;
            return ((n = e == null ? void 0 : e.rootId) == null ? void 0 : n.indexOf("test")) !== -1
        }
        list() {
            if (!ln.isSupported) return [];
            const e = new Intl.DateTimeFormat(vc.locale, {
                    year: "numeric",
                    month: "short",
                    day: "numeric"
                }),
                n = ln.get("galleries") || "[]",
                r = Date.now();
            try {
                return (JSON.parse(n) || []).filter(i => r - i.time < 525600 * 60 * 1e3).map(i => {
                    const a = new Date(i.time),
                        c = e.format(a),
                        u = i.url.split("/"),
                        h = u[u.length - 1] === "" ? u[u.length - 2] : u[u.length - 1];
                    let d = i.categoryId;
                    return d || (i.url.indexOf("Quiplash2") !== -1 ? d = "Quiplash2Game" : i.url.indexOf("Drawful") !== -1 ? d = "DrawfulGame" : i.url.indexOf("TeeKO") !== -1 ? d = "TeeKOGame" : i.url.indexOf("TriviaDeath") !== -1 && (d = "TriviaDeathResults")), {
                        id: h,
                        gameName: d,
                        date: c,
                        ...i
                    }
                })
            } catch {
                return console.warn("[Artifacts] Unable to parse artifacts array"), []
            }
        }
    }
    var f1 = {
        exports: {}
    };
    (function(t, e) {
        var n = typeof self < "u" ? self : gn,
            r = function() {
                function i() {
                    this.fetch = !1, this.DOMException = n.DOMException
                }
                return i.prototype = n, new i
            }();
        (function(i) {
            (function(a) {
                var c = {
                    searchParams: "URLSearchParams" in i,
                    iterable: "Symbol" in i && "iterator" in Symbol,
                    blob: "FileReader" in i && "Blob" in i && function() {
                        try {
                            return new Blob, !0
                        } catch {
                            return !1
                        }
                    }(),
                    formData: "FormData" in i,
                    arrayBuffer: "ArrayBuffer" in i
                };

                function u(q) {
                    return q && DataView.prototype.isPrototypeOf(q)
                }
                if (c.arrayBuffer) var h = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                    d = ArrayBuffer.isView || function(q) {
                        return q && h.indexOf(Object.prototype.toString.call(q)) > -1
                    };

                function p(q) {
                    if (typeof q != "string" && (q = String(q)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(q)) throw new TypeError("Invalid character in header field name");
                    return q.toLowerCase()
                }

                function m(q) {
                    return typeof q != "string" && (q = String(q)), q
                }

                function _(q) {
                    var ie = {
                        next: function() {
                            var ae = q.shift();
                            return {
                                done: ae === void 0,
                                value: ae
                            }
                        }
                    };
                    return c.iterable && (ie[Symbol.iterator] = function() {
                        return ie
                    }), ie
                }

                function y(q) {
                    this.map = {}, q instanceof y ? q.forEach(function(ie, ae) {
                        this.append(ae, ie)
                    }, this) : Array.isArray(q) ? q.forEach(function(ie) {
                        this.append(ie[0], ie[1])
                    }, this) : q && Object.getOwnPropertyNames(q).forEach(function(ie) {
                        this.append(ie, q[ie])
                    }, this)
                }
                y.prototype.append = function(q, ie) {
                    q = p(q), ie = m(ie);
                    var ae = this.map[q];
                    this.map[q] = ae ? ae + ", " + ie : ie
                }, y.prototype.delete = function(q) {
                    delete this.map[p(q)]
                }, y.prototype.get = function(q) {
                    return q = p(q), this.has(q) ? this.map[q] : null
                }, y.prototype.has = function(q) {
                    return this.map.hasOwnProperty(p(q))
                }, y.prototype.set = function(q, ie) {
                    this.map[p(q)] = m(ie)
                }, y.prototype.forEach = function(q, ie) {
                    for (var ae in this.map) this.map.hasOwnProperty(ae) && q.call(ie, this.map[ae], ae, this)
                }, y.prototype.keys = function() {
                    var q = [];
                    return this.forEach(function(ie, ae) {
                        q.push(ae)
                    }), _(q)
                }, y.prototype.values = function() {
                    var q = [];
                    return this.forEach(function(ie) {
                        q.push(ie)
                    }), _(q)
                }, y.prototype.entries = function() {
                    var q = [];
                    return this.forEach(function(ie, ae) {
                        q.push([ae, ie])
                    }), _(q)
                }, c.iterable && (y.prototype[Symbol.iterator] = y.prototype.entries);

                function v(q) {
                    if (q.bodyUsed) return Promise.reject(new TypeError("Already read"));
                    q.bodyUsed = !0
                }

                function w(q) {
                    return new Promise(function(ie, ae) {
                        q.onload = function() {
                            ie(q.result)
                        }, q.onerror = function() {
                            ae(q.error)
                        }
                    })
                }

                function b(q) {
                    var ie = new FileReader,
                        ae = w(ie);
                    return ie.readAsArrayBuffer(q), ae
                }

                function I(q) {
                    var ie = new FileReader,
                        ae = w(ie);
                    return ie.readAsText(q), ae
                }

                function F(q) {
                    for (var ie = new Uint8Array(q), ae = new Array(ie.length), he = 0; he < ie.length; he++) ae[he] = String.fromCharCode(ie[he]);
                    return ae.join("")
                }

                function x(q) {
                    if (q.slice) return q.slice(0);
                    var ie = new Uint8Array(q.byteLength);
                    return ie.set(new Uint8Array(q)), ie.buffer
                }

                function O() {
                    return this.bodyUsed = !1, this._initBody = function(q) {
                        this._bodyInit = q, q ? typeof q == "string" ? this._bodyText = q : c.blob && Blob.prototype.isPrototypeOf(q) ? this._bodyBlob = q : c.formData && FormData.prototype.isPrototypeOf(q) ? this._bodyFormData = q : c.searchParams && URLSearchParams.prototype.isPrototypeOf(q) ? this._bodyText = q.toString() : c.arrayBuffer && c.blob && u(q) ? (this._bodyArrayBuffer = x(q.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : c.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(q) || d(q)) ? this._bodyArrayBuffer = x(q) : this._bodyText = q = Object.prototype.toString.call(q) : this._bodyText = "", this.headers.get("content-type") || (typeof q == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : c.searchParams && URLSearchParams.prototype.isPrototypeOf(q) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                    }, c.blob && (this.blob = function() {
                        var q = v(this);
                        if (q) return q;
                        if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                        if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                        if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                        return Promise.resolve(new Blob([this._bodyText]))
                    }, this.arrayBuffer = function() {
                        return this._bodyArrayBuffer ? v(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(b)
                    }), this.text = function() {
                        var q = v(this);
                        if (q) return q;
                        if (this._bodyBlob) return I(this._bodyBlob);
                        if (this._bodyArrayBuffer) return Promise.resolve(F(this._bodyArrayBuffer));
                        if (this._bodyFormData) throw new Error("could not read FormData body as text");
                        return Promise.resolve(this._bodyText)
                    }, c.formData && (this.formData = function() {
                        return this.text().then(ee)
                    }), this.json = function() {
                        return this.text().then(JSON.parse)
                    }, this
                }
                var M = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

                function $(q) {
                    var ie = q.toUpperCase();
                    return M.indexOf(ie) > -1 ? ie : q
                }

                function j(q, ie) {
                    ie = ie || {};
                    var ae = ie.body;
                    if (q instanceof j) {
                        if (q.bodyUsed) throw new TypeError("Already read");
                        this.url = q.url, this.credentials = q.credentials, ie.headers || (this.headers = new y(q.headers)), this.method = q.method, this.mode = q.mode, this.signal = q.signal, !ae && q._bodyInit != null && (ae = q._bodyInit, q.bodyUsed = !0)
                    } else this.url = String(q);
                    if (this.credentials = ie.credentials || this.credentials || "same-origin", (ie.headers || !this.headers) && (this.headers = new y(ie.headers)), this.method = $(ie.method || this.method || "GET"), this.mode = ie.mode || this.mode || null, this.signal = ie.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && ae) throw new TypeError("Body not allowed for GET or HEAD requests");
                    this._initBody(ae)
                }
                j.prototype.clone = function() {
                    return new j(this, {
                        body: this._bodyInit
                    })
                };

                function ee(q) {
                    var ie = new FormData;
                    return q.trim().split("&").forEach(function(ae) {
                        if (ae) {
                            var he = ae.split("="),
                                ve = he.shift().replace(/\+/g, " "),
                                be = he.join("=").replace(/\+/g, " ");
                            ie.append(decodeURIComponent(ve), decodeURIComponent(be))
                        }
                    }), ie
                }

                function se(q) {
                    var ie = new y,
                        ae = q.replace(/\r?\n[\t ]+/g, " ");
                    return ae.split(/\r?\n/).forEach(function(he) {
                        var ve = he.split(":"),
                            be = ve.shift().trim();
                        if (be) {
                            var Ae = ve.join(":").trim();
                            ie.append(be, Ae)
                        }
                    }), ie
                }
                O.call(j.prototype);

                function oe(q, ie) {
                    ie || (ie = {}), this.type = "default", this.status = ie.status === void 0 ? 200 : ie.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in ie ? ie.statusText : "OK", this.headers = new y(ie.headers), this.url = ie.url || "", this._initBody(q)
                }
                O.call(oe.prototype), oe.prototype.clone = function() {
                    return new oe(this._bodyInit, {
                        status: this.status,
                        statusText: this.statusText,
                        headers: new y(this.headers),
                        url: this.url
                    })
                }, oe.error = function() {
                    var q = new oe(null, {
                        status: 0,
                        statusText: ""
                    });
                    return q.type = "error", q
                };
                var Z = [301, 302, 303, 307, 308];
                oe.redirect = function(q, ie) {
                    if (Z.indexOf(ie) === -1) throw new RangeError("Invalid status code");
                    return new oe(null, {
                        status: ie,
                        headers: {
                            location: q
                        }
                    })
                }, a.DOMException = i.DOMException;
                try {
                    new a.DOMException
                } catch {
                    a.DOMException = function(ie, ae) {
                        this.message = ie, this.name = ae;
                        var he = Error(ie);
                        this.stack = he.stack
                    }, a.DOMException.prototype = Object.create(Error.prototype), a.DOMException.prototype.constructor = a.DOMException
                }

                function de(q, ie) {
                    return new Promise(function(ae, he) {
                        var ve = new j(q, ie);
                        if (ve.signal && ve.signal.aborted) return he(new a.DOMException("Aborted", "AbortError"));
                        var be = new XMLHttpRequest;

                        function Ae() {
                            be.abort()
                        }
                        be.onload = function() {
                            var we = {
                                status: be.status,
                                statusText: be.statusText,
                                headers: se(be.getAllResponseHeaders() || "")
                            };
                            we.url = "responseURL" in be ? be.responseURL : we.headers.get("X-Request-URL");
                            var Me = "response" in be ? be.response : be.responseText;
                            ae(new oe(Me, we))
                        }, be.onerror = function() {
                            he(new TypeError("Network request failed"))
                        }, be.ontimeout = function() {
                            he(new TypeError("Network request failed"))
                        }, be.onabort = function() {
                            he(new a.DOMException("Aborted", "AbortError"))
                        }, be.open(ve.method, ve.url, !0), ve.credentials === "include" ? be.withCredentials = !0 : ve.credentials === "omit" && (be.withCredentials = !1), "responseType" in be && c.blob && (be.responseType = "blob"), ve.headers.forEach(function(we, Me) {
                            be.setRequestHeader(Me, we)
                        }), ve.signal && (ve.signal.addEventListener("abort", Ae), be.onreadystatechange = function() {
                            be.readyState === 4 && ve.signal.removeEventListener("abort", Ae)
                        }), be.send(typeof ve._bodyInit > "u" ? null : ve._bodyInit)
                    })
                }
                return de.polyfill = !0, i.fetch || (i.fetch = de, i.Headers = y, i.Request = j, i.Response = oe), a.Headers = y, a.Request = j, a.Response = oe, a.fetch = de, Object.defineProperty(a, "__esModule", {
                    value: !0
                }), a
            })({})
        })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
        var s = r;
        e = s.fetch, e.default = s.fetch, e.fetch = s.fetch, e.Headers = s.Headers, e.Request = s.Request, e.Response = s.Response, t.exports = e
    })(f1, f1.exports);
    var Vj = f1.exports,
        Gj = function() {
            if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
            if (typeof Symbol.iterator == "symbol") return !0;
            var e = {},
                n = Symbol("test"),
                r = Object(n);
            if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]") return !1;
            var s = 42;
            e[n] = s;
            for (n in e) return !1;
            if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
            var i = Object.getOwnPropertySymbols(e);
            if (i.length !== 1 || i[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n)) return !1;
            if (typeof Object.getOwnPropertyDescriptor == "function") {
                var a = Object.getOwnPropertyDescriptor(e, n);
                if (a.value !== s || a.enumerable !== !0) return !1
            }
            return !0
        },
        XT = typeof Symbol < "u" && Symbol,
        Wj = Gj,
        Hj = function() {
            return typeof XT != "function" || typeof Symbol != "function" || typeof XT("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : Wj()
        },
        Kj = "Function.prototype.bind called on incompatible ",
        a_ = Array.prototype.slice,
        Yj = Object.prototype.toString,
        zj = "[object Function]",
        Zj = function(e) {
            var n = this;
            if (typeof n != "function" || Yj.call(n) !== zj) throw new TypeError(Kj + n);
            for (var r = a_.call(arguments, 1), s, i = function() {
                    if (this instanceof s) {
                        var d = n.apply(this, r.concat(a_.call(arguments)));
                        return Object(d) === d ? d : this
                    } else return n.apply(e, r.concat(a_.call(arguments)))
                }, a = Math.max(0, n.length - r.length), c = [], u = 0; u < a; u++) c.push("$" + u);
            if (s = Function("binder", "return function (" + c.join(",") + "){ return binder.apply(this,arguments); }")(i), n.prototype) {
                var h = function() {};
                h.prototype = n.prototype, s.prototype = new h, h.prototype = null
            }
            return s
        },
        Xj = Zj,
        _v = Function.prototype.bind || Xj,
        Jj = _v,
        Qj = Jj.call(Function.call, Object.prototype.hasOwnProperty),
        wt, Dc = SyntaxError,
        $4 = Function,
        bc = TypeError,
        c_ = function(t) {
            try {
                return $4('"use strict"; return (' + t + ").constructor;")()
            } catch {}
        },
        _a = Object.getOwnPropertyDescriptor;
    if (_a) try {
        _a({}, "")
    } catch {
        _a = null
    }
    var l_ = function() {
            throw new bc
        },
        eV = _a ? function() {
            try {
                return arguments.callee, l_
            } catch {
                try {
                    return _a(arguments, "callee").get
                } catch {
                    return l_
                }
            }
        }() : l_,
        Qa = Hj(),
        io = Object.getPrototypeOf || function(t) {
            return t.__proto__
        },
        rc = {},
        tV = typeof Uint8Array > "u" ? wt : io(Uint8Array),
        Ec = {
            "%AggregateError%": typeof AggregateError > "u" ? wt : AggregateError,
            "%Array%": Array,
            "%ArrayBuffer%": typeof ArrayBuffer > "u" ? wt : ArrayBuffer,
            "%ArrayIteratorPrototype%": Qa ? io([][Symbol.iterator]()) : wt,
            "%AsyncFromSyncIteratorPrototype%": wt,
            "%AsyncFunction%": rc,
            "%AsyncGenerator%": rc,
            "%AsyncGeneratorFunction%": rc,
            "%AsyncIteratorPrototype%": rc,
            "%Atomics%": typeof Atomics > "u" ? wt : Atomics,
            "%BigInt%": typeof BigInt > "u" ? wt : BigInt,
            "%Boolean%": Boolean,
            "%DataView%": typeof DataView > "u" ? wt : DataView,
            "%Date%": Date,
            "%decodeURI%": decodeURI,
            "%decodeURIComponent%": decodeURIComponent,
            "%encodeURI%": encodeURI,
            "%encodeURIComponent%": encodeURIComponent,
            "%Error%": Error,
            "%eval%": eval,
            "%EvalError%": EvalError,
            "%Float32Array%": typeof Float32Array > "u" ? wt : Float32Array,
            "%Float64Array%": typeof Float64Array > "u" ? wt : Float64Array,
            "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? wt : FinalizationRegistry,
            "%Function%": $4,
            "%GeneratorFunction%": rc,
            "%Int8Array%": typeof Int8Array > "u" ? wt : Int8Array,
            "%Int16Array%": typeof Int16Array > "u" ? wt : Int16Array,
            "%Int32Array%": typeof Int32Array > "u" ? wt : Int32Array,
            "%isFinite%": isFinite,
            "%isNaN%": isNaN,
            "%IteratorPrototype%": Qa ? io(io([][Symbol.iterator]())) : wt,
            "%JSON%": typeof JSON == "object" ? JSON : wt,
            "%Map%": typeof Map > "u" ? wt : Map,
            "%MapIteratorPrototype%": typeof Map > "u" || !Qa ? wt : io(new Map()[Symbol.iterator]()),
            "%Math%": Math,
            "%Number%": Number,
            "%Object%": Object,
            "%parseFloat%": parseFloat,
            "%parseInt%": parseInt,
            "%Promise%": typeof Promise > "u" ? wt : Promise,
            "%Proxy%": typeof Proxy > "u" ? wt : Proxy,
            "%RangeError%": RangeError,
            "%ReferenceError%": ReferenceError,
            "%Reflect%": typeof Reflect > "u" ? wt : Reflect,
            "%RegExp%": RegExp,
            "%Set%": typeof Set > "u" ? wt : Set,
            "%SetIteratorPrototype%": typeof Set > "u" || !Qa ? wt : io(new Set()[Symbol.iterator]()),
            "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? wt : SharedArrayBuffer,
            "%String%": String,
            "%StringIteratorPrototype%": Qa ? io("" [Symbol.iterator]()) : wt,
            "%Symbol%": Qa ? Symbol : wt,
            "%SyntaxError%": Dc,
            "%ThrowTypeError%": eV,
            "%TypedArray%": tV,
            "%TypeError%": bc,
            "%Uint8Array%": typeof Uint8Array > "u" ? wt : Uint8Array,
            "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? wt : Uint8ClampedArray,
            "%Uint16Array%": typeof Uint16Array > "u" ? wt : Uint16Array,
            "%Uint32Array%": typeof Uint32Array > "u" ? wt : Uint32Array,
            "%URIError%": URIError,
            "%WeakMap%": typeof WeakMap > "u" ? wt : WeakMap,
            "%WeakRef%": typeof WeakRef > "u" ? wt : WeakRef,
            "%WeakSet%": typeof WeakSet > "u" ? wt : WeakSet
        },
        nV = function t(e) {
            var n;
            if (e === "%AsyncFunction%") n = c_("async function () {}");
            else if (e === "%GeneratorFunction%") n = c_("function* () {}");
            else if (e === "%AsyncGeneratorFunction%") n = c_("async function* () {}");
            else if (e === "%AsyncGenerator%") {
                var r = t("%AsyncGeneratorFunction%");
                r && (n = r.prototype)
            } else if (e === "%AsyncIteratorPrototype%") {
                var s = t("%AsyncGenerator%");
                s && (n = io(s.prototype))
            }
            return Ec[e] = n, n
        },
        JT = {
            "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
            "%ArrayPrototype%": ["Array", "prototype"],
            "%ArrayProto_entries%": ["Array", "prototype", "entries"],
            "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
            "%ArrayProto_keys%": ["Array", "prototype", "keys"],
            "%ArrayProto_values%": ["Array", "prototype", "values"],
            "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
            "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
            "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
            "%BooleanPrototype%": ["Boolean", "prototype"],
            "%DataViewPrototype%": ["DataView", "prototype"],
            "%DatePrototype%": ["Date", "prototype"],
            "%ErrorPrototype%": ["Error", "prototype"],
            "%EvalErrorPrototype%": ["EvalError", "prototype"],
            "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
            "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
            "%FunctionPrototype%": ["Function", "prototype"],
            "%Generator%": ["GeneratorFunction", "prototype"],
            "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
            "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
            "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
            "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
            "%JSONParse%": ["JSON", "parse"],
            "%JSONStringify%": ["JSON", "stringify"],
            "%MapPrototype%": ["Map", "prototype"],
            "%NumberPrototype%": ["Number", "prototype"],
            "%ObjectPrototype%": ["Object", "prototype"],
            "%ObjProto_toString%": ["Object", "prototype", "toString"],
            "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
            "%PromisePrototype%": ["Promise", "prototype"],
            "%PromiseProto_then%": ["Promise", "prototype", "then"],
            "%Promise_all%": ["Promise", "all"],
            "%Promise_reject%": ["Promise", "reject"],
            "%Promise_resolve%": ["Promise", "resolve"],
            "%RangeErrorPrototype%": ["RangeError", "prototype"],
            "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
            "%RegExpPrototype%": ["RegExp", "prototype"],
            "%SetPrototype%": ["Set", "prototype"],
            "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
            "%StringPrototype%": ["String", "prototype"],
            "%SymbolPrototype%": ["Symbol", "prototype"],
            "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
            "%TypedArrayPrototype%": ["TypedArray", "prototype"],
            "%TypeErrorPrototype%": ["TypeError", "prototype"],
            "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
            "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
            "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
            "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
            "%URIErrorPrototype%": ["URIError", "prototype"],
            "%WeakMapPrototype%": ["WeakMap", "prototype"],
            "%WeakSetPrototype%": ["WeakSet", "prototype"]
        },
        Xu = _v,
        yd = Qj,
        rV = Xu.call(Function.call, Array.prototype.concat),
        sV = Xu.call(Function.apply, Array.prototype.splice),
        QT = Xu.call(Function.call, String.prototype.replace),
        vd = Xu.call(Function.call, String.prototype.slice),
        iV = Xu.call(Function.call, RegExp.prototype.exec),
        oV = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
        aV = /\\(\\)?/g,
        cV = function(e) {
            var n = vd(e, 0, 1),
                r = vd(e, -1);
            if (n === "%" && r !== "%") throw new Dc("invalid intrinsic syntax, expected closing `%`");
            if (r === "%" && n !== "%") throw new Dc("invalid intrinsic syntax, expected opening `%`");
            var s = [];
            return QT(e, oV, function(i, a, c, u) {
                s[s.length] = c ? QT(u, aV, "$1") : a || i
            }), s
        },
        lV = function(e, n) {
            var r = e,
                s;
            if (yd(JT, r) && (s = JT[r], r = "%" + s[0] + "%"), yd(Ec, r)) {
                var i = Ec[r];
                if (i === rc && (i = nV(r)), typeof i > "u" && !n) throw new bc("intrinsic " + e + " exists, but is not available. Please file an issue!");
                return {
                    alias: s,
                    name: r,
                    value: i
                }
            }
            throw new Dc("intrinsic " + e + " does not exist!")
        },
        yv = function(e, n) {
            if (typeof e != "string" || e.length === 0) throw new bc("intrinsic name must be a non-empty string");
            if (arguments.length > 1 && typeof n != "boolean") throw new bc('"allowMissing" argument must be a boolean');
            if (iV(/^%?[^%]*%?$/g, e) === null) throw new Dc("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
            var r = cV(e),
                s = r.length > 0 ? r[0] : "",
                i = lV("%" + s + "%", n),
                a = i.name,
                c = i.value,
                u = !1,
                h = i.alias;
            h && (s = h[0], sV(r, rV([0, 1], h)));
            for (var d = 1, p = !0; d < r.length; d += 1) {
                var m = r[d],
                    _ = vd(m, 0, 1),
                    y = vd(m, -1);
                if ((_ === '"' || _ === "'" || _ === "`" || y === '"' || y === "'" || y === "`") && _ !== y) throw new Dc("property names with quotes must have matching quotes");
                if ((m === "constructor" || !p) && (u = !0), s += "." + m, a = "%" + s + "%", yd(Ec, a)) c = Ec[a];
                else if (c != null) {
                    if (!(m in c)) {
                        if (!n) throw new bc("base intrinsic for " + e + " exists, but the property is not available.");
                        return
                    }
                    if (_a && d + 1 >= r.length) {
                        var v = _a(c, m);
                        p = !!v, p && "get" in v && !("originalValue" in v.get) ? c = v.get : c = c[m]
                    } else p = yd(c, m), c = c[m];
                    p && !u && (Ec[a] = c)
                }
            }
            return c
        },
        L4 = {
            exports: {}
        };
    (function(t) {
        var e = _v,
            n = yv,
            r = n("%Function.prototype.apply%"),
            s = n("%Function.prototype.call%"),
            i = n("%Reflect.apply%", !0) || e.call(s, r),
            a = n("%Object.getOwnPropertyDescriptor%", !0),
            c = n("%Object.defineProperty%", !0),
            u = n("%Math.max%");
        if (c) try {
            c({}, "a", {
                value: 1
            })
        } catch {
            c = null
        }
        t.exports = function(p) {
            var m = i(e, s, arguments);
            if (a && c) {
                var _ = a(m, "length");
                _.configurable && c(m, "length", {
                    value: 1 + u(0, p.length - (arguments.length - 1))
                })
            }
            return m
        };
        var h = function() {
            return i(e, r, arguments)
        };
        c ? c(t.exports, "apply", {
            value: h
        }) : t.exports.apply = h
    })(L4);
    var uV = L4.exports,
        F4 = yv,
        U4 = uV,
        hV = U4(F4("String.prototype.indexOf")),
        fV = function(e, n) {
            var r = F4(e, !!n);
            return typeof r == "function" && hV(e, ".prototype.") > -1 ? U4(r) : r
        };
    const dV = {},
        pV = Object.freeze(Object.defineProperty({
            __proto__: null,
            default: dV
        }, Symbol.toStringTag, {
            value: "Module"
        })),
        mV = KD(pV);
    var vv = typeof Map == "function" && Map.prototype,
        u_ = Object.getOwnPropertyDescriptor && vv ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
        bd = vv && u_ && typeof u_.get == "function" ? u_.get : null,
        gV = vv && Map.prototype.forEach,
        bv = typeof Set == "function" && Set.prototype,
        h_ = Object.getOwnPropertyDescriptor && bv ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
        Ed = bv && h_ && typeof h_.get == "function" ? h_.get : null,
        _V = bv && Set.prototype.forEach,
        yV = typeof WeakMap == "function" && WeakMap.prototype,
        Xl = yV ? WeakMap.prototype.has : null,
        vV = typeof WeakSet == "function" && WeakSet.prototype,
        Jl = vV ? WeakSet.prototype.has : null,
        bV = typeof WeakRef == "function" && WeakRef.prototype,
        eS = bV ? WeakRef.prototype.deref : null,
        EV = Boolean.prototype.valueOf,
        TV = Object.prototype.toString,
        SV = Function.prototype.toString,
        wV = String.prototype.match,
        Ev = String.prototype.slice,
        ho = String.prototype.replace,
        OV = String.prototype.toUpperCase,
        tS = String.prototype.toLowerCase,
        B4 = RegExp.prototype.test,
        nS = Array.prototype.concat,
        Ks = Array.prototype.join,
        AV = Array.prototype.slice,
        rS = Math.floor,
        d1 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
        f_ = Object.getOwnPropertySymbols,
        p1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null,
        $c = typeof Symbol == "function" && typeof Symbol.iterator == "object",
        rr = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === $c || "symbol") ? Symbol.toStringTag : null,
        q4 = Object.prototype.propertyIsEnumerable,
        sS = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
            return t.__proto__
        } : null);

    function iS(t, e) {
        if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || B4.call(/e/, e)) return e;
        var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof t == "number") {
            var r = t < 0 ? -rS(-t) : rS(t);
            if (r !== t) {
                var s = String(r),
                    i = Ev.call(e, s.length + 1);
                return ho.call(s, n, "$&_") + "." + ho.call(ho.call(i, /([0-9]{3})/g, "$&_"), /_$/, "")
            }
        }
        return ho.call(e, n, "$&_")
    }
    var m1 = mV,
        oS = m1.custom,
        aS = V4(oS) ? oS : null,
        CV = function t(e, n, r, s) {
            var i = n || {};
            if (oo(i, "quoteStyle") && i.quoteStyle !== "single" && i.quoteStyle !== "double") throw new TypeError('option "quoteStyle" must be "single" or "double"');
            if (oo(i, "maxStringLength") && (typeof i.maxStringLength == "number" ? i.maxStringLength < 0 && i.maxStringLength !== 1 / 0 : i.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
            var a = oo(i, "customInspect") ? i.customInspect : !0;
            if (typeof a != "boolean" && a !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
            if (oo(i, "indent") && i.indent !== null && i.indent !== "	" && !(parseInt(i.indent, 10) === i.indent && i.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
            if (oo(i, "numericSeparator") && typeof i.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
            var c = i.numericSeparator;
            if (typeof e > "u") return "undefined";
            if (e === null) return "null";
            if (typeof e == "boolean") return e ? "true" : "false";
            if (typeof e == "string") return W4(e, i);
            if (typeof e == "number") {
                if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
                var u = String(e);
                return c ? iS(e, u) : u
            }
            if (typeof e == "bigint") {
                var h = String(e) + "n";
                return c ? iS(e, h) : h
            }
            var d = typeof i.depth > "u" ? 5 : i.depth;
            if (typeof r > "u" && (r = 0), r >= d && d > 0 && typeof e == "object") return g1(e) ? "[Array]" : "[Object]";
            var p = WV(i, r);
            if (typeof s > "u") s = [];
            else if (G4(s, e) >= 0) return "[Circular]";

            function m(de, q, ie) {
                if (q && (s = AV.call(s), s.push(q)), ie) {
                    var ae = {
                        depth: i.depth
                    };
                    return oo(i, "quoteStyle") && (ae.quoteStyle = i.quoteStyle), t(de, ae, r + 1, s)
                }
                return t(de, i, r + 1, s)
            }
            if (typeof e == "function" && !cS(e)) {
                var _ = $V(e),
                    y = yf(e, m);
                return "[Function" + (_ ? ": " + _ : " (anonymous)") + "]" + (y.length > 0 ? " { " + Ks.call(y, ", ") + " }" : "")
            }
            if (V4(e)) {
                var v = $c ? ho.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : p1.call(e);
                return typeof e == "object" && !$c ? Ul(v) : v
            }
            if (jV(e)) {
                for (var w = "<" + tS.call(String(e.nodeName)), b = e.attributes || [], I = 0; I < b.length; I++) w += " " + b[I].name + "=" + j4(kV(b[I].value), "double", i);
                return w += ">", e.childNodes && e.childNodes.length && (w += "..."), w += "</" + tS.call(String(e.nodeName)) + ">", w
            }
            if (g1(e)) {
                if (e.length === 0) return "[]";
                var F = yf(e, m);
                return p && !GV(F) ? "[" + _1(F, p) + "]" : "[ " + Ks.call(F, ", ") + " ]"
            }
            if (NV(e)) {
                var x = yf(e, m);
                return !("cause" in Error.prototype) && "cause" in e && !q4.call(e, "cause") ? "{ [" + String(e) + "] " + Ks.call(nS.call("[cause]: " + m(e.cause), x), ", ") + " }" : x.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + Ks.call(x, ", ") + " }"
            }
            if (typeof e == "object" && a) {
                if (aS && typeof e[aS] == "function" && m1) return m1(e, {
                    depth: d - r
                });
                if (a !== "symbol" && typeof e.inspect == "function") return e.inspect()
            }
            if (LV(e)) {
                var O = [];
                return gV.call(e, function(de, q) {
                    O.push(m(q, e, !0) + " => " + m(de, e))
                }), lS("Map", bd.call(e), O, p)
            }
            if (BV(e)) {
                var M = [];
                return _V.call(e, function(de) {
                    M.push(m(de, e))
                }), lS("Set", Ed.call(e), M, p)
            }
            if (FV(e)) return d_("WeakMap");
            if (qV(e)) return d_("WeakSet");
            if (UV(e)) return d_("WeakRef");
            if (PV(e)) return Ul(m(Number(e)));
            if (MV(e)) return Ul(m(d1.call(e)));
            if (RV(e)) return Ul(EV.call(e));
            if (xV(e)) return Ul(m(String(e)));
            if (!IV(e) && !cS(e)) {
                var $ = yf(e, m),
                    j = sS ? sS(e) === Object.prototype : e instanceof Object || e.constructor === Object,
                    ee = e instanceof Object ? "" : "null prototype",
                    se = !j && rr && Object(e) === e && rr in e ? Ev.call(Do(e), 8, -1) : ee ? "Object" : "",
                    oe = j || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "",
                    Z = oe + (se || ee ? "[" + Ks.call(nS.call([], se || [], ee || []), ": ") + "] " : "");
                return $.length === 0 ? Z + "{}" : p ? Z + "{" + _1($, p) + "}" : Z + "{ " + Ks.call($, ", ") + " }"
            }
            return String(e)
        };

    function j4(t, e, n) {
        var r = (n.quoteStyle || e) === "double" ? '"' : "'";
        return r + t + r
    }

    function kV(t) {
        return ho.call(String(t), /"/g, "&quot;")
    }

    function g1(t) {
        return Do(t) === "[object Array]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function IV(t) {
        return Do(t) === "[object Date]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function cS(t) {
        return Do(t) === "[object RegExp]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function NV(t) {
        return Do(t) === "[object Error]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function xV(t) {
        return Do(t) === "[object String]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function PV(t) {
        return Do(t) === "[object Number]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function RV(t) {
        return Do(t) === "[object Boolean]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function V4(t) {
        if ($c) return t && typeof t == "object" && t instanceof Symbol;
        if (typeof t == "symbol") return !0;
        if (!t || typeof t != "object" || !p1) return !1;
        try {
            return p1.call(t), !0
        } catch {}
        return !1
    }

    function MV(t) {
        if (!t || typeof t != "object" || !d1) return !1;
        try {
            return d1.call(t), !0
        } catch {}
        return !1
    }
    var DV = Object.prototype.hasOwnProperty || function(t) {
        return t in this
    };

    function oo(t, e) {
        return DV.call(t, e)
    }

    function Do(t) {
        return TV.call(t)
    }

    function $V(t) {
        if (t.name) return t.name;
        var e = wV.call(SV.call(t), /^function\s*([\w$]+)/);
        return e ? e[1] : null
    }

    function G4(t, e) {
        if (t.indexOf) return t.indexOf(e);
        for (var n = 0, r = t.length; n < r; n++)
            if (t[n] === e) return n;
        return -1
    }

    function LV(t) {
        if (!bd || !t || typeof t != "object") return !1;
        try {
            bd.call(t);
            try {
                Ed.call(t)
            } catch {
                return !0
            }
            return t instanceof Map
        } catch {}
        return !1
    }

    function FV(t) {
        if (!Xl || !t || typeof t != "object") return !1;
        try {
            Xl.call(t, Xl);
            try {
                Jl.call(t, Jl)
            } catch {
                return !0
            }
            return t instanceof WeakMap
        } catch {}
        return !1
    }

    function UV(t) {
        if (!eS || !t || typeof t != "object") return !1;
        try {
            return eS.call(t), !0
        } catch {}
        return !1
    }

    function BV(t) {
        if (!Ed || !t || typeof t != "object") return !1;
        try {
            Ed.call(t);
            try {
                bd.call(t)
            } catch {
                return !0
            }
            return t instanceof Set
        } catch {}
        return !1
    }

    function qV(t) {
        if (!Jl || !t || typeof t != "object") return !1;
        try {
            Jl.call(t, Jl);
            try {
                Xl.call(t, Xl)
            } catch {
                return !0
            }
            return t instanceof WeakSet
        } catch {}
        return !1
    }

    function jV(t) {
        return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function"
    }

    function W4(t, e) {
        if (t.length > e.maxStringLength) {
            var n = t.length - e.maxStringLength,
                r = "... " + n + " more character" + (n > 1 ? "s" : "");
            return W4(Ev.call(t, 0, e.maxStringLength), e) + r
        }
        var s = ho.call(ho.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, VV);
        return j4(s, "single", e)
    }

    function VV(t) {
        var e = t.charCodeAt(0),
            n = {
                8: "b",
                9: "t",
                10: "n",
                12: "f",
                13: "r"
            } [e];
        return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + OV.call(e.toString(16))
    }

    function Ul(t) {
        return "Object(" + t + ")"
    }

    function d_(t) {
        return t + " { ? }"
    }

    function lS(t, e, n, r) {
        var s = r ? _1(n, r) : Ks.call(n, ", ");
        return t + " (" + e + ") {" + s + "}"
    }

    function GV(t) {
        for (var e = 0; e < t.length; e++)
            if (G4(t[e], `
`) >= 0) return !1;
        return !0
    }

    function WV(t, e) {
        var n;
        if (t.indent === "	") n = "	";
        else if (typeof t.indent == "number" && t.indent > 0) n = Ks.call(Array(t.indent + 1), " ");
        else return null;
        return {
            base: n,
            prev: Ks.call(Array(e + 1), n)
        }
    }

    function _1(t, e) {
        if (t.length === 0) return "";
        var n = `
` + e.prev + e.base;
        return n + Ks.call(t, "," + n) + `
` + e.prev
    }

    function yf(t, e) {
        var n = g1(t),
            r = [];
        if (n) {
            r.length = t.length;
            for (var s = 0; s < t.length; s++) r[s] = oo(t, s) ? e(t[s], t) : ""
        }
        var i = typeof f_ == "function" ? f_(t) : [],
            a;
        if ($c) {
            a = {};
            for (var c = 0; c < i.length; c++) a["$" + i[c]] = i[c]
        }
        for (var u in t) oo(t, u) && (n && String(Number(u)) === u && u < t.length || $c && a["$" + u] instanceof Symbol || (B4.call(/[^\w$]/, u) ? r.push(e(u, t) + ": " + e(t[u], t)) : r.push(u + ": " + e(t[u], t))));
        if (typeof f_ == "function")
            for (var h = 0; h < i.length; h++) q4.call(t, i[h]) && r.push("[" + e(i[h]) + "]: " + e(t[i[h]], t));
        return r
    }
    var Tv = yv,
        al = fV,
        HV = CV,
        KV = Tv("%TypeError%"),
        vf = Tv("%WeakMap%", !0),
        bf = Tv("%Map%", !0),
        YV = al("WeakMap.prototype.get", !0),
        zV = al("WeakMap.prototype.set", !0),
        ZV = al("WeakMap.prototype.has", !0),
        XV = al("Map.prototype.get", !0),
        JV = al("Map.prototype.set", !0),
        QV = al("Map.prototype.has", !0),
        Sv = function(t, e) {
            for (var n = t, r;
                (r = n.next) !== null; n = r)
                if (r.key === e) return n.next = r.next, r.next = t.next, t.next = r, r
        },
        eG = function(t, e) {
            var n = Sv(t, e);
            return n && n.value
        },
        tG = function(t, e, n) {
            var r = Sv(t, e);
            r ? r.value = n : t.next = {
                key: e,
                next: t.next,
                value: n
            }
        },
        nG = function(t, e) {
            return !!Sv(t, e)
        },
        rG = function() {
            var e, n, r, s = {
                assert: function(i) {
                    if (!s.has(i)) throw new KV("Side channel does not contain " + HV(i))
                },
                get: function(i) {
                    if (vf && i && (typeof i == "object" || typeof i == "function")) {
                        if (e) return YV(e, i)
                    } else if (bf) {
                        if (n) return XV(n, i)
                    } else if (r) return eG(r, i)
                },
                has: function(i) {
                    if (vf && i && (typeof i == "object" || typeof i == "function")) {
                        if (e) return ZV(e, i)
                    } else if (bf) {
                        if (n) return QV(n, i)
                    } else if (r) return nG(r, i);
                    return !1
                },
                set: function(i, a) {
                    vf && i && (typeof i == "object" || typeof i == "function") ? (e || (e = new vf), zV(e, i, a)) : bf ? (n || (n = new bf), JV(n, i, a)) : (r || (r = {
                        key: {},
                        next: null
                    }), tG(r, i, a))
                }
            };
            return s
        },
        sG = String.prototype.replace,
        iG = /%20/g,
        p_ = {
            RFC1738: "RFC1738",
            RFC3986: "RFC3986"
        },
        wv = {
            default: p_.RFC3986,
            formatters: {
                RFC1738: function(t) {
                    return sG.call(t, iG, "+")
                },
                RFC3986: function(t) {
                    return String(t)
                }
            },
            RFC1738: p_.RFC1738,
            RFC3986: p_.RFC3986
        },
        oG = wv,
        m_ = Object.prototype.hasOwnProperty,
        ca = Array.isArray,
        js = function() {
            for (var t = [], e = 0; e < 256; ++e) t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
            return t
        }(),
        aG = function(e) {
            for (; e.length > 1;) {
                var n = e.pop(),
                    r = n.obj[n.prop];
                if (ca(r)) {
                    for (var s = [], i = 0; i < r.length; ++i) typeof r[i] < "u" && s.push(r[i]);
                    n.obj[n.prop] = s
                }
            }
        },
        H4 = function(e, n) {
            for (var r = n && n.plainObjects ? Object.create(null) : {}, s = 0; s < e.length; ++s) typeof e[s] < "u" && (r[s] = e[s]);
            return r
        },
        cG = function t(e, n, r) {
            if (!n) return e;
            if (typeof n != "object") {
                if (ca(e)) e.push(n);
                else if (e && typeof e == "object")(r && (r.plainObjects || r.allowPrototypes) || !m_.call(Object.prototype, n)) && (e[n] = !0);
                else return [e, n];
                return e
            }
            if (!e || typeof e != "object") return [e].concat(n);
            var s = e;
            return ca(e) && !ca(n) && (s = H4(e, r)), ca(e) && ca(n) ? (n.forEach(function(i, a) {
                if (m_.call(e, a)) {
                    var c = e[a];
                    c && typeof c == "object" && i && typeof i == "object" ? e[a] = t(c, i, r) : e.push(i)
                } else e[a] = i
            }), e) : Object.keys(n).reduce(function(i, a) {
                var c = n[a];
                return m_.call(i, a) ? i[a] = t(i[a], c, r) : i[a] = c, i
            }, s)
        },
        lG = function(e, n) {
            return Object.keys(n).reduce(function(r, s) {
                return r[s] = n[s], r
            }, e)
        },
        uG = function(t, e, n) {
            var r = t.replace(/\+/g, " ");
            if (n === "iso-8859-1") return r.replace(/%[0-9a-f]{2}/gi, unescape);
            try {
                return decodeURIComponent(r)
            } catch {
                return r
            }
        },
        hG = function(e, n, r, s, i) {
            if (e.length === 0) return e;
            var a = e;
            if (typeof e == "symbol" ? a = Symbol.prototype.toString.call(e) : typeof e != "string" && (a = String(e)), r === "iso-8859-1") return escape(a).replace(/%u[0-9a-f]{4}/gi, function(d) {
                return "%26%23" + parseInt(d.slice(2), 16) + "%3B"
            });
            for (var c = "", u = 0; u < a.length; ++u) {
                var h = a.charCodeAt(u);
                if (h === 45 || h === 46 || h === 95 || h === 126 || h >= 48 && h <= 57 || h >= 65 && h <= 90 || h >= 97 && h <= 122 || i === oG.RFC1738 && (h === 40 || h === 41)) {
                    c += a.charAt(u);
                    continue
                }
                if (h < 128) {
                    c = c + js[h];
                    continue
                }
                if (h < 2048) {
                    c = c + (js[192 | h >> 6] + js[128 | h & 63]);
                    continue
                }
                if (h < 55296 || h >= 57344) {
                    c = c + (js[224 | h >> 12] + js[128 | h >> 6 & 63] + js[128 | h & 63]);
                    continue
                }
                u += 1, h = 65536 + ((h & 1023) << 10 | a.charCodeAt(u) & 1023), c += js[240 | h >> 18] + js[128 | h >> 12 & 63] + js[128 | h >> 6 & 63] + js[128 | h & 63]
            }
            return c
        },
        fG = function(e) {
            for (var n = [{
                    obj: {
                        o: e
                    },
                    prop: "o"
                }], r = [], s = 0; s < n.length; ++s)
                for (var i = n[s], a = i.obj[i.prop], c = Object.keys(a), u = 0; u < c.length; ++u) {
                    var h = c[u],
                        d = a[h];
                    typeof d == "object" && d !== null && r.indexOf(d) === -1 && (n.push({
                        obj: a,
                        prop: h
                    }), r.push(d))
                }
            return aG(n), e
        },
        dG = function(e) {
            return Object.prototype.toString.call(e) === "[object RegExp]"
        },
        pG = function(e) {
            return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
        },
        mG = function(e, n) {
            return [].concat(e, n)
        },
        gG = function(e, n) {
            if (ca(e)) {
                for (var r = [], s = 0; s < e.length; s += 1) r.push(n(e[s]));
                return r
            }
            return n(e)
        },
        K4 = {
            arrayToObject: H4,
            assign: lG,
            combine: mG,
            compact: fG,
            decode: uG,
            encode: hG,
            isBuffer: pG,
            isRegExp: dG,
            maybeMap: gG,
            merge: cG
        },
        Y4 = rG,
        Hf = K4,
        Ql = wv,
        _G = Object.prototype.hasOwnProperty,
        uS = {
            brackets: function(e) {
                return e + "[]"
            },
            comma: "comma",
            indices: function(e, n) {
                return e + "[" + n + "]"
            },
            repeat: function(e) {
                return e
            }
        },
        Oi = Array.isArray,
        yG = Array.prototype.push,
        z4 = function(t, e) {
            yG.apply(t, Oi(e) ? e : [e])
        },
        vG = Date.prototype.toISOString,
        hS = Ql.default,
        Jn = {
            addQueryPrefix: !1,
            allowDots: !1,
            charset: "utf-8",
            charsetSentinel: !1,
            delimiter: "&",
            encode: !0,
            encoder: Hf.encode,
            encodeValuesOnly: !1,
            format: hS,
            formatter: Ql.formatters[hS],
            indices: !1,
            serializeDate: function(e) {
                return vG.call(e)
            },
            skipNulls: !1,
            strictNullHandling: !1
        },
        bG = function(e) {
            return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint"
        },
        g_ = {},
        EG = function t(e, n, r, s, i, a, c, u, h, d, p, m, _, y, v, w) {
            for (var b = e, I = w, F = 0, x = !1;
                (I = I.get(g_)) !== void 0 && !x;) {
                var O = I.get(e);
                if (F += 1, typeof O < "u") {
                    if (O === F) throw new RangeError("Cyclic object value");
                    x = !0
                }
                typeof I.get(g_) > "u" && (F = 0)
            }
            if (typeof u == "function" ? b = u(n, b) : b instanceof Date ? b = p(b) : r === "comma" && Oi(b) && (b = Hf.maybeMap(b, function(ae) {
                    return ae instanceof Date ? p(ae) : ae
                })), b === null) {
                if (i) return c && !y ? c(n, Jn.encoder, v, "key", m) : n;
                b = ""
            }
            if (bG(b) || Hf.isBuffer(b)) {
                if (c) {
                    var M = y ? n : c(n, Jn.encoder, v, "key", m);
                    return [_(M) + "=" + _(c(b, Jn.encoder, v, "value", m))]
                }
                return [_(n) + "=" + _(String(b))]
            }
            var $ = [];
            if (typeof b > "u") return $;
            var j;
            if (r === "comma" && Oi(b)) y && c && (b = Hf.maybeMap(b, c)), j = [{
                value: b.length > 0 ? b.join(",") || null : void 0
            }];
            else if (Oi(u)) j = u;
            else {
                var ee = Object.keys(b);
                j = h ? ee.sort(h) : ee
            }
            for (var se = s && Oi(b) && b.length === 1 ? n + "[]" : n, oe = 0; oe < j.length; ++oe) {
                var Z = j[oe],
                    de = typeof Z == "object" && typeof Z.value < "u" ? Z.value : b[Z];
                if (!(a && de === null)) {
                    var q = Oi(b) ? typeof r == "function" ? r(se, Z) : se : se + (d ? "." + Z : "[" + Z + "]");
                    w.set(e, F);
                    var ie = Y4();
                    ie.set(g_, w), z4($, t(de, q, r, s, i, a, r === "comma" && y && Oi(b) ? null : c, u, h, d, p, m, _, y, v, ie))
                }
            }
            return $
        },
        TG = function(e) {
            if (!e) return Jn;
            if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function") throw new TypeError("Encoder has to be a function.");
            var n = e.charset || Jn.charset;
            if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
            var r = Ql.default;
            if (typeof e.format < "u") {
                if (!_G.call(Ql.formatters, e.format)) throw new TypeError("Unknown format option provided.");
                r = e.format
            }
            var s = Ql.formatters[r],
                i = Jn.filter;
            return (typeof e.filter == "function" || Oi(e.filter)) && (i = e.filter), {
                addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : Jn.addQueryPrefix,
                allowDots: typeof e.allowDots > "u" ? Jn.allowDots : !!e.allowDots,
                charset: n,
                charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Jn.charsetSentinel,
                delimiter: typeof e.delimiter > "u" ? Jn.delimiter : e.delimiter,
                encode: typeof e.encode == "boolean" ? e.encode : Jn.encode,
                encoder: typeof e.encoder == "function" ? e.encoder : Jn.encoder,
                encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : Jn.encodeValuesOnly,
                filter: i,
                format: r,
                formatter: s,
                serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : Jn.serializeDate,
                skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : Jn.skipNulls,
                sort: typeof e.sort == "function" ? e.sort : null,
                strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Jn.strictNullHandling
            }
        },
        SG = function(t, e) {
            var n = t,
                r = TG(e),
                s, i;
            typeof r.filter == "function" ? (i = r.filter, n = i("", n)) : Oi(r.filter) && (i = r.filter, s = i);
            var a = [];
            if (typeof n != "object" || n === null) return "";
            var c;
            e && e.arrayFormat in uS ? c = e.arrayFormat : e && "indices" in e ? c = e.indices ? "indices" : "repeat" : c = "indices";
            var u = uS[c];
            if (e && "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
            var h = u === "comma" && e && e.commaRoundTrip;
            s || (s = Object.keys(n)), r.sort && s.sort(r.sort);
            for (var d = Y4(), p = 0; p < s.length; ++p) {
                var m = s[p];
                r.skipNulls && n[m] === null || z4(a, EG(n[m], m, u, h, r.strictNullHandling, r.skipNulls, r.encode ? r.encoder : null, r.filter, r.sort, r.allowDots, r.serializeDate, r.format, r.formatter, r.encodeValuesOnly, r.charset, d))
            }
            var _ = a.join(r.delimiter),
                y = r.addQueryPrefix === !0 ? "?" : "";
            return r.charsetSentinel && (r.charset === "iso-8859-1" ? y += "utf8=%26%2310003%3B&" : y += "utf8=%E2%9C%93&"), _.length > 0 ? y + _ : ""
        },
        Lc = K4,
        y1 = Object.prototype.hasOwnProperty,
        wG = Array.isArray,
        Dn = {
            allowDots: !1,
            allowPrototypes: !1,
            allowSparse: !1,
            arrayLimit: 20,
            charset: "utf-8",
            charsetSentinel: !1,
            comma: !1,
            decoder: Lc.decode,
            delimiter: "&",
            depth: 5,
            ignoreQueryPrefix: !1,
            interpretNumericEntities: !1,
            parameterLimit: 1e3,
            parseArrays: !0,
            plainObjects: !1,
            strictNullHandling: !1
        },
        OG = function(t) {
            return t.replace(/&#(\d+);/g, function(e, n) {
                return String.fromCharCode(parseInt(n, 10))
            })
        },
        Z4 = function(t, e) {
            return t && typeof t == "string" && e.comma && t.indexOf(",") > -1 ? t.split(",") : t
        },
        AG = "utf8=%26%2310003%3B",
        CG = "utf8=%E2%9C%93",
        kG = function(e, n) {
            var r = {
                    __proto__: null
                },
                s = n.ignoreQueryPrefix ? e.replace(/^\?/, "") : e,
                i = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit,
                a = s.split(n.delimiter, i),
                c = -1,
                u, h = n.charset;
            if (n.charsetSentinel)
                for (u = 0; u < a.length; ++u) a[u].indexOf("utf8=") === 0 && (a[u] === CG ? h = "utf-8" : a[u] === AG && (h = "iso-8859-1"), c = u, u = a.length);
            for (u = 0; u < a.length; ++u)
                if (u !== c) {
                    var d = a[u],
                        p = d.indexOf("]="),
                        m = p === -1 ? d.indexOf("=") : p + 1,
                        _, y;
                    m === -1 ? (_ = n.decoder(d, Dn.decoder, h, "key"), y = n.strictNullHandling ? null : "") : (_ = n.decoder(d.slice(0, m), Dn.decoder, h, "key"), y = Lc.maybeMap(Z4(d.slice(m + 1), n), function(v) {
                        return n.decoder(v, Dn.decoder, h, "value")
                    })), y && n.interpretNumericEntities && h === "iso-8859-1" && (y = OG(y)), d.indexOf("[]=") > -1 && (y = wG(y) ? [y] : y), y1.call(r, _) ? r[_] = Lc.combine(r[_], y) : r[_] = y
                } return r
        },
        IG = function(t, e, n, r) {
            for (var s = r ? e : Z4(e, n), i = t.length - 1; i >= 0; --i) {
                var a, c = t[i];
                if (c === "[]" && n.parseArrays) a = [].concat(s);
                else {
                    a = n.plainObjects ? Object.create(null) : {};
                    var u = c.charAt(0) === "[" && c.charAt(c.length - 1) === "]" ? c.slice(1, -1) : c,
                        h = parseInt(u, 10);
                    !n.parseArrays && u === "" ? a = {
                        0: s
                    } : !isNaN(h) && c !== u && String(h) === u && h >= 0 && n.parseArrays && h <= n.arrayLimit ? (a = [], a[h] = s) : u !== "__proto__" && (a[u] = s)
                }
                s = a
            }
            return s
        },
        NG = function(e, n, r, s) {
            if (e) {
                var i = r.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
                    a = /(\[[^[\]]*])/,
                    c = /(\[[^[\]]*])/g,
                    u = r.depth > 0 && a.exec(i),
                    h = u ? i.slice(0, u.index) : i,
                    d = [];
                if (h) {
                    if (!r.plainObjects && y1.call(Object.prototype, h) && !r.allowPrototypes) return;
                    d.push(h)
                }
                for (var p = 0; r.depth > 0 && (u = c.exec(i)) !== null && p < r.depth;) {
                    if (p += 1, !r.plainObjects && y1.call(Object.prototype, u[1].slice(1, -1)) && !r.allowPrototypes) return;
                    d.push(u[1])
                }
                return u && d.push("[" + i.slice(u.index) + "]"), IG(d, n, r, s)
            }
        },
        xG = function(e) {
            if (!e) return Dn;
            if (e.decoder !== null && e.decoder !== void 0 && typeof e.decoder != "function") throw new TypeError("Decoder has to be a function.");
            if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
            var n = typeof e.charset > "u" ? Dn.charset : e.charset;
            return {
                allowDots: typeof e.allowDots > "u" ? Dn.allowDots : !!e.allowDots,
                allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : Dn.allowPrototypes,
                allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : Dn.allowSparse,
                arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : Dn.arrayLimit,
                charset: n,
                charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Dn.charsetSentinel,
                comma: typeof e.comma == "boolean" ? e.comma : Dn.comma,
                decoder: typeof e.decoder == "function" ? e.decoder : Dn.decoder,
                delimiter: typeof e.delimiter == "string" || Lc.isRegExp(e.delimiter) ? e.delimiter : Dn.delimiter,
                depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : Dn.depth,
                ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
                interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : Dn.interpretNumericEntities,
                parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : Dn.parameterLimit,
                parseArrays: e.parseArrays !== !1,
                plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : Dn.plainObjects,
                strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Dn.strictNullHandling
            }
        },
        PG = function(t, e) {
            var n = xG(e);
            if (t === "" || t === null || typeof t > "u") return n.plainObjects ? Object.create(null) : {};
            for (var r = typeof t == "string" ? kG(t, n) : t, s = n.plainObjects ? Object.create(null) : {}, i = Object.keys(r), a = 0; a < i.length; ++a) {
                var c = i[a],
                    u = NG(c, r[c], n, typeof t == "string");
                s = Lc.merge(s, u, n)
            }
            return n.allowSparse === !0 ? s : Lc.compact(s)
        },
        RG = SG,
        MG = PG,
        DG = wv,
        X4 = {
            formats: DG,
            parse: MG,
            stringify: RG
        };
    let $G = class {
            constructor(e) {
                this.code = e.code, this.token = e.token, this.host = e.host
            }
        },
        LG = class {
            constructor(e) {
                this.appId = e.appId, this.appTag = e.appTag, this.audienceEnabled = e.audienceEnabled, this.code = e.code, this.host = e.host, this.audienceHost = e.audienceHost, this.locked = e.locked, this.full = e.full, this.maxPlayers = e.maxPlayers, this.minPlayers = e.minPlayers, this.moderationEnabled = e.moderationEnabled, this.passwordRequired = e.passwordRequired, this.twitchLocked = e.twitchLocked, this.locale = e.locale, this.keepalive = e.keepalive, this.controllerBranch = e.controllerBranch
            }
        },
        FG = class {
            constructor(e) {
                this.connections = e.connections
            }
        },
        UG = class {
            constructor(e) {
                this.cause = e.cause
            }
            whenReceived(e) {
                e.disconnect()
            }
        },
        BG = class {};
    var Jp = {
        CreateRoomReply: $G,
        GetRoomReply: LG,
        GetAudienceReply: FG,
        RoomExit: UG,
        RoomLock: BG
    };
    const fS = Vj,
        qG = X4,
        {
            CreateRoomReply: jG,
            GetRoomReply: VG
        } = Jp;
    let GG = class {
        constructor(e) {
            if (!e.host) throw new Error("unable to create ecast APIClient: no host provided");
            if (this.host = e.host, !e.scheme) throw new Error("unable to create ecast APIClient: no scheme provided");
            this.scheme = e.scheme
        }
        url(e, n) {
            if (n) {
                let r = qG.stringify(n);
                return `${this.scheme}://${this.host}/api/v2${e}?${r}`
            }
            return `${this.scheme}://${this.host}/api/v2${e}`
        }
        async createRoom(e) {
            let n = {
                    appTag: "test",
                    userId: "fart",
                    ...e
                },
                r = this.url("/rooms", n),
                i = await fS(r, {
                    method: "POST"
                });
            const {
                body: a,
                error: c,
                ok: u
            } = await i.json();
            if (!u) throw new Error(`failed to create room: ${c}`);
            return new jG({
                code: a.code,
                token: a.token,
                host: a.host
            })
        }
        async getRoom(e) {
            let n = this.url(`/rooms/${e.code}`),
                s = await (await fS(n)).json();
            if (!s.ok) throw new Error(`unable to get room with options ${JSON.stringify(e)}: ${s.error}`);
            let i = s.body;
            return new VG({
                appId: i.appId,
                appTag: i.appTag,
                audienceEnabled: i.audienceEnabled,
                code: i.code,
                host: i.host,
                audienceHost: i.audienceHost,
                locked: i.locked,
                full: i.full,
                maxPlayers: i.maxPlayers,
                minPlayers: i.minPlayers,
                moderationEnabled: i.moderationEnabled,
                passwordRequired: i.passwordRequired,
                twitchLocked: i.twitchLocked,
                locale: i.locale,
                keepalive: i.keepalive,
                controllerBranch: i.controllerBranch
            })
        }
    };
    var WG = {
            APIClient: GG
        },
        sc = null;
    typeof WebSocket < "u" ? sc = WebSocket : typeof MozWebSocket < "u" ? sc = MozWebSocket : typeof gn < "u" ? sc = gn.WebSocket || gn.MozWebSocket : typeof window < "u" ? sc = window.WebSocket || window.MozWebSocket : typeof self < "u" && (sc = self.WebSocket || self.MozWebSocket);
    var HG = sc,
        Ov = {
            exports: {}
        },
        Tc = typeof Reflect == "object" ? Reflect : null,
        dS = Tc && typeof Tc.apply == "function" ? Tc.apply : function(e, n, r) {
            return Function.prototype.apply.call(e, n, r)
        },
        Kf;
    Tc && typeof Tc.ownKeys == "function" ? Kf = Tc.ownKeys : Object.getOwnPropertySymbols ? Kf = function(e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
    } : Kf = function(e) {
        return Object.getOwnPropertyNames(e)
    };

    function KG(t) {
        console && console.warn && console.warn(t)
    }
    var J4 = Number.isNaN || function(e) {
        return e !== e
    };

    function Dt() {
        Dt.init.call(this)
    }
    Ov.exports = Dt;
    Ov.exports.once = XG;
    Dt.EventEmitter = Dt;
    Dt.prototype._events = void 0;
    Dt.prototype._eventsCount = 0;
    Dt.prototype._maxListeners = void 0;
    var pS = 10;

    function Qp(t) {
        if (typeof t != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
    }
    Object.defineProperty(Dt, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return pS
        },
        set: function(t) {
            if (typeof t != "number" || t < 0 || J4(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
            pS = t
        }
    });
    Dt.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
    };
    Dt.prototype.setMaxListeners = function(e) {
        if (typeof e != "number" || e < 0 || J4(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
        return this._maxListeners = e, this
    };

    function Q4(t) {
        return t._maxListeners === void 0 ? Dt.defaultMaxListeners : t._maxListeners
    }
    Dt.prototype.getMaxListeners = function() {
        return Q4(this)
    };
    Dt.prototype.emit = function(e) {
        for (var n = [], r = 1; r < arguments.length; r++) n.push(arguments[r]);
        var s = e === "error",
            i = this._events;
        if (i !== void 0) s = s && i.error === void 0;
        else if (!s) return !1;
        if (s) {
            var a;
            if (n.length > 0 && (a = n[0]), a instanceof Error) throw a;
            var c = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
            throw c.context = a, c
        }
        var u = i[e];
        if (u === void 0) return !1;
        if (typeof u == "function") dS(u, this, n);
        else
            for (var h = u.length, d = sO(u, h), r = 0; r < h; ++r) dS(d[r], this, n);
        return !0
    };

    function eO(t, e, n, r) {
        var s, i, a;
        if (Qp(n), i = t._events, i === void 0 ? (i = t._events = Object.create(null), t._eventsCount = 0) : (i.newListener !== void 0 && (t.emit("newListener", e, n.listener ? n.listener : n), i = t._events), a = i[e]), a === void 0) a = i[e] = n, ++t._eventsCount;
        else if (typeof a == "function" ? a = i[e] = r ? [n, a] : [a, n] : r ? a.unshift(n) : a.push(n), s = Q4(t), s > 0 && a.length > s && !a.warned) {
            a.warned = !0;
            var c = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            c.name = "MaxListenersExceededWarning", c.emitter = t, c.type = e, c.count = a.length, KG(c)
        }
        return t
    }
    Dt.prototype.addListener = function(e, n) {
        return eO(this, e, n, !1)
    };
    Dt.prototype.on = Dt.prototype.addListener;
    Dt.prototype.prependListener = function(e, n) {
        return eO(this, e, n, !0)
    };

    function YG() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }

    function tO(t, e, n) {
        var r = {
                fired: !1,
                wrapFn: void 0,
                target: t,
                type: e,
                listener: n
            },
            s = YG.bind(r);
        return s.listener = n, r.wrapFn = s, s
    }
    Dt.prototype.once = function(e, n) {
        return Qp(n), this.on(e, tO(this, e, n)), this
    };
    Dt.prototype.prependOnceListener = function(e, n) {
        return Qp(n), this.prependListener(e, tO(this, e, n)), this
    };
    Dt.prototype.removeListener = function(e, n) {
        var r, s, i, a, c;
        if (Qp(n), s = this._events, s === void 0) return this;
        if (r = s[e], r === void 0) return this;
        if (r === n || r.listener === n) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete s[e], s.removeListener && this.emit("removeListener", e, r.listener || n));
        else if (typeof r != "function") {
            for (i = -1, a = r.length - 1; a >= 0; a--)
                if (r[a] === n || r[a].listener === n) {
                    c = r[a].listener, i = a;
                    break
                } if (i < 0) return this;
            i === 0 ? r.shift() : zG(r, i), r.length === 1 && (s[e] = r[0]), s.removeListener !== void 0 && this.emit("removeListener", e, c || n)
        }
        return this
    };
    Dt.prototype.off = Dt.prototype.removeListener;
    Dt.prototype.removeAllListeners = function(e) {
        var n, r, s;
        if (r = this._events, r === void 0) return this;
        if (r.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r[e]), this;
        if (arguments.length === 0) {
            var i = Object.keys(r),
                a;
            for (s = 0; s < i.length; ++s) a = i[s], a !== "removeListener" && this.removeAllListeners(a);
            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
        }
        if (n = r[e], typeof n == "function") this.removeListener(e, n);
        else if (n !== void 0)
            for (s = n.length - 1; s >= 0; s--) this.removeListener(e, n[s]);
        return this
    };

    function nO(t, e, n) {
        var r = t._events;
        if (r === void 0) return [];
        var s = r[e];
        return s === void 0 ? [] : typeof s == "function" ? n ? [s.listener || s] : [s] : n ? ZG(s) : sO(s, s.length)
    }
    Dt.prototype.listeners = function(e) {
        return nO(this, e, !0)
    };
    Dt.prototype.rawListeners = function(e) {
        return nO(this, e, !1)
    };
    Dt.listenerCount = function(t, e) {
        return typeof t.listenerCount == "function" ? t.listenerCount(e) : rO.call(t, e)
    };
    Dt.prototype.listenerCount = rO;

    function rO(t) {
        var e = this._events;
        if (e !== void 0) {
            var n = e[t];
            if (typeof n == "function") return 1;
            if (n !== void 0) return n.length
        }
        return 0
    }
    Dt.prototype.eventNames = function() {
        return this._eventsCount > 0 ? Kf(this._events) : []
    };

    function sO(t, e) {
        for (var n = new Array(e), r = 0; r < e; ++r) n[r] = t[r];
        return n
    }

    function zG(t, e) {
        for (; e + 1 < t.length; e++) t[e] = t[e + 1];
        t.pop()
    }

    function ZG(t) {
        for (var e = new Array(t.length), n = 0; n < e.length; ++n) e[n] = t[n].listener || t[n];
        return e
    }

    function XG(t, e) {
        return new Promise(function(n, r) {
            function s(a) {
                t.removeListener(e, i), r(a)
            }

            function i() {
                typeof t.removeListener == "function" && t.removeListener("error", s), n([].slice.call(arguments))
            }
            iO(t, e, i, {
                once: !0
            }), e !== "error" && JG(t, s, {
                once: !0
            })
        })
    }

    function JG(t, e, n) {
        typeof t.on == "function" && iO(t, "error", e, n)
    }

    function iO(t, e, n, r) {
        if (typeof t.on == "function") r.once ? t.once(e, n) : t.on(e, n);
        else if (typeof t.addEventListener == "function") t.addEventListener(e, function s(i) {
            r.once && t.removeEventListener(e, s), n(i)
        });
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t)
    }
    var QG = Ov.exports;
    let eW = class {
            constructor(e) {
                e && (this.error = e.error, this.to = e.to, this.opcode = e.opcode)
            }
            toString() {
                return `ObservedError{
	to:${this.to}
	error:${this.error}
	opcode:${this.opcode}
}`
            }
        },
        em = class extends Error {
            constructor(e) {
                super(e), e && (this.code = e.code, this.message = e.message)
            }
        };
    class Ju extends em {
        constructor(e) {
            super(e), this.code = 1e3, this.message = e && e.message ? e.message : "ecast server error"
        }
    }
    class oO extends Ju {
        constructor(e) {
            super(e), this.code = 1001, this.message = e && e.message ? e.message : "create room failed"
        }
    }
    class aO extends Ju {
        constructor(e) {
            super(e), this.code = 1002, this.message = e && e.message ? e.message : "unable to connect to room"
        }
    }
    class cO extends Ju {
        constructor(e) {
            super(e), this.code = 1003, this.message = e && e.message ? e.message : "server is shutting down"
        }
    }
    class Pt extends em {
        constructor(e) {
            super(e), this.code = 2e3, this.message = e && e.message ? e.message : "ecast client error"
        }
    }
    class lO extends Pt {
        constructor(e) {
            super(e), this.code = 2001, this.message = e && e.message ? e.message : "parse error in ecast protocol"
        }
    }
    class uO extends Pt {
        constructor(e) {
            super(e), this.code = 2002, this.message = e && e.message ? e.message : "missing opcode"
        }
    }
    class hO extends Pt {
        constructor(e) {
            super(e), this.code = 2003, this.message = e && e.message ? e.message : "invalid opcode"
        }
    }
    class fO extends Pt {
        constructor(e) {
            super(e), this.code = 2004, this.message = e && e.message ? e.message : "invalid arguments"
        }
    }
    class dO extends Pt {
        constructor(e) {
            super(e), this.code = 2005, this.message = e && e.message ? e.message : "entity not found"
        }
    }
    class pO extends Pt {
        constructor(e) {
            super(e), this.code = 2006, this.message = e && e.message ? e.message : "an entity already exists with that key"
        }
    }
    class mO extends Pt {
        constructor(e) {
            super(e), this.code = 2007, this.message = e && e.message ? e.message : "the entity is not of the expected type"
        }
    }
    class gO extends Pt {
        constructor(e) {
            super(e), this.code = 2008, this.message = e && e.message ? e.message : "no such client"
        }
    }
    class _O extends Pt {
        constructor(e) {
            super(e), this.code = 2009, this.message = e && e.message ? e.message : "room is locked"
        }
    }
    class yO extends Pt {
        constructor(e) {
            super(e), this.code = 2010, this.message = e && e.message ? e.message : "room is full"
        }
    }
    class vO extends Pt {
        constructor(e) {
            super(e), this.code = 2011, this.message = e && e.message ? e.message : "no such license"
        }
    }
    class bO extends Pt {
        constructor(e) {
            super(e), this.code = 2012, this.message = e && e.message ? e.message : "invalid license"
        }
    }
    class EO extends Pt {
        constructor(e) {
            super(e), this.code = 2013, this.message = e && e.message ? e.message : "room not found"
        }
    }
    class TO extends Pt {
        constructor(e) {
            super(e), this.code = 2014, this.message = e && e.message ? e.message : "requested role does not exist"
        }
    }
    class SO extends Pt {
        constructor(e) {
            super(e), this.code = 2015, this.message = e && e.message ? e.message : "twitch login required"
        }
    }
    class wO extends Pt {
        constructor(e) {
            super(e), this.code = 2016, this.message = e && e.message ? e.message : "no such option"
        }
    }
    class OO extends Pt {
        constructor(e) {
            super(e), this.code = 2017, this.message = e && e.message ? e.message : "password required"
        }
    }
    class AO extends Pt {
        constructor(e) {
            super(e), this.code = 2018, this.message = e && e.message ? e.message : "invalid room password"
        }
    }
    class CO extends Pt {
        constructor(e) {
            super(e), this.code = 2019, this.message = e && e.message ? e.message : "missing name"
        }
    }
    class kO extends Pt {
        constructor(e) {
            super(e), this.code = 2021, this.message = e && e.message ? e.message : "text did not pass text filters"
        }
    }
    class IO extends Pt {
        constructor(e) {
            super(e), this.code = 2022, this.message = e && e.message ? e.message : "no such filter"
        }
    }
    class NO extends Pt {
        constructor(e) {
            super(e), this.code = 2023, this.message = e && e.message ? e.message : "permission denied"
        }
    }
    class xO extends Pt {
        constructor(e) {
            super(e), this.code = 2024, this.message = e && e.message ? e.message : "not connected to a room"
        }
    }
    class PO extends Pt {
        constructor(e) {
            super(e), this.code = 2025, this.message = e && e.message ? e.message : "illegal operation"
        }
    }
    class RO extends Pt {
        constructor(e) {
            super(e), this.code = 2026, this.message = e && e.message ? e.message : "invalid ACL change"
        }
    }
    class MO extends Pt {
        constructor(e) {
            super(e), this.code = 2027, this.message = e && e.message ? e.message : "room has already ended"
        }
    }
    class DO extends Pt {
        constructor(e) {
            super(e), this.code = 2028, this.message = e && e.message ? e.message : "the entity is locked"
        }
    }
    class $O extends Pt {
        constructor(e) {
            super(e), this.code = 2420, this.message = e && e.message ? e.message : "rate limit exceeded"
        }
    }

    function tW({
        code: t,
        message: e
    }) {
        const n = nW[t];
        return n ? new n({
            message: e
        }) : new em({
            message: e
        })
    }
    var eu = {
        createError: tW,
        CallError: em,
        EcastServerError: Ju,
        EcastCreateRoomFailed: oO,
        EcastDialRoomFailed: aO,
        EcastServerIsShuttingDown: cO,
        EcastClientError: Pt,
        EcastParseError: lO,
        EcastRequestIsMissingOpcode: uO,
        EcastRequestHasInvalidOpcode: hO,
        EcastRequestHasInvalidArguments: fO,
        EcastEntityNotFound: dO,
        EcastEntityAlreadyExists: pO,
        EcastEntityTypeError: mO,
        EcastNoSuchClient: gO,
        EcastRoomIsLocked: _O,
        EcastRoomIsFull: yO,
        EcastLicenseNotFound: vO,
        EcastLicenseCheckFailed: bO,
        EcastRoomNotFound: EO,
        EcastInvalidRole: TO,
        EcastTwitchLoginRequired: SO,
        EcastInvalidOption: wO,
        EcastPasswordRequired: OO,
        EcastInvalidPassword: AO,
        EcastNameRequired: CO,
        EcastFilterError: kO,
        EcastNoSuchFilter: IO,
        EcastPermissionDenied: NO,
        EcastNotConnected: xO,
        EcastIllegalOperation: PO,
        EcastACLChangeDenied: RO,
        EcastRoomHasEnded: MO,
        EcastEntityLocked: DO,
        EcastRateLimitExceeded: $O,
        ObservedError: eW
    };
    const nW = {
        1e3: Ju,
        1001: oO,
        1002: aO,
        1003: cO,
        2e3: Pt,
        2001: lO,
        2002: uO,
        2003: hO,
        2004: fO,
        2005: dO,
        2006: pO,
        2007: mO,
        2008: gO,
        2009: _O,
        2010: yO,
        2011: vO,
        2012: bO,
        2013: EO,
        2014: TO,
        2015: SO,
        2016: wO,
        2017: OO,
        2018: AO,
        2019: CO,
        2021: kO,
        2022: IO,
        2023: NO,
        2024: xO,
        2025: PO,
        2026: RO,
        2027: MO,
        2028: DO,
        2420: $O
    };
    let rW = class {
            constructor(e) {
                this.id = e.id, this.deviceId = e.deviceId, this.name = e.name, this.secret = e.secret, this.reconnect = e.reconnect, this.entities = e.entities, this.here = e.here, this.profile = e.profile, this.replayEnd = e.replayEnd
            }
        },
        sW = class {
            constructor(e) {
                this.id = e.id, this.userId = e.userId, this.name = e.name, this.role = e.role, this.reconnect = e.reconnect
            }
        },
        iW = class {
            constructor(e) {
                this.id = e.id, this.role = e.role
            }
        },
        oW = class {
            constructor(e) {
                this.to = e.to, this.from = e.from, this.body = e.body, this.userId = e.userId
            }
        },
        aW = class {
            constructor(e) {
                this.id = e.id, this.banned = e.banned, this.reason = e.reason
            }
        };
    var Av = {
        ClientConnected: sW,
        ClientDisconnected: iW,
        ClientKicked: aW,
        ClientSend: oW,
        ClientWelcome: rW
    };
    let cW = class {
        constructor(e) {
            this.choices = e.choices, this.key = e.key, this.meta = e.meta || {}
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `CountGroup{
	choices: ${this.choices}
	meta:${JSON.stringify(this.meta)}
}`
        }
    };
    var Cv = {
        CountGroup: cW
    };
    let lW = class {
            constructor(e) {
                this.key = e.key, this.colors = e.colors, this.lines = e.lines, this.live = e.live, this.maxLayer = e.maxLayer, this.maxPoints = e.maxPoints, this.size = e.size, this.weights = e.weights, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
            }
            whenReceived(e) {
                e.entities[this.key] = this
            }
            toString() {
                return `Doodle{
	key:${this.key}
	colors:${this.colors}
	lines:${this.lines}
	live:${this.live}
	maxLayer:${this.maxLayer}
	maxPoints:${this.maxPoints}
	size:${this.size}
	weights:${this.weights}
	meta:${JSON.stringify(this.meta)}
}`
            }
        },
        uW = class {
            constructor(e) {
                this.key = e.key, this.line = e.line
            }
            whenReceived(e) {
                e.entities[this.key].lines.push(this.line)
            }
            toString() {
                return `DoodleLine{
	val:${this.line}
}`
            }
        },
        hW = class {
            constructor(e) {
                this.key = e.key, this.index = e.index
            }
            whenReceived(e) {
                e.entities[this.key].lines.splice(this.index, 1)
            }
            toString() {
                return `DoodleLineRemoved{
	index:${this.index}
}`
            }
        };
    var kv = {
        DoodleEntity: lW,
        DoodleLine: uW,
        DoodleLineRemoved: hW
    };
    let fW = class {
        constructor(e) {
            this.key = e.key, this.count = e.count, this.meta = e.meta || {}
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `GCounter{
	count:${this.count}
	meta:${this.meta}
}`
        }
    };
    var Iv = {
        GCounter: fW
    };
    let dW = class {
        constructor(e) {
            this.pc = e.pc, this.opcode = e.opcode, this.result = e.result
        }
    };
    var LO = {
        Notification: dW
    };
    let pW = class FO {
        constructor(e) {
            this.from = e.from, this.key = e.key, this.val = e.val, this.restrictions = e.restrictions, this.version = e.version, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
        }
        whenReceived(e) {
            if (e.entities[this.key] && e.entities[this.key] instanceof FO && !this.restrictions) {
                e.entities[this.key].val = this.val, e.entities[this.key].meta = this.meta, e.entities[this.key].version = this.version, e.entities[this.key].from = this.from;
                return
            }
            e.entities[this.key] = this
        }
        toString() {
            return `NumberEntity{
	key:${this.key}
	val: ${this.val}
	restrictions: ${JSON.stringify(this.restrictions)}
	meta: ${JSON.stringify(this.meta)}
}`
        }
    };
    var Nv = {
        NumberEntity: pW
    };
    let mW = class {
            constructor(e) {
                this.from = e.from, this.key = e.key, this.val = e.val, this.version = e.version, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
            }
            whenReceived(e) {
                e.entities[this.key] = this
            }
            toString() {
                return `ObjectEntity{
	key:${this.key}
	value: ${JSON.stringify(this.val)}
	meta:${JSON.stringify(this.meta)}
}`
            }
            toBlob() {
                return this.val
            }
        },
        gW = class {
            constructor(e) {
                this.message = e.message
            }
            toString() {
                return `ObjectEcho{message: ${this.message}}`
            }
        };
    var xv = {
        ObjectEntity: mW,
        ObjectEcho: gW
    };
    let _W = class {
        constructor(e) {
            this.key = e.key, this.count = e.count, this.meta = e.meta || {}
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `PNCounter{
	count:${this.count}
	meta:${JSON.stringify(this.meta)}
}`
        }
    };
    var Pv = {
        PNCounter: _W
    };
    let yW = class {
        constructor(e) {
            this.pc = e.pc, this.re = e.re, this.opcode = e.opcode, this.result = e.result
        }
    };
    var UO = {
        Reply: yW
    };
    let vW = class {
        constructor(e) {
            this.seq = e.seq, this.opcode = e.opcode, this.params = e.params
        }
    };
    var bW = {
        Request: vW
    };
    let EW = class {
            constructor(e) {
                this.key = e.key, this.size = e.size, this.version = e.version, this.from = e.from, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
            }
            whenRecived(e) {
                e.entities[this.key] = this
            }
            toString() {
                return `Stack{
	key:${this.key}
	size:${this.size}
	version:${this.version}
	from:${this.from}
	meta:${this.meta}
}`
            }
        },
        TW = class {
            constructor(e) {
                this.key = e.key, this.val = e.val
            }
            toString() {
                return `StackElement{
	key:${this.key}
	value: ${JSON.stringify(this.val)}
}`
            }
        },
        SW = class {
            constructor(e) {
                this.key = e.key, this.vals = e.vals
            }
            toString() {
                return `StackElements{
	key:${this.key}
	values: ${JSON.stringify(this.vals)}
}`
            }
        };
    var BO = {
        StackEntity: EW,
        StackElement: TW,
        StackElements: SW
    };
    let wW = class {
            constructor(e) {
                this.from = e.from, this.key = e.key, this.text = e.text, this.version = e.version, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
            }
            whenReceived(e) {
                e.entities[this.key] = this, e.emit("text " + this.key, this)
            }
            toString() {
                return `TextEntity{
	key: ${this.key}
	text: ${this.text}
	meta:${JSON.stringify(this.meta)}
}`
            }
            toBlob() {
                return JSON.parse(this.text)
            }
        },
        OW = class {
            constructor(e) {
                this.message = e.message
            }
            toString() {
                return `TextEcho{
	key: ${this.key}
	message: ${this.message}
}`
            }
        };
    var Rv = {
        TextEntity: wW,
        TextEcho: OW
    };
    let AW = class {
            constructor(e) {
                this.from = e.from, this.key = e.key, this.meta = e.meta || {}, this.root = e.root, e.acl && (this.acl = e.acl)
            }
            whenReceived(e) {
                e.entities[this.key] = this
            }
            toString() {
                return `TextMap{
	key:${this.key}
	meta:${JSON.stringify(this.meta)}
}`
            }
        },
        CW = class {
            constructor(e) {
                this.from = e.from, this.key = e.key, this.msg = e.msg
            }
            toString() {
                const e = this.msg ? this.msg.join(", ") : this.msg;
                return `TextMapSynced{
	key:${this.key}
	from:${this.from}
	msg:${e}
}`
            }
        },
        kW = class {
            constructor(e) {
                this.from = e.from, this.key = e.key, this.text = e.text, this.attributions = e.attributions
            }
            toString() {
                return `TextMapState{
	key: ${this.key}
	from:${this.from}
	text:${this.text}
	attributions:${this.attributions}
}`
            }
        };
    var Mv = {
        TextMapEntity: AW,
        TextMapSynced: CW,
        TextMapState: kW
    };
    let IW = class {
        constructor(e) {
            this.key = e.key, this.elements = e.elements, this.limit = e.limit, this.meta = e.meta || {}
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `TextRing{
	elements: ${this.elements}
	meta:${JSON.stringify(this.meta)}
}`
        }
    };
    var Dv = {
        TextRing: IW
    };
    let NW = class {
        constructor(e) {
            this.key = e.key, this.artifactId = e.artifactId, this.categoryId = e.categoryId, this.rootId = e.rootId, this.meta = e.meta || {}
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `ArtifactEntity${JSON.stringify(this)}
`
        }
    };
    var qO = {
        ArtifactEntity: NW
    };
    let xW = class {
        constructor(e) {
            this.key = e.key
        }
        whenReceived(e) {
            delete e.entities[this.key]
        }
        toString() {
            return `DropEntity{
	key:${this.key}
}`
        }
    };
    var jO = {
        DropEntity: xW
    };
    let PW = class {
        constructor(e) {
            this.message = e.message
        }
        toString() {
            return `Echo{message: ${this.message}
}`
        }
    };
    var RW = {
        Echo: PW
    };
    let MW = class {
        constructor(e) {
            this.key = e.key, this.from = e.from
        }
        whenReceived(e) {
            e.entities[this.key] && (e.entities[this.key].meta.locked = !0)
        }
        toString() {
            return `LockEntity{
	key:${this.key}
}`
        }
    };
    var DW = {
        LockEntity: MW
    };
    let $W = class {
        constructor() {}
        toString() {
            return "OK"
        }
    };
    var VO = {
        OK: $W
    };
    const {
        ArtifactEntity: LW
    } = qO, {
        ClientWelcome: FW,
        ClientConnected: UW,
        ClientDisconnected: BW,
        ClientKicked: qW,
        ClientSend: jW
    } = Av, {
        CountGroup: VW
    } = Cv, {
        DoodleEntity: GW,
        DoodleLine: WW,
        DoodleLineRemoved: HW
    } = kv, {
        StackEntity: KW,
        StackElement: YW,
        StackElements: zW
    } = BO, {
        DropEntity: ZW
    } = jO, {
        Echo: XW
    } = RW, {
        LockEntity: JW
    } = DW, {
        GCounter: QW
    } = Iv, {
        GetAudienceReply: eH,
        RoomExit: tH,
        RoomLock: nH
    } = Jp, {
        Notification: rH
    } = LO, {
        OK: sH
    } = VO, {
        NumberEntity: iH
    } = Nv, {
        ObjectEcho: oH,
        ObjectEntity: aH
    } = xv, {
        PNCounter: mS
    } = Pv, {
        Reply: cH
    } = UO, {
        TextEcho: lH,
        TextEntity: uH
    } = Rv, {
        TextRing: hH
    } = Dv, {
        createError: gS,
        ObservedError: fH
    } = eu, {
        TextMapEntity: dH,
        TextMapSynced: pH,
        TextMapState: mH
    } = Mv;

    function v1(t, e, n) {
        switch (t) {
            case "ok":
                return new sH;
            case "echo":
                return new XW({
                    message: e.message
                });
            case "lock":
                return new JW({
                    key: e.key,
                    from: e.from
                });
            case "error":
                return gS({
                    code: e.code,
                    message: e.msg
                });
            case "error/observed":
                return new fH({
                    to: e.to,
                    opcode: e.opcode,
                    error: gS({
                        code: e.error.code,
                        message: e.error.msg
                    })
                });
            case "string":
                return e;
            case "text":
                return new uH({
                    from: e.from,
                    key: e.key,
                    text: e.val,
                    version: e.version,
                    meta: n,
                    acl: e.acl
                });
            case "text/echo":
                return new lH({
                    message: e.message
                });
            case "object":
                return new aH({
                    from: e.from,
                    key: e.key,
                    val: e.val,
                    meta: n,
                    acl: e.acl
                });
            case "object/echo":
                return new oH({
                    message: e.message
                });
            case "drop":
                return new ZW({
                    key: e.key
                });
            case "artifact":
                return new LW({
                    key: e.key,
                    artifactId: e.artifactId,
                    categoryId: e.categoryId,
                    rootId: e.rootId,
                    meta: n
                });
            case "client/connected":
                return new UW({
                    id: e.id,
                    userId: e.userId,
                    name: e.name,
                    role: e.role,
                    reconnect: e.reconnect
                });
            case "client/disconnected":
                return new BW({
                    id: e.id,
                    role: e.role
                });
            case "client/kicked":
                return new qW({
                    id: e.id,
                    banned: e.banned,
                    reason: e.reason
                });
            case "client/send":
                return new jW({
                    to: e.to,
                    from: e.from,
                    body: e.body,
                    userId: e.userID
                });
            case "client/welcome": {
                let r = new FW({
                    id: e.id,
                    name: e.name,
                    secret: e.secret,
                    reconnect: e.reconnect,
                    here: e.here,
                    profile: e.profile,
                    replayEnd: e.replayEnd
                });
                if (e.entities) {
                    let s = {};
                    Object.entries(e.entities).forEach(([i, a]) => {
                        s[i] = v1(a[0], a[1], a[2])
                    }), r.entities = s
                }
                return r
            }
            case "doodle":
                return new GW({
                    key: e.key,
                    colors: e.val.colors,
                    lines: e.val.lines,
                    live: e.val.live,
                    maxLayer: e.val.maxLayer,
                    maxPoints: e.val.maxPoints,
                    size: e.val.size,
                    weights: e.val.weights,
                    meta: n,
                    acl: e.acl
                });
            case "doodle/line":
                return new WW({
                    key: e.key,
                    line: e.val
                });
            case "doodle/line/removed":
                return new HW({
                    key: e.key,
                    index: e.index
                });
            case "stack":
                return new KW({
                    key: e.key,
                    size: e.size,
                    from: e.from,
                    version: e.version,
                    meta: e.meta,
                    acl: e.acl
                });
            case "stack/element":
                return new YW({
                    key: e.key,
                    val: e.val
                });
            case "stack/elements":
                return new zW({
                    key: e.key,
                    vals: e.vals
                });
            case "number":
                return new iH({
                    key: e.key,
                    val: e.val,
                    restrictions: e.restrictions,
                    from: e.from,
                    version: e.version,
                    meta: n,
                    acl: e.acl
                });
            case "text-map":
                return new dH({
                    key: e.key,
                    from: e.from,
                    root: e.root,
                    meta: n,
                    acl: e.acl
                });
            case "text-map/state":
                return new mH({
                    key: e.key,
                    from: e.from,
                    attributions: e.attributions,
                    text: e.text
                });
            case "text-map/synced":
                return new pH({
                    key: e.key,
                    from: e.from,
                    msg: e.msg
                });
            case "room/exit":
                return new tH({
                    cause: e.cause
                });
            case "room/lock":
                return new nH;
            case "room/get-audience":
                return new eH({
                    connections: e.connections
                });
            case "audience":
                return new mS({
                    key: t,
                    count: e[1]
                });
            case "audience/count-group":
                return new VW({
                    key: e.key,
                    choices: e.choices,
                    meta: n
                });
            case "audience/text-ring":
                return new hH({
                    key: e.key,
                    elements: e.elements,
                    meta: n
                });
            case "audience/g-counter":
                return new QW({
                    key: e.key,
                    count: e.count,
                    meta: n
                });
            case "audience/pn-counter":
                return new mS({
                    key: e.key,
                    count: e.count,
                    meta: n
                });
            default:
                return console.error(`failed to parse result of type ${t}: ${JSON.stringify(e,null,2)}`), e
        }
    }

    function gH(t) {
        let e = JSON.parse(t.data),
            n = e.opcode || e.type;
        return e.re ? new cH({
            pc: e.pc,
            re: e.re,
            opcode: n,
            result: v1(n, e.result)
        }) : new rH({
            pc: e.pc,
            opcode: n,
            result: v1(n, e.result)
        })
    }
    var _H = {
        parseResponseMessage: gH
    };
    const _S = HG,
        yH = X4,
        vH = QG,
        {
            CallError: bH
        } = eu,
        {
            ClientWelcome: EH
        } = Av,
        {
            CountGroup: TH
        } = Cv,
        {
            DoodleEntity: SH
        } = kv,
        {
            GCounter: wH
        } = Iv,
        {
            Notification: yS
        } = LO,
        {
            NumberEntity: OH
        } = Nv,
        {
            ObjectEntity: __
        } = xv,
        {
            PNCounter: AH
        } = Pv,
        {
            Reply: CH
        } = UO,
        {
            Request: kH
        } = bW,
        {
            StackEntity: IH
        } = BO,
        {
            TextEntity: y_
        } = Rv,
        {
            TextMapEntity: NH
        } = Mv,
        {
            TextRing: xH
        } = Dv,
        {
            parseResponseMessage: PH
        } = _H,
        RH = 1e3 + Math.floor(Math.random() * 500),
        vS = 13e3;
    let MH = class extends vH {
        constructor(e) {
            if (super(), this.debug = e.debug || !1, !e.host) throw new Error("unable to create ecast WSClient: no host provided");
            if (this.host = e.host, !e.code) throw new Error("unable to create ecast WSClient: no room code provided");
            if (this.code = e.code, e.scheme ? this.scheme = e.scheme : this.scheme = "wss", e.secret && e.id) this.id = e.id, this.secret = e.secret;
            else {
                switch (e.role) {
                    case "player":
                        if (!e.name) throw new Error("unable to create ecast WSClient: no name provided");
                        break;
                    case "host":
                        if (!e.token) throw new Error("unable to create ecast WSClient: tried to connect with host role but without host token");
                        this.token = e.token;
                        break;
                    case "moderator":
                        if (!e.password) throw new Error("unable to create ecast WSClient: tried to connect with moderator role but without password");
                        break
                }
                e.password && (this.password = e.password), e.twitchToken && (this.twitchToken = e.twitchToken)
            }
            this.name = e.name, this.role = e.role, this.deviceId = e.deviceId, this.userId = e.userId, this.conn = null, this.seq = 0, this.pending = {}, this.entities = {}, e.role == "host" && (this.replaySince = e.replaySince || 0, this.syncEntities = e.syncEntities || !1)
        }
        connect() {
            const e = {
                id: this.id,
                role: this.role,
                name: this.name,
                format: "json",
                "user-id": this.userId,
                password: this.password
            };
            this.deviceId && (e["device-id"] = this.deviceId), this.twitchToken && (e["twitch-token"] = this.twitchToken), this.secret && (e.secret = this.secret), this.role === "host" && (e["host-token"] = this.token, this.replaySince > 0 && (e["replay-since"] = this.replaySince), this.syncEntities && (e["sync-entities"] = this.syncEntities));
            const n = yH.stringify(e),
                r = this.role === "audience" || this.id > 1e7 ? `${this.scheme}://${this.host}/api/v2/audience/${this.code}/play?${n}` : `${this.scheme}://${this.host}/api/v2/rooms/${this.code}/play?${n}`;
            return new Promise((s, i) => {
                let a = !1,
                    c = !1,
                    u = d => {
                        s(d), a = !0
                    },
                    h = d => {
                        i(d), a = !0
                    };
                this.conn = new _S(r, "ecast-v0"), this.conn.onmessage = d => {
                    this.debugLog(`recv <- ${JSON.stringify(JSON.parse(d.data),null,2)}`);
                    const p = PH(d);
                    if (p instanceof CH) this.onReply(p);
                    else if (p instanceof yS) {
                        if (p.result instanceof EH) c = !0, this.id = p.result.id, this.deviceId = p.result.deviceId, this.entities = p.result.entities, this.secret = p.result.secret, p.result.name && (this.name = p.result.name), u(p.result);
                        else if (!a) {
                            h(p.result);
                            return
                        }
                        this.onNotification(p)
                    } else console.error(`failed to parse response messsage: ${p}`)
                }, this.conn.onerror = d => {
                    a ? this.emit("socketError", d) : h(d)
                }, this.conn.onclose = d => {
                    this.debugLog("onclose", d.code), c && d.code === 1006 ? this.reconnect() : this.emit("socketClose", d)
                }, this.conn.onopen = d => {
                    this.emit("socketOpen", d)
                }
            })
        }
        sleep(e) {
            return new Promise(n => setTimeout(n, e))
        }
        debugLog(...e) {
            this.debug && console.log(`%c[WSClient:${this.name}]`, "background-color:blue;color:white;", ...e)
        }
        async reconnect() {
            this.disconnect(), this.debugLog("Attempting to reconnect");
            let e = 1,
                n = RH;
            for (;;) try {
                this.emit("connection", {
                    status: "connecting",
                    attempt: e
                }), await this.connect(), this.debugLog("reconnected"), this.emit("connection", {
                    status: "connected"
                });
                return
            } catch (r) {
                if (this.debugLog("reconnect error", r), r.code === 1005 || r.code === 1e3) {
                    this.debugLog("unable to reconnect!", r), this.emit("socketClose", r);
                    return
                }
                if (n >= vS) {
                    this.debugLog("reconnect failed!", r), this.emit("socketClose", r);
                    return
                }
                e += 1, this.debugLog("waiting", n), this.emit("connection", {
                    status: "waiting",
                    attempt: e
                }), await this.sleep(n), n = Math.min(vS, n * 2)
            }
        }
        disconnect() {
            this.conn && (this.conn.close(), this.conn.onmessage = null, this.conn.onerror = null, this.conn.onopen = null, this.conn.onclose = null, this.conn = null)
        }
        onReply(e) {
            const n = e.re,
                r = this.pending[n];
            if (!r) {
                const s = new yS(e);
                s.re = n, this.emit("notification", s);
                return
            }
            delete this.pending[n], e.result instanceof bH ? r.reject(e.result) : r.resolve(e.result)
        }
        onNotification(e) {
            typeof e.result.whenReceived == "function" && e.result.whenReceived(this), this.emit("notification", e), this.emit(e.opcode, e.result)
        }
        send(e, n = {}) {
            if (!this.conn) throw new Error("No connection available");
            if (this.conn.readyState !== _S.OPEN) throw new Error(`Socket not ready to send, readyState is ${this.conn.readyState}`);
            const r = ++this.seq,
                s = new kH({
                    seq: r,
                    opcode: e,
                    params: n
                }),
                i = new Promise((c, u) => {
                    this.pending[r] = {
                        resolve: c,
                        reject: u,
                        request: s
                    }
                }),
                a = JSON.stringify(s);
            return this.debugLog(`send -> ${a}`), this.conn.send(a), i
        }
        lockRoom() {
            return this.send("room/lock")
        }
        startAudience() {
            return this.send("room/start-audience")
        }
        getAudience() {
            return this.send("room/get-audience")
        }
        mail(e, n) {
            return this.send("client/send", {
                from: this.id,
                to: e,
                body: n
            })
        }
        kick(e, n = !1, r) {
            return this.send("client/kick", {
                id: e,
                ban: n,
                reason: r
            })
        }
        async drop(e) {
            const n = await this.send("drop", {
                key: e
            });
            return delete this.entities[e], n
        }
        echo(e) {
            return this.send("echo", {
                message: e
            })
        }
        async lock(e) {
            const n = await this.send("lock", {
                key: e
            });
            return this.entities[e].meta.locked = !0, n
        }
        async createNumber(e, n = {}) {
            let r = {
                key: e
            };
            const {
                val: s = 0,
                acl: i,
                min: a,
                max: c,
                increment: u,
                type: h
            } = n;
            r.val = s, i && (r.acl = i), a != null && (r.min = a), c != null && (r.max = c), u && (r.increment = u), h && (r.type = h);
            const d = await this.send("number/create", r);
            return this.entities[e] = new OH({
                key: e,
                val: s,
                restrictions: {
                    min: a,
                    max: c,
                    increment: u,
                    type: h
                },
                meta: {
                    locked: !1
                }
            }), d
        }
        async decrementNumber(e) {
            const n = await this.send("number/decrement", {
                key: e
            });
            return this.entities[e].val = n.val, n
        }
        async getNumber(e) {
            const n = await this.send("number/get", {
                key: e
            });
            return this.entities[e].val = n.val, this.entities[e].restrictions = n.restrictions, n
        }
        async incrementNumber(e) {
            const n = await this.send("number/increment", {
                key: e
            });
            return this.entities[e].val = n.val, n
        }
        async updateNumber(e, n) {
            const r = await this.send("number/update", {
                key: e,
                val: n
            });
            return this.entities[e].val = n, r
        }
        async createObject(e, n, r) {
            const s = {
                key: e,
                val: n
            };
            r && (s.acl = r);
            const i = await this.send("object/create", s);
            return this.entities[e] = new __({
                key: e,
                val: n,
                meta: {
                    locked: !1
                }
            }), i
        }
        echoObject(e) {
            return this.send("object/echo", {
                message: e
            })
        }
        async getObject(e) {
            const n = await this.send("object/get", {
                key: e
            });
            return this.entities[e].val = n.val, this.entities[e].version = n.version, this.entities[e].from = n.from, n
        }
        async setObject(e, n, r) {
            const s = {
                key: e,
                val: n
            };
            r && (s.acl = r);
            const i = await this.send("object/set", s);
            return this.entities[e] = new __({
                key: e,
                val: n,
                meta: {
                    locked: !1
                }
            }), i
        }
        async updateObject(e, n) {
            const r = await this.send("object/update", {
                key: e,
                val: n
            });
            return this.entities[e] = new __({
                key: e,
                val: n,
                meta: {
                    locked: !1
                }
            }), r
        }
        echoText(e) {
            return this.send("text/echo", {
                message: e
            })
        }
        getText(e) {
            return this.send("text/get", {
                key: e
            })
        }
        async createText(e, n, r) {
            const s = {
                    key: e,
                    val: n
                },
                {
                    acl: i,
                    accept: a,
                    reject: c
                } = r;
            i && (s.acl = i), a && (s.accept = a), c && (s.reject = c);
            const u = await this.send("text/create", s);
            return this.entities[e] = new y_({
                key: e,
                text: n,
                meta: {
                    locked: !1
                }
            }), u
        }
        async setText(e, n, r) {
            const s = {
                key: e,
                val: n
            };
            r && (s.acl = r);
            const i = await this.send("text/set", s);
            return this.entities[e] = new y_({
                key: e,
                text: n,
                meta: {
                    locked: !1
                }
            }), i
        }
        async updateText(e, n) {
            const r = await this.send("text/update", {
                key: e,
                val: n
            });
            return this.entities[e] = new y_({
                key: e,
                text: n,
                meta: {
                    locked: !1
                }
            }), r
        }
        async createTextMap(e, n = {}) {
            const {
                val: r,
                notifyHost: s,
                acl: i,
                accept: a,
                reject: c
            } = n;
            let u = {
                key: e
            };
            r && (u.val = n.val), s && (u.notifyHost = n.notifyHost), i && (u.acl = i), a && (u.accept = a), c && (u.reject = c);
            const h = await this.send("text-map/create", u);
            return this.entities[e] = new NH({
                key: e,
                acl: i,
                meta: {
                    locked: !1
                }
            }), h
        }
        async syncTextMap(e, n) {
            return await this.send("text-map/sync", {
                key: e,
                msg: n
            })
        }
        async getTextMap(e, n) {
            const {
                includeNodes: r
            } = n;
            return await this.send("text-map/get", {
                key: e,
                includeNodes: r
            })
        }
        async createDoodle(e, n) {
            let r = {
                key: e
            };
            const {
                acl: s,
                colors: i,
                live: a,
                maxLayer: c,
                maxPoints: u,
                size: h,
                weights: d
            } = n;
            s && (r.acl = s), i && (r.colors = i), r.live = a, c != null && (r.maxLayer = c), u != null && (r.maxPoints = u), h && (r.size = h), d && (r.weights = d);
            const p = await this.send("doodle/create", r);
            return this.entities[e] = new SH({
                key: e,
                colors: i,
                lines: [],
                live: a,
                maxLayer: r.maxLayer || 0,
                maxPoints: r.maxPoints || 0,
                size: h,
                weights: d,
                meta: {
                    locked: !1
                }
            }), p
        }
        async getDoodle(e) {
            const n = await this.send("doodle/get", {
                key: e
            });
            return this.entities[e].lines = n.lines, n
        }
        async strokeDoodle(e, n) {
            const {
                color: r,
                weight: s,
                layer: i,
                points: a,
                brush: c
            } = n, u = {
                color: r,
                weight: s,
                layer: i,
                points: a
            };
            c && (u.brush = c);
            const h = await this.send("doodle/stroke", {
                key: e,
                ...u
            });
            return this.entities[e].lines.push(u), h
        }
        async undoDoodle(e) {
            const n = await this.send("doodle/undo", {
                key: e
            });
            return this.entities[e].lines.pop(), n
        }
        async createStack(e, n) {
            const r = {
                key: e
            };
            n && (r.acl = n);
            const s = await this.send("stack/create", r);
            return this.entities[e] = new IH({
                key: e,
                size: 0,
                meta: {
                    locked: !1
                }
            }), s
        }
        pushStack(e, n) {
            return this.send("stack/push", {
                key: e,
                val: n
            })
        }
        bulkPushStack(e, n) {
            return this.send("stack/bulkpush", {
                key: e,
                vals: n
            })
        }
        peekStack(e, n) {
            return this.send("stack/peek", {
                key: e,
                size: n
            })
        }
        popStack(e) {
            return this.send("stack/pop", {
                key: e
            })
        }
        async createCountGroup(e, n) {
            const r = await this.send("audience/count-group/create", {
                name: e,
                options: n
            });
            return this.entities[e] = new TH({
                key: e,
                choices: n,
                meta: {
                    locked: !1
                }
            }), r
        }
        incrementCountGroupCounter(e, n, r = 1) {
            return this.send("audience/count-group/increment", {
                name: e,
                vote: n,
                times: r
            })
        }
        getCountGroup(e) {
            return this.send("audience/count-group/get", {
                name: e
            })
        }
        async createGCounter(e, n) {
            const r = await this.send("audience/g-counter/create", {
                key: e,
                count: n
            });
            return this.entities[e] = new wH({
                key: e,
                count: n,
                meta: {
                    locked: !1
                }
            }), r
        }
        incrementGCounter(e, n) {
            return this.send("audience/g-counter/increment", {
                key: e,
                times: n
            })
        }
        getGCounter(e) {
            return this.send("audience/g-counter/get", {
                key: e
            })
        }
        async createPNCounter(e, n) {
            const r = await this.send("audience/pn-counter/create", {
                key: e,
                count: n
            });
            return this.entities[e] = new AH({
                key: e,
                count: n,
                meta: {
                    locked: !1
                }
            }), r
        }
        incrementPNCounter(e, n) {
            return this.send("audience/pn-counter/increment", {
                key: e,
                times: n
            })
        }
        decrementPNCounter(e, n) {
            return this.send("audience/pn-counter/decrement", {
                key: e,
                times: n
            })
        }
        getPNCounter(e) {
            return this.send("audience/pn-counter/get", {
                key: e
            })
        }
        async createTextRing(e, n) {
            const r = {
                    key: e
                },
                {
                    limit: s,
                    accept: i,
                    reject: a
                } = n;
            s && (r.limit = s), i && (r.accept = i), a && (r.reject = a);
            const c = await this.send("audience/text-ring/create", r);
            return this.entities[e] = new xH({
                key: e,
                elements: [],
                limit: s,
                meta: {
                    locked: !1
                }
            }), c
        }
        getTextRing(e) {
            return this.send("audience/text-ring/get", {
                name: e
            })
        }
        pushTextRing(e, n) {
            return this.send("audience/text-ring/push", {
                name: e,
                text: n
            })
        }
    };
    var DH = {
        WSClient: MH
    };
    const {
        APIClient: $H
    } = WG, {
        WSClient: LH
    } = DH, {
        CreateRoomReply: FH,
        GetRoomReply: UH
    } = Jp, {
        ClientWelcome: BH,
        ClientDisconnected: qH
    } = Av, {
        ArtifactEntity: jH
    } = qO, {
        GCounter: VH
    } = Iv, {
        NumberEntity: GH
    } = Nv, {
        TextEntity: WH
    } = Rv, {
        DoodleEntity: HH
    } = kv, {
        ObjectEntity: KH
    } = xv, {
        CountGroup: YH
    } = Cv, {
        DropEntity: zH
    } = jO, {
        OK: ZH
    } = VO, {
        RoomExit: XH
    } = Jp, {
        TextRing: JH
    } = Dv, {
        TextMapEntity: QH
    } = Mv, {
        PNCounter: eK
    } = Pv;
    var Tr = {
        APIClient: $H,
        WSClient: LH,
        ClientWelcome: BH,
        CreateRoomReply: FH,
        DropEntity: zH,
        GetRoomReply: UH,
        ClientDisconnected: qH,
        RoomExit: XH,
        OK: ZH,
        ArtifactEntity: jH,
        DoodleEntity: HH,
        NumberEntity: GH,
        CountGroup: YH,
        GCounter: VH,
        ObjectEntity: KH,
        PNCounter: eK,
        TextEntity: WH,
        TextRing: JH,
        TextMapEntity: QH
    };
    const tK = [{
            name: "Prototype",
            tag: "prototype",
            wrapper: "vue",
            isPublic: !0,
            directory: "internal/prototype"
        }, {
            name: "EcastTestClient",
            tag: "ecast-test-client",
            wrapper: "marionette",
            isPublic: !0,
            directory: "internal/ecast-test-client"
        }, {
            name: "Quiplash 2 InterLASHional",
            tag: "quiplash2-international",
            wrapper: "marionette",
            isPublic: !0,
            directory: "standalone/quiplash2-international",
            categoryId: "quiplash2-internationalGame"
        }, {
            name: "Guesspionage Crowdplay",
            tag: "guesspionage-crowdplay",
            wrapper: "marionette",
            isPublic: !0,
            directory: "standalone/guesspionage-crowdplay"
        }, {
            name: "Drawful 2",
            tag: "drawful2",
            wrapper: "marionette",
            isPublic: !0,
            directory: "standalone/drawful2",
            categoryId: "DrawfulGame",
            shopItems: ["shirts"]
        }, {
            name: "Drawful 2",
            tag: "drawful2international",
            wrapper: "marionette",
            isPublic: !0,
            directory: "standalone/drawful2-international",
            features: ["moderation"]
        }, {
            name: "Acquisitions, Inc.",
            tag: "acquisitions-inc",
            wrapper: "marionette",
            isPublic: !0,
            directory: "standalone/acquisitions-inc"
        }, {
            name: "You Don't Know Jack 2015",
            tag: "ydkj2015",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp1/ydkj2015"
        }, {
            name: "Drawful",
            tag: "drawful",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp1/drawful"
        }, {
            name: "Word Spud",
            tag: "wordspud",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp1/wordspud"
        }, {
            name: "Lie Swatter",
            tag: "lieswatter",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp1/lieswatter"
        }, {
            name: "Fibbage",
            tag: "fibbage",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp1/fibbage"
        }, {
            name: "Fibbage 2",
            tag: "fibbage2",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp2/fibbage2"
        }, {
            name: "Earwax",
            tag: "earwax",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp2/earwax"
        }, {
            name: "Bidiots",
            tag: "auction",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp2/auction"
        }, {
            name: "Bomb Corp",
            tag: "bombintern",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp2/bombintern"
        }, {
            name: "Quiplash",
            tag: "quiplash",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp2/quiplash"
        }, {
            name: "Fakin' It",
            tag: "fakinit",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp3/fakinit"
        }, {
            name: "Tee K.O.",
            tag: "awshirt",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp3/awshirt",
            categoryId: "TeeKOGame",
            shopItems: ["shirts"]
        }, {
            name: "Quiplash 2",
            tag: "quiplash2",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp3/quiplash2",
            categoryId: "Quiplash2Game"
        }, {
            name: "Trivia Murder Party",
            tag: "triviadeath",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp3/triviadeath",
            categoryId: "TriviaDeathResults"
        }, {
            name: "Guesspionage",
            tag: "pollposition",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp3/pollposition"
        }, {
            name: "Fibbage 3",
            tag: "fibbage3",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp4/fibbage3"
        }, {
            name: "Survive the Internet",
            tag: "survivetheinternet",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp4/survivetheinternet",
            categoryId: "STIGame"
        }, {
            name: "Monster Seeking Monster",
            tag: "monstermingle",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp4/monstermingle",
            categoryId: "MonsterMingleGame"
        }, {
            name: "Bracketeering",
            tag: "bracketeering",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp4/bracketeering",
            categoryId: "BRKGame"
        }, {
            name: "Civic Doodle",
            tag: "overdrawn",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp4/overdrawn",
            categoryId: "OverdrawnGame",
            shopItems: ["shirts"]
        }, {
            name: "You Don't Know Jack: Full Stream",
            tag: "ydkj2018",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp5/ydkj2018",
            categoryId: "YDKJ2018Game"
        }, {
            name: "Split the Room",
            tag: "splittheroom",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp5/splittheroom",
            categoryId: "SplitTheRoomGame"
        }, {
            name: "Mad Verse City",
            tag: "rapbattle",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp5/rapbattle",
            categoryId: "RapBattleGame"
        }, {
            name: "Zeeple Dome",
            tag: "slingshoot",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp5/slingshoot",
            categoryId: "SlingShootGame"
        }, {
            name: "Patently Stupid",
            tag: "patentlystupid",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp5/patentlystupid",
            categoryId: "PatentlyStupidGame",
            shopItems: ["mugs"]
        }, {
            name: "Trivia Murder Party 2",
            tag: "triviadeath2",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp6/triviadeath2",
            categoryId: "TriviaDeath2Game"
        }, {
            name: "Role Models",
            tag: "rolemodels",
            wrapper: "marionette",
            isPublic: !0,
            features: ["camera"],
            directory: "pp6/rolemodels",
            categoryId: "RoleModelsGame",
            shopItems: ["shirts"]
        }, {
            name: "Joke Boat",
            tag: "jokeboat",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp6/jokeboat",
            categoryId: "JokeboatGame"
        }, {
            name: "Dictionarium",
            tag: "ridictionary",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp6/ridictionary",
            categoryId: "RidictionaryGame"
        }, {
            name: "Push the Button",
            tag: "pushthebutton",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp6/pushthebutton",
            categoryId: "PushTheButtonGame"
        }, {
            name: "Talking Points",
            tag: "jackbox-talks",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp7/jackboxtalks",
            features: ["camera", "moderation"],
            categoryId: "JackboxTalksGame"
        }, {
            name: "Quiplash 3",
            tag: "quiplash3",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp7/quiplash3",
            features: ["moderation"],
            categoryId: "quiplash3Game"
        }, {
            name: "The Devils and the Details",
            tag: "everyday",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp7/everyday",
            categoryId: "EverydayGame",
            shopItems: ["mugs"]
        }, {
            name: "Champ'd Up",
            tag: "worldchamps",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp7/worldchamps",
            features: ["moderation"],
            categoryId: "WorldChampionsGame",
            shopItems: ["cards"]
        }, {
            name: "Blather 'Round",
            tag: "blanky-blank",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp7/blanky-blank",
            categoryId: "BlankyBlankGame"
        }, {
            name: "Job Job",
            tag: "apply-yourself",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp8/apply-yourself",
            categoryId: "JobGameGame",
            features: ["moderation", "previews"]
        }, {
            name: "Drawful Animate",
            tag: "drawful-animate",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp8/drawful-animate",
            categoryId: "DrawfulAnimateGame",
            features: ["moderation"]
        }, {
            name: "The Wheel of Enormous Proportions",
            tag: "the-wheel",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp8/the-wheel",
            categoryId: "TheWheelGame"
        }, {
            name: "The Poll Mine",
            tag: "survey-bomb",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp8/survey-bomb",
            categoryId: "SurveyBombGame"
        }, {
            name: "Weapons Drawn",
            tag: "murder-detectives",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp8/murder-detectives",
            categoryId: "MurderDetectivesGame",
            features: ["moderation"]
        }, {
            name: "Quiplash 3",
            tag: "quiplash3-tjsp",
            wrapper: "vue",
            isPublic: !0,
            directory: "tjsp/quiplash3",
            features: ["moderation"],
            categoryId: "quiplash3Game"
        }, {
            name: "Tee K.O.",
            tag: "awshirt-tjsp",
            wrapper: "vue",
            isPublic: !0,
            directory: "tjsp/awshirt",
            features: ["moderation"],
            shopItems: ["shirts"],
            categoryId: "TeeKOGame"
        }, {
            name: "Trivia Murder Party 2",
            tag: "triviadeath2-tjsp",
            wrapper: "vue",
            isPublic: !0,
            directory: "tjsp/triviadeath2",
            categoryId: "TriviaMurderParty2Game"
        }, {
            name: "Fibbage 4",
            tag: "fourbage",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp9/fourbage",
            features: ["moderation", "kicking"],
            categoryId: "Fibbage4Game"
        }, {
            name: "Roomerang",
            tag: "htmf",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp9/htmf",
            features: ["moderation", "kicking"],
            categoryId: "MakeFriendsGame"
        }, {
            name: "Junktopia",
            tag: "antique-freak",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp9/antique-freak",
            features: ["moderation", "kicking"],
            categoryId: "AntiqueGameGame"
        }, {
            name: "Nonsensory",
            tag: "range-game",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp9/range-game",
            features: ["moderation", "kicking"],
            categoryId: "RangeGameGame"
        }, {
            name: "Quixort",
            tag: "lineup",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp9/lineup",
            features: ["kicking", "previews"],
            categoryId: "LineupGame"
        }, {
            name: "Tee K.O. 2",
            tag: "awshirt2",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp10/awshirt2",
            features: ["moderation", "kicking"],
            shopItems: ["shirts"],
            categoryId: "TeeKO2Game"
        }, {
            name: "Dodo Re Mi",
            tag: "nopus-opus",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp10/nopus-opus",
            features: ["dropInDropOut", "kicking"],
            shopItems: [],
            categoryId: "NopusOpusGame"
        }, {
            name: "FixyText",
            tag: "risky-text",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp10/risky-text",
            features: ["moderation", "kicking"],
            shopItems: [],
            categoryId: "RiskyTextGame"
        }, {
            name: "Timejinx",
            tag: "time-trivia",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp10/time-trivia",
            features: ["kicking"],
            shopItems: [],
            categoryId: "TimeTriviaGame"
        }, {
            name: "Hypnotorious",
            tag: "us-them",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp10/us-them",
            features: ["moderation", "kicking"],
            shopItems: [],
            categoryId: "UsThemGame"
        }],
        b1 = t => tK.find(e => e.tag === t || e.categoryId === t);

    function E1(...t) {
        console.log(...t)
    }
    class nK {
        constructor(e, n) {
            Se(this, "client");
            Se(this, "room");
            Se(this, "items", []);
            Se(this, "autoMarkWindow", 150);
            Se(this, "autoMarkTimeout");
            Se(this, "autoMarkerCount", 0);
            Se(this, "automarkIgnoredKeys", []);
            Se(this, "automarkPendingLabel");
            window.tv.debug = this.expose(), this.client = e, this.room = n, Object.keys(this.client.entities).forEach(r => {
                this.pushEntity(this.client.entities[r])
            }), this.items.length && this.setMarker("welcome"), e.on("artifact", r => this.pushEntity(r)), e.on("doodle", r => this.pushEntity(r)), e.on("drop", r => this.pushEntity(r)), e.on("number", r => this.pushEntity(r)), e.on("object", r => this.pushEntity(r)), e.on("text", r => this.pushEntity(r)), this.hijackConsole(), this.hijackSend()
        }
        get markerCount() {
            return this.items.reduce((e, n) => "marker" in n ? e + 1 : e, 0)
        }
        reset() {
            this.items = []
        }
        setAutomarkIgnoredKeys(e) {
            this.automarkIgnoredKeys = e
        }
        hijackConsole() {
            const e = console.error.bind(console);
            console.error = (...n) => {
                this.pushError(n), e.apply(console, n)
            }
        }
        hijackSend() {
            window.Proxy && (this.client.send = new Proxy(this.client.send, {
                apply: (e, n, r) => (this.pushSend(r), e.apply(n, r))
            }))
        }
        pushEntity(e) {
            E1("[Debug] pushEntity", e), e instanceof Tr.ArtifactEntity ? this.items.push({
                type: "artifact",
                ...e
            }) : e instanceof Tr.DoodleEntity ? this.items.push({
                type: "doodle",
                ...e
            }) : e instanceof Tr.DropEntity ? this.items.push({
                key: e.key,
                type: "drop"
            }) : e instanceof Tr.NumberEntity ? this.items.push({
                key: e.key,
                type: "number",
                value: e.val,
                meta: e.meta,
                restrictions: e.restrictions
            }) : e instanceof Tr.ObjectEntity ? (e.val.kind && (this.automarkPendingLabel = e.val.kind), this.items.push({
                key: e.key,
                type: "object",
                value: e.val,
                meta: e.meta
            })) : e instanceof Tr.TextEntity && this.items.push({
                key: e.key,
                type: "text",
                value: e.text,
                meta: e.meta
            }), !this.automarkIgnoredKeys.includes(e.key) && this.startAutoMarkTimeout()
        }
        pushError(...e) {
            this.items.push({
                error: e
            })
        }
        pushSend(e) {
            this.items.push({
                opcode: e[0],
                arguments: e[1]
            })
        }
        setMarker(e) {
            const n = this.items.filter(s => s.marker === e).length,
                r = n ? `label-${n}` : e;
            this.items.push({
                marker: r
            }), this.clearAutoMarkTimeout()
        }
        setAutoMarker() {
            const e = this.automarkPendingLabel ?? "marker";
            this.items.push({
                marker: `${this.autoMarkerCount}-${e}`
            }), this.autoMarkerCount += 1, delete this.automarkPendingLabel, this.clearAutoMarkTimeout()
        }
        startAutoMarkTimeout() {
            this.clearAutoMarkTimeout(), this.autoMarkTimeout = window.setTimeout(() => {
                this.setAutoMarker()
            }, this.autoMarkWindow)
        }
        clearAutoMarkTimeout() {
            this.autoMarkTimeout && (window.clearTimeout(this.autoMarkTimeout), delete this.autoMarkTimeout)
        }
        async send(e) {
            if (!this.client) return;
            const n = await this.sendToEcast();
            n && await this.sendToSlack(n, e)
        }
        getSendData() {
            return {
                appTag: this.room.appTag,
                state: {
                    version: 3,
                    room: {
                        code: this.room.code,
                        appTag: this.room.appTag
                    },
                    client: {
                        id: this.client.id,
                        name: this.client.name,
                        role: this.client.role
                    },
                    items: this.items
                }
            }
        }
        async sendToEcast() {
            const e = this.getSendData();
            try {
                const r = await (await fetch("https://ecast.jackboxgames.com/api/v2/controller/state", {
                    method: "POST",
                    body: JSON.stringify(e)
                })).json();
                if (!r.body || !r.body.url) return console.warn(r), null;
                const s = r.body.url.split("/"),
                    i = s[s.length - 1].replace(".json", ""),
                    a = s[s.length - 2];
                return {
                    json: r.body.url,
                    dev: `https://dev.jackbox.tv/debug/cloud/${a}/${i}/`,
                    local: `http://localhost:9090/debug/cloud/${a}/${i}/`
                }
            } catch (n) {
                return console.error("[Debug] sendToEcast", n), null
            }
        }
        async sendToSlack(e, n) {
            if (!this.room || !this.client) return;
            const r = b1(this.room.appTag),
                s = this.items.length - this.markerCount,
                i = `${this.markerCount} ${this.markerCount===1?"marker":"markers"}`,
                a = `${s} ${s===1?"entity":"entities"}`,
                c = [{
                    type: "mrkdwn",
                    text: `${this.client.role}:${this.client.id}`
                }, {
                    type: "mrkdwn",
                    text: `*Version:* ${window.tv.manifest.loader.version}`
                }, {
                    type: "mrkdwn",
                    text: `*Domain:* ${window.location.hostname}`
                }];
            try {
                const u = "https://hooks.slack.com/services/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",
                    m = {
                        unfurl_links: !1,
                        blocks: [{
                            type: "section",
                            text: {
                                type: "mrkdwn",
                                text: `*${(r==null?void 0:r.name)??this.room.appTag} :${this.room.appTag}:* (${i}, ${a}) 

 From: ${this.client.name},
${n}`
                            }
                        }, {
                            type: "context",
                            elements: c
                        }, {
                            type: "actions",
                            elements: [{
                                type: "button",
                                action_id: "actionId-0",
                                url: e.json,
                                text: {
                                    type: "plain_text",
                                    text: "JSON",
                                    emoji: !0
                                }
                            }, {
                                type: "button",
                                action_id: "actionId-3",
                                url: e.local,
                                text: {
                                    type: "plain_text",
                                    text: "localhost:9090",
                                    emoji: !0
                                }
                            }, {
                                type: "button",
                                action_id: "actionId-1",
                                url: e.dev,
                                text: {
                                    type: "plain_text",
                                    text: "dev.jackbox.tv",
                                    emoji: !0
                                }
                            }]
                        }]
                    };
                if (this.room) {
                    m.icon_emoji = this.room.appTag;
                    const v = b1(this.room.appTag);
                    m.username = `DebugRecorder ${v?v.name:this.room.appTag}`
                }
                const y = await (await fetch(u, {
                    method: "POST",
                    body: JSON.stringify(m)
                })).text();
                E1("[Debug] sendToSlack", y)
            } catch (u) {
                console.error("[Debug] sendToSlack", u)
            }
        }
        download(e) {
            var a;
            const n = e ?? `${((a=this.room)==null?void 0:a.appTag)??"unknown"}-debug`,
                r = this.getSendData().state,
                s = JSON.stringify(r, null, 4),
                i = document.createElement("a");
            i.setAttribute("href", `data:text/json;charset=utf-8,${encodeURIComponent(s)}`), i.setAttribute("download", `${n}.json`), i.style.display = "none", document.body.appendChild(i), i.click(), document.body.removeChild(i)
        }
        open() {
            var s;
            const e = this.getSendData().state,
                n = JSON.stringify(e, null, 4),
                r = window.open();
            r.document.write(`
            <iframe src="data:text/json;charset=utf-8,${encodeURIComponent(n)}" frameborder="0" style="border:0;
                top:0px; left:0px; bottom:0px; right:0px; width:100%; height:100%;" allowfullscreen>
            </iframe>
        `), r.document.title = `${(s=this.room)==null?void 0:s.appTag} debug JSON`, r.document.close(), r.focus()
        }
        expose() {
            return {
                print: () => this.items,
                reset: () => this.reset(),
                setMarker: e => this.setMarker(e),
                download: e => this.download(e),
                open: () => this.open(),
                send: e => void this.send(e)
            }
        }
    }

    function rK(t) {
        throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
    }
    var bS = {
        exports: {}
    };
    (function(t, e) {
        (function(n, r) {
            r(e)
        })(gn, function(n) {
            var r = typeof window < "u" ? window : typeof gn < "u" ? gn : typeof self < "u" ? self : {},
                s = function(P, z) {
                    if (z = z.split(":")[0], P = +P, !P) return !1;
                    switch (z) {
                        case "http":
                        case "ws":
                            return P !== 80;
                        case "https":
                        case "wss":
                            return P !== 443;
                        case "ftp":
                            return P !== 21;
                        case "gopher":
                            return P !== 70;
                        case "file":
                            return !1
                    }
                    return P !== 0
                },
                i = Object.prototype.hasOwnProperty,
                a;

            function c(D) {
                try {
                    return decodeURIComponent(D.replace(/\+/g, " "))
                } catch {
                    return null
                }
            }

            function u(D) {
                try {
                    return encodeURIComponent(D)
                } catch {
                    return null
                }
            }

            function h(D) {
                for (var P = /([^=?#&]+)=?([^&]*)/g, z = {}, R; R = P.exec(D);) {
                    var K = c(R[1]),
                        me = c(R[2]);
                    K === null || me === null || K in z || (z[K] = me)
                }
                return z
            }

            function d(D, P) {
                P = P || "";
                var z = [],
                    R, K;
                typeof P != "string" && (P = "?");
                for (K in D)
                    if (i.call(D, K)) {
                        if (R = D[K], !R && (R === null || R === a || isNaN(R)) && (R = ""), K = u(K), R = u(R), K === null || R === null) continue;
                        z.push(K + "=" + R)
                    } return z.length ? P + z.join("&") : ""
            }
            var p = d,
                m = h,
                _ = {
                    stringify: p,
                    parse: m
                },
                y = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//,
                v = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i,
                w = "[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]",
                b = new RegExp("^" + w + "+");

            function I(D) {
                return (D || "").toString().replace(b, "")
            }
            var F = [
                    ["#", "hash"],
                    ["?", "query"],
                    function(P, z) {
                        return M(z.protocol) ? P.replace(/\\/g, "/") : P
                    },
                    ["/", "pathname"],
                    ["@", "auth", 1],
                    [NaN, "host", void 0, 1, 1],
                    [/:(\d+)$/, "port", void 0, 1],
                    [NaN, "hostname", void 0, 1, 1]
                ],
                x = {
                    hash: 1,
                    query: 1
                };

            function O(D) {
                var P;
                typeof window < "u" ? P = window : typeof r < "u" ? P = r : typeof self < "u" ? P = self : P = {};
                var z = P.location || {};
                D = D || z;
                var R = {},
                    K = typeof D,
                    me;
                if (D.protocol === "blob:") R = new ee(unescape(D.pathname), {});
                else if (K === "string") {
                    R = new ee(D, {});
                    for (me in x) delete R[me]
                } else if (K === "object") {
                    for (me in D) me in x || (R[me] = D[me]);
                    R.slashes === void 0 && (R.slashes = y.test(D.href))
                }
                return R
            }

            function M(D) {
                return D === "file:" || D === "ftp:" || D === "http:" || D === "https:" || D === "ws:" || D === "wss:"
            }

            function $(D, P) {
                D = I(D), P = P || {};
                var z = v.exec(D),
                    R = z[1] ? z[1].toLowerCase() : "",
                    K = !!z[2],
                    me = !!z[3],
                    Ee = 0,
                    Ce;
                return K ? me ? (Ce = z[2] + z[3] + z[4], Ee = z[2].length + z[3].length) : (Ce = z[2] + z[4], Ee = z[2].length) : me ? (Ce = z[3] + z[4], Ee = z[3].length) : Ce = z[4], R === "file:" ? Ee >= 2 && (Ce = Ce.slice(2)) : M(R) ? Ce = z[4] : R ? K && (Ce = Ce.slice(2)) : Ee >= 2 && M(P.protocol) && (Ce = z[4]), {
                    protocol: R,
                    slashes: K || M(R),
                    slashesCount: Ee,
                    rest: Ce
                }
            }

            function j(D, P) {
                if (D === "") return P;
                for (var z = (P || "/").split("/").slice(0, -1).concat(D.split("/")), R = z.length, K = z[R - 1], me = !1, Ee = 0; R--;) z[R] === "." ? z.splice(R, 1) : z[R] === ".." ? (z.splice(R, 1), Ee++) : Ee && (R === 0 && (me = !0), z.splice(R, 1), Ee--);
                return me && z.unshift(""), (K === "." || K === "..") && z.push(""), z.join("/")
            }

            function ee(D, P, z) {
                if (D = I(D), !(this instanceof ee)) return new ee(D, P, z);
                var R, K, me, Ee, Ce, De, hn = F.slice(),
                    Nr = typeof P,
                    Ze = this,
                    bl = 0;
                for (Nr !== "object" && Nr !== "string" && (z = P, P = null), z && typeof z != "function" && (z = _.parse), P = O(P), K = $(D || "", P), R = !K.protocol && !K.slashes, Ze.slashes = K.slashes || R && P.slashes, Ze.protocol = K.protocol || P.protocol || "", D = K.rest, (Ze.protocol === "file:" || !K.slashes && (K.protocol || K.slashesCount < 2 || !M(Ze.protocol))) && (hn[3] = [/(.*)/, "pathname"]); bl < hn.length; bl++) {
                    if (Ee = hn[bl], typeof Ee == "function") {
                        D = Ee(D, Ze);
                        continue
                    }
                    me = Ee[0], De = Ee[1], me !== me ? Ze[De] = D : typeof me == "string" ? ~(Ce = D.indexOf(me)) && (typeof Ee[2] == "number" ? (Ze[De] = D.slice(0, Ce), D = D.slice(Ce + Ee[2])) : (Ze[De] = D.slice(Ce), D = D.slice(0, Ce))) : (Ce = me.exec(D)) && (Ze[De] = Ce[1], D = D.slice(0, Ce.index)), Ze[De] = Ze[De] || R && Ee[3] && P[De] || "", Ee[4] && (Ze[De] = Ze[De].toLowerCase())
                }
                z && (Ze.query = z(Ze.query)), R && P.slashes && Ze.pathname.charAt(0) !== "/" && (Ze.pathname !== "" || P.pathname !== "") && (Ze.pathname = j(Ze.pathname, P.pathname)), Ze.pathname.charAt(0) !== "/" && M(Ze.protocol) && (Ze.pathname = "/" + Ze.pathname), s(Ze.port, Ze.protocol) || (Ze.host = Ze.hostname, Ze.port = ""), Ze.username = Ze.password = "", Ze.auth && (Ee = Ze.auth.split(":"), Ze.username = Ee[0] || "", Ze.password = Ee[1] || ""), Ze.origin = Ze.protocol !== "file:" && M(Ze.protocol) && Ze.host ? Ze.protocol + "//" + Ze.host : "null", Ze.href = Ze.toString()
            }

            function se(D, P, z) {
                var R = this;
                switch (D) {
                    case "query":
                        typeof P == "string" && P.length && (P = (z || _.parse)(P)), R[D] = P;
                        break;
                    case "port":
                        R[D] = P, s(P, R.protocol) ? P && (R.host = R.hostname + ":" + P) : (R.host = R.hostname, R[D] = "");
                        break;
                    case "hostname":
                        R[D] = P, R.port && (P += ":" + R.port), R.host = P;
                        break;
                    case "host":
                        R[D] = P, /:\d+$/.test(P) ? (P = P.split(":"), R.port = P.pop(), R.hostname = P.join(":")) : (R.hostname = P, R.port = "");
                        break;
                    case "protocol":
                        R.protocol = P.toLowerCase(), R.slashes = !z;
                        break;
                    case "pathname":
                    case "hash":
                        if (P) {
                            var K = D === "pathname" ? "/" : "#";
                            R[D] = P.charAt(0) !== K ? K + P : P
                        } else R[D] = P;
                        break;
                    default:
                        R[D] = P
                }
                for (var me = 0; me < F.length; me++) {
                    var Ee = F[me];
                    Ee[4] && (R[Ee[1]] = R[Ee[1]].toLowerCase())
                }
                return R.origin = R.protocol !== "file:" && M(R.protocol) && R.host ? R.protocol + "//" + R.host : "null", R.href = R.toString(), R
            }

            function oe(D) {
                (!D || typeof D != "function") && (D = _.stringify);
                var P, z = this,
                    R = z.protocol;
                R && R.charAt(R.length - 1) !== ":" && (R += ":");
                var K = R + (z.slashes || M(z.protocol) ? "//" : "");
                return z.username && (K += z.username, z.password && (K += ":" + z.password), K += "@"), K += z.host + z.pathname, P = typeof z.query == "object" ? D(z.query) : z.query, P && (K += P.charAt(0) !== "?" ? "?" + P : P), z.hash && (K += z.hash), K
            }
            ee.prototype = {
                set: se,
                toString: oe
            }, ee.extractProtocol = $, ee.location = O, ee.trimLeft = I, ee.qs = _;
            var Z = ee;

            function de(D, P) {
                setTimeout(function(z) {
                    return D.call(z)
                }, 4, P)
            }

            function q(D, P) {
                typeof process < "u" && console[D].call(null, P)
            }

            function ie(D, P) {
                D === void 0 && (D = []);
                var z = [];
                return D.forEach(function(R) {
                    P(R) || z.push(R)
                }), z
            }

            function ae(D, P) {
                D === void 0 && (D = []);
                var z = [];
                return D.forEach(function(R) {
                    P(R) && z.push(R)
                }), z
            }
            var he = function() {
                this.listeners = {}
            };
            he.prototype.addEventListener = function(P, z) {
                typeof z == "function" && (Array.isArray(this.listeners[P]) || (this.listeners[P] = []), ae(this.listeners[P], function(R) {
                    return R === z
                }).length === 0 && this.listeners[P].push(z))
            }, he.prototype.removeEventListener = function(P, z) {
                var R = this.listeners[P];
                this.listeners[P] = ie(R, function(K) {
                    return K === z
                })
            }, he.prototype.dispatchEvent = function(P) {
                for (var z = this, R = [], K = arguments.length - 1; K-- > 0;) R[K] = arguments[K + 1];
                var me = P.type,
                    Ee = this.listeners[me];
                return Array.isArray(Ee) ? (Ee.forEach(function(Ce) {
                    R.length > 0 ? Ce.apply(z, R) : Ce.call(z, P)
                }), !0) : !1
            };

            function ve(D) {
                var P = D.indexOf("?");
                return P >= 0 ? D.slice(0, P) : D
            }
            var be = function() {
                this.urlMap = {}
            };
            be.prototype.attachWebSocket = function(P, z) {
                var R = ve(z),
                    K = this.urlMap[R];
                if (K && K.server && K.websockets.indexOf(P) === -1) return K.websockets.push(P), K.server
            }, be.prototype.addMembershipToRoom = function(P, z) {
                var R = this.urlMap[ve(P.url)];
                R && R.server && R.websockets.indexOf(P) !== -1 && (R.roomMemberships[z] || (R.roomMemberships[z] = []), R.roomMemberships[z].push(P))
            }, be.prototype.attachServer = function(P, z) {
                var R = ve(z),
                    K = this.urlMap[R];
                if (!K) return this.urlMap[R] = {
                    server: P,
                    websockets: [],
                    roomMemberships: {}
                }, P
            }, be.prototype.serverLookup = function(P) {
                var z = ve(P),
                    R = this.urlMap[z];
                if (R) return R.server
            }, be.prototype.websocketsLookup = function(P, z, R) {
                var K = ve(P),
                    me, Ee = this.urlMap[K];
                if (me = Ee ? Ee.websockets : [], z) {
                    var Ce = Ee.roomMemberships[z];
                    me = Ce || []
                }
                return R ? me.filter(function(De) {
                    return De !== R
                }) : me
            }, be.prototype.removeServer = function(P) {
                delete this.urlMap[ve(P)]
            }, be.prototype.removeWebSocket = function(P, z) {
                var R = ve(z),
                    K = this.urlMap[R];
                K && (K.websockets = ie(K.websockets, function(me) {
                    return me === P
                }))
            }, be.prototype.removeMembershipFromRoom = function(P, z) {
                var R = this.urlMap[ve(P.url)],
                    K = R.roomMemberships[z];
                R && K !== null && (R.roomMemberships[z] = ie(K, function(me) {
                    return me === P
                }))
            };
            var Ae = new be,
                we = {
                    CLOSE_NORMAL: 1e3,
                    CLOSE_GOING_AWAY: 1001,
                    CLOSE_PROTOCOL_ERROR: 1002,
                    CLOSE_UNSUPPORTED: 1003,
                    CLOSE_NO_STATUS: 1005,
                    CLOSE_ABNORMAL: 1006,
                    UNSUPPORTED_DATA: 1007,
                    POLICY_VIOLATION: 1008,
                    CLOSE_TOO_LARGE: 1009,
                    MISSING_EXTENSION: 1010,
                    INTERNAL_ERROR: 1011,
                    SERVICE_RESTART: 1012,
                    TRY_AGAIN_LATER: 1013,
                    TLS_HANDSHAKE: 1015
                },
                Me = {
                    CONSTRUCTOR_ERROR: "Failed to construct 'WebSocket':",
                    CLOSE_ERROR: "Failed to execute 'close' on 'WebSocket':",
                    EVENT: {
                        CONSTRUCT: "Failed to construct 'Event':",
                        MESSAGE: "Failed to construct 'MessageEvent':",
                        CLOSE: "Failed to construct 'CloseEvent':"
                    }
                },
                Nt = function() {};
            Nt.prototype.stopPropagation = function() {}, Nt.prototype.stopImmediatePropagation = function() {}, Nt.prototype.initEvent = function(P, z, R) {
                P === void 0 && (P = "undefined"), z === void 0 && (z = !1), R === void 0 && (R = !1), this.type = "" + P, this.bubbles = !!z, this.cancelable = !!R
            };
            var jt = function(D) {
                    function P(z, R) {
                        if (R === void 0 && (R = {}), D.call(this), !z) throw new TypeError(Me.EVENT_ERROR + " 1 argument required, but only 0 present.");
                        if (typeof R != "object") throw new TypeError(Me.EVENT_ERROR + " parameter 2 ('eventInitDict') is not an object.");
                        var K = R.bubbles,
                            me = R.cancelable;
                        this.type = "" + z, this.timeStamp = Date.now(), this.target = null, this.srcElement = null, this.returnValue = !0, this.isTrusted = !1, this.eventPhase = 0, this.defaultPrevented = !1, this.currentTarget = null, this.cancelable = me ? !!me : !1, this.cancelBubble = !1, this.bubbles = K ? !!K : !1
                    }
                    return D && (P.__proto__ = D), P.prototype = Object.create(D && D.prototype), P.prototype.constructor = P, P
                }(Nt),
                Ue = function(D) {
                    function P(z, R) {
                        if (R === void 0 && (R = {}), D.call(this), !z) throw new TypeError(Me.EVENT.MESSAGE + " 1 argument required, but only 0 present.");
                        if (typeof R != "object") throw new TypeError(Me.EVENT.MESSAGE + " parameter 2 ('eventInitDict') is not an object");
                        var K = R.bubbles,
                            me = R.cancelable,
                            Ee = R.data,
                            Ce = R.origin,
                            De = R.lastEventId,
                            hn = R.ports;
                        this.type = "" + z, this.timeStamp = Date.now(), this.target = null, this.srcElement = null, this.returnValue = !0, this.isTrusted = !1, this.eventPhase = 0, this.defaultPrevented = !1, this.currentTarget = null, this.cancelable = me ? !!me : !1, this.canncelBubble = !1, this.bubbles = K ? !!K : !1, this.origin = "" + Ce, this.ports = typeof hn > "u" ? null : hn, this.data = typeof Ee > "u" ? null : Ee, this.lastEventId = "" + (De || "")
                    }
                    return D && (P.__proto__ = D), P.prototype = Object.create(D && D.prototype), P.prototype.constructor = P, P
                }(Nt),
                Ye = function(D) {
                    function P(z, R) {
                        if (R === void 0 && (R = {}), D.call(this), !z) throw new TypeError(Me.EVENT.CLOSE + " 1 argument required, but only 0 present.");
                        if (typeof R != "object") throw new TypeError(Me.EVENT.CLOSE + " parameter 2 ('eventInitDict') is not an object");
                        var K = R.bubbles,
                            me = R.cancelable,
                            Ee = R.code,
                            Ce = R.reason,
                            De = R.wasClean;
                        this.type = "" + z, this.timeStamp = Date.now(), this.target = null, this.srcElement = null, this.returnValue = !0, this.isTrusted = !1, this.eventPhase = 0, this.defaultPrevented = !1, this.currentTarget = null, this.cancelable = me ? !!me : !1, this.cancelBubble = !1, this.bubbles = K ? !!K : !1, this.code = typeof Ee == "number" ? parseInt(Ee, 10) : 0, this.reason = "" + (Ce || ""), this.wasClean = De ? !!De : !1
                    }
                    return D && (P.__proto__ = D), P.prototype = Object.create(D && D.prototype), P.prototype.constructor = P, P
                }(Nt);

            function at(D) {
                var P = D.type,
                    z = D.target,
                    R = new jt(P);
                return z && (R.target = z, R.srcElement = z, R.currentTarget = z), R
            }

            function ke(D) {
                var P = D.type,
                    z = D.origin,
                    R = D.data,
                    K = D.target,
                    me = new Ue(P, {
                        data: R,
                        origin: z
                    });
                return K && (me.target = K, me.srcElement = K, me.currentTarget = K), me
            }

            function rt(D) {
                var P = D.code,
                    z = D.reason,
                    R = D.type,
                    K = D.target,
                    me = D.wasClean;
                me || (me = P === we.CLOSE_NORMAL || P === we.CLOSE_NO_STATUS);
                var Ee = new Ye(R, {
                    code: P,
                    reason: z,
                    wasClean: me
                });
                return K && (Ee.target = K, Ee.srcElement = K, Ee.currentTarget = K), Ee
            }

            function Yt(D, P, z) {
                D.readyState = re.CLOSING;
                var R = Ae.serverLookup(D.url),
                    K = rt({
                        type: "close",
                        target: D.target,
                        code: P,
                        reason: z
                    }),
                    me = rt({
                        type: "server::close",
                        target: D,
                        code: P,
                        reason: z
                    });
                de(function() {
                    Ae.removeWebSocket(D, D.url), D.readyState = re.CLOSED, D.dispatchEvent(K), D.dispatchEvent(me), R && R.dispatchEvent(K, R)
                }, D)
            }

            function zt(D, P, z) {
                D.readyState = re.CLOSING;
                var R = Ae.serverLookup(D.url),
                    K = rt({
                        type: "close",
                        target: D.target,
                        code: P,
                        reason: z,
                        wasClean: !1
                    }),
                    me = rt({
                        type: "server::close",
                        target: D,
                        code: P,
                        reason: z,
                        wasClean: !1
                    }),
                    Ee = at({
                        type: "error",
                        target: D.target
                    });
                de(function() {
                    Ae.removeWebSocket(D, D.url), D.readyState = re.CLOSED, D.dispatchEvent(Ee), D.dispatchEvent(K), D.dispatchEvent(me), R && R.dispatchEvent(K, R)
                }, D)
            }

            function U(D) {
                return Object.prototype.toString.call(D) !== "[object Blob]" && !(D instanceof ArrayBuffer) && (D = String(D)), D
            }
            var T = new WeakMap;

            function S(D) {
                if (T.has(D)) return T.get(D);
                var P = new Proxy(D, {
                    get: function(R, K) {
                        return K === "close" ? function(Ee) {
                            Ee === void 0 && (Ee = {});
                            var Ce = Ee.code || we.CLOSE_NORMAL,
                                De = Ee.reason || "";
                            Yt(P, Ce, De)
                        } : K === "send" ? function(Ee) {
                            Ee = U(Ee), D.dispatchEvent(ke({
                                type: "message",
                                data: Ee,
                                origin: this.url,
                                target: D
                            }))
                        } : K === "on" ? function(Ee, Ce) {
                            D.addEventListener("server::" + Ee, Ce)
                        } : K === "target" ? D : R[K]
                    }
                });
                return T.set(D, P), P
            }

            function N(D) {
                var P = encodeURIComponent(D).match(/%[89ABab]/g);
                return D.length + (P ? P.length : 0)
            }

            function V(D) {
                var P = new Z(D),
                    z = P.pathname,
                    R = P.protocol,
                    K = P.hash;
                if (!D) throw new TypeError(Me.CONSTRUCTOR_ERROR + " 1 argument required, but only 0 present.");
                if (z || (P.pathname = "/"), R === "") throw new SyntaxError(Me.CONSTRUCTOR_ERROR + " The URL '" + P.toString() + "' is invalid.");
                if (R !== "ws:" && R !== "wss:") throw new SyntaxError(Me.CONSTRUCTOR_ERROR + " The URL's scheme must be either 'ws' or 'wss'. '" + R + "' is not allowed.");
                if (K !== "") throw new SyntaxError(Me.CONSTRUCTOR_ERROR + " The URL contains a fragment identifier ('" + K + "'). Fragment identifiers are not allowed in WebSocket URLs.");
                return P.toString()
            }

            function te(D) {
                if (D === void 0 && (D = []), !Array.isArray(D) && typeof D != "string") throw new SyntaxError(Me.CONSTRUCTOR_ERROR + " The subprotocol '" + D.toString() + "' is invalid.");
                typeof D == "string" && (D = [D]);
                var P = D.map(function(R) {
                        return {
                            count: 1,
                            protocol: R
                        }
                    }).reduce(function(R, K) {
                        return R[K.protocol] = (R[K.protocol] || 0) + K.count, R
                    }, {}),
                    z = Object.keys(P).filter(function(R) {
                        return P[R] > 1
                    });
                if (z.length > 0) throw new SyntaxError(Me.CONSTRUCTOR_ERROR + " The subprotocol '" + z[0] + "' is duplicated.");
                return D
            }
            var re = function(D) {
                function P(R, K) {
                    D.call(this), this._onopen = null, this._onmessage = null, this._onerror = null, this._onclose = null, this.url = V(R), K = te(K), this.protocol = K[0] || "", this.binaryType = "blob", this.readyState = P.CONNECTING;
                    var me = S(this),
                        Ee = Ae.attachWebSocket(me, this.url);
                    de(function() {
                        if (Ee)
                            if (Ee.options.verifyClient && typeof Ee.options.verifyClient == "function" && !Ee.options.verifyClient()) this.readyState = P.CLOSED, q("error", "WebSocket connection to '" + this.url + "' failed: HTTP Authentication failed; no valid credentials available"), Ae.removeWebSocket(me, this.url), this.dispatchEvent(at({
                                type: "error",
                                target: this
                            })), this.dispatchEvent(rt({
                                type: "close",
                                target: this,
                                code: we.CLOSE_NORMAL
                            }));
                            else {
                                if (Ee.options.selectProtocol && typeof Ee.options.selectProtocol == "function") {
                                    var De = Ee.options.selectProtocol(K),
                                        hn = De !== "",
                                        Nr = K.indexOf(De) !== -1;
                                    if (hn && !Nr) {
                                        this.readyState = P.CLOSED, q("error", "WebSocket connection to '" + this.url + "' failed: Invalid Sub-Protocol"), Ae.removeWebSocket(me, this.url), this.dispatchEvent(at({
                                            type: "error",
                                            target: this
                                        })), this.dispatchEvent(rt({
                                            type: "close",
                                            target: this,
                                            code: we.CLOSE_NORMAL
                                        }));
                                        return
                                    }
                                    this.protocol = De
                                }
                                this.readyState = P.OPEN, this.dispatchEvent(at({
                                    type: "open",
                                    target: this
                                })), Ee.dispatchEvent(at({
                                    type: "connection"
                                }), me)
                            }
                        else this.readyState = P.CLOSED, this.dispatchEvent(at({
                            type: "error",
                            target: this
                        })), this.dispatchEvent(rt({
                            type: "close",
                            target: this,
                            code: we.CLOSE_NORMAL
                        })), q("error", "WebSocket connection to '" + this.url + "' failed")
                    }, this)
                }
                D && (P.__proto__ = D), P.prototype = Object.create(D && D.prototype), P.prototype.constructor = P;
                var z = {
                    onopen: {},
                    onmessage: {},
                    onclose: {},
                    onerror: {}
                };
                return z.onopen.get = function() {
                    return this._onopen
                }, z.onmessage.get = function() {
                    return this._onmessage
                }, z.onclose.get = function() {
                    return this._onclose
                }, z.onerror.get = function() {
                    return this._onerror
                }, z.onopen.set = function(R) {
                    this.removeEventListener("open", this._onopen), this._onopen = R, this.addEventListener("open", R)
                }, z.onmessage.set = function(R) {
                    this.removeEventListener("message", this._onmessage), this._onmessage = R, this.addEventListener("message", R)
                }, z.onclose.set = function(R) {
                    this.removeEventListener("close", this._onclose), this._onclose = R, this.addEventListener("close", R)
                }, z.onerror.set = function(R) {
                    this.removeEventListener("error", this._onerror), this._onerror = R, this.addEventListener("error", R)
                }, P.prototype.send = function(K) {
                    var me = this;
                    if (this.readyState === P.CLOSING || this.readyState === P.CLOSED) throw new Error("WebSocket is already in CLOSING or CLOSED state");
                    var Ee = ke({
                            type: "server::message",
                            origin: this.url,
                            data: U(K)
                        }),
                        Ce = Ae.serverLookup(this.url);
                    Ce && de(function() {
                        me.dispatchEvent(Ee, K)
                    }, Ce)
                }, P.prototype.close = function(K, me) {
                    if (K !== void 0 && (typeof K != "number" || K !== 1e3 && (K < 3e3 || K > 4999))) throw new TypeError(Me.CLOSE_ERROR + " The code must be either 1000, or between 3000 and 4999. " + K + " is neither.");
                    if (me !== void 0) {
                        var Ee = N(me);
                        if (Ee > 123) throw new SyntaxError(Me.CLOSE_ERROR + " The message must not be greater than 123 bytes.")
                    }
                    if (!(this.readyState === P.CLOSING || this.readyState === P.CLOSED)) {
                        var Ce = S(this);
                        this.readyState === P.CONNECTING ? zt(Ce, K || we.CLOSE_ABNORMAL, me) : Yt(Ce, K || we.CLOSE_NO_STATUS, me)
                    }
                }, Object.defineProperties(P.prototype, z), P
            }(he);
            re.CONNECTING = 0, re.prototype.CONNECTING = re.CONNECTING, re.OPEN = 1, re.prototype.OPEN = re.OPEN, re.CLOSING = 2, re.prototype.CLOSING = re.CLOSING, re.CLOSED = 3, re.prototype.CLOSED = re.CLOSED;
            var ue = function(D) {
                return D.reduce(function(P, z) {
                    return P.indexOf(z) > -1 ? P : P.concat(z)
                }, [])
            };

            function pe() {
                return typeof window < "u" ? window : typeof process == "object" && typeof rK == "function" && typeof gn == "object" ? gn : this
            }
            var ce = {
                    mock: !0,
                    verifyClient: null,
                    selectProtocol: null
                },
                J = function(D) {
                    function P(z, R) {
                        R === void 0 && (R = ce), D.call(this);
                        var K = new Z(z);
                        K.pathname || (K.pathname = "/"), this.url = K.toString(), this.originalWebSocket = null;
                        var me = Ae.attachServer(this, this.url);
                        if (!me) throw this.dispatchEvent(at({
                            type: "error"
                        })), new Error("A mock server is already listening on this url");
                        this.options = Object.assign({}, ce, R), this.options.mock && this.mockWebsocket()
                    }
                    return D && (P.__proto__ = D), P.prototype = Object.create(D && D.prototype), P.prototype.constructor = P, P.prototype.mockWebsocket = function() {
                        var R = pe();
                        this.originalWebSocket = R.WebSocket, R.WebSocket = re
                    }, P.prototype.restoreWebsocket = function() {
                        var R = pe();
                        this.originalWebSocket !== null && (R.WebSocket = this.originalWebSocket), this.originalWebSocket = null
                    }, P.prototype.stop = function(R) {
                        R === void 0 && (R = function() {}), this.options.mock && this.restoreWebsocket(), Ae.removeServer(this.url), typeof R == "function" && R()
                    }, P.prototype.on = function(R, K) {
                        this.addEventListener(R, K)
                    }, P.prototype.close = function(R) {
                        R === void 0 && (R = {});
                        var K = R.code,
                            me = R.reason,
                            Ee = R.wasClean,
                            Ce = Ae.websocketsLookup(this.url);
                        Ae.removeServer(this.url), Ce.forEach(function(De) {
                            De.readyState = re.CLOSED, De.dispatchEvent(rt({
                                type: "close",
                                target: De.target,
                                code: K || we.CLOSE_NORMAL,
                                reason: me || "",
                                wasClean: Ee
                            }))
                        }), this.dispatchEvent(rt({
                            type: "close"
                        }), this)
                    }, P.prototype.emit = function(R, K, me) {
                        var Ee = this;
                        me === void 0 && (me = {});
                        var Ce = me.websockets;
                        Ce || (Ce = Ae.websocketsLookup(this.url)), typeof me != "object" || arguments.length > 3 ? (K = Array.prototype.slice.call(arguments, 1, arguments.length), K = K.map(function(De) {
                            return U(De)
                        })) : K = U(K), Ce.forEach(function(De) {
                            Array.isArray(K) ? De.dispatchEvent.apply(De, [ke({
                                type: R,
                                data: K,
                                origin: Ee.url,
                                target: De.target
                            })].concat(K)) : De.dispatchEvent(ke({
                                type: R,
                                data: K,
                                origin: Ee.url,
                                target: De.target
                            }))
                        })
                    }, P.prototype.clients = function() {
                        return Ae.websocketsLookup(this.url)
                    }, P.prototype.to = function(R, K, me) {
                        var Ee = this;
                        me === void 0 && (me = []);
                        var Ce = this,
                            De = ue(me.concat(Ae.websocketsLookup(this.url, R, K)));
                        return {
                            to: function(hn, Nr) {
                                return Ee.to.call(Ee, hn, Nr, De)
                            },
                            emit: function(Nr, Ze) {
                                Ce.emit(Nr, Ze, {
                                    websockets: De
                                })
                            }
                        }
                    }, P.prototype.in = function() {
                        for (var R = [], K = arguments.length; K--;) R[K] = arguments[K];
                        return this.to.apply(null, R)
                    }, P.prototype.simulate = function(R) {
                        var K = Ae.websocketsLookup(this.url);
                        R === "error" && K.forEach(function(me) {
                            me.readyState = re.CLOSED, me.dispatchEvent(at({
                                type: "error"
                            }))
                        })
                    }, P
                }(he);
            J.of = function(P) {
                return new J(P)
            };
            var ne = function(D) {
                function P(R, K) {
                    var me = this;
                    R === void 0 && (R = "socket.io"), K === void 0 && (K = ""), D.call(this), this.binaryType = "blob";
                    var Ee = new Z(R);
                    Ee.pathname || (Ee.pathname = "/"), this.url = Ee.toString(), this.readyState = P.CONNECTING, this.protocol = "", this.target = this, typeof K == "string" || typeof K == "object" && K !== null ? this.protocol = K : Array.isArray(K) && K.length > 0 && (this.protocol = K[0]);
                    var Ce = Ae.attachWebSocket(this, this.url);
                    de(function() {
                        Ce ? (this.readyState = P.OPEN, Ce.dispatchEvent(at({
                            type: "connection"
                        }), Ce, this), Ce.dispatchEvent(at({
                            type: "connect"
                        }), Ce, this), this.dispatchEvent(at({
                            type: "connect",
                            target: this
                        }))) : (this.readyState = P.CLOSED, this.dispatchEvent(at({
                            type: "error",
                            target: this
                        })), this.dispatchEvent(rt({
                            type: "close",
                            target: this,
                            code: we.CLOSE_NORMAL
                        })), q("error", "Socket.io connection to '" + this.url + "' failed"))
                    }, this), this.addEventListener("close", function(De) {
                        me.dispatchEvent(rt({
                            type: "disconnect",
                            target: De.target,
                            code: De.code
                        }))
                    })
                }
                D && (P.__proto__ = D), P.prototype = Object.create(D && D.prototype), P.prototype.constructor = P;
                var z = {
                    broadcast: {}
                };
                return P.prototype.close = function() {
                    if (this.readyState === P.OPEN) {
                        var K = Ae.serverLookup(this.url);
                        return Ae.removeWebSocket(this, this.url), this.readyState = P.CLOSED, this.dispatchEvent(rt({
                            type: "close",
                            target: this,
                            code: we.CLOSE_NORMAL
                        })), K && K.dispatchEvent(rt({
                            type: "disconnect",
                            target: this,
                            code: we.CLOSE_NORMAL
                        }), K), this
                    }
                }, P.prototype.disconnect = function() {
                    return this.close()
                }, P.prototype.emit = function(K) {
                    for (var me = [], Ee = arguments.length - 1; Ee-- > 0;) me[Ee] = arguments[Ee + 1];
                    if (this.readyState !== P.OPEN) throw new Error("SocketIO is already in CLOSING or CLOSED state");
                    var Ce = ke({
                            type: K,
                            origin: this.url,
                            data: me
                        }),
                        De = Ae.serverLookup(this.url);
                    return De && De.dispatchEvent.apply(De, [Ce].concat(me)), this
                }, P.prototype.send = function(K) {
                    return this.emit("message", K), this
                }, z.broadcast.get = function() {
                    if (this.readyState !== P.OPEN) throw new Error("SocketIO is already in CLOSING or CLOSED state");
                    var R = this,
                        K = Ae.serverLookup(this.url);
                    if (!K) throw new Error("SocketIO can not find a server at the specified URL (" + this.url + ")");
                    return {
                        emit: function(Ee, Ce) {
                            return K.emit(Ee, Ce, {
                                websockets: Ae.websocketsLookup(R.url, null, R)
                            }), R
                        },
                        to: function(Ee) {
                            return K.to(Ee, R)
                        },
                        in: function(Ee) {
                            return K.in(Ee, R)
                        }
                    }
                }, P.prototype.on = function(K, me) {
                    return this.addEventListener(K, me), this
                }, P.prototype.off = function(K, me) {
                    this.removeEventListener(K, me)
                }, P.prototype.hasListeners = function(K) {
                    var me = this.listeners[K];
                    return Array.isArray(me) ? !!me.length : !1
                }, P.prototype.join = function(K) {
                    Ae.addMembershipToRoom(this, K)
                }, P.prototype.leave = function(K) {
                    Ae.removeMembershipFromRoom(this, K)
                }, P.prototype.to = function(K) {
                    return this.broadcast.to(K)
                }, P.prototype.in = function() {
                    return this.to.apply(null, arguments)
                }, P.prototype.dispatchEvent = function(K) {
                    for (var me = this, Ee = [], Ce = arguments.length - 1; Ce-- > 0;) Ee[Ce] = arguments[Ce + 1];
                    var De = K.type,
                        hn = this.listeners[De];
                    if (!Array.isArray(hn)) return !1;
                    hn.forEach(function(Nr) {
                        Ee.length > 0 ? Nr.apply(me, Ee) : Nr.call(me, K.data ? K.data : K)
                    })
                }, Object.defineProperties(P.prototype, z), P
            }(he);
            ne.CONNECTING = 0, ne.OPEN = 1, ne.CLOSING = 2, ne.CLOSED = 3;
            var Ne = function(P, z) {
                return new ne(P, z)
            };
            Ne.connect = function(P, z) {
                return Ne(P, z)
            };
            var Pe = J,
                ze = re,
                ft = Ne;
            n.Server = Pe, n.WebSocket = ze, n.SocketIO = ft, Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    })(bS, bS.exports);
    var sK = {
        exports: {}
    };
    (function(t) {
        (function() {
            function e(c, u) {
                var h = c.x - u.x,
                    d = c.y - u.y;
                return h * h + d * d
            }

            function n(c, u, h) {
                var d = u.x,
                    p = u.y,
                    m = h.x - d,
                    _ = h.y - p;
                if (m !== 0 || _ !== 0) {
                    var y = ((c.x - d) * m + (c.y - p) * _) / (m * m + _ * _);
                    y > 1 ? (d = h.x, p = h.y) : y > 0 && (d += m * y, p += _ * y)
                }
                return m = c.x - d, _ = c.y - p, m * m + _ * _
            }

            function r(c, u) {
                for (var h = c[0], d = [h], p, m = 1, _ = c.length; m < _; m++) p = c[m], e(p, h) > u && (d.push(p), h = p);
                return h !== p && d.push(p), d
            }

            function s(c, u, h, d, p) {
                for (var m = d, _, y = u + 1; y < h; y++) {
                    var v = n(c[y], c[u], c[h]);
                    v > m && (_ = y, m = v)
                }
                m > d && (_ - u > 1 && s(c, u, _, d, p), p.push(c[_]), h - _ > 1 && s(c, _, h, d, p))
            }

            function i(c, u) {
                var h = c.length - 1,
                    d = [c[0]];
                return s(c, 0, h, u, d), d.push(c[h]), d
            }

            function a(c, u, h) {
                if (c.length <= 2) return c;
                var d = u !== void 0 ? u * u : 1;
                return c = h ? c : r(c, d), c = i(c, d), c
            }
            t.exports = a, t.exports.default = a
        })()
    })(sK);
    class ES {
        static getPromptGuess(e, n) {
            var r, s, i;
            if ((r = e.player) != null && r.prompt) return e.player.prompt;
            if ((s = e.audience) != null && s.prompt) return e.audience.prompt;
            if ((i = e.audiencePlayer) != null && i.prompt) return e.audiencePlayer.prompt;
            if (e.prompt) return e.prompt;
            if (n === "range-game") return this.getRangeGameGuess(e)
        }
        static getRangeGameGuess(e) {
            var n, r, s, i, a, c, u, h;
            if ((r = (n = e.player) == null ? void 0 : n.content) != null && r.text) return (i = (s = e.player) == null ? void 0 : s.content) == null ? void 0 : i.text;
            if ((c = (a = e.content) == null ? void 0 : a.content) != null && c.text) return (h = (u = e.content) == null ? void 0 : u.content) == null ? void 0 : h.text
        }
        static async send(e) {
            const n = {
                appTag: e.room.appTag,
                state: {
                    appTag: e.room.appTag,
                    name: e.name,
                    role: e.role,
                    code: e.room.code,
                    message: e.message,
                    vibe: e.vibe,
                    state: e.values
                }
            };
            try {
                const r = await this.sendToEcast(n);
                await this.sendToSlack(r, e)
            } catch (r) {
                console.error(r)
            }
        }
        static async sendToEcast(e) {
            return (await (await fetch("https://ecast.jackboxgames.com/api/v2/controller/state", {
                method: "POST",
                body: JSON.stringify(e)
            })).json()).body.url
        }
        static async sendToSlack(e, n) {
            const r = b1(n.room.appTag),
                s = "https://hooks.slack.com/services/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",
                i = {
                    good: ":large_green_circle:",
                    meh: ":large_yellow_circle:",
                    bad: ":red_circle:"
                },
                c = `${(r==null?void 0:r.name)??n.room.appTag} :${n.room.appTag}: 

 From: ${n.name},
${n.message}`,
                u = [];
            n.vibe && n.vibe !== "none" && u.push({
                type: "plain_text",
                text: `${i[n.vibe]} ${n.vibe.toUpperCase()} Vibes`,
                emoji: !0
            }), n.content && u.push({
                type: "plain_text",
                text: `Content: ${n.content}`,
                emoji: !0
            });
            const d = {
                blocks: [{
                    type: "section",
                    text: {
                        type: "mrkdwn",
                        text: c
                    }
                }, {
                    type: "context",
                    elements: u
                }, {
                    type: "actions",
                    elements: [{
                        type: "button",
                        action_id: "actionId-0",
                        url: e,
                        text: {
                            type: "plain_text",
                            text: "View Game State JSON",
                            emoji: !0
                        }
                    }]
                }]
            };
            try {
                const m = await (await fetch(s, {
                    method: "POST",
                    body: JSON.stringify(d)
                })).text();
                E1("[Feedback] sendToSlack", m)
            } catch (p) {
                console.error("[Feedback] sendToSlack", p)
            }
        }
    }
    const fc = class fc {
        constructor(e, n) {
            Se(this, "activePointers", new Map);
            Se(this, "element");
            Se(this, "documentElement");
            Se(this, "usePointerEvents");
            Se(this, "isCanceled", !1);
            Se(this, "cachedElementRect");
            Se(this, "cachedDocumentRect");
            Se(this, "cachedTranslations");
            Se(this, "isMultitouch");
            Se(this, "isRestrictedToBox");
            Se(this, "swipeVelocity");
            Se(this, "swipeDistance");
            Se(this, "boundOnClick", this.onClick.bind(this));
            Se(this, "boundOnStart", this.onStart.bind(this));
            Se(this, "boundOnMove", this.onMove.bind(this));
            Se(this, "boundOnEnd", this.onEnd.bind(this));
            this.applyPolyfill(), this.element = e, this.documentElement = document.documentElement, this.usePointerEvents = window.PointerEvent !== void 0, this.isRestrictedToBox = n.restrictToBox, this.isMultitouch = n.isMultitouch ?? !1, this.swipeDistance = n.swipeDistance ?? 30, this.swipeVelocity = n.swipeVelocity ?? .5, this.bindStaticEvents()
        }
        destroy() {
            this.unbindStaticEvents(), this.unbindStartedEvents()
        }
        cancel() {
            this.isCanceled = !0, this.unbindStartedEvents()
        }
        isPointerEvent(e) {
            return window.PointerEvent === void 0 ? !1 : e instanceof PointerEvent
        }
        isTouchEvent(e) {
            return "ontouchstart" in window ? e instanceof TouchEvent : !1
        }
        isMouseEvent(e) {
            return e instanceof MouseEvent
        }
        getTouchById(e, n) {
            return Array.from(e).find(r => r.identifier === n)
        }
        bindStaticEvents() {
            if (this.element.addEventListener("click", this.boundOnClick), this.usePointerEvents) {
                this.element.addEventListener("pointerdown", this.boundOnStart);
                return
            }
            this.element.addEventListener("touchstart", this.boundOnStart), this.element.addEventListener("mousedown", this.boundOnStart)
        }
        unbindStaticEvents() {
            if (this.element.removeEventListener("click", this.boundOnClick), this.usePointerEvents) {
                this.element.removeEventListener("pointerdown", this.boundOnStart);
                return
            }
            this.element.removeEventListener("touchstart", this.boundOnStart), this.element.removeEventListener("mousedown", this.boundOnStart)
        }
        bindStartedEvents() {
            if (this.usePointerEvents) {
                this.element.addEventListener("pointermove", this.boundOnMove), this.element.addEventListener("pointerup", this.boundOnEnd), this.isRestrictedToBox && this.element.addEventListener("pointerleave", this.boundOnEnd), this.element.addEventListener("lostpointercapture", this.boundOnEnd), this.disableChildPointerEvents();
                return
            }
            this.element.addEventListener("touchmove", this.boundOnMove), this.element.addEventListener("mousemove", this.boundOnMove), this.element.addEventListener("touchend", this.boundOnEnd), this.element.addEventListener("mouseleave", this.boundOnEnd), this.element.addEventListener("mouseup", this.boundOnEnd)
        }
        unbindStartedEvents() {
            if (this.usePointerEvents) {
                this.element.removeEventListener("pointermove", this.boundOnMove), this.element.removeEventListener("pointerup", this.boundOnEnd), this.isRestrictedToBox && this.element.removeEventListener("pointerleave", this.boundOnEnd), this.element.removeEventListener("lostpointercapture", this.boundOnEnd), this.enableChildPointerEvents();
                return
            }
            this.element.removeEventListener("touchmove", this.boundOnMove), this.element.removeEventListener("mousemove", this.boundOnMove), this.element.removeEventListener("touchend", this.boundOnEnd), this.element.removeEventListener("mouseleave", this.boundOnEnd), this.element.removeEventListener("mouseup", this.boundOnEnd)
        }
        onClick(e) {
            const n = this.getStartDetail(e, {
                    id: 0,
                    type: "click"
                }),
                r = new CustomEvent("pointerbox:click", {
                    detail: n
                });
            this.element.dispatchEvent(r)
        }
        onStart(e) {
            if (e.preventDefault(), this.isCanceled = !1, !this.isMultitouch && this.activePointers.size) return !1;
            if (this.isPointerEvent(e)) return this.processStartEvent(e, {
                id: e.pointerId,
                type: e.pointerType
            }), !1;
            if (this.isTouchEvent(e)) {
                for (let n = 0; n < e.targetTouches.length; n++) {
                    const r = e.targetTouches.item(n);
                    this.processStartEvent(e, {
                        id: r.identifier,
                        type: "touch"
                    }, r)
                }
                return !1
            }
            return this.processStartEvent(e, {
                id: 0,
                type: "mouse"
            }), !1
        }
        processStartEvent(e, n, r) {
            if (this.activePointers.get(n.id)) return;
            const s = this.getStartDetail(e, n, r),
                i = {
                    id: n.id,
                    type: n.type,
                    distanceAccumulator: 0,
                    velocityValues: [0],
                    children: document.elementsFromPoint(s.clientX, s.clientY),
                    previousEventTimestamp: Date.now(),
                    initial: s,
                    previous: s
                };
            this.activePointers.set(n.id, i);
            const a = new CustomEvent("pointerbox:start", {
                detail: s
            });
            this.element.dispatchEvent(a);
            const c = new CustomEvent("pointerbox:childdown", {
                detail: s
            });
            i.children.forEach(u => u.dispatchEvent(c)), this.bindStartedEvents()
        }
        onMove(e) {
            if (e.preventDefault(), !this.isCanceled) {
                if (this.isPointerEvent(e)) return this.processMoveEvent(e, {
                    id: e.pointerId,
                    type: e.pointerType
                }), !1;
                if (this.isTouchEvent(e)) {
                    for (let n = 0; n < e.changedTouches.length; n++) {
                        const r = e.targetTouches.item(n);
                        this.processMoveEvent(e, {
                            id: r.identifier,
                            type: "touch"
                        }, r)
                    }
                    return !1
                }
                return this.processMoveEvent(e, {
                    id: 0,
                    type: "mouse"
                }), !1
            }
        }
        processMoveEvent(e, n, r) {
            const s = this.activePointers.get(n.id);
            if (!s) return !1;
            const i = this.getMoveDetail(e, s, r);
            s.previous = i, s.previousEventTimestamp = Date.now();
            const a = new CustomEvent("pointerbox:move", {
                detail: i
            });
            return this.element.dispatchEvent(a), !1
        }
        onEnd(e) {
            if (e.preventDefault(), !this.isCanceled) return this.isPointerEvent(e) ? (this.processEndEvent(e, {
                id: e.pointerId,
                type: e.pointerType
            }), !1) : this.isTouchEvent(e) ? (this.activePointers.forEach((n, r) => {
                if (this.getTouchById(e.touches, r)) return;
                const s = this.getTouchById(n.previous.originalEvent.touches, r);
                if (!s) throw new Error("[PointerBox] No previous details stored");
                this.processEndEvent(e, {
                    id: r,
                    type: n.type
                }, s)
            }), !1) : (this.processEndEvent(e, {
                id: 0,
                type: "mouse"
            }), !1)
        }
        processEndEvent(e, n, r) {
            const s = this.activePointers.get(n.id);
            if (!s) return !1;
            const i = this.getMoveDetail(e, s, r),
                a = new CustomEvent("pointerbox:end", {
                    detail: i
                });
            this.element.dispatchEvent(a), this.checkForSwipe(a), this.activePointers.delete(s.id), this.activePointers.size || (delete this.cachedElementRect, delete this.cachedDocumentRect, delete this.cachedTranslations, this.unbindStartedEvents());
            const c = new CustomEvent("pointerbox:childup", {
                detail: i
            });
            return document.elementsFromPoint(i.clientX, i.clientY).forEach(h => {
                if (h.dispatchEvent(c), !s.children.includes(h)) return;
                const d = new CustomEvent("pointerbox:childclick", {
                    detail: i
                });
                h.dispatchEvent(d)
            }), !1
        }
        checkForSwipe(e) {
            const n = e.detail;
            if (n.distanceFromInitial < this.swipeDistance || n.previous.normalizedVelocity < this.swipeVelocity) return;
            const r = n.degreesFromInitial;
            r > 45 && r < 135 ? n.direction = "up" : r > 135 && r < 225 ? n.direction = "left" : r > 225 && r < 315 ? n.direction = "down" : n.direction = "right";
            const s = new CustomEvent("pointerbox:swipe", {
                    detail: n
                }),
                i = new CustomEvent(`pointerbox:swipe${n.direction}`, {
                    detail: n
                });
            this.element.dispatchEvent(s), this.element.dispatchEvent(i)
        }
        getStartDetail(e, n, r) {
            let s, i, a, c;
            this.cachedElementRect || (this.cachedElementRect = this.element.getBoundingClientRect()), this.cachedDocumentRect || (this.cachedDocumentRect = this.documentElement.getBoundingClientRect());
            const u = this.cachedDocumentRect.top;
            this.cachedTranslations || (this.cachedTranslations = this.getTranslations()), r ? (s = r.pageX, i = r.pageY + u, a = r.clientX, c = r.clientY) : (s = e.pageX, i = e.pageY + u, a = e.clientX, c = e.clientY);
            const h = s - this.cachedElementRect.left,
                d = i - this.cachedElementRect.top,
                p = h / this.cachedElementRect.width,
                m = d / this.cachedElementRect.height,
                _ = p < 0 || p > 1 || m < 0 || m > 1,
                y = {};
            return this.cachedTranslations.forEach(v => {
                y[v.id] && console.warn(`[PointerBox] duplicate translation key ${v.id}`), y[v.id] = {
                    x: h * v.x - v.left,
                    y: d * v.y - v.top
                }
            }), {
                id: n.id,
                type: n.type,
                boxX: h,
                boxY: d,
                pageX: s,
                pageY: i,
                clientX: a,
                clientY: c,
                percentX: p,
                percentY: m,
                translations: y,
                isOutsideBox: _,
                originalEvent: e,
                cancel: () => this.cancel()
            }
        }
        getMoveDetail(e, n, r) {
            if (!n.initial) throw new Error("[PointerBox] No initial details stored");
            if (!n.previous) throw new Error("[PointerBox] No previous details stored");
            const s = this.getStartDetail(e, {
                    id: n.id,
                    type: n.type
                }, r),
                i = vs.getAngleBetweenPoints({
                    x: n.initial.boxX,
                    y: n.initial.boxY
                }, {
                    x: s.boxX,
                    y: s.boxY
                }),
                a = vs.getDistanceBetweenPoints({
                    x: n.initial.boxX,
                    y: n.initial.boxY
                }, {
                    x: s.boxX,
                    y: s.boxY
                }),
                c = vs.getAngleBetweenPoints({
                    x: n.previous.boxX,
                    y: n.previous.boxY
                }, {
                    x: s.boxX,
                    y: s.boxY
                }),
                u = vs.getDistanceBetweenPoints({
                    x: n.previous.boxX,
                    y: n.previous.boxY
                }, {
                    x: s.boxX,
                    y: s.boxY
                });
            n.distanceAccumulator += u;
            let h = 0;
            return n.previousEventTimestamp && (h = vs.getVelocity({
                x: n.previous.boxX,
                y: n.previous.boxY
            }, n.previousEventTimestamp, {
                x: s.boxX,
                y: s.boxY
            }, Date.now())), h && (n.velocityValues.unshift(h), n.velocityValues.length = Math.min(n.velocityValues.length, 5)), {
                id: s.id,
                type: s.type,
                boxX: s.boxX,
                boxY: s.boxY,
                pageX: s.pageX,
                pageY: s.pageY,
                clientX: s.clientX,
                clientY: s.clientY,
                percentX: s.percentX,
                percentY: s.percentY,
                translations: s.translations,
                isOutsideBox: s.isOutsideBox,
                degreesFromInitial: i,
                distanceFromInitial: a,
                changeXFromInitial: s.boxX - n.initial.boxX,
                changeYFromInitial: s.boxY - n.initial.boxY,
                degreesFromPrevious: c,
                distancefromPrevious: u,
                changeXFromPrevious: s.boxX - n.previous.boxX,
                changeYFromPrevious: s.boxY - n.previous.boxY,
                totalDistance: n.distanceAccumulator,
                velocity: h,
                normalizedVelocity: n.velocityValues.reduce((d, p) => d + p) / n.velocityValues.length,
                originalEvent: s.originalEvent,
                initial: n.initial,
                previous: n.previous,
                cancel: s.cancel
            }
        }
        getTranslations() {
            if (!this.cachedElementRect) throw Error("[PointerBox] Element rect is undefined");
            const e = [],
                n = this.element.children;
            for (let r = 0; r < n.length; r++) {
                const s = n[r].attributes.getNamedItem("data-pointerboxtranslateid");
                if (!s) continue;
                const i = s.value;
                if (!i) continue;
                const a = n[r].attributes.getNamedItem("data-pointerboxtranslatewidth"),
                    c = n[r].attributes.getNamedItem("data-pointerboxtranslateheight"),
                    u = a != null && a.value ? parseInt(a.value, 10) : this.cachedElementRect.width,
                    h = c != null && c.value ? parseInt(c.value, 10) : this.cachedElementRect.height,
                    d = n[r].getBoundingClientRect();
                e.push({
                    id: i,
                    left: d.left - this.cachedElementRect.left,
                    top: d.top - this.cachedElementRect.top,
                    x: u / d.width,
                    y: h / d.height
                })
            }
            return e
        }
        disableChildPointerEvents() {
            this.element.style.touchAction = "none";
            for (let e = 0; e < this.element.children.length; e++) {
                const n = this.element.children[e];
                n.style.pointerEvents = "none", n.style.touchAction = "none"
            }
        }
        enableChildPointerEvents() {
            this.element.style.touchAction = "";
            for (let e = 0; e < this.element.children.length; e++) {
                const n = this.element.children[e];
                n.style.pointerEvents = "", n.style.touchAction = ""
            }
        }
        applyPolyfill() {
            fc.isPolyfilled || (fc.isPolyfilled = !0, window && window.document && (window.document.elementsFromPoint || (window.document.elementsFromPoint = fc.elementsFromPoint)))
        }
        static elementsFromPoint(e, n) {
            const r = [],
                s = [];
            let i = null;
            do {
                const a = window.document.elementFromPoint(e, n);
                i !== a ? (i = a, r.push(i), s.push(i.style.pointerEvents), i.style.pointerEvents = "none") : i = null
            } while (i);
            return r.forEach((a, c) => {
                a.style.pointerEvents = s[c]
            }), r
        }
    };
    Se(fc, "isPolyfilled", !1);
    let T1 = fc;
    const iK = {
            BACK: "Back",
            CANCEL: "Cancel",
            CLOSE: "Close",
            CONFIRM: "Confirm",
            CREATE: "Create",
            DELETE: "Delete",
            DONE: "Done",
            EDIT: "Edit",
            OK: "OK",
            NEXT: "Next",
            NO: "No",
            PLAY: "Play",
            PUBLISH: "Publish",
            REMOVE: "Remove",
            RESET: "Reset",
            SUBMIT: "Submit",
            TRY_AGAIN: "Try Again",
            UNDO: "Undo",
            YES: "Yes"
        },
        oK = {
            UGC: {
                VISIBILITY_CONTROLLER_OFF: "prompts hidden on players devices",
                VISIBILITY_CONTROLLER_ON: "prompts shown on players devices",
                VISIBILITY_SCREEN_OFF: "prompts hidden on game screen",
                VISIBILITY_SCREEN_ON: "prompts shown on game screen"
            }
        },
        aK = {
            DISCONNECTED: "You have been disconnected.",
            DRAWING_NOTHING: "You have to draw something!",
            PLAYER_KICKED: "You have been kicked from the game by a moderator.",
            ROOM_DESTROYED: "Thanks for playing!",
            ROOM_DISCONNECTED: "Disconnected",
            TEXT_NAUGHTY: "Im afraid you cant write that. Please be respectful of other players.",
            TEXT_NOTHING: "You cant enter nothing!",
            TITLE: "Error"
        },
        cK = "LOADING",
        lK = {
            JOINED_COUNT: "{count} of {maxPlayers} players joined",
            PLAYERS_NEEDED: "1 player needed to start | {count} players needed to start",
            WAITING_FOR_VIP: "Waiting for {name} to start the game",
            WAITING_FOR_GAMEPAD: "Waiting for the game to start",
            GAME_STARTING: "Game is starting",
            BUTTON_START: "Press to Start",
            BUTTON_CANCEL: "Press to Cancel"
        },
        uK = {
            GALLERY_LINK: "Visit the Gallery",
            PLAY_AGAIN: "Play again?",
            BUTTON_SAME_PLAYERS: "Same Players",
            BUTTON_NEW_PLAYERS: "New Players"
        },
        hK = {
            AND: "AND",
            OR: "OR"
        },
        fK = {
            BUTTON_SKIP: "Skip",
            BUTTON_NEXT: "Next",
            BUTTON_DONE: "Lets Go!"
        },
        dK = {
            NAME: "AUDIENCE"
        },
        pK = {
            EPISODE_REPORT: "Report Episode",
            EPISODE_UNLOAD: "Unload Episode",
            EPISODE_VIEW_AUTHOR: "View Author",
            EPISODES_LOAD: "Load an episode by id:",
            EPISODES_MENU: "Episodes Menu",
            EPISODES_SELECT: "Or select an epsiode:",
            EPISODES_WARNING: "Warning: user generated content is not rated",
            INSTRUCTION: {
                CREATE_TITLE: "first things first, enter a name for the episode that will contain all your prompts and hit create.",
                LOAD: "create or load?",
                PUBLISH: "publish your episode",
                TITLE: "name your episode",
                TOGGLE_VISIBILITY: "tap to show/hide prompts",
                WRITE: "write your prompts"
            },
            WARNING: {
                DELETE: "Are you sure you want to delete this episode?",
                TOS: "By sharing content, you agree to our [tos]Terms of Service[/tos]",
                TOS_AGREE: "agree and share"
            },
            BACK_TO_EPISODES: "back to episodes",
            BACK_TO_MENU: "back to menu",
            CREATE_NEW_EPISODE: "create a new episode",
            PREVIOUS_EPISODES: "previous episodes",
            PROMPT_ADD: "add prompt",
            PROMPT_PLACEHOLDER: "enter a prompt",
            PROMPTS_COUNT_HIDDEN: "({count} hidden)",
            TITLE_PLACEHOLDER: "enter a title"
        },
        mK = {
            BROADCASTER: {
                SUBTEXT: "You have successfully connected your account to the Jackbox Audience Kit Twitch Extension.",
                WARNING: "THIS ROOM DOESN'T HAVE THE AUDIENCE SETTING ENABLED"
            },
            RECONNECTED: {
                TEXT: "RECONNECTED",
                SUBTEXT: "Have fun!"
            },
            RECONNECTING: {
                CONTROLLER: {
                    TEXT: "CONNECTION INTERRUPTED",
                    SUBTEXT: "Attempting to reconnect ({attempt} of 5)"
                },
                GAME: {
                    TEXT: "GAME CONNECTION INTERRUPTED",
                    SUBTEXT: "Please wait while we attempt to reconnect"
                }
            },
            PAUSED: {
                TEXT: "THE GAME IS PAUSED",
                SUBTEXT: "Anything you submit will still be sent to the game."
            }
        },
        gK = {
            ACTION: iK,
            ALT: oK,
            ERROR: aK,
            LOADING: cK,
            LOBBY: lK,
            POST_GAME: uK,
            SEPARATOR: hK,
            TUTORIAL: fK,
            AUDIENCE: dK,
            UGC: pK,
            TOAST: mK
        },
        _K = {
            BACK: "Retour",
            CANCEL: "Annuler",
            CLOSE: "Fermer",
            CONFIRM: "Confirmer",
            CREATE: "Crer",
            DELETE: "Supprimer",
            DONE: "Termin",
            EDIT: "Modifier",
            OK: "OK",
            NEXT: "Suivant",
            NO: "Non",
            PLAY: "Jouer",
            PUBLISH: "Publier",
            REMOVE: "Supprimer",
            RESET: "Rinitialiser",
            SUBMIT: "Envoyer",
            TRY_AGAIN: "Ressayer",
            UNDO: "Annuler",
            YES: "Oui"
        },
        yK = {
            UGC: {
                VISIBILITY_CONTROLLER_OFF: "sujets non affichs sur les appareils des joueurs",
                VISIBILITY_CONTROLLER_ON: "sujets affichs sur les appareils des joueurs",
                VISIBILITY_SCREEN_OFF: "sujets non affichs sur l'cran de jeu",
                VISIBILITY_SCREEN_ON: "sujets affichs sur l'cran de jeu"
            }
        },
        vK = {
            DISCONNECTED: "Vous avez t dconnect(e).",
            DRAWING_NOTHING: "Vous devez dessiner quelque chose!",
            PLAYER_KICKED: "Vous avez t ject(e) de la partie par un modrateur.",
            ROOM_DESTROYED: "Merci d'avoir jou!",
            ROOM_DISCONNECTED: "Dconnexion",
            TEXT_NAUGHTY: "Je crains que vous ne puissiez pas crire a. Respectez les autres joueurs.",
            TEXT_NOTHING: "Vous ne pouvez pas ne rien entrer",
            TITLE: "Erreur"
        },
        bK = "CHARGEMENT",
        EK = {
            JOINED_COUNT: "{count} joueurs sur {maxPlayers} ont rejoint la partie",
            PLAYERS_NEEDED: "1joueur ncessaire pour commencer | {count}joueurs ncessaires pour commencer",
            WAITING_FOR_VIP: "En attente de {name} pour commencer la partie",
            WAITING_FOR_GAMEPAD: "En attente du dbut de la partie",
            GAME_STARTING: "La partie commence",
            BUTTON_START: "Appuyer pour commencer",
            BUTTON_CANCEL: "Appuyer pour annuler"
        },
        TK = {
            GALLERY_LINK: "Visiter la galerie",
            PLAY_AGAIN: "Rejouer?",
            BUTTON_SAME_PLAYERS: "Les mmes joueurs",
            BUTTON_NEW_PLAYERS: "De nouveaux joueurs"
        },
        SK = {
            AND: "ET",
            OR: "OU"
        },
        wK = {
            BUTTON_SKIP: "Passer",
            BUTTON_NEXT: "Suivant",
            BUTTON_DONE: "Allons-y!"
        },
        OK = {
            NAME: "SPECTATEURS"
        },
        AK = {
            EPISODE_REPORT: "Signaler l'pisode",
            EPISODE_UNLOAD: "Retirer l'pisode",
            EPISODE_VIEW_AUTHOR: "Voir l'auteur",
            EPISODES_LOAD: "Charger un pisode par id:",
            EPISODES_MENU: "Menu des pisodes",
            EPISODES_SELECT: "Ou slectionner un pisode:",
            EPISODES_WARNING: "Attention: le contenu gnr par les utilisateurs ne fait pas l'objet d'un classement",
            INSTRUCTION: {
                CREATE_TITLE: "commencez par donner un nom  l'pisode qui contiendra vos sujets, puis touchez crer.",
                LOAD: "crer ou charger?",
                PUBLISH: "publiez votre pisode",
                TITLE: "donnez un nom  votre pisode",
                TOGGLE_VISIBILITY: "touchez pour afficher/masquer les sujets",
                WRITE: "crivez vos sujets"
            },
            WARNING: {
                DELETE: "Voulez-vous vraiment supprimer cet pisode?",
                TOS: "En partageant votre contenu, vous acceptez nos [tos]Conditions de service[/tos]",
                TOS_AGREE: "accepter et partager"
            },
            BACK_TO_EPISODES: "retour aux pisodes",
            BACK_TO_MENU: "retour au menu",
            CREATE_NEW_EPISODE: "crer un nouvel pisode",
            PREVIOUS_EPISODES: "pisodes prcdents",
            PROMPT_ADD: "ajouter un sujet",
            PROMPT_PLACEHOLDER: "taper un sujet",
            PROMPTS_COUNT_HIDDEN: "({count} non affich)",
            TITLE_PLACEHOLDER: "taper un titre"
        },
        CK = {
            BROADCASTER: {
                SUBTEXT: "La connexion de votre compte  l'extension Twitch Jackbox Audience Kit a russi.",
                WARNING: "LE PARAMTRE 'PUBLIC' N'EST PAS ACTIV DANS CETTE SALLE."
            },
            RECONNECTED: {
                TEXT: "RECONNECT(E)",
                SUBTEXT: "Amusez-vous bien!"
            },
            RECONNECTING: {
                CONTROLLER: {
                    TEXT: "CONNEXION INTERROMPUE",
                    SUBTEXT: "Tentative de reconnexion ({attempt} sur 5)"
                },
                GAME: {
                    TEXT: "CONNEXION AU JEU INTERROMPUE",
                    SUBTEXT: "Veuillez patienter pendant que nous tentons de vous reconnecter."
                }
            }
        },
        kK = {
            ACTION: _K,
            ALT: yK,
            ERROR: vK,
            LOADING: bK,
            LOBBY: EK,
            POST_GAME: TK,
            SEPARATOR: SK,
            TUTORIAL: wK,
            AUDIENCE: OK,
            UGC: AK,
            TOAST: CK
        },
        IK = {
            BACK: "Indietro",
            CANCEL: "Annulla",
            CLOSE: "Chiuda",
            CONFIRM: "Conferma",
            CREATE: "Crea",
            DELETE: "Elimina",
            DONE: "Fine",
            EDIT: "Modifica",
            OK: "OK",
            NEXT: "Prossimo",
            NO: "No",
            PLAY: "Gioca",
            PUBLISH: "Pubblica",
            REMOVE: "Rimuovi",
            RESET: "Reset",
            SUBMIT: "Invia",
            TRY_AGAIN: "Riprova",
            UNDO: "Annulla",
            YES: "S"
        },
        NK = {
            UGC: {
                VISIBILITY_CONTROLLER_OFF: "definizioni nascoste sui dispositivi dei giocatori",
                VISIBILITY_CONTROLLER_ON: "definizioni visualizzate sui dispositivi dei giocatori",
                VISIBILITY_SCREEN_OFF: "definizioni nascoste sullo schermo di gioco",
                VISIBILITY_SCREEN_ON: "definizioni visualizzate sullo schermo di gioco"
            }
        },
        xK = {
            DISCONNECTED: " stata effettuata la disconnessione.",
            DRAWING_NOTHING: "Devi disegnare qualcosa!",
            PLAYER_KICKED: "Un moderatore ti ha cacciato dalla partita.",
            ROOM_DESTROYED: "Grazie per aver scelto di giocare con noi!",
            ROOM_DISCONNECTED: "Disconnessione effettuata",
            TEXT_NAUGHTY: "Purtroppo non puoi scrivere questa cosa. Abbi rispetto per gli altri giocatori.",
            TEXT_NOTHING: "Devi per forza inserire qualcosa!",
            TITLE: "Errore"
        },
        PK = "CARICAMENTO",
        RK = {
            JOINED_COUNT: "{count} su {maxPlayers} giocatori in partita",
            PLAYERS_NEEDED: "Manca 1 giocatore per iniziare | Mancano {count} giocatori per iniziare",
            WAITING_FOR_VIP: "In attesa di {name} per iniziare la partita",
            WAITING_FOR_GAMEPAD: "In attesa d'iniziare la partita",
            GAME_STARTING: "La partita sta per iniziare",
            BUTTON_START: "Premi per avviare",
            BUTTON_CANCEL: "Premi per annullare"
        },
        MK = {
            GALLERY_LINK: "Visita la galleria",
            PLAY_AGAIN: "Vuoi giocare di nuovo?",
            BUTTON_SAME_PLAYERS: "Stessi giocatori",
            BUTTON_NEW_PLAYERS: "Nuovi giocatori"
        },
        DK = {
            AND: "E",
            OR: "O"
        },
        $K = {
            BUTTON_SKIP: "Salta",
            BUTTON_NEXT: "Avanti",
            BUTTON_DONE: "Iniziamo!"
        },
        LK = {
            NAME: "PUBBLICO"
        },
        FK = {
            EPISODE_REPORT: "Segnala episodio",
            EPISODE_UNLOAD: "Rimuovi episodio",
            EPISODE_VIEW_AUTHOR: "Mostra autore",
            EPISODES_LOAD: "Carica un episodio in base al suo id:",
            EPISODES_MENU: "Menu Episodi",
            EPISODES_SELECT: "Oppure seleziona un episodio:",
            EPISODES_WARNING: "Attenzione: il contenuto generato dagli utenti non  classificato",
            INSTRUCTION: {
                CREATE_TITLE: "per prima cosa, inserisci un nome per lepisodio che contenga tutti i tuoi suggerimenti e premi crea.",
                LOAD: "creare o caricare?",
                PUBLISH: "pubblica il tuo episodio",
                TITLE: "dai un nome al tuo episodio",
                TOGGLE_VISIBILITY: "tocca per mostrare/nascondere suggerimenti",
                WRITE: "scrivi le tue definizioni"
            },
            WARNING: {
                DELETE: "Vuoi davvero eliminare questo episodio?",
                TOS: "Condividendo i contenuti, accetti le nostre [tos]Condizioni del servizio[/tos]",
                TOS_AGREE: "accetta e condividi"
            },
            BACK_TO_EPISODES: "torna agli episodi",
            BACK_TO_MENU: "torna al menu",
            CREATE_NEW_EPISODE: "crea un nuovo episodio",
            PREVIOUS_EPISODES: "episodi precedenti",
            PROMPT_ADD: "aggiungi suggerimento",
            PROMPT_PLACEHOLDER: "inserisci suggerimento",
            PROMPTS_COUNT_HIDDEN: "({count} nascosti)",
            TITLE_PLACEHOLDER: "inserisci un titolo"
        },
        UK = {
            BROADCASTER: {
                SUBTEXT: "Il collegamento del tuo account con l'estensione per Twitch Jackbox Audience Kit  andato a buon fine.",
                WARNING: "L'IMPOSTAZIONE DEL PUBBLICO NON  ATTIVA PER QUESTA STANZA"
            },
            RECONNECTED: {
                TEXT: "RICONNESSO",
                SUBTEXT: "Buon divertimento!"
            },
            RECONNECTING: {
                CONTROLLER: {
                    TEXT: "CONNESSIONE INTERROTTA",
                    SUBTEXT: "Tentativo di riconnessione in corso ({attempt} di 5)"
                },
                GAME: {
                    TEXT: "CONNESSIONE AL GIOCO INTERROTTA",
                    SUBTEXT: "Resta in attesa mentre proviamo a riconnetterci"
                }
            }
        },
        BK = {
            ACTION: IK,
            ALT: NK,
            ERROR: xK,
            LOADING: PK,
            LOBBY: RK,
            POST_GAME: MK,
            SEPARATOR: DK,
            TUTORIAL: $K,
            AUDIENCE: LK,
            UGC: FK,
            TOAST: UK
        },
        qK = {
            BACK: "Zurck",
            CANCEL: "Abbrechen",
            CLOSE: "Schlieen",
            CONFIRM: "Besttigen",
            CREATE: "Erstellen",
            DELETE: "Lschen",
            DONE: "Fertig",
            EDIT: "Bearbeiten",
            OK: "OK",
            NEXT: "Weiter",
            NO: "Nein",
            PLAY: "Spielen",
            PUBLISH: "Verffentlichen",
            REMOVE: "Entfernen",
            RESET: "Neu starten",
            SUBMIT: "Abschicken",
            TRY_AGAIN: "Erneut versuchen",
            UNDO: "Rckgngig",
            YES: "Ja"
        },
        jK = {
            UGC: {
                VISIBILITY_CONTROLLER_OFF: "Prompts auf Spielergerten verborgen",
                VISIBILITY_CONTROLLER_ON: "Prompts auf Spielergerten angezeigt",
                VISIBILITY_SCREEN_OFF: "Prompts auf Spielbildschirm verborgen",
                VISIBILITY_SCREEN_ON: "Prompts auf Spielbildschirm angezeigt"
            }
        },
        VK = {
            DISCONNECTED: "Deine Verbindung wurde getrennt.",
            DRAWING_NOTHING: "Du musst irgendwas zeichnen!",
            PLAYER_KICKED: "Du wurdest von einem Moderator gekickt.",
            ROOM_DESTROYED: "Danke frs Spielen!",
            ROOM_DISCONNECTED: "Verbindung getrennt",
            TEXT_NAUGHTY: "Das kannst du leider nicht schreiben. Bitte nimm Rcksicht auf deine Mitspieler.",
            TEXT_NOTHING: "Du musst etwas eingeben!",
            TITLE: "Fehler"
        },
        GK = "LADE",
        WK = {
            JOINED_COUNT: "{count} von {maxPlayers} Spielern sind beigetreten",
            PLAYERS_NEEDED: "1 Spieler zum Starten bentigt | {count} Spieler zum Starten bentigt",
            WAITING_FOR_VIP: "Warten, bis {name} das Spiel startet",
            WAITING_FOR_GAMEPAD: "Warten, bis das Spiel startet",
            GAME_STARTING: "Das Spiel beginnt",
            BUTTON_START: "Zum Starten drcken",
            BUTTON_CANCEL: "Zum Abbrechen drcken"
        },
        HK = {
            GALLERY_LINK: "Galerie besuchen",
            PLAY_AGAIN: "Erneut spielen?",
            BUTTON_SAME_PLAYERS: "Selbe Spieler",
            BUTTON_NEW_PLAYERS: "Neue Spieler"
        },
        KK = {
            AND: "UND",
            OR: "ODER"
        },
        YK = {
            BUTTON_SKIP: "berspringen",
            BUTTON_NEXT: "Weiter",
            BUTTON_DONE: "Los geht's!"
        },
        zK = {
            NAME: "PUBLIKUM"
        },
        ZK = {
            EPISODE_REPORT: "Episode melden",
            EPISODE_UNLOAD: "Episode deaktivieren",
            EPISODE_VIEW_AUTHOR: "Autor ansehen",
            EPISODES_LOAD: "Lade eine Episode ber dessen ID:",
            EPISODES_MENU: "Episoden-Men",
            EPISODES_SELECT: "Oder whle eine Episode aus:",
            EPISODES_WARNING: "Achtung: Von Nutzern erstellte Inhalte werden nicht auf Familientauglichkeit geprft",
            INSTRUCTION: {
                CREATE_TITLE: 'Benenne als allererstes deine Episode, die alle deine Prompts enthalten wird und drcke dann "Erstellen".',
                LOAD: "Erstellen oder laden?",
                PUBLISH: "Verffentliche deine Episode",
                TITLE: "Benenne deine Episode",
                TOGGLE_VISIBILITY: "Drcken, um Prompts zu zeigen / zu verstecken",
                WRITE: "Schreibe deine Prompts"
            },
            WARNING: {
                DELETE: "Bist du sicher, dass du diese Episode lschen mchtest?",
                TOS: "Durch das Teilen von Inhalten stimmst du unseren [tos]Nutzungsbedingungen[/tos] zu",
                TOS_AGREE: "Zustimmen und teilen"
            },
            BACK_TO_EPISODES: "Zurck zu den Episoden",
            BACK_TO_MENU: "Zurck zum Men",
            CREATE_NEW_EPISODE: "Eigene Episode erstellen",
            PREVIOUS_EPISODES: "Vorige Episoden",
            PROMPT_ADD: "Prompt hinzufgen",
            PROMPT_PLACEHOLDER: "Prompt eingeben",
            PROMPTS_COUNT_HIDDEN: "({count} versteckt)",
            TITLE_PLACEHOLDER: "Titel eingeben"
        },
        XK = {
            BROADCASTER: {
                SUBTEXT: "Du hast dein Konto erfolgreich mit der Jackbox Audience Kit Twitch-Erweiterung verknpft.",
                WARNING: "FR DIESEN RAUM IST DIE PUBLIKUMS-EINSTELLUNG NICHT AKTIV"
            },
            RECONNECTED: {
                TEXT: "NEU VERBUNDEN",
                SUBTEXT: "Viel Spa!"
            },
            RECONNECTING: {
                CONTROLLER: {
                    TEXT: "VERBINDUNG UNTERBROCHEN",
                    SUBTEXT: "Versuche neu zu verbinden ({attempt} von 5)"
                },
                GAME: {
                    TEXT: "VERBINDUNG ZUM SPIEL UNTERBROCHEN",
                    SUBTEXT: "Bitte warte whrend wir versuchen, die Verbindung wiederherzustellen."
                }
            }
        },
        JK = {
            ACTION: qK,
            ALT: jK,
            ERROR: VK,
            LOADING: GK,
            LOBBY: WK,
            POST_GAME: HK,
            SEPARATOR: KK,
            TUTORIAL: YK,
            AUDIENCE: zK,
            UGC: ZK,
            TOAST: XK
        },
        QK = {
            BACK: "Atrs",
            CANCEL: "Cancelar",
            CLOSE: "Cerrar",
            CONFIRM: "Confirmar",
            CREATE: "Crear",
            DELETE: "Borrar",
            DONE: "Hecho",
            EDIT: "Editar",
            OK: "Aceptar",
            NEXT: "Siguiente",
            NO: "No",
            PLAY: "Jugar",
            PUBLISH: "Publicar",
            REMOVE: "Eliminar",
            RESET: "Reiniciar",
            SUBMIT: "Enviar",
            TRY_AGAIN: "Volver a intentarlo",
            UNDO: "Deshacer",
            YES: "S"
        },
        eY = {
            UGC: {
                VISIBILITY_CONTROLLER_OFF: "los enunciados no se muestran en el dispositivo del jugador",
                VISIBILITY_CONTROLLER_ON: "los enunciados se muestran en el dispositivo del jugador",
                VISIBILITY_SCREEN_OFF: "los enunciados no se muestran en la pantalla",
                VISIBILITY_SCREEN_ON: "los enunciados se muestran en la pantalla"
            }
        },
        tY = {
            DISCONNECTED: "Te has desconectado.",
            DRAWING_NOTHING: "Tienes que dibujar algo!",
            PLAYER_KICKED: "Un moderador te ha expulsado de la partida.",
            ROOM_DESTROYED: "Gracias por jugar!",
            ROOM_DISCONNECTED: "Desconectado",
            TEXT_NAUGHTY: "Lo siento, no puedes escribir eso. Hay que ser respetuoso con los dems jugadores.",
            TEXT_NOTHING: "Tienes que escribir algo",
            TITLE: "Error"
        },
        nY = "CARGANDO",
        rY = {
            JOINED_COUNT: "Se han unido {count} de {maxPlayers} jugadores",
            PLAYERS_NEEDED: "Se necesita 1 jugador para empezar | Se necesitan {count} jugadores para empezar",
            WAITING_FOR_VIP: "Esperando a que {name} inicie la partida",
            WAITING_FOR_GAMEPAD: "Esperando a que empiece la partida",
            GAME_STARTING: "La partida va a empezar",
            BUTTON_START: "Pulsa para empezar",
            BUTTON_CANCEL: "Pulsa para cancelar"
        },
        sY = {
            GALLERY_LINK: "Visita la galera",
            PLAY_AGAIN: "Jugar otra vez?",
            BUTTON_SAME_PLAYERS: "Los mismos jugadores",
            BUTTON_NEW_PLAYERS: "Nuevos jugadores"
        },
        iY = {
            AND: "Y",
            OR: "O"
        },
        oY = {
            BUTTON_SKIP: "Omitir",
            BUTTON_NEXT: "Siguiente",
            BUTTON_DONE: "Vamos!"
        },
        aY = {
            NAME: "PBLICO"
        },
        cY = {
            EPISODE_REPORT: "Denunciar episodio",
            EPISODE_UNLOAD: "Retirar episodio",
            EPISODE_VIEW_AUTHOR: "Ver autor",
            EPISODES_LOAD: "Cargar un episodio por ID:",
            EPISODES_MENU: "Men de episodios",
            EPISODES_SELECT: "O selecciona un episodio:",
            EPISODES_WARNING: "Aviso: El contenido de los usuarios no tiene clasificacin de edad",
            INSTRUCTION: {
                CREATE_TITLE: "en primer lugar, ponle un nombre al episodio que contendr tus enunciados y dale a crear.",
                LOAD: "crear o cargar?",
                PUBLISH: "publica tu episodio",
                TITLE: "ponle nombre al episodio",
                TOGGLE_VISIBILITY: "toca para mostrar u ocultar los enunciados",
                WRITE: "escribe los enunciados"
            },
            WARNING: {
                DELETE: "Seguro que quieres borrar este episodio?",
                TOS: "Al compartir contenidos, aceptas las [tos]Condiciones del servicio[/tos]",
                TOS_AGREE: "aceptar y compartir"
            },
            BACK_TO_EPISODES: "volver a los episodios",
            BACK_TO_MENU: "volver al men",
            CREATE_NEW_EPISODE: "crear nuevo episodio",
            PREVIOUS_EPISODES: "episodios anteriores",
            PROMPT_ADD: "aadir enunciado",
            PROMPT_PLACEHOLDER: "escribe un enunciado",
            PROMPTS_COUNT_HIDDEN: "({count} ocultos)",
            TITLE_PLACEHOLDER: "escribe un ttulo"
        },
        lY = {
            BROADCASTER: {
                SUBTEXT: "Has conectado tu cuenta con xito a la extensin de Twitch del kit para pblico de Jackbox.",
                WARNING: "ESTA SALA NO TIENE LA FUNCIN DE PBLICO HABILITADA"
            },
            RECONNECTED: {
                TEXT: "CONEXIN RESTABLECIDA",
                SUBTEXT: "Divirtete!"
            },
            RECONNECTING: {
                CONTROLLER: {
                    TEXT: "SE HA INTERRUMPIDO LA CONEXIN",
                    SUBTEXT: "Recuperando conexin (intento {attempt} de 5)"
                },
                GAME: {
                    TEXT: "SE HA INTERRUMPIDO LA CONEXIN CON EL JUEGO",
                    SUBTEXT: "Espera mientras intentamos recuperar la conexin"
                }
            }
        },
        uY = {
            ACTION: QK,
            ALT: eY,
            ERROR: tY,
            LOADING: nY,
            LOBBY: rY,
            POST_GAME: sY,
            SEPARATOR: iY,
            TUTORIAL: oY,
            AUDIENCE: aY,
            UGC: cY,
            TOAST: lY
        },
        hY = {
            BACK: "Volver",
            CANCEL: "Cancelar",
            CLOSE: "Cerrar",
            CONFIRM: "Confirmar",
            CREATE: "Crear",
            DELETE: "Borrar",
            DONE: "Listo",
            EDIT: "Editar",
            OK: "Aceptar",
            NEXT: "Siguiente",
            NO: "No",
            PLAY: "Jugar",
            PUBLISH: "Publicar",
            REMOVE: "Quitar",
            RESET: "Reiniciar",
            SUBMIT: "Enviar",
            TRY_AGAIN: "Volver a intentarlo",
            UNDO: "Deshacer",
            YES: "S"
        },
        fY = {
            UGC: {
                VISIBILITY_CONTROLLER_OFF: "indicaciones ocultas en los dispositivos de los jugadores",
                VISIBILITY_CONTROLLER_ON: "indicaciones presentes en los dispositivos de los jugadores",
                VISIBILITY_SCREEN_OFF: "indicaciones ocultas en la pantalla del juego",
                VISIBILITY_SCREEN_ON: "indicaciones presentes en la pantalla del juego"
            }
        },
        dY = {
            DISCONNECTED: "Te desconectaste.",
            DRAWING_NOTHING: "Tienes que dibujar algo!",
            PLAYER_KICKED: "Un moderador te expuls del juego.",
            ROOM_DESTROYED: "Gracias por jugar!",
            ROOM_DISCONNECTED: "Desconectado",
            TEXT_NAUGHTY: "Lo siento, no puedes escribir eso. Seamos respetuosos con los dems jugadores.",
            TEXT_NOTHING: "Tienes que escribir algo!",
            TITLE: "Error"
        },
        pY = "CARGANDO",
        mY = {
            JOINED_COUNT: "{count} de {maxPlayers} jugadores se unieron",
            PLAYERS_NEEDED: "Se necesita 1 jugador para empezar | Se necesitan {count} jugadores para empezar",
            WAITING_FOR_VIP: "Esperando a que {name} inicie la partida",
            WAITING_FOR_GAMEPAD: "Esperando a que empiece la partida",
            GAME_STARTING: "La partida va a empezar",
            BUTTON_START: "Pulsa para empezar",
            BUTTON_CANCEL: "Pulsa para cancelar"
        },
        gY = {
            GALLERY_LINK: "Visita la galera",
            PLAY_AGAIN: "Jugar otra vez?",
            BUTTON_SAME_PLAYERS: "Los mismos jugadores",
            BUTTON_NEW_PLAYERS: "Nuevos jugadores"
        },
        _Y = {
            AND: "Y",
            OR: "O"
        },
        yY = {
            BUTTON_SKIP: "Omitir",
            BUTTON_NEXT: "Siguiente",
            BUTTON_DONE: "Vamos!"
        },
        vY = {
            NAME: "PBLICO"
        },
        bY = {
            EPISODE_REPORT: "Denunciar episodio",
            EPISODE_UNLOAD: "Descargar episodio",
            EPISODE_VIEW_AUTHOR: "Ver autor",
            EPISODES_LOAD: "Cargar un episodio por ID:",
            EPISODES_MENU: "Men de episodios",
            EPISODES_SELECT: "O selecciona un episodio:",
            EPISODES_WARNING: "Aviso: El contenido de los usuarios no tiene clasificacin por edades",
            INSTRUCTION: {
                CREATE_TITLE: "Lo primero que debes hacer es escribir un nombre para el episodio que contendr todas sus indicaciones y pulsar crear.",
                LOAD: "Crear o cargar?",
                PUBLISH: "Publica tu episodio",
                TITLE: "Nombra tu episodio",
                TOGGLE_VISIBILITY: "Pulsa para mostrar/ocultar las indicaciones",
                WRITE: "Escribe tus indicaciones"
            },
            WARNING: {
                DELETE: "De verdad quieres borrar este episodio?",
                TOS: "Al compartir contenido, aceptas nuestros [tos]Trminos de servicio[/tos]",
                TOS_AGREE: "Aceptar y compartir"
            },
            BACK_TO_EPISODES: "Volver a los episodios",
            BACK_TO_MENU: "Volver al men",
            CREATE_NEW_EPISODE: "Crear un nuevo episodio",
            PREVIOUS_EPISODES: "Episodios anteriores",
            PROMPT_ADD: "Aadir indicacin",
            PROMPT_PLACEHOLDER: "Escribe una indicacin",
            PROMPTS_COUNT_HIDDEN: "({count} oculto(s))",
            TITLE_PLACEHOLDER: "Escribir un ttulo"
        },
        EY = {
            BROADCASTER: {
                SUBTEXT: "Conectaste correctamente tu cuenta a la extensin para Twitch del kit para pblico de Jackbox.",
                WARNING: "ESTA SALA NO TIENE ACTIVADA LA OPCIN DE PBLICO"
            },
            RECONNECTED: {
                TEXT: "CONEXIN RESTABLECIDA",
                SUBTEXT: "Divirtete!"
            },
            RECONNECTING: {
                CONTROLLER: {
                    TEXT: "CONEXIN INTERRUMPIDA",
                    SUBTEXT: "Intento de reconexin ({attempt} de 5)"
                },
                GAME: {
                    TEXT: "SE INTERRUMPI LA CONEXIN AL JUEGO",
                    SUBTEXT: "Espera mientras intentamos restablecer la conexin"
                }
            }
        },
        TY = {
            ACTION: hY,
            ALT: fY,
            ERROR: dY,
            LOADING: pY,
            LOBBY: mY,
            POST_GAME: gY,
            SEPARATOR: _Y,
            TUTORIAL: yY,
            AUDIENCE: vY,
            UGC: bY,
            TOAST: EY
        },
        SY = {
            en: gK,
            fr: kK,
            it: BK,
            de: JK,
            es: uY,
            "es-XL": TY
        };
    var Td = {
        exports: {}
    };
    /**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    Td.exports;
    (function(t, e) {
        (function() {
            var n, r = "4.17.21",
                s = 200,
                i = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
                a = "Expected a function",
                c = "Invalid `variable` option passed into `_.template`",
                u = "__lodash_hash_undefined__",
                h = 500,
                d = "__lodash_placeholder__",
                p = 1,
                m = 2,
                _ = 4,
                y = 1,
                v = 2,
                w = 1,
                b = 2,
                I = 4,
                F = 8,
                x = 16,
                O = 32,
                M = 64,
                $ = 128,
                j = 256,
                ee = 512,
                se = 30,
                oe = "...",
                Z = 800,
                de = 16,
                q = 1,
                ie = 2,
                ae = 3,
                he = 1 / 0,
                ve = 9007199254740991,
                be = 17976931348623157e292,
                Ae = 0 / 0,
                we = 4294967295,
                Me = we - 1,
                Nt = we >>> 1,
                jt = [
                    ["ary", $],
                    ["bind", w],
                    ["bindKey", b],
                    ["curry", F],
                    ["curryRight", x],
                    ["flip", ee],
                    ["partial", O],
                    ["partialRight", M],
                    ["rearg", j]
                ],
                Ue = "[object Arguments]",
                Ye = "[object Array]",
                at = "[object AsyncFunction]",
                ke = "[object Boolean]",
                rt = "[object Date]",
                Yt = "[object DOMException]",
                zt = "[object Error]",
                U = "[object Function]",
                T = "[object GeneratorFunction]",
                S = "[object Map]",
                N = "[object Number]",
                V = "[object Null]",
                te = "[object Object]",
                re = "[object Promise]",
                ue = "[object Proxy]",
                pe = "[object RegExp]",
                ce = "[object Set]",
                J = "[object String]",
                ne = "[object Symbol]",
                Ne = "[object Undefined]",
                Pe = "[object WeakMap]",
                ze = "[object WeakSet]",
                ft = "[object ArrayBuffer]",
                D = "[object DataView]",
                P = "[object Float32Array]",
                z = "[object Float64Array]",
                R = "[object Int8Array]",
                K = "[object Int16Array]",
                me = "[object Int32Array]",
                Ee = "[object Uint8Array]",
                Ce = "[object Uint8ClampedArray]",
                De = "[object Uint16Array]",
                hn = "[object Uint32Array]",
                Nr = /\b__p \+= '';/g,
                Ze = /\b(__p \+=) '' \+/g,
                bl = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
                cb = /&(?:amp|lt|gt|quot|#39);/g,
                lb = /[&<>"']/g,
                M6 = RegExp(cb.source),
                D6 = RegExp(lb.source),
                $6 = /<%-([\s\S]+?)%>/g,
                L6 = /<%([\s\S]+?)%>/g,
                ub = /<%=([\s\S]+?)%>/g,
                F6 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                U6 = /^\w*$/,
                B6 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                Fm = /[\\^$.*+?()[\]{}|]/g,
                q6 = RegExp(Fm.source),
                Um = /^\s+/,
                j6 = /\s/,
                V6 = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                G6 = /\{\n\/\* \[wrapped with (.+)\] \*/,
                W6 = /,? & /,
                H6 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
                K6 = /[()=,{}\[\]\/\s]/,
                Y6 = /\\(\\)?/g,
                z6 = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
                hb = /\w*$/,
                Z6 = /^[-+]0x[0-9a-f]+$/i,
                X6 = /^0b[01]+$/i,
                J6 = /^\[object .+?Constructor\]$/,
                Q6 = /^0o[0-7]+$/i,
                eI = /^(?:0|[1-9]\d*)$/,
                tI = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
                Sh = /($^)/,
                nI = /['\n\r\u2028\u2029\\]/g,
                wh = "\\ud800-\\udfff",
                rI = "\\u0300-\\u036f",
                sI = "\\ufe20-\\ufe2f",
                iI = "\\u20d0-\\u20ff",
                fb = rI + sI + iI,
                db = "\\u2700-\\u27bf",
                pb = "a-z\\xdf-\\xf6\\xf8-\\xff",
                oI = "\\xac\\xb1\\xd7\\xf7",
                aI = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
                cI = "\\u2000-\\u206f",
                lI = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
                mb = "A-Z\\xc0-\\xd6\\xd8-\\xde",
                gb = "\\ufe0e\\ufe0f",
                _b = oI + aI + cI + lI,
                Bm = "[']",
                uI = "[" + wh + "]",
                yb = "[" + _b + "]",
                Oh = "[" + fb + "]",
                vb = "\\d+",
                hI = "[" + db + "]",
                bb = "[" + pb + "]",
                Eb = "[^" + wh + _b + vb + db + pb + mb + "]",
                qm = "\\ud83c[\\udffb-\\udfff]",
                fI = "(?:" + Oh + "|" + qm + ")",
                Tb = "[^" + wh + "]",
                jm = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                Vm = "[\\ud800-\\udbff][\\udc00-\\udfff]",
                Fa = "[" + mb + "]",
                Sb = "\\u200d",
                wb = "(?:" + bb + "|" + Eb + ")",
                dI = "(?:" + Fa + "|" + Eb + ")",
                Ob = "(?:" + Bm + "(?:d|ll|m|re|s|t|ve))?",
                Ab = "(?:" + Bm + "(?:D|LL|M|RE|S|T|VE))?",
                Cb = fI + "?",
                kb = "[" + gb + "]?",
                pI = "(?:" + Sb + "(?:" + [Tb, jm, Vm].join("|") + ")" + kb + Cb + ")*",
                mI = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
                gI = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
                Ib = kb + Cb + pI,
                _I = "(?:" + [hI, jm, Vm].join("|") + ")" + Ib,
                yI = "(?:" + [Tb + Oh + "?", Oh, jm, Vm, uI].join("|") + ")",
                vI = RegExp(Bm, "g"),
                bI = RegExp(Oh, "g"),
                Gm = RegExp(qm + "(?=" + qm + ")|" + yI + Ib, "g"),
                EI = RegExp([Fa + "?" + bb + "+" + Ob + "(?=" + [yb, Fa, "$"].join("|") + ")", dI + "+" + Ab + "(?=" + [yb, Fa + wb, "$"].join("|") + ")", Fa + "?" + wb + "+" + Ob, Fa + "+" + Ab, gI, mI, vb, _I].join("|"), "g"),
                TI = RegExp("[" + Sb + wh + fb + gb + "]"),
                SI = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
                wI = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
                OI = -1,
                Zt = {};
            Zt[P] = Zt[z] = Zt[R] = Zt[K] = Zt[me] = Zt[Ee] = Zt[Ce] = Zt[De] = Zt[hn] = !0, Zt[Ue] = Zt[Ye] = Zt[ft] = Zt[ke] = Zt[D] = Zt[rt] = Zt[zt] = Zt[U] = Zt[S] = Zt[N] = Zt[te] = Zt[pe] = Zt[ce] = Zt[J] = Zt[Pe] = !1;
            var Vt = {};
            Vt[Ue] = Vt[Ye] = Vt[ft] = Vt[D] = Vt[ke] = Vt[rt] = Vt[P] = Vt[z] = Vt[R] = Vt[K] = Vt[me] = Vt[S] = Vt[N] = Vt[te] = Vt[pe] = Vt[ce] = Vt[J] = Vt[ne] = Vt[Ee] = Vt[Ce] = Vt[De] = Vt[hn] = !0, Vt[zt] = Vt[U] = Vt[Pe] = !1;
            var AI = {
                    : "A",
                    : "A",
                    : "A",
                    : "A",
                    : "A",
                    : "A",
                    : "a",
                    : "a",
                    : "a",
                    : "a",
                    : "a",
                    : "a",
                    : "C",
                    : "c",
                    : "D",
                    : "d",
                    : "E",
                    : "E",
                    : "E",
                    : "E",
                    : "e",
                    : "e",
                    : "e",
                    : "e",
                    : "I",
                    : "I",
                    : "I",
                    : "I",
                    : "i",
                    : "i",
                    : "i",
                    : "i",
                    : "N",
                    : "n",
                    : "O",
                    : "O",
                    : "O",
                    : "O",
                    : "O",
                    : "O",
                    : "o",
                    : "o",
                    : "o",
                    : "o",
                    : "o",
                    : "o",
                    : "U",
                    : "U",
                    : "U",
                    : "U",
                    : "u",
                    : "u",
                    : "u",
                    : "u",
                    : "Y",
                    : "y",
                    : "y",
                    : "Ae",
                    : "ae",
                    : "Th",
                    : "th",
                    : "ss",
                    : "A",
                    : "A",
                    : "A",
                    : "a",
                    : "a",
                    : "a",
                    : "C",
                    : "C",
                    : "C",
                    : "C",
                    : "c",
                    : "c",
                    : "c",
                    : "c",
                    : "D",
                    : "D",
                    : "d",
                    : "d",
                    : "E",
                    : "E",
                    : "E",
                    : "E",
                    : "E",
                    : "e",
                    : "e",
                    : "e",
                    : "e",
                    : "e",
                    : "G",
                    : "G",
                    : "G",
                    : "G",
                    : "g",
                    : "g",
                    : "g",
                    : "g",
                    : "H",
                    : "H",
                    : "h",
                    : "h",
                    : "I",
                    : "I",
                    : "I",
                    : "I",
                    : "I",
                    : "i",
                    : "i",
                    : "i",
                    : "i",
                    : "i",
                    : "J",
                    : "j",
                    : "K",
                    : "k",
                    : "k",
                    : "L",
                    : "L",
                    : "L",
                    : "L",
                    : "L",
                    : "l",
                    : "l",
                    : "l",
                    : "l",
                    : "l",
                    : "N",
                    : "N",
                    : "N",
                    : "N",
                    : "n",
                    : "n",
                    : "n",
                    : "n",
                    : "O",
                    : "O",
                    : "O",
                    : "o",
                    : "o",
                    : "o",
                    : "R",
                    : "R",
                    : "R",
                    : "r",
                    : "r",
                    : "r",
                    : "S",
                    : "S",
                    : "S",
                    : "S",
                    : "s",
                    : "s",
                    : "s",
                    : "s",
                    : "T",
                    : "T",
                    : "T",
                    : "t",
                    : "t",
                    : "t",
                    : "U",
                    : "U",
                    : "U",
                    : "U",
                    : "U",
                    : "U",
                    : "u",
                    : "u",
                    : "u",
                    : "u",
                    : "u",
                    : "u",
                    : "W",
                    : "w",
                    : "Y",
                    : "y",
                    : "Y",
                    : "Z",
                    : "Z",
                    : "Z",
                    : "z",
                    : "z",
                    : "z",
                    : "IJ",
                    : "ij",
                    : "Oe",
                    : "oe",
                    : "'n",
                    : "s"
                },
                CI = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;"
                },
                kI = {
                    "&amp;": "&",
                    "&lt;": "<",
                    "&gt;": ">",
                    "&quot;": '"',
                    "&#39;": "'"
                },
                II = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                },
                NI = parseFloat,
                xI = parseInt,
                Nb = typeof gn == "object" && gn && gn.Object === Object && gn,
                PI = typeof self == "object" && self && self.Object === Object && self,
                Un = Nb || PI || Function("return this")(),
                Wm = e && !e.nodeType && e,
                Vo = Wm && !0 && t && !t.nodeType && t,
                xb = Vo && Vo.exports === Wm,
                Hm = xb && Nb.process,
                jr = function() {
                    try {
                        var X = Vo && Vo.require && Vo.require("util").types;
                        return X || Hm && Hm.binding && Hm.binding("util")
                    } catch {}
                }(),
                Pb = jr && jr.isArrayBuffer,
                Rb = jr && jr.isDate,
                Mb = jr && jr.isMap,
                Db = jr && jr.isRegExp,
                $b = jr && jr.isSet,
                Lb = jr && jr.isTypedArray;

            function xr(X, fe, le) {
                switch (le.length) {
                    case 0:
                        return X.call(fe);
                    case 1:
                        return X.call(fe, le[0]);
                    case 2:
                        return X.call(fe, le[0], le[1]);
                    case 3:
                        return X.call(fe, le[0], le[1], le[2])
                }
                return X.apply(fe, le)
            }

            function RI(X, fe, le, Re) {
                for (var Qe = -1, It = X == null ? 0 : X.length; ++Qe < It;) {
                    var Cn = X[Qe];
                    fe(Re, Cn, le(Cn), X)
                }
                return Re
            }

            function Vr(X, fe) {
                for (var le = -1, Re = X == null ? 0 : X.length; ++le < Re && fe(X[le], le, X) !== !1;);
                return X
            }

            function MI(X, fe) {
                for (var le = X == null ? 0 : X.length; le-- && fe(X[le], le, X) !== !1;);
                return X
            }

            function Fb(X, fe) {
                for (var le = -1, Re = X == null ? 0 : X.length; ++le < Re;)
                    if (!fe(X[le], le, X)) return !1;
                return !0
            }

            function Vi(X, fe) {
                for (var le = -1, Re = X == null ? 0 : X.length, Qe = 0, It = []; ++le < Re;) {
                    var Cn = X[le];
                    fe(Cn, le, X) && (It[Qe++] = Cn)
                }
                return It
            }

            function Ah(X, fe) {
                var le = X == null ? 0 : X.length;
                return !!le && Ua(X, fe, 0) > -1
            }

            function Km(X, fe, le) {
                for (var Re = -1, Qe = X == null ? 0 : X.length; ++Re < Qe;)
                    if (le(fe, X[Re])) return !0;
                return !1
            }

            function tn(X, fe) {
                for (var le = -1, Re = X == null ? 0 : X.length, Qe = Array(Re); ++le < Re;) Qe[le] = fe(X[le], le, X);
                return Qe
            }

            function Gi(X, fe) {
                for (var le = -1, Re = fe.length, Qe = X.length; ++le < Re;) X[Qe + le] = fe[le];
                return X
            }

            function Ym(X, fe, le, Re) {
                var Qe = -1,
                    It = X == null ? 0 : X.length;
                for (Re && It && (le = X[++Qe]); ++Qe < It;) le = fe(le, X[Qe], Qe, X);
                return le
            }

            function DI(X, fe, le, Re) {
                var Qe = X == null ? 0 : X.length;
                for (Re && Qe && (le = X[--Qe]); Qe--;) le = fe(le, X[Qe], Qe, X);
                return le
            }

            function zm(X, fe) {
                for (var le = -1, Re = X == null ? 0 : X.length; ++le < Re;)
                    if (fe(X[le], le, X)) return !0;
                return !1
            }
            var $I = Zm("length");

            function LI(X) {
                return X.split("")
            }

            function FI(X) {
                return X.match(H6) || []
            }

            function Ub(X, fe, le) {
                var Re;
                return le(X, function(Qe, It, Cn) {
                    if (fe(Qe, It, Cn)) return Re = It, !1
                }), Re
            }

            function Ch(X, fe, le, Re) {
                for (var Qe = X.length, It = le + (Re ? 1 : -1); Re ? It-- : ++It < Qe;)
                    if (fe(X[It], It, X)) return It;
                return -1
            }

            function Ua(X, fe, le) {
                return fe === fe ? ZI(X, fe, le) : Ch(X, Bb, le)
            }

            function UI(X, fe, le, Re) {
                for (var Qe = le - 1, It = X.length; ++Qe < It;)
                    if (Re(X[Qe], fe)) return Qe;
                return -1
            }

            function Bb(X) {
                return X !== X
            }

            function qb(X, fe) {
                var le = X == null ? 0 : X.length;
                return le ? Jm(X, fe) / le : Ae
            }

            function Zm(X) {
                return function(fe) {
                    return fe == null ? n : fe[X]
                }
            }

            function Xm(X) {
                return function(fe) {
                    return X == null ? n : X[fe]
                }
            }

            function jb(X, fe, le, Re, Qe) {
                return Qe(X, function(It, Cn, Lt) {
                    le = Re ? (Re = !1, It) : fe(le, It, Cn, Lt)
                }), le
            }

            function BI(X, fe) {
                var le = X.length;
                for (X.sort(fe); le--;) X[le] = X[le].value;
                return X
            }

            function Jm(X, fe) {
                for (var le, Re = -1, Qe = X.length; ++Re < Qe;) {
                    var It = fe(X[Re]);
                    It !== n && (le = le === n ? It : le + It)
                }
                return le
            }

            function Qm(X, fe) {
                for (var le = -1, Re = Array(X); ++le < X;) Re[le] = fe(le);
                return Re
            }

            function qI(X, fe) {
                return tn(fe, function(le) {
                    return [le, X[le]]
                })
            }

            function Vb(X) {
                return X && X.slice(0, Kb(X) + 1).replace(Um, "")
            }

            function Pr(X) {
                return function(fe) {
                    return X(fe)
                }
            }

            function eg(X, fe) {
                return tn(fe, function(le) {
                    return X[le]
                })
            }

            function El(X, fe) {
                return X.has(fe)
            }

            function Gb(X, fe) {
                for (var le = -1, Re = X.length; ++le < Re && Ua(fe, X[le], 0) > -1;);
                return le
            }

            function Wb(X, fe) {
                for (var le = X.length; le-- && Ua(fe, X[le], 0) > -1;);
                return le
            }

            function jI(X, fe) {
                for (var le = X.length, Re = 0; le--;) X[le] === fe && ++Re;
                return Re
            }
            var VI = Xm(AI),
                GI = Xm(CI);

            function WI(X) {
                return "\\" + II[X]
            }

            function HI(X, fe) {
                return X == null ? n : X[fe]
            }

            function Ba(X) {
                return TI.test(X)
            }

            function KI(X) {
                return SI.test(X)
            }

            function YI(X) {
                for (var fe, le = []; !(fe = X.next()).done;) le.push(fe.value);
                return le
            }

            function tg(X) {
                var fe = -1,
                    le = Array(X.size);
                return X.forEach(function(Re, Qe) {
                    le[++fe] = [Qe, Re]
                }), le
            }

            function Hb(X, fe) {
                return function(le) {
                    return X(fe(le))
                }
            }

            function Wi(X, fe) {
                for (var le = -1, Re = X.length, Qe = 0, It = []; ++le < Re;) {
                    var Cn = X[le];
                    (Cn === fe || Cn === d) && (X[le] = d, It[Qe++] = le)
                }
                return It
            }

            function kh(X) {
                var fe = -1,
                    le = Array(X.size);
                return X.forEach(function(Re) {
                    le[++fe] = Re
                }), le
            }

            function zI(X) {
                var fe = -1,
                    le = Array(X.size);
                return X.forEach(function(Re) {
                    le[++fe] = [Re, Re]
                }), le
            }

            function ZI(X, fe, le) {
                for (var Re = le - 1, Qe = X.length; ++Re < Qe;)
                    if (X[Re] === fe) return Re;
                return -1
            }

            function XI(X, fe, le) {
                for (var Re = le + 1; Re--;)
                    if (X[Re] === fe) return Re;
                return Re
            }

            function qa(X) {
                return Ba(X) ? QI(X) : $I(X)
            }

            function ls(X) {
                return Ba(X) ? eN(X) : LI(X)
            }

            function Kb(X) {
                for (var fe = X.length; fe-- && j6.test(X.charAt(fe)););
                return fe
            }
            var JI = Xm(kI);

            function QI(X) {
                for (var fe = Gm.lastIndex = 0; Gm.test(X);) ++fe;
                return fe
            }

            function eN(X) {
                return X.match(Gm) || []
            }

            function tN(X) {
                return X.match(EI) || []
            }
            var nN = function X(fe) {
                    fe = fe == null ? Un : ja.defaults(Un.Object(), fe, ja.pick(Un, wI));
                    var le = fe.Array,
                        Re = fe.Date,
                        Qe = fe.Error,
                        It = fe.Function,
                        Cn = fe.Math,
                        Lt = fe.Object,
                        ng = fe.RegExp,
                        rN = fe.String,
                        Gr = fe.TypeError,
                        Ih = le.prototype,
                        sN = It.prototype,
                        Va = Lt.prototype,
                        Nh = fe["__core-js_shared__"],
                        xh = sN.toString,
                        Rt = Va.hasOwnProperty,
                        iN = 0,
                        Yb = function() {
                            var o = /[^.]+$/.exec(Nh && Nh.keys && Nh.keys.IE_PROTO || "");
                            return o ? "Symbol(src)_1." + o : ""
                        }(),
                        Ph = Va.toString,
                        oN = xh.call(Lt),
                        aN = Un._,
                        cN = ng("^" + xh.call(Rt).replace(Fm, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                        Rh = xb ? fe.Buffer : n,
                        Hi = fe.Symbol,
                        Mh = fe.Uint8Array,
                        zb = Rh ? Rh.allocUnsafe : n,
                        Dh = Hb(Lt.getPrototypeOf, Lt),
                        Zb = Lt.create,
                        Xb = Va.propertyIsEnumerable,
                        $h = Ih.splice,
                        Jb = Hi ? Hi.isConcatSpreadable : n,
                        Tl = Hi ? Hi.iterator : n,
                        Go = Hi ? Hi.toStringTag : n,
                        Lh = function() {
                            try {
                                var o = zo(Lt, "defineProperty");
                                return o({}, "", {}), o
                            } catch {}
                        }(),
                        lN = fe.clearTimeout !== Un.clearTimeout && fe.clearTimeout,
                        uN = Re && Re.now !== Un.Date.now && Re.now,
                        hN = fe.setTimeout !== Un.setTimeout && fe.setTimeout,
                        Fh = Cn.ceil,
                        Uh = Cn.floor,
                        rg = Lt.getOwnPropertySymbols,
                        fN = Rh ? Rh.isBuffer : n,
                        Qb = fe.isFinite,
                        dN = Ih.join,
                        pN = Hb(Lt.keys, Lt),
                        kn = Cn.max,
                        Zn = Cn.min,
                        mN = Re.now,
                        gN = fe.parseInt,
                        e2 = Cn.random,
                        _N = Ih.reverse,
                        sg = zo(fe, "DataView"),
                        Sl = zo(fe, "Map"),
                        ig = zo(fe, "Promise"),
                        Ga = zo(fe, "Set"),
                        wl = zo(fe, "WeakMap"),
                        Ol = zo(Lt, "create"),
                        Bh = wl && new wl,
                        Wa = {},
                        yN = Zo(sg),
                        vN = Zo(Sl),
                        bN = Zo(ig),
                        EN = Zo(Ga),
                        TN = Zo(wl),
                        qh = Hi ? Hi.prototype : n,
                        Al = qh ? qh.valueOf : n,
                        t2 = qh ? qh.toString : n;

                    function A(o) {
                        if (cn(o) && !tt(o) && !(o instanceof _t)) {
                            if (o instanceof Wr) return o;
                            if (Rt.call(o, "__wrapped__")) return nE(o)
                        }
                        return new Wr(o)
                    }
                    var Ha = function() {
                        function o() {}
                        return function(l) {
                            if (!an(l)) return {};
                            if (Zb) return Zb(l);
                            o.prototype = l;
                            var f = new o;
                            return o.prototype = n, f
                        }
                    }();

                    function jh() {}

                    function Wr(o, l) {
                        this.__wrapped__ = o, this.__actions__ = [], this.__chain__ = !!l, this.__index__ = 0, this.__values__ = n
                    }
                    A.templateSettings = {
                        escape: $6,
                        evaluate: L6,
                        interpolate: ub,
                        variable: "",
                        imports: {
                            _: A
                        }
                    }, A.prototype = jh.prototype, A.prototype.constructor = A, Wr.prototype = Ha(jh.prototype), Wr.prototype.constructor = Wr;

                    function _t(o) {
                        this.__wrapped__ = o, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = we, this.__views__ = []
                    }

                    function SN() {
                        var o = new _t(this.__wrapped__);
                        return o.__actions__ = gr(this.__actions__), o.__dir__ = this.__dir__, o.__filtered__ = this.__filtered__, o.__iteratees__ = gr(this.__iteratees__), o.__takeCount__ = this.__takeCount__, o.__views__ = gr(this.__views__), o
                    }

                    function wN() {
                        if (this.__filtered__) {
                            var o = new _t(this);
                            o.__dir__ = -1, o.__filtered__ = !0
                        } else o = this.clone(), o.__dir__ *= -1;
                        return o
                    }

                    function ON() {
                        var o = this.__wrapped__.value(),
                            l = this.__dir__,
                            f = tt(o),
                            g = l < 0,
                            E = f ? o.length : 0,
                            k = L7(0, E, this.__views__),
                            L = k.start,
                            W = k.end,
                            Q = W - L,
                            _e = g ? W : L - 1,
                            ye = this.__iteratees__,
                            Te = ye.length,
                            Ie = 0,
                            $e = Zn(Q, this.__takeCount__);
                        if (!f || !g && E == Q && $e == Q) return O2(o, this.__actions__);
                        var We = [];
                        e: for (; Q-- && Ie < $e;) {
                            _e += l;
                            for (var ut = -1, He = o[_e]; ++ut < Te;) {
                                var gt = ye[ut],
                                    Et = gt.iteratee,
                                    Dr = gt.type,
                                    cr = Et(He);
                                if (Dr == ie) He = cr;
                                else if (!cr) {
                                    if (Dr == q) continue e;
                                    break e
                                }
                            }
                            We[Ie++] = He
                        }
                        return We
                    }
                    _t.prototype = Ha(jh.prototype), _t.prototype.constructor = _t;

                    function Wo(o) {
                        var l = -1,
                            f = o == null ? 0 : o.length;
                        for (this.clear(); ++l < f;) {
                            var g = o[l];
                            this.set(g[0], g[1])
                        }
                    }

                    function AN() {
                        this.__data__ = Ol ? Ol(null) : {}, this.size = 0
                    }

                    function CN(o) {
                        var l = this.has(o) && delete this.__data__[o];
                        return this.size -= l ? 1 : 0, l
                    }

                    function kN(o) {
                        var l = this.__data__;
                        if (Ol) {
                            var f = l[o];
                            return f === u ? n : f
                        }
                        return Rt.call(l, o) ? l[o] : n
                    }

                    function IN(o) {
                        var l = this.__data__;
                        return Ol ? l[o] !== n : Rt.call(l, o)
                    }

                    function NN(o, l) {
                        var f = this.__data__;
                        return this.size += this.has(o) ? 0 : 1, f[o] = Ol && l === n ? u : l, this
                    }
                    Wo.prototype.clear = AN, Wo.prototype.delete = CN, Wo.prototype.get = kN, Wo.prototype.has = IN, Wo.prototype.set = NN;

                    function ui(o) {
                        var l = -1,
                            f = o == null ? 0 : o.length;
                        for (this.clear(); ++l < f;) {
                            var g = o[l];
                            this.set(g[0], g[1])
                        }
                    }

                    function xN() {
                        this.__data__ = [], this.size = 0
                    }

                    function PN(o) {
                        var l = this.__data__,
                            f = Vh(l, o);
                        if (f < 0) return !1;
                        var g = l.length - 1;
                        return f == g ? l.pop() : $h.call(l, f, 1), --this.size, !0
                    }

                    function RN(o) {
                        var l = this.__data__,
                            f = Vh(l, o);
                        return f < 0 ? n : l[f][1]
                    }

                    function MN(o) {
                        return Vh(this.__data__, o) > -1
                    }

                    function DN(o, l) {
                        var f = this.__data__,
                            g = Vh(f, o);
                        return g < 0 ? (++this.size, f.push([o, l])) : f[g][1] = l, this
                    }
                    ui.prototype.clear = xN, ui.prototype.delete = PN, ui.prototype.get = RN, ui.prototype.has = MN, ui.prototype.set = DN;

                    function hi(o) {
                        var l = -1,
                            f = o == null ? 0 : o.length;
                        for (this.clear(); ++l < f;) {
                            var g = o[l];
                            this.set(g[0], g[1])
                        }
                    }

                    function $N() {
                        this.size = 0, this.__data__ = {
                            hash: new Wo,
                            map: new(Sl || ui),
                            string: new Wo
                        }
                    }

                    function LN(o) {
                        var l = tf(this, o).delete(o);
                        return this.size -= l ? 1 : 0, l
                    }

                    function FN(o) {
                        return tf(this, o).get(o)
                    }

                    function UN(o) {
                        return tf(this, o).has(o)
                    }

                    function BN(o, l) {
                        var f = tf(this, o),
                            g = f.size;
                        return f.set(o, l), this.size += f.size == g ? 0 : 1, this
                    }
                    hi.prototype.clear = $N, hi.prototype.delete = LN, hi.prototype.get = FN, hi.prototype.has = UN, hi.prototype.set = BN;

                    function Ho(o) {
                        var l = -1,
                            f = o == null ? 0 : o.length;
                        for (this.__data__ = new hi; ++l < f;) this.add(o[l])
                    }

                    function qN(o) {
                        return this.__data__.set(o, u), this
                    }

                    function jN(o) {
                        return this.__data__.has(o)
                    }
                    Ho.prototype.add = Ho.prototype.push = qN, Ho.prototype.has = jN;

                    function us(o) {
                        var l = this.__data__ = new ui(o);
                        this.size = l.size
                    }

                    function VN() {
                        this.__data__ = new ui, this.size = 0
                    }

                    function GN(o) {
                        var l = this.__data__,
                            f = l.delete(o);
                        return this.size = l.size, f
                    }

                    function WN(o) {
                        return this.__data__.get(o)
                    }

                    function HN(o) {
                        return this.__data__.has(o)
                    }

                    function KN(o, l) {
                        var f = this.__data__;
                        if (f instanceof ui) {
                            var g = f.__data__;
                            if (!Sl || g.length < s - 1) return g.push([o, l]), this.size = ++f.size, this;
                            f = this.__data__ = new hi(g)
                        }
                        return f.set(o, l), this.size = f.size, this
                    }
                    us.prototype.clear = VN, us.prototype.delete = GN, us.prototype.get = WN, us.prototype.has = HN, us.prototype.set = KN;

                    function n2(o, l) {
                        var f = tt(o),
                            g = !f && Xo(o),
                            E = !f && !g && Xi(o),
                            k = !f && !g && !E && Za(o),
                            L = f || g || E || k,
                            W = L ? Qm(o.length, rN) : [],
                            Q = W.length;
                        for (var _e in o)(l || Rt.call(o, _e)) && !(L && (_e == "length" || E && (_e == "offset" || _e == "parent") || k && (_e == "buffer" || _e == "byteLength" || _e == "byteOffset") || mi(_e, Q))) && W.push(_e);
                        return W
                    }

                    function r2(o) {
                        var l = o.length;
                        return l ? o[gg(0, l - 1)] : n
                    }

                    function YN(o, l) {
                        return nf(gr(o), Ko(l, 0, o.length))
                    }

                    function zN(o) {
                        return nf(gr(o))
                    }

                    function og(o, l, f) {
                        (f !== n && !hs(o[l], f) || f === n && !(l in o)) && fi(o, l, f)
                    }

                    function Cl(o, l, f) {
                        var g = o[l];
                        (!(Rt.call(o, l) && hs(g, f)) || f === n && !(l in o)) && fi(o, l, f)
                    }

                    function Vh(o, l) {
                        for (var f = o.length; f--;)
                            if (hs(o[f][0], l)) return f;
                        return -1
                    }

                    function ZN(o, l, f, g) {
                        return Ki(o, function(E, k, L) {
                            l(g, E, f(E), L)
                        }), g
                    }

                    function s2(o, l) {
                        return o && Us(l, Mn(l), o)
                    }

                    function XN(o, l) {
                        return o && Us(l, yr(l), o)
                    }

                    function fi(o, l, f) {
                        l == "__proto__" && Lh ? Lh(o, l, {
                            configurable: !0,
                            enumerable: !0,
                            value: f,
                            writable: !0
                        }) : o[l] = f
                    }

                    function ag(o, l) {
                        for (var f = -1, g = l.length, E = le(g), k = o == null; ++f < g;) E[f] = k ? n : qg(o, l[f]);
                        return E
                    }

                    function Ko(o, l, f) {
                        return o === o && (f !== n && (o = o <= f ? o : f), l !== n && (o = o >= l ? o : l)), o
                    }

                    function Hr(o, l, f, g, E, k) {
                        var L, W = l & p,
                            Q = l & m,
                            _e = l & _;
                        if (f && (L = E ? f(o, g, E, k) : f(o)), L !== n) return L;
                        if (!an(o)) return o;
                        var ye = tt(o);
                        if (ye) {
                            if (L = U7(o), !W) return gr(o, L)
                        } else {
                            var Te = Xn(o),
                                Ie = Te == U || Te == T;
                            if (Xi(o)) return k2(o, W);
                            if (Te == te || Te == Ue || Ie && !E) {
                                if (L = Q || Ie ? {} : K2(o), !W) return Q ? k7(o, XN(L, o)) : C7(o, s2(L, o))
                            } else {
                                if (!Vt[Te]) return E ? o : {};
                                L = B7(o, Te, W)
                            }
                        }
                        k || (k = new us);
                        var $e = k.get(o);
                        if ($e) return $e;
                        k.set(o, L), TE(o) ? o.forEach(function(He) {
                            L.add(Hr(He, l, f, He, o, k))
                        }) : bE(o) && o.forEach(function(He, gt) {
                            L.set(gt, Hr(He, l, f, gt, o, k))
                        });
                        var We = _e ? Q ? Cg : Ag : Q ? yr : Mn,
                            ut = ye ? n : We(o);
                        return Vr(ut || o, function(He, gt) {
                            ut && (gt = He, He = o[gt]), Cl(L, gt, Hr(He, l, f, gt, o, k))
                        }), L
                    }

                    function JN(o) {
                        var l = Mn(o);
                        return function(f) {
                            return i2(f, o, l)
                        }
                    }

                    function i2(o, l, f) {
                        var g = f.length;
                        if (o == null) return !g;
                        for (o = Lt(o); g--;) {
                            var E = f[g],
                                k = l[E],
                                L = o[E];
                            if (L === n && !(E in o) || !k(L)) return !1
                        }
                        return !0
                    }

                    function o2(o, l, f) {
                        if (typeof o != "function") throw new Gr(a);
                        return Ml(function() {
                            o.apply(n, f)
                        }, l)
                    }

                    function kl(o, l, f, g) {
                        var E = -1,
                            k = Ah,
                            L = !0,
                            W = o.length,
                            Q = [],
                            _e = l.length;
                        if (!W) return Q;
                        f && (l = tn(l, Pr(f))), g ? (k = Km, L = !1) : l.length >= s && (k = El, L = !1, l = new Ho(l));
                        e: for (; ++E < W;) {
                            var ye = o[E],
                                Te = f == null ? ye : f(ye);
                            if (ye = g || ye !== 0 ? ye : 0, L && Te === Te) {
                                for (var Ie = _e; Ie--;)
                                    if (l[Ie] === Te) continue e;
                                Q.push(ye)
                            } else k(l, Te, g) || Q.push(ye)
                        }
                        return Q
                    }
                    var Ki = R2(Fs),
                        a2 = R2(lg, !0);

                    function QN(o, l) {
                        var f = !0;
                        return Ki(o, function(g, E, k) {
                            return f = !!l(g, E, k), f
                        }), f
                    }

                    function Gh(o, l, f) {
                        for (var g = -1, E = o.length; ++g < E;) {
                            var k = o[g],
                                L = l(k);
                            if (L != null && (W === n ? L === L && !Mr(L) : f(L, W))) var W = L,
                                Q = k
                        }
                        return Q
                    }

                    function e7(o, l, f, g) {
                        var E = o.length;
                        for (f = ct(f), f < 0 && (f = -f > E ? 0 : E + f), g = g === n || g > E ? E : ct(g), g < 0 && (g += E), g = f > g ? 0 : wE(g); f < g;) o[f++] = l;
                        return o
                    }

                    function c2(o, l) {
                        var f = [];
                        return Ki(o, function(g, E, k) {
                            l(g, E, k) && f.push(g)
                        }), f
                    }

                    function Bn(o, l, f, g, E) {
                        var k = -1,
                            L = o.length;
                        for (f || (f = j7), E || (E = []); ++k < L;) {
                            var W = o[k];
                            l > 0 && f(W) ? l > 1 ? Bn(W, l - 1, f, g, E) : Gi(E, W) : g || (E[E.length] = W)
                        }
                        return E
                    }
                    var cg = M2(),
                        l2 = M2(!0);

                    function Fs(o, l) {
                        return o && cg(o, l, Mn)
                    }

                    function lg(o, l) {
                        return o && l2(o, l, Mn)
                    }

                    function Wh(o, l) {
                        return Vi(l, function(f) {
                            return gi(o[f])
                        })
                    }

                    function Yo(o, l) {
                        l = zi(l, o);
                        for (var f = 0, g = l.length; o != null && f < g;) o = o[Bs(l[f++])];
                        return f && f == g ? o : n
                    }

                    function u2(o, l, f) {
                        var g = l(o);
                        return tt(o) ? g : Gi(g, f(o))
                    }

                    function or(o) {
                        return o == null ? o === n ? Ne : V : Go && Go in Lt(o) ? $7(o) : z7(o)
                    }

                    function ug(o, l) {
                        return o > l
                    }

                    function t7(o, l) {
                        return o != null && Rt.call(o, l)
                    }

                    function n7(o, l) {
                        return o != null && l in Lt(o)
                    }

                    function r7(o, l, f) {
                        return o >= Zn(l, f) && o < kn(l, f)
                    }

                    function hg(o, l, f) {
                        for (var g = f ? Km : Ah, E = o[0].length, k = o.length, L = k, W = le(k), Q = 1 / 0, _e = []; L--;) {
                            var ye = o[L];
                            L && l && (ye = tn(ye, Pr(l))), Q = Zn(ye.length, Q), W[L] = !f && (l || E >= 120 && ye.length >= 120) ? new Ho(L && ye) : n
                        }
                        ye = o[0];
                        var Te = -1,
                            Ie = W[0];
                        e: for (; ++Te < E && _e.length < Q;) {
                            var $e = ye[Te],
                                We = l ? l($e) : $e;
                            if ($e = f || $e !== 0 ? $e : 0, !(Ie ? El(Ie, We) : g(_e, We, f))) {
                                for (L = k; --L;) {
                                    var ut = W[L];
                                    if (!(ut ? El(ut, We) : g(o[L], We, f))) continue e
                                }
                                Ie && Ie.push(We), _e.push($e)
                            }
                        }
                        return _e
                    }

                    function s7(o, l, f, g) {
                        return Fs(o, function(E, k, L) {
                            l(g, f(E), k, L)
                        }), g
                    }

                    function Il(o, l, f) {
                        l = zi(l, o), o = X2(o, l);
                        var g = o == null ? o : o[Bs(Yr(l))];
                        return g == null ? n : xr(g, o, f)
                    }

                    function h2(o) {
                        return cn(o) && or(o) == Ue
                    }

                    function i7(o) {
                        return cn(o) && or(o) == ft
                    }

                    function o7(o) {
                        return cn(o) && or(o) == rt
                    }

                    function Nl(o, l, f, g, E) {
                        return o === l ? !0 : o == null || l == null || !cn(o) && !cn(l) ? o !== o && l !== l : a7(o, l, f, g, Nl, E)
                    }

                    function a7(o, l, f, g, E, k) {
                        var L = tt(o),
                            W = tt(l),
                            Q = L ? Ye : Xn(o),
                            _e = W ? Ye : Xn(l);
                        Q = Q == Ue ? te : Q, _e = _e == Ue ? te : _e;
                        var ye = Q == te,
                            Te = _e == te,
                            Ie = Q == _e;
                        if (Ie && Xi(o)) {
                            if (!Xi(l)) return !1;
                            L = !0, ye = !1
                        }
                        if (Ie && !ye) return k || (k = new us), L || Za(o) ? G2(o, l, f, g, E, k) : M7(o, l, Q, f, g, E, k);
                        if (!(f & y)) {
                            var $e = ye && Rt.call(o, "__wrapped__"),
                                We = Te && Rt.call(l, "__wrapped__");
                            if ($e || We) {
                                var ut = $e ? o.value() : o,
                                    He = We ? l.value() : l;
                                return k || (k = new us), E(ut, He, f, g, k)
                            }
                        }
                        return Ie ? (k || (k = new us), D7(o, l, f, g, E, k)) : !1
                    }

                    function c7(o) {
                        return cn(o) && Xn(o) == S
                    }

                    function fg(o, l, f, g) {
                        var E = f.length,
                            k = E,
                            L = !g;
                        if (o == null) return !k;
                        for (o = Lt(o); E--;) {
                            var W = f[E];
                            if (L && W[2] ? W[1] !== o[W[0]] : !(W[0] in o)) return !1
                        }
                        for (; ++E < k;) {
                            W = f[E];
                            var Q = W[0],
                                _e = o[Q],
                                ye = W[1];
                            if (L && W[2]) {
                                if (_e === n && !(Q in o)) return !1
                            } else {
                                var Te = new us;
                                if (g) var Ie = g(_e, ye, Q, o, l, Te);
                                if (!(Ie === n ? Nl(ye, _e, y | v, g, Te) : Ie)) return !1
                            }
                        }
                        return !0
                    }

                    function f2(o) {
                        if (!an(o) || G7(o)) return !1;
                        var l = gi(o) ? cN : J6;
                        return l.test(Zo(o))
                    }

                    function l7(o) {
                        return cn(o) && or(o) == pe
                    }

                    function u7(o) {
                        return cn(o) && Xn(o) == ce
                    }

                    function h7(o) {
                        return cn(o) && lf(o.length) && !!Zt[or(o)]
                    }

                    function d2(o) {
                        return typeof o == "function" ? o : o == null ? vr : typeof o == "object" ? tt(o) ? g2(o[0], o[1]) : m2(o) : DE(o)
                    }

                    function dg(o) {
                        if (!Rl(o)) return pN(o);
                        var l = [];
                        for (var f in Lt(o)) Rt.call(o, f) && f != "constructor" && l.push(f);
                        return l
                    }

                    function f7(o) {
                        if (!an(o)) return Y7(o);
                        var l = Rl(o),
                            f = [];
                        for (var g in o) g == "constructor" && (l || !Rt.call(o, g)) || f.push(g);
                        return f
                    }

                    function pg(o, l) {
                        return o < l
                    }

                    function p2(o, l) {
                        var f = -1,
                            g = _r(o) ? le(o.length) : [];
                        return Ki(o, function(E, k, L) {
                            g[++f] = l(E, k, L)
                        }), g
                    }

                    function m2(o) {
                        var l = Ig(o);
                        return l.length == 1 && l[0][2] ? z2(l[0][0], l[0][1]) : function(f) {
                            return f === o || fg(f, o, l)
                        }
                    }

                    function g2(o, l) {
                        return xg(o) && Y2(l) ? z2(Bs(o), l) : function(f) {
                            var g = qg(f, o);
                            return g === n && g === l ? jg(f, o) : Nl(l, g, y | v)
                        }
                    }

                    function Hh(o, l, f, g, E) {
                        o !== l && cg(l, function(k, L) {
                            if (E || (E = new us), an(k)) d7(o, l, L, f, Hh, g, E);
                            else {
                                var W = g ? g(Rg(o, L), k, L + "", o, l, E) : n;
                                W === n && (W = k), og(o, L, W)
                            }
                        }, yr)
                    }

                    function d7(o, l, f, g, E, k, L) {
                        var W = Rg(o, f),
                            Q = Rg(l, f),
                            _e = L.get(Q);
                        if (_e) {
                            og(o, f, _e);
                            return
                        }
                        var ye = k ? k(W, Q, f + "", o, l, L) : n,
                            Te = ye === n;
                        if (Te) {
                            var Ie = tt(Q),
                                $e = !Ie && Xi(Q),
                                We = !Ie && !$e && Za(Q);
                            ye = Q, Ie || $e || We ? tt(W) ? ye = W : fn(W) ? ye = gr(W) : $e ? (Te = !1, ye = k2(Q, !0)) : We ? (Te = !1, ye = I2(Q, !0)) : ye = [] : Dl(Q) || Xo(Q) ? (ye = W, Xo(W) ? ye = OE(W) : (!an(W) || gi(W)) && (ye = K2(Q))) : Te = !1
                        }
                        Te && (L.set(Q, ye), E(ye, Q, g, k, L), L.delete(Q)), og(o, f, ye)
                    }

                    function _2(o, l) {
                        var f = o.length;
                        if (f) return l += l < 0 ? f : 0, mi(l, f) ? o[l] : n
                    }

                    function y2(o, l, f) {
                        l.length ? l = tn(l, function(k) {
                            return tt(k) ? function(L) {
                                return Yo(L, k.length === 1 ? k[0] : k)
                            } : k
                        }) : l = [vr];
                        var g = -1;
                        l = tn(l, Pr(je()));
                        var E = p2(o, function(k, L, W) {
                            var Q = tn(l, function(_e) {
                                return _e(k)
                            });
                            return {
                                criteria: Q,
                                index: ++g,
                                value: k
                            }
                        });
                        return BI(E, function(k, L) {
                            return A7(k, L, f)
                        })
                    }

                    function p7(o, l) {
                        return v2(o, l, function(f, g) {
                            return jg(o, g)
                        })
                    }

                    function v2(o, l, f) {
                        for (var g = -1, E = l.length, k = {}; ++g < E;) {
                            var L = l[g],
                                W = Yo(o, L);
                            f(W, L) && xl(k, zi(L, o), W)
                        }
                        return k
                    }

                    function m7(o) {
                        return function(l) {
                            return Yo(l, o)
                        }
                    }

                    function mg(o, l, f, g) {
                        var E = g ? UI : Ua,
                            k = -1,
                            L = l.length,
                            W = o;
                        for (o === l && (l = gr(l)), f && (W = tn(o, Pr(f))); ++k < L;)
                            for (var Q = 0, _e = l[k], ye = f ? f(_e) : _e;
                                (Q = E(W, ye, Q, g)) > -1;) W !== o && $h.call(W, Q, 1), $h.call(o, Q, 1);
                        return o
                    }

                    function b2(o, l) {
                        for (var f = o ? l.length : 0, g = f - 1; f--;) {
                            var E = l[f];
                            if (f == g || E !== k) {
                                var k = E;
                                mi(E) ? $h.call(o, E, 1) : vg(o, E)
                            }
                        }
                        return o
                    }

                    function gg(o, l) {
                        return o + Uh(e2() * (l - o + 1))
                    }

                    function g7(o, l, f, g) {
                        for (var E = -1, k = kn(Fh((l - o) / (f || 1)), 0), L = le(k); k--;) L[g ? k : ++E] = o, o += f;
                        return L
                    }

                    function _g(o, l) {
                        var f = "";
                        if (!o || l < 1 || l > ve) return f;
                        do l % 2 && (f += o), l = Uh(l / 2), l && (o += o); while (l);
                        return f
                    }

                    function dt(o, l) {
                        return Mg(Z2(o, l, vr), o + "")
                    }

                    function _7(o) {
                        return r2(Xa(o))
                    }

                    function y7(o, l) {
                        var f = Xa(o);
                        return nf(f, Ko(l, 0, f.length))
                    }

                    function xl(o, l, f, g) {
                        if (!an(o)) return o;
                        l = zi(l, o);
                        for (var E = -1, k = l.length, L = k - 1, W = o; W != null && ++E < k;) {
                            var Q = Bs(l[E]),
                                _e = f;
                            if (Q === "__proto__" || Q === "constructor" || Q === "prototype") return o;
                            if (E != L) {
                                var ye = W[Q];
                                _e = g ? g(ye, Q, W) : n, _e === n && (_e = an(ye) ? ye : mi(l[E + 1]) ? [] : {})
                            }
                            Cl(W, Q, _e), W = W[Q]
                        }
                        return o
                    }
                    var E2 = Bh ? function(o, l) {
                            return Bh.set(o, l), o
                        } : vr,
                        v7 = Lh ? function(o, l) {
                            return Lh(o, "toString", {
                                configurable: !0,
                                enumerable: !1,
                                value: Gg(l),
                                writable: !0
                            })
                        } : vr;

                    function b7(o) {
                        return nf(Xa(o))
                    }

                    function Kr(o, l, f) {
                        var g = -1,
                            E = o.length;
                        l < 0 && (l = -l > E ? 0 : E + l), f = f > E ? E : f, f < 0 && (f += E), E = l > f ? 0 : f - l >>> 0, l >>>= 0;
                        for (var k = le(E); ++g < E;) k[g] = o[g + l];
                        return k
                    }

                    function E7(o, l) {
                        var f;
                        return Ki(o, function(g, E, k) {
                            return f = l(g, E, k), !f
                        }), !!f
                    }

                    function Kh(o, l, f) {
                        var g = 0,
                            E = o == null ? g : o.length;
                        if (typeof l == "number" && l === l && E <= Nt) {
                            for (; g < E;) {
                                var k = g + E >>> 1,
                                    L = o[k];
                                L !== null && !Mr(L) && (f ? L <= l : L < l) ? g = k + 1 : E = k
                            }
                            return E
                        }
                        return yg(o, l, vr, f)
                    }

                    function yg(o, l, f, g) {
                        var E = 0,
                            k = o == null ? 0 : o.length;
                        if (k === 0) return 0;
                        l = f(l);
                        for (var L = l !== l, W = l === null, Q = Mr(l), _e = l === n; E < k;) {
                            var ye = Uh((E + k) / 2),
                                Te = f(o[ye]),
                                Ie = Te !== n,
                                $e = Te === null,
                                We = Te === Te,
                                ut = Mr(Te);
                            if (L) var He = g || We;
                            else _e ? He = We && (g || Ie) : W ? He = We && Ie && (g || !$e) : Q ? He = We && Ie && !$e && (g || !ut) : $e || ut ? He = !1 : He = g ? Te <= l : Te < l;
                            He ? E = ye + 1 : k = ye
                        }
                        return Zn(k, Me)
                    }

                    function T2(o, l) {
                        for (var f = -1, g = o.length, E = 0, k = []; ++f < g;) {
                            var L = o[f],
                                W = l ? l(L) : L;
                            if (!f || !hs(W, Q)) {
                                var Q = W;
                                k[E++] = L === 0 ? 0 : L
                            }
                        }
                        return k
                    }

                    function S2(o) {
                        return typeof o == "number" ? o : Mr(o) ? Ae : +o
                    }

                    function Rr(o) {
                        if (typeof o == "string") return o;
                        if (tt(o)) return tn(o, Rr) + "";
                        if (Mr(o)) return t2 ? t2.call(o) : "";
                        var l = o + "";
                        return l == "0" && 1 / o == -he ? "-0" : l
                    }

                    function Yi(o, l, f) {
                        var g = -1,
                            E = Ah,
                            k = o.length,
                            L = !0,
                            W = [],
                            Q = W;
                        if (f) L = !1, E = Km;
                        else if (k >= s) {
                            var _e = l ? null : P7(o);
                            if (_e) return kh(_e);
                            L = !1, E = El, Q = new Ho
                        } else Q = l ? [] : W;
                        e: for (; ++g < k;) {
                            var ye = o[g],
                                Te = l ? l(ye) : ye;
                            if (ye = f || ye !== 0 ? ye : 0, L && Te === Te) {
                                for (var Ie = Q.length; Ie--;)
                                    if (Q[Ie] === Te) continue e;
                                l && Q.push(Te), W.push(ye)
                            } else E(Q, Te, f) || (Q !== W && Q.push(Te), W.push(ye))
                        }
                        return W
                    }

                    function vg(o, l) {
                        return l = zi(l, o), o = X2(o, l), o == null || delete o[Bs(Yr(l))]
                    }

                    function w2(o, l, f, g) {
                        return xl(o, l, f(Yo(o, l)), g)
                    }

                    function Yh(o, l, f, g) {
                        for (var E = o.length, k = g ? E : -1;
                            (g ? k-- : ++k < E) && l(o[k], k, o););
                        return f ? Kr(o, g ? 0 : k, g ? k + 1 : E) : Kr(o, g ? k + 1 : 0, g ? E : k)
                    }

                    function O2(o, l) {
                        var f = o;
                        return f instanceof _t && (f = f.value()), Ym(l, function(g, E) {
                            return E.func.apply(E.thisArg, Gi([g], E.args))
                        }, f)
                    }

                    function bg(o, l, f) {
                        var g = o.length;
                        if (g < 2) return g ? Yi(o[0]) : [];
                        for (var E = -1, k = le(g); ++E < g;)
                            for (var L = o[E], W = -1; ++W < g;) W != E && (k[E] = kl(k[E] || L, o[W], l, f));
                        return Yi(Bn(k, 1), l, f)
                    }

                    function A2(o, l, f) {
                        for (var g = -1, E = o.length, k = l.length, L = {}; ++g < E;) {
                            var W = g < k ? l[g] : n;
                            f(L, o[g], W)
                        }
                        return L
                    }

                    function Eg(o) {
                        return fn(o) ? o : []
                    }

                    function Tg(o) {
                        return typeof o == "function" ? o : vr
                    }

                    function zi(o, l) {
                        return tt(o) ? o : xg(o, l) ? [o] : tE(xt(o))
                    }
                    var T7 = dt;

                    function Zi(o, l, f) {
                        var g = o.length;
                        return f = f === n ? g : f, !l && f >= g ? o : Kr(o, l, f)
                    }
                    var C2 = lN || function(o) {
                        return Un.clearTimeout(o)
                    };

                    function k2(o, l) {
                        if (l) return o.slice();
                        var f = o.length,
                            g = zb ? zb(f) : new o.constructor(f);
                        return o.copy(g), g
                    }

                    function Sg(o) {
                        var l = new o.constructor(o.byteLength);
                        return new Mh(l).set(new Mh(o)), l
                    }

                    function S7(o, l) {
                        var f = l ? Sg(o.buffer) : o.buffer;
                        return new o.constructor(f, o.byteOffset, o.byteLength)
                    }

                    function w7(o) {
                        var l = new o.constructor(o.source, hb.exec(o));
                        return l.lastIndex = o.lastIndex, l
                    }

                    function O7(o) {
                        return Al ? Lt(Al.call(o)) : {}
                    }

                    function I2(o, l) {
                        var f = l ? Sg(o.buffer) : o.buffer;
                        return new o.constructor(f, o.byteOffset, o.length)
                    }

                    function N2(o, l) {
                        if (o !== l) {
                            var f = o !== n,
                                g = o === null,
                                E = o === o,
                                k = Mr(o),
                                L = l !== n,
                                W = l === null,
                                Q = l === l,
                                _e = Mr(l);
                            if (!W && !_e && !k && o > l || k && L && Q && !W && !_e || g && L && Q || !f && Q || !E) return 1;
                            if (!g && !k && !_e && o < l || _e && f && E && !g && !k || W && f && E || !L && E || !Q) return -1
                        }
                        return 0
                    }

                    function A7(o, l, f) {
                        for (var g = -1, E = o.criteria, k = l.criteria, L = E.length, W = f.length; ++g < L;) {
                            var Q = N2(E[g], k[g]);
                            if (Q) {
                                if (g >= W) return Q;
                                var _e = f[g];
                                return Q * (_e == "desc" ? -1 : 1)
                            }
                        }
                        return o.index - l.index
                    }

                    function x2(o, l, f, g) {
                        for (var E = -1, k = o.length, L = f.length, W = -1, Q = l.length, _e = kn(k - L, 0), ye = le(Q + _e), Te = !g; ++W < Q;) ye[W] = l[W];
                        for (; ++E < L;)(Te || E < k) && (ye[f[E]] = o[E]);
                        for (; _e--;) ye[W++] = o[E++];
                        return ye
                    }

                    function P2(o, l, f, g) {
                        for (var E = -1, k = o.length, L = -1, W = f.length, Q = -1, _e = l.length, ye = kn(k - W, 0), Te = le(ye + _e), Ie = !g; ++E < ye;) Te[E] = o[E];
                        for (var $e = E; ++Q < _e;) Te[$e + Q] = l[Q];
                        for (; ++L < W;)(Ie || E < k) && (Te[$e + f[L]] = o[E++]);
                        return Te
                    }

                    function gr(o, l) {
                        var f = -1,
                            g = o.length;
                        for (l || (l = le(g)); ++f < g;) l[f] = o[f];
                        return l
                    }

                    function Us(o, l, f, g) {
                        var E = !f;
                        f || (f = {});
                        for (var k = -1, L = l.length; ++k < L;) {
                            var W = l[k],
                                Q = g ? g(f[W], o[W], W, f, o) : n;
                            Q === n && (Q = o[W]), E ? fi(f, W, Q) : Cl(f, W, Q)
                        }
                        return f
                    }

                    function C7(o, l) {
                        return Us(o, Ng(o), l)
                    }

                    function k7(o, l) {
                        return Us(o, W2(o), l)
                    }

                    function zh(o, l) {
                        return function(f, g) {
                            var E = tt(f) ? RI : ZN,
                                k = l ? l() : {};
                            return E(f, o, je(g, 2), k)
                        }
                    }

                    function Ka(o) {
                        return dt(function(l, f) {
                            var g = -1,
                                E = f.length,
                                k = E > 1 ? f[E - 1] : n,
                                L = E > 2 ? f[2] : n;
                            for (k = o.length > 3 && typeof k == "function" ? (E--, k) : n, L && ar(f[0], f[1], L) && (k = E < 3 ? n : k, E = 1), l = Lt(l); ++g < E;) {
                                var W = f[g];
                                W && o(l, W, g, k)
                            }
                            return l
                        })
                    }

                    function R2(o, l) {
                        return function(f, g) {
                            if (f == null) return f;
                            if (!_r(f)) return o(f, g);
                            for (var E = f.length, k = l ? E : -1, L = Lt(f);
                                (l ? k-- : ++k < E) && g(L[k], k, L) !== !1;);
                            return f
                        }
                    }

                    function M2(o) {
                        return function(l, f, g) {
                            for (var E = -1, k = Lt(l), L = g(l), W = L.length; W--;) {
                                var Q = L[o ? W : ++E];
                                if (f(k[Q], Q, k) === !1) break
                            }
                            return l
                        }
                    }

                    function I7(o, l, f) {
                        var g = l & w,
                            E = Pl(o);

                        function k() {
                            var L = this && this !== Un && this instanceof k ? E : o;
                            return L.apply(g ? f : this, arguments)
                        }
                        return k
                    }

                    function D2(o) {
                        return function(l) {
                            l = xt(l);
                            var f = Ba(l) ? ls(l) : n,
                                g = f ? f[0] : l.charAt(0),
                                E = f ? Zi(f, 1).join("") : l.slice(1);
                            return g[o]() + E
                        }
                    }

                    function Ya(o) {
                        return function(l) {
                            return Ym(RE(PE(l).replace(vI, "")), o, "")
                        }
                    }

                    function Pl(o) {
                        return function() {
                            var l = arguments;
                            switch (l.length) {
                                case 0:
                                    return new o;
                                case 1:
                                    return new o(l[0]);
                                case 2:
                                    return new o(l[0], l[1]);
                                case 3:
                                    return new o(l[0], l[1], l[2]);
                                case 4:
                                    return new o(l[0], l[1], l[2], l[3]);
                                case 5:
                                    return new o(l[0], l[1], l[2], l[3], l[4]);
                                case 6:
                                    return new o(l[0], l[1], l[2], l[3], l[4], l[5]);
                                case 7:
                                    return new o(l[0], l[1], l[2], l[3], l[4], l[5], l[6])
                            }
                            var f = Ha(o.prototype),
                                g = o.apply(f, l);
                            return an(g) ? g : f
                        }
                    }

                    function N7(o, l, f) {
                        var g = Pl(o);

                        function E() {
                            for (var k = arguments.length, L = le(k), W = k, Q = za(E); W--;) L[W] = arguments[W];
                            var _e = k < 3 && L[0] !== Q && L[k - 1] !== Q ? [] : Wi(L, Q);
                            if (k -= _e.length, k < f) return B2(o, l, Zh, E.placeholder, n, L, _e, n, n, f - k);
                            var ye = this && this !== Un && this instanceof E ? g : o;
                            return xr(ye, this, L)
                        }
                        return E
                    }

                    function $2(o) {
                        return function(l, f, g) {
                            var E = Lt(l);
                            if (!_r(l)) {
                                var k = je(f, 3);
                                l = Mn(l), f = function(W) {
                                    return k(E[W], W, E)
                                }
                            }
                            var L = o(l, f, g);
                            return L > -1 ? E[k ? l[L] : L] : n
                        }
                    }

                    function L2(o) {
                        return pi(function(l) {
                            var f = l.length,
                                g = f,
                                E = Wr.prototype.thru;
                            for (o && l.reverse(); g--;) {
                                var k = l[g];
                                if (typeof k != "function") throw new Gr(a);
                                if (E && !L && ef(k) == "wrapper") var L = new Wr([], !0)
                            }
                            for (g = L ? g : f; ++g < f;) {
                                k = l[g];
                                var W = ef(k),
                                    Q = W == "wrapper" ? kg(k) : n;
                                Q && Pg(Q[0]) && Q[1] == ($ | F | O | j) && !Q[4].length && Q[9] == 1 ? L = L[ef(Q[0])].apply(L, Q[3]) : L = k.length == 1 && Pg(k) ? L[W]() : L.thru(k)
                            }
                            return function() {
                                var _e = arguments,
                                    ye = _e[0];
                                if (L && _e.length == 1 && tt(ye)) return L.plant(ye).value();
                                for (var Te = 0, Ie = f ? l[Te].apply(this, _e) : ye; ++Te < f;) Ie = l[Te].call(this, Ie);
                                return Ie
                            }
                        })
                    }

                    function Zh(o, l, f, g, E, k, L, W, Q, _e) {
                        var ye = l & $,
                            Te = l & w,
                            Ie = l & b,
                            $e = l & (F | x),
                            We = l & ee,
                            ut = Ie ? n : Pl(o);

                        function He() {
                            for (var gt = arguments.length, Et = le(gt), Dr = gt; Dr--;) Et[Dr] = arguments[Dr];
                            if ($e) var cr = za(He),
                                $r = jI(Et, cr);
                            if (g && (Et = x2(Et, g, E, $e)), k && (Et = P2(Et, k, L, $e)), gt -= $r, $e && gt < _e) {
                                var dn = Wi(Et, cr);
                                return B2(o, l, Zh, He.placeholder, f, Et, dn, W, Q, _e - gt)
                            }
                            var fs = Te ? f : this,
                                yi = Ie ? fs[o] : o;
                            return gt = Et.length, W ? Et = Z7(Et, W) : We && gt > 1 && Et.reverse(), ye && Q < gt && (Et.length = Q), this && this !== Un && this instanceof He && (yi = ut || Pl(yi)), yi.apply(fs, Et)
                        }
                        return He
                    }

                    function F2(o, l) {
                        return function(f, g) {
                            return s7(f, o, l(g), {})
                        }
                    }

                    function Xh(o, l) {
                        return function(f, g) {
                            var E;
                            if (f === n && g === n) return l;
                            if (f !== n && (E = f), g !== n) {
                                if (E === n) return g;
                                typeof f == "string" || typeof g == "string" ? (f = Rr(f), g = Rr(g)) : (f = S2(f), g = S2(g)), E = o(f, g)
                            }
                            return E
                        }
                    }

                    function wg(o) {
                        return pi(function(l) {
                            return l = tn(l, Pr(je())), dt(function(f) {
                                var g = this;
                                return o(l, function(E) {
                                    return xr(E, g, f)
                                })
                            })
                        })
                    }

                    function Jh(o, l) {
                        l = l === n ? " " : Rr(l);
                        var f = l.length;
                        if (f < 2) return f ? _g(l, o) : l;
                        var g = _g(l, Fh(o / qa(l)));
                        return Ba(l) ? Zi(ls(g), 0, o).join("") : g.slice(0, o)
                    }

                    function x7(o, l, f, g) {
                        var E = l & w,
                            k = Pl(o);

                        function L() {
                            for (var W = -1, Q = arguments.length, _e = -1, ye = g.length, Te = le(ye + Q), Ie = this && this !== Un && this instanceof L ? k : o; ++_e < ye;) Te[_e] = g[_e];
                            for (; Q--;) Te[_e++] = arguments[++W];
                            return xr(Ie, E ? f : this, Te)
                        }
                        return L
                    }

                    function U2(o) {
                        return function(l, f, g) {
                            return g && typeof g != "number" && ar(l, f, g) && (f = g = n), l = _i(l), f === n ? (f = l, l = 0) : f = _i(f), g = g === n ? l < f ? 1 : -1 : _i(g), g7(l, f, g, o)
                        }
                    }

                    function Qh(o) {
                        return function(l, f) {
                            return typeof l == "string" && typeof f == "string" || (l = zr(l), f = zr(f)), o(l, f)
                        }
                    }

                    function B2(o, l, f, g, E, k, L, W, Q, _e) {
                        var ye = l & F,
                            Te = ye ? L : n,
                            Ie = ye ? n : L,
                            $e = ye ? k : n,
                            We = ye ? n : k;
                        l |= ye ? O : M, l &= ~(ye ? M : O), l & I || (l &= ~(w | b));
                        var ut = [o, l, E, $e, Te, We, Ie, W, Q, _e],
                            He = f.apply(n, ut);
                        return Pg(o) && J2(He, ut), He.placeholder = g, Q2(He, o, l)
                    }

                    function Og(o) {
                        var l = Cn[o];
                        return function(f, g) {
                            if (f = zr(f), g = g == null ? 0 : Zn(ct(g), 292), g && Qb(f)) {
                                var E = (xt(f) + "e").split("e"),
                                    k = l(E[0] + "e" + (+E[1] + g));
                                return E = (xt(k) + "e").split("e"), +(E[0] + "e" + (+E[1] - g))
                            }
                            return l(f)
                        }
                    }
                    var P7 = Ga && 1 / kh(new Ga([, -0]))[1] == he ? function(o) {
                        return new Ga(o)
                    } : Kg;

                    function q2(o) {
                        return function(l) {
                            var f = Xn(l);
                            return f == S ? tg(l) : f == ce ? zI(l) : qI(l, o(l))
                        }
                    }

                    function di(o, l, f, g, E, k, L, W) {
                        var Q = l & b;
                        if (!Q && typeof o != "function") throw new Gr(a);
                        var _e = g ? g.length : 0;
                        if (_e || (l &= ~(O | M), g = E = n), L = L === n ? L : kn(ct(L), 0), W = W === n ? W : ct(W), _e -= E ? E.length : 0, l & M) {
                            var ye = g,
                                Te = E;
                            g = E = n
                        }
                        var Ie = Q ? n : kg(o),
                            $e = [o, l, f, g, E, ye, Te, k, L, W];
                        if (Ie && K7($e, Ie), o = $e[0], l = $e[1], f = $e[2], g = $e[3], E = $e[4], W = $e[9] = $e[9] === n ? Q ? 0 : o.length : kn($e[9] - _e, 0), !W && l & (F | x) && (l &= ~(F | x)), !l || l == w) var We = I7(o, l, f);
                        else l == F || l == x ? We = N7(o, l, W) : (l == O || l == (w | O)) && !E.length ? We = x7(o, l, f, g) : We = Zh.apply(n, $e);
                        var ut = Ie ? E2 : J2;
                        return Q2(ut(We, $e), o, l)
                    }

                    function j2(o, l, f, g) {
                        return o === n || hs(o, Va[f]) && !Rt.call(g, f) ? l : o
                    }

                    function V2(o, l, f, g, E, k) {
                        return an(o) && an(l) && (k.set(l, o), Hh(o, l, n, V2, k), k.delete(l)), o
                    }

                    function R7(o) {
                        return Dl(o) ? n : o
                    }

                    function G2(o, l, f, g, E, k) {
                        var L = f & y,
                            W = o.length,
                            Q = l.length;
                        if (W != Q && !(L && Q > W)) return !1;
                        var _e = k.get(o),
                            ye = k.get(l);
                        if (_e && ye) return _e == l && ye == o;
                        var Te = -1,
                            Ie = !0,
                            $e = f & v ? new Ho : n;
                        for (k.set(o, l), k.set(l, o); ++Te < W;) {
                            var We = o[Te],
                                ut = l[Te];
                            if (g) var He = L ? g(ut, We, Te, l, o, k) : g(We, ut, Te, o, l, k);
                            if (He !== n) {
                                if (He) continue;
                                Ie = !1;
                                break
                            }
                            if ($e) {
                                if (!zm(l, function(gt, Et) {
                                        if (!El($e, Et) && (We === gt || E(We, gt, f, g, k))) return $e.push(Et)
                                    })) {
                                    Ie = !1;
                                    break
                                }
                            } else if (!(We === ut || E(We, ut, f, g, k))) {
                                Ie = !1;
                                break
                            }
                        }
                        return k.delete(o), k.delete(l), Ie
                    }

                    function M7(o, l, f, g, E, k, L) {
                        switch (f) {
                            case D:
                                if (o.byteLength != l.byteLength || o.byteOffset != l.byteOffset) return !1;
                                o = o.buffer, l = l.buffer;
                            case ft:
                                return !(o.byteLength != l.byteLength || !k(new Mh(o), new Mh(l)));
                            case ke:
                            case rt:
                            case N:
                                return hs(+o, +l);
                            case zt:
                                return o.name == l.name && o.message == l.message;
                            case pe:
                            case J:
                                return o == l + "";
                            case S:
                                var W = tg;
                            case ce:
                                var Q = g & y;
                                if (W || (W = kh), o.size != l.size && !Q) return !1;
                                var _e = L.get(o);
                                if (_e) return _e == l;
                                g |= v, L.set(o, l);
                                var ye = G2(W(o), W(l), g, E, k, L);
                                return L.delete(o), ye;
                            case ne:
                                if (Al) return Al.call(o) == Al.call(l)
                        }
                        return !1
                    }

                    function D7(o, l, f, g, E, k) {
                        var L = f & y,
                            W = Ag(o),
                            Q = W.length,
                            _e = Ag(l),
                            ye = _e.length;
                        if (Q != ye && !L) return !1;
                        for (var Te = Q; Te--;) {
                            var Ie = W[Te];
                            if (!(L ? Ie in l : Rt.call(l, Ie))) return !1
                        }
                        var $e = k.get(o),
                            We = k.get(l);
                        if ($e && We) return $e == l && We == o;
                        var ut = !0;
                        k.set(o, l), k.set(l, o);
                        for (var He = L; ++Te < Q;) {
                            Ie = W[Te];
                            var gt = o[Ie],
                                Et = l[Ie];
                            if (g) var Dr = L ? g(Et, gt, Ie, l, o, k) : g(gt, Et, Ie, o, l, k);
                            if (!(Dr === n ? gt === Et || E(gt, Et, f, g, k) : Dr)) {
                                ut = !1;
                                break
                            }
                            He || (He = Ie == "constructor")
                        }
                        if (ut && !He) {
                            var cr = o.constructor,
                                $r = l.constructor;
                            cr != $r && "constructor" in o && "constructor" in l && !(typeof cr == "function" && cr instanceof cr && typeof $r == "function" && $r instanceof $r) && (ut = !1)
                        }
                        return k.delete(o), k.delete(l), ut
                    }

                    function pi(o) {
                        return Mg(Z2(o, n, iE), o + "")
                    }

                    function Ag(o) {
                        return u2(o, Mn, Ng)
                    }

                    function Cg(o) {
                        return u2(o, yr, W2)
                    }
                    var kg = Bh ? function(o) {
                        return Bh.get(o)
                    } : Kg;

                    function ef(o) {
                        for (var l = o.name + "", f = Wa[l], g = Rt.call(Wa, l) ? f.length : 0; g--;) {
                            var E = f[g],
                                k = E.func;
                            if (k == null || k == o) return E.name
                        }
                        return l
                    }

                    function za(o) {
                        var l = Rt.call(A, "placeholder") ? A : o;
                        return l.placeholder
                    }

                    function je() {
                        var o = A.iteratee || Wg;
                        return o = o === Wg ? d2 : o, arguments.length ? o(arguments[0], arguments[1]) : o
                    }

                    function tf(o, l) {
                        var f = o.__data__;
                        return V7(l) ? f[typeof l == "string" ? "string" : "hash"] : f.map
                    }

                    function Ig(o) {
                        for (var l = Mn(o), f = l.length; f--;) {
                            var g = l[f],
                                E = o[g];
                            l[f] = [g, E, Y2(E)]
                        }
                        return l
                    }

                    function zo(o, l) {
                        var f = HI(o, l);
                        return f2(f) ? f : n
                    }

                    function $7(o) {
                        var l = Rt.call(o, Go),
                            f = o[Go];
                        try {
                            o[Go] = n;
                            var g = !0
                        } catch {}
                        var E = Ph.call(o);
                        return g && (l ? o[Go] = f : delete o[Go]), E
                    }
                    var Ng = rg ? function(o) {
                            return o == null ? [] : (o = Lt(o), Vi(rg(o), function(l) {
                                return Xb.call(o, l)
                            }))
                        } : Yg,
                        W2 = rg ? function(o) {
                            for (var l = []; o;) Gi(l, Ng(o)), o = Dh(o);
                            return l
                        } : Yg,
                        Xn = or;
                    (sg && Xn(new sg(new ArrayBuffer(1))) != D || Sl && Xn(new Sl) != S || ig && Xn(ig.resolve()) != re || Ga && Xn(new Ga) != ce || wl && Xn(new wl) != Pe) && (Xn = function(o) {
                        var l = or(o),
                            f = l == te ? o.constructor : n,
                            g = f ? Zo(f) : "";
                        if (g) switch (g) {
                            case yN:
                                return D;
                            case vN:
                                return S;
                            case bN:
                                return re;
                            case EN:
                                return ce;
                            case TN:
                                return Pe
                        }
                        return l
                    });

                    function L7(o, l, f) {
                        for (var g = -1, E = f.length; ++g < E;) {
                            var k = f[g],
                                L = k.size;
                            switch (k.type) {
                                case "drop":
                                    o += L;
                                    break;
                                case "dropRight":
                                    l -= L;
                                    break;
                                case "take":
                                    l = Zn(l, o + L);
                                    break;
                                case "takeRight":
                                    o = kn(o, l - L);
                                    break
                            }
                        }
                        return {
                            start: o,
                            end: l
                        }
                    }

                    function F7(o) {
                        var l = o.match(G6);
                        return l ? l[1].split(W6) : []
                    }

                    function H2(o, l, f) {
                        l = zi(l, o);
                        for (var g = -1, E = l.length, k = !1; ++g < E;) {
                            var L = Bs(l[g]);
                            if (!(k = o != null && f(o, L))) break;
                            o = o[L]
                        }
                        return k || ++g != E ? k : (E = o == null ? 0 : o.length, !!E && lf(E) && mi(L, E) && (tt(o) || Xo(o)))
                    }

                    function U7(o) {
                        var l = o.length,
                            f = new o.constructor(l);
                        return l && typeof o[0] == "string" && Rt.call(o, "index") && (f.index = o.index, f.input = o.input), f
                    }

                    function K2(o) {
                        return typeof o.constructor == "function" && !Rl(o) ? Ha(Dh(o)) : {}
                    }

                    function B7(o, l, f) {
                        var g = o.constructor;
                        switch (l) {
                            case ft:
                                return Sg(o);
                            case ke:
                            case rt:
                                return new g(+o);
                            case D:
                                return S7(o, f);
                            case P:
                            case z:
                            case R:
                            case K:
                            case me:
                            case Ee:
                            case Ce:
                            case De:
                            case hn:
                                return I2(o, f);
                            case S:
                                return new g;
                            case N:
                            case J:
                                return new g(o);
                            case pe:
                                return w7(o);
                            case ce:
                                return new g;
                            case ne:
                                return O7(o)
                        }
                    }

                    function q7(o, l) {
                        var f = l.length;
                        if (!f) return o;
                        var g = f - 1;
                        return l[g] = (f > 1 ? "& " : "") + l[g], l = l.join(f > 2 ? ", " : " "), o.replace(V6, `{
/* [wrapped with ` + l + `] */
`)
                    }

                    function j7(o) {
                        return tt(o) || Xo(o) || !!(Jb && o && o[Jb])
                    }

                    function mi(o, l) {
                        var f = typeof o;
                        return l = l ?? ve, !!l && (f == "number" || f != "symbol" && eI.test(o)) && o > -1 && o % 1 == 0 && o < l
                    }

                    function ar(o, l, f) {
                        if (!an(f)) return !1;
                        var g = typeof l;
                        return (g == "number" ? _r(f) && mi(l, f.length) : g == "string" && l in f) ? hs(f[l], o) : !1
                    }

                    function xg(o, l) {
                        if (tt(o)) return !1;
                        var f = typeof o;
                        return f == "number" || f == "symbol" || f == "boolean" || o == null || Mr(o) ? !0 : U6.test(o) || !F6.test(o) || l != null && o in Lt(l)
                    }

                    function V7(o) {
                        var l = typeof o;
                        return l == "string" || l == "number" || l == "symbol" || l == "boolean" ? o !== "__proto__" : o === null
                    }

                    function Pg(o) {
                        var l = ef(o),
                            f = A[l];
                        if (typeof f != "function" || !(l in _t.prototype)) return !1;
                        if (o === f) return !0;
                        var g = kg(f);
                        return !!g && o === g[0]
                    }

                    function G7(o) {
                        return !!Yb && Yb in o
                    }
                    var W7 = Nh ? gi : zg;

                    function Rl(o) {
                        var l = o && o.constructor,
                            f = typeof l == "function" && l.prototype || Va;
                        return o === f
                    }

                    function Y2(o) {
                        return o === o && !an(o)
                    }

                    function z2(o, l) {
                        return function(f) {
                            return f == null ? !1 : f[o] === l && (l !== n || o in Lt(f))
                        }
                    }

                    function H7(o) {
                        var l = af(o, function(g) {
                                return f.size === h && f.clear(), g
                            }),
                            f = l.cache;
                        return l
                    }

                    function K7(o, l) {
                        var f = o[1],
                            g = l[1],
                            E = f | g,
                            k = E < (w | b | $),
                            L = g == $ && f == F || g == $ && f == j && o[7].length <= l[8] || g == ($ | j) && l[7].length <= l[8] && f == F;
                        if (!(k || L)) return o;
                        g & w && (o[2] = l[2], E |= f & w ? 0 : I);
                        var W = l[3];
                        if (W) {
                            var Q = o[3];
                            o[3] = Q ? x2(Q, W, l[4]) : W, o[4] = Q ? Wi(o[3], d) : l[4]
                        }
                        return W = l[5], W && (Q = o[5], o[5] = Q ? P2(Q, W, l[6]) : W, o[6] = Q ? Wi(o[5], d) : l[6]), W = l[7], W && (o[7] = W), g & $ && (o[8] = o[8] == null ? l[8] : Zn(o[8], l[8])), o[9] == null && (o[9] = l[9]), o[0] = l[0], o[1] = E, o
                    }

                    function Y7(o) {
                        var l = [];
                        if (o != null)
                            for (var f in Lt(o)) l.push(f);
                        return l
                    }

                    function z7(o) {
                        return Ph.call(o)
                    }

                    function Z2(o, l, f) {
                        return l = kn(l === n ? o.length - 1 : l, 0),
                            function() {
                                for (var g = arguments, E = -1, k = kn(g.length - l, 0), L = le(k); ++E < k;) L[E] = g[l + E];
                                E = -1;
                                for (var W = le(l + 1); ++E < l;) W[E] = g[E];
                                return W[l] = f(L), xr(o, this, W)
                            }
                    }

                    function X2(o, l) {
                        return l.length < 2 ? o : Yo(o, Kr(l, 0, -1))
                    }

                    function Z7(o, l) {
                        for (var f = o.length, g = Zn(l.length, f), E = gr(o); g--;) {
                            var k = l[g];
                            o[g] = mi(k, f) ? E[k] : n
                        }
                        return o
                    }

                    function Rg(o, l) {
                        if (!(l === "constructor" && typeof o[l] == "function") && l != "__proto__") return o[l]
                    }
                    var J2 = eE(E2),
                        Ml = hN || function(o, l) {
                            return Un.setTimeout(o, l)
                        },
                        Mg = eE(v7);

                    function Q2(o, l, f) {
                        var g = l + "";
                        return Mg(o, q7(g, X7(F7(g), f)))
                    }

                    function eE(o) {
                        var l = 0,
                            f = 0;
                        return function() {
                            var g = mN(),
                                E = de - (g - f);
                            if (f = g, E > 0) {
                                if (++l >= Z) return arguments[0]
                            } else l = 0;
                            return o.apply(n, arguments)
                        }
                    }

                    function nf(o, l) {
                        var f = -1,
                            g = o.length,
                            E = g - 1;
                        for (l = l === n ? g : l; ++f < l;) {
                            var k = gg(f, E),
                                L = o[k];
                            o[k] = o[f], o[f] = L
                        }
                        return o.length = l, o
                    }
                    var tE = H7(function(o) {
                        var l = [];
                        return o.charCodeAt(0) === 46 && l.push(""), o.replace(B6, function(f, g, E, k) {
                            l.push(E ? k.replace(Y6, "$1") : g || f)
                        }), l
                    });

                    function Bs(o) {
                        if (typeof o == "string" || Mr(o)) return o;
                        var l = o + "";
                        return l == "0" && 1 / o == -he ? "-0" : l
                    }

                    function Zo(o) {
                        if (o != null) {
                            try {
                                return xh.call(o)
                            } catch {}
                            try {
                                return o + ""
                            } catch {}
                        }
                        return ""
                    }

                    function X7(o, l) {
                        return Vr(jt, function(f) {
                            var g = "_." + f[0];
                            l & f[1] && !Ah(o, g) && o.push(g)
                        }), o.sort()
                    }

                    function nE(o) {
                        if (o instanceof _t) return o.clone();
                        var l = new Wr(o.__wrapped__, o.__chain__);
                        return l.__actions__ = gr(o.__actions__), l.__index__ = o.__index__, l.__values__ = o.__values__, l
                    }

                    function J7(o, l, f) {
                        (f ? ar(o, l, f) : l === n) ? l = 1: l = kn(ct(l), 0);
                        var g = o == null ? 0 : o.length;
                        if (!g || l < 1) return [];
                        for (var E = 0, k = 0, L = le(Fh(g / l)); E < g;) L[k++] = Kr(o, E, E += l);
                        return L
                    }

                    function Q7(o) {
                        for (var l = -1, f = o == null ? 0 : o.length, g = 0, E = []; ++l < f;) {
                            var k = o[l];
                            k && (E[g++] = k)
                        }
                        return E
                    }

                    function ex() {
                        var o = arguments.length;
                        if (!o) return [];
                        for (var l = le(o - 1), f = arguments[0], g = o; g--;) l[g - 1] = arguments[g];
                        return Gi(tt(f) ? gr(f) : [f], Bn(l, 1))
                    }
                    var tx = dt(function(o, l) {
                            return fn(o) ? kl(o, Bn(l, 1, fn, !0)) : []
                        }),
                        nx = dt(function(o, l) {
                            var f = Yr(l);
                            return fn(f) && (f = n), fn(o) ? kl(o, Bn(l, 1, fn, !0), je(f, 2)) : []
                        }),
                        rx = dt(function(o, l) {
                            var f = Yr(l);
                            return fn(f) && (f = n), fn(o) ? kl(o, Bn(l, 1, fn, !0), n, f) : []
                        });

                    function sx(o, l, f) {
                        var g = o == null ? 0 : o.length;
                        return g ? (l = f || l === n ? 1 : ct(l), Kr(o, l < 0 ? 0 : l, g)) : []
                    }

                    function ix(o, l, f) {
                        var g = o == null ? 0 : o.length;
                        return g ? (l = f || l === n ? 1 : ct(l), l = g - l, Kr(o, 0, l < 0 ? 0 : l)) : []
                    }

                    function ox(o, l) {
                        return o && o.length ? Yh(o, je(l, 3), !0, !0) : []
                    }

                    function ax(o, l) {
                        return o && o.length ? Yh(o, je(l, 3), !0) : []
                    }

                    function cx(o, l, f, g) {
                        var E = o == null ? 0 : o.length;
                        return E ? (f && typeof f != "number" && ar(o, l, f) && (f = 0, g = E), e7(o, l, f, g)) : []
                    }

                    function rE(o, l, f) {
                        var g = o == null ? 0 : o.length;
                        if (!g) return -1;
                        var E = f == null ? 0 : ct(f);
                        return E < 0 && (E = kn(g + E, 0)), Ch(o, je(l, 3), E)
                    }

                    function sE(o, l, f) {
                        var g = o == null ? 0 : o.length;
                        if (!g) return -1;
                        var E = g - 1;
                        return f !== n && (E = ct(f), E = f < 0 ? kn(g + E, 0) : Zn(E, g - 1)), Ch(o, je(l, 3), E, !0)
                    }

                    function iE(o) {
                        var l = o == null ? 0 : o.length;
                        return l ? Bn(o, 1) : []
                    }

                    function lx(o) {
                        var l = o == null ? 0 : o.length;
                        return l ? Bn(o, he) : []
                    }

                    function ux(o, l) {
                        var f = o == null ? 0 : o.length;
                        return f ? (l = l === n ? 1 : ct(l), Bn(o, l)) : []
                    }

                    function hx(o) {
                        for (var l = -1, f = o == null ? 0 : o.length, g = {}; ++l < f;) {
                            var E = o[l];
                            g[E[0]] = E[1]
                        }
                        return g
                    }

                    function oE(o) {
                        return o && o.length ? o[0] : n
                    }

                    function fx(o, l, f) {
                        var g = o == null ? 0 : o.length;
                        if (!g) return -1;
                        var E = f == null ? 0 : ct(f);
                        return E < 0 && (E = kn(g + E, 0)), Ua(o, l, E)
                    }

                    function dx(o) {
                        var l = o == null ? 0 : o.length;
                        return l ? Kr(o, 0, -1) : []
                    }
                    var px = dt(function(o) {
                            var l = tn(o, Eg);
                            return l.length && l[0] === o[0] ? hg(l) : []
                        }),
                        mx = dt(function(o) {
                            var l = Yr(o),
                                f = tn(o, Eg);
                            return l === Yr(f) ? l = n : f.pop(), f.length && f[0] === o[0] ? hg(f, je(l, 2)) : []
                        }),
                        gx = dt(function(o) {
                            var l = Yr(o),
                                f = tn(o, Eg);
                            return l = typeof l == "function" ? l : n, l && f.pop(), f.length && f[0] === o[0] ? hg(f, n, l) : []
                        });

                    function _x(o, l) {
                        return o == null ? "" : dN.call(o, l)
                    }

                    function Yr(o) {
                        var l = o == null ? 0 : o.length;
                        return l ? o[l - 1] : n
                    }

                    function yx(o, l, f) {
                        var g = o == null ? 0 : o.length;
                        if (!g) return -1;
                        var E = g;
                        return f !== n && (E = ct(f), E = E < 0 ? kn(g + E, 0) : Zn(E, g - 1)), l === l ? XI(o, l, E) : Ch(o, Bb, E, !0)
                    }

                    function vx(o, l) {
                        return o && o.length ? _2(o, ct(l)) : n
                    }
                    var bx = dt(aE);

                    function aE(o, l) {
                        return o && o.length && l && l.length ? mg(o, l) : o
                    }

                    function Ex(o, l, f) {
                        return o && o.length && l && l.length ? mg(o, l, je(f, 2)) : o
                    }

                    function Tx(o, l, f) {
                        return o && o.length && l && l.length ? mg(o, l, n, f) : o
                    }
                    var Sx = pi(function(o, l) {
                        var f = o == null ? 0 : o.length,
                            g = ag(o, l);
                        return b2(o, tn(l, function(E) {
                            return mi(E, f) ? +E : E
                        }).sort(N2)), g
                    });

                    function wx(o, l) {
                        var f = [];
                        if (!(o && o.length)) return f;
                        var g = -1,
                            E = [],
                            k = o.length;
                        for (l = je(l, 3); ++g < k;) {
                            var L = o[g];
                            l(L, g, o) && (f.push(L), E.push(g))
                        }
                        return b2(o, E), f
                    }

                    function Dg(o) {
                        return o == null ? o : _N.call(o)
                    }

                    function Ox(o, l, f) {
                        var g = o == null ? 0 : o.length;
                        return g ? (f && typeof f != "number" && ar(o, l, f) ? (l = 0, f = g) : (l = l == null ? 0 : ct(l), f = f === n ? g : ct(f)), Kr(o, l, f)) : []
                    }

                    function Ax(o, l) {
                        return Kh(o, l)
                    }

                    function Cx(o, l, f) {
                        return yg(o, l, je(f, 2))
                    }

                    function kx(o, l) {
                        var f = o == null ? 0 : o.length;
                        if (f) {
                            var g = Kh(o, l);
                            if (g < f && hs(o[g], l)) return g
                        }
                        return -1
                    }

                    function Ix(o, l) {
                        return Kh(o, l, !0)
                    }

                    function Nx(o, l, f) {
                        return yg(o, l, je(f, 2), !0)
                    }

                    function xx(o, l) {
                        var f = o == null ? 0 : o.length;
                        if (f) {
                            var g = Kh(o, l, !0) - 1;
                            if (hs(o[g], l)) return g
                        }
                        return -1
                    }

                    function Px(o) {
                        return o && o.length ? T2(o) : []
                    }

                    function Rx(o, l) {
                        return o && o.length ? T2(o, je(l, 2)) : []
                    }

                    function Mx(o) {
                        var l = o == null ? 0 : o.length;
                        return l ? Kr(o, 1, l) : []
                    }

                    function Dx(o, l, f) {
                        return o && o.length ? (l = f || l === n ? 1 : ct(l), Kr(o, 0, l < 0 ? 0 : l)) : []
                    }

                    function $x(o, l, f) {
                        var g = o == null ? 0 : o.length;
                        return g ? (l = f || l === n ? 1 : ct(l), l = g - l, Kr(o, l < 0 ? 0 : l, g)) : []
                    }

                    function Lx(o, l) {
                        return o && o.length ? Yh(o, je(l, 3), !1, !0) : []
                    }

                    function Fx(o, l) {
                        return o && o.length ? Yh(o, je(l, 3)) : []
                    }
                    var Ux = dt(function(o) {
                            return Yi(Bn(o, 1, fn, !0))
                        }),
                        Bx = dt(function(o) {
                            var l = Yr(o);
                            return fn(l) && (l = n), Yi(Bn(o, 1, fn, !0), je(l, 2))
                        }),
                        qx = dt(function(o) {
                            var l = Yr(o);
                            return l = typeof l == "function" ? l : n, Yi(Bn(o, 1, fn, !0), n, l)
                        });

                    function jx(o) {
                        return o && o.length ? Yi(o) : []
                    }

                    function Vx(o, l) {
                        return o && o.length ? Yi(o, je(l, 2)) : []
                    }

                    function Gx(o, l) {
                        return l = typeof l == "function" ? l : n, o && o.length ? Yi(o, n, l) : []
                    }

                    function $g(o) {
                        if (!(o && o.length)) return [];
                        var l = 0;
                        return o = Vi(o, function(f) {
                            if (fn(f)) return l = kn(f.length, l), !0
                        }), Qm(l, function(f) {
                            return tn(o, Zm(f))
                        })
                    }

                    function cE(o, l) {
                        if (!(o && o.length)) return [];
                        var f = $g(o);
                        return l == null ? f : tn(f, function(g) {
                            return xr(l, n, g)
                        })
                    }
                    var Wx = dt(function(o, l) {
                            return fn(o) ? kl(o, l) : []
                        }),
                        Hx = dt(function(o) {
                            return bg(Vi(o, fn))
                        }),
                        Kx = dt(function(o) {
                            var l = Yr(o);
                            return fn(l) && (l = n), bg(Vi(o, fn), je(l, 2))
                        }),
                        Yx = dt(function(o) {
                            var l = Yr(o);
                            return l = typeof l == "function" ? l : n, bg(Vi(o, fn), n, l)
                        }),
                        zx = dt($g);

                    function Zx(o, l) {
                        return A2(o || [], l || [], Cl)
                    }

                    function Xx(o, l) {
                        return A2(o || [], l || [], xl)
                    }
                    var Jx = dt(function(o) {
                        var l = o.length,
                            f = l > 1 ? o[l - 1] : n;
                        return f = typeof f == "function" ? (o.pop(), f) : n, cE(o, f)
                    });

                    function lE(o) {
                        var l = A(o);
                        return l.__chain__ = !0, l
                    }

                    function Qx(o, l) {
                        return l(o), o
                    }

                    function rf(o, l) {
                        return l(o)
                    }
                    var e8 = pi(function(o) {
                        var l = o.length,
                            f = l ? o[0] : 0,
                            g = this.__wrapped__,
                            E = function(k) {
                                return ag(k, o)
                            };
                        return l > 1 || this.__actions__.length || !(g instanceof _t) || !mi(f) ? this.thru(E) : (g = g.slice(f, +f + (l ? 1 : 0)), g.__actions__.push({
                            func: rf,
                            args: [E],
                            thisArg: n
                        }), new Wr(g, this.__chain__).thru(function(k) {
                            return l && !k.length && k.push(n), k
                        }))
                    });

                    function t8() {
                        return lE(this)
                    }

                    function n8() {
                        return new Wr(this.value(), this.__chain__)
                    }

                    function r8() {
                        this.__values__ === n && (this.__values__ = SE(this.value()));
                        var o = this.__index__ >= this.__values__.length,
                            l = o ? n : this.__values__[this.__index__++];
                        return {
                            done: o,
                            value: l
                        }
                    }

                    function s8() {
                        return this
                    }

                    function i8(o) {
                        for (var l, f = this; f instanceof jh;) {
                            var g = nE(f);
                            g.__index__ = 0, g.__values__ = n, l ? E.__wrapped__ = g : l = g;
                            var E = g;
                            f = f.__wrapped__
                        }
                        return E.__wrapped__ = o, l
                    }

                    function o8() {
                        var o = this.__wrapped__;
                        if (o instanceof _t) {
                            var l = o;
                            return this.__actions__.length && (l = new _t(this)), l = l.reverse(), l.__actions__.push({
                                func: rf,
                                args: [Dg],
                                thisArg: n
                            }), new Wr(l, this.__chain__)
                        }
                        return this.thru(Dg)
                    }

                    function a8() {
                        return O2(this.__wrapped__, this.__actions__)
                    }
                    var c8 = zh(function(o, l, f) {
                        Rt.call(o, f) ? ++o[f] : fi(o, f, 1)
                    });

                    function l8(o, l, f) {
                        var g = tt(o) ? Fb : QN;
                        return f && ar(o, l, f) && (l = n), g(o, je(l, 3))
                    }

                    function u8(o, l) {
                        var f = tt(o) ? Vi : c2;
                        return f(o, je(l, 3))
                    }
                    var h8 = $2(rE),
                        f8 = $2(sE);

                    function d8(o, l) {
                        return Bn(sf(o, l), 1)
                    }

                    function p8(o, l) {
                        return Bn(sf(o, l), he)
                    }

                    function m8(o, l, f) {
                        return f = f === n ? 1 : ct(f), Bn(sf(o, l), f)
                    }

                    function uE(o, l) {
                        var f = tt(o) ? Vr : Ki;
                        return f(o, je(l, 3))
                    }

                    function hE(o, l) {
                        var f = tt(o) ? MI : a2;
                        return f(o, je(l, 3))
                    }
                    var g8 = zh(function(o, l, f) {
                        Rt.call(o, f) ? o[f].push(l) : fi(o, f, [l])
                    });

                    function _8(o, l, f, g) {
                        o = _r(o) ? o : Xa(o), f = f && !g ? ct(f) : 0;
                        var E = o.length;
                        return f < 0 && (f = kn(E + f, 0)), uf(o) ? f <= E && o.indexOf(l, f) > -1 : !!E && Ua(o, l, f) > -1
                    }
                    var y8 = dt(function(o, l, f) {
                            var g = -1,
                                E = typeof l == "function",
                                k = _r(o) ? le(o.length) : [];
                            return Ki(o, function(L) {
                                k[++g] = E ? xr(l, L, f) : Il(L, l, f)
                            }), k
                        }),
                        v8 = zh(function(o, l, f) {
                            fi(o, f, l)
                        });

                    function sf(o, l) {
                        var f = tt(o) ? tn : p2;
                        return f(o, je(l, 3))
                    }

                    function b8(o, l, f, g) {
                        return o == null ? [] : (tt(l) || (l = l == null ? [] : [l]), f = g ? n : f, tt(f) || (f = f == null ? [] : [f]), y2(o, l, f))
                    }
                    var E8 = zh(function(o, l, f) {
                        o[f ? 0 : 1].push(l)
                    }, function() {
                        return [
                            [],
                            []
                        ]
                    });

                    function T8(o, l, f) {
                        var g = tt(o) ? Ym : jb,
                            E = arguments.length < 3;
                        return g(o, je(l, 4), f, E, Ki)
                    }

                    function S8(o, l, f) {
                        var g = tt(o) ? DI : jb,
                            E = arguments.length < 3;
                        return g(o, je(l, 4), f, E, a2)
                    }

                    function w8(o, l) {
                        var f = tt(o) ? Vi : c2;
                        return f(o, cf(je(l, 3)))
                    }

                    function O8(o) {
                        var l = tt(o) ? r2 : _7;
                        return l(o)
                    }

                    function A8(o, l, f) {
                        (f ? ar(o, l, f) : l === n) ? l = 1: l = ct(l);
                        var g = tt(o) ? YN : y7;
                        return g(o, l)
                    }

                    function C8(o) {
                        var l = tt(o) ? zN : b7;
                        return l(o)
                    }

                    function k8(o) {
                        if (o == null) return 0;
                        if (_r(o)) return uf(o) ? qa(o) : o.length;
                        var l = Xn(o);
                        return l == S || l == ce ? o.size : dg(o).length
                    }

                    function I8(o, l, f) {
                        var g = tt(o) ? zm : E7;
                        return f && ar(o, l, f) && (l = n), g(o, je(l, 3))
                    }
                    var N8 = dt(function(o, l) {
                            if (o == null) return [];
                            var f = l.length;
                            return f > 1 && ar(o, l[0], l[1]) ? l = [] : f > 2 && ar(l[0], l[1], l[2]) && (l = [l[0]]), y2(o, Bn(l, 1), [])
                        }),
                        of = uN || function() {
                            return Un.Date.now()
                        };

                    function x8(o, l) {
                        if (typeof l != "function") throw new Gr(a);
                        return o = ct(o),
                            function() {
                                if (--o < 1) return l.apply(this, arguments)
                            }
                    }

                    function fE(o, l, f) {
                        return l = f ? n : l, l = o && l == null ? o.length : l, di(o, $, n, n, n, n, l)
                    }

                    function dE(o, l) {
                        var f;
                        if (typeof l != "function") throw new Gr(a);
                        return o = ct(o),
                            function() {
                                return --o > 0 && (f = l.apply(this, arguments)), o <= 1 && (l = n), f
                            }
                    }
                    var Lg = dt(function(o, l, f) {
                            var g = w;
                            if (f.length) {
                                var E = Wi(f, za(Lg));
                                g |= O
                            }
                            return di(o, g, l, f, E)
                        }),
                        pE = dt(function(o, l, f) {
                            var g = w | b;
                            if (f.length) {
                                var E = Wi(f, za(pE));
                                g |= O
                            }
                            return di(l, g, o, f, E)
                        });

                    function mE(o, l, f) {
                        l = f ? n : l;
                        var g = di(o, F, n, n, n, n, n, l);
                        return g.placeholder = mE.placeholder, g
                    }

                    function gE(o, l, f) {
                        l = f ? n : l;
                        var g = di(o, x, n, n, n, n, n, l);
                        return g.placeholder = gE.placeholder, g
                    }

                    function _E(o, l, f) {
                        var g, E, k, L, W, Q, _e = 0,
                            ye = !1,
                            Te = !1,
                            Ie = !0;
                        if (typeof o != "function") throw new Gr(a);
                        l = zr(l) || 0, an(f) && (ye = !!f.leading, Te = "maxWait" in f, k = Te ? kn(zr(f.maxWait) || 0, l) : k, Ie = "trailing" in f ? !!f.trailing : Ie);

                        function $e(dn) {
                            var fs = g,
                                yi = E;
                            return g = E = n, _e = dn, L = o.apply(yi, fs), L
                        }

                        function We(dn) {
                            return _e = dn, W = Ml(gt, l), ye ? $e(dn) : L
                        }

                        function ut(dn) {
                            var fs = dn - Q,
                                yi = dn - _e,
                                $E = l - fs;
                            return Te ? Zn($E, k - yi) : $E
                        }

                        function He(dn) {
                            var fs = dn - Q,
                                yi = dn - _e;
                            return Q === n || fs >= l || fs < 0 || Te && yi >= k
                        }

                        function gt() {
                            var dn = of();
                            if (He(dn)) return Et(dn);
                            W = Ml(gt, ut(dn))
                        }

                        function Et(dn) {
                            return W = n, Ie && g ? $e(dn) : (g = E = n, L)
                        }

                        function Dr() {
                            W !== n && C2(W), _e = 0, g = Q = E = W = n
                        }

                        function cr() {
                            return W === n ? L : Et(of())
                        }

                        function $r() {
                            var dn = of(),
                                fs = He(dn);
                            if (g = arguments, E = this, Q = dn, fs) {
                                if (W === n) return We(Q);
                                if (Te) return C2(W), W = Ml(gt, l), $e(Q)
                            }
                            return W === n && (W = Ml(gt, l)), L
                        }
                        return $r.cancel = Dr, $r.flush = cr, $r
                    }
                    var P8 = dt(function(o, l) {
                            return o2(o, 1, l)
                        }),
                        R8 = dt(function(o, l, f) {
                            return o2(o, zr(l) || 0, f)
                        });

                    function M8(o) {
                        return di(o, ee)
                    }

                    function af(o, l) {
                        if (typeof o != "function" || l != null && typeof l != "function") throw new Gr(a);
                        var f = function() {
                            var g = arguments,
                                E = l ? l.apply(this, g) : g[0],
                                k = f.cache;
                            if (k.has(E)) return k.get(E);
                            var L = o.apply(this, g);
                            return f.cache = k.set(E, L) || k, L
                        };
                        return f.cache = new(af.Cache || hi), f
                    }
                    af.Cache = hi;

                    function cf(o) {
                        if (typeof o != "function") throw new Gr(a);
                        return function() {
                            var l = arguments;
                            switch (l.length) {
                                case 0:
                                    return !o.call(this);
                                case 1:
                                    return !o.call(this, l[0]);
                                case 2:
                                    return !o.call(this, l[0], l[1]);
                                case 3:
                                    return !o.call(this, l[0], l[1], l[2])
                            }
                            return !o.apply(this, l)
                        }
                    }

                    function D8(o) {
                        return dE(2, o)
                    }
                    var $8 = T7(function(o, l) {
                            l = l.length == 1 && tt(l[0]) ? tn(l[0], Pr(je())) : tn(Bn(l, 1), Pr(je()));
                            var f = l.length;
                            return dt(function(g) {
                                for (var E = -1, k = Zn(g.length, f); ++E < k;) g[E] = l[E].call(this, g[E]);
                                return xr(o, this, g)
                            })
                        }),
                        Fg = dt(function(o, l) {
                            var f = Wi(l, za(Fg));
                            return di(o, O, n, l, f)
                        }),
                        yE = dt(function(o, l) {
                            var f = Wi(l, za(yE));
                            return di(o, M, n, l, f)
                        }),
                        L8 = pi(function(o, l) {
                            return di(o, j, n, n, n, l)
                        });

                    function F8(o, l) {
                        if (typeof o != "function") throw new Gr(a);
                        return l = l === n ? l : ct(l), dt(o, l)
                    }

                    function U8(o, l) {
                        if (typeof o != "function") throw new Gr(a);
                        return l = l == null ? 0 : kn(ct(l), 0), dt(function(f) {
                            var g = f[l],
                                E = Zi(f, 0, l);
                            return g && Gi(E, g), xr(o, this, E)
                        })
                    }

                    function B8(o, l, f) {
                        var g = !0,
                            E = !0;
                        if (typeof o != "function") throw new Gr(a);
                        return an(f) && (g = "leading" in f ? !!f.leading : g, E = "trailing" in f ? !!f.trailing : E), _E(o, l, {
                            leading: g,
                            maxWait: l,
                            trailing: E
                        })
                    }

                    function q8(o) {
                        return fE(o, 1)
                    }

                    function j8(o, l) {
                        return Fg(Tg(l), o)
                    }

                    function V8() {
                        if (!arguments.length) return [];
                        var o = arguments[0];
                        return tt(o) ? o : [o]
                    }

                    function G8(o) {
                        return Hr(o, _)
                    }

                    function W8(o, l) {
                        return l = typeof l == "function" ? l : n, Hr(o, _, l)
                    }

                    function H8(o) {
                        return Hr(o, p | _)
                    }

                    function K8(o, l) {
                        return l = typeof l == "function" ? l : n, Hr(o, p | _, l)
                    }

                    function Y8(o, l) {
                        return l == null || i2(o, l, Mn(l))
                    }

                    function hs(o, l) {
                        return o === l || o !== o && l !== l
                    }
                    var z8 = Qh(ug),
                        Z8 = Qh(function(o, l) {
                            return o >= l
                        }),
                        Xo = h2(function() {
                            return arguments
                        }()) ? h2 : function(o) {
                            return cn(o) && Rt.call(o, "callee") && !Xb.call(o, "callee")
                        },
                        tt = le.isArray,
                        X8 = Pb ? Pr(Pb) : i7;

                    function _r(o) {
                        return o != null && lf(o.length) && !gi(o)
                    }

                    function fn(o) {
                        return cn(o) && _r(o)
                    }

                    function J8(o) {
                        return o === !0 || o === !1 || cn(o) && or(o) == ke
                    }
                    var Xi = fN || zg,
                        Q8 = Rb ? Pr(Rb) : o7;

                    function e9(o) {
                        return cn(o) && o.nodeType === 1 && !Dl(o)
                    }

                    function t9(o) {
                        if (o == null) return !0;
                        if (_r(o) && (tt(o) || typeof o == "string" || typeof o.splice == "function" || Xi(o) || Za(o) || Xo(o))) return !o.length;
                        var l = Xn(o);
                        if (l == S || l == ce) return !o.size;
                        if (Rl(o)) return !dg(o).length;
                        for (var f in o)
                            if (Rt.call(o, f)) return !1;
                        return !0
                    }

                    function n9(o, l) {
                        return Nl(o, l)
                    }

                    function r9(o, l, f) {
                        f = typeof f == "function" ? f : n;
                        var g = f ? f(o, l) : n;
                        return g === n ? Nl(o, l, n, f) : !!g
                    }

                    function Ug(o) {
                        if (!cn(o)) return !1;
                        var l = or(o);
                        return l == zt || l == Yt || typeof o.message == "string" && typeof o.name == "string" && !Dl(o)
                    }

                    function s9(o) {
                        return typeof o == "number" && Qb(o)
                    }

                    function gi(o) {
                        if (!an(o)) return !1;
                        var l = or(o);
                        return l == U || l == T || l == at || l == ue
                    }

                    function vE(o) {
                        return typeof o == "number" && o == ct(o)
                    }

                    function lf(o) {
                        return typeof o == "number" && o > -1 && o % 1 == 0 && o <= ve
                    }

                    function an(o) {
                        var l = typeof o;
                        return o != null && (l == "object" || l == "function")
                    }

                    function cn(o) {
                        return o != null && typeof o == "object"
                    }
                    var bE = Mb ? Pr(Mb) : c7;

                    function i9(o, l) {
                        return o === l || fg(o, l, Ig(l))
                    }

                    function o9(o, l, f) {
                        return f = typeof f == "function" ? f : n, fg(o, l, Ig(l), f)
                    }

                    function a9(o) {
                        return EE(o) && o != +o
                    }

                    function c9(o) {
                        if (W7(o)) throw new Qe(i);
                        return f2(o)
                    }

                    function l9(o) {
                        return o === null
                    }

                    function u9(o) {
                        return o == null
                    }

                    function EE(o) {
                        return typeof o == "number" || cn(o) && or(o) == N
                    }

                    function Dl(o) {
                        if (!cn(o) || or(o) != te) return !1;
                        var l = Dh(o);
                        if (l === null) return !0;
                        var f = Rt.call(l, "constructor") && l.constructor;
                        return typeof f == "function" && f instanceof f && xh.call(f) == oN
                    }
                    var Bg = Db ? Pr(Db) : l7;

                    function h9(o) {
                        return vE(o) && o >= -ve && o <= ve
                    }
                    var TE = $b ? Pr($b) : u7;

                    function uf(o) {
                        return typeof o == "string" || !tt(o) && cn(o) && or(o) == J
                    }

                    function Mr(o) {
                        return typeof o == "symbol" || cn(o) && or(o) == ne
                    }
                    var Za = Lb ? Pr(Lb) : h7;

                    function f9(o) {
                        return o === n
                    }

                    function d9(o) {
                        return cn(o) && Xn(o) == Pe
                    }

                    function p9(o) {
                        return cn(o) && or(o) == ze
                    }
                    var m9 = Qh(pg),
                        g9 = Qh(function(o, l) {
                            return o <= l
                        });

                    function SE(o) {
                        if (!o) return [];
                        if (_r(o)) return uf(o) ? ls(o) : gr(o);
                        if (Tl && o[Tl]) return YI(o[Tl]());
                        var l = Xn(o),
                            f = l == S ? tg : l == ce ? kh : Xa;
                        return f(o)
                    }

                    function _i(o) {
                        if (!o) return o === 0 ? o : 0;
                        if (o = zr(o), o === he || o === -he) {
                            var l = o < 0 ? -1 : 1;
                            return l * be
                        }
                        return o === o ? o : 0
                    }

                    function ct(o) {
                        var l = _i(o),
                            f = l % 1;
                        return l === l ? f ? l - f : l : 0
                    }

                    function wE(o) {
                        return o ? Ko(ct(o), 0, we) : 0
                    }

                    function zr(o) {
                        if (typeof o == "number") return o;
                        if (Mr(o)) return Ae;
                        if (an(o)) {
                            var l = typeof o.valueOf == "function" ? o.valueOf() : o;
                            o = an(l) ? l + "" : l
                        }
                        if (typeof o != "string") return o === 0 ? o : +o;
                        o = Vb(o);
                        var f = X6.test(o);
                        return f || Q6.test(o) ? xI(o.slice(2), f ? 2 : 8) : Z6.test(o) ? Ae : +o
                    }

                    function OE(o) {
                        return Us(o, yr(o))
                    }

                    function _9(o) {
                        return o ? Ko(ct(o), -ve, ve) : o === 0 ? o : 0
                    }

                    function xt(o) {
                        return o == null ? "" : Rr(o)
                    }
                    var y9 = Ka(function(o, l) {
                            if (Rl(l) || _r(l)) {
                                Us(l, Mn(l), o);
                                return
                            }
                            for (var f in l) Rt.call(l, f) && Cl(o, f, l[f])
                        }),
                        AE = Ka(function(o, l) {
                            Us(l, yr(l), o)
                        }),
                        hf = Ka(function(o, l, f, g) {
                            Us(l, yr(l), o, g)
                        }),
                        v9 = Ka(function(o, l, f, g) {
                            Us(l, Mn(l), o, g)
                        }),
                        b9 = pi(ag);

                    function E9(o, l) {
                        var f = Ha(o);
                        return l == null ? f : s2(f, l)
                    }
                    var T9 = dt(function(o, l) {
                            o = Lt(o);
                            var f = -1,
                                g = l.length,
                                E = g > 2 ? l[2] : n;
                            for (E && ar(l[0], l[1], E) && (g = 1); ++f < g;)
                                for (var k = l[f], L = yr(k), W = -1, Q = L.length; ++W < Q;) {
                                    var _e = L[W],
                                        ye = o[_e];
                                    (ye === n || hs(ye, Va[_e]) && !Rt.call(o, _e)) && (o[_e] = k[_e])
                                }
                            return o
                        }),
                        S9 = dt(function(o) {
                            return o.push(n, V2), xr(CE, n, o)
                        });

                    function w9(o, l) {
                        return Ub(o, je(l, 3), Fs)
                    }

                    function O9(o, l) {
                        return Ub(o, je(l, 3), lg)
                    }

                    function A9(o, l) {
                        return o == null ? o : cg(o, je(l, 3), yr)
                    }

                    function C9(o, l) {
                        return o == null ? o : l2(o, je(l, 3), yr)
                    }

                    function k9(o, l) {
                        return o && Fs(o, je(l, 3))
                    }

                    function I9(o, l) {
                        return o && lg(o, je(l, 3))
                    }

                    function N9(o) {
                        return o == null ? [] : Wh(o, Mn(o))
                    }

                    function x9(o) {
                        return o == null ? [] : Wh(o, yr(o))
                    }

                    function qg(o, l, f) {
                        var g = o == null ? n : Yo(o, l);
                        return g === n ? f : g
                    }

                    function P9(o, l) {
                        return o != null && H2(o, l, t7)
                    }

                    function jg(o, l) {
                        return o != null && H2(o, l, n7)
                    }
                    var R9 = F2(function(o, l, f) {
                            l != null && typeof l.toString != "function" && (l = Ph.call(l)), o[l] = f
                        }, Gg(vr)),
                        M9 = F2(function(o, l, f) {
                            l != null && typeof l.toString != "function" && (l = Ph.call(l)), Rt.call(o, l) ? o[l].push(f) : o[l] = [f]
                        }, je),
                        D9 = dt(Il);

                    function Mn(o) {
                        return _r(o) ? n2(o) : dg(o)
                    }

                    function yr(o) {
                        return _r(o) ? n2(o, !0) : f7(o)
                    }

                    function $9(o, l) {
                        var f = {};
                        return l = je(l, 3), Fs(o, function(g, E, k) {
                            fi(f, l(g, E, k), g)
                        }), f
                    }

                    function L9(o, l) {
                        var f = {};
                        return l = je(l, 3), Fs(o, function(g, E, k) {
                            fi(f, E, l(g, E, k))
                        }), f
                    }
                    var F9 = Ka(function(o, l, f) {
                            Hh(o, l, f)
                        }),
                        CE = Ka(function(o, l, f, g) {
                            Hh(o, l, f, g)
                        }),
                        U9 = pi(function(o, l) {
                            var f = {};
                            if (o == null) return f;
                            var g = !1;
                            l = tn(l, function(k) {
                                return k = zi(k, o), g || (g = k.length > 1), k
                            }), Us(o, Cg(o), f), g && (f = Hr(f, p | m | _, R7));
                            for (var E = l.length; E--;) vg(f, l[E]);
                            return f
                        });

                    function B9(o, l) {
                        return kE(o, cf(je(l)))
                    }
                    var q9 = pi(function(o, l) {
                        return o == null ? {} : p7(o, l)
                    });

                    function kE(o, l) {
                        if (o == null) return {};
                        var f = tn(Cg(o), function(g) {
                            return [g]
                        });
                        return l = je(l), v2(o, f, function(g, E) {
                            return l(g, E[0])
                        })
                    }

                    function j9(o, l, f) {
                        l = zi(l, o);
                        var g = -1,
                            E = l.length;
                        for (E || (E = 1, o = n); ++g < E;) {
                            var k = o == null ? n : o[Bs(l[g])];
                            k === n && (g = E, k = f), o = gi(k) ? k.call(o) : k
                        }
                        return o
                    }

                    function V9(o, l, f) {
                        return o == null ? o : xl(o, l, f)
                    }

                    function G9(o, l, f, g) {
                        return g = typeof g == "function" ? g : n, o == null ? o : xl(o, l, f, g)
                    }
                    var IE = q2(Mn),
                        NE = q2(yr);

                    function W9(o, l, f) {
                        var g = tt(o),
                            E = g || Xi(o) || Za(o);
                        if (l = je(l, 4), f == null) {
                            var k = o && o.constructor;
                            E ? f = g ? new k : [] : an(o) ? f = gi(k) ? Ha(Dh(o)) : {} : f = {}
                        }
                        return (E ? Vr : Fs)(o, function(L, W, Q) {
                            return l(f, L, W, Q)
                        }), f
                    }

                    function H9(o, l) {
                        return o == null ? !0 : vg(o, l)
                    }

                    function K9(o, l, f) {
                        return o == null ? o : w2(o, l, Tg(f))
                    }

                    function Y9(o, l, f, g) {
                        return g = typeof g == "function" ? g : n, o == null ? o : w2(o, l, Tg(f), g)
                    }

                    function Xa(o) {
                        return o == null ? [] : eg(o, Mn(o))
                    }

                    function z9(o) {
                        return o == null ? [] : eg(o, yr(o))
                    }

                    function Z9(o, l, f) {
                        return f === n && (f = l, l = n), f !== n && (f = zr(f), f = f === f ? f : 0), l !== n && (l = zr(l), l = l === l ? l : 0), Ko(zr(o), l, f)
                    }

                    function X9(o, l, f) {
                        return l = _i(l), f === n ? (f = l, l = 0) : f = _i(f), o = zr(o), r7(o, l, f)
                    }

                    function J9(o, l, f) {
                        if (f && typeof f != "boolean" && ar(o, l, f) && (l = f = n), f === n && (typeof l == "boolean" ? (f = l, l = n) : typeof o == "boolean" && (f = o, o = n)), o === n && l === n ? (o = 0, l = 1) : (o = _i(o), l === n ? (l = o, o = 0) : l = _i(l)), o > l) {
                            var g = o;
                            o = l, l = g
                        }
                        if (f || o % 1 || l % 1) {
                            var E = e2();
                            return Zn(o + E * (l - o + NI("1e-" + ((E + "").length - 1))), l)
                        }
                        return gg(o, l)
                    }
                    var Q9 = Ya(function(o, l, f) {
                        return l = l.toLowerCase(), o + (f ? xE(l) : l)
                    });

                    function xE(o) {
                        return Vg(xt(o).toLowerCase())
                    }

                    function PE(o) {
                        return o = xt(o), o && o.replace(tI, VI).replace(bI, "")
                    }

                    function eP(o, l, f) {
                        o = xt(o), l = Rr(l);
                        var g = o.length;
                        f = f === n ? g : Ko(ct(f), 0, g);
                        var E = f;
                        return f -= l.length, f >= 0 && o.slice(f, E) == l
                    }

                    function tP(o) {
                        return o = xt(o), o && D6.test(o) ? o.replace(lb, GI) : o
                    }

                    function nP(o) {
                        return o = xt(o), o && q6.test(o) ? o.replace(Fm, "\\$&") : o
                    }
                    var rP = Ya(function(o, l, f) {
                            return o + (f ? "-" : "") + l.toLowerCase()
                        }),
                        sP = Ya(function(o, l, f) {
                            return o + (f ? " " : "") + l.toLowerCase()
                        }),
                        iP = D2("toLowerCase");

                    function oP(o, l, f) {
                        o = xt(o), l = ct(l);
                        var g = l ? qa(o) : 0;
                        if (!l || g >= l) return o;
                        var E = (l - g) / 2;
                        return Jh(Uh(E), f) + o + Jh(Fh(E), f)
                    }

                    function aP(o, l, f) {
                        o = xt(o), l = ct(l);
                        var g = l ? qa(o) : 0;
                        return l && g < l ? o + Jh(l - g, f) : o
                    }

                    function cP(o, l, f) {
                        o = xt(o), l = ct(l);
                        var g = l ? qa(o) : 0;
                        return l && g < l ? Jh(l - g, f) + o : o
                    }

                    function lP(o, l, f) {
                        return f || l == null ? l = 0 : l && (l = +l), gN(xt(o).replace(Um, ""), l || 0)
                    }

                    function uP(o, l, f) {
                        return (f ? ar(o, l, f) : l === n) ? l = 1 : l = ct(l), _g(xt(o), l)
                    }

                    function hP() {
                        var o = arguments,
                            l = xt(o[0]);
                        return o.length < 3 ? l : l.replace(o[1], o[2])
                    }
                    var fP = Ya(function(o, l, f) {
                        return o + (f ? "_" : "") + l.toLowerCase()
                    });

                    function dP(o, l, f) {
                        return f && typeof f != "number" && ar(o, l, f) && (l = f = n), f = f === n ? we : f >>> 0, f ? (o = xt(o), o && (typeof l == "string" || l != null && !Bg(l)) && (l = Rr(l), !l && Ba(o)) ? Zi(ls(o), 0, f) : o.split(l, f)) : []
                    }
                    var pP = Ya(function(o, l, f) {
                        return o + (f ? " " : "") + Vg(l)
                    });

                    function mP(o, l, f) {
                        return o = xt(o), f = f == null ? 0 : Ko(ct(f), 0, o.length), l = Rr(l), o.slice(f, f + l.length) == l
                    }

                    function gP(o, l, f) {
                        var g = A.templateSettings;
                        f && ar(o, l, f) && (l = n), o = xt(o), l = hf({}, l, g, j2);
                        var E = hf({}, l.imports, g.imports, j2),
                            k = Mn(E),
                            L = eg(E, k),
                            W, Q, _e = 0,
                            ye = l.interpolate || Sh,
                            Te = "__p += '",
                            Ie = ng((l.escape || Sh).source + "|" + ye.source + "|" + (ye === ub ? z6 : Sh).source + "|" + (l.evaluate || Sh).source + "|$", "g"),
                            $e = "//# sourceURL=" + (Rt.call(l, "sourceURL") ? (l.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++OI + "]") + `
`;
                        o.replace(Ie, function(He, gt, Et, Dr, cr, $r) {
                            return Et || (Et = Dr), Te += o.slice(_e, $r).replace(nI, WI), gt && (W = !0, Te += `' +
__e(` + gt + `) +
'`), cr && (Q = !0, Te += `';
` + cr + `;
__p += '`), Et && (Te += `' +
((__t = (` + Et + `)) == null ? '' : __t) +
'`), _e = $r + He.length, He
                        }), Te += `';
`;
                        var We = Rt.call(l, "variable") && l.variable;
                        if (!We) Te = `with (obj) {
` + Te + `
}
`;
                        else if (K6.test(We)) throw new Qe(c);
                        Te = (Q ? Te.replace(Nr, "") : Te).replace(Ze, "$1").replace(bl, "$1;"), Te = "function(" + (We || "obj") + `) {
` + (We ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (W ? ", __e = _.escape" : "") + (Q ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Te + `return __p
}`;
                        var ut = ME(function() {
                            return It(k, $e + "return " + Te).apply(n, L)
                        });
                        if (ut.source = Te, Ug(ut)) throw ut;
                        return ut
                    }

                    function _P(o) {
                        return xt(o).toLowerCase()
                    }

                    function yP(o) {
                        return xt(o).toUpperCase()
                    }

                    function vP(o, l, f) {
                        if (o = xt(o), o && (f || l === n)) return Vb(o);
                        if (!o || !(l = Rr(l))) return o;
                        var g = ls(o),
                            E = ls(l),
                            k = Gb(g, E),
                            L = Wb(g, E) + 1;
                        return Zi(g, k, L).join("")
                    }

                    function bP(o, l, f) {
                        if (o = xt(o), o && (f || l === n)) return o.slice(0, Kb(o) + 1);
                        if (!o || !(l = Rr(l))) return o;
                        var g = ls(o),
                            E = Wb(g, ls(l)) + 1;
                        return Zi(g, 0, E).join("")
                    }

                    function EP(o, l, f) {
                        if (o = xt(o), o && (f || l === n)) return o.replace(Um, "");
                        if (!o || !(l = Rr(l))) return o;
                        var g = ls(o),
                            E = Gb(g, ls(l));
                        return Zi(g, E).join("")
                    }

                    function TP(o, l) {
                        var f = se,
                            g = oe;
                        if (an(l)) {
                            var E = "separator" in l ? l.separator : E;
                            f = "length" in l ? ct(l.length) : f, g = "omission" in l ? Rr(l.omission) : g
                        }
                        o = xt(o);
                        var k = o.length;
                        if (Ba(o)) {
                            var L = ls(o);
                            k = L.length
                        }
                        if (f >= k) return o;
                        var W = f - qa(g);
                        if (W < 1) return g;
                        var Q = L ? Zi(L, 0, W).join("") : o.slice(0, W);
                        if (E === n) return Q + g;
                        if (L && (W += Q.length - W), Bg(E)) {
                            if (o.slice(W).search(E)) {
                                var _e, ye = Q;
                                for (E.global || (E = ng(E.source, xt(hb.exec(E)) + "g")), E.lastIndex = 0; _e = E.exec(ye);) var Te = _e.index;
                                Q = Q.slice(0, Te === n ? W : Te)
                            }
                        } else if (o.indexOf(Rr(E), W) != W) {
                            var Ie = Q.lastIndexOf(E);
                            Ie > -1 && (Q = Q.slice(0, Ie))
                        }
                        return Q + g
                    }

                    function SP(o) {
                        return o = xt(o), o && M6.test(o) ? o.replace(cb, JI) : o
                    }
                    var wP = Ya(function(o, l, f) {
                            return o + (f ? " " : "") + l.toUpperCase()
                        }),
                        Vg = D2("toUpperCase");

                    function RE(o, l, f) {
                        return o = xt(o), l = f ? n : l, l === n ? KI(o) ? tN(o) : FI(o) : o.match(l) || []
                    }
                    var ME = dt(function(o, l) {
                            try {
                                return xr(o, n, l)
                            } catch (f) {
                                return Ug(f) ? f : new Qe(f)
                            }
                        }),
                        OP = pi(function(o, l) {
                            return Vr(l, function(f) {
                                f = Bs(f), fi(o, f, Lg(o[f], o))
                            }), o
                        });

                    function AP(o) {
                        var l = o == null ? 0 : o.length,
                            f = je();
                        return o = l ? tn(o, function(g) {
                            if (typeof g[1] != "function") throw new Gr(a);
                            return [f(g[0]), g[1]]
                        }) : [], dt(function(g) {
                            for (var E = -1; ++E < l;) {
                                var k = o[E];
                                if (xr(k[0], this, g)) return xr(k[1], this, g)
                            }
                        })
                    }

                    function CP(o) {
                        return JN(Hr(o, p))
                    }

                    function Gg(o) {
                        return function() {
                            return o
                        }
                    }

                    function kP(o, l) {
                        return o == null || o !== o ? l : o
                    }
                    var IP = L2(),
                        NP = L2(!0);

                    function vr(o) {
                        return o
                    }

                    function Wg(o) {
                        return d2(typeof o == "function" ? o : Hr(o, p))
                    }

                    function xP(o) {
                        return m2(Hr(o, p))
                    }

                    function PP(o, l) {
                        return g2(o, Hr(l, p))
                    }
                    var RP = dt(function(o, l) {
                            return function(f) {
                                return Il(f, o, l)
                            }
                        }),
                        MP = dt(function(o, l) {
                            return function(f) {
                                return Il(o, f, l)
                            }
                        });

                    function Hg(o, l, f) {
                        var g = Mn(l),
                            E = Wh(l, g);
                        f == null && !(an(l) && (E.length || !g.length)) && (f = l, l = o, o = this, E = Wh(l, Mn(l)));
                        var k = !(an(f) && "chain" in f) || !!f.chain,
                            L = gi(o);
                        return Vr(E, function(W) {
                            var Q = l[W];
                            o[W] = Q, L && (o.prototype[W] = function() {
                                var _e = this.__chain__;
                                if (k || _e) {
                                    var ye = o(this.__wrapped__),
                                        Te = ye.__actions__ = gr(this.__actions__);
                                    return Te.push({
                                        func: Q,
                                        args: arguments,
                                        thisArg: o
                                    }), ye.__chain__ = _e, ye
                                }
                                return Q.apply(o, Gi([this.value()], arguments))
                            })
                        }), o
                    }

                    function DP() {
                        return Un._ === this && (Un._ = aN), this
                    }

                    function Kg() {}

                    function $P(o) {
                        return o = ct(o), dt(function(l) {
                            return _2(l, o)
                        })
                    }
                    var LP = wg(tn),
                        FP = wg(Fb),
                        UP = wg(zm);

                    function DE(o) {
                        return xg(o) ? Zm(Bs(o)) : m7(o)
                    }

                    function BP(o) {
                        return function(l) {
                            return o == null ? n : Yo(o, l)
                        }
                    }
                    var qP = U2(),
                        jP = U2(!0);

                    function Yg() {
                        return []
                    }

                    function zg() {
                        return !1
                    }

                    function VP() {
                        return {}
                    }

                    function GP() {
                        return ""
                    }

                    function WP() {
                        return !0
                    }

                    function HP(o, l) {
                        if (o = ct(o), o < 1 || o > ve) return [];
                        var f = we,
                            g = Zn(o, we);
                        l = je(l), o -= we;
                        for (var E = Qm(g, l); ++f < o;) l(f);
                        return E
                    }

                    function KP(o) {
                        return tt(o) ? tn(o, Bs) : Mr(o) ? [o] : gr(tE(xt(o)))
                    }

                    function YP(o) {
                        var l = ++iN;
                        return xt(o) + l
                    }
                    var zP = Xh(function(o, l) {
                            return o + l
                        }, 0),
                        ZP = Og("ceil"),
                        XP = Xh(function(o, l) {
                            return o / l
                        }, 1),
                        JP = Og("floor");

                    function QP(o) {
                        return o && o.length ? Gh(o, vr, ug) : n
                    }

                    function eR(o, l) {
                        return o && o.length ? Gh(o, je(l, 2), ug) : n
                    }

                    function tR(o) {
                        return qb(o, vr)
                    }

                    function nR(o, l) {
                        return qb(o, je(l, 2))
                    }

                    function rR(o) {
                        return o && o.length ? Gh(o, vr, pg) : n
                    }

                    function sR(o, l) {
                        return o && o.length ? Gh(o, je(l, 2), pg) : n
                    }
                    var iR = Xh(function(o, l) {
                            return o * l
                        }, 1),
                        oR = Og("round"),
                        aR = Xh(function(o, l) {
                            return o - l
                        }, 0);

                    function cR(o) {
                        return o && o.length ? Jm(o, vr) : 0
                    }

                    function lR(o, l) {
                        return o && o.length ? Jm(o, je(l, 2)) : 0
                    }
                    return A.after = x8, A.ary = fE, A.assign = y9, A.assignIn = AE, A.assignInWith = hf, A.assignWith = v9, A.at = b9, A.before = dE, A.bind = Lg, A.bindAll = OP, A.bindKey = pE, A.castArray = V8, A.chain = lE, A.chunk = J7, A.compact = Q7, A.concat = ex, A.cond = AP, A.conforms = CP, A.constant = Gg, A.countBy = c8, A.create = E9, A.curry = mE, A.curryRight = gE, A.debounce = _E, A.defaults = T9, A.defaultsDeep = S9, A.defer = P8, A.delay = R8, A.difference = tx, A.differenceBy = nx, A.differenceWith = rx, A.drop = sx, A.dropRight = ix, A.dropRightWhile = ox, A.dropWhile = ax, A.fill = cx, A.filter = u8, A.flatMap = d8, A.flatMapDeep = p8, A.flatMapDepth = m8, A.flatten = iE, A.flattenDeep = lx, A.flattenDepth = ux, A.flip = M8, A.flow = IP, A.flowRight = NP, A.fromPairs = hx, A.functions = N9, A.functionsIn = x9, A.groupBy = g8, A.initial = dx, A.intersection = px, A.intersectionBy = mx, A.intersectionWith = gx, A.invert = R9, A.invertBy = M9, A.invokeMap = y8, A.iteratee = Wg, A.keyBy = v8, A.keys = Mn, A.keysIn = yr, A.map = sf, A.mapKeys = $9, A.mapValues = L9, A.matches = xP, A.matchesProperty = PP, A.memoize = af, A.merge = F9, A.mergeWith = CE, A.method = RP, A.methodOf = MP, A.mixin = Hg, A.negate = cf, A.nthArg = $P, A.omit = U9, A.omitBy = B9, A.once = D8, A.orderBy = b8, A.over = LP, A.overArgs = $8, A.overEvery = FP, A.overSome = UP, A.partial = Fg, A.partialRight = yE, A.partition = E8, A.pick = q9, A.pickBy = kE, A.property = DE, A.propertyOf = BP, A.pull = bx, A.pullAll = aE, A.pullAllBy = Ex, A.pullAllWith = Tx, A.pullAt = Sx, A.range = qP, A.rangeRight = jP, A.rearg = L8, A.reject = w8, A.remove = wx, A.rest = F8, A.reverse = Dg, A.sampleSize = A8, A.set = V9, A.setWith = G9, A.shuffle = C8, A.slice = Ox, A.sortBy = N8, A.sortedUniq = Px, A.sortedUniqBy = Rx, A.split = dP, A.spread = U8, A.tail = Mx, A.take = Dx, A.takeRight = $x, A.takeRightWhile = Lx, A.takeWhile = Fx, A.tap = Qx, A.throttle = B8, A.thru = rf, A.toArray = SE, A.toPairs = IE, A.toPairsIn = NE, A.toPath = KP, A.toPlainObject = OE, A.transform = W9, A.unary = q8, A.union = Ux, A.unionBy = Bx, A.unionWith = qx, A.uniq = jx, A.uniqBy = Vx, A.uniqWith = Gx, A.unset = H9, A.unzip = $g, A.unzipWith = cE, A.update = K9, A.updateWith = Y9, A.values = Xa, A.valuesIn = z9, A.without = Wx, A.words = RE, A.wrap = j8, A.xor = Hx, A.xorBy = Kx, A.xorWith = Yx, A.zip = zx, A.zipObject = Zx, A.zipObjectDeep = Xx, A.zipWith = Jx, A.entries = IE, A.entriesIn = NE, A.extend = AE, A.extendWith = hf, Hg(A, A), A.add = zP, A.attempt = ME, A.camelCase = Q9, A.capitalize = xE, A.ceil = ZP, A.clamp = Z9, A.clone = G8, A.cloneDeep = H8, A.cloneDeepWith = K8, A.cloneWith = W8, A.conformsTo = Y8, A.deburr = PE, A.defaultTo = kP, A.divide = XP, A.endsWith = eP, A.eq = hs, A.escape = tP, A.escapeRegExp = nP, A.every = l8, A.find = h8, A.findIndex = rE, A.findKey = w9, A.findLast = f8, A.findLastIndex = sE, A.findLastKey = O9, A.floor = JP, A.forEach = uE, A.forEachRight = hE, A.forIn = A9, A.forInRight = C9, A.forOwn = k9, A.forOwnRight = I9, A.get = qg, A.gt = z8, A.gte = Z8, A.has = P9, A.hasIn = jg, A.head = oE, A.identity = vr, A.includes = _8, A.indexOf = fx, A.inRange = X9, A.invoke = D9, A.isArguments = Xo, A.isArray = tt, A.isArrayBuffer = X8, A.isArrayLike = _r, A.isArrayLikeObject = fn, A.isBoolean = J8, A.isBuffer = Xi, A.isDate = Q8, A.isElement = e9, A.isEmpty = t9, A.isEqual = n9, A.isEqualWith = r9, A.isError = Ug, A.isFinite = s9, A.isFunction = gi, A.isInteger = vE, A.isLength = lf, A.isMap = bE, A.isMatch = i9, A.isMatchWith = o9, A.isNaN = a9, A.isNative = c9, A.isNil = u9, A.isNull = l9, A.isNumber = EE, A.isObject = an, A.isObjectLike = cn, A.isPlainObject = Dl, A.isRegExp = Bg, A.isSafeInteger = h9, A.isSet = TE, A.isString = uf, A.isSymbol = Mr, A.isTypedArray = Za, A.isUndefined = f9, A.isWeakMap = d9, A.isWeakSet = p9, A.join = _x, A.kebabCase = rP, A.last = Yr, A.lastIndexOf = yx, A.lowerCase = sP, A.lowerFirst = iP, A.lt = m9, A.lte = g9, A.max = QP, A.maxBy = eR, A.mean = tR, A.meanBy = nR, A.min = rR, A.minBy = sR, A.stubArray = Yg, A.stubFalse = zg, A.stubObject = VP, A.stubString = GP, A.stubTrue = WP, A.multiply = iR, A.nth = vx, A.noConflict = DP, A.noop = Kg, A.now = of, A.pad = oP, A.padEnd = aP, A.padStart = cP, A.parseInt = lP, A.random = J9, A.reduce = T8, A.reduceRight = S8, A.repeat = uP, A.replace = hP, A.result = j9, A.round = oR, A.runInContext = X, A.sample = O8, A.size = k8, A.snakeCase = fP, A.some = I8, A.sortedIndex = Ax, A.sortedIndexBy = Cx, A.sortedIndexOf = kx, A.sortedLastIndex = Ix, A.sortedLastIndexBy = Nx, A.sortedLastIndexOf = xx, A.startCase = pP, A.startsWith = mP, A.subtract = aR, A.sum = cR, A.sumBy = lR, A.template = gP, A.times = HP, A.toFinite = _i, A.toInteger = ct, A.toLength = wE, A.toLower = _P, A.toNumber = zr, A.toSafeInteger = _9, A.toString = xt, A.toUpper = yP, A.trim = vP, A.trimEnd = bP, A.trimStart = EP, A.truncate = TP, A.unescape = SP, A.uniqueId = YP, A.upperCase = wP, A.upperFirst = Vg, A.each = uE, A.eachRight = hE, A.first = oE, Hg(A, function() {
                        var o = {};
                        return Fs(A, function(l, f) {
                            Rt.call(A.prototype, f) || (o[f] = l)
                        }), o
                    }(), {
                        chain: !1
                    }), A.VERSION = r, Vr(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(o) {
                        A[o].placeholder = A
                    }), Vr(["drop", "take"], function(o, l) {
                        _t.prototype[o] = function(f) {
                            f = f === n ? 1 : kn(ct(f), 0);
                            var g = this.__filtered__ && !l ? new _t(this) : this.clone();
                            return g.__filtered__ ? g.__takeCount__ = Zn(f, g.__takeCount__) : g.__views__.push({
                                size: Zn(f, we),
                                type: o + (g.__dir__ < 0 ? "Right" : "")
                            }), g
                        }, _t.prototype[o + "Right"] = function(f) {
                            return this.reverse()[o](f).reverse()
                        }
                    }), Vr(["filter", "map", "takeWhile"], function(o, l) {
                        var f = l + 1,
                            g = f == q || f == ae;
                        _t.prototype[o] = function(E) {
                            var k = this.clone();
                            return k.__iteratees__.push({
                                iteratee: je(E, 3),
                                type: f
                            }), k.__filtered__ = k.__filtered__ || g, k
                        }
                    }), Vr(["head", "last"], function(o, l) {
                        var f = "take" + (l ? "Right" : "");
                        _t.prototype[o] = function() {
                            return this[f](1).value()[0]
                        }
                    }), Vr(["initial", "tail"], function(o, l) {
                        var f = "drop" + (l ? "" : "Right");
                        _t.prototype[o] = function() {
                            return this.__filtered__ ? new _t(this) : this[f](1)
                        }
                    }), _t.prototype.compact = function() {
                        return this.filter(vr)
                    }, _t.prototype.find = function(o) {
                        return this.filter(o).head()
                    }, _t.prototype.findLast = function(o) {
                        return this.reverse().find(o)
                    }, _t.prototype.invokeMap = dt(function(o, l) {
                        return typeof o == "function" ? new _t(this) : this.map(function(f) {
                            return Il(f, o, l)
                        })
                    }), _t.prototype.reject = function(o) {
                        return this.filter(cf(je(o)))
                    }, _t.prototype.slice = function(o, l) {
                        o = ct(o);
                        var f = this;
                        return f.__filtered__ && (o > 0 || l < 0) ? new _t(f) : (o < 0 ? f = f.takeRight(-o) : o && (f = f.drop(o)), l !== n && (l = ct(l), f = l < 0 ? f.dropRight(-l) : f.take(l - o)), f)
                    }, _t.prototype.takeRightWhile = function(o) {
                        return this.reverse().takeWhile(o).reverse()
                    }, _t.prototype.toArray = function() {
                        return this.take(we)
                    }, Fs(_t.prototype, function(o, l) {
                        var f = /^(?:filter|find|map|reject)|While$/.test(l),
                            g = /^(?:head|last)$/.test(l),
                            E = A[g ? "take" + (l == "last" ? "Right" : "") : l],
                            k = g || /^find/.test(l);
                        E && (A.prototype[l] = function() {
                            var L = this.__wrapped__,
                                W = g ? [1] : arguments,
                                Q = L instanceof _t,
                                _e = W[0],
                                ye = Q || tt(L),
                                Te = function(gt) {
                                    var Et = E.apply(A, Gi([gt], W));
                                    return g && Ie ? Et[0] : Et
                                };
                            ye && f && typeof _e == "function" && _e.length != 1 && (Q = ye = !1);
                            var Ie = this.__chain__,
                                $e = !!this.__actions__.length,
                                We = k && !Ie,
                                ut = Q && !$e;
                            if (!k && ye) {
                                L = ut ? L : new _t(this);
                                var He = o.apply(L, W);
                                return He.__actions__.push({
                                    func: rf,
                                    args: [Te],
                                    thisArg: n
                                }), new Wr(He, Ie)
                            }
                            return We && ut ? o.apply(this, W) : (He = this.thru(Te), We ? g ? He.value()[0] : He.value() : He)
                        })
                    }), Vr(["pop", "push", "shift", "sort", "splice", "unshift"], function(o) {
                        var l = Ih[o],
                            f = /^(?:push|sort|unshift)$/.test(o) ? "tap" : "thru",
                            g = /^(?:pop|shift)$/.test(o);
                        A.prototype[o] = function() {
                            var E = arguments;
                            if (g && !this.__chain__) {
                                var k = this.value();
                                return l.apply(tt(k) ? k : [], E)
                            }
                            return this[f](function(L) {
                                return l.apply(tt(L) ? L : [], E)
                            })
                        }
                    }), Fs(_t.prototype, function(o, l) {
                        var f = A[l];
                        if (f) {
                            var g = f.name + "";
                            Rt.call(Wa, g) || (Wa[g] = []), Wa[g].push({
                                name: l,
                                func: f
                            })
                        }
                    }), Wa[Zh(n, b).name] = [{
                        name: "wrapper",
                        func: n
                    }], _t.prototype.clone = SN, _t.prototype.reverse = wN, _t.prototype.value = ON, A.prototype.at = e8, A.prototype.chain = t8, A.prototype.commit = n8, A.prototype.next = r8, A.prototype.plant = i8, A.prototype.reverse = o8, A.prototype.toJSON = A.prototype.valueOf = A.prototype.value = a8, A.prototype.first = A.prototype.head, Tl && (A.prototype[Tl] = s8), A
                },
                ja = nN();
            Vo ? ((Vo.exports = ja)._ = ja, Wm._ = ja) : Un._ = ja
        }).call(gn)
    })(Td, Td.exports);
    Td.exports;
    var na, Ef, tu = typeof Map == "function" ? new Map : (na = [], Ef = [], {
            has: function(t) {
                return na.indexOf(t) > -1
            },
            get: function(t) {
                return Ef[na.indexOf(t)]
            },
            set: function(t, e) {
                na.indexOf(t) === -1 && (na.push(t), Ef.push(e))
            },
            delete: function(t) {
                var e = na.indexOf(t);
                e > -1 && (na.splice(e, 1), Ef.splice(e, 1))
            }
        }),
        GO = function(t) {
            return new Event(t, {
                bubbles: !0
            })
        };
    try {
        new Event("test")
    } catch {
        GO = function(e) {
            var n = document.createEvent("Event");
            return n.initEvent(e, !0, !1), n
        }
    }

    function wY(t) {
        var e = tu.get(t);
        e && e.destroy()
    }

    function OY(t) {
        var e = tu.get(t);
        e && e.update()
    }
    var Tf = null;
    typeof window > "u" || typeof window.getComputedStyle != "function" ? ((Tf = function(t) {
        return t
    }).destroy = function(t) {
        return t
    }, Tf.update = function(t) {
        return t
    }) : ((Tf = function(t, e) {
        return t && Array.prototype.forEach.call(t.length ? t : [t], function(n) {
            return function(r) {
                if (r && r.nodeName && r.nodeName === "TEXTAREA" && !tu.has(r)) {
                    var s, i = null,
                        a = null,
                        c = null,
                        u = function() {
                            r.clientWidth !== a && m()
                        },
                        h = (function(_) {
                            window.removeEventListener("resize", u, !1), r.removeEventListener("input", m, !1), r.removeEventListener("keyup", m, !1), r.removeEventListener("autosize:destroy", h, !1), r.removeEventListener("autosize:update", m, !1), Object.keys(_).forEach(function(y) {
                                r.style[y] = _[y]
                            }), tu.delete(r)
                        }).bind(r, {
                            height: r.style.height,
                            resize: r.style.resize,
                            overflowY: r.style.overflowY,
                            overflowX: r.style.overflowX,
                            wordWrap: r.style.wordWrap
                        });
                    r.addEventListener("autosize:destroy", h, !1), "onpropertychange" in r && "oninput" in r && r.addEventListener("keyup", m, !1), window.addEventListener("resize", u, !1), r.addEventListener("input", m, !1), r.addEventListener("autosize:update", m, !1), r.style.overflowX = "hidden", r.style.wordWrap = "break-word", tu.set(r, {
                        destroy: h,
                        update: m
                    }), (s = window.getComputedStyle(r, null)).resize === "vertical" ? r.style.resize = "none" : s.resize === "both" && (r.style.resize = "horizontal"), i = s.boxSizing === "content-box" ? -(parseFloat(s.paddingTop) + parseFloat(s.paddingBottom)) : parseFloat(s.borderTopWidth) + parseFloat(s.borderBottomWidth), isNaN(i) && (i = 0), m()
                }

                function d(_) {
                    var y = r.style.width;
                    r.style.width = "0px", r.style.width = y, r.style.overflowY = _
                }

                function p() {
                    if (r.scrollHeight !== 0) {
                        var _ = function(v) {
                                for (var w = []; v && v.parentNode && v.parentNode instanceof Element;) v.parentNode.scrollTop && w.push({
                                    node: v.parentNode,
                                    scrollTop: v.parentNode.scrollTop
                                }), v = v.parentNode;
                                return w
                            }(r),
                            y = document.documentElement && document.documentElement.scrollTop;
                        r.style.height = "", r.style.height = r.scrollHeight + i + "px", a = r.clientWidth, _.forEach(function(v) {
                            v.node.scrollTop = v.scrollTop
                        }), y && (document.documentElement.scrollTop = y)
                    }
                }

                function m() {
                    p();
                    var _ = Math.round(parseFloat(r.style.height)),
                        y = window.getComputedStyle(r, null),
                        v = y.boxSizing === "content-box" ? Math.round(parseFloat(y.height)) : r.offsetHeight;
                    if (v < _ ? y.overflowY === "hidden" && (d("scroll"), p(), v = y.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(r, null).height)) : r.offsetHeight) : y.overflowY !== "hidden" && (d("hidden"), p(), v = y.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(r, null).height)) : r.offsetHeight), c !== v) {
                        c = v;
                        var w = GO("autosize:resized");
                        try {
                            r.dispatchEvent(w)
                        } catch {}
                    }
                }
            }(n)
        }), t
    }).destroy = function(t) {
        return t && Array.prototype.forEach.call(t.length ? t : [t], wY), t
    }, Tf.update = function(t) {
        return t && Array.prototype.forEach.call(t.length ? t : [t], OY), t
    });
    var Sf = function(t) {
            return t && t.Math == Math && t
        },
        kr = Sf(typeof globalThis == "object" && globalThis) || Sf(typeof window == "object" && window) || Sf(typeof self == "object" && self) || Sf(typeof gn == "object" && gn) || function() {
            return this
        }() || gn || Function("return this")(),
        $v = {},
        qr = function(t) {
            try {
                return !!t()
            } catch {
                return !0
            }
        },
        AY = qr,
        $o = !AY(function() {
            return Object.defineProperty({}, 1, {
                get: function() {
                    return 7
                }
            })[1] != 7
        }),
        CY = qr,
        Lv = !CY(function() {
            var t = (function() {}).bind();
            return typeof t != "function" || t.hasOwnProperty("prototype")
        }),
        kY = Lv,
        wf = Function.prototype.call,
        Lo = kY ? wf.bind(wf) : function() {
            return wf.apply(wf, arguments)
        },
        WO = {},
        HO = {}.propertyIsEnumerable,
        KO = Object.getOwnPropertyDescriptor,
        IY = KO && !HO.call({
            1: 2
        }, 1);
    WO.f = IY ? function(e) {
        var n = KO(this, e);
        return !!n && n.enumerable
    } : HO;
    var YO = function(t, e) {
            return {
                enumerable: !(t & 1),
                configurable: !(t & 2),
                writable: !(t & 4),
                value: e
            }
        },
        zO = Lv,
        ZO = Function.prototype,
        S1 = ZO.call,
        NY = zO && ZO.bind.bind(S1, S1),
        sr = zO ? NY : function(t) {
            return function() {
                return S1.apply(t, arguments)
            }
        },
        XO = sr,
        xY = XO({}.toString),
        PY = XO("".slice),
        Qu = function(t) {
            return PY(xY(t), 8, -1)
        },
        RY = sr,
        MY = qr,
        DY = Qu,
        v_ = Object,
        $Y = RY("".split),
        LY = MY(function() {
            return !v_("z").propertyIsEnumerable(0)
        }) ? function(t) {
            return DY(t) == "String" ? $Y(t, "") : v_(t)
        } : v_,
        tm = function(t) {
            return t == null
        },
        FY = tm,
        UY = TypeError,
        eh = function(t) {
            if (FY(t)) throw UY("Can't call method on " + t);
            return t
        },
        BY = LY,
        qY = eh,
        nm = function(t) {
            return BY(qY(t))
        },
        w1 = typeof document == "object" && document.all,
        jY = typeof w1 > "u" && w1 !== void 0,
        JO = {
            all: w1,
            IS_HTMLDDA: jY
        },
        QO = JO,
        VY = QO.all,
        Ir = QO.IS_HTMLDDA ? function(t) {
            return typeof t == "function" || t === VY
        } : function(t) {
            return typeof t == "function"
        },
        TS = Ir,
        eA = JO,
        GY = eA.all,
        cl = eA.IS_HTMLDDA ? function(t) {
            return typeof t == "object" ? t !== null : TS(t) || t === GY
        } : function(t) {
            return typeof t == "object" ? t !== null : TS(t)
        },
        b_ = kr,
        WY = Ir,
        HY = function(t) {
            return WY(t) ? t : void 0
        },
        Fv = function(t, e) {
            return arguments.length < 2 ? HY(b_[t]) : b_[t] && b_[t][e]
        },
        KY = sr,
        tA = KY({}.isPrototypeOf),
        YY = typeof navigator < "u" && String(navigator.userAgent) || "",
        nA = kr,
        E_ = YY,
        SS = nA.process,
        wS = nA.Deno,
        OS = SS && SS.versions || wS && wS.version,
        AS = OS && OS.v8,
        gs, Sd;
    AS && (gs = AS.split("."), Sd = gs[0] > 0 && gs[0] < 4 ? 1 : +(gs[0] + gs[1]));
    !Sd && E_ && (gs = E_.match(/Edge\/(\d+)/), (!gs || gs[1] >= 74) && (gs = E_.match(/Chrome\/(\d+)/), gs && (Sd = +gs[1])));
    var zY = Sd,
        CS = zY,
        ZY = qr,
        XY = kr,
        JY = XY.String,
        rA = !!Object.getOwnPropertySymbols && !ZY(function() {
            var t = Symbol();
            return !JY(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && CS && CS < 41
        }),
        QY = rA,
        sA = QY && !Symbol.sham && typeof Symbol.iterator == "symbol",
        ez = Fv,
        tz = Ir,
        nz = tA,
        rz = sA,
        sz = Object,
        iA = rz ? function(t) {
            return typeof t == "symbol"
        } : function(t) {
            var e = ez("Symbol");
            return tz(e) && nz(e.prototype, sz(t))
        },
        iz = String,
        oz = function(t) {
            try {
                return iz(t)
            } catch {
                return "Object"
            }
        },
        az = Ir,
        cz = oz,
        lz = TypeError,
        uz = function(t) {
            if (az(t)) return t;
            throw lz(cz(t) + " is not a function")
        },
        hz = uz,
        fz = tm,
        Uv = function(t, e) {
            var n = t[e];
            return fz(n) ? void 0 : hz(n)
        },
        T_ = Lo,
        S_ = Ir,
        w_ = cl,
        dz = TypeError,
        pz = function(t, e) {
            var n, r;
            if (e === "string" && S_(n = t.toString) && !w_(r = T_(n, t)) || S_(n = t.valueOf) && !w_(r = T_(n, t)) || e !== "string" && S_(n = t.toString) && !w_(r = T_(n, t))) return r;
            throw dz("Can't convert object to primitive value")
        },
        oA = {
            exports: {}
        },
        kS = kr,
        mz = Object.defineProperty,
        Bv = function(t, e) {
            try {
                mz(kS, t, {
                    value: e,
                    configurable: !0,
                    writable: !0
                })
            } catch {
                kS[t] = e
            }
            return e
        },
        gz = kr,
        _z = Bv,
        IS = "__core-js_shared__",
        yz = gz[IS] || _z(IS, {}),
        qv = yz,
        NS = qv;
    (oA.exports = function(t, e) {
        return NS[t] || (NS[t] = e !== void 0 ? e : {})
    })("versions", []).push({
        version: "3.30.2",
        mode: "global",
        copyright: " 2014-2023 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.30.2/LICENSE",
        source: "https://github.com/zloirock/core-js"
    });
    var jv = oA.exports,
        vz = eh,
        bz = Object,
        aA = function(t) {
            return bz(vz(t))
        },
        Ez = sr,
        Tz = aA,
        Sz = Ez({}.hasOwnProperty),
        Fo = Object.hasOwn || function(e, n) {
            return Sz(Tz(e), n)
        },
        wz = sr,
        Oz = 0,
        Az = Math.random(),
        Cz = wz(1 .toString),
        cA = function(t) {
            return "Symbol(" + (t === void 0 ? "" : t) + ")_" + Cz(++Oz + Az, 36)
        },
        kz = kr,
        Iz = jv,
        xS = Fo,
        Nz = cA,
        xz = rA,
        Pz = sA,
        ac = kz.Symbol,
        O_ = Iz("wks"),
        Rz = Pz ? ac.for || ac : ac && ac.withoutSetter || Nz,
        xa = function(t) {
            return xS(O_, t) || (O_[t] = xz && xS(ac, t) ? ac[t] : Rz("Symbol." + t)), O_[t]
        },
        Mz = Lo,
        PS = cl,
        RS = iA,
        Dz = Uv,
        $z = pz,
        Lz = xa,
        Fz = TypeError,
        Uz = Lz("toPrimitive"),
        Bz = function(t, e) {
            if (!PS(t) || RS(t)) return t;
            var n = Dz(t, Uz),
                r;
            if (n) {
                if (e === void 0 && (e = "default"), r = Mz(n, t, e), !PS(r) || RS(r)) return r;
                throw Fz("Can't convert object to primitive value")
            }
            return e === void 0 && (e = "number"), $z(t, e)
        },
        qz = Bz,
        jz = iA,
        lA = function(t) {
            var e = qz(t, "string");
            return jz(e) ? e : e + ""
        },
        Vz = kr,
        MS = cl,
        O1 = Vz.document,
        Gz = MS(O1) && MS(O1.createElement),
        uA = function(t) {
            return Gz ? O1.createElement(t) : {}
        },
        Wz = $o,
        Hz = qr,
        Kz = uA,
        hA = !Wz && !Hz(function() {
            return Object.defineProperty(Kz("div"), "a", {
                get: function() {
                    return 7
                }
            }).a != 7
        }),
        Yz = $o,
        zz = Lo,
        Zz = WO,
        Xz = YO,
        Jz = nm,
        Qz = lA,
        eZ = Fo,
        tZ = hA,
        DS = Object.getOwnPropertyDescriptor;
    $v.f = Yz ? DS : function(e, n) {
        if (e = Jz(e), n = Qz(n), tZ) try {
            return DS(e, n)
        } catch {}
        if (eZ(e, n)) return Xz(!zz(Zz.f, e, n), e[n])
    };
    var th = {},
        nZ = $o,
        rZ = qr,
        fA = nZ && rZ(function() {
            return Object.defineProperty(function() {}, "prototype", {
                value: 42,
                writable: !1
            }).prototype != 42
        }),
        sZ = cl,
        iZ = String,
        oZ = TypeError,
        Pa = function(t) {
            if (sZ(t)) return t;
            throw oZ(iZ(t) + " is not an object")
        },
        aZ = $o,
        cZ = hA,
        lZ = fA,
        Of = Pa,
        $S = lA,
        uZ = TypeError,
        A_ = Object.defineProperty,
        hZ = Object.getOwnPropertyDescriptor,
        C_ = "enumerable",
        k_ = "configurable",
        I_ = "writable";
    th.f = aZ ? lZ ? function(e, n, r) {
        if (Of(e), n = $S(n), Of(r), typeof e == "function" && n === "prototype" && "value" in r && I_ in r && !r[I_]) {
            var s = hZ(e, n);
            s && s[I_] && (e[n] = r.value, r = {
                configurable: k_ in r ? r[k_] : s[k_],
                enumerable: C_ in r ? r[C_] : s[C_],
                writable: !1
            })
        }
        return A_(e, n, r)
    } : A_ : function(e, n, r) {
        if (Of(e), n = $S(n), Of(r), cZ) try {
            return A_(e, n, r)
        } catch {}
        if ("get" in r || "set" in r) throw uZ("Accessors not supported");
        return "value" in r && (e[n] = r.value), e
    };
    var fZ = $o,
        dZ = th,
        pZ = YO,
        Vv = fZ ? function(t, e, n) {
            return dZ.f(t, e, pZ(1, n))
        } : function(t, e, n) {
            return t[e] = n, t
        },
        dA = {
            exports: {}
        },
        A1 = $o,
        mZ = Fo,
        pA = Function.prototype,
        gZ = A1 && Object.getOwnPropertyDescriptor,
        Gv = mZ(pA, "name"),
        _Z = Gv && (function() {}).name === "something",
        yZ = Gv && (!A1 || A1 && gZ(pA, "name").configurable),
        vZ = {
            EXISTS: Gv,
            PROPER: _Z,
            CONFIGURABLE: yZ
        },
        bZ = sr,
        EZ = Ir,
        C1 = qv,
        TZ = bZ(Function.toString);
    EZ(C1.inspectSource) || (C1.inspectSource = function(t) {
        return TZ(t)
    });
    var SZ = C1.inspectSource,
        wZ = kr,
        OZ = Ir,
        LS = wZ.WeakMap,
        AZ = OZ(LS) && /native code/.test(String(LS)),
        CZ = jv,
        kZ = cA,
        FS = CZ("keys"),
        mA = function(t) {
            return FS[t] || (FS[t] = kZ(t))
        },
        Wv = {},
        IZ = AZ,
        gA = kr,
        NZ = cl,
        xZ = Vv,
        N_ = Fo,
        x_ = qv,
        PZ = mA,
        RZ = Wv,
        US = "Object already initialized",
        k1 = gA.TypeError,
        MZ = gA.WeakMap,
        wd, yu, Od, DZ = function(t) {
            return Od(t) ? yu(t) : wd(t, {})
        },
        $Z = function(t) {
            return function(e) {
                var n;
                if (!NZ(e) || (n = yu(e)).type !== t) throw k1("Incompatible receiver, " + t + " required");
                return n
            }
        };
    if (IZ || x_.state) {
        var Vs = x_.state || (x_.state = new MZ);
        Vs.get = Vs.get, Vs.has = Vs.has, Vs.set = Vs.set, wd = function(t, e) {
            if (Vs.has(t)) throw k1(US);
            return e.facade = t, Vs.set(t, e), e
        }, yu = function(t) {
            return Vs.get(t) || {}
        }, Od = function(t) {
            return Vs.has(t)
        }
    } else {
        var ec = PZ("state");
        RZ[ec] = !0, wd = function(t, e) {
            if (N_(t, ec)) throw k1(US);
            return e.facade = t, xZ(t, ec, e), e
        }, yu = function(t) {
            return N_(t, ec) ? t[ec] : {}
        }, Od = function(t) {
            return N_(t, ec)
        }
    }
    var _A = {
            set: wd,
            get: yu,
            has: Od,
            enforce: DZ,
            getterFor: $Z
        },
        Hv = sr,
        LZ = qr,
        FZ = Ir,
        Af = Fo,
        I1 = $o,
        UZ = vZ.CONFIGURABLE,
        BZ = SZ,
        yA = _A,
        qZ = yA.enforce,
        jZ = yA.get,
        BS = String,
        Yf = Object.defineProperty,
        VZ = Hv("".slice),
        GZ = Hv("".replace),
        WZ = Hv([].join),
        HZ = I1 && !LZ(function() {
            return Yf(function() {}, "length", {
                value: 8
            }).length !== 8
        }),
        KZ = String(String).split("String"),
        YZ = dA.exports = function(t, e, n) {
            VZ(BS(e), 0, 7) === "Symbol(" && (e = "[" + GZ(BS(e), /^Symbol\(([^)]*)\)/, "$1") + "]"), n && n.getter && (e = "get " + e), n && n.setter && (e = "set " + e), (!Af(t, "name") || UZ && t.name !== e) && (I1 ? Yf(t, "name", {
                value: e,
                configurable: !0
            }) : t.name = e), HZ && n && Af(n, "arity") && t.length !== n.arity && Yf(t, "length", {
                value: n.arity
            });
            try {
                n && Af(n, "constructor") && n.constructor ? I1 && Yf(t, "prototype", {
                    writable: !1
                }) : t.prototype && (t.prototype = void 0)
            } catch {}
            var r = qZ(t);
            return Af(r, "source") || (r.source = WZ(KZ, typeof e == "string" ? e : "")), t
        };
    Function.prototype.toString = YZ(function() {
        return FZ(this) && jZ(this).source || BZ(this)
    }, "toString");
    var zZ = dA.exports,
        ZZ = Ir,
        XZ = th,
        JZ = zZ,
        QZ = Bv,
        vA = function(t, e, n, r) {
            r || (r = {});
            var s = r.enumerable,
                i = r.name !== void 0 ? r.name : e;
            if (ZZ(n) && JZ(n, i, r), r.global) s ? t[e] = n : QZ(e, n);
            else {
                try {
                    r.unsafe ? t[e] && (s = !0) : delete t[e]
                } catch {}
                s ? t[e] = n : XZ.f(t, e, {
                    value: n,
                    enumerable: !1,
                    configurable: !r.nonConfigurable,
                    writable: !r.nonWritable
                })
            }
            return t
        },
        bA = {},
        eX = Math.ceil,
        tX = Math.floor,
        nX = Math.trunc || function(e) {
            var n = +e;
            return (n > 0 ? tX : eX)(n)
        },
        rX = nX,
        rm = function(t) {
            var e = +t;
            return e !== e || e === 0 ? 0 : rX(e)
        },
        sX = rm,
        iX = Math.max,
        oX = Math.min,
        aX = function(t, e) {
            var n = sX(t);
            return n < 0 ? iX(n + e, 0) : oX(n, e)
        },
        cX = rm,
        lX = Math.min,
        EA = function(t) {
            return t > 0 ? lX(cX(t), 9007199254740991) : 0
        },
        uX = EA,
        hX = function(t) {
            return uX(t.length)
        },
        fX = nm,
        dX = aX,
        pX = hX,
        qS = function(t) {
            return function(e, n, r) {
                var s = fX(e),
                    i = pX(s),
                    a = dX(r, i),
                    c;
                if (t && n != n) {
                    for (; i > a;)
                        if (c = s[a++], c != c) return !0
                } else
                    for (; i > a; a++)
                        if ((t || a in s) && s[a] === n) return t || a || 0;
                return !t && -1
            }
        },
        mX = {
            includes: qS(!0),
            indexOf: qS(!1)
        },
        gX = sr,
        P_ = Fo,
        _X = nm,
        yX = mX.indexOf,
        vX = Wv,
        jS = gX([].push),
        TA = function(t, e) {
            var n = _X(t),
                r = 0,
                s = [],
                i;
            for (i in n) !P_(vX, i) && P_(n, i) && jS(s, i);
            for (; e.length > r;) P_(n, i = e[r++]) && (~yX(s, i) || jS(s, i));
            return s
        },
        Kv = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
        bX = TA,
        EX = Kv,
        TX = EX.concat("length", "prototype");
    bA.f = Object.getOwnPropertyNames || function(e) {
        return bX(e, TX)
    };
    var SA = {};
    SA.f = Object.getOwnPropertySymbols;
    var SX = Fv,
        wX = sr,
        OX = bA,
        AX = SA,
        CX = Pa,
        kX = wX([].concat),
        IX = SX("Reflect", "ownKeys") || function(e) {
            var n = OX.f(CX(e)),
                r = AX.f;
            return r ? kX(n, r(e)) : n
        },
        VS = Fo,
        NX = IX,
        xX = $v,
        PX = th,
        RX = function(t, e, n) {
            for (var r = NX(e), s = PX.f, i = xX.f, a = 0; a < r.length; a++) {
                var c = r[a];
                !VS(t, c) && !(n && VS(n, c)) && s(t, c, i(e, c))
            }
        },
        MX = qr,
        DX = Ir,
        $X = /#|\.prototype\./,
        nh = function(t, e) {
            var n = FX[LX(t)];
            return n == BX ? !0 : n == UX ? !1 : DX(e) ? MX(e) : !!e
        },
        LX = nh.normalize = function(t) {
            return String(t).replace($X, ".").toLowerCase()
        },
        FX = nh.data = {},
        UX = nh.NATIVE = "N",
        BX = nh.POLYFILL = "P",
        qX = nh,
        R_ = kr,
        jX = $v.f,
        VX = Vv,
        GX = vA,
        WX = Bv,
        HX = RX,
        KX = qX,
        wA = function(t, e) {
            var n = t.target,
                r = t.global,
                s = t.stat,
                i, a, c, u, h, d;
            if (r ? a = R_ : s ? a = R_[n] || WX(n, {}) : a = (R_[n] || {}).prototype, a)
                for (c in e) {
                    if (h = e[c], t.dontCallGetSet ? (d = jX(a, c), u = d && d.value) : u = a[c], i = KX(r ? c : n + (s ? "." : "#") + c, t.forced), !i && u !== void 0) {
                        if (typeof h == typeof u) continue;
                        HX(h, u)
                    }(t.sham || u && u.sham) && VX(h, "sham", !0), GX(a, c, h, t)
                }
        },
        YX = cl,
        zX = Qu,
        ZX = xa,
        XX = ZX("match"),
        JX = function(t) {
            var e;
            return YX(t) && ((e = t[XX]) !== void 0 ? !!e : zX(t) == "RegExp")
        },
        QX = xa,
        eJ = QX("toStringTag"),
        OA = {};
    OA[eJ] = "z";
    var tJ = String(OA) === "[object z]",
        nJ = tJ,
        rJ = Ir,
        zf = Qu,
        sJ = xa,
        iJ = sJ("toStringTag"),
        oJ = Object,
        aJ = zf(function() {
            return arguments
        }()) == "Arguments",
        cJ = function(t, e) {
            try {
                return t[e]
            } catch {}
        },
        lJ = nJ ? zf : function(t) {
            var e, n, r;
            return t === void 0 ? "Undefined" : t === null ? "Null" : typeof(n = cJ(e = oJ(t), iJ)) == "string" ? n : aJ ? zf(e) : (r = zf(e)) == "Object" && rJ(e.callee) ? "Arguments" : r
        },
        uJ = lJ,
        hJ = String,
        sm = function(t) {
            if (uJ(t) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
            return hJ(t)
        },
        fJ = Pa,
        AA = function() {
            var t = fJ(this),
                e = "";
            return t.hasIndices && (e += "d"), t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.unicodeSets && (e += "v"), t.sticky && (e += "y"), e
        },
        dJ = Lo,
        pJ = Fo,
        mJ = tA,
        gJ = AA,
        GS = RegExp.prototype,
        _J = function(t) {
            var e = t.flags;
            return e === void 0 && !("flags" in GS) && !pJ(t, "flags") && mJ(GS, t) ? dJ(gJ, t) : e
        },
        Yv = sr,
        yJ = aA,
        vJ = Math.floor,
        M_ = Yv("".charAt),
        bJ = Yv("".replace),
        D_ = Yv("".slice),
        EJ = /\$([$&'`]|\d{1,2}|<[^>]*>)/g,
        TJ = /\$([$&'`]|\d{1,2})/g,
        CA = function(t, e, n, r, s, i) {
            var a = n + t.length,
                c = r.length,
                u = TJ;
            return s !== void 0 && (s = yJ(s), u = EJ), bJ(i, u, function(h, d) {
                var p;
                switch (M_(d, 0)) {
                    case "$":
                        return "$";
                    case "&":
                        return t;
                    case "`":
                        return D_(e, 0, n);
                    case "'":
                        return D_(e, a);
                    case "<":
                        p = s[D_(d, 1, -1)];
                        break;
                    default:
                        var m = +d;
                        if (m === 0) return h;
                        if (m > c) {
                            var _ = vJ(m / 10);
                            return _ === 0 ? h : _ <= c ? r[_ - 1] === void 0 ? M_(d, 1) : r[_ - 1] + M_(d, 1) : h
                        }
                        p = r[m - 1]
                }
                return p === void 0 ? "" : p
            })
        },
        SJ = wA,
        wJ = Lo,
        zv = sr,
        WS = eh,
        OJ = Ir,
        AJ = tm,
        CJ = JX,
        Bl = sm,
        kJ = Uv,
        IJ = _J,
        NJ = CA,
        xJ = xa,
        PJ = xJ("replace"),
        RJ = TypeError,
        kA = zv("".indexOf);
    zv("".replace);
    var HS = zv("".slice),
        MJ = Math.max,
        KS = function(t, e, n) {
            return n > t.length ? -1 : e === "" ? n : kA(t, e, n)
        };
    SJ({
        target: "String",
        proto: !0
    }, {
        replaceAll: function(e, n) {
            var r = WS(this),
                s, i, a, c, u, h, d, p, m, _ = 0,
                y = 0,
                v = "";
            if (!AJ(e)) {
                if (s = CJ(e), s && (i = Bl(WS(IJ(e))), !~kA(i, "g"))) throw RJ("`.replaceAll` does not allow non-global regexes");
                if (a = kJ(e, PJ), a) return wJ(a, e, r, n)
            }
            for (c = Bl(r), u = Bl(e), h = OJ(n), h || (n = Bl(n)), d = u.length, p = MJ(1, d), _ = KS(c, u, 0); _ !== -1;) m = h ? Bl(n(u, _, c)) : NJ(u, c, _, [], void 0, n), v += HS(c, y, _) + m, y = _ + d, _ = KS(c, u, _ + p);
            return y < c.length && (v += HS(c, y)), v
        }
    });
    var Zv = qr,
        DJ = kr,
        Xv = DJ.RegExp,
        Jv = Zv(function() {
            var t = Xv("a", "y");
            return t.lastIndex = 2, t.exec("abcd") != null
        }),
        $J = Jv || Zv(function() {
            return !Xv("a", "y").sticky
        }),
        LJ = Jv || Zv(function() {
            var t = Xv("^r", "gy");
            return t.lastIndex = 2, t.exec("str") != null
        }),
        FJ = {
            BROKEN_CARET: LJ,
            MISSED_STICKY: $J,
            UNSUPPORTED_Y: Jv
        },
        IA = {},
        UJ = TA,
        BJ = Kv,
        qJ = Object.keys || function(e) {
            return UJ(e, BJ)
        },
        jJ = $o,
        VJ = fA,
        GJ = th,
        WJ = Pa,
        HJ = nm,
        KJ = qJ;
    IA.f = jJ && !VJ ? Object.defineProperties : function(e, n) {
        WJ(e);
        for (var r = HJ(n), s = KJ(n), i = s.length, a = 0, c; i > a;) GJ.f(e, c = s[a++], r[c]);
        return e
    };
    var YJ = Fv,
        zJ = YJ("document", "documentElement"),
        ZJ = Pa,
        XJ = IA,
        YS = Kv,
        JJ = Wv,
        QJ = zJ,
        eQ = uA,
        tQ = mA,
        zS = ">",
        ZS = "<",
        N1 = "prototype",
        x1 = "script",
        NA = tQ("IE_PROTO"),
        $_ = function() {},
        xA = function(t) {
            return ZS + x1 + zS + t + ZS + "/" + x1 + zS
        },
        XS = function(t) {
            t.write(xA("")), t.close();
            var e = t.parentWindow.Object;
            return t = null, e
        },
        nQ = function() {
            var t = eQ("iframe"),
                e = "java" + x1 + ":",
                n;
            return t.style.display = "none", QJ.appendChild(t), t.src = String(e), n = t.contentWindow.document, n.open(), n.write(xA("document.F=Object")), n.close(), n.F
        },
        Cf, Zf = function() {
            try {
                Cf = new ActiveXObject("htmlfile")
            } catch {}
            Zf = typeof document < "u" ? document.domain && Cf ? XS(Cf) : nQ() : XS(Cf);
            for (var t = YS.length; t--;) delete Zf[N1][YS[t]];
            return Zf()
        };
    JJ[NA] = !0;
    var rQ = Object.create || function(e, n) {
            var r;
            return e !== null ? ($_[N1] = ZJ(e), r = new $_, $_[N1] = null, r[NA] = e) : r = Zf(), n === void 0 ? r : XJ.f(r, n)
        },
        sQ = qr,
        iQ = kr,
        oQ = iQ.RegExp,
        aQ = sQ(function() {
            var t = oQ(".", "s");
            return !(t.dotAll && t.exec(`
`) && t.flags === "s")
        }),
        cQ = qr,
        lQ = kr,
        uQ = lQ.RegExp,
        hQ = cQ(function() {
            var t = uQ("(?<a>b)", "g");
            return t.exec("b").groups.a !== "b" || "b".replace(t, "$<a>c") !== "bc"
        }),
        cc = Lo,
        im = sr,
        fQ = sm,
        dQ = AA,
        pQ = FJ,
        mQ = jv,
        gQ = rQ,
        _Q = _A.get,
        yQ = aQ,
        vQ = hQ,
        bQ = mQ("native-string-replace", String.prototype.replace),
        Ad = RegExp.prototype.exec,
        P1 = Ad,
        EQ = im("".charAt),
        TQ = im("".indexOf),
        SQ = im("".replace),
        L_ = im("".slice),
        R1 = function() {
            var t = /a/,
                e = /b*/g;
            return cc(Ad, t, "a"), cc(Ad, e, "a"), t.lastIndex !== 0 || e.lastIndex !== 0
        }(),
        PA = pQ.BROKEN_CARET,
        M1 = /()??/.exec("")[1] !== void 0,
        wQ = R1 || M1 || PA || yQ || vQ;
    wQ && (P1 = function(e) {
        var n = this,
            r = _Q(n),
            s = fQ(e),
            i = r.raw,
            a, c, u, h, d, p, m;
        if (i) return i.lastIndex = n.lastIndex, a = cc(P1, i, s), n.lastIndex = i.lastIndex, a;
        var _ = r.groups,
            y = PA && n.sticky,
            v = cc(dQ, n),
            w = n.source,
            b = 0,
            I = s;
        if (y && (v = SQ(v, "y", ""), TQ(v, "g") === -1 && (v += "g"), I = L_(s, n.lastIndex), n.lastIndex > 0 && (!n.multiline || n.multiline && EQ(s, n.lastIndex - 1) !== `
`) && (w = "(?: " + w + ")", I = " " + I, b++), c = new RegExp("^(?:" + w + ")", v)), M1 && (c = new RegExp("^" + w + "$(?!\\s)", v)), R1 && (u = n.lastIndex), h = cc(Ad, y ? c : n, I), y ? h ? (h.input = L_(h.input, b), h[0] = L_(h[0], b), h.index = n.lastIndex, n.lastIndex += h[0].length) : n.lastIndex = 0 : R1 && h && (n.lastIndex = n.global ? h.index + h[0].length : u), M1 && h && h.length > 1 && cc(bQ, h[0], c, function() {
                for (d = 1; d < arguments.length - 2; d++) arguments[d] === void 0 && (h[d] = void 0)
            }), h && _)
            for (h.groups = p = gQ(null), d = 0; d < _.length; d++) m = _[d], p[m[0]] = h[m[1]];
        return h
    });
    var Qv = P1,
        OQ = wA,
        JS = Qv;
    OQ({
        target: "RegExp",
        proto: !0,
        forced: /./.exec !== JS
    }, {
        exec: JS
    });
    var AQ = Lv,
        RA = Function.prototype,
        QS = RA.apply,
        ew = RA.call,
        CQ = typeof Reflect == "object" && Reflect.apply || (AQ ? ew.bind(QS) : function() {
            return ew.apply(QS, arguments)
        }),
        kQ = Qu,
        IQ = sr,
        NQ = function(t) {
            if (kQ(t) === "Function") return IQ(t)
        },
        tw = NQ,
        nw = vA,
        xQ = Qv,
        rw = qr,
        MA = xa,
        PQ = Vv,
        RQ = MA("species"),
        F_ = RegExp.prototype,
        MQ = function(t, e, n, r) {
            var s = MA(t),
                i = !rw(function() {
                    var h = {};
                    return h[s] = function() {
                        return 7
                    }, "" [t](h) != 7
                }),
                a = i && !rw(function() {
                    var h = !1,
                        d = /a/;
                    return t === "split" && (d = {}, d.constructor = {}, d.constructor[RQ] = function() {
                        return d
                    }, d.flags = "", d[s] = /./ [s]), d.exec = function() {
                        return h = !0, null
                    }, d[s](""), !h
                });
            if (!i || !a || n) {
                var c = tw(/./ [s]),
                    u = e(s, "" [t], function(h, d, p, m, _) {
                        var y = tw(h),
                            v = d.exec;
                        return v === xQ || v === F_.exec ? i && !_ ? {
                            done: !0,
                            value: c(d, p, m)
                        } : {
                            done: !0,
                            value: y(p, d, m)
                        } : {
                            done: !1
                        }
                    });
                nw(String.prototype, t, u[0]), nw(F_, s, u[1])
            }
            r && PQ(F_[s], "sham", !0)
        },
        e0 = sr,
        DQ = rm,
        $Q = sm,
        LQ = eh,
        FQ = e0("".charAt),
        sw = e0("".charCodeAt),
        UQ = e0("".slice),
        iw = function(t) {
            return function(e, n) {
                var r = $Q(LQ(e)),
                    s = DQ(n),
                    i = r.length,
                    a, c;
                return s < 0 || s >= i ? t ? "" : void 0 : (a = sw(r, s), a < 55296 || a > 56319 || s + 1 === i || (c = sw(r, s + 1)) < 56320 || c > 57343 ? t ? FQ(r, s) : a : t ? UQ(r, s, s + 2) : (a - 55296 << 10) + (c - 56320) + 65536)
            }
        },
        BQ = {
            codeAt: iw(!1),
            charAt: iw(!0)
        },
        qQ = BQ.charAt,
        jQ = function(t, e, n) {
            return e + (n ? qQ(t, e).length : 1)
        },
        ow = Lo,
        VQ = Pa,
        GQ = Ir,
        WQ = Qu,
        HQ = Qv,
        KQ = TypeError,
        YQ = function(t, e) {
            var n = t.exec;
            if (GQ(n)) {
                var r = ow(n, t, e);
                return r !== null && VQ(r), r
            }
            if (WQ(t) === "RegExp") return ow(HQ, t, e);
            throw KQ("RegExp#exec called on incompatible receiver")
        },
        zQ = CQ,
        aw = Lo,
        om = sr,
        ZQ = MQ,
        XQ = qr,
        JQ = Pa,
        QQ = Ir,
        eee = tm,
        tee = rm,
        nee = EA,
        tc = sm,
        ree = eh,
        see = jQ,
        iee = Uv,
        oee = CA,
        aee = YQ,
        cee = xa,
        D1 = cee("replace"),
        lee = Math.max,
        uee = Math.min,
        hee = om([].concat),
        U_ = om([].push),
        cw = om("".indexOf),
        lw = om("".slice),
        fee = function(t) {
            return t === void 0 ? t : String(t)
        },
        dee = function() {
            return "a".replace(/./, "$0") === "$0"
        }(),
        uw = function() {
            return /./ [D1] ? /./ [D1]("a", "$0") === "" : !1
        }(),
        pee = !XQ(function() {
            var t = /./;
            return t.exec = function() {
                var e = [];
                return e.groups = {
                    a: "7"
                }, e
            }, "".replace(t, "$<a>") !== "7"
        });
    ZQ("replace", function(t, e, n) {
        var r = uw ? "$" : "$0";
        return [function(i, a) {
            var c = ree(this),
                u = eee(i) ? void 0 : iee(i, D1);
            return u ? aw(u, i, c, a) : aw(e, tc(c), i, a)
        }, function(s, i) {
            var a = JQ(this),
                c = tc(s);
            if (typeof i == "string" && cw(i, r) === -1 && cw(i, "$<") === -1) {
                var u = n(e, a, c, i);
                if (u.done) return u.value
            }
            var h = QQ(i);
            h || (i = tc(i));
            var d = a.global;
            if (d) {
                var p = a.unicode;
                a.lastIndex = 0
            }
            for (var m = [];;) {
                var _ = aee(a, c);
                if (_ === null || (U_(m, _), !d)) break;
                var y = tc(_[0]);
                y === "" && (a.lastIndex = see(c, nee(a.lastIndex), p))
            }
            for (var v = "", w = 0, b = 0; b < m.length; b++) {
                _ = m[b];
                for (var I = tc(_[0]), F = lee(uee(tee(_.index), c.length), 0), x = [], O = 1; O < _.length; O++) U_(x, fee(_[O]));
                var M = _.groups;
                if (h) {
                    var $ = hee([I], x, F, c);
                    M !== void 0 && U_($, M);
                    var j = tc(zQ(i, void 0, $))
                } else j = oee(I, c, F, x, M, i);
                F >= w && (v += lw(c, w, F) + j, w = F + I.length)
            }
            return v + lw(c, w)
        }]
    }, !pee || !dee || uw);
    var mee = kr,
        gee = sr,
        _ee = function(t, e) {
            return gee(mee[t].prototype[e])
        },
        yee = _ee;
    yee("String", "replaceAll");
    var Ei = {},
        am = {},
        DA = {},
        cm = {},
        t0 = {};
    (function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.Token = void 0;
        var e = function() {
            function n(r, s, i, a) {
                this.type = r, this.content = s, this.attributes = i, this.text = a
            }
            return n.prototype.toString = function() {
                return this.content + " (" + this.type + ")"
            }, n.prototype.equals = function(r) {
                return this.type === r.type && this.content === r.content
            }, n.prototype.convertToTextToken = function() {
                var r;
                this.type === n.Type.startTag ? (this.content = (r = this.text) !== null && r !== void 0 ? r : "", this.type = n.Type.text) : this.type === n.Type.endTag && (this.content = "[/" + this.content + "]", this.type = n.Type.text)
            }, n
        }();
        t.Token = e,
            function(n) {
                (function(r) {
                    r[r.text = 0] = "text", r[r.startTag = 1] = "startTag", r[r.endTag = 2] = "endTag"
                })(n.Type || (n.Type = {}))
            }(e = t.Token || (t.Token = {})), t.Token = e
    })(t0);
    Object.defineProperty(cm, "__esModule", {
        value: !0
    });
    cm.Tokenizer = void 0;
    var to = t0,
        vee = function() {
            function t(e) {
                this.tags = e
            }
            return t.prototype.tokenizeString = function(e) {
                var n = this,
                    r = this.getTokens(e),
                    s = [],
                    i = !1,
                    a = "",
                    c = "";
                return r.forEach(function(u) {
                    var h = n.tags[u.content],
                        d = !0;
                    !h && !i ? u.convertToTextToken() : i ? u.type === to.Token.Type.endTag && u.content === a ? (i = !1, s.push(t.createTextToken(c))) : (u.convertToTextToken(), c += u.content, d = !1) : h.noNesting && u.type === to.Token.Type.startTag && (i = !0, a = u.content, c = ""), d && s.push(u)
                }), s
            }, t.prototype.getTokens = function(e) {
                for (var n = '\\[(/\\w*)\\]|\\[(\\w*)+(=(["])' + t.valueChars + "*\\4)?( (" + t.nameChars + '+)?=(["])(' + t.valueChars + "+)\\7)*\\]", r = new RegExp(n, "g"), s = [], i = r.exec(e), a = 0; i;) {
                    var c = i.index - a;
                    c > 0 && s.push(t.createTextToken(e.substr(a, c))), s.push(t.createTagToken(i)), a = r.lastIndex, i = r.exec(e)
                }
                var u = e.length - a;
                return u > 0 && s.push(t.createTextToken(e.substr(a, u))), s
            }, t.createTextToken = function(e) {
                return new to.Token(to.Token.Type.text, e)
            }, t.createTagToken = function(e) {
                if (!e[1]) {
                    for (var n = e[2], r = {}, s = new RegExp("(" + t.nameChars + '+)?=(["])(' + t.valueChars + "+)\\2", "g"), i = e[0].substr(1 + n.length, e[0].length - 2 - n.length), a = s.exec(i); a;) a[1] ? r[a[1]] = a[3] : r[n] = a[3], a = s.exec(i);
                    return new to.Token(to.Token.Type.startTag, n, r, e[0])
                }
                return new to.Token(to.Token.Type.endTag, e[1].substr(1, e[1].length - 1))
            }, t.nameChars = "[a-zA-Z0-9\\.\\-_:;/]", t.valueChars = "[a-zA-Z0-9\\.\\-_:;#/\\s]", t
        }();
    cm.Tokenizer = vee;
    (function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.ParseTree = void 0;
        var e = cm,
            n = t0,
            r = function() {
                function s(i) {
                    this.subTrees = [], this.type = i.type, this.content = i.content, i.attributes && (this.attributes = i.attributes), i.subTrees && (this.subTrees = i.subTrees)
                }
                return Object.defineProperty(s.prototype, "isValid", {
                    get: function() {
                        return this.subTrees.length ? this.subTrees.every(function(i) {
                            return i.isValid
                        }) : !0
                    },
                    enumerable: !1,
                    configurable: !0
                }), s.prototype.toString = function() {
                    return this.type + " - " + this.content
                }, s.buildTree = function(i, a) {
                    var c = new e.Tokenizer(a),
                        u = c.tokenizeString(i),
                        h = new s({
                            type: s.Type.root,
                            content: i
                        });
                    return this.buildTreeFromTokens(h, u.reverse())
                }, s.buildTreeFromTokens = function(i, a, c) {
                    if (c === void 0 && (c = ""), !i) return null;
                    if (!a.length) return i;
                    var u = a.pop();
                    if (!u) return null;
                    if (u.type === n.Token.Type.text) {
                        var h = new s({
                            type: s.Type.text,
                            content: u.content
                        });
                        i.subTrees.push(h)
                    }
                    if (u.type === n.Token.Type.startTag) {
                        var d = u.content,
                            h = new s({
                                type: s.Type.tag,
                                content: d,
                                attributes: u.attributes
                            }),
                            p = s.buildTreeFromTokens(h, a, d);
                        if (!p) return null;
                        i.subTrees.push(p)
                    }
                    if (u.type === n.Token.Type.endTag) {
                        var d = u.content;
                        return d === c ? i : null
                    }
                    return !a.length && c !== "" ? null : this.buildTreeFromTokens(i, a, c)
                }, s
            }();
        t.ParseTree = r,
            function(s) {
                (function(i) {
                    i[i.root = 0] = "root", i[i.text = 1] = "text", i[i.tag = 2] = "tag"
                })(s.Type || (s.Type = {}))
            }(r = t.ParseTree || (t.ParseTree = {})), t.ParseTree = r
    })(DA);
    var rh = {};
    Object.defineProperty(rh, "__esModule", {
        value: !0
    });
    rh.Tag = void 0;
    var bee = function() {
        function t(e) {
            var n;
            this.tagName = e.tagName, this.insertLineBreaks = e.insertLineBreaks, this.suppressLineBreaks = e.suppressLineBreaks, this.noNesting = e.noNesting, this.markupGenerator = (n = e.markupGenerator) !== null && n !== void 0 ? n : function(r, s) {
                return "<" + r.tagName + ">" + s + "</" + r.tagName + ">"
            }
        }
        return t.create = function(e, n, r) {
            var s, i, a;
            return r === void 0 && (r = {}), new t({
                tagName: e,
                insertLineBreaks: (s = r.insertLineBreaks) !== null && s !== void 0 ? s : !0,
                suppressLineBreaks: (i = r.suppressLineBreaks) !== null && i !== void 0 ? i : !1,
                noNesting: (a = r.noNesting) !== null && a !== void 0 ? a : !1,
                markupGenerator: n
            })
        }, t
    }();
    rh.Tag = bee;
    Object.defineProperty(am, "__esModule", {
        value: !0
    });
    am.BBCodeParser = void 0;
    var hw = DA,
        fw = rh,
        Eee = function() {
            function t(e, n) {
                this.options = n, this.escapeHTML = !1, this.tags = e, n && (this.escapeHTML = n.escapeHTML)
            }
            return Object.defineProperty(t, "defaultTags", {
                get: function() {
                    return {
                        b: fw.Tag.create("b"),
                        i: fw.Tag.create("i")
                    }
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.parse = function(e, n, r, s) {
                n === void 0 && (n = !1), r === void 0 && (r = !0), s === void 0 && (s = !0);
                var i = hw.ParseTree.buildTree(e, this.tags);
                return !i || !i.isValid ? e : this.treeToHtml(i.subTrees, r, s, n)
            }, t.prototype.addTag = function(e, n) {
                this.tags[e] = n
            }, t.prototype.treeToHtml = function(e, n, r, s) {
                var i = this;
                s === void 0 && (s = !1);
                var a = "",
                    c = !1;
                return e.forEach(function(u) {
                    var h;
                    if (u.type === hw.ParseTree.Type.text) {
                        var d = u.content;
                        r && (d = i.escapeHTML ? t.escapeHTML(d) : d), n && !c && (d = d.replace(/(\r\n|\n|\r)/gm, "<br>"), c = !1), a += d
                    } else {
                        var p = i.tags[u.content],
                            m = i.treeToHtml(u.subTrees, p.insertLineBreaks, r, s);
                        s ? a += m : a += p.markupGenerator(p, m, (h = u.attributes) !== null && h !== void 0 ? h : {}), c = p.suppressLineBreaks
                    }
                }), a
            }, t.escapeHTML = function(e) {
                return e.replace(/[&<>]/g, function(n) {
                    return t.tagsToReplace[n] || n
                })
            }, t.tagsToReplace = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;"
            }, t
        }();
    am.BBCodeParser = Eee;
    (function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.Tag = t.BBCodeParser = void 0;
        var e = am;
        Object.defineProperty(t, "BBCodeParser", {
            enumerable: !0,
            get: function() {
                return e.BBCodeParser
            }
        });
        var n = rh;
        Object.defineProperty(t, "Tag", {
            enumerable: !0,
            get: function() {
                return n.Tag
            }
        })
    })(Ei);
    const Tee = {
            install: t => {
                const e = {
                    section: Ei.Tag.create("section", (i, a, {
                        section: c
                    }) => `<div ${c?`class="section ${c}"`:'class="section"'}>${a}</div>`)
                };
                ["b", "bold", "B"].forEach(i => {
                    e[i] = Ei.Tag.create(i, (a, c) => `<strong>${c}</strong>`)
                }), ["i", "italic", "I"].forEach(i => {
                    e[i] = Ei.Tag.create(i, (a, c) => `<em>${c}</em>`)
                }), e.tos = Ei.Tag.create("tos", (i, a) => `<a class="tosLink" href="https://jackboxgames.com/terms-of-service/" target="_blank">${a}</a>`), e.pp = Ei.Tag.create("pp", (i, a) => `<a class="ppLink" href="https://jackboxgames.com/privacy-policy/" target="_blank">${a}</a>`);
                const s = new Ei.BBCodeParser(e);
                t.directive("bb", {
                    mounted(i, a) {
                        const c = document.createElement("div");
                        c.textContent = a.value, i.innerHTML = s.parse(c.innerHTML)
                    },
                    updated(i, a) {
                        const c = document.createElement("div");
                        c.textContent = a.value, i.innerHTML = s.parse(c.innerHTML)
                    }
                }), t.mixin({
                    beforeCreate() {
                        this.$options.bb && Object.keys(this.$options.bb).forEach(i => {
                            const a = this.$options.bb[i];
                            if (a instanceof Function) {
                                s.addTag(i, Ei.Tag.create(i, a));
                                return
                            }
                            s.addTag(i, Ei.Tag.create(i, a.generator, a.options))
                        })
                    }
                }), t.config.globalProperties.$bb = i => (typeof i != "string" && console.warn(`[BBCodePlugin] Received unexpected ${typeof i} with value ${i};converting to string before parsing.`), s.parse(String(i)))
            }
        },
        See = mt({
            data() {
                return {
                    showPowerNav: !1
                }
            },
            computed: {
                debugNav() {
                    return this.$refs.debugNav
                },
                replayer() {
                    return this.$debugReplayer
                }
            },
            mounted() {
                window.addEventListener("keydown", t => {
                    var e, n, r, s;
                    return t.key === "," ? (e = this.replayer) == null ? void 0 : e.toPreviousEntity() : t.key === "." ? (n = this.replayer) == null ? void 0 : n.toNextEntity() : t.key === "q" ? (r = this.replayer) == null ? void 0 : r.toPreviousMarker() : t.key === "w" ? (s = this.replayer) == null ? void 0 : s.toNextMarker() : null
                })
            },
            methods: {
                onPreviousClick() {
                    var t;
                    (t = this.replayer) == null || t.toPreviousMarker()
                },
                onNextClick() {
                    var t;
                    (t = this.replayer) == null || t.toNextMarker()
                },
                onOpenPowerNavClick() {
                    this.showPowerNav = !0, this.debugNav.focus()
                },
                onClosePowerNavClick() {
                    this.showPowerNav = !1, this.debugNav.focus()
                },
                onMarkerClick(t) {
                    var e;
                    (e = this.replayer) == null || e.toMarkerIndex(t)
                },
                onKillClick() {
                    var t;
                    (t = this.replayer) == null || t.kill()
                },
                onDisconnectClick() {
                    var t;
                    (t = this.replayer) == null || t.disconnect()
                }
            }
        }),
        Ui = t => (Ns("data-v-220ec4c0"), t = t(), xs(), t),
        wee = {
            key: 0,
            ref: "debugNav",
            class: "debug-nav",
            tabindex: "0"
        },
        Oee = {
            key: 0,
            class: "power-nav"
        },
        Aee = Ui(() => B("p", null, "MARKERS", -1)),
        Cee = ["onClick"],
        kee = Ui(() => B("br", null, null, -1)),
        Iee = Ui(() => B("p", {
            class: "title blurred"
        }, "DEBUG", -1)),
        Nee = {
            key: 1,
            class: "title focused"
        },
        xee = {
            key: 2,
            class: "title focused"
        },
        Pee = Ui(() => B("svg", {
            viewBox: "0 0 20 10"
        }, [B("polygon", {
            points: "0,10 10,0 20,10"
        })], -1)),
        Ree = Ui(() => B("div", {
            class: "visually-hidden"
        }, "Open debug menu", -1)),
        Mee = [Pee, Ree],
        Dee = Ui(() => B("svg", {
            viewBox: "0 0 60 50"
        }, [B("polygon", {
            class: "outline",
            points: "40,35.6 20,25 40,14.4"
        }), B("polygon", {
            points: "40,35.6 20,25 40,14.4"
        })], -1)),
        $ee = Ui(() => B("div", {
            class: "visually-hidden"
        }, "Previous", -1)),
        Lee = [Dee, $ee],
        Fee = Ui(() => B("svg", {
            viewBox: "0 0 60 50"
        }, [B("polygon", {
            class: "outline",
            points: "40,35.6 20,25 40,14.4"
        }), B("polygon", {
            points: "40,35.6 20,25 40,14.4"
        })], -1)),
        Uee = Ui(() => B("div", {
            class: "visually-hidden"
        }, "Next", -1)),
        Bee = [Fee, Uee];

    function qee(t, e, n, r, s, i) {
        return t.replayer ? (G(), H("div", wee, [t.showPowerNav ? (G(), H("div", Oee, [B("button", {
            class: "close",
            onClick: e[0] || (e[0] = (...a) => t.onClosePowerNavClick && t.onClosePowerNavClick(...a))
        }, "X"), Aee, B("ul", null, [(G(!0), H(Tt, null, $n(t.replayer.markerMap, (a, c) => (G(), H("li", {
            key: c,
            class: Xe({
                active: c === t.replayer.currentMarkerItemIndex
            }),
            onClick: u => t.onMarkerClick(c)
        }, vt(a[1].marker), 11, Cee))), 128))]), B("button", {
            class: "option",
            onClick: e[1] || (e[1] = (...a) => t.onKillClick && t.onKillClick(...a))
        }, [Nn("KILL"), kee, Nn("ROOM")]), B("button", {
            class: "option",
            onClick: e[2] || (e[2] = (...a) => t.onDisconnectClick && t.onDisconnectClick(...a))
        }, "DISCONNECT")])) : Be("", !0), Iee, t.replayer.markerMap.length ? (G(), H("p", xee, vt(t.replayer.currentMarkerItemIndex) + " : " + vt(t.replayer.currentMarkerItem[1].marker) + " (" + vt(t.replayer.currentEntityItemIndex) + ") ", 1)) : (G(), H("p", Nee, "Item #" + vt(t.replayer.currentEntityItemIndex), 1)), t.showPowerNav ? Be("", !0) : (G(), H("button", {
            key: 3,
            class: "open-power-nav",
            onClick: e[3] || (e[3] = (...a) => t.onOpenPowerNavClick && t.onOpenPowerNavClick(...a))
        }, Mee)), B("button", {
            class: "direction previous",
            onClick: e[4] || (e[4] = (...a) => t.onPreviousClick && t.onPreviousClick(...a))
        }, Lee), B("button", {
            class: "direction next",
            onClick: e[5] || (e[5] = (...a) => t.onNextClick && t.onNextClick(...a))
        }, Bee)], 512)) : Be("", !0)
    }
    const jee = ot(See, [
        ["render", qee],
        ["__scopeId", "data-v-220ec4c0"]
    ]);

    function Vee(t, e) {
        for (var n = -1, r = t == null ? 0 : t.length; ++n < r && e(t[n], n, t) !== !1;);
        return t
    }
    var Gee = Vee,
        Wee = O4,
        Hee = Wee(Object.keys, Object),
        Kee = Hee,
        Yee = hv,
        zee = Kee,
        Zee = Object.prototype,
        Xee = Zee.hasOwnProperty;

    function Jee(t) {
        if (!Yee(t)) return zee(t);
        var e = [];
        for (var n in Object(t)) Xee.call(t, n) && n != "constructor" && e.push(n);
        return e
    }
    var Qee = Jee,
        ete = R4,
        tte = Qee,
        nte = Xp;

    function rte(t) {
        return nte(t) ? ete(t) : tte(t)
    }
    var lm = rte,
        ste = zu,
        ite = lm;

    function ote(t, e) {
        return t && ste(e, ite(e), t)
    }
    var ate = ote,
        cte = zu,
        lte = Zu;

    function ute(t, e) {
        return t && cte(e, lte(e), t)
    }
    var hte = ute;

    function fte(t, e) {
        for (var n = -1, r = t == null ? 0 : t.length, s = 0, i = []; ++n < r;) {
            var a = t[n];
            e(a, n, t) && (i[s++] = a)
        }
        return i
    }
    var dte = fte;

    function pte() {
        return []
    }
    var $A = pte,
        mte = dte,
        gte = $A,
        _te = Object.prototype,
        yte = _te.propertyIsEnumerable,
        dw = Object.getOwnPropertySymbols,
        vte = dw ? function(t) {
            return t == null ? [] : (t = Object(t), mte(dw(t), function(e) {
                return yte.call(t, e)
            }))
        } : gte,
        n0 = vte,
        bte = zu,
        Ete = n0;

    function Tte(t, e) {
        return bte(t, Ete(t), e)
    }
    var Ste = Tte;

    function wte(t, e) {
        for (var n = -1, r = e.length, s = t.length; ++n < r;) t[s + n] = e[n];
        return t
    }
    var LA = wte,
        Ote = LA,
        Ate = uv,
        Cte = n0,
        kte = $A,
        Ite = Object.getOwnPropertySymbols,
        Nte = Ite ? function(t) {
            for (var e = []; t;) Ote(e, Cte(t)), t = Ate(t);
            return e
        } : kte,
        FA = Nte,
        xte = zu,
        Pte = FA;

    function Rte(t, e) {
        return xte(t, Pte(t), e)
    }
    var Mte = Rte,
        Dte = LA,
        $te = Mo;

    function Lte(t, e, n) {
        var r = e(t);
        return $te(t) ? r : Dte(r, n(t))
    }
    var UA = Lte,
        Fte = UA,
        Ute = n0,
        Bte = lm;

    function qte(t) {
        return Fte(t, Bte, Ute)
    }
    var jte = qte,
        Vte = UA,
        Gte = FA,
        Wte = Zu;

    function Hte(t) {
        return Vte(t, Wte, Gte)
    }
    var Kte = Hte,
        Yte = Na,
        zte = Ps,
        Zte = Yte(zte, "DataView"),
        Xte = Zte,
        Jte = Na,
        Qte = Ps,
        ene = Jte(Qte, "Promise"),
        tne = ene,
        nne = Na,
        rne = Ps,
        sne = nne(rne, "Set"),
        ine = sne,
        one = Na,
        ane = Ps,
        cne = one(ane, "WeakMap"),
        lne = cne,
        $1 = Xte,
        L1 = av,
        F1 = tne,
        U1 = ine,
        B1 = lne,
        BA = rl,
        ll = _4,
        pw = "[object Map]",
        une = "[object Object]",
        mw = "[object Promise]",
        gw = "[object Set]",
        _w = "[object WeakMap]",
        yw = "[object DataView]",
        hne = ll($1),
        fne = ll(L1),
        dne = ll(F1),
        pne = ll(U1),
        mne = ll(B1),
        ra = BA;
    ($1 && ra(new $1(new ArrayBuffer(1))) != yw || L1 && ra(new L1) != pw || F1 && ra(F1.resolve()) != mw || U1 && ra(new U1) != gw || B1 && ra(new B1) != _w) && (ra = function(t) {
        var e = BA(t),
            n = e == une ? t.constructor : void 0,
            r = n ? ll(n) : "";
        if (r) switch (r) {
            case hne:
                return yw;
            case fne:
                return pw;
            case dne:
                return mw;
            case pne:
                return gw;
            case mne:
                return _w
        }
        return e
    });
    var r0 = ra,
        gne = Object.prototype,
        _ne = gne.hasOwnProperty;

    function yne(t) {
        var e = t.length,
            n = new t.constructor(e);
        return e && typeof t[0] == "string" && _ne.call(t, "index") && (n.index = t.index, n.input = t.input), n
    }
    var vne = yne,
        bne = lv;

    function Ene(t, e) {
        var n = e ? bne(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.byteLength)
    }
    var Tne = Ene,
        Sne = /\w*$/;

    function wne(t) {
        var e = new t.constructor(t.source, Sne.exec(t));
        return e.lastIndex = t.lastIndex, e
    }
    var One = wne,
        vw = Yp,
        bw = vw ? vw.prototype : void 0,
        Ew = bw ? bw.valueOf : void 0;

    function Ane(t) {
        return Ew ? Object(Ew.call(t)) : {}
    }
    var Cne = Ane,
        kne = lv,
        Ine = Tne,
        Nne = One,
        xne = Cne,
        Pne = S4,
        Rne = "[object Boolean]",
        Mne = "[object Date]",
        Dne = "[object Map]",
        $ne = "[object Number]",
        Lne = "[object RegExp]",
        Fne = "[object Set]",
        Une = "[object String]",
        Bne = "[object Symbol]",
        qne = "[object ArrayBuffer]",
        jne = "[object DataView]",
        Vne = "[object Float32Array]",
        Gne = "[object Float64Array]",
        Wne = "[object Int8Array]",
        Hne = "[object Int16Array]",
        Kne = "[object Int32Array]",
        Yne = "[object Uint8Array]",
        zne = "[object Uint8ClampedArray]",
        Zne = "[object Uint16Array]",
        Xne = "[object Uint32Array]";

    function Jne(t, e, n) {
        var r = t.constructor;
        switch (e) {
            case qne:
                return kne(t);
            case Rne:
            case Mne:
                return new r(+t);
            case jne:
                return Ine(t, n);
            case Vne:
            case Gne:
            case Wne:
            case Hne:
            case Kne:
            case Yne:
            case zne:
            case Zne:
            case Xne:
                return Pne(t, n);
            case Dne:
                return new r;
            case $ne:
            case Une:
                return new r(t);
            case Lne:
                return Nne(t);
            case Fne:
                return new r;
            case Bne:
                return xne(t)
        }
    }
    var Qne = Jne,
        ere = r0,
        tre = Ro,
        nre = "[object Map]";

    function rre(t) {
        return tre(t) && ere(t) == nre
    }
    var sre = rre,
        ire = sre,
        ore = dv,
        Tw = pv,
        Sw = Tw && Tw.isMap,
        are = Sw ? ore(Sw) : ire,
        cre = are,
        lre = r0,
        ure = Ro,
        hre = "[object Set]";

    function fre(t) {
        return ure(t) && lre(t) == hre
    }
    var dre = fre,
        pre = dre,
        mre = dv,
        ww = pv,
        Ow = ww && ww.isSet,
        gre = Ow ? mre(Ow) : pre,
        _re = gre,
        yre = v4,
        vre = Gee,
        bre = mv,
        Ere = ate,
        Tre = hte,
        Sre = T4,
        wre = w4,
        Ore = Ste,
        Are = Mte,
        Cre = jte,
        kre = Kte,
        Ire = r0,
        Nre = vne,
        xre = Qne,
        Pre = A4,
        Rre = Mo,
        Mre = fv,
        Dre = cre,
        $re = Rs,
        Lre = _re,
        Fre = lm,
        Ure = Zu,
        Bre = 1,
        qre = 2,
        jre = 4,
        qA = "[object Arguments]",
        Vre = "[object Array]",
        Gre = "[object Boolean]",
        Wre = "[object Date]",
        Hre = "[object Error]",
        jA = "[object Function]",
        Kre = "[object GeneratorFunction]",
        Yre = "[object Map]",
        zre = "[object Number]",
        VA = "[object Object]",
        Zre = "[object RegExp]",
        Xre = "[object Set]",
        Jre = "[object String]",
        Qre = "[object Symbol]",
        ese = "[object WeakMap]",
        tse = "[object ArrayBuffer]",
        nse = "[object DataView]",
        rse = "[object Float32Array]",
        sse = "[object Float64Array]",
        ise = "[object Int8Array]",
        ose = "[object Int16Array]",
        ase = "[object Int32Array]",
        cse = "[object Uint8Array]",
        lse = "[object Uint8ClampedArray]",
        use = "[object Uint16Array]",
        hse = "[object Uint32Array]",
        Gt = {};
    Gt[qA] = Gt[Vre] = Gt[tse] = Gt[nse] = Gt[Gre] = Gt[Wre] = Gt[rse] = Gt[sse] = Gt[ise] = Gt[ose] = Gt[ase] = Gt[Yre] = Gt[zre] = Gt[VA] = Gt[Zre] = Gt[Xre] = Gt[Jre] = Gt[Qre] = Gt[cse] = Gt[lse] = Gt[use] = Gt[hse] = !0;
    Gt[Hre] = Gt[jA] = Gt[ese] = !1;

    function Xf(t, e, n, r, s, i) {
        var a, c = e & Bre,
            u = e & qre,
            h = e & jre;
        if (n && (a = s ? n(t, r, s, i) : n(t)), a !== void 0) return a;
        if (!$re(t)) return t;
        var d = Rre(t);
        if (d) {
            if (a = Nre(t), !c) return wre(t, a)
        } else {
            var p = Ire(t),
                m = p == jA || p == Kre;
            if (Mre(t)) return Sre(t, c);
            if (p == VA || p == qA || m && !s) {
                if (a = u || m ? {} : Pre(t), !c) return u ? Are(t, Tre(a, t)) : Ore(t, Ere(a, t))
            } else {
                if (!Gt[p]) return s ? t : {};
                a = xre(t, p, c)
            }
        }
        i || (i = new yre);
        var _ = i.get(t);
        if (_) return _;
        i.set(t, a), Lre(t) ? t.forEach(function(w) {
            a.add(Xf(w, e, n, w, t, i))
        }) : Dre(t) && t.forEach(function(w, b) {
            a.set(b, Xf(w, e, n, b, t, i))
        });
        var y = h ? u ? kre : Cre : u ? Ure : Fre,
            v = d ? void 0 : y(t);
        return vre(v || t, function(w, b) {
            v && (b = w, w = t[b]), bre(a, b, Xf(w, e, n, b, t, i))
        }), a
    }
    var fse = Xf,
        dse = fse,
        pse = 1,
        mse = 4;

    function gse(t) {
        return dse(t, pse | mse)
    }
    var _se = gse;
    const GA = el(_se),
        yse = mt({
            emits: {
                resolve: () => !0
            },
            data() {
                return {
                    screen: "options",
                    vibe: null,
                    message: "",
                    content: null,
                    isContent: !0,
                    values: {}
                }
            },
            mounted() {
                var e, n;
                const t = (n = (e = this.$debugRecorder) == null ? void 0 : e.room) == null ? void 0 : n.appTag;
                t && (this.values = GA(this.$ecastValues), this.content = ES.getPromptGuess(this.values, t) ?? null)
            },
            methods: {
                onFeedbackClick() {
                    this.screen = "feedback"
                },
                onDebugClick() {
                    this.screen = "debug"
                },
                onVibeClick(t) {
                    this.vibe = t
                },
                async onSubmitClick() {
                    this.$debugRecorder && (this.screen === "debug" && (await this.$debugRecorder.send(this.message), this.$emit("resolve")), this.screen === "feedback" && (await ES.send({
                        room: this.$debugRecorder.room,
                        name: this.$ecast.name,
                        role: this.$ecast.role,
                        content: this.isContent ? this.content : null,
                        message: this.message ?? "",
                        vibe: this.vibe ?? "none",
                        values: this.values
                    }), this.$emit("resolve")))
                }
            }
        }),
        WA = "main/pp10/nopus-opus/assets/ad9172fc.png",
        HA = "main/pp10/nopus-opus/assets/dc131b16.png",
        vse = "main/pp10/nopus-opus/assets/38715b18.png",
        bse = "main/pp10/nopus-opus/assets/b0d7c822.png",
        Ese = "main/pp10/nopus-opus/assets/06150f24.png",
        cs = t => (Ns("data-v-2c53389f"), t = t(), xs(), t),
        Tse = {
            class: "jbg"
        },
        Sse = {
            key: 0,
            class: "options"
        },
        wse = cs(() => B("img", {
            src: WA,
            alt: "Leave Feedback"
        }, null, -1)),
        Ose = cs(() => B("span", null, [Nn("LEAVE"), B("br"), Nn("FEEDBACK")], -1)),
        Ase = [wse, Ose],
        Cse = cs(() => B("img", {
            src: HA,
            alt: "Send Debug"
        }, null, -1)),
        kse = cs(() => B("span", null, [Nn("SEND A"), B("br"), Nn("DEBUG")], -1)),
        Ise = [Cse, kse],
        Nse = {
            key: 1,
            class: "feedback"
        },
        xse = cs(() => B("img", {
            class: "image",
            src: WA,
            alt: "Feedback"
        }, null, -1)),
        Pse = cs(() => B("h3", {
            class: "text"
        }, "Send Feedback", -1)),
        Rse = cs(() => B("p", {
            class: "cta"
        }, "CHOOSE A VIBE", -1)),
        Mse = {
            class: "buttons"
        },
        Dse = cs(() => B("img", {
            src: vse,
            alt: "good"
        }, null, -1)),
        $se = [Dse],
        Lse = cs(() => B("img", {
            src: bse,
            alt: "good"
        }, null, -1)),
        Fse = [Lse],
        Use = cs(() => B("img", {
            src: Ese,
            alt: "bad"
        }, null, -1)),
        Bse = [Use],
        qse = {
            class: "actions"
        },
        jse = {
            key: 0,
            class: "content-guess"
        },
        Vse = {
            key: 2,
            class: "debug"
        },
        Gse = cs(() => B("img", {
            class: "image",
            src: HA,
            alt: "Debug"
        }, null, -1)),
        Wse = cs(() => B("h3", {
            class: "text"
        }, "What is Happening?", -1)),
        Hse = {
            class: "actions"
        };

    function Kse(t, e, n, r, s, i) {
        return G(), H("div", Tse, [t.screen === "options" ? (G(), H("div", Sse, [B("button", {
            class: "feedback-button",
            onClick: e[0] || (e[0] = (...a) => t.onFeedbackClick && t.onFeedbackClick(...a))
        }, Ase), B("button", {
            onClick: e[1] || (e[1] = (...a) => t.onDebugClick && t.onDebugClick(...a))
        }, Ise)])) : t.screen === "feedback" ? (G(), H("div", Nse, [xse, Pse, B("div", {
            class: Xe(["vibes", {
                "has-selected": t.vibe
            }])
        }, [Rse, B("div", Mse, [B("button", {
            class: Xe({
                selected: t.vibe === "good"
            }),
            onClick: e[2] || (e[2] = a => t.onVibeClick("good"))
        }, $se, 2), B("button", {
            class: Xe({
                selected: t.vibe === "meh"
            }),
            onClick: e[3] || (e[3] = a => t.onVibeClick("meh"))
        }, Fse, 2), B("button", {
            class: Xe({
                selected: t.vibe === "bad"
            }),
            onClick: e[4] || (e[4] = a => t.onVibeClick("bad"))
        }, Bse, 2)])], 2), B("div", qse, [t.content ? (G(), H("div", jse, [Ke(B("input", {
            "onUpdate:modelValue": e[5] || (e[5] = a => t.isContent = a),
            type: "checkbox"
        }, null, 512), [
            [FD, t.isContent]
        ]), B("span", null, [Nn("Feedback is about: "), B("em", null, vt(t.content), 1)])])) : Be("", !0), Ke(B("textarea", {
            "onUpdate:modelValue": e[6] || (e[6] = a => t.message = a),
            rows: "3",
            placeholder: "(optional) more details",
            "aria-label": "Details"
        }, null, 512), [
            [bT, t.message]
        ]), B("button", {
            onClick: e[7] || (e[7] = Pi((...a) => t.onSubmitClick && t.onSubmitClick(...a), ["prevent"]))
        }, vt(t.$t("ACTION.SUBMIT")), 1)])])) : t.screen === "debug" ? (G(), H("div", Vse, [Gse, Wse, B("div", Hse, [Ke(B("textarea", {
            "onUpdate:modelValue": e[8] || (e[8] = a => t.message = a),
            rows: "3",
            placeholder: "Enter details",
            "aria-label": "Details"
        }, null, 512), [
            [bT, t.message]
        ]), B("button", {
            onClick: e[9] || (e[9] = Pi((...a) => t.onSubmitClick && t.onSubmitClick(...a), ["prevent"]))
        }, vt(t.$t("ACTION.OK")), 1)])])) : Be("", !0)])
    }
    const Yse = ot(yse, [
            ["render", Kse],
            ["__scopeId", "data-v-2c53389f"]
        ]),
        zse = mt({
            methods: {
                onFeedbackClick() {
                    this.$showModal(Yse)
                }
            }
        });

    function Zse(t, e, n, r, s, i) {
        return G(), H("div", {
            class: "feedback-button",
            onClick: e[0] || (e[0] = (...a) => t.onFeedbackClick && t.onFeedbackClick(...a))
        }, "SEND FEEDBACK")
    }
    const Xse = ot(zse, [
            ["render", Zse],
            ["__scopeId", "data-v-6f2f1788"]
        ]),
        Jse = {
            install: (t, e) => {
                if (!t.config.globalProperties.$debugRecorder && !t.config.globalProperties.$debugReplayer) {
                    if (e.replayer) {
                        t.config.globalProperties.$debugReplayer = e.replayer, t.component("Debug", jee);
                        return
                    }
                    if (t.config.globalProperties.$debugRecorder = new nK(e.client, e.room), !t.config.globalProperties.$showModal) {
                        console.warn("[debugPlugin] Sending debug and feedback messages is disabled because the modalPlugin is missing.");
                        return
                    }(!vs.isProduction() || vs.getQueryParam("feedback")) && t.component("Debug", Xse)
                }
            }
        };
    var Qse = Ps,
        eie = function() {
            return Qse.Date.now()
        },
        tie = eie,
        nie = /\s/;

    function rie(t) {
        for (var e = t.length; e-- && nie.test(t.charAt(e)););
        return e
    }
    var sie = rie,
        iie = sie,
        oie = /^\s+/;

    function aie(t) {
        return t && t.slice(0, iie(t) + 1).replace(oie, "")
    }
    var cie = aie,
        lie = rl,
        uie = Ro,
        hie = "[object Symbol]";

    function fie(t) {
        return typeof t == "symbol" || uie(t) && lie(t) == hie
    }
    var um = fie,
        die = cie,
        Aw = Rs,
        pie = um,
        Cw = 0 / 0,
        mie = /^[-+]0x[0-9a-f]+$/i,
        gie = /^0b[01]+$/i,
        _ie = /^0o[0-7]+$/i,
        yie = parseInt;

    function vie(t) {
        if (typeof t == "number") return t;
        if (pie(t)) return Cw;
        if (Aw(t)) {
            var e = typeof t.valueOf == "function" ? t.valueOf() : t;
            t = Aw(e) ? e + "" : e
        }
        if (typeof t != "string") return t === 0 ? t : +t;
        t = die(t);
        var n = gie.test(t);
        return n || _ie.test(t) ? yie(t.slice(2), n ? 2 : 8) : mie.test(t) ? Cw : +t
    }
    var bie = vie,
        Eie = Rs,
        B_ = tie,
        kw = bie,
        Tie = "Expected a function",
        Sie = Math.max,
        wie = Math.min;

    function Oie(t, e, n) {
        var r, s, i, a, c, u, h = 0,
            d = !1,
            p = !1,
            m = !0;
        if (typeof t != "function") throw new TypeError(Tie);
        e = kw(e) || 0, Eie(n) && (d = !!n.leading, p = "maxWait" in n, i = p ? Sie(kw(n.maxWait) || 0, e) : i, m = "trailing" in n ? !!n.trailing : m);

        function _(M) {
            var $ = r,
                j = s;
            return r = s = void 0, h = M, a = t.apply(j, $), a
        }

        function y(M) {
            return h = M, c = setTimeout(b, e), d ? _(M) : a
        }

        function v(M) {
            var $ = M - u,
                j = M - h,
                ee = e - $;
            return p ? wie(ee, i - j) : ee
        }

        function w(M) {
            var $ = M - u,
                j = M - h;
            return u === void 0 || $ >= e || $ < 0 || p && j >= i
        }

        function b() {
            var M = B_();
            if (w(M)) return I(M);
            c = setTimeout(b, v(M))
        }

        function I(M) {
            return c = void 0, m && r ? _(M) : (r = s = void 0, a)
        }

        function F() {
            c !== void 0 && clearTimeout(c), h = 0, r = u = s = c = void 0
        }

        function x() {
            return c === void 0 ? a : I(B_())
        }

        function O() {
            var M = B_(),
                $ = w(M);
            if (r = arguments, s = this, u = M, $) {
                if (c === void 0) return y(u);
                if (p) return clearTimeout(c), c = setTimeout(b, e), _(u)
            }
            return c === void 0 && (c = setTimeout(b, e)), a
        }
        return O.cancel = F, O.flush = x, O
    }
    var Aie = Oie;
    const Cie = el(Aie);
    var kie = Mo,
        Iie = um,
        Nie = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        xie = /^\w*$/;

    function Pie(t, e) {
        if (kie(t)) return !1;
        var n = typeof t;
        return n == "number" || n == "symbol" || n == "boolean" || t == null || Iie(t) ? !0 : xie.test(t) || !Nie.test(t) || e != null && t in Object(e)
    }
    var Rie = Pie,
        KA = y4,
        Mie = "Expected a function";

    function s0(t, e) {
        if (typeof t != "function" || e != null && typeof e != "function") throw new TypeError(Mie);
        var n = function() {
            var r = arguments,
                s = e ? e.apply(this, r) : r[0],
                i = n.cache;
            if (i.has(s)) return i.get(s);
            var a = t.apply(this, r);
            return n.cache = i.set(s, a) || i, a
        };
        return n.cache = new(s0.Cache || KA), n
    }
    s0.Cache = KA;
    var Die = s0,
        $ie = Die,
        Lie = 500;

    function Fie(t) {
        var e = $ie(t, function(r) {
                return n.size === Lie && n.clear(), r
            }),
            n = e.cache;
        return e
    }
    var Uie = Fie,
        Bie = Uie,
        qie = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        jie = /\\(\\)?/g,
        Vie = Bie(function(t) {
            var e = [];
            return t.charCodeAt(0) === 46 && e.push(""), t.replace(qie, function(n, r, s, i) {
                e.push(s ? i.replace(jie, "$1") : r || n)
            }), e
        }),
        Gie = Vie;

    function Wie(t, e) {
        for (var n = -1, r = t == null ? 0 : t.length, s = Array(r); ++n < r;) s[n] = e(t[n], n, t);
        return s
    }
    var YA = Wie,
        Iw = Yp,
        Hie = YA,
        Kie = Mo,
        Yie = um,
        zie = 1 / 0,
        Nw = Iw ? Iw.prototype : void 0,
        xw = Nw ? Nw.toString : void 0;

    function zA(t) {
        if (typeof t == "string") return t;
        if (Kie(t)) return Hie(t, zA) + "";
        if (Yie(t)) return xw ? xw.call(t) : "";
        var e = t + "";
        return e == "0" && 1 / t == -zie ? "-0" : e
    }
    var Zie = zA,
        Xie = Zie;

    function Jie(t) {
        return t == null ? "" : Xie(t)
    }
    var Qie = Jie,
        eoe = Mo,
        toe = Rie,
        noe = Gie,
        roe = Qie;

    function soe(t, e) {
        return eoe(t) ? t : toe(t, e) ? [t] : noe(roe(t))
    }
    var ZA = soe,
        ioe = um,
        ooe = 1 / 0;

    function aoe(t) {
        if (typeof t == "string" || ioe(t)) return t;
        var e = t + "";
        return e == "0" && 1 / t == -ooe ? "-0" : e
    }
    var XA = aoe,
        coe = mv,
        loe = ZA,
        uoe = gv,
        Pw = Rs,
        hoe = XA;

    function foe(t, e, n, r) {
        if (!Pw(t)) return t;
        e = loe(e, t);
        for (var s = -1, i = e.length, a = i - 1, c = t; c != null && ++s < i;) {
            var u = hoe(e[s]),
                h = n;
            if (u === "__proto__" || u === "constructor" || u === "prototype") return t;
            if (s != a) {
                var d = c[u];
                h = r ? r(d, u, c) : void 0, h === void 0 && (h = Pw(d) ? d : uoe(e[s + 1]) ? [] : {})
            }
            coe(c, u, h), c = c[u]
        }
        return t
    }
    var doe = foe,
        poe = doe;

    function moe(t, e, n) {
        return t == null ? t : poe(t, e, n)
    }
    var goe = moe;
    const _oe = el(goe);
    class yoe {
        constructor() {
            Se(this, "wsClient");
            Se(this, "keyMap");
            Se(this, "providerMap");
            Se(this, "mappedValues", Nc({}));
            Se(this, "shouldParseBlobcast", !1);
            Se(this, "pausedKeys", null);
            Se(this, "keyMapKeys");
            Se(this, "providerMapKeys");
            Se(this, "hotValues");
            Se(this, "newValues");
            Se(this, "pause", (e = []) => {
                this.pausedKeys = e
            });
            Se(this, "resume", () => {
                this.pausedKeys = null, this.sync()
            });
            Se(this, "sync", Cie(() => {
                this.wsClient && (!this.keyMap && !this.providerMap || this.pausedKeys && !this.pausedKeys.length || (this.hotValues = {}, this.newValues = {}, this.normalize().mapKeysToValues().mapProvidersToValues().deleteDropped().hydrateRefs().syncExisting(), delete this.hotValues, delete this.newValues))
            }, 50))
        }
        setWSClient(e) {
            this.wsClient = e, this.setupWatcher()
        }
        setupWatcher() {
            this.wsClient.entities = Nc(this.wsClient.entities), ma(this.wsClient.entities, (e, n) => {
                this.sync()
            })
        }
        valueForEntity(e) {
            return e instanceof Tr.ArtifactEntity || e instanceof Tr.DoodleEntity || e instanceof Tr.TextMapEntity || e instanceof Tr.NumberEntity ? e : e instanceof Tr.ObjectEntity ? GA(e.val) : e instanceof Tr.TextEntity ? e.text : null
        }
        normalize() {
            var n;
            const e = Object.keys(this.wsClient.entities);
            for (let r = 0; r < e.length; r++) {
                let s = e[r];
                if ((n = this.pausedKeys) != null && n.includes(s)) continue;
                const i = this.valueForEntity(this.wsClient.entities[s]);
                if (i != null) {
                    if (this.shouldParseBlobcast) {
                        const a = s.split(":");
                        if (a[0] === "bc")
                            if (a[1] === "customer") {
                                if (a[2] !== `${this.wsClient.id}`) continue;
                                s = "player"
                            } else a[1] === "room" && (s = "room")
                    }
                    this.hotValues[s] = i
                }
            }
            return this
        }
        hydrateRefs() {
            const e = (n, r, s = !1) => {
                const i = n.$ref ?? n.ref;
                if (i) {
                    const a = this.hotValues[i];
                    if (a === void 0) throw new Error(`[ecastPlugin] entity "${r}" referenced entity "${i}" but it does not exist`);
                    _oe(this.newValues, r, a)
                } else s && Object.entries(n).forEach(([a, c]) => {
                    c !== null && typeof c == "object" && e(c, `${r}.${a}`, s)
                })
            };
            return Object.entries(this.newValues).forEach(([n, r]) => {
                r && Object.entries(r).forEach(([s, i]) => {
                    i !== null && typeof i == "object" && e(i, `${n}.${s}`, this.keyHasDeepRefs(n))
                })
            }), this
        }
        keyHasDeepRefs(e) {
            var n, r, s, i;
            return !!((r = (n = this.keyMap) == null ? void 0 : n[e]) != null && r.hasDeepRefs || (i = (s = this.providerMap) == null ? void 0 : s[e]) != null && i.hasDeepRefs)
        }
        mapKeysToValues() {
            if (!this.keyMap) return this;
            for (let e = 0; e < this.keyMapKeys.length; e++) this.newValues[this.keyMapKeys[e]] = this.hotValues[this.keyMap[this.keyMapKeys[e]].key];
            return this
        }
        mapProvidersToValues() {
            if (!this.providerMap) return this;
            for (let e = 0; e < this.providerMapKeys.length; e++) this.newValues[this.providerMapKeys[e]] = this.providerMap[this.providerMapKeys[e]].fn(this.hotValues, this.wsClient);
            return this
        }
        deleteDropped() {
            const e = Object.keys(this.mappedValues);
            for (let n = 0; n < e.length; n++) this.newValues[e[n]] || delete this.mappedValues[e[n]];
            return this
        }
        syncExisting() {
            const e = Object.keys(this.newValues);
            for (let n = 0; n < e.length; n++) this.mappedValues[e[n]] = this.newValues[e[n]];
            return this.mappedValues
        }
        addKeys(e) {
            this.keyMap || (this.keyMap = {}), Object.keys(e).forEach(n => {
                if (typeof e[n] == "function") {
                    const r = e[n];
                    this.keyMap[n] = {
                        key: r(this.wsClient),
                        hasDeepRefs: !1
                    };
                    return
                }
                if (typeof e[n] == "object") {
                    const r = e[n];
                    this.keyMap[n] = {
                        key: r.fn ? r.fn(this.wsClient) : r.key,
                        hasDeepRefs: r.hasDeepRefs ?? !1
                    };
                    return
                }
                this.keyMap[n] = {
                    key: e[n]
                }
            }), this.keyMapKeys = Object.keys(this.keyMap), this.sync()
        }
        purgeKeys(e) {
            this.keyMap && (Object.keys(e).forEach(n => {
                this.keyMap[n] && delete this.keyMap[n]
            }), this.keyMapKeys = Object.keys(this.keyMap), this.sync())
        }
        addProviders(e) {
            this.providerMap || (this.providerMap = {}), Object.keys(e).forEach(n => {
                if (typeof e[n] == "object") {
                    const r = e[n];
                    this.providerMap[n] = {
                        fn: r.fn,
                        hasDeepRefs: r.hasDeepRefs ?? !1
                    };
                    return
                }
                this.providerMap[n] = {
                    fn: e[n]
                }
            }), this.providerMapKeys = Object.keys(this.providerMap), this.sync()
        }
        purgeProviders(e) {
            this.providerMap && (Object.keys(e).forEach(n => {
                this.providerMap[n] && delete this.providerMap[n]
            }), this.providerMapKeys = Object.keys(this.providerMap), this.sync())
        }
    }
    const Xr = new yoe,
        voe = {
            install: (t, e) => {
                t.config.globalProperties.$setupEcast = n => {
                    Xr.setWSClient(n.wsClient), n.wsClient.on("artifact", r => _d.add(r)), n.wsClient.on("connection", r => {
                        r.status === "connected" && Xr.setupWatcher()
                    }), Xr.sync(), t.config.globalProperties.$ecast = Xr.wsClient, t.config.globalProperties.$ecastValues = Xr.mappedValues, t.config.globalProperties.$ecastRoom = n.room, t.config.globalProperties.$ecastWelcome = n.welcome, t.config.globalProperties.$syncEcast = Xr.sync, t.config.globalProperties.$pauseEcastUpdates = Xr.pause, t.config.globalProperties.$resumeEcastUpdates = Xr.resume, t.mixin({
                        beforeCreate() {
                            this.$options.ecastKeys && Xr.addKeys(this.$options.ecastKeys), this.$options.ecastProviders && Xr.addProviders(this.$options.ecastProviders)
                        },
                        beforeDestroy() {
                            this.$options.ecastKeys && Xr.purgeKeys(this.$options.ecastKeys), this.$options.ecastProviders && Xr.purgeProviders(this.$options.ecastProviders)
                        }
                    })
                }, e != null && e.wsClient && t.config.globalProperties.$setupEcast(e)
            }
        },
        sh = {
            fatal: {
                error: Symbol("fatal.error")
            },
            modal: {
                active: Symbol("modal.active")
            },
            textDescriptions: {
                announcement: Symbol("textDescriptions.announcement")
            }
        },
        JA = Object.prototype.toString;

    function QA(t) {
        switch (JA.call(t)) {
            case "[object Error]":
            case "[object Exception]":
            case "[object DOMException]":
                return !0;
            default:
                return hl(t, Error)
        }
    }

    function ul(t, e) {
        return JA.call(t) === `[object ${e}]`
    }

    function eC(t) {
        return ul(t, "ErrorEvent")
    }

    function Rw(t) {
        return ul(t, "DOMError")
    }

    function boe(t) {
        return ul(t, "DOMException")
    }

    function Sa(t) {
        return ul(t, "String")
    }

    function Eoe(t) {
        return t === null || typeof t != "object" && typeof t != "function"
    }

    function hm(t) {
        return ul(t, "Object")
    }

    function i0(t) {
        return typeof Event < "u" && hl(t, Event)
    }

    function Toe(t) {
        return typeof Element < "u" && hl(t, Element)
    }

    function Soe(t) {
        return ul(t, "RegExp")
    }

    function tC(t) {
        return !!(t && t.then && typeof t.then == "function")
    }

    function woe(t) {
        return hm(t) && "nativeEvent" in t && "preventDefault" in t && "stopPropagation" in t
    }

    function Ooe(t) {
        return typeof t == "number" && t !== t
    }

    function hl(t, e) {
        try {
            return t instanceof e
        } catch {
            return !1
        }
    }

    function kf(t) {
        return t && t.Math == Math ? t : void 0
    }
    const Ss = typeof globalThis == "object" && kf(globalThis) || typeof window == "object" && kf(window) || typeof self == "object" && kf(self) || typeof global == "object" && kf(global) || function() {
        return this
    }() || {};

    function ih() {
        return Ss
    }

    function o0(t, e, n) {
        const r = n || Ss,
            s = r.__SENTRY__ = r.__SENTRY__ || {};
        return s[t] || (s[t] = e())
    }
    const Aoe = ih(),
        Coe = 80;

    function q1(t, e = {}) {
        try {
            let n = t;
            const r = 5,
                s = [];
            let i = 0,
                a = 0;
            const c = " > ",
                u = c.length;
            let h;
            const d = Array.isArray(e) ? e : e.keyAttrs,
                p = !Array.isArray(e) && e.maxStringLength || Coe;
            for (; n && i++ < r && (h = koe(n, d), !(h === "html" || i > 1 && a + s.length * u + h.length >= p));) s.push(h), a += h.length, n = n.parentNode;
            return s.reverse().join(c)
        } catch {
            return "<unknown>"
        }
    }

    function koe(t, e) {
        const n = t,
            r = [];
        let s, i, a, c, u;
        if (!n || !n.tagName) return "";
        r.push(n.tagName.toLowerCase());
        const h = e && e.length ? e.filter(p => n.getAttribute(p)).map(p => [p, n.getAttribute(p)]) : null;
        if (h && h.length) h.forEach(p => {
            r.push(`[${p[0]}="${p[1]}"]`)
        });
        else if (n.id && r.push(`#${n.id}`), s = n.className, s && Sa(s))
            for (i = s.split(/\s+/), u = 0; u < i.length; u++) r.push(`.${i[u]}`);
        const d = ["aria-label", "type", "name", "title", "alt"];
        for (u = 0; u < d.length; u++) a = d[u], c = n.getAttribute(a), c && r.push(`[${a}="${c}"]`);
        return r.join("")
    }

    function Ioe() {
        try {
            return Aoe.document.location.href
        } catch {
            return ""
        }
    }
    class Wl extends Error {
        constructor(e, n = "warn") {
            super(e), this.message = e, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = n
        }
    }
    const Noe = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

    function xoe(t) {
        return t === "http" || t === "https"
    }

    function Poe(t, e = !1) {
        const {
            host: n,
            path: r,
            pass: s,
            port: i,
            projectId: a,
            protocol: c,
            publicKey: u
        } = t;
        return `${c}://${u}${e&&s?`:${s}`:""}@${n}${i?`:${i}`:""}/${r&&`${r}/`}${a}`
    }

    function Roe(t) {
        const e = Noe.exec(t);
        if (!e) throw new Wl(`Invalid Sentry Dsn: ${t}`);
        const [n, r, s = "", i, a = "", c] = e.slice(1);
        let u = "",
            h = c;
        const d = h.split("/");
        if (d.length > 1 && (u = d.slice(0, -1).join("/"), h = d.pop()), h) {
            const p = h.match(/^\d+/);
            p && (h = p[0])
        }
        return nC({
            host: i,
            pass: s,
            path: u,
            projectId: h,
            port: a,
            protocol: n,
            publicKey: r
        })
    }

    function nC(t) {
        return {
            protocol: t.protocol,
            publicKey: t.publicKey || "",
            pass: t.pass || "",
            host: t.host,
            port: t.port || "",
            path: t.path || "",
            projectId: t.projectId
        }
    }

    function Moe(t) {
        if (!(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__)) return;
        const {
            port: e,
            projectId: n,
            protocol: r
        } = t;
        if (["protocol", "publicKey", "host", "projectId"].forEach(i => {
                if (!t[i]) throw new Wl(`Invalid Sentry Dsn: ${i} missing`)
            }), !n.match(/^\d+$/)) throw new Wl(`Invalid Sentry Dsn: Invalid projectId ${n}`);
        if (!xoe(r)) throw new Wl(`Invalid Sentry Dsn: Invalid protocol ${r}`);
        if (e && isNaN(parseInt(e, 10))) throw new Wl(`Invalid Sentry Dsn: Invalid port ${e}`);
        return !0
    }

    function Doe(t) {
        const e = typeof t == "string" ? Roe(t) : nC(t);
        return Moe(e), e
    }
    const $oe = "Sentry Logger ",
        Cd = ["debug", "info", "warn", "error", "log", "assert", "trace"];

    function rC(t) {
        if (!("console" in Ss)) return t();
        const e = Ss.console,
            n = {};
        Cd.forEach(r => {
            const s = e[r] && e[r].__sentry_original__;
            r in e && s && (n[r] = e[r], e[r] = s)
        });
        try {
            return t()
        } finally {
            Object.keys(n).forEach(r => {
                e[r] = n[r]
            })
        }
    }

    function Mw() {
        let t = !1;
        const e = {
            enable: () => {
                t = !0
            },
            disable: () => {
                t = !1
            }
        };
        return typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? Cd.forEach(n => {
            e[n] = (...r) => {
                t && rC(() => {
                    Ss.console[n](`${$oe}[${n}]:`, ...r)
                })
            }
        }) : Cd.forEach(n => {
            e[n] = () => {}
        }), e
    }
    let _n;
    typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? _n = o0("logger", Mw) : _n = Mw();

    function Dw(t, e = 0) {
        return typeof t != "string" || e === 0 || t.length <= e ? t : `${t.slice(0,e)}...`
    }

    function $w(t, e) {
        if (!Array.isArray(t)) return "";
        const n = [];
        for (let r = 0; r < t.length; r++) {
            const s = t[r];
            try {
                n.push(String(s))
            } catch {
                n.push("[value cannot be serialized]")
            }
        }
        return n.join(e)
    }

    function Loe(t, e, n = !1) {
        return Sa(t) ? Soe(e) ? e.test(t) : Sa(e) ? n ? t === e : t.includes(e) : !1 : !1
    }

    function fm(t, e = [], n = !1) {
        return e.some(r => Loe(t, r, n))
    }

    function Gn(t, e, n) {
        if (!(e in t)) return;
        const r = t[e],
            s = n(r);
        if (typeof s == "function") try {
            iC(s, r)
        } catch {}
        t[e] = s
    }

    function sC(t, e, n) {
        Object.defineProperty(t, e, {
            value: n,
            writable: !0,
            configurable: !0
        })
    }

    function iC(t, e) {
        const n = e.prototype || {};
        t.prototype = e.prototype = n, sC(t, "__sentry_original__", e)
    }

    function a0(t) {
        return t.__sentry_original__
    }

    function oC(t) {
        if (QA(t)) return {
            message: t.message,
            name: t.name,
            stack: t.stack,
            ...Fw(t)
        };
        if (i0(t)) {
            const e = {
                type: t.type,
                target: Lw(t.target),
                currentTarget: Lw(t.currentTarget),
                ...Fw(t)
            };
            return typeof CustomEvent < "u" && hl(t, CustomEvent) && (e.detail = t.detail), e
        } else return t
    }

    function Lw(t) {
        try {
            return Toe(t) ? q1(t) : Object.prototype.toString.call(t)
        } catch {
            return "<unknown>"
        }
    }

    function Fw(t) {
        if (typeof t == "object" && t !== null) {
            const e = {};
            for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            return e
        } else return {}
    }

    function Foe(t, e = 40) {
        const n = Object.keys(oC(t));
        if (n.sort(), !n.length) return "[object has no keys]";
        if (n[0].length >= e) return Dw(n[0], e);
        for (let r = n.length; r > 0; r--) {
            const s = n.slice(0, r).join(", ");
            if (!(s.length > e)) return r === n.length ? s : Dw(s, e)
        }
        return ""
    }

    function Uoe(t) {
        return j1(t, new Map)
    }

    function j1(t, e) {
        if (hm(t)) {
            const n = e.get(t);
            if (n !== void 0) return n;
            const r = {};
            e.set(t, r);
            for (const s of Object.keys(t)) typeof t[s] < "u" && (r[s] = j1(t[s], e));
            return r
        }
        if (Array.isArray(t)) {
            const n = e.get(t);
            if (n !== void 0) return n;
            const r = [];
            return e.set(t, r), t.forEach(s => {
                r.push(j1(s, e))
            }), r
        }
        return t
    }
    const q_ = "<anonymous>";

    function wo(t) {
        try {
            return !t || typeof t != "function" ? q_ : t.name || q_
        } catch {
            return q_
        }
    }
    const V1 = ih();

    function Boe() {
        if (!("fetch" in V1)) return !1;
        try {
            return new Headers, new Request("http://www.example.com"), new Response, !0
        } catch {
            return !1
        }
    }

    function Uw(t) {
        return t && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
    }

    function qoe() {
        if (!Boe()) return !1;
        if (Uw(V1.fetch)) return !0;
        let t = !1;
        const e = V1.document;
        if (e && typeof e.createElement == "function") try {
            const n = e.createElement("iframe");
            n.hidden = !0, e.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (t = Uw(n.contentWindow.fetch)), e.head.removeChild(n)
        } catch (n) {
            (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n)
        }
        return t
    }
    const If = ih();

    function joe() {
        const t = If.chrome,
            e = t && t.app && t.app.runtime,
            n = "history" in If && !!If.history.pushState && !!If.history.replaceState;
        return !e && n
    }
    const sn = ih(),
        Hl = "__sentry_xhr_v2__",
        nu = {},
        Bw = {};

    function Voe(t) {
        if (!Bw[t]) switch (Bw[t] = !0, t) {
            case "console":
                Goe();
                break;
            case "dom":
                Joe();
                break;
            case "xhr":
                Koe();
                break;
            case "fetch":
                Woe();
                break;
            case "history":
                Yoe();
                break;
            case "error":
                Qoe();
                break;
            case "unhandledrejection":
                eae();
                break;
            default:
                (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.warn("unknown instrumentation type:", t);
                return
        }
    }

    function la(t, e) {
        nu[t] = nu[t] || [], nu[t].push(e), Voe(t)
    }

    function ws(t, e) {
        if (!(!t || !nu[t]))
            for (const n of nu[t] || []) try {
                n(e)
            } catch (r) {
                (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${wo(n)}
Error:`, r)
            }
    }

    function Goe() {
        "console" in sn && Cd.forEach(function(t) {
            t in sn.console && Gn(sn.console, t, function(e) {
                return function(...n) {
                    ws("console", {
                        args: n,
                        level: t
                    }), e && e.apply(sn.console, n)
                }
            })
        })
    }

    function Woe() {
        qoe() && Gn(sn, "fetch", function(t) {
            return function(...e) {
                const {
                    method: n,
                    url: r
                } = Hoe(e), s = {
                    args: e,
                    fetchData: {
                        method: n,
                        url: r
                    },
                    startTimestamp: Date.now()
                };
                return ws("fetch", {
                    ...s
                }), t.apply(sn, e).then(i => (ws("fetch", {
                    ...s,
                    endTimestamp: Date.now(),
                    response: i
                }), i), i => {
                    throw ws("fetch", {
                        ...s,
                        endTimestamp: Date.now(),
                        error: i
                    }), i
                })
            }
        })
    }

    function G1(t, e) {
        return !!t && typeof t == "object" && !!t[e]
    }

    function qw(t) {
        return typeof t == "string" ? t : t ? G1(t, "url") ? t.url : t.toString ? t.toString() : "" : ""
    }

    function Hoe(t) {
        if (t.length === 0) return {
            method: "GET",
            url: ""
        };
        if (t.length === 2) {
            const [n, r] = t;
            return {
                url: qw(n),
                method: G1(r, "method") ? String(r.method).toUpperCase() : "GET"
            }
        }
        const e = t[0];
        return {
            url: qw(e),
            method: G1(e, "method") ? String(e.method).toUpperCase() : "GET"
        }
    }

    function Koe() {
        if (!("XMLHttpRequest" in sn)) return;
        const t = XMLHttpRequest.prototype;
        Gn(t, "open", function(e) {
            return function(...n) {
                const r = n[1],
                    s = this[Hl] = {
                        method: Sa(n[0]) ? n[0].toUpperCase() : n[0],
                        url: n[1],
                        request_headers: {}
                    };
                Sa(r) && s.method === "POST" && r.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
                const i = () => {
                    const a = this[Hl];
                    if (a && this.readyState === 4) {
                        try {
                            a.status_code = this.status
                        } catch {}
                        ws("xhr", {
                            args: n,
                            endTimestamp: Date.now(),
                            startTimestamp: Date.now(),
                            xhr: this
                        })
                    }
                };
                return "onreadystatechange" in this && typeof this.onreadystatechange == "function" ? Gn(this, "onreadystatechange", function(a) {
                    return function(...c) {
                        return i(), a.apply(this, c)
                    }
                }) : this.addEventListener("readystatechange", i), Gn(this, "setRequestHeader", function(a) {
                    return function(...c) {
                        const [u, h] = c, d = this[Hl];
                        return d && (d.request_headers[u.toLowerCase()] = h), a.apply(this, c)
                    }
                }), e.apply(this, n)
            }
        }), Gn(t, "send", function(e) {
            return function(...n) {
                const r = this[Hl];
                return r && n[0] !== void 0 && (r.body = n[0]), ws("xhr", {
                    args: n,
                    startTimestamp: Date.now(),
                    xhr: this
                }), e.apply(this, n)
            }
        })
    }
    let Nf;

    function Yoe() {
        if (!joe()) return;
        const t = sn.onpopstate;
        sn.onpopstate = function(...n) {
            const r = sn.location.href,
                s = Nf;
            if (Nf = r, ws("history", {
                    from: s,
                    to: r
                }), t) try {
                return t.apply(this, n)
            } catch {}
        };

        function e(n) {
            return function(...r) {
                const s = r.length > 2 ? r[2] : void 0;
                if (s) {
                    const i = Nf,
                        a = String(s);
                    Nf = a, ws("history", {
                        from: i,
                        to: a
                    })
                }
                return n.apply(this, r)
            }
        }
        Gn(sn.history, "pushState", e), Gn(sn.history, "replaceState", e)
    }
    const zoe = 1e3;
    let xf, Pf;

    function Zoe(t, e) {
        if (!t || t.type !== e.type) return !0;
        try {
            if (t.target !== e.target) return !0
        } catch {}
        return !1
    }

    function Xoe(t) {
        if (t.type !== "keypress") return !1;
        try {
            const e = t.target;
            if (!e || !e.tagName) return !0;
            if (e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable) return !1
        } catch {}
        return !0
    }

    function jw(t, e = !1) {
        return n => {
            if (!n || Pf === n || Xoe(n)) return;
            const r = n.type === "keypress" ? "input" : n.type;
            xf === void 0 ? (t({
                event: n,
                name: r,
                global: e
            }), Pf = n) : Zoe(Pf, n) && (t({
                event: n,
                name: r,
                global: e
            }), Pf = n), clearTimeout(xf), xf = sn.setTimeout(() => {
                xf = void 0
            }, zoe)
        }
    }

    function Joe() {
        if (!("document" in sn)) return;
        const t = ws.bind(null, "dom"),
            e = jw(t, !0);
        sn.document.addEventListener("click", e, !1), sn.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach(n => {
            const r = sn[n] && sn[n].prototype;
            !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (Gn(r, "addEventListener", function(s) {
                return function(i, a, c) {
                    if (i === "click" || i == "keypress") try {
                        const u = this,
                            h = u.__sentry_instrumentation_handlers__ = u.__sentry_instrumentation_handlers__ || {},
                            d = h[i] = h[i] || {
                                refCount: 0
                            };
                        if (!d.handler) {
                            const p = jw(t);
                            d.handler = p, s.call(this, i, p, c)
                        }
                        d.refCount++
                    } catch {}
                    return s.call(this, i, a, c)
                }
            }), Gn(r, "removeEventListener", function(s) {
                return function(i, a, c) {
                    if (i === "click" || i == "keypress") try {
                        const u = this,
                            h = u.__sentry_instrumentation_handlers__ || {},
                            d = h[i];
                        d && (d.refCount--, d.refCount <= 0 && (s.call(this, i, d.handler, c), d.handler = void 0, delete h[i]), Object.keys(h).length === 0 && delete u.__sentry_instrumentation_handlers__)
                    } catch {}
                    return s.call(this, i, a, c)
                }
            }))
        })
    }
    let Rf = null;

    function Qoe() {
        Rf = sn.onerror, sn.onerror = function(t, e, n, r, s) {
            return ws("error", {
                column: r,
                error: s,
                line: n,
                msg: t,
                url: e
            }), Rf && !Rf.__SENTRY_LOADER__ ? Rf.apply(this, arguments) : !1
        }, sn.onerror.__SENTRY_INSTRUMENTED__ = !0
    }
    let Mf = null;

    function eae() {
        Mf = sn.onunhandledrejection, sn.onunhandledrejection = function(t) {
            return ws("unhandledrejection", t), Mf && !Mf.__SENTRY_LOADER__ ? Mf.apply(this, arguments) : !0
        }, sn.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
    }

    function tae() {
        const t = typeof WeakSet == "function",
            e = t ? new WeakSet : [];

        function n(s) {
            if (t) return e.has(s) ? !0 : (e.add(s), !1);
            for (let i = 0; i < e.length; i++)
                if (e[i] === s) return !0;
            return e.push(s), !1
        }

        function r(s) {
            if (t) e.delete(s);
            else
                for (let i = 0; i < e.length; i++)
                    if (e[i] === s) {
                        e.splice(i, 1);
                        break
                    }
        }
        return [n, r]
    }

    function ru() {
        const t = Ss,
            e = t.crypto || t.msCrypto;
        if (e && e.randomUUID) return e.randomUUID().replace(/-/g, "");
        const n = e && e.getRandomValues ? () => e.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;
        return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, r => (r ^ (n() & 15) >> r / 4).toString(16))
    }

    function aC(t) {
        return t.exception && t.exception.values ? t.exception.values[0] : void 0
    }

    function co(t) {
        const {
            message: e,
            event_id: n
        } = t;
        if (e) return e;
        const r = aC(t);
        return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>"
    }

    function W1(t, e, n) {
        const r = t.exception = t.exception || {},
            s = r.values = r.values || [],
            i = s[0] = s[0] || {};
        i.value || (i.value = e || ""), i.type || (i.type = n || "Error")
    }

    function kd(t, e) {
        const n = aC(t);
        if (!n) return;
        const r = {
                type: "generic",
                handled: !0
            },
            s = n.mechanism;
        if (n.mechanism = {
                ...r,
                ...s,
                ...e
            }, e && "data" in e) {
            const i = {
                ...s && s.data,
                ...e.data
            };
            n.mechanism.data = i
        }
    }

    function nae(t) {
        return Array.isArray(t) ? t : [t]
    }

    function rae() {
        return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__
    }

    function sae() {
        return !rae() && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]"
    }

    function iae(t, e) {
        return t.require(e)
    }

    function oae(t, e = 100, n = 1 / 0) {
        try {
            return H1("", t, e, n)
        } catch (r) {
            return {
                ERROR: `**non-serializable** (${r})`
            }
        }
    }

    function cC(t, e = 3, n = 100 * 1024) {
        const r = oae(t, e);
        return uae(r) > n ? cC(t, e - 1, n) : r
    }

    function H1(t, e, n = 1 / 0, r = 1 / 0, s = tae()) {
        const [i, a] = s;
        if (e == null || ["number", "boolean", "string"].includes(typeof e) && !Ooe(e)) return e;
        const c = aae(t, e);
        if (!c.startsWith("[object ")) return c;
        if (e.__sentry_skip_normalization__) return e;
        const u = typeof e.__sentry_override_normalization_depth__ == "number" ? e.__sentry_override_normalization_depth__ : n;
        if (u === 0) return c.replace("object ", "");
        if (i(e)) return "[Circular ~]";
        const h = e;
        if (h && typeof h.toJSON == "function") try {
            const _ = h.toJSON();
            return H1("", _, u - 1, r, s)
        } catch {}
        const d = Array.isArray(e) ? [] : {};
        let p = 0;
        const m = oC(e);
        for (const _ in m) {
            if (!Object.prototype.hasOwnProperty.call(m, _)) continue;
            if (p >= r) {
                d[_] = "[MaxProperties ~]";
                break
            }
            const y = m[_];
            d[_] = H1(_, y, u - 1, r, s), p++
        }
        return a(e), d
    }

    function aae(t, e) {
        try {
            if (t === "domain" && e && typeof e == "object" && e._events) return "[Domain]";
            if (t === "domainEmitter") return "[DomainEmitter]";
            if (typeof global < "u" && e === global) return "[Global]";
            if (typeof window < "u" && e === window) return "[Window]";
            if (typeof document < "u" && e === document) return "[Document]";
            if (woe(e)) return "[SyntheticEvent]";
            if (typeof e == "number" && e !== e) return "[NaN]";
            if (typeof e == "function") return `[Function: ${wo(e)}]`;
            if (typeof e == "symbol") return `[${String(e)}]`;
            if (typeof e == "bigint") return `[BigInt: ${String(e)}]`;
            const n = cae(e);
            return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`
        } catch (n) {
            return `**non-serializable** (${n})`
        }
    }

    function cae(t) {
        const e = Object.getPrototypeOf(t);
        return e ? e.constructor.name : "null prototype"
    }

    function lae(t) {
        return ~-encodeURI(t).split(/%..|./).length
    }

    function uae(t) {
        return lae(JSON.stringify(t))
    }
    var Si;
    (function(t) {
        t[t.PENDING = 0] = "PENDING";
        const n = 1;
        t[t.RESOLVED = n] = "RESOLVED";
        const r = 2;
        t[t.REJECTED = r] = "REJECTED"
    })(Si || (Si = {}));
    class Ws {
        __init() {
            this._state = Si.PENDING
        }
        __init2() {
            this._handlers = []
        }
        constructor(e) {
            Ws.prototype.__init.call(this), Ws.prototype.__init2.call(this), Ws.prototype.__init3.call(this), Ws.prototype.__init4.call(this), Ws.prototype.__init5.call(this), Ws.prototype.__init6.call(this);
            try {
                e(this._resolve, this._reject)
            } catch (n) {
                this._reject(n)
            }
        }
        then(e, n) {
            return new Ws((r, s) => {
                this._handlers.push([!1, i => {
                    if (!e) r(i);
                    else try {
                        r(e(i))
                    } catch (a) {
                        s(a)
                    }
                }, i => {
                    if (!n) s(i);
                    else try {
                        r(n(i))
                    } catch (a) {
                        s(a)
                    }
                }]), this._executeHandlers()
            })
        } catch (e) {
            return this.then(n => n, e)
        } finally(e) {
            return new Ws((n, r) => {
                let s, i;
                return this.then(a => {
                    i = !1, s = a, e && e()
                }, a => {
                    i = !0, s = a, e && e()
                }).then(() => {
                    if (i) {
                        r(s);
                        return
                    }
                    n(s)
                })
            })
        }
        __init3() {
            this._resolve = e => {
                this._setResult(Si.RESOLVED, e)
            }
        }
        __init4() {
            this._reject = e => {
                this._setResult(Si.REJECTED, e)
            }
        }
        __init5() {
            this._setResult = (e, n) => {
                if (this._state === Si.PENDING) {
                    if (tC(n)) {
                        n.then(this._resolve, this._reject);
                        return
                    }
                    this._state = e, this._value = n, this._executeHandlers()
                }
            }
        }
        __init6() {
            this._executeHandlers = () => {
                if (this._state === Si.PENDING) return;
                const e = this._handlers.slice();
                this._handlers = [], e.forEach(n => {
                    n[0] || (this._state === Si.RESOLVED && n[1](this._value), this._state === Si.REJECTED && n[2](this._value), n[0] = !0)
                })
            }
        }
    }

    function j_(t) {
        if (!t) return {};
        const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
        if (!e) return {};
        const n = e[6] || "",
            r = e[8] || "";
        return {
            host: e[4],
            path: e[5],
            protocol: e[2],
            search: n,
            hash: r,
            relative: e[5] + n + r
        }
    }
    const hae = ["fatal", "error", "warning", "log", "info", "debug"];

    function fae(t) {
        return t === "warn" ? "warning" : hae.includes(t) ? t : "log"
    }
    const lC = ih(),
        K1 = {
            nowSeconds: () => Date.now() / 1e3
        };

    function dae() {
        const {
            performance: t
        } = lC;
        if (!t || !t.now) return;
        const e = Date.now() - t.now();
        return {
            now: () => t.now(),
            timeOrigin: e
        }
    }

    function pae() {
        try {
            return iae(R6, "perf_hooks").performance
        } catch {
            return
        }
    }
    const V_ = sae() ? pae() : dae(),
        Vw = V_ === void 0 ? K1 : {
            nowSeconds: () => (V_.timeOrigin + V_.now()) / 1e3
        },
        uC = K1.nowSeconds.bind(K1),
        hC = Vw.nowSeconds.bind(Vw);
    (() => {
        const {
            performance: t
        } = lC;
        if (!t || !t.now) return;
        const e = 3600 * 1e3,
            n = t.now(),
            r = Date.now(),
            s = t.timeOrigin ? Math.abs(t.timeOrigin + n - r) : e,
            i = s < e,
            a = t.timing && t.timing.navigationStart,
            u = typeof a == "number" ? Math.abs(a + n - r) : e,
            h = u < e;
        return i || h ? s <= u ? t.timeOrigin : a : r
    })();
    const mae = "production";

    function gae(t) {
        const e = hC(),
            n = {
                sid: ru(),
                init: !0,
                timestamp: e,
                started: e,
                duration: 0,
                status: "ok",
                errors: 0,
                ignoreDuration: !1,
                toJSON: () => yae(n)
            };
        return t && dm(n, t), n
    }

    function dm(t, e = {}) {
        if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address), !t.did && !e.did && (t.did = e.user.id || e.user.email || e.user.username)), t.timestamp = e.timestamp || hC(), e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration), e.sid && (t.sid = e.sid.length === 32 ? e.sid : ru()), e.init !== void 0 && (t.init = e.init), !t.did && e.did && (t.did = `${e.did}`), typeof e.started == "number" && (t.started = e.started), t.ignoreDuration) t.duration = void 0;
        else if (typeof e.duration == "number") t.duration = e.duration;
        else {
            const n = t.timestamp - t.started;
            t.duration = n >= 0 ? n : 0
        }
        e.release && (t.release = e.release), e.environment && (t.environment = e.environment), !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress), !t.userAgent && e.userAgent && (t.userAgent = e.userAgent), typeof e.errors == "number" && (t.errors = e.errors), e.status && (t.status = e.status)
    }

    function _ae(t, e) {
        let n = {};
        e ? n = {
            status: e
        } : t.status === "ok" && (n = {
            status: "exited"
        }), dm(t, n)
    }

    function yae(t) {
        return Uoe({
            sid: `${t.sid}`,
            init: t.init,
            started: new Date(t.started * 1e3).toISOString(),
            timestamp: new Date(t.timestamp * 1e3).toISOString(),
            status: t.status,
            errors: t.errors,
            did: typeof t.did == "number" || typeof t.did == "string" ? `${t.did}` : void 0,
            duration: t.duration,
            attrs: {
                release: t.release,
                environment: t.environment,
                ip_address: t.ipAddress,
                user_agent: t.userAgent
            }
        })
    }
    const vae = 100;
    class Sc {
        constructor() {
            this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}
        }
        static clone(e) {
            const n = new Sc;
            return e && (n._breadcrumbs = [...e._breadcrumbs], n._tags = {
                ...e._tags
            }, n._extra = {
                ...e._extra
            }, n._contexts = {
                ...e._contexts
            }, n._user = e._user, n._level = e._level, n._span = e._span, n._session = e._session, n._transactionName = e._transactionName, n._fingerprint = e._fingerprint, n._eventProcessors = [...e._eventProcessors], n._requestSession = e._requestSession, n._attachments = [...e._attachments], n._sdkProcessingMetadata = {
                ...e._sdkProcessingMetadata
            }), n
        }
        addScopeListener(e) {
            this._scopeListeners.push(e)
        }
        addEventProcessor(e) {
            return this._eventProcessors.push(e), this
        }
        setUser(e) {
            return this._user = e || {}, this._session && dm(this._session, {
                user: e
            }), this._notifyScopeListeners(), this
        }
        getUser() {
            return this._user
        }
        getRequestSession() {
            return this._requestSession
        }
        setRequestSession(e) {
            return this._requestSession = e, this
        }
        setTags(e) {
            return this._tags = {
                ...this._tags,
                ...e
            }, this._notifyScopeListeners(), this
        }
        setTag(e, n) {
            return this._tags = {
                ...this._tags,
                [e]: n
            }, this._notifyScopeListeners(), this
        }
        setExtras(e) {
            return this._extra = {
                ...this._extra,
                ...e
            }, this._notifyScopeListeners(), this
        }
        setExtra(e, n) {
            return this._extra = {
                ...this._extra,
                [e]: n
            }, this._notifyScopeListeners(), this
        }
        setFingerprint(e) {
            return this._fingerprint = e, this._notifyScopeListeners(), this
        }
        setLevel(e) {
            return this._level = e, this._notifyScopeListeners(), this
        }
        setTransactionName(e) {
            return this._transactionName = e, this._notifyScopeListeners(), this
        }
        setContext(e, n) {
            return n === null ? delete this._contexts[e] : this._contexts[e] = n, this._notifyScopeListeners(), this
        }
        setSpan(e) {
            return this._span = e, this._notifyScopeListeners(), this
        }
        getSpan() {
            return this._span
        }
        getTransaction() {
            const e = this.getSpan();
            return e && e.transaction
        }
        setSession(e) {
            return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this
        }
        getSession() {
            return this._session
        }
        update(e) {
            if (!e) return this;
            if (typeof e == "function") {
                const n = e(this);
                return n instanceof Sc ? n : this
            }
            return e instanceof Sc ? (this._tags = {
                ...this._tags,
                ...e._tags
            }, this._extra = {
                ...this._extra,
                ...e._extra
            }, this._contexts = {
                ...this._contexts,
                ...e._contexts
            }, e._user && Object.keys(e._user).length && (this._user = e._user), e._level && (this._level = e._level), e._fingerprint && (this._fingerprint = e._fingerprint), e._requestSession && (this._requestSession = e._requestSession)) : hm(e) && (e = e, this._tags = {
                ...this._tags,
                ...e.tags
            }, this._extra = {
                ...this._extra,
                ...e.extra
            }, this._contexts = {
                ...this._contexts,
                ...e.contexts
            }, e.user && (this._user = e.user), e.level && (this._level = e.level), e.fingerprint && (this._fingerprint = e.fingerprint), e.requestSession && (this._requestSession = e.requestSession)), this
        }
        clear() {
            return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this
        }
        addBreadcrumb(e, n) {
            const r = typeof n == "number" ? n : vae;
            if (r <= 0) return this;
            const s = {
                timestamp: uC(),
                ...e
            };
            return this._breadcrumbs = [...this._breadcrumbs, s].slice(-r), this._notifyScopeListeners(), this
        }
        getLastBreadcrumb() {
            return this._breadcrumbs[this._breadcrumbs.length - 1]
        }
        clearBreadcrumbs() {
            return this._breadcrumbs = [], this._notifyScopeListeners(), this
        }
        addAttachment(e) {
            return this._attachments.push(e), this
        }
        getAttachments() {
            return this._attachments
        }
        clearAttachments() {
            return this._attachments = [], this
        }
        applyToEvent(e, n = {}) {
            if (this._extra && Object.keys(this._extra).length && (e.extra = {
                    ...this._extra,
                    ...e.extra
                }), this._tags && Object.keys(this._tags).length && (e.tags = {
                    ...this._tags,
                    ...e.tags
                }), this._user && Object.keys(this._user).length && (e.user = {
                    ...this._user,
                    ...e.user
                }), this._contexts && Object.keys(this._contexts).length && (e.contexts = {
                    ...this._contexts,
                    ...e.contexts
                }), this._level && (e.level = this._level), this._transactionName && (e.transaction = this._transactionName), this._span) {
                e.contexts = {
                    trace: this._span.getTraceContext(),
                    ...e.contexts
                };
                const r = this._span.transaction;
                if (r) {
                    e.sdkProcessingMetadata = {
                        dynamicSamplingContext: r.getDynamicSamplingContext(),
                        ...e.sdkProcessingMetadata
                    };
                    const s = r.name;
                    s && (e.tags = {
                        transaction: s,
                        ...e.tags
                    })
                }
            }
            return this._applyFingerprint(e), e.breadcrumbs = [...e.breadcrumbs || [], ...this._breadcrumbs], e.breadcrumbs = e.breadcrumbs.length > 0 ? e.breadcrumbs : void 0, e.sdkProcessingMetadata = {
                ...e.sdkProcessingMetadata,
                ...this._sdkProcessingMetadata
            }, this._notifyEventProcessors([...fC(), ...this._eventProcessors], e, n)
        }
        setSDKProcessingMetadata(e) {
            return this._sdkProcessingMetadata = {
                ...this._sdkProcessingMetadata,
                ...e
            }, this
        }
        _notifyEventProcessors(e, n, r, s = 0) {
            return new Ws((i, a) => {
                const c = e[s];
                if (n === null || typeof c != "function") i(n);
                else {
                    const u = c({
                        ...n
                    }, r);
                    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && c.id && u === null && _n.log(`Event processor "${c.id}" dropped event`), tC(u) ? u.then(h => this._notifyEventProcessors(e, h, r, s + 1).then(i)).then(null, a) : this._notifyEventProcessors(e, u, r, s + 1).then(i).then(null, a)
                }
            })
        }
        _notifyScopeListeners() {
            this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(e => {
                e(this)
            }), this._notifyingListeners = !1)
        }
        _applyFingerprint(e) {
            e.fingerprint = e.fingerprint ? nae(e.fingerprint) : [], this._fingerprint && (e.fingerprint = e.fingerprint.concat(this._fingerprint)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint
        }
    }

    function fC() {
        return o0("globalEventProcessors", () => [])
    }

    function dC(t) {
        fC().push(t)
    }
    const pC = 4,
        bae = 100;
    class mC {
        constructor(e, n = new Sc, r = pC) {
            this._version = r, this._stack = [{
                scope: n
            }], e && this.bindClient(e)
        }
        isOlderThan(e) {
            return this._version < e
        }
        bindClient(e) {
            const n = this.getStackTop();
            n.client = e, e && e.setupIntegrations && e.setupIntegrations()
        }
        pushScope() {
            const e = Sc.clone(this.getScope());
            return this.getStack().push({
                client: this.getClient(),
                scope: e
            }), e
        }
        popScope() {
            return this.getStack().length <= 1 ? !1 : !!this.getStack().pop()
        }
        withScope(e) {
            const n = this.pushScope();
            try {
                e(n)
            } finally {
                this.popScope()
            }
        }
        getClient() {
            return this.getStackTop().client
        }
        getScope() {
            return this.getStackTop().scope
        }
        getStack() {
            return this._stack
        }
        getStackTop() {
            return this._stack[this._stack.length - 1]
        }
        captureException(e, n) {
            const r = this._lastEventId = n && n.event_id ? n.event_id : ru(),
                s = new Error("Sentry syntheticException");
            return this._withClient((i, a) => {
                i.captureException(e, {
                    originalException: e,
                    syntheticException: s,
                    ...n,
                    event_id: r
                }, a)
            }), r
        }
        captureMessage(e, n, r) {
            const s = this._lastEventId = r && r.event_id ? r.event_id : ru(),
                i = new Error(e);
            return this._withClient((a, c) => {
                a.captureMessage(e, n, {
                    originalException: e,
                    syntheticException: i,
                    ...r,
                    event_id: s
                }, c)
            }), s
        }
        captureEvent(e, n) {
            const r = n && n.event_id ? n.event_id : ru();
            return e.type || (this._lastEventId = r), this._withClient((s, i) => {
                s.captureEvent(e, {
                    ...n,
                    event_id: r
                }, i)
            }), r
        }
        lastEventId() {
            return this._lastEventId
        }
        addBreadcrumb(e, n) {
            const {
                scope: r,
                client: s
            } = this.getStackTop();
            if (!s) return;
            const {
                beforeBreadcrumb: i = null,
                maxBreadcrumbs: a = bae
            } = s.getOptions && s.getOptions() || {};
            if (a <= 0) return;
            const u = {
                    timestamp: uC(),
                    ...e
                },
                h = i ? rC(() => i(u, n)) : u;
            h !== null && (s.emit && s.emit("beforeAddBreadcrumb", h, n), r.addBreadcrumb(h, a))
        }
        setUser(e) {
            this.getScope().setUser(e)
        }
        setTags(e) {
            this.getScope().setTags(e)
        }
        setExtras(e) {
            this.getScope().setExtras(e)
        }
        setTag(e, n) {
            this.getScope().setTag(e, n)
        }
        setExtra(e, n) {
            this.getScope().setExtra(e, n)
        }
        setContext(e, n) {
            this.getScope().setContext(e, n)
        }
        configureScope(e) {
            const {
                scope: n,
                client: r
            } = this.getStackTop();
            r && e(n)
        }
        run(e) {
            const n = Gw(this);
            try {
                e(this)
            } finally {
                Gw(n)
            }
        }
        getIntegration(e) {
            const n = this.getClient();
            if (!n) return null;
            try {
                return n.getIntegration(e)
            } catch {
                return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.warn(`Cannot retrieve integration ${e.id} from the current Hub`), null
            }
        }
        startTransaction(e, n) {
            const r = this._callExtensionMethod("startTransaction", e, n);
            return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && !r && console.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`), r
        }
        traceHeaders() {
            return this._callExtensionMethod("traceHeaders")
        }
        captureSession(e = !1) {
            if (e) return this.endSession();
            this._sendSessionUpdate()
        }
        endSession() {
            const n = this.getStackTop().scope,
                r = n.getSession();
            r && _ae(r), this._sendSessionUpdate(), n.setSession()
        }
        startSession(e) {
            const {
                scope: n,
                client: r
            } = this.getStackTop(), {
                release: s,
                environment: i = mae
            } = r && r.getOptions() || {}, {
                userAgent: a
            } = Ss.navigator || {}, c = gae({
                release: s,
                environment: i,
                user: n.getUser(),
                ...a && {
                    userAgent: a
                },
                ...e
            }), u = n.getSession && n.getSession();
            return u && u.status === "ok" && dm(u, {
                status: "exited"
            }), this.endSession(), n.setSession(c), c
        }
        shouldSendDefaultPii() {
            const e = this.getClient(),
                n = e && e.getOptions();
            return !!(n && n.sendDefaultPii)
        }
        _sendSessionUpdate() {
            const {
                scope: e,
                client: n
            } = this.getStackTop(), r = e.getSession();
            r && n && n.captureSession && n.captureSession(r)
        }
        _withClient(e) {
            const {
                scope: n,
                client: r
            } = this.getStackTop();
            r && e(r, n)
        }
        _callExtensionMethod(e, ...n) {
            const s = pm().__SENTRY__;
            if (s && s.extensions && typeof s.extensions[e] == "function") return s.extensions[e].apply(this, n);
            (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.warn(`Extension method ${e} couldn't be found, doing nothing.`)
        }
    }

    function pm() {
        return Ss.__SENTRY__ = Ss.__SENTRY__ || {
            extensions: {},
            hub: void 0
        }, Ss
    }

    function Gw(t) {
        const e = pm(),
            n = Y1(e);
        return gC(e, t), n
    }

    function pr() {
        const t = pm();
        if (t.__SENTRY__ && t.__SENTRY__.acs) {
            const e = t.__SENTRY__.acs.getCurrentHub();
            if (e) return e
        }
        return Eae(t)
    }

    function Eae(t = pm()) {
        return (!Tae(t) || Y1(t).isOlderThan(pC)) && gC(t, new mC), Y1(t)
    }

    function Tae(t) {
        return !!(t && t.__SENTRY__ && t.__SENTRY__.hub)
    }

    function Y1(t) {
        return o0("hub", () => new mC, t)
    }

    function gC(t, e) {
        if (!t) return !1;
        const n = t.__SENTRY__ = t.__SENTRY__ || {};
        return n.hub = e, !0
    }

    function Sae(t, e) {
        return pr().captureException(t, {
            captureContext: e
        })
    }

    function wae(t) {
        pr().withScope(t)
    }

    function Oae(t) {
        const e = t.protocol ? `${t.protocol}:` : "",
            n = t.port ? `:${t.port}` : "";
        return `${e}//${t.host}${n}${t.path?`/${t.path}`:""}/api/`
    }

    function Aae(t, e) {
        const n = Doe(t),
            r = `${Oae(n)}embed/error-page/`;
        let s = `dsn=${Poe(n)}`;
        for (const i in e)
            if (i !== "dsn")
                if (i === "user") {
                    const a = e.user;
                    if (!a) continue;
                    a.name && (s += `&name=${encodeURIComponent(a.name)}`), a.email && (s += `&email=${encodeURIComponent(a.email)}`)
                } else s += `&${encodeURIComponent(i)}=${encodeURIComponent(e[i])}`;
        return `${r}?${s}`
    }
    let Ww;
    class vu {
        constructor() {
            vu.prototype.__init.call(this)
        }
        static __initStatic() {
            this.id = "FunctionToString"
        }
        __init() {
            this.name = vu.id
        }
        setupOnce() {
            Ww = Function.prototype.toString;
            try {
                Function.prototype.toString = function(...e) {
                    const n = a0(this) || this;
                    return Ww.apply(n, e)
                }
            } catch {}
        }
    }
    vu.__initStatic();
    const Cae = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
    class wc {
        static __initStatic() {
            this.id = "InboundFilters"
        }
        __init() {
            this.name = wc.id
        }
        constructor(e = {}) {
            this._options = e, wc.prototype.__init.call(this)
        }
        setupOnce(e, n) {
            const r = s => {
                const i = n();
                if (i) {
                    const a = i.getIntegration(wc);
                    if (a) {
                        const c = i.getClient(),
                            u = c ? c.getOptions() : {},
                            h = kae(a._options, u);
                        return Iae(s, h) ? null : s
                    }
                }
                return s
            };
            r.id = this.name, e(r)
        }
    }
    wc.__initStatic();

    function kae(t = {}, e = {}) {
        return {
            allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
            denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
            ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...Cae],
            ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []],
            ignoreInternal: t.ignoreInternal !== void 0 ? t.ignoreInternal : !0
        }
    }

    function Iae(t, e) {
        return e.ignoreInternal && Dae(t) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.warn(`Event dropped due to being internal Sentry Error.
Event: ${co(t)}`), !0) : Nae(t, e.ignoreErrors) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${co(t)}`), !0) : xae(t, e.ignoreTransactions) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${co(t)}`), !0) : Pae(t, e.denyUrls) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${co(t)}.
Url: ${Id(t)}`), !0) : Rae(t, e.allowUrls) ? !1 : ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${co(t)}.
Url: ${Id(t)}`), !0)
    }

    function Nae(t, e) {
        return t.type || !e || !e.length ? !1 : Mae(t).some(n => fm(n, e))
    }

    function xae(t, e) {
        if (t.type !== "transaction" || !e || !e.length) return !1;
        const n = t.transaction;
        return n ? fm(n, e) : !1
    }

    function Pae(t, e) {
        if (!e || !e.length) return !1;
        const n = Id(t);
        return n ? fm(n, e) : !1
    }

    function Rae(t, e) {
        if (!e || !e.length) return !0;
        const n = Id(t);
        return n ? fm(n, e) : !0
    }

    function Mae(t) {
        if (t.message) return [t.message];
        if (t.exception) {
            const {
                values: e
            } = t.exception;
            try {
                const {
                    type: n = "",
                    value: r = ""
                } = e && e[e.length - 1] || {};
                return [`${r}`, `${n}: ${r}`]
            } catch {
                return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.error(`Cannot extract message for event ${co(t)}`), []
            }
        }
        return []
    }

    function Dae(t) {
        try {
            return t.exception.values[0].type === "SentryError"
        } catch {}
        return !1
    }

    function $ae(t = []) {
        for (let e = t.length - 1; e >= 0; e--) {
            const n = t[e];
            if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]") return n.filename || null
        }
        return null
    }

    function Id(t) {
        try {
            let e;
            try {
                e = t.exception.values[0].stacktrace.frames
            } catch {}
            return e ? $ae(e) : null
        } catch {
            return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.error(`Cannot extract url for event ${co(t)}`), null
        }
    }
    const qn = Ss;
    let z1 = 0;

    function _C() {
        return z1 > 0
    }

    function Lae() {
        z1++, setTimeout(() => {
            z1--
        })
    }

    function Fc(t, e = {}, n) {
        if (typeof t != "function") return t;
        try {
            const s = t.__sentry_wrapped__;
            if (s) return s;
            if (a0(t)) return t
        } catch {
            return t
        }
        const r = function() {
            const s = Array.prototype.slice.call(arguments);
            try {
                n && typeof n == "function" && n.apply(this, arguments);
                const i = s.map(a => Fc(a, e));
                return t.apply(this, i)
            } catch (i) {
                throw Lae(), wae(a => {
                    a.addEventProcessor(c => (e.mechanism && (W1(c, void 0, void 0), kd(c, e.mechanism)), c.extra = {
                        ...c.extra,
                        arguments: s
                    }, c)), Sae(i)
                }), i
            }
        };
        try {
            for (const s in t) Object.prototype.hasOwnProperty.call(t, s) && (r[s] = t[s])
        } catch {}
        iC(r, t), sC(t, "__sentry_wrapped__", r);
        try {
            Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
                get() {
                    return t.name
                }
            })
        } catch {}
        return r
    }

    function yC(t, e) {
        const n = c0(t, e),
            r = {
                type: e && e.name,
                value: qae(e)
            };
        return n.length && (r.stacktrace = {
            frames: n
        }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r
    }

    function Fae(t, e, n, r) {
        const i = pr().getClient(),
            a = i && i.getOptions().normalizeDepth,
            c = {
                exception: {
                    values: [{
                        type: i0(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
                        value: `Non-Error ${r?"promise rejection":"exception"} captured with keys: ${Foe(e)}`
                    }]
                },
                extra: {
                    __serialized__: cC(e, a)
                }
            };
        if (n) {
            const u = c0(t, n);
            u.length && (c.exception.values[0].stacktrace = {
                frames: u
            })
        }
        return c
    }

    function G_(t, e) {
        return {
            exception: {
                values: [yC(t, e)]
            }
        }
    }

    function c0(t, e) {
        const n = e.stacktrace || e.stack || "",
            r = Bae(e);
        try {
            return t(n, r)
        } catch {}
        return []
    }
    const Uae = /Minified React error #\d+;/i;

    function Bae(t) {
        if (t) {
            if (typeof t.framesToPop == "number") return t.framesToPop;
            if (Uae.test(t.message)) return 1
        }
        return 0
    }

    function qae(t) {
        const e = t && t.message;
        return e ? e.error && typeof e.error.message == "string" ? e.error.message : e : "No error message"
    }

    function vC(t, e, n, r, s) {
        let i;
        if (eC(e) && e.error) return G_(t, e.error);
        if (Rw(e) || boe(e)) {
            const a = e;
            if ("stack" in e) i = G_(t, e);
            else {
                const c = a.name || (Rw(a) ? "DOMError" : "DOMException"),
                    u = a.message ? `${c}: ${a.message}` : c;
                i = Hw(t, u, n, r), W1(i, u)
            }
            return "code" in a && (i.tags = {
                ...i.tags,
                "DOMException.code": `${a.code}`
            }), i
        }
        return QA(e) ? G_(t, e) : hm(e) || i0(e) ? (i = Fae(t, e, n, s), kd(i, {
            synthetic: !0
        }), i) : (i = Hw(t, e, n, r), W1(i, `${e}`, void 0), kd(i, {
            synthetic: !0
        }), i)
    }

    function Hw(t, e, n, r) {
        const s = {
            message: e
        };
        if (r && n) {
            const i = c0(t, n);
            i.length && (s.exception = {
                values: [{
                    value: e,
                    stacktrace: {
                        frames: i
                    }
                }]
            })
        }
        return s
    }
    const Df = 1024,
        jae = "Breadcrumbs";
    class bu {
        static __initStatic() {
            this.id = jae
        }
        __init() {
            this.name = bu.id
        }
        constructor(e) {
            bu.prototype.__init.call(this), this.options = {
                console: !0,
                dom: !0,
                fetch: !0,
                history: !0,
                sentry: !0,
                xhr: !0,
                ...e
            }
        }
        setupOnce() {
            this.options.console && la("console", Gae), this.options.dom && la("dom", Vae(this.options.dom)), this.options.xhr && la("xhr", Wae), this.options.fetch && la("fetch", Hae), this.options.history && la("history", Kae)
        }
        addSentryBreadcrumb(e) {
            this.options.sentry && pr().addBreadcrumb({
                category: `sentry.${e.type==="transaction"?"transaction":"event"}`,
                event_id: e.event_id,
                level: e.level,
                message: co(e)
            }, {
                event: e
            })
        }
    }
    bu.__initStatic();

    function Vae(t) {
        function e(n) {
            let r, s = typeof t == "object" ? t.serializeAttribute : void 0,
                i = typeof t == "object" && typeof t.maxStringLength == "number" ? t.maxStringLength : void 0;
            i && i > Df && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.warn(`\`dom.maxStringLength\` cannot exceed ${Df}, but a value of ${i} was configured. Sentry will use ${Df} instead.`), i = Df), typeof s == "string" && (s = [s]);
            try {
                const a = n.event;
                r = Yae(a) ? q1(a.target, {
                    keyAttrs: s,
                    maxStringLength: i
                }) : q1(a, {
                    keyAttrs: s,
                    maxStringLength: i
                })
            } catch {
                r = "<unknown>"
            }
            r.length !== 0 && pr().addBreadcrumb({
                category: `ui.${n.name}`,
                message: r
            }, {
                event: n.event,
                name: n.name,
                global: n.global
            })
        }
        return e
    }

    function Gae(t) {
        for (let n = 0; n < t.args.length; n++)
            if (t.args[n] === "ref=Ref<") {
                t.args[n + 1] = "viewRef";
                break
            } const e = {
            category: "console",
            data: {
                arguments: t.args,
                logger: "console"
            },
            level: fae(t.level),
            message: $w(t.args, " ")
        };
        if (t.level === "assert")
            if (t.args[0] === !1) e.message = `Assertion failed: ${$w(t.args.slice(1)," ")||"console.assert"}`, e.data.arguments = t.args.slice(1);
            else return;
        pr().addBreadcrumb(e, {
            input: t.args,
            level: t.level
        })
    }

    function Wae(t) {
        const {
            startTimestamp: e,
            endTimestamp: n
        } = t, r = t.xhr[Hl];
        if (!e || !n || !r) return;
        const {
            method: s,
            url: i,
            status_code: a,
            body: c
        } = r, u = {
            method: s,
            url: i,
            status_code: a
        }, h = {
            xhr: t.xhr,
            input: c,
            startTimestamp: e,
            endTimestamp: n
        };
        pr().addBreadcrumb({
            category: "xhr",
            data: u,
            type: "http"
        }, h)
    }

    function Hae(t) {
        const {
            startTimestamp: e,
            endTimestamp: n
        } = t;
        if (n && !(t.fetchData.url.match(/sentry_key/) && t.fetchData.method === "POST"))
            if (t.error) {
                const r = t.fetchData,
                    s = {
                        data: t.error,
                        input: t.args,
                        startTimestamp: e,
                        endTimestamp: n
                    };
                pr().addBreadcrumb({
                    category: "fetch",
                    data: r,
                    level: "error",
                    type: "http"
                }, s)
            } else {
                const r = {
                        ...t.fetchData,
                        status_code: t.response && t.response.status
                    },
                    s = {
                        input: t.args,
                        response: t.response,
                        startTimestamp: e,
                        endTimestamp: n
                    };
                pr().addBreadcrumb({
                    category: "fetch",
                    data: r,
                    type: "http"
                }, s)
            }
    }

    function Kae(t) {
        let e = t.from,
            n = t.to;
        const r = j_(qn.location.href);
        let s = j_(e);
        const i = j_(n);
        s.path || (s = r), r.protocol === i.protocol && r.host === i.host && (n = i.relative), r.protocol === s.protocol && r.host === s.host && (e = s.relative), pr().addBreadcrumb({
            category: "navigation",
            data: {
                from: e,
                to: n
            }
        })
    }

    function Yae(t) {
        return t && !!t.target
    }
    class _o {
        static __initStatic() {
            this.id = "GlobalHandlers"
        }
        __init() {
            this.name = _o.id
        }
        __init2() {
            this._installFunc = {
                onerror: zae,
                onunhandledrejection: Zae
            }
        }
        constructor(e) {
            _o.prototype.__init.call(this), _o.prototype.__init2.call(this), this._options = {
                onerror: !0,
                onunhandledrejection: !0,
                ...e
            }
        }
        setupOnce() {
            Error.stackTraceLimit = 50;
            const e = this._options;
            for (const n in e) {
                const r = this._installFunc[n];
                r && e[n] && (Qae(n), r(), this._installFunc[n] = void 0)
            }
        }
    }
    _o.__initStatic();

    function zae() {
        la("error", t => {
            const [e, n, r] = TC();
            if (!e.getIntegration(_o)) return;
            const {
                msg: s,
                url: i,
                line: a,
                column: c,
                error: u
            } = t;
            if (_C() || u && u.__sentry_own_request__) return;
            const h = u === void 0 && Sa(s) ? Jae(s, i, a, c) : bC(vC(n, u || s, void 0, r, !1), i, a, c);
            h.level = "error", EC(e, u, h, "onerror")
        })
    }

    function Zae() {
        la("unhandledrejection", t => {
            const [e, n, r] = TC();
            if (!e.getIntegration(_o)) return;
            let s = t;
            try {
                "reason" in t ? s = t.reason : "detail" in t && "reason" in t.detail && (s = t.detail.reason)
            } catch {}
            if (_C() || s && s.__sentry_own_request__) return !0;
            const i = Eoe(s) ? Xae(s) : vC(n, s, void 0, r, !0);
            i.level = "error", EC(e, s, i, "onunhandledrejection")
        })
    }

    function Xae(t) {
        return {
            exception: {
                values: [{
                    type: "UnhandledRejection",
                    value: `Non-Error promise rejection captured with value: ${String(t)}`
                }]
            }
        }
    }

    function Jae(t, e, n, r) {
        const s = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
        let i = eC(t) ? t.message : t,
            a = "Error";
        const c = i.match(s);
        return c && (a = c[1], i = c[2]), bC({
            exception: {
                values: [{
                    type: a,
                    value: i
                }]
            }
        }, e, n, r)
    }

    function bC(t, e, n, r) {
        const s = t.exception = t.exception || {},
            i = s.values = s.values || [],
            a = i[0] = i[0] || {},
            c = a.stacktrace = a.stacktrace || {},
            u = c.frames = c.frames || [],
            h = isNaN(parseInt(r, 10)) ? void 0 : r,
            d = isNaN(parseInt(n, 10)) ? void 0 : n,
            p = Sa(e) && e.length > 0 ? e : Ioe();
        return u.length === 0 && u.push({
            colno: h,
            filename: p,
            function: "?",
            in_app: !0,
            lineno: d
        }), t
    }

    function Qae(t) {
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.log(`Global Handler attached: ${t}`)
    }

    function EC(t, e, n, r) {
        kd(n, {
            handled: !1,
            type: r
        }), t.captureEvent(n, {
            originalException: e
        })
    }

    function TC() {
        const t = pr(),
            e = t.getClient(),
            n = e && e.getOptions() || {
                stackParser: () => [],
                attachStacktrace: !1
            };
        return [t, n.stackParser, n.attachStacktrace]
    }
    const ece = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
    class Eu {
        static __initStatic() {
            this.id = "TryCatch"
        }
        __init() {
            this.name = Eu.id
        }
        constructor(e) {
            Eu.prototype.__init.call(this), this._options = {
                XMLHttpRequest: !0,
                eventTarget: !0,
                requestAnimationFrame: !0,
                setInterval: !0,
                setTimeout: !0,
                ...e
            }
        }
        setupOnce() {
            this._options.setTimeout && Gn(qn, "setTimeout", Kw), this._options.setInterval && Gn(qn, "setInterval", Kw), this._options.requestAnimationFrame && Gn(qn, "requestAnimationFrame", tce), this._options.XMLHttpRequest && "XMLHttpRequest" in qn && Gn(XMLHttpRequest.prototype, "send", nce);
            const e = this._options.eventTarget;
            e && (Array.isArray(e) ? e : ece).forEach(rce)
        }
    }
    Eu.__initStatic();

    function Kw(t) {
        return function(...e) {
            const n = e[0];
            return e[0] = Fc(n, {
                mechanism: {
                    data: {
                        function: wo(t)
                    },
                    handled: !0,
                    type: "instrument"
                }
            }), t.apply(this, e)
        }
    }

    function tce(t) {
        return function(e) {
            return t.apply(this, [Fc(e, {
                mechanism: {
                    data: {
                        function: "requestAnimationFrame",
                        handler: wo(t)
                    },
                    handled: !0,
                    type: "instrument"
                }
            })])
        }
    }

    function nce(t) {
        return function(...e) {
            const n = this;
            return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(s => {
                s in n && typeof n[s] == "function" && Gn(n, s, function(i) {
                    const a = {
                            mechanism: {
                                data: {
                                    function: s,
                                    handler: wo(i)
                                },
                                handled: !0,
                                type: "instrument"
                            }
                        },
                        c = a0(i);
                    return c && (a.mechanism.data.handler = wo(c)), Fc(i, a)
                })
            }), t.apply(this, e)
        }
    }

    function rce(t) {
        const e = qn,
            n = e[t] && e[t].prototype;
        !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (Gn(n, "addEventListener", function(r) {
            return function(s, i, a) {
                try {
                    typeof i.handleEvent == "function" && (i.handleEvent = Fc(i.handleEvent, {
                        mechanism: {
                            data: {
                                function: "handleEvent",
                                handler: wo(i),
                                target: t
                            },
                            handled: !0,
                            type: "instrument"
                        }
                    }))
                } catch {}
                return r.apply(this, [s, Fc(i, {
                    mechanism: {
                        data: {
                            function: "addEventListener",
                            handler: wo(i),
                            target: t
                        },
                        handled: !0,
                        type: "instrument"
                    }
                }), a])
            }
        }), Gn(n, "removeEventListener", function(r) {
            return function(s, i, a) {
                const c = i;
                try {
                    const u = c && c.__sentry_wrapped__;
                    u && r.call(this, s, u, a)
                } catch {}
                return r.call(this, s, c, a)
            }
        }))
    }
    const sce = "cause",
        ice = 5;
    class Oc {
        static __initStatic() {
            this.id = "LinkedErrors"
        }
        __init() {
            this.name = Oc.id
        }
        constructor(e = {}) {
            Oc.prototype.__init.call(this), this._key = e.key || sce, this._limit = e.limit || ice
        }
        setupOnce() {
            const e = pr().getClient();
            e && dC((n, r) => {
                const s = pr().getIntegration(Oc);
                return s ? oce(e.getOptions().stackParser, s._key, s._limit, n, r) : n
            })
        }
    }
    Oc.__initStatic();

    function oce(t, e, n, r, s) {
        if (!r.exception || !r.exception.values || !s || !hl(s.originalException, Error)) return r;
        const i = SC(t, n, s.originalException, e);
        return r.exception.values = [...i, ...r.exception.values], r
    }

    function SC(t, e, n, r, s = []) {
        if (!hl(n[r], Error) || s.length + 1 >= e) return s;
        const i = yC(t, n[r]);
        return SC(t, e, n[r], r, [i, ...s])
    }
    class Ac {
        constructor() {
            Ac.prototype.__init.call(this)
        }
        static __initStatic() {
            this.id = "HttpContext"
        }
        __init() {
            this.name = Ac.id
        }
        setupOnce() {
            dC(e => {
                if (pr().getIntegration(Ac)) {
                    if (!qn.navigator && !qn.location && !qn.document) return e;
                    const n = e.request && e.request.url || qn.location && qn.location.href,
                        {
                            referrer: r
                        } = qn.document || {},
                        {
                            userAgent: s
                        } = qn.navigator || {},
                        i = {
                            ...e.request && e.request.headers,
                            ...r && {
                                Referer: r
                            },
                            ...s && {
                                "User-Agent": s
                            }
                        },
                        a = {
                            ...e.request,
                            ...n && {
                                url: n
                            },
                            headers: i
                        };
                    return {
                        ...e,
                        request: a
                    }
                }
                return e
            })
        }
    }
    Ac.__initStatic();
    class Cc {
        constructor() {
            Cc.prototype.__init.call(this)
        }
        static __initStatic() {
            this.id = "Dedupe"
        }
        __init() {
            this.name = Cc.id
        }
        setupOnce(e, n) {
            const r = s => {
                if (s.type) return s;
                const i = n().getIntegration(Cc);
                if (i) {
                    try {
                        if (ace(s, i._previousEvent)) return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.warn("Event dropped due to being a duplicate of previously captured event."), null
                    } catch {
                        return i._previousEvent = s
                    }
                    return i._previousEvent = s
                }
                return s
            };
            r.id = this.name, e(r)
        }
    }
    Cc.__initStatic();

    function ace(t, e) {
        return e ? !!(cce(t, e) || lce(t, e)) : !1
    }

    function cce(t, e) {
        const n = t.message,
            r = e.message;
        return !(!n && !r || n && !r || !n && r || n !== r || !OC(t, e) || !wC(t, e))
    }

    function lce(t, e) {
        const n = Yw(e),
            r = Yw(t);
        return !(!n || !r || n.type !== r.type || n.value !== r.value || !OC(t, e) || !wC(t, e))
    }

    function wC(t, e) {
        let n = zw(t),
            r = zw(e);
        if (!n && !r) return !0;
        if (n && !r || !n && r || (n = n, r = r, r.length !== n.length)) return !1;
        for (let s = 0; s < r.length; s++) {
            const i = r[s],
                a = n[s];
            if (i.filename !== a.filename || i.lineno !== a.lineno || i.colno !== a.colno || i.function !== a.function) return !1
        }
        return !0
    }

    function OC(t, e) {
        let n = t.fingerprint,
            r = e.fingerprint;
        if (!n && !r) return !0;
        if (n && !r || !n && r) return !1;
        n = n, r = r;
        try {
            return n.join("") === r.join("")
        } catch {
            return !1
        }
    }

    function Yw(t) {
        return t.exception && t.exception.values && t.exception.values[0]
    }

    function zw(t) {
        const e = t.exception;
        if (e) try {
            return e.values[0].stacktrace.frames
        } catch {
            return
        }
    }
    new wc, new vu, new Eu, new bu, new _o, new Oc, new Cc, new Ac;

    function uce(t = {}, e = pr()) {
        if (!qn.document) {
            (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.error("Global document not defined in showReportDialog call");
            return
        }
        const {
            client: n,
            scope: r
        } = e.getStackTop(), s = t.dsn || n && n.getDsn();
        if (!s) {
            (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.error("DSN not configured for showReportDialog call");
            return
        }
        r && (t.user = {
            ...r.getUser(),
            ...t.user
        }), t.eventId || (t.eventId = e.lastEventId());
        const i = qn.document.createElement("script");
        i.async = !0, i.src = Aae(s, t), t.onLoad && (i.onload = t.onLoad);
        const a = qn.document.head || qn.document.body;
        a ? a.appendChild(i) : (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && _n.error("Not injecting report dialog. No injection point found in HTML")
    }
    const hce = mt({
            setup() {
                return {
                    fatalError: mo(sh.fatal.error)
                }
            },
            computed: {
                message() {
                    var r, s, i, a;
                    const t = ((s = (r = this.fatalError) == null ? void 0 : r.event) == null ? void 0 : s.event_id) ?? "Unknown";
                    let e = "";
                    const n = (a = (i = this.fatalError) == null ? void 0 : i.hint) == null ? void 0 : a.originalException;
                    return n ? typeof n == "string" ? e = n : e = n.message : e = "An unknown error occured", `Version:
${window.tv.manifest.loader.version}

Event ID:
${t}

${e}`
                }
            },
            methods: {
                onFeedbackClick() {
                    var t, e;
                    uce({
                        id: ((e = (t = this.fatalError) == null ? void 0 : t.event) == null ? void 0 : e.event_id) ?? "Unknown"
                    })
                }
            }
        }),
        oh = t => (Ns("data-v-a7272d53"), t = t(), xs(), t),
        fce = {
            class: "jbg fatal"
        },
        dce = {
            class: "constrain"
        },
        pce = oh(() => B("a", {
            class: "logo",
            href: "/",
            "aria-label": "Jackbox Games Logo"
        }, null, -1)),
        mce = {
            class: "content"
        },
        gce = oh(() => B("h1", null, "You have encountered an error", -1)),
        _ce = oh(() => B("p", null, "Something went wrong! But don't worry, you can try a few things to get going.", -1)),
        yce = oh(() => B("ul", null, [B("li", null, "Refresh the page"), B("li", null, "Turn off adblockers or other browser extensions."), B("li", null, "Check your connection to the Internet."), B("li", null, "Make sure you're using an up-to-date browser."), B("li", null, "If that doesn't work, let us know.")], -1)),
        vce = oh(() => B("hr", null, null, -1)),
        bce = {
            class: "error"
        };

    function Ece(t, e, n, r, s, i) {
        return G(), H("div", fce, [B("div", dce, [pce, B("div", mce, [gce, _ce, yce, B("button", {
            onClick: e[0] || (e[0] = (...a) => t.onFeedbackClick && t.onFeedbackClick(...a))
        }, "Tell us what happened"), vce, B("pre", bce, vt(t.message), 1)])])])
    }
    const Tce = ot(hce, [
            ["render", Ece],
            ["__scopeId", "data-v-a7272d53"]
        ]),
        $f = Nc({
            hasCrashed: !1
        }),
        Sce = {
            install: t => {
                if (t.config.globalProperties.$handleEcastError) return;
                t.provide(sh.fatal.error, Lr(() => $f));
                const e = (n, r) => {
                    var s, i;
                    if (n instanceof eu.EcastEntityNotFound || n instanceof eu.EcastFilterError || n instanceof eu.EcastRateLimitExceeded || n instanceof Error && ((s = n.message) != null && s.includes("Socket not ready to send")) || n instanceof Error && ((i = n.message) != null && i.includes("No connection available"))) return console.warn(n);
                    throw r ? console.error(r, n) : console.error(n), n
                };
                window.tv.onError = async (n, r) => {
                    if (n.level === "error" && ($f.hasCrashed = !0, $f.event = n, $f.hint = r), t.config.globalProperties.$debugRecorder) return await t.config.globalProperties.$debugRecorder.sendToEcast()
                }, t.component("Fatal", Tce), t.config.globalProperties.$handleEcastError = e
            }
        };
    var wce = ZA,
        Oce = XA;

    function Ace(t, e) {
        e = wce(e, t);
        for (var n = 0, r = e.length; t != null && n < r;) t = t[Oce(e[n++])];
        return n && n == r ? t : void 0
    }
    var Cce = Ace,
        kce = Cce;

    function Ice(t, e, n) {
        var r = t == null ? void 0 : kce(t, e);
        return r === void 0 ? n : r
    }
    var Nce = Ice;
    const xce = el(Nce);
    var Pce = Math.floor,
        Rce = Math.random;

    function Mce(t, e) {
        return t + Pce(Rce() * (e - t + 1))
    }
    var Dce = Mce,
        $ce = Dce;

    function Lce(t) {
        var e = t.length;
        return e ? t[$ce(0, e - 1)] : void 0
    }
    var AC = Lce,
        Fce = YA;

    function Uce(t, e) {
        return Fce(e, function(n) {
            return t[n]
        })
    }
    var Bce = Uce,
        qce = Bce,
        jce = lm;

    function Vce(t) {
        return t == null ? [] : qce(t, jce(t))
    }
    var Gce = Vce,
        Wce = AC,
        Hce = Gce;

    function Kce(t) {
        return Wce(Hce(t))
    }
    var Yce = Kce,
        zce = AC,
        Zce = Yce,
        Xce = Mo;

    function Jce(t) {
        var e = Xce(t) ? zce : Zce;
        return e(t)
    }
    var Qce = Jce;
    const ele = el(Qce);

    function Zw(t, e) {
        const n = t.global.locale,
            r = t.global.messages[n],
            s = xce(r, e);
        return Array.isArray(s) || console.warn(`[i18nPlugin] Translation with key ${e} is not an array`), ele(s)
    }
    const tle = {
            install: (t, e) => {
                t.directive("ts", (n, r) => {
                    const s = Zw(e.i18n, r.value);
                    n.textContent = s || ""
                }), t.config.globalProperties.$ts = function(r) {
                    return Zw(e.i18n, r) || ""
                }, t.config.globalProperties.$t = e.i18n.global.t, t.config.globalProperties.$tc = e.i18n.global.tc, t.config.globalProperties.$te = e.i18n.global.te, t.config.globalProperties.$tm = e.i18n.global.tm
            }
        },
        nle = mt({
            props: {
                image: String,
                text: String,
                subtext: String,
                classes: {
                    type: [Array, String],
                    default: () => "jbg"
                },
                dismissText: String
            }
        }),
        rle = "main/pp10/nopus-opus/assets/928ef0da.png",
        sle = "main/pp10/nopus-opus/assets/0bb76a2d.png",
        ile = "main/pp10/nopus-opus/assets/ed4469b3.png",
        ole = {
            key: 0,
            class: "image",
            src: rle,
            alt: "Kicked"
        },
        ale = {
            key: 1,
            class: "image",
            src: sle,
            alt: "Thank You"
        },
        cle = {
            key: 2,
            class: "image",
            src: ile,
            alt: "Error"
        },
        lle = {
            class: "text"
        },
        ule = {
            key: 3,
            class: "subtext"
        },
        hle = {
            class: "actions"
        };

    function fle(t, e, n, r, s, i) {
        const a = On("bb");
        return G(), H("div", {
            class: Xe(["error-model", t.classes])
        }, [t.image === "tear" ? (G(), H("img", ole)) : t.image === "moon" ? (G(), H("img", ale)) : (G(), H("img", cle)), Ke(B("h3", lle, null, 512), [
            [a, t.text]
        ]), t.subtext ? Ke((G(), H("h3", ule, null, 512)), [
            [a, t.subtext]
        ]) : Be("", !0), B("div", hle, [Ke(B("button", {
            onClick: e[0] || (e[0] = Pi(c => t.$emit("resolve"), ["prevent"]))
        }, null, 512), [
            [a, t.dismissText]
        ])])], 2)
    }
    const dle = ot(nle, [
            ["render", fle],
            ["__scopeId", "data-v-39debcb6"]
        ]),
        ple = mt({
            props: {
                text: String,
                subtext: String,
                classes: {
                    type: [Array, String],
                    default: () => "jbg"
                },
                options: Array
            },
            emits: ["resolve"]
        }),
        mle = {
            class: "text"
        },
        gle = {
            key: 0,
            class: "subtext"
        },
        _le = {
            class: "actions"
        },
        yle = ["onClick"];

    function vle(t, e, n, r, s, i) {
        const a = On("bb");
        return G(), H("div", {
            class: Xe(["options-modal", t.classes])
        }, [Ke(B("h3", mle, null, 512), [
            [a, t.text]
        ]), t.subtext ? Ke((G(), H("h3", gle, null, 512)), [
            [a, t.subtext]
        ]) : Be("", !0), B("div", _le, [(G(!0), H(Tt, null, $n(t.options, (c, u) => Ke((G(), H("button", {
            key: u,
            class: Xe(c.classes),
            onClick: Pi(h => t.$emit("resolve", c.value), ["prevent"])
        }, null, 10, yle)), [
            [a, c.text]
        ])), 128))])], 2)
    }
    const ble = ot(ple, [
            ["render", vle],
            ["__scopeId", "data-v-adb60058"]
        ]),
        Ele = mt({
            data() {
                return {
                    classes: "jbg",
                    props: null,
                    resolve: null,
                    content: null
                }
            },
            beforeMount() {
                this.$registerModal(this)
            },
            methods: {
                show(t, e = {}, n = {}) {
                    return this.props = e, this.classes = n.classes || "jbg", t === "Error" ? this.content = dle : t === "Options" ? this.content = ble : this.content = t, new Promise(r => {
                        this.resolve = r
                    })
                },
                onResolve(...t) {
                    this.props = null, this.resolve(...t)
                },
                onBackgroundClick() {
                    this.props = null, this.resolve()
                }
            }
        });

    function Tle(t, e, n, r, s, i) {
        return G(), Ut(Li, {
            name: "modal-transition"
        }, {
            default: si(() => [t.props ? (G(), H("div", {
                key: 0,
                class: Xe(["modal", t.classes]),
                onKeyup: e[0] || (e[0] = Wy((...a) => t.onBackgroundClick && t.onBackgroundClick(...a), ["esc"])),
                onClick: e[1] || (e[1] = Pi((...a) => t.onBackgroundClick && t.onBackgroundClick(...a), ["self"]))
            }, [t.content ? (G(), Ut(Fy(t.content), Bp({
                key: 0,
                class: "content"
            }, t.props, {
                onResolve: t.onResolve
            }), null, 16, ["onResolve"])) : Be("", !0)], 34)) : Be("", !0)]),
            _: 1
        })
    }
    const Sle = ot(Ele, [
            ["render", Tle],
            ["__scopeId", "data-v-dc92e8d3"]
        ]),
        wle = {
            install: t => {
                if (t.config.globalProperties.$showModal) return;
                let e;
                const n = () => {
                        if (!e) throw new Error("No ModalComponent is registered");
                        return e.onBackgroundClick()
                    },
                    r = (i, a, c) => {
                        if (!e) throw new Error("No ModalComponent is registered");
                        return e.show(i, a, c)
                    },
                    s = i => {
                        e = i
                    };
                t.component("Modal", Sle), t.config.globalProperties.$hideModal = n, t.config.globalProperties.$showModal = r, t.config.globalProperties.$registerModal = s
            }
        },
        Ole = {
            install: t => {
                const e = new Map;
                t.directive("pointerbox", {
                    mounted(n, r) {
                        const s = new T1(n, {
                            restrictToBox: r.modifiers.restrict,
                            isMultitouch: r.modifiers.multi
                        });
                        e.set(n, s)
                    },
                    unmounted(n) {
                        var r;
                        (r = e.get(n)) == null || r.destroy(), e.delete(n)
                    }
                }), t.directive("pointerbox-translate", {
                    mounted(n, r) {
                        n.setAttribute("data-pointerboxtranslateid", r.value.id ?? ""), n.setAttribute("data-pointerboxtranslatewidth", r.value.width ?? ""), n.setAttribute("data-pointerboxtranslateheight", r.value.height ?? "")
                    },
                    unmounted(n) {
                        n.removeAttribute("data-pointerboxtranslateid"), n.removeAttribute("data-pointerboxtranslatewidth"), n.removeAttribute("data-pointerboxtranslateheight")
                    }
                })
            }
        },
        Ale = mt({
            setup() {
                return {
                    announcment: mo(sh.textDescriptions.announcement)
                }
            },
            ecastKeys: {
                textDescriptions: "textDescriptions"
            },
            data() {
                return {
                    lines: []
                }
            },
            computed: {
                textDescriptions() {
                    return !this.$ecastValues || !this.$ecastValues.textDescriptions ? null : this.$ecastValues.textDescriptions
                }
            },
            watch: {
                announcment: function(e) {
                    this.lines.push({
                        id: Math.random(),
                        category: "announce",
                        text: e
                    })
                },
                "textDescriptions.latestDescriptions": function(e) {
                    !e || !e.length || e.forEach(n => {
                        n.id !== void 0 && this.lines.find(r => r.id === n.id) || this.lines.push(n)
                    })
                }
            }
        }),
        Cle = {
            class: "text-descriptions",
            role: "log",
            "aria-atomic": "false",
            "aria-relevant": "additions",
            "aria-live": "polite"
        };

    function kle(t, e, n, r, s, i) {
        return G(), H("div", Cle, [(G(!0), H(Tt, null, $n(t.lines, a => (G(), H("p", {
            key: a.id
        }, vt(a.text), 1))), 128))])
    }
    const Ile = ot(Ale, [
            ["render", kle]
        ]),
        Xw = Jr(""),
        Nle = {
            install: t => {
                if (t.config.globalProperties.$announce) return;
                t.provide(sh.textDescriptions.announcement, Lr(() => Xw.value));
                const e = n => {
                    Xw.value = n
                };
                t.component("TextDescriptions", Ile), t.config.globalProperties.$announce = e
            }
        },
        xle = {
            install: t => {
                let e = "",
                    n = "";
                const r = i => i instanceof Function ? i() : i,
                    s = i => {
                        const a = document.querySelector('meta[name="theme-color"]');
                        a && (document.body && (document.body.style.background = i), a.setAttribute("content", i), n = i)
                    };
                t.config.globalProperties.$setThemeColor = function(a) {
                    this.$options.themeColor = a, s(a)
                }, t.mixin({
                    mounted() {
                        if (!this.$options.themeColor) return;
                        const i = r(this.$options.themeColor);
                        s(i), this.$attrs.name === "game" && (e = i)
                    },
                    beforeDestroy() {
                        !this.$options.themeColor || r(this.$options.themeColor) !== n || s(e)
                    }
                })
            }
        },
        Ple = {
            install: t => {
                t.config.globalProperties.$vibrate = (e = [100, 100]) => {
                    var n;
                    if (!((n = window.navigator) != null && n.vibrate)) return !1;
                    try {
                        return window.navigator.vibrate(e), !0
                    } catch {
                        return !1
                    }
                }
            }
        };
    /*!
     * shared v9.2.2
     * (c) 2022 kazuya kawaguchi
     * Released under the MIT License.
     */
    const Z1 = typeof window < "u",
        Rle = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol",
        Uo = t => Rle ? Symbol(t) : t,
        Mle = (t, e, n) => Dle({
            l: t,
            k: e,
            s: n
        }),
        Dle = t => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"),
        In = t => typeof t == "number" && isFinite(t),
        $le = t => u0(t) === "[object Date]",
        Oo = t => u0(t) === "[object RegExp]",
        mm = t => et(t) && Object.keys(t).length === 0;

    function Lle(t, e) {
        typeof console < "u" && (console.warn("[intlify] " + t), e && console.warn(e.stack))
    }
    const Kn = Object.assign;

    function Jw(t) {
        return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
    }
    const Fle = Object.prototype.hasOwnProperty;

    function l0(t, e) {
        return Fle.call(t, e)
    }
    const Wt = Array.isArray,
        mn = t => typeof t == "function",
        xe = t => typeof t == "string",
        St = t => typeof t == "boolean",
        Ht = t => t !== null && typeof t == "object",
        CC = Object.prototype.toString,
        u0 = t => CC.call(t),
        et = t => u0(t) === "[object Object]",
        Ule = t => t == null ? "" : Wt(t) || et(t) && t.toString === CC ? JSON.stringify(t, null, 2) : String(t);
    /*!
     * message-compiler v9.2.2
     * (c) 2022 kazuya kawaguchi
     * Released under the MIT License.
     */
    const Ct = {
        EXPECTED_TOKEN: 1,
        INVALID_TOKEN_IN_PLACEHOLDER: 2,
        UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
        UNKNOWN_ESCAPE_SEQUENCE: 4,
        INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
        UNBALANCED_CLOSING_BRACE: 6,
        UNTERMINATED_CLOSING_BRACE: 7,
        EMPTY_PLACEHOLDER: 8,
        NOT_ALLOW_NEST_PLACEHOLDER: 9,
        INVALID_LINKED_FORMAT: 10,
        MUST_HAVE_MESSAGES_IN_PLURAL: 11,
        UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
        UNEXPECTED_EMPTY_LINKED_KEY: 13,
        UNEXPECTED_LEXICAL_ANALYSIS: 14,
        __EXTEND_POINT__: 15
    };

    function gm(t, e, n = {}) {
        const {
            domain: r,
            messages: s,
            args: i
        } = n, a = t, c = new SyntaxError(String(a));
        return c.code = t, e && (c.location = e), c.domain = r, c
    }

    function Ble(t) {
        throw t
    }

    function qle(t, e, n) {
        return {
            line: t,
            column: e,
            offset: n
        }
    }

    function X1(t, e, n) {
        const r = {
            start: t,
            end: e
        };
        return n != null && (r.source = n), r
    }
    const vi = " ",
        jle = "\r",
        ur = `
`,
        Vle = String.fromCharCode(8232),
        Gle = String.fromCharCode(8233);

    function Wle(t) {
        const e = t;
        let n = 0,
            r = 1,
            s = 1,
            i = 0;
        const a = $ => e[$] === jle && e[$ + 1] === ur,
            c = $ => e[$] === ur,
            u = $ => e[$] === Gle,
            h = $ => e[$] === Vle,
            d = $ => a($) || c($) || u($) || h($),
            p = () => n,
            m = () => r,
            _ = () => s,
            y = () => i,
            v = $ => a($) || u($) || h($) ? ur : e[$],
            w = () => v(n),
            b = () => v(n + i);

        function I() {
            return i = 0, d(n) && (r++, s = 0), a(n) && n++, n++, s++, e[n]
        }

        function F() {
            return a(n + i) && i++, i++, e[n + i]
        }

        function x() {
            n = 0, r = 1, s = 1, i = 0
        }

        function O($ = 0) {
            i = $
        }

        function M() {
            const $ = n + i;
            for (; $ !== n;) I();
            i = 0
        }
        return {
            index: p,
            line: m,
            column: _,
            peekOffset: y,
            charAt: v,
            currentChar: w,
            currentPeek: b,
            next: I,
            peek: F,
            reset: x,
            resetPeek: O,
            skipToPeek: M
        }
    }
    const no = void 0,
        Qw = "'",
        Hle = "tokenizer";

    function Kle(t, e = {}) {
        const n = e.location !== !1,
            r = Wle(t),
            s = () => r.index(),
            i = () => qle(r.line(), r.column(), r.index()),
            a = i(),
            c = s(),
            u = {
                currentType: 14,
                offset: c,
                startLoc: a,
                endLoc: a,
                lastType: 14,
                lastOffset: c,
                lastStartLoc: a,
                lastEndLoc: a,
                braceNest: 0,
                inLinked: !1,
                text: ""
            },
            h = () => u,
            {
                onError: d
            } = e;

        function p(T, S, N, ...V) {
            const te = h();
            if (S.column += N, S.offset += N, d) {
                const re = X1(te.startLoc, S),
                    ue = gm(T, re, {
                        domain: Hle,
                        args: V
                    });
                d(ue)
            }
        }

        function m(T, S, N) {
            T.endLoc = i(), T.currentType = S;
            const V = {
                type: S
            };
            return n && (V.loc = X1(T.startLoc, T.endLoc)), N != null && (V.value = N), V
        }
        const _ = T => m(T, 14);

        function y(T, S) {
            return T.currentChar() === S ? (T.next(), S) : (p(Ct.EXPECTED_TOKEN, i(), 0, S), "")
        }

        function v(T) {
            let S = "";
            for (; T.currentPeek() === vi || T.currentPeek() === ur;) S += T.currentPeek(), T.peek();
            return S
        }

        function w(T) {
            const S = v(T);
            return T.skipToPeek(), S
        }

        function b(T) {
            if (T === no) return !1;
            const S = T.charCodeAt(0);
            return S >= 97 && S <= 122 || S >= 65 && S <= 90 || S === 95
        }

        function I(T) {
            if (T === no) return !1;
            const S = T.charCodeAt(0);
            return S >= 48 && S <= 57
        }

        function F(T, S) {
            const {
                currentType: N
            } = S;
            if (N !== 2) return !1;
            v(T);
            const V = b(T.currentPeek());
            return T.resetPeek(), V
        }

        function x(T, S) {
            const {
                currentType: N
            } = S;
            if (N !== 2) return !1;
            v(T);
            const V = T.currentPeek() === "-" ? T.peek() : T.currentPeek(),
                te = I(V);
            return T.resetPeek(), te
        }

        function O(T, S) {
            const {
                currentType: N
            } = S;
            if (N !== 2) return !1;
            v(T);
            const V = T.currentPeek() === Qw;
            return T.resetPeek(), V
        }

        function M(T, S) {
            const {
                currentType: N
            } = S;
            if (N !== 8) return !1;
            v(T);
            const V = T.currentPeek() === ".";
            return T.resetPeek(), V
        }

        function $(T, S) {
            const {
                currentType: N
            } = S;
            if (N !== 9) return !1;
            v(T);
            const V = b(T.currentPeek());
            return T.resetPeek(), V
        }

        function j(T, S) {
            const {
                currentType: N
            } = S;
            if (!(N === 8 || N === 12)) return !1;
            v(T);
            const V = T.currentPeek() === ":";
            return T.resetPeek(), V
        }

        function ee(T, S) {
            const {
                currentType: N
            } = S;
            if (N !== 10) return !1;
            const V = () => {
                    const re = T.currentPeek();
                    return re === "{" ? b(T.peek()) : re === "@" || re === "%" || re === "|" || re === ":" || re === "." || re === vi || !re ? !1 : re === ur ? (T.peek(), V()) : b(re)
                },
                te = V();
            return T.resetPeek(), te
        }

        function se(T) {
            v(T);
            const S = T.currentPeek() === "|";
            return T.resetPeek(), S
        }

        function oe(T) {
            const S = v(T),
                N = T.currentPeek() === "%" && T.peek() === "{";
            return T.resetPeek(), {
                isModulo: N,
                hasSpace: S.length > 0
            }
        }

        function Z(T, S = !0) {
            const N = (te = !1, re = "", ue = !1) => {
                    const pe = T.currentPeek();
                    return pe === "{" ? re === "%" ? !1 : te : pe === "@" || !pe ? re === "%" ? !0 : te : pe === "%" ? (T.peek(), N(te, "%", !0)) : pe === "|" ? re === "%" || ue ? !0 : !(re === vi || re === ur) : pe === vi ? (T.peek(), N(!0, vi, ue)) : pe === ur ? (T.peek(), N(!0, ur, ue)) : !0
                },
                V = N();
            return S && T.resetPeek(), V
        }

        function de(T, S) {
            const N = T.currentChar();
            return N === no ? no : S(N) ? (T.next(), N) : null
        }

        function q(T) {
            return de(T, N => {
                const V = N.charCodeAt(0);
                return V >= 97 && V <= 122 || V >= 65 && V <= 90 || V >= 48 && V <= 57 || V === 95 || V === 36
            })
        }

        function ie(T) {
            return de(T, N => {
                const V = N.charCodeAt(0);
                return V >= 48 && V <= 57
            })
        }

        function ae(T) {
            return de(T, N => {
                const V = N.charCodeAt(0);
                return V >= 48 && V <= 57 || V >= 65 && V <= 70 || V >= 97 && V <= 102
            })
        }

        function he(T) {
            let S = "",
                N = "";
            for (; S = ie(T);) N += S;
            return N
        }

        function ve(T) {
            w(T);
            const S = T.currentChar();
            return S !== "%" && p(Ct.EXPECTED_TOKEN, i(), 0, S), T.next(), "%"
        }

        function be(T) {
            let S = "";
            for (;;) {
                const N = T.currentChar();
                if (N === "{" || N === "}" || N === "@" || N === "|" || !N) break;
                if (N === "%")
                    if (Z(T)) S += N, T.next();
                    else break;
                else if (N === vi || N === ur)
                    if (Z(T)) S += N, T.next();
                    else {
                        if (se(T)) break;
                        S += N, T.next()
                    }
                else S += N, T.next()
            }
            return S
        }

        function Ae(T) {
            w(T);
            let S = "",
                N = "";
            for (; S = q(T);) N += S;
            return T.currentChar() === no && p(Ct.UNTERMINATED_CLOSING_BRACE, i(), 0), N
        }

        function we(T) {
            w(T);
            let S = "";
            return T.currentChar() === "-" ? (T.next(), S += `-${he(T)}`) : S += he(T), T.currentChar() === no && p(Ct.UNTERMINATED_CLOSING_BRACE, i(), 0), S
        }

        function Me(T) {
            w(T), y(T, "'");
            let S = "",
                N = "";
            const V = re => re !== Qw && re !== ur;
            for (; S = de(T, V);) S === "\\" ? N += Nt(T) : N += S;
            const te = T.currentChar();
            return te === ur || te === no ? (p(Ct.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, i(), 0), te === ur && (T.next(), y(T, "'")), N) : (y(T, "'"), N)
        }

        function Nt(T) {
            const S = T.currentChar();
            switch (S) {
                case "\\":
                case "'":
                    return T.next(), `\\${S}`;
                case "u":
                    return jt(T, S, 4);
                case "U":
                    return jt(T, S, 6);
                default:
                    return p(Ct.UNKNOWN_ESCAPE_SEQUENCE, i(), 0, S), ""
            }
        }

        function jt(T, S, N) {
            y(T, S);
            let V = "";
            for (let te = 0; te < N; te++) {
                const re = ae(T);
                if (!re) {
                    p(Ct.INVALID_UNICODE_ESCAPE_SEQUENCE, i(), 0, `\\${S}${V}${T.currentChar()}`);
                    break
                }
                V += re
            }
            return `\\${S}${V}`
        }

        function Ue(T) {
            w(T);
            let S = "",
                N = "";
            const V = te => te !== "{" && te !== "}" && te !== vi && te !== ur;
            for (; S = de(T, V);) N += S;
            return N
        }

        function Ye(T) {
            let S = "",
                N = "";
            for (; S = q(T);) N += S;
            return N
        }

        function at(T) {
            const S = (N = !1, V) => {
                const te = T.currentChar();
                return te === "{" || te === "%" || te === "@" || te === "|" || !te || te === vi ? V : te === ur ? (V += te, T.next(), S(N, V)) : (V += te, T.next(), S(!0, V))
            };
            return S(!1, "")
        }

        function ke(T) {
            w(T);
            const S = y(T, "|");
            return w(T), S
        }

        function rt(T, S) {
            let N = null;
            switch (T.currentChar()) {
                case "{":
                    return S.braceNest >= 1 && p(Ct.NOT_ALLOW_NEST_PLACEHOLDER, i(), 0), T.next(), N = m(S, 2, "{"), w(T), S.braceNest++, N;
                case "}":
                    return S.braceNest > 0 && S.currentType === 2 && p(Ct.EMPTY_PLACEHOLDER, i(), 0), T.next(), N = m(S, 3, "}"), S.braceNest--, S.braceNest > 0 && w(T), S.inLinked && S.braceNest === 0 && (S.inLinked = !1), N;
                case "@":
                    return S.braceNest > 0 && p(Ct.UNTERMINATED_CLOSING_BRACE, i(), 0), N = Yt(T, S) || _(S), S.braceNest = 0, N;
                default:
                    let te = !0,
                        re = !0,
                        ue = !0;
                    if (se(T)) return S.braceNest > 0 && p(Ct.UNTERMINATED_CLOSING_BRACE, i(), 0), N = m(S, 1, ke(T)), S.braceNest = 0, S.inLinked = !1, N;
                    if (S.braceNest > 0 && (S.currentType === 5 || S.currentType === 6 || S.currentType === 7)) return p(Ct.UNTERMINATED_CLOSING_BRACE, i(), 0), S.braceNest = 0, zt(T, S);
                    if (te = F(T, S)) return N = m(S, 5, Ae(T)), w(T), N;
                    if (re = x(T, S)) return N = m(S, 6, we(T)), w(T), N;
                    if (ue = O(T, S)) return N = m(S, 7, Me(T)), w(T), N;
                    if (!te && !re && !ue) return N = m(S, 13, Ue(T)), p(Ct.INVALID_TOKEN_IN_PLACEHOLDER, i(), 0, N.value), w(T), N;
                    break
            }
            return N
        }

        function Yt(T, S) {
            const {
                currentType: N
            } = S;
            let V = null;
            const te = T.currentChar();
            switch ((N === 8 || N === 9 || N === 12 || N === 10) && (te === ur || te === vi) && p(Ct.INVALID_LINKED_FORMAT, i(), 0), te) {
                case "@":
                    return T.next(), V = m(S, 8, "@"), S.inLinked = !0, V;
                case ".":
                    return w(T), T.next(), m(S, 9, ".");
                case ":":
                    return w(T), T.next(), m(S, 10, ":");
                default:
                    return se(T) ? (V = m(S, 1, ke(T)), S.braceNest = 0, S.inLinked = !1, V) : M(T, S) || j(T, S) ? (w(T), Yt(T, S)) : $(T, S) ? (w(T), m(S, 12, Ye(T))) : ee(T, S) ? (w(T), te === "{" ? rt(T, S) || V : m(S, 11, at(T))) : (N === 8 && p(Ct.INVALID_LINKED_FORMAT, i(), 0), S.braceNest = 0, S.inLinked = !1, zt(T, S))
            }
        }

        function zt(T, S) {
            let N = {
                type: 14
            };
            if (S.braceNest > 0) return rt(T, S) || _(S);
            if (S.inLinked) return Yt(T, S) || _(S);
            switch (T.currentChar()) {
                case "{":
                    return rt(T, S) || _(S);
                case "}":
                    return p(Ct.UNBALANCED_CLOSING_BRACE, i(), 0), T.next(), m(S, 3, "}");
                case "@":
                    return Yt(T, S) || _(S);
                default:
                    if (se(T)) return N = m(S, 1, ke(T)), S.braceNest = 0, S.inLinked = !1, N;
                    const {
                        isModulo: te, hasSpace: re
                    } = oe(T);
                    if (te) return re ? m(S, 0, be(T)) : m(S, 4, ve(T));
                    if (Z(T)) return m(S, 0, be(T));
                    break
            }
            return N
        }

        function U() {
            const {
                currentType: T,
                offset: S,
                startLoc: N,
                endLoc: V
            } = u;
            return u.lastType = T, u.lastOffset = S, u.lastStartLoc = N, u.lastEndLoc = V, u.offset = s(), u.startLoc = i(), r.currentChar() === no ? m(u, 14) : zt(r, u)
        }
        return {
            nextToken: U,
            currentOffset: s,
            currentPosition: i,
            context: h
        }
    }
    const Yle = "parser",
        zle = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

    function Zle(t, e, n) {
        switch (t) {
            case "\\\\":
                return "\\";
            case "\\'":
                return "'";
            default: {
                const r = parseInt(e || n, 16);
                return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : ""
            }
        }
    }

    function Xle(t = {}) {
        const e = t.location !== !1,
            {
                onError: n
            } = t;

        function r(b, I, F, x, ...O) {
            const M = b.currentPosition();
            if (M.offset += x, M.column += x, n) {
                const $ = X1(F, M),
                    j = gm(I, $, {
                        domain: Yle,
                        args: O
                    });
                n(j)
            }
        }

        function s(b, I, F) {
            const x = {
                type: b,
                start: I,
                end: I
            };
            return e && (x.loc = {
                start: F,
                end: F
            }), x
        }

        function i(b, I, F, x) {
            b.end = I, x && (b.type = x), e && b.loc && (b.loc.end = F)
        }

        function a(b, I) {
            const F = b.context(),
                x = s(3, F.offset, F.startLoc);
            return x.value = I, i(x, b.currentOffset(), b.currentPosition()), x
        }

        function c(b, I) {
            const F = b.context(),
                {
                    lastOffset: x,
                    lastStartLoc: O
                } = F,
                M = s(5, x, O);
            return M.index = parseInt(I, 10), b.nextToken(), i(M, b.currentOffset(), b.currentPosition()), M
        }

        function u(b, I) {
            const F = b.context(),
                {
                    lastOffset: x,
                    lastStartLoc: O
                } = F,
                M = s(4, x, O);
            return M.key = I, b.nextToken(), i(M, b.currentOffset(), b.currentPosition()), M
        }

        function h(b, I) {
            const F = b.context(),
                {
                    lastOffset: x,
                    lastStartLoc: O
                } = F,
                M = s(9, x, O);
            return M.value = I.replace(zle, Zle), b.nextToken(), i(M, b.currentOffset(), b.currentPosition()), M
        }

        function d(b) {
            const I = b.nextToken(),
                F = b.context(),
                {
                    lastOffset: x,
                    lastStartLoc: O
                } = F,
                M = s(8, x, O);
            return I.type !== 12 ? (r(b, Ct.UNEXPECTED_EMPTY_LINKED_MODIFIER, F.lastStartLoc, 0), M.value = "", i(M, x, O), {
                nextConsumeToken: I,
                node: M
            }) : (I.value == null && r(b, Ct.UNEXPECTED_LEXICAL_ANALYSIS, F.lastStartLoc, 0, Gs(I)), M.value = I.value || "", i(M, b.currentOffset(), b.currentPosition()), {
                node: M
            })
        }

        function p(b, I) {
            const F = b.context(),
                x = s(7, F.offset, F.startLoc);
            return x.value = I, i(x, b.currentOffset(), b.currentPosition()), x
        }

        function m(b) {
            const I = b.context(),
                F = s(6, I.offset, I.startLoc);
            let x = b.nextToken();
            if (x.type === 9) {
                const O = d(b);
                F.modifier = O.node, x = O.nextConsumeToken || b.nextToken()
            }
            switch (x.type !== 10 && r(b, Ct.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Gs(x)), x = b.nextToken(), x.type === 2 && (x = b.nextToken()), x.type) {
                case 11:
                    x.value == null && r(b, Ct.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Gs(x)), F.key = p(b, x.value || "");
                    break;
                case 5:
                    x.value == null && r(b, Ct.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Gs(x)), F.key = u(b, x.value || "");
                    break;
                case 6:
                    x.value == null && r(b, Ct.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Gs(x)), F.key = c(b, x.value || "");
                    break;
                case 7:
                    x.value == null && r(b, Ct.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Gs(x)), F.key = h(b, x.value || "");
                    break;
                default:
                    r(b, Ct.UNEXPECTED_EMPTY_LINKED_KEY, I.lastStartLoc, 0);
                    const O = b.context(),
                        M = s(7, O.offset, O.startLoc);
                    return M.value = "", i(M, O.offset, O.startLoc), F.key = M, i(F, O.offset, O.startLoc), {
                        nextConsumeToken: x,
                        node: F
                    }
            }
            return i(F, b.currentOffset(), b.currentPosition()), {
                node: F
            }
        }

        function _(b) {
            const I = b.context(),
                F = I.currentType === 1 ? b.currentOffset() : I.offset,
                x = I.currentType === 1 ? I.endLoc : I.startLoc,
                O = s(2, F, x);
            O.items = [];
            let M = null;
            do {
                const ee = M || b.nextToken();
                switch (M = null, ee.type) {
                    case 0:
                        ee.value == null && r(b, Ct.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Gs(ee)), O.items.push(a(b, ee.value || ""));
                        break;
                    case 6:
                        ee.value == null && r(b, Ct.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Gs(ee)), O.items.push(c(b, ee.value || ""));
                        break;
                    case 5:
                        ee.value == null && r(b, Ct.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Gs(ee)), O.items.push(u(b, ee.value || ""));
                        break;
                    case 7:
                        ee.value == null && r(b, Ct.UNEXPECTED_LEXICAL_ANALYSIS, I.lastStartLoc, 0, Gs(ee)), O.items.push(h(b, ee.value || ""));
                        break;
                    case 8:
                        const se = m(b);
                        O.items.push(se.node), M = se.nextConsumeToken || null;
                        break
                }
            } while (I.currentType !== 14 && I.currentType !== 1);
            const $ = I.currentType === 1 ? I.lastOffset : b.currentOffset(),
                j = I.currentType === 1 ? I.lastEndLoc : b.currentPosition();
            return i(O, $, j), O
        }

        function y(b, I, F, x) {
            const O = b.context();
            let M = x.items.length === 0;
            const $ = s(1, I, F);
            $.cases = [], $.cases.push(x);
            do {
                const j = _(b);
                M || (M = j.items.length === 0), $.cases.push(j)
            } while (O.currentType !== 14);
            return M && r(b, Ct.MUST_HAVE_MESSAGES_IN_PLURAL, F, 0), i($, b.currentOffset(), b.currentPosition()), $
        }

        function v(b) {
            const I = b.context(),
                {
                    offset: F,
                    startLoc: x
                } = I,
                O = _(b);
            return I.currentType === 14 ? O : y(b, F, x, O)
        }

        function w(b) {
            const I = Kle(b, Kn({}, t)),
                F = I.context(),
                x = s(0, F.offset, F.startLoc);
            return e && x.loc && (x.loc.source = b), x.body = v(I), F.currentType !== 14 && r(I, Ct.UNEXPECTED_LEXICAL_ANALYSIS, F.lastStartLoc, 0, b[F.offset] || ""), i(x, I.currentOffset(), I.currentPosition()), x
        }
        return {
            parse: w
        }
    }

    function Gs(t) {
        if (t.type === 14) return "EOF";
        const e = (t.value || "").replace(/\r?\n/gu, "\\n");
        return e.length > 10 ? e.slice(0, 9) + "" : e
    }

    function Jle(t, e = {}) {
        const n = {
            ast: t,
            helpers: new Set
        };
        return {
            context: () => n,
            helper: i => (n.helpers.add(i), i)
        }
    }

    function e3(t, e) {
        for (let n = 0; n < t.length; n++) h0(t[n], e)
    }

    function h0(t, e) {
        switch (t.type) {
            case 1:
                e3(t.cases, e), e.helper("plural");
                break;
            case 2:
                e3(t.items, e);
                break;
            case 6:
                h0(t.key, e), e.helper("linked"), e.helper("type");
                break;
            case 5:
                e.helper("interpolate"), e.helper("list");
                break;
            case 4:
                e.helper("interpolate"), e.helper("named");
                break
        }
    }

    function Qle(t, e = {}) {
        const n = Jle(t);
        n.helper("normalize"), t.body && h0(t.body, n);
        const r = n.context();
        t.helpers = Array.from(r.helpers)
    }

    function eue(t, e) {
        const {
            sourceMap: n,
            filename: r,
            breakLineCode: s,
            needIndent: i
        } = e, a = {
            source: t.loc.source,
            filename: r,
            code: "",
            column: 1,
            line: 1,
            offset: 0,
            map: void 0,
            breakLineCode: s,
            needIndent: i,
            indentLevel: 0
        }, c = () => a;

        function u(v, w) {
            a.code += v
        }

        function h(v, w = !0) {
            const b = w ? s : "";
            u(i ? b + "  ".repeat(v) : b)
        }

        function d(v = !0) {
            const w = ++a.indentLevel;
            v && h(w)
        }

        function p(v = !0) {
            const w = --a.indentLevel;
            v && h(w)
        }

        function m() {
            h(a.indentLevel)
        }
        return {
            context: c,
            push: u,
            indent: d,
            deindent: p,
            newline: m,
            helper: v => `_${v}`,
            needIndent: () => a.needIndent
        }
    }

    function tue(t, e) {
        const {
            helper: n
        } = t;
        t.push(`${n("linked")}(`), Uc(t, e.key), e.modifier ? (t.push(", "), Uc(t, e.modifier), t.push(", _type")) : t.push(", undefined, _type"), t.push(")")
    }

    function nue(t, e) {
        const {
            helper: n,
            needIndent: r
        } = t;
        t.push(`${n("normalize")}([`), t.indent(r());
        const s = e.items.length;
        for (let i = 0; i < s && (Uc(t, e.items[i]), i !== s - 1); i++) t.push(", ");
        t.deindent(r()), t.push("])")
    }

    function rue(t, e) {
        const {
            helper: n,
            needIndent: r
        } = t;
        if (e.cases.length > 1) {
            t.push(`${n("plural")}([`), t.indent(r());
            const s = e.cases.length;
            for (let i = 0; i < s && (Uc(t, e.cases[i]), i !== s - 1); i++) t.push(", ");
            t.deindent(r()), t.push("])")
        }
    }

    function sue(t, e) {
        e.body ? Uc(t, e.body) : t.push("null")
    }

    function Uc(t, e) {
        const {
            helper: n
        } = t;
        switch (e.type) {
            case 0:
                sue(t, e);
                break;
            case 1:
                rue(t, e);
                break;
            case 2:
                nue(t, e);
                break;
            case 6:
                tue(t, e);
                break;
            case 8:
                t.push(JSON.stringify(e.value), e);
                break;
            case 7:
                t.push(JSON.stringify(e.value), e);
                break;
            case 5:
                t.push(`${n("interpolate")}(${n("list")}(${e.index}))`, e);
                break;
            case 4:
                t.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(e.key)}))`, e);
                break;
            case 9:
                t.push(JSON.stringify(e.value), e);
                break;
            case 3:
                t.push(JSON.stringify(e.value), e);
                break
        }
    }
    const iue = (t, e = {}) => {
        const n = xe(e.mode) ? e.mode : "normal",
            r = xe(e.filename) ? e.filename : "message.intl",
            s = !!e.sourceMap,
            i = e.breakLineCode != null ? e.breakLineCode : n === "arrow" ? ";" : `
`,
            a = e.needIndent ? e.needIndent : n !== "arrow",
            c = t.helpers || [],
            u = eue(t, {
                mode: n,
                filename: r,
                sourceMap: s,
                breakLineCode: i,
                needIndent: a
            });
        u.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), u.indent(a), c.length > 0 && (u.push(`const { ${c.map(p=>`${p}: _${p}`).join(", ")} } = ctx`), u.newline()), u.push("return "), Uc(u, t), u.deindent(a), u.push("}");
        const {
            code: h,
            map: d
        } = u.context();
        return {
            ast: t,
            code: h,
            map: d ? d.toJSON() : void 0
        }
    };

    function oue(t, e = {}) {
        const n = Kn({}, e),
            s = Xle(n).parse(t);
        return Qle(s, n), iue(s, n)
    }
    /*!
     * core-base v9.2.2
     * (c) 2022 kazuya kawaguchi
     * Released under the MIT License.
     */
    const Bo = [];
    Bo[0] = {
        w: [0],
        i: [3, 0],
        "[": [4],
        o: [7]
    };
    Bo[1] = {
        w: [1],
        ".": [2],
        "[": [4],
        o: [7]
    };
    Bo[2] = {
        w: [2],
        i: [3, 0],
        0: [3, 0]
    };
    Bo[3] = {
        i: [3, 0],
        0: [3, 0],
        w: [1, 1],
        ".": [2, 1],
        "[": [4, 1],
        o: [7, 1]
    };
    Bo[4] = {
        "'": [5, 0],
        '"': [6, 0],
        "[": [4, 2],
        "]": [1, 3],
        o: 8,
        l: [4, 0]
    };
    Bo[5] = {
        "'": [4, 0],
        o: 8,
        l: [5, 0]
    };
    Bo[6] = {
        '"': [4, 0],
        o: 8,
        l: [6, 0]
    };
    const aue = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

    function cue(t) {
        return aue.test(t)
    }

    function lue(t) {
        const e = t.charCodeAt(0),
            n = t.charCodeAt(t.length - 1);
        return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t
    }

    function uue(t) {
        if (t == null) return "o";
        switch (t.charCodeAt(0)) {
            case 91:
            case 93:
            case 46:
            case 34:
            case 39:
                return t;
            case 95:
            case 36:
            case 45:
                return "i";
            case 9:
            case 10:
            case 13:
            case 160:
            case 65279:
            case 8232:
            case 8233:
                return "w"
        }
        return "i"
    }

    function hue(t) {
        const e = t.trim();
        return t.charAt(0) === "0" && isNaN(parseInt(t)) ? !1 : cue(e) ? lue(e) : "*" + e
    }

    function fue(t) {
        const e = [];
        let n = -1,
            r = 0,
            s = 0,
            i, a, c, u, h, d, p;
        const m = [];
        m[0] = () => {
            a === void 0 ? a = c : a += c
        }, m[1] = () => {
            a !== void 0 && (e.push(a), a = void 0)
        }, m[2] = () => {
            m[0](), s++
        }, m[3] = () => {
            if (s > 0) s--, r = 4, m[0]();
            else {
                if (s = 0, a === void 0 || (a = hue(a), a === !1)) return !1;
                m[1]()
            }
        };

        function _() {
            const y = t[n + 1];
            if (r === 5 && y === "'" || r === 6 && y === '"') return n++, c = "\\" + y, m[0](), !0
        }
        for (; r !== null;)
            if (n++, i = t[n], !(i === "\\" && _())) {
                if (u = uue(i), p = Bo[r], h = p[u] || p.l || 8, h === 8 || (r = h[0], h[1] !== void 0 && (d = m[h[1]], d && (c = i, d() === !1)))) return;
                if (r === 7) return e
            }
    }
    const t3 = new Map;

    function due(t, e) {
        return Ht(t) ? t[e] : null
    }

    function pue(t, e) {
        if (!Ht(t)) return null;
        let n = t3.get(e);
        if (n || (n = fue(e), n && t3.set(e, n)), !n) return null;
        const r = n.length;
        let s = t,
            i = 0;
        for (; i < r;) {
            const a = s[n[i]];
            if (a === void 0) return null;
            s = a, i++
        }
        return s
    }
    const mue = t => t,
        gue = t => "",
        _ue = "text",
        yue = t => t.length === 0 ? "" : t.join(""),
        vue = Ule;

    function n3(t, e) {
        return t = Math.abs(t), e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0
    }

    function bue(t) {
        const e = In(t.pluralIndex) ? t.pluralIndex : -1;
        return t.named && (In(t.named.count) || In(t.named.n)) ? In(t.named.count) ? t.named.count : In(t.named.n) ? t.named.n : e : e
    }

    function Eue(t, e) {
        e.count || (e.count = t), e.n || (e.n = t)
    }

    function Tue(t = {}) {
        const e = t.locale,
            n = bue(t),
            r = Ht(t.pluralRules) && xe(e) && mn(t.pluralRules[e]) ? t.pluralRules[e] : n3,
            s = Ht(t.pluralRules) && xe(e) && mn(t.pluralRules[e]) ? n3 : void 0,
            i = b => b[r(n, b.length, s)],
            a = t.list || [],
            c = b => a[b],
            u = t.named || {};
        In(t.pluralIndex) && Eue(n, u);
        const h = b => u[b];

        function d(b) {
            const I = mn(t.messages) ? t.messages(b) : Ht(t.messages) ? t.messages[b] : !1;
            return I || (t.parent ? t.parent.message(b) : gue)
        }
        const p = b => t.modifiers ? t.modifiers[b] : mue,
            m = et(t.processor) && mn(t.processor.normalize) ? t.processor.normalize : yue,
            _ = et(t.processor) && mn(t.processor.interpolate) ? t.processor.interpolate : vue,
            y = et(t.processor) && xe(t.processor.type) ? t.processor.type : _ue,
            w = {
                list: c,
                named: h,
                plural: i,
                linked: (b, ...I) => {
                    const [F, x] = I;
                    let O = "text",
                        M = "";
                    I.length === 1 ? Ht(F) ? (M = F.modifier || M, O = F.type || O) : xe(F) && (M = F || M) : I.length === 2 && (xe(F) && (M = F || M), xe(x) && (O = x || O));
                    let $ = d(b)(w);
                    return O === "vnode" && Wt($) && M && ($ = $[0]), M ? p(M)($, O) : $
                },
                message: d,
                type: y,
                interpolate: _,
                normalize: m
            };
        return w
    }

    function Sue(t, e, n) {
        return [...new Set([n, ...Wt(e) ? e : Ht(e) ? Object.keys(e) : xe(e) ? [e] : [n]])]
    }

    function kC(t, e, n) {
        const r = xe(n) ? n : ah,
            s = t;
        s.__localeChainCache || (s.__localeChainCache = new Map);
        let i = s.__localeChainCache.get(r);
        if (!i) {
            i = [];
            let a = [n];
            for (; Wt(a);) a = r3(i, a, e);
            const c = Wt(e) || !et(e) ? e : e.default ? e.default : null;
            a = xe(c) ? [c] : c, Wt(a) && r3(i, a, !1), s.__localeChainCache.set(r, i)
        }
        return i
    }

    function r3(t, e, n) {
        let r = !0;
        for (let s = 0; s < e.length && St(r); s++) {
            const i = e[s];
            xe(i) && (r = wue(t, e[s], n))
        }
        return r
    }

    function wue(t, e, n) {
        let r;
        const s = e.split("-");
        do {
            const i = s.join("-");
            r = Oue(t, i, n), s.splice(-1, 1)
        } while (s.length && r === !0);
        return r
    }

    function Oue(t, e, n) {
        let r = !1;
        if (!t.includes(e) && (r = !0, e)) {
            r = e[e.length - 1] !== "!";
            const s = e.replace(/!/g, "");
            t.push(s), (Wt(n) || et(n)) && n[s] && (r = n[s])
        }
        return r
    }
    const Aue = "9.2.2",
        _m = -1,
        ah = "en-US",
        s3 = "",
        i3 = t => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;

    function Cue() {
        return {
            upper: (t, e) => e === "text" && xe(t) ? t.toUpperCase() : e === "vnode" && Ht(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
            lower: (t, e) => e === "text" && xe(t) ? t.toLowerCase() : e === "vnode" && Ht(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
            capitalize: (t, e) => e === "text" && xe(t) ? i3(t) : e === "vnode" && Ht(t) && "__v_isVNode" in t ? i3(t.children) : t
        }
    }
    let IC;

    function kue(t) {
        IC = t
    }
    let NC;

    function Iue(t) {
        NC = t
    }
    let xC;

    function Nue(t) {
        xC = t
    }
    let o3 = 0;

    function xue(t = {}) {
        const e = xe(t.version) ? t.version : Aue,
            n = xe(t.locale) ? t.locale : ah,
            r = Wt(t.fallbackLocale) || et(t.fallbackLocale) || xe(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : n,
            s = et(t.messages) ? t.messages : {
                [n]: {}
            },
            i = et(t.datetimeFormats) ? t.datetimeFormats : {
                [n]: {}
            },
            a = et(t.numberFormats) ? t.numberFormats : {
                [n]: {}
            },
            c = Kn({}, t.modifiers || {}, Cue()),
            u = t.pluralRules || {},
            h = mn(t.missing) ? t.missing : null,
            d = St(t.missingWarn) || Oo(t.missingWarn) ? t.missingWarn : !0,
            p = St(t.fallbackWarn) || Oo(t.fallbackWarn) ? t.fallbackWarn : !0,
            m = !!t.fallbackFormat,
            _ = !!t.unresolving,
            y = mn(t.postTranslation) ? t.postTranslation : null,
            v = et(t.processor) ? t.processor : null,
            w = St(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
            b = !!t.escapeParameter,
            I = mn(t.messageCompiler) ? t.messageCompiler : IC,
            F = mn(t.messageResolver) ? t.messageResolver : NC || due,
            x = mn(t.localeFallbacker) ? t.localeFallbacker : xC || Sue,
            O = Ht(t.fallbackContext) ? t.fallbackContext : void 0,
            M = mn(t.onWarn) ? t.onWarn : Lle,
            $ = t,
            j = Ht($.__datetimeFormatters) ? $.__datetimeFormatters : new Map,
            ee = Ht($.__numberFormatters) ? $.__numberFormatters : new Map,
            se = Ht($.__meta) ? $.__meta : {};
        o3++;
        const oe = {
            version: e,
            cid: o3,
            locale: n,
            fallbackLocale: r,
            messages: s,
            modifiers: c,
            pluralRules: u,
            missing: h,
            missingWarn: d,
            fallbackWarn: p,
            fallbackFormat: m,
            unresolving: _,
            postTranslation: y,
            processor: v,
            warnHtmlMessage: w,
            escapeParameter: b,
            messageCompiler: I,
            messageResolver: F,
            localeFallbacker: x,
            fallbackContext: O,
            onWarn: M,
            __meta: se
        };
        return oe.datetimeFormats = i, oe.numberFormats = a, oe.__datetimeFormatters = j, oe.__numberFormatters = ee, oe
    }

    function f0(t, e, n, r, s) {
        const {
            missing: i,
            onWarn: a
        } = t;
        if (i !== null) {
            const c = i(t, n, e, s);
            return xe(c) ? c : e
        } else return e
    }

    function ql(t, e, n) {
        const r = t;
        r.__localeChainCache = new Map, t.localeFallbacker(t, n, e)
    }
    const Pue = t => t;
    let a3 = Object.create(null);

    function Rue(t, e = {}) {
        {
            const r = (e.onCacheKey || Pue)(t),
                s = a3[r];
            if (s) return s;
            let i = !1;
            const a = e.onError || Ble;
            e.onError = h => {
                i = !0, a(h)
            };
            const {
                code: c
            } = oue(t, e), u = new Function(`return ${c}`)();
            return i ? u : a3[r] = u
        }
    }
    let PC = Ct.__EXTEND_POINT__;
    const W_ = () => ++PC,
        lc = {
            INVALID_ARGUMENT: PC,
            INVALID_DATE_ARGUMENT: W_(),
            INVALID_ISO_DATE_ARGUMENT: W_(),
            __EXTEND_POINT__: W_()
        };

    function uc(t) {
        return gm(t, null, void 0)
    }
    const c3 = () => "",
        ya = t => mn(t);

    function l3(t, ...e) {
        const {
            fallbackFormat: n,
            postTranslation: r,
            unresolving: s,
            messageCompiler: i,
            fallbackLocale: a,
            messages: c
        } = t, [u, h] = J1(...e), d = St(h.missingWarn) ? h.missingWarn : t.missingWarn, p = St(h.fallbackWarn) ? h.fallbackWarn : t.fallbackWarn, m = St(h.escapeParameter) ? h.escapeParameter : t.escapeParameter, _ = !!h.resolvedMessage, y = xe(h.default) || St(h.default) ? St(h.default) ? i ? u : () => u : h.default : n ? i ? u : () => u : "", v = n || y !== "", w = xe(h.locale) ? h.locale : t.locale;
        m && Mue(h);
        let [b, I, F] = _ ? [u, w, c[w] || {}] : RC(t, u, w, a, p, d), x = b, O = u;
        if (!_ && !(xe(x) || ya(x)) && v && (x = y, O = x), !_ && (!(xe(x) || ya(x)) || !xe(I))) return s ? _m : u;
        let M = !1;
        const $ = () => {
                M = !0
            },
            j = ya(x) ? x : MC(t, u, I, x, O, $);
        if (M) return x;
        const ee = Lue(t, I, F, h),
            se = Tue(ee),
            oe = Due(t, j, se);
        return r ? r(oe, u) : oe
    }

    function Mue(t) {
        Wt(t.list) ? t.list = t.list.map(e => xe(e) ? Jw(e) : e) : Ht(t.named) && Object.keys(t.named).forEach(e => {
            xe(t.named[e]) && (t.named[e] = Jw(t.named[e]))
        })
    }

    function RC(t, e, n, r, s, i) {
        const {
            messages: a,
            onWarn: c,
            messageResolver: u,
            localeFallbacker: h
        } = t, d = h(t, r, n);
        let p = {},
            m, _ = null;
        const y = "translate";
        for (let v = 0; v < d.length && (m = d[v], p = a[m] || {}, (_ = u(p, e)) === null && (_ = p[e]), !(xe(_) || mn(_))); v++) {
            const w = f0(t, e, m, i, y);
            w !== e && (_ = w)
        }
        return [_, m, p]
    }

    function MC(t, e, n, r, s, i) {
        const {
            messageCompiler: a,
            warnHtmlMessage: c
        } = t;
        if (ya(r)) {
            const h = r;
            return h.locale = h.locale || n, h.key = h.key || e, h
        }
        if (a == null) {
            const h = () => r;
            return h.locale = n, h.key = e, h
        }
        const u = a(r, $ue(t, n, s, r, c, i));
        return u.locale = n, u.key = e, u.source = r, u
    }

    function Due(t, e, n) {
        return e(n)
    }

    function J1(...t) {
        const [e, n, r] = t, s = {};
        if (!xe(e) && !In(e) && !ya(e)) throw uc(lc.INVALID_ARGUMENT);
        const i = In(e) ? String(e) : (ya(e), e);
        return In(n) ? s.plural = n : xe(n) ? s.default = n : et(n) && !mm(n) ? s.named = n : Wt(n) && (s.list = n), In(r) ? s.plural = r : xe(r) ? s.default = r : et(r) && Kn(s, r), [i, s]
    }

    function $ue(t, e, n, r, s, i) {
        return {
            warnHtmlMessage: s,
            onError: a => {
                throw i && i(a), a
            },
            onCacheKey: a => Mle(e, n, a)
        }
    }

    function Lue(t, e, n, r) {
        const {
            modifiers: s,
            pluralRules: i,
            messageResolver: a,
            fallbackLocale: c,
            fallbackWarn: u,
            missingWarn: h,
            fallbackContext: d
        } = t, m = {
            locale: e,
            modifiers: s,
            pluralRules: i,
            messages: _ => {
                let y = a(n, _);
                if (y == null && d) {
                    const [, , v] = RC(d, _, e, c, u, h);
                    y = a(v, _)
                }
                if (xe(y)) {
                    let v = !1;
                    const b = MC(t, _, e, y, _, () => {
                        v = !0
                    });
                    return v ? c3 : b
                } else return ya(y) ? y : c3
            }
        };
        return t.processor && (m.processor = t.processor), r.list && (m.list = r.list), r.named && (m.named = r.named), In(r.plural) && (m.pluralIndex = r.plural), m
    }

    function u3(t, ...e) {
        const {
            datetimeFormats: n,
            unresolving: r,
            fallbackLocale: s,
            onWarn: i,
            localeFallbacker: a
        } = t, {
            __datetimeFormatters: c
        } = t, [u, h, d, p] = Q1(...e), m = St(d.missingWarn) ? d.missingWarn : t.missingWarn;
        St(d.fallbackWarn) ? d.fallbackWarn : t.fallbackWarn;
        const _ = !!d.part,
            y = xe(d.locale) ? d.locale : t.locale,
            v = a(t, s, y);
        if (!xe(u) || u === "") return new Intl.DateTimeFormat(y, p).format(h);
        let w = {},
            b, I = null;
        const F = "datetime format";
        for (let M = 0; M < v.length && (b = v[M], w = n[b] || {}, I = w[u], !et(I)); M++) f0(t, u, b, m, F);
        if (!et(I) || !xe(b)) return r ? _m : u;
        let x = `${b}__${u}`;
        mm(p) || (x = `${x}__${JSON.stringify(p)}`);
        let O = c.get(x);
        return O || (O = new Intl.DateTimeFormat(b, Kn({}, I, p)), c.set(x, O)), _ ? O.formatToParts(h) : O.format(h)
    }
    const DC = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];

    function Q1(...t) {
        const [e, n, r, s] = t, i = {};
        let a = {},
            c;
        if (xe(e)) {
            const u = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
            if (!u) throw uc(lc.INVALID_ISO_DATE_ARGUMENT);
            const h = u[3] ? u[3].trim().startsWith("T") ? `${u[1].trim()}${u[3].trim()}` : `${u[1].trim()}T${u[3].trim()}` : u[1].trim();
            c = new Date(h);
            try {
                c.toISOString()
            } catch {
                throw uc(lc.INVALID_ISO_DATE_ARGUMENT)
            }
        } else if ($le(e)) {
            if (isNaN(e.getTime())) throw uc(lc.INVALID_DATE_ARGUMENT);
            c = e
        } else if (In(e)) c = e;
        else throw uc(lc.INVALID_ARGUMENT);
        return xe(n) ? i.key = n : et(n) && Object.keys(n).forEach(u => {
            DC.includes(u) ? a[u] = n[u] : i[u] = n[u]
        }), xe(r) ? i.locale = r : et(r) && (a = r), et(s) && (a = s), [i.key || "", c, i, a]
    }

    function h3(t, e, n) {
        const r = t;
        for (const s in n) {
            const i = `${e}__${s}`;
            r.__datetimeFormatters.has(i) && r.__datetimeFormatters.delete(i)
        }
    }

    function f3(t, ...e) {
        const {
            numberFormats: n,
            unresolving: r,
            fallbackLocale: s,
            onWarn: i,
            localeFallbacker: a
        } = t, {
            __numberFormatters: c
        } = t, [u, h, d, p] = ey(...e), m = St(d.missingWarn) ? d.missingWarn : t.missingWarn;
        St(d.fallbackWarn) ? d.fallbackWarn : t.fallbackWarn;
        const _ = !!d.part,
            y = xe(d.locale) ? d.locale : t.locale,
            v = a(t, s, y);
        if (!xe(u) || u === "") return new Intl.NumberFormat(y, p).format(h);
        let w = {},
            b, I = null;
        const F = "number format";
        for (let M = 0; M < v.length && (b = v[M], w = n[b] || {}, I = w[u], !et(I)); M++) f0(t, u, b, m, F);
        if (!et(I) || !xe(b)) return r ? _m : u;
        let x = `${b}__${u}`;
        mm(p) || (x = `${x}__${JSON.stringify(p)}`);
        let O = c.get(x);
        return O || (O = new Intl.NumberFormat(b, Kn({}, I, p)), c.set(x, O)), _ ? O.formatToParts(h) : O.format(h)
    }
    const $C = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];

    function ey(...t) {
        const [e, n, r, s] = t, i = {};
        let a = {};
        if (!In(e)) throw uc(lc.INVALID_ARGUMENT);
        const c = e;
        return xe(n) ? i.key = n : et(n) && Object.keys(n).forEach(u => {
            $C.includes(u) ? a[u] = n[u] : i[u] = n[u]
        }), xe(r) ? i.locale = r : et(r) && (a = r), et(s) && (a = s), [i.key || "", c, i, a]
    }

    function d3(t, e, n) {
        const r = t;
        for (const s in n) {
            const i = `${e}__${s}`;
            r.__numberFormatters.has(i) && r.__numberFormatters.delete(i)
        }
    }
    /*!
     * vue-i18n v9.2.2
     * (c) 2022 kazuya kawaguchi
     * Released under the MIT License.
     */
    const Fue = "9.2.2";
    let LC = Ct.__EXTEND_POINT__;
    const br = () => ++LC,
        Sn = {
            UNEXPECTED_RETURN_TYPE: LC,
            INVALID_ARGUMENT: br(),
            MUST_BE_CALL_SETUP_TOP: br(),
            NOT_INSLALLED: br(),
            NOT_AVAILABLE_IN_LEGACY_MODE: br(),
            REQUIRED_VALUE: br(),
            INVALID_VALUE: br(),
            CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: br(),
            NOT_INSLALLED_WITH_PROVIDE: br(),
            UNEXPECTED_ERROR: br(),
            NOT_COMPATIBLE_LEGACY_VUE_I18N: br(),
            BRIDGE_SUPPORT_VUE_2_ONLY: br(),
            MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: br(),
            NOT_AVAILABLE_COMPOSITION_IN_LEGACY: br(),
            __EXTEND_POINT__: br()
        };

    function xn(t, ...e) {
        return gm(t, null, void 0)
    }
    const ty = Uo("__transrateVNode"),
        ny = Uo("__datetimeParts"),
        ry = Uo("__numberParts"),
        FC = Uo("__setPluralRules");
    Uo("__intlifyMeta");
    const UC = Uo("__injectWithOption");

    function sy(t) {
        if (!Ht(t)) return t;
        for (const e in t)
            if (l0(t, e))
                if (!e.includes(".")) Ht(t[e]) && sy(t[e]);
                else {
                    const n = e.split("."),
                        r = n.length - 1;
                    let s = t;
                    for (let i = 0; i < r; i++) n[i] in s || (s[n[i]] = {}), s = s[n[i]];
                    s[n[r]] = t[e], delete t[e], Ht(s[n[r]]) && sy(s[n[r]])
                } return t
    }

    function ym(t, e) {
        const {
            messages: n,
            __i18n: r,
            messageResolver: s,
            flatJson: i
        } = e, a = et(n) ? n : Wt(r) ? {} : {
            [t]: {}
        };
        if (Wt(r) && r.forEach(c => {
                if ("locale" in c && "resource" in c) {
                    const {
                        locale: u,
                        resource: h
                    } = c;
                    u ? (a[u] = a[u] || {}, su(h, a[u])) : su(h, a)
                } else xe(c) && su(JSON.parse(c), a)
            }), s == null && i)
            for (const c in a) l0(a, c) && sy(a[c]);
        return a
    }
    const Lf = t => !Ht(t) || Wt(t);

    function su(t, e) {
        if (Lf(t) || Lf(e)) throw xn(Sn.INVALID_VALUE);
        for (const n in t) l0(t, n) && (Lf(t[n]) || Lf(e[n]) ? e[n] = t[n] : su(t[n], e[n]))
    }

    function Uue(t) {
        return t.type
    }

    function BC(t, e, n) {
        let r = Ht(e.messages) ? e.messages : {};
        "__i18nGlobal" in n && (r = ym(t.locale.value, {
            messages: r,
            __i18n: n.__i18nGlobal
        }));
        const s = Object.keys(r);
        s.length && s.forEach(i => {
            t.mergeLocaleMessage(i, r[i])
        }); {
            if (Ht(e.datetimeFormats)) {
                const i = Object.keys(e.datetimeFormats);
                i.length && i.forEach(a => {
                    t.mergeDateTimeFormat(a, e.datetimeFormats[a])
                })
            }
            if (Ht(e.numberFormats)) {
                const i = Object.keys(e.numberFormats);
                i.length && i.forEach(a => {
                    t.mergeNumberFormat(a, e.numberFormats[a])
                })
            }
        }
    }

    function p3(t) {
        return Je(Hu, null, t, 0)
    }
    let m3 = 0;

    function g3(t) {
        return (e, n, r, s) => t(n, r, pu() || void 0, s)
    }

    function d0(t = {}, e) {
        const {
            __root: n
        } = t, r = n === void 0;
        let s = St(t.inheritLocale) ? t.inheritLocale : !0;
        const i = Jr(n && s ? n.locale.value : xe(t.locale) ? t.locale : ah),
            a = Jr(n && s ? n.fallbackLocale.value : xe(t.fallbackLocale) || Wt(t.fallbackLocale) || et(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : i.value),
            c = Jr(ym(i.value, t)),
            u = Jr(et(t.datetimeFormats) ? t.datetimeFormats : {
                [i.value]: {}
            }),
            h = Jr(et(t.numberFormats) ? t.numberFormats : {
                [i.value]: {}
            });
        let d = n ? n.missingWarn : St(t.missingWarn) || Oo(t.missingWarn) ? t.missingWarn : !0,
            p = n ? n.fallbackWarn : St(t.fallbackWarn) || Oo(t.fallbackWarn) ? t.fallbackWarn : !0,
            m = n ? n.fallbackRoot : St(t.fallbackRoot) ? t.fallbackRoot : !0,
            _ = !!t.fallbackFormat,
            y = mn(t.missing) ? t.missing : null,
            v = mn(t.missing) ? g3(t.missing) : null,
            w = mn(t.postTranslation) ? t.postTranslation : null,
            b = n ? n.warnHtmlMessage : St(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
            I = !!t.escapeParameter;
        const F = n ? n.modifiers : et(t.modifiers) ? t.modifiers : {};
        let x = t.pluralRules || n && n.pluralRules,
            O;
        O = (() => {
            const J = {
                version: Fue,
                locale: i.value,
                fallbackLocale: a.value,
                messages: c.value,
                modifiers: F,
                pluralRules: x,
                missing: v === null ? void 0 : v,
                missingWarn: d,
                fallbackWarn: p,
                fallbackFormat: _,
                unresolving: !0,
                postTranslation: w === null ? void 0 : w,
                warnHtmlMessage: b,
                escapeParameter: I,
                messageResolver: t.messageResolver,
                __meta: {
                    framework: "vue"
                }
            };
            return J.datetimeFormats = u.value, J.numberFormats = h.value, J.__datetimeFormatters = et(O) ? O.__datetimeFormatters : void 0, J.__numberFormatters = et(O) ? O.__numberFormatters : void 0, xue(J)
        })(), ql(O, i.value, a.value);

        function $() {
            return [i.value, a.value, c.value, u.value, h.value]
        }
        const j = Lr({
                get: () => i.value,
                set: J => {
                    i.value = J, O.locale = i.value
                }
            }),
            ee = Lr({
                get: () => a.value,
                set: J => {
                    a.value = J, O.fallbackLocale = a.value, ql(O, i.value, J)
                }
            }),
            se = Lr(() => c.value),
            oe = Lr(() => u.value),
            Z = Lr(() => h.value);

        function de() {
            return mn(w) ? w : null
        }

        function q(J) {
            w = J, O.postTranslation = J
        }

        function ie() {
            return y
        }

        function ae(J) {
            J !== null && (v = g3(J)), y = J, O.missing = v
        }
        const he = (J, ne, Ne, Pe, ze, ft) => {
            $();
            let D;
            if (D = J(O), In(D) && D === _m) {
                const [P, z] = ne();
                return n && m ? Pe(n) : ze(P)
            } else {
                if (ft(D)) return D;
                throw xn(Sn.UNEXPECTED_RETURN_TYPE)
            }
        };

        function ve(...J) {
            return he(ne => Reflect.apply(l3, null, [ne, ...J]), () => J1(...J), "translate", ne => Reflect.apply(ne.t, ne, [...J]), ne => ne, ne => xe(ne))
        }

        function be(...J) {
            const [ne, Ne, Pe] = J;
            if (Pe && !Ht(Pe)) throw xn(Sn.INVALID_ARGUMENT);
            return ve(ne, Ne, Kn({
                resolvedMessage: !0
            }, Pe || {}))
        }

        function Ae(...J) {
            return he(ne => Reflect.apply(u3, null, [ne, ...J]), () => Q1(...J), "datetime format", ne => Reflect.apply(ne.d, ne, [...J]), () => s3, ne => xe(ne))
        }

        function we(...J) {
            return he(ne => Reflect.apply(f3, null, [ne, ...J]), () => ey(...J), "number format", ne => Reflect.apply(ne.n, ne, [...J]), () => s3, ne => xe(ne))
        }

        function Me(J) {
            return J.map(ne => xe(ne) || In(ne) || St(ne) ? p3(String(ne)) : ne)
        }
        const jt = {
            normalize: Me,
            interpolate: J => J,
            type: "vnode"
        };

        function Ue(...J) {
            return he(ne => {
                let Ne;
                const Pe = ne;
                try {
                    Pe.processor = jt, Ne = Reflect.apply(l3, null, [Pe, ...J])
                } finally {
                    Pe.processor = null
                }
                return Ne
            }, () => J1(...J), "translate", ne => ne[ty](...J), ne => [p3(ne)], ne => Wt(ne))
        }

        function Ye(...J) {
            return he(ne => Reflect.apply(f3, null, [ne, ...J]), () => ey(...J), "number format", ne => ne[ry](...J), () => [], ne => xe(ne) || Wt(ne))
        }

        function at(...J) {
            return he(ne => Reflect.apply(u3, null, [ne, ...J]), () => Q1(...J), "datetime format", ne => ne[ny](...J), () => [], ne => xe(ne) || Wt(ne))
        }

        function ke(J) {
            x = J, O.pluralRules = x
        }

        function rt(J, ne) {
            const Ne = xe(ne) ? ne : i.value,
                Pe = U(Ne);
            return O.messageResolver(Pe, J) !== null
        }

        function Yt(J) {
            let ne = null;
            const Ne = kC(O, a.value, i.value);
            for (let Pe = 0; Pe < Ne.length; Pe++) {
                const ze = c.value[Ne[Pe]] || {},
                    ft = O.messageResolver(ze, J);
                if (ft != null) {
                    ne = ft;
                    break
                }
            }
            return ne
        }

        function zt(J) {
            const ne = Yt(J);
            return ne ?? (n ? n.tm(J) || {} : {})
        }

        function U(J) {
            return c.value[J] || {}
        }

        function T(J, ne) {
            c.value[J] = ne, O.messages = c.value
        }

        function S(J, ne) {
            c.value[J] = c.value[J] || {}, su(ne, c.value[J]), O.messages = c.value
        }

        function N(J) {
            return u.value[J] || {}
        }

        function V(J, ne) {
            u.value[J] = ne, O.datetimeFormats = u.value, h3(O, J, ne)
        }

        function te(J, ne) {
            u.value[J] = Kn(u.value[J] || {}, ne), O.datetimeFormats = u.value, h3(O, J, ne)
        }

        function re(J) {
            return h.value[J] || {}
        }

        function ue(J, ne) {
            h.value[J] = ne, O.numberFormats = h.value, d3(O, J, ne)
        }

        function pe(J, ne) {
            h.value[J] = Kn(h.value[J] || {}, ne), O.numberFormats = h.value, d3(O, J, ne)
        }
        m3++, n && Z1 && (ma(n.locale, J => {
            s && (i.value = J, O.locale = J, ql(O, i.value, a.value))
        }), ma(n.fallbackLocale, J => {
            s && (a.value = J, O.fallbackLocale = J, ql(O, i.value, a.value))
        }));
        const ce = {
            id: m3,
            locale: j,
            fallbackLocale: ee,
            get inheritLocale() {
                return s
            },
            set inheritLocale(J) {
                s = J, J && n && (i.value = n.locale.value, a.value = n.fallbackLocale.value, ql(O, i.value, a.value))
            },
            get availableLocales() {
                return Object.keys(c.value).sort()
            },
            messages: se,
            get modifiers() {
                return F
            },
            get pluralRules() {
                return x || {}
            },
            get isGlobal() {
                return r
            },
            get missingWarn() {
                return d
            },
            set missingWarn(J) {
                d = J, O.missingWarn = d
            },
            get fallbackWarn() {
                return p
            },
            set fallbackWarn(J) {
                p = J, O.fallbackWarn = p
            },
            get fallbackRoot() {
                return m
            },
            set fallbackRoot(J) {
                m = J
            },
            get fallbackFormat() {
                return _
            },
            set fallbackFormat(J) {
                _ = J, O.fallbackFormat = _
            },
            get warnHtmlMessage() {
                return b
            },
            set warnHtmlMessage(J) {
                b = J, O.warnHtmlMessage = J
            },
            get escapeParameter() {
                return I
            },
            set escapeParameter(J) {
                I = J, O.escapeParameter = J
            },
            t: ve,
            getLocaleMessage: U,
            setLocaleMessage: T,
            mergeLocaleMessage: S,
            getPostTranslationHandler: de,
            setPostTranslationHandler: q,
            getMissingHandler: ie,
            setMissingHandler: ae,
            [FC]: ke
        };
        return ce.datetimeFormats = oe, ce.numberFormats = Z, ce.rt = be, ce.te = rt, ce.tm = zt, ce.d = Ae, ce.n = we, ce.getDateTimeFormat = N, ce.setDateTimeFormat = V, ce.mergeDateTimeFormat = te, ce.getNumberFormat = re, ce.setNumberFormat = ue, ce.mergeNumberFormat = pe, ce[UC] = t.__injectWithOption, ce[ty] = Ue, ce[ny] = at, ce[ry] = Ye, ce
    }

    function Bue(t) {
        const e = xe(t.locale) ? t.locale : ah,
            n = xe(t.fallbackLocale) || Wt(t.fallbackLocale) || et(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : e,
            r = mn(t.missing) ? t.missing : void 0,
            s = St(t.silentTranslationWarn) || Oo(t.silentTranslationWarn) ? !t.silentTranslationWarn : !0,
            i = St(t.silentFallbackWarn) || Oo(t.silentFallbackWarn) ? !t.silentFallbackWarn : !0,
            a = St(t.fallbackRoot) ? t.fallbackRoot : !0,
            c = !!t.formatFallbackMessages,
            u = et(t.modifiers) ? t.modifiers : {},
            h = t.pluralizationRules,
            d = mn(t.postTranslation) ? t.postTranslation : void 0,
            p = xe(t.warnHtmlInMessage) ? t.warnHtmlInMessage !== "off" : !0,
            m = !!t.escapeParameterHtml,
            _ = St(t.sync) ? t.sync : !0;
        let y = t.messages;
        if (et(t.sharedMessages)) {
            const O = t.sharedMessages;
            y = Object.keys(O).reduce(($, j) => {
                const ee = $[j] || ($[j] = {});
                return Kn(ee, O[j]), $
            }, y || {})
        }
        const {
            __i18n: v,
            __root: w,
            __injectWithOption: b
        } = t, I = t.datetimeFormats, F = t.numberFormats, x = t.flatJson;
        return {
            locale: e,
            fallbackLocale: n,
            messages: y,
            flatJson: x,
            datetimeFormats: I,
            numberFormats: F,
            missing: r,
            missingWarn: s,
            fallbackWarn: i,
            fallbackRoot: a,
            fallbackFormat: c,
            modifiers: u,
            pluralRules: h,
            postTranslation: d,
            warnHtmlMessage: p,
            escapeParameter: m,
            messageResolver: t.messageResolver,
            inheritLocale: _,
            __i18n: v,
            __root: w,
            __injectWithOption: b
        }
    }

    function iy(t = {}, e) {
        {
            const n = d0(Bue(t)),
                r = {
                    id: n.id,
                    get locale() {
                        return n.locale.value
                    },
                    set locale(s) {
                        n.locale.value = s
                    },
                    get fallbackLocale() {
                        return n.fallbackLocale.value
                    },
                    set fallbackLocale(s) {
                        n.fallbackLocale.value = s
                    },
                    get messages() {
                        return n.messages.value
                    },
                    get datetimeFormats() {
                        return n.datetimeFormats.value
                    },
                    get numberFormats() {
                        return n.numberFormats.value
                    },
                    get availableLocales() {
                        return n.availableLocales
                    },
                    get formatter() {
                        return {
                            interpolate() {
                                return []
                            }
                        }
                    },
                    set formatter(s) {},
                    get missing() {
                        return n.getMissingHandler()
                    },
                    set missing(s) {
                        n.setMissingHandler(s)
                    },
                    get silentTranslationWarn() {
                        return St(n.missingWarn) ? !n.missingWarn : n.missingWarn
                    },
                    set silentTranslationWarn(s) {
                        n.missingWarn = St(s) ? !s : s
                    },
                    get silentFallbackWarn() {
                        return St(n.fallbackWarn) ? !n.fallbackWarn : n.fallbackWarn
                    },
                    set silentFallbackWarn(s) {
                        n.fallbackWarn = St(s) ? !s : s
                    },
                    get modifiers() {
                        return n.modifiers
                    },
                    get formatFallbackMessages() {
                        return n.fallbackFormat
                    },
                    set formatFallbackMessages(s) {
                        n.fallbackFormat = s
                    },
                    get postTranslation() {
                        return n.getPostTranslationHandler()
                    },
                    set postTranslation(s) {
                        n.setPostTranslationHandler(s)
                    },
                    get sync() {
                        return n.inheritLocale
                    },
                    set sync(s) {
                        n.inheritLocale = s
                    },
                    get warnHtmlInMessage() {
                        return n.warnHtmlMessage ? "warn" : "off"
                    },
                    set warnHtmlInMessage(s) {
                        n.warnHtmlMessage = s !== "off"
                    },
                    get escapeParameterHtml() {
                        return n.escapeParameter
                    },
                    set escapeParameterHtml(s) {
                        n.escapeParameter = s
                    },
                    get preserveDirectiveContent() {
                        return !0
                    },
                    set preserveDirectiveContent(s) {},
                    get pluralizationRules() {
                        return n.pluralRules || {}
                    },
                    __composer: n,
                    t(...s) {
                        const [i, a, c] = s, u = {};
                        let h = null,
                            d = null;
                        if (!xe(i)) throw xn(Sn.INVALID_ARGUMENT);
                        const p = i;
                        return xe(a) ? u.locale = a : Wt(a) ? h = a : et(a) && (d = a), Wt(c) ? h = c : et(c) && (d = c), Reflect.apply(n.t, n, [p, h || d || {}, u])
                    },
                    rt(...s) {
                        return Reflect.apply(n.rt, n, [...s])
                    },
                    tc(...s) {
                        const [i, a, c] = s, u = {
                            plural: 1
                        };
                        let h = null,
                            d = null;
                        if (!xe(i)) throw xn(Sn.INVALID_ARGUMENT);
                        const p = i;
                        return xe(a) ? u.locale = a : In(a) ? u.plural = a : Wt(a) ? h = a : et(a) && (d = a), xe(c) ? u.locale = c : Wt(c) ? h = c : et(c) && (d = c), Reflect.apply(n.t, n, [p, h || d || {}, u])
                    },
                    te(s, i) {
                        return n.te(s, i)
                    },
                    tm(s) {
                        return n.tm(s)
                    },
                    getLocaleMessage(s) {
                        return n.getLocaleMessage(s)
                    },
                    setLocaleMessage(s, i) {
                        n.setLocaleMessage(s, i)
                    },
                    mergeLocaleMessage(s, i) {
                        n.mergeLocaleMessage(s, i)
                    },
                    d(...s) {
                        return Reflect.apply(n.d, n, [...s])
                    },
                    getDateTimeFormat(s) {
                        return n.getDateTimeFormat(s)
                    },
                    setDateTimeFormat(s, i) {
                        n.setDateTimeFormat(s, i)
                    },
                    mergeDateTimeFormat(s, i) {
                        n.mergeDateTimeFormat(s, i)
                    },
                    n(...s) {
                        return Reflect.apply(n.n, n, [...s])
                    },
                    getNumberFormat(s) {
                        return n.getNumberFormat(s)
                    },
                    setNumberFormat(s, i) {
                        n.setNumberFormat(s, i)
                    },
                    mergeNumberFormat(s, i) {
                        n.mergeNumberFormat(s, i)
                    },
                    getChoiceIndex(s, i) {
                        return -1
                    },
                    __onComponentInstanceCreated(s) {
                        const {
                            componentInstanceCreatedListener: i
                        } = t;
                        i && i(s, r)
                    }
                };
            return r
        }
    }
    const p0 = {
        tag: {
            type: [String, Object]
        },
        locale: {
            type: String
        },
        scope: {
            type: String,
            validator: t => t === "parent" || t === "global",
            default: "parent"
        },
        i18n: {
            type: Object
        }
    };

    function que({
        slots: t
    }, e) {
        return e.length === 1 && e[0] === "default" ? (t.default ? t.default() : []).reduce((r, s) => r = [...r, ...Wt(s.children) ? s.children : [s]], []) : e.reduce((n, r) => {
            const s = t[r];
            return s && (n[r] = s()), n
        }, {})
    }

    function qC(t) {
        return Tt
    }
    const _3 = {
        name: "i18n-t",
        props: Kn({
            keypath: {
                type: String,
                required: !0
            },
            plural: {
                type: [Number, String],
                validator: t => In(t) || !isNaN(t)
            }
        }, p0),
        setup(t, e) {
            const {
                slots: n,
                attrs: r
            } = e, s = t.i18n || m0({
                useScope: t.scope,
                __useComponent: !0
            });
            return () => {
                const i = Object.keys(n).filter(p => p !== "_"),
                    a = {};
                t.locale && (a.locale = t.locale), t.plural !== void 0 && (a.plural = xe(t.plural) ? +t.plural : t.plural);
                const c = que(e, i),
                    u = s[ty](t.keypath, c, a),
                    h = Kn({}, r),
                    d = xe(t.tag) || Ht(t.tag) ? t.tag : qC();
                return Gy(d, h, u)
            }
        }
    };

    function jue(t) {
        return Wt(t) && !xe(t[0])
    }

    function jC(t, e, n, r) {
        const {
            slots: s,
            attrs: i
        } = e;
        return () => {
            const a = {
                part: !0
            };
            let c = {};
            t.locale && (a.locale = t.locale), xe(t.format) ? a.key = t.format : Ht(t.format) && (xe(t.format.key) && (a.key = t.format.key), c = Object.keys(t.format).reduce((m, _) => n.includes(_) ? Kn({}, m, {
                [_]: t.format[_]
            }) : m, {}));
            const u = r(t.value, a, c);
            let h = [a.key];
            Wt(u) ? h = u.map((m, _) => {
                const y = s[m.type],
                    v = y ? y({
                        [m.type]: m.value,
                        index: _,
                        parts: u
                    }) : [m.value];
                return jue(v) && (v[0].key = `${m.type}-${_}`), v
            }) : xe(u) && (h = [u]);
            const d = Kn({}, i),
                p = xe(t.tag) || Ht(t.tag) ? t.tag : qC();
            return Gy(p, d, h)
        }
    }
    const y3 = {
            name: "i18n-n",
            props: Kn({
                value: {
                    type: Number,
                    required: !0
                },
                format: {
                    type: [String, Object]
                }
            }, p0),
            setup(t, e) {
                const n = t.i18n || m0({
                    useScope: "parent",
                    __useComponent: !0
                });
                return jC(t, e, $C, (...r) => n[ry](...r))
            }
        },
        v3 = {
            name: "i18n-d",
            props: Kn({
                value: {
                    type: [Number, Date],
                    required: !0
                },
                format: {
                    type: [String, Object]
                }
            }, p0),
            setup(t, e) {
                const n = t.i18n || m0({
                    useScope: "parent",
                    __useComponent: !0
                });
                return jC(t, e, DC, (...r) => n[ny](...r))
            }
        };

    function Vue(t, e) {
        const n = t;
        if (t.mode === "composition") return n.__getInstance(e) || t.global; {
            const r = n.__getInstance(e);
            return r != null ? r.__composer : t.global.__composer
        }
    }

    function Gue(t) {
        const e = a => {
            const {
                instance: c,
                modifiers: u,
                value: h
            } = a;
            if (!c || !c.$) throw xn(Sn.UNEXPECTED_ERROR);
            const d = Vue(t, c.$),
                p = b3(h);
            return [Reflect.apply(d.t, d, [...E3(p)]), d]
        };
        return {
            created: (a, c) => {
                const [u, h] = e(c);
                Z1 && t.global === h && (a.__i18nWatcher = ma(h.locale, () => {
                    c.instance && c.instance.$forceUpdate()
                })), a.__composer = h, a.textContent = u
            },
            unmounted: a => {
                Z1 && a.__i18nWatcher && (a.__i18nWatcher(), a.__i18nWatcher = void 0, delete a.__i18nWatcher), a.__composer && (a.__composer = void 0, delete a.__composer)
            },
            beforeUpdate: (a, {
                value: c
            }) => {
                if (a.__composer) {
                    const u = a.__composer,
                        h = b3(c);
                    a.textContent = Reflect.apply(u.t, u, [...E3(h)])
                }
            },
            getSSRProps: a => {
                const [c] = e(a);
                return {
                    textContent: c
                }
            }
        }
    }

    function b3(t) {
        if (xe(t)) return {
            path: t
        };
        if (et(t)) {
            if (!("path" in t)) throw xn(Sn.REQUIRED_VALUE, "path");
            return t
        } else throw xn(Sn.INVALID_VALUE)
    }

    function E3(t) {
        const {
            path: e,
            locale: n,
            args: r,
            choice: s,
            plural: i
        } = t, a = {}, c = r || {};
        return xe(n) && (a.locale = n), In(s) && (a.plural = s), In(i) && (a.plural = i), [e, c, a]
    }

    function Wue(t, e, ...n) {
        const r = et(n[0]) ? n[0] : {},
            s = !!r.useI18nComponentName;
        (St(r.globalInstall) ? r.globalInstall : !0) && (t.component(s ? "i18n" : _3.name, _3), t.component(y3.name, y3), t.component(v3.name, v3)), t.directive("t", Gue(e))
    }

    function Hue(t, e, n) {
        return {
            beforeCreate() {
                const r = pu();
                if (!r) throw xn(Sn.UNEXPECTED_ERROR);
                const s = this.$options;
                if (s.i18n) {
                    const i = s.i18n;
                    s.__i18n && (i.__i18n = s.__i18n), i.__root = e, this === this.$root ? this.$i18n = T3(t, i) : (i.__injectWithOption = !0, this.$i18n = iy(i))
                } else s.__i18n ? this === this.$root ? this.$i18n = T3(t, s) : this.$i18n = iy({
                    __i18n: s.__i18n,
                    __injectWithOption: !0,
                    __root: e
                }) : this.$i18n = t;
                s.__i18nGlobal && BC(e, s, s), t.__onComponentInstanceCreated(this.$i18n), n.__setInstance(r, this.$i18n), this.$t = (...i) => this.$i18n.t(...i), this.$rt = (...i) => this.$i18n.rt(...i), this.$tc = (...i) => this.$i18n.tc(...i), this.$te = (i, a) => this.$i18n.te(i, a), this.$d = (...i) => this.$i18n.d(...i), this.$n = (...i) => this.$i18n.n(...i), this.$tm = i => this.$i18n.tm(i)
            },
            mounted() {},
            unmounted() {
                const r = pu();
                if (!r) throw xn(Sn.UNEXPECTED_ERROR);
                delete this.$t, delete this.$rt, delete this.$tc, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, n.__deleteInstance(r), delete this.$i18n
            }
        }
    }

    function T3(t, e) {
        t.locale = e.locale || t.locale, t.fallbackLocale = e.fallbackLocale || t.fallbackLocale, t.missing = e.missing || t.missing, t.silentTranslationWarn = e.silentTranslationWarn || t.silentFallbackWarn, t.silentFallbackWarn = e.silentFallbackWarn || t.silentFallbackWarn, t.formatFallbackMessages = e.formatFallbackMessages || t.formatFallbackMessages, t.postTranslation = e.postTranslation || t.postTranslation, t.warnHtmlInMessage = e.warnHtmlInMessage || t.warnHtmlInMessage, t.escapeParameterHtml = e.escapeParameterHtml || t.escapeParameterHtml, t.sync = e.sync || t.sync, t.__composer[FC](e.pluralizationRules || t.pluralizationRules);
        const n = ym(t.locale, {
            messages: e.messages,
            __i18n: e.__i18n
        });
        return Object.keys(n).forEach(r => t.mergeLocaleMessage(r, n[r])), e.datetimeFormats && Object.keys(e.datetimeFormats).forEach(r => t.mergeDateTimeFormat(r, e.datetimeFormats[r])), e.numberFormats && Object.keys(e.numberFormats).forEach(r => t.mergeNumberFormat(r, e.numberFormats[r])), t
    }
    const Kue = Uo("global-vue-i18n");

    function Yue(t = {}, e) {
        const n = St(t.legacy) ? t.legacy : !0,
            r = St(t.globalInjection) ? t.globalInjection : !0,
            s = n ? !!t.allowComposition : !0,
            i = new Map,
            [a, c] = zue(t, n),
            u = Uo("");

        function h(m) {
            return i.get(m) || null
        }

        function d(m, _) {
            i.set(m, _)
        }

        function p(m) {
            i.delete(m)
        } {
            const m = {
                get mode() {
                    return n ? "legacy" : "composition"
                },
                get allowComposition() {
                    return s
                },
                async install(_, ...y) {
                    _.__VUE_I18N_SYMBOL__ = u, _.provide(_.__VUE_I18N_SYMBOL__, m), !n && r && she(_, m.global), Wue(_, m, ...y), n && _.mixin(Hue(c, c.__composer, m));
                    const v = _.unmount;
                    _.unmount = () => {
                        m.dispose(), v()
                    }
                },
                get global() {
                    return c
                },
                dispose() {
                    a.stop()
                },
                __instances: i,
                __getInstance: h,
                __setInstance: d,
                __deleteInstance: p
            };
            return m
        }
    }

    function m0(t = {}) {
        const e = pu();
        if (e == null) throw xn(Sn.MUST_BE_CALL_SETUP_TOP);
        if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__) throw xn(Sn.NOT_INSLALLED);
        const n = Zue(e),
            r = Jue(n),
            s = Uue(e),
            i = Xue(t, s);
        if (n.mode === "legacy" && !t.__useComponent) {
            if (!n.allowComposition) throw xn(Sn.NOT_AVAILABLE_IN_LEGACY_MODE);
            return the(e, i, r, t)
        }
        if (i === "global") return BC(r, t, s), r;
        if (i === "parent") {
            let u = Que(n, e, t.__useComponent);
            return u == null && (u = r), u
        }
        const a = n;
        let c = a.__getInstance(e);
        if (c == null) {
            const u = Kn({}, t);
            "__i18n" in s && (u.__i18n = s.__i18n), r && (u.__root = r), c = d0(u), ehe(a, e), a.__setInstance(e, c)
        }
        return c
    }

    function zue(t, e, n) {
        const r = CR(); {
            const s = e ? r.run(() => iy(t)) : r.run(() => d0(t));
            if (s == null) throw xn(Sn.UNEXPECTED_ERROR);
            return [r, s]
        }
    }

    function Zue(t) {
        {
            const e = mo(t.isCE ? Kue : t.appContext.app.__VUE_I18N_SYMBOL__);
            if (!e) throw xn(t.isCE ? Sn.NOT_INSLALLED_WITH_PROVIDE : Sn.UNEXPECTED_ERROR);
            return e
        }
    }

    function Xue(t, e) {
        return mm(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local"
    }

    function Jue(t) {
        return t.mode === "composition" ? t.global : t.global.__composer
    }

    function Que(t, e, n = !1) {
        let r = null;
        const s = e.root;
        let i = e.parent;
        for (; i != null;) {
            const a = t;
            if (t.mode === "composition") r = a.__getInstance(i);
            else {
                const c = a.__getInstance(i);
                c != null && (r = c.__composer, n && r && !r[UC] && (r = null))
            }
            if (r != null || s === i) break;
            i = i.parent
        }
        return r
    }

    function ehe(t, e, n) {
        Dy(() => {}, e), $y(() => {
            t.__deleteInstance(e)
        }, e)
    }

    function the(t, e, n, r = {}) {
        const s = e === "local",
            i = rM(null);
        if (s && t.proxy && !(t.proxy.$options.i18n || t.proxy.$options.__i18n)) throw xn(Sn.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
        const a = St(r.inheritLocale) ? r.inheritLocale : !0,
            c = Jr(s && a ? n.locale.value : xe(r.locale) ? r.locale : ah),
            u = Jr(s && a ? n.fallbackLocale.value : xe(r.fallbackLocale) || Wt(r.fallbackLocale) || et(r.fallbackLocale) || r.fallbackLocale === !1 ? r.fallbackLocale : c.value),
            h = Jr(ym(c.value, r)),
            d = Jr(et(r.datetimeFormats) ? r.datetimeFormats : {
                [c.value]: {}
            }),
            p = Jr(et(r.numberFormats) ? r.numberFormats : {
                [c.value]: {}
            }),
            m = s ? n.missingWarn : St(r.missingWarn) || Oo(r.missingWarn) ? r.missingWarn : !0,
            _ = s ? n.fallbackWarn : St(r.fallbackWarn) || Oo(r.fallbackWarn) ? r.fallbackWarn : !0,
            y = s ? n.fallbackRoot : St(r.fallbackRoot) ? r.fallbackRoot : !0,
            v = !!r.fallbackFormat,
            w = mn(r.missing) ? r.missing : null,
            b = mn(r.postTranslation) ? r.postTranslation : null,
            I = s ? n.warnHtmlMessage : St(r.warnHtmlMessage) ? r.warnHtmlMessage : !0,
            F = !!r.escapeParameter,
            x = s ? n.modifiers : et(r.modifiers) ? r.modifiers : {},
            O = r.pluralRules || s && n.pluralRules;

        function M() {
            return [c.value, u.value, h.value, d.value, p.value]
        }
        const $ = Lr({
                get: () => i.value ? i.value.locale.value : c.value,
                set: S => {
                    i.value && (i.value.locale.value = S), c.value = S
                }
            }),
            j = Lr({
                get: () => i.value ? i.value.fallbackLocale.value : u.value,
                set: S => {
                    i.value && (i.value.fallbackLocale.value = S), u.value = S
                }
            }),
            ee = Lr(() => i.value ? i.value.messages.value : h.value),
            se = Lr(() => d.value),
            oe = Lr(() => p.value);

        function Z() {
            return i.value ? i.value.getPostTranslationHandler() : b
        }

        function de(S) {
            i.value && i.value.setPostTranslationHandler(S)
        }

        function q() {
            return i.value ? i.value.getMissingHandler() : w
        }

        function ie(S) {
            i.value && i.value.setMissingHandler(S)
        }

        function ae(S) {
            return M(), S()
        }

        function he(...S) {
            return i.value ? ae(() => Reflect.apply(i.value.t, null, [...S])) : ae(() => "")
        }

        function ve(...S) {
            return i.value ? Reflect.apply(i.value.rt, null, [...S]) : ""
        }

        function be(...S) {
            return i.value ? ae(() => Reflect.apply(i.value.d, null, [...S])) : ae(() => "")
        }

        function Ae(...S) {
            return i.value ? ae(() => Reflect.apply(i.value.n, null, [...S])) : ae(() => "")
        }

        function we(S) {
            return i.value ? i.value.tm(S) : {}
        }

        function Me(S, N) {
            return i.value ? i.value.te(S, N) : !1
        }

        function Nt(S) {
            return i.value ? i.value.getLocaleMessage(S) : {}
        }

        function jt(S, N) {
            i.value && (i.value.setLocaleMessage(S, N), h.value[S] = N)
        }

        function Ue(S, N) {
            i.value && i.value.mergeLocaleMessage(S, N)
        }

        function Ye(S) {
            return i.value ? i.value.getDateTimeFormat(S) : {}
        }

        function at(S, N) {
            i.value && (i.value.setDateTimeFormat(S, N), d.value[S] = N)
        }

        function ke(S, N) {
            i.value && i.value.mergeDateTimeFormat(S, N)
        }

        function rt(S) {
            return i.value ? i.value.getNumberFormat(S) : {}
        }

        function Yt(S, N) {
            i.value && (i.value.setNumberFormat(S, N), p.value[S] = N)
        }

        function zt(S, N) {
            i.value && i.value.mergeNumberFormat(S, N)
        }
        const U = {
            get id() {
                return i.value ? i.value.id : -1
            },
            locale: $,
            fallbackLocale: j,
            messages: ee,
            datetimeFormats: se,
            numberFormats: oe,
            get inheritLocale() {
                return i.value ? i.value.inheritLocale : a
            },
            set inheritLocale(S) {
                i.value && (i.value.inheritLocale = S)
            },
            get availableLocales() {
                return i.value ? i.value.availableLocales : Object.keys(h.value)
            },
            get modifiers() {
                return i.value ? i.value.modifiers : x
            },
            get pluralRules() {
                return i.value ? i.value.pluralRules : O
            },
            get isGlobal() {
                return i.value ? i.value.isGlobal : !1
            },
            get missingWarn() {
                return i.value ? i.value.missingWarn : m
            },
            set missingWarn(S) {
                i.value && (i.value.missingWarn = S)
            },
            get fallbackWarn() {
                return i.value ? i.value.fallbackWarn : _
            },
            set fallbackWarn(S) {
                i.value && (i.value.missingWarn = S)
            },
            get fallbackRoot() {
                return i.value ? i.value.fallbackRoot : y
            },
            set fallbackRoot(S) {
                i.value && (i.value.fallbackRoot = S)
            },
            get fallbackFormat() {
                return i.value ? i.value.fallbackFormat : v
            },
            set fallbackFormat(S) {
                i.value && (i.value.fallbackFormat = S)
            },
            get warnHtmlMessage() {
                return i.value ? i.value.warnHtmlMessage : I
            },
            set warnHtmlMessage(S) {
                i.value && (i.value.warnHtmlMessage = S)
            },
            get escapeParameter() {
                return i.value ? i.value.escapeParameter : F
            },
            set escapeParameter(S) {
                i.value && (i.value.escapeParameter = S)
            },
            t: he,
            getPostTranslationHandler: Z,
            setPostTranslationHandler: de,
            getMissingHandler: q,
            setMissingHandler: ie,
            rt: ve,
            d: be,
            n: Ae,
            tm: we,
            te: Me,
            getLocaleMessage: Nt,
            setLocaleMessage: jt,
            mergeLocaleMessage: Ue,
            getDateTimeFormat: Ye,
            setDateTimeFormat: at,
            mergeDateTimeFormat: ke,
            getNumberFormat: rt,
            setNumberFormat: Yt,
            mergeNumberFormat: zt
        };

        function T(S) {
            S.locale.value = c.value, S.fallbackLocale.value = u.value, Object.keys(h.value).forEach(N => {
                S.mergeLocaleMessage(N, h.value[N])
            }), Object.keys(d.value).forEach(N => {
                S.mergeDateTimeFormat(N, d.value[N])
            }), Object.keys(p.value).forEach(N => {
                S.mergeNumberFormat(N, p.value[N])
            }), S.escapeParameter = F, S.fallbackFormat = v, S.fallbackRoot = y, S.fallbackWarn = _, S.missingWarn = m, S.warnHtmlMessage = I
        }
        return U5(() => {
            if (t.proxy == null || t.proxy.$i18n == null) throw xn(Sn.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
            const S = i.value = t.proxy.$i18n.__composer;
            e === "global" ? (c.value = S.locale.value, u.value = S.fallbackLocale.value, h.value = S.messages.value, d.value = S.datetimeFormats.value, p.value = S.numberFormats.value) : s && T(S)
        }), U
    }
    const nhe = ["locale", "fallbackLocale", "availableLocales"],
        rhe = ["t", "rt", "d", "n", "tm"];

    function she(t, e) {
        const n = Object.create(null);
        nhe.forEach(r => {
            const s = Object.getOwnPropertyDescriptor(e, r);
            if (!s) throw xn(Sn.UNEXPECTED_ERROR);
            const i = jn(s.value) ? {
                get() {
                    return s.value.value
                },
                set(a) {
                    s.value.value = a
                }
            } : {
                get() {
                    return s.get && s.get()
                }
            };
            Object.defineProperty(n, r, i)
        }), t.config.globalProperties.$i18n = n, rhe.forEach(r => {
            const s = Object.getOwnPropertyDescriptor(e, r);
            if (!s || !s.value) throw xn(Sn.UNEXPECTED_ERROR);
            Object.defineProperty(t.config.globalProperties, `$${r}`, s)
        })
    }
    kue(Rue);
    Iue(pue);
    Nue(kC);
    const ihe = mt({
            data() {
                return {
                    isVisible: !1,
                    options: null,
                    timeout: null
                }
            },
            beforeMount() {
                this.$registerToast(this)
            },
            methods: {
                show(t) {
                    this.isVisible = !0, this.options = t, this.timeout && (window.clearTimeout(this.timeout), this.timeout = null), t.duration && (this.timeout = window.setTimeout(() => {
                        this.hide()
                    }, t.duration))
                },
                hide() {
                    this.isVisible = !1, this.options = null, this.timeout && (window.clearTimeout(this.timeout), this.timeout = null)
                }
            }
        }),
        ohe = "main/pp10/nopus-opus/assets/c8afd972.svg",
        ahe = {
            class: "constrain"
        },
        che = {
            class: "text"
        },
        lhe = {
            class: "subtext"
        },
        uhe = {
            key: 0,
            class: "warning"
        },
        hhe = {
            key: 1,
            class: "spinner"
        },
        fhe = {
            key: 2,
            class: "pause"
        };

    function dhe(t, e, n, r, s, i) {
        return G(), Ut(Li, {
            name: "toast-transition"
        }, {
            default: si(() => [t.isVisible && t.options ? (G(), H("div", {
                key: 0,
                class: Xe([t.options.type, "jbg toast"])
            }, [B("div", ahe, [B("img", {
                class: "close",
                alt: "close",
                src: ohe,
                onClick: e[0] || (e[0] = (...a) => t.hide && t.hide(...a)),
                onKeydown: e[1] || (e[1] = Wy((...a) => t.hide && t.hide(...a), ["esc"]))
            }, null, 32), B("p", che, vt(t.options.text), 1), B("p", lhe, vt(t.options.subtext), 1), t.options.warning ? (G(), H("p", uhe, vt(t.options.warning), 1)) : Be("", !0), t.options.type === "reconnecting" || t.options.type === "paused" ? (G(), H("div", hhe)) : Be("", !0), t.options.type === "paused" ? (G(), H("div", fhe)) : Be("", !0)])], 2)) : Be("", !0)]),
            _: 1
        })
    }
    const phe = ot(ihe, [
            ["render", dhe],
            ["__scopeId", "data-v-6d2a2aa3"]
        ]),
        mhe = {
            install: t => {
                if (t.config.globalProperties.$showToast) return;
                let e;
                const n = i => {
                        if (!e) throw new Error("No ToastComponent is registered to show");
                        e.show(i)
                    },
                    r = () => {
                        if (!e) throw new Error("No ToastComponent is registered to hide");
                        e.hide()
                    },
                    s = i => {
                        e = i
                    };
                t.component("Toast", phe), t.config.globalProperties.$showToast = n, t.config.globalProperties.$hideToast = r, t.config.globalProperties.$registerToast = s
            }
        },
        ghe = mt({
            props: {
                options: Object,
                mainView: Object
            },
            setup() {
                return {
                    fatalError: mo(sh.fatal.error)
                }
            },
            data() {
                return {
                    isKicked: !1
                }
            },
            computed: {
                ecast() {
                    return this.$ecast
                },
                ecastValues() {
                    return this.$ecastValues ? this.$ecastValues : null
                },
                classes() {
                    return [`locale-${this.$i18n.locale}`]
                },
                shouldShowFatal() {
                    var t;
                    return ((t = this.fatalError) == null ? void 0 : t.hasCrashed) ?? !1
                }
            },
            watch: {
                "ecastValues.hostIsPaused": function(e) {
                    e ? this.$showToast({
                        type: "paused",
                        text: this.$t("TOAST.PAUSED.TEXT"),
                        subtext: this.$t("TOAST.PAUSED.SUBTEXT")
                    }) : this.$hideToast()
                }
            },
            beforeMount() {
                this.$ecast.on("connection", t => {
                    this.onConnection(t)
                }), this.$ecast.on("client/connected", t => {
                    this.onClientConnected(t)
                }), this.$ecast.on("client/disconnected", t => {
                    this.onClientDisconnected(t)
                }), this.$ecast.on("room/exit", () => {
                    this.onRoomExit()
                }), this.$ecast.on("client/kicked", () => {
                    this.onClientKicked()
                }), this.$ecast.on("socketClose", () => {
                    this.onSocketClose()
                })
            },
            beforeUnmount() {},
            methods: {
                onConnection(t) {
                    switch (t.status) {
                        case "waiting":
                        case "connecting":
                            this.$showToast({
                                type: "reconnecting",
                                text: this.$t("TOAST.RECONNECTING.CONTROLLER.TEXT"),
                                subtext: this.$t("TOAST.RECONNECTING.CONTROLLER.SUBTEXT", {
                                    attempt: t.attempt
                                })
                            });
                            break;
                        case "connected":
                            this.$showToast({
                                type: "generic",
                                text: this.$t("TOAST.RECONNECTED.TEXT"),
                                subtext: this.$t("TOAST.RECONNECTED.SUBTEXT"),
                                duration: 1500
                            });
                            break
                    }
                },
                onClientConnected(t) {
                    t.role === "host" && t.reconnect && this.$showToast({
                        type: "generic",
                        text: this.$t("TOAST.RECONNECTED.TEXT"),
                        subtext: this.$t("TOAST.RECONNECTED.SUBTEXT"),
                        duration: 1500
                    })
                },
                onClientDisconnected(t) {
                    t.role === "host" && this.$showToast({
                        type: "reconnecting",
                        text: this.$t("TOAST.RECONNECTING.GAME.TEXT"),
                        subtext: this.$t("TOAST.RECONNECTING.GAME.SUBTEXT")
                    })
                },
                async onRoomExit() {
                    this.$hideToast(), await this.$showModal("Error", {
                        image: "moon",
                        text: this.$t("ERROR.ROOM_DISCONNECTED"),
                        subtext: this.$t("ERROR.ROOM_DESTROYED"),
                        dismissText: this.$t("ACTION.OK")
                    }), window.location.reload()
                },
                async onClientKicked() {
                    this.isKicked = !0, this.$hideToast(), await this.$showModal("Error", {
                        image: "tear",
                        text: this.$t("ERROR.ROOM_DISCONNECTED"),
                        subtext: this.$t("ERROR.PLAYER_KICKED"),
                        dismissText: this.$t("ACTION.OK")
                    }), window.location.reload()
                },
                async onSocketClose() {
                    this.isKicked || (this.$hideToast(), await this.$showModal("Error", {
                        image: "moon",
                        text: this.$t("ERROR.ROOM_DISCONNECTED"),
                        dismissText: this.$t("ACTION.OK")
                    }), window.location.reload())
                }
            }
        });

    function _he(t, e, n, r, s, i) {
        const a = st("Fatal"),
            c = st("TextDescriptions"),
            u = st("Debug"),
            h = st("Modal"),
            d = st("Toast");
        return t.shouldShowFatal ? (G(), Ut(a, {
            key: 0
        })) : (G(), H(Tt, {
            key: 1
        }, [Je(c), (G(), Ut(Fy(t.mainView), Bp({
            id: "game",
            class: t.classes
        }, t.ecastValues), null, 16, ["class"])), Je(u), Je(h), Je(d)], 64))
    }
    const S3 = ot(ghe, [
            ["render", _he]
        ]),
        yhe = t => {
            let e;
            window.tv.register({
                connect: (n, r) => (r ? e = r.setClient(Tr.WSClient, n) : e = new Tr.WSClient(n), e.connect()),
                mount: n => {
                    var a, c, u;
                    S3.name = n.app;
                    let r = WD(S3, {
                            options: n,
                            mainView: t.MainView
                        }),
                        s;
                    (a = n.room) != null && a.locale && (s = n.room.locale), (u = (c = n.match) == null ? void 0 : c.params) != null && u.locale && (s = n.match.params.locale), vc.set(s);
                    const i = Yue({
                        fallbackLocale: "en",
                        locale: vc.locale,
                        messages: vc.mergeMessages(SY, t.messages ?? {})
                    });
                    if (r.use(Tee), r.use(wle), r.use(Jse, {
                            replayer: n.replayer,
                            client: e,
                            room: n.room
                        }), r.use(voe, {
                            wsClient: e,
                            room: n.room,
                            welcome: n.welcome
                        }), r.use(Sce), r.use(i), r.use(tle, {
                            i18n: i
                        }), r.use(Nle), r.use(xle), r.use(mhe), r.use(Ple), t.plugins) {
                        const h = d => d.plugin === void 0;
                        t.plugins.forEach(d => {
                            if (h(d)) {
                                r.use(d);
                                return
                            }
                            r.use(d.plugin, ...d.options)
                        })
                    }
                    return r.mount("#app"), () => {
                        r.unmount(), r = null
                    }
                },
                info: n => ({
                    tag: n.app,
                    version: n.version,
                    type: n.type,
                    wrapper: "vue",
                    branch: n.branch
                })
            })
        },
        vhe = {
            AVATARS: {
                0: "calm light green bird with a single dark green feather on its head",
                1: "punky yellow bird with yellow feathers that look like a mohawk",
                2: "fancy teal bird with round yellow feathers on its head and tail",
                3: "sleek red bird with a pointy head and curly black tail",
                4: "tufted green bird with yellow wings",
                5: "wild magenta bird with light pink, unkempt feathers on its head",
                6: "dramatic white bird with angular black eyebrow feathers",
                7: "flamboyant purple bird with forward feathers on its head and a big curly tail",
                8: "chill brown bird with a foxy tail",
                9: "cute pink bird with a tail that looks like ice cream cones",
                10: "dorky blue bird with perfect hair",
                11: "emo pink bird with feathers brushed forward on its head"
            },
            CHANGE_AVATAR: "Change Avatar",
            LOGO: "the Dodo Re Mi logo"
        },
        bhe = {
            CHANGE_AVATAR: "change avatar",
            SONG_DOWN: "scroll to the next song {songName}",
            SONG_UP: "scroll to the previous song {songName}",
            SELECT_SONG: "select song {songName}"
        },
        Ehe = {
            BASS: "Bass",
            MELODY: "Melody",
            COUNTER: "Counter",
            DRUMS: "Drums",
            PERCUSSION: "Percussion",
            HARMONY: "Harmony",
            SIGNATURE: "Signature"
        },
        The = {
            WHEN: "When the screen says to",
            GET_READY: "Get Ready",
            TAP_HERE: "TAP[break][/break]HERE[break][/break][info](OR PRESS THE SPACEBAR)[/info]",
            TAP: "tap",
            SYNCED: "synced",
            SYNCING: "Syncing"
        },
        She = {
            SHARE: "Share the music"
        },
        whe = {
            CONTINUOUS: "Tap and hold notes when they enter the zone below",
            DISCRETE: "Tap notes when they fill the circles below"
        },
        Ohe = {
            SURVIVED: "Survived",
            EATEN: "Eaten"
        },
        Ahe = {
            VERY_EASY: "Super Easy",
            EASY: "Easy",
            MEDIUM: "Medium",
            HARD: "Hard",
            VERY_HARD: "Super Hard"
        },
        Che = {
            BACK_TO_MENU: "Back to Game Menu",
            BEST_SCORE: "Best Score",
            CHANGE_HOST: "Change[break][/break]Host?",
            CHOOSE_HOST: "Choose New Host",
            CHOOSE_INSTRUMENT: "Choose Instrument",
            CHOOSE_SONG: "Choose Song",
            COMPLETED_PARTS: "Parts Survived",
            DIFFICULTY: "Difficulty",
            END_SESSION: "End Session",
            LANES: "Lanes",
            LOADING: "Loading",
            NEVERMIND: "Nevermind",
            NEW_SONG: "New Song",
            RETRY_SONG: "Retry Song",
            SELECT_SONG: "Select Song",
            SONG_PART: "Song Part",
            START_SONG: "Start Song",
            TEST_IT: "Test It Out",
            THANKS: "Thanks for playing",
            VOTE_SONG: "Vote for a Song",
            WAITING_FOR: "Waiting for {vipName}",
            WHAT_NEXT: "What's Next?"
        },
        khe = {
            WELCOME: "Welcome to Dodo Re Mi",
            SILENT: "Please turn Silent Mode OFF on your device",
            VOLUME: "Turn your volume UP",
            POWER_SAVER: "Make sure your device is NOT on Power Save Mode",
            TEST: "TEST YOUR AUDIO ",
            GO: "Let's Go"
        },
        Ihe = {
            ALT: vhe,
            ARIA: bhe,
            BEATMAPS: Ehe,
            COUNT_IN: The,
            CREDITS: She,
            INFO: whe,
            RESULTS: Ohe,
            DIFFICULTY: Ahe,
            MENU: Che,
            WELCOME: khe
        },
        Nhe = {
            AVATARS: {
                0: "oiseau calme vert clair avec une seule plume vert fonc sur sa tte",
                1: "oiseau jaune punk avec plumes jaunes faon crte",
                2: "oiseau chic bleu sarcelle avec plumes jaunes rondes sur sa tte et sa queue",
                3: "oiseau rouge au plumage soyeux avec une tte pointue et une queue noire boucle",
                4: "oiseau vert touffu avec ailes jaunes",
                5: "oiseau sauvage magenta avec plumes hirsutes rose clair sur sa tte",
                6: "oiseau blanc dramatique avec plumes noires angulaires au niveau des sourcils",
                7: "oiseau violet flamboyant avec plumes vers l'avant sur sa tte et une grande queue frise",
                8: "oiseau marron relax avec queue rousse",
                9: "oiseau rose mignon avec une queue en forme de cornet de glace",
                10: "oiseau bleu intello au plumage trs soign",
                11: "oiseau rose emo avec plumes de sa tte coiffes vers l'avant"
            },
            CHANGE_AVATAR: "Changer d'avatar",
            LOGO: "logo Dodo R Mi"
        },
        xhe = {
            CHANGE_AVATAR: "changer d'avatar",
            SONG_DOWN: "faire dfiler jusqu' la prochaine chanson {songName}",
            SONG_UP: "faire dfiler jusqu' la chanson prcdente {songName}",
            SELECT_SONG: "choisir la chanson {songName}"
        },
        Phe = {
            BASS: "Basse",
            MELODY: "Mlodie",
            COUNTER: "Contre",
            DRUMS: "Batterie",
            PERCUSSION: "Percussion",
            HARMONY: "Harmonie",
            SIGNATURE: "Signature"
        },
        Rhe = {
            WHEN: "Lorsque l'cran indique",
            GET_READY: "Prparez-vous",
            TAP_HERE: "TOUCHER[break][/break]ICI[break][/break][info](OU APPUYER SUR LA BARRE D'ESPACE)[/info]",
            TAP: "toucher",
            SYNCED: "synchronis",
            SYNCING: "Synchro en cours"
        },
        Mhe = {
            SHARE: "Partager la musique"
        },
        Dhe = {
            SURVIVED: "Survcu",
            EATEN: "Mang"
        },
        $he = {
            VERY_EASY: "Super facile",
            EASY: "Facile",
            MEDIUM: "Moyen",
            HARD: "Difficile",
            VERY_HARD: "Super difficile"
        },
        Lhe = {
            BACK_TO_MENU: "Retour au menu du jeu",
            BEST_SCORE: "Meilleur score",
            CHANGE_HOST: "Changer[break][/break]d'hte?",
            CHOOSE_HOST: "Choisissez un nouvel hte",
            CHOOSE_INSTRUMENT: "Choisissez un instrument",
            CHOOSE_SONG: "Choisissez une chanson",
            COMPLETED_PARTS: "Sections survcues",
            DIFFICULTY: "Difficult",
            END_SESSION: "Terminer la session",
            LANES: "Lanes",
            LOADING: "Chargement",
            NEVERMIND: "Nevermind",
            NEW_SONG: "Nouvelle chanson",
            RETRY_SONG: "Ressayer la chanson",
            SELECT_SONG: "Choisir la chanson",
            SONG_PART: "Section de la chanson",
            START_SONG: "Lancer la chanson",
            TEST_IT: "Tester",
            THANKS: "Merci d'avoir jou!",
            VOTE_SONG: "Votez pour une chanson",
            WAITING_FOR: "En attente de {vipName}",
            WHAT_NEXT: "Et ensuite?"
        },
        Fhe = {
            WELCOME: "Bienvenue dans Dodo R Mi",
            SILENT: "Veuillez dsactiver le mode silencieux sur votre appareil",
            VOLUME: "Augmentez le volume",
            POWER_SAVER: "Assurez-vous que votre appareil n'est PAS en mode conomie d'nergie",
            TEST: "TESTEZ VOTRE AUDIO ",
            GO: "C'est parti!"
        },
        Uhe = {
            ALT: Nhe,
            ARIA: xhe,
            BEATMAPS: Phe,
            COUNT_IN: Rhe,
            CREDITS: Mhe,
            RESULTS: Dhe,
            DIFFICULTY: $he,
            MENU: Lhe,
            WELCOME: Fhe
        },
        Bhe = {
            AVATARS: {
                0: "uccello calmo di colore verde chiaro con un'unica piuma verde scuro sulla testa",
                1: "uccello punk di colore giallo con piume gialle che sembrano un taglio alla moicana",
                2: "uccello splendido di colore verde acqua con piume gialle rotonde sulla testa e sulla coda",
                3: "uccello sinuoso di colore rosso con una testa a punta e una coda nera arricciata",
                4: "uccello di colore verde con un ciuffo e le ali gialle",
                5: "uccello selvatico di colore magenta con piume arruffate rosa chiaro in testa",
                6: "uccello vistoso di colore bianco con piume nere ad angolo come sopracciglia",
                7: "uccello appariscente di colore viola con piume all'ins sulla testa e una grande coda arricciata",
                8: "uccello calmo di colore marrone con una coda di volpe",
                9: "uccello carino di colore rosa con una coda che ricorda dei coni gelato",
                10: "uccello maldestro di colore blu con capelli perfetti",
                11: "uccello emo di colore rosa con piume pettinate in avanti sulla testa"
            },
            CHANGE_AVATAR: "Cambia avatar",
            LOGO: "il logo di Dodo Re Mi"
        },
        qhe = {
            CHANGE_AVATAR: "cambia avatar",
            SONG_DOWN: "scorri alla canzone successiva {songName}",
            SONG_UP: "scorri alla canzone precedente {songName}",
            SELECT_SONG: "seleziona canzone {songName}"
        },
        jhe = {
            BASS: "Basso",
            MELODY: "Melodia",
            COUNTER: "Controcanto",
            DRUMS: "Batteria",
            PERCUSSION: "Percussioni",
            HARMONY: "Armonia",
            SIGNATURE: "Alterazione"
        },
        Vhe = {
            WHEN: "Quando lo schermo dice di",
            GET_READY: "Preparati",
            TAP_HERE: "CLICCA[break][/break]QUI[break][/break][info](O PREMI LA BARRA SPAZIATRICE)[/info]",
            TAP: "clicca",
            SYNCED: "sincronizzato",
            SYNCING: "Sincronizzazione"
        },
        Ghe = {
            SHARE: "Condividi la musica"
        },
        Whe = {
            SURVIVED: "Se l' cavata",
            EATEN: " stat mangiat"
        },
        Hhe = {
            VERY_EASY: "Facilissima",
            EASY: "Facile",
            MEDIUM: "Media",
            HARD: "Difficile",
            VERY_HARD: "Difficilissima"
        },
        Khe = {
            BACK_TO_MENU: "Torna al menu di gioco",
            BEST_SCORE: "Miglior punteggio",
            CHANGE_HOST: "Cambia[break][/break]ospite?",
            CHOOSE_HOST: "Scegli un nuovo ospite",
            CHOOSE_INSTRUMENT: "Scegli strumento",
            CHOOSE_SONG: "Scegli canzone",
            COMPLETED_PARTS: "Parti sopravvissute",
            DIFFICULTY: "Difficolt",
            END_SESSION: "Termina sessione",
            LANES: "Corsie",
            LOADING: "Caricamento",
            NEVERMIND: "Non importa",
            NEW_SONG: "Nuova canzone",
            RETRY_SONG: "Riprova canzone",
            SELECT_SONG: "Seleziona canzone",
            SONG_PART: "Parte della canzone",
            START_SONG: "Avvia canzone",
            TEST_IT: "Provala",
            THANKS: "Grazie per aver scelto di giocare con noi",
            VOTE_SONG: "Vota una canzone",
            WAITING_FOR: "In attesa di {vipName}",
            WHAT_NEXT: "Che si fa dopo?"
        },
        Yhe = {
            WELCOME: "Ti diamo il benvenuto a Dodo Re Mi",
            SILENT: "Disattiva la modalit silenziosa sul dispositivo",
            VOLUME: "Alza il volume",
            POWER_SAVER: "Assicurati che il dispositivo NON sia in modalit di risparmio energetico",
            TEST: "PROVA L'AUDIO ",
            GO: "Iniziamo"
        },
        zhe = {
            ALT: Bhe,
            ARIA: qhe,
            BEATMAPS: jhe,
            COUNT_IN: Vhe,
            CREDITS: Ghe,
            RESULTS: Whe,
            DIFFICULTY: Hhe,
            MENU: Khe,
            WELCOME: Yhe
        },
        Zhe = {
            AVATARS: {
                0: "ruhiger hellgrner Vogel mit einer einzigen dunklen Feder auf dem Kopf",
                1: "punkiger gelber Vogel mit gelben Federn, die wir ein Irokesenschnitt aussehen",
                2: "schicker trkiser Vogel mit runden, gelben Federn auf dem Kopf sowie einem Schwanz",
                3: "geschmeidiger roter Vogel mit einem spitzen Kopf und einem lockigen schwarzen Schwanz",
                4: "grner Vogel mit gelben Flgeln",
                5: "wilder magentafarbener Vogel mit ungegltteten hellrosa Federn auf dem Kopf",
                6: "dramatisch aussehender weier Vogel mit rechteckigen schwarzen Federn als Augenbrauen",
                7: "extravaganter lila Vogel mit nach vorne zeigenden Federn auf dem Kopf sowie einem groen, gelockten Schwanz",
                8: "entspannter brauner Vogel mit einem Fuchsartigen Schwanz",
                9: "niedlicher rosa Vogel mit einem Schwanz, der wie Eiswaffeln aussieht",
                10: "einfltig aussehender blauer Vogel mit perfektem Federkleid",
                11: "rosa Emo-Vogel, dessen Kopffedern nach vorn gebrstet sind"
            },
            CHANGE_AVATAR: "Avatar wechseln",
            LOGO: "das Dodo Re Mi-Logo "
        },
        Xhe = {
            CHANGE_AVATAR: "Avatar wechseln",
            SONG_DOWN: "Zum nchsten Lied scrollen: {songName}",
            SONG_UP: "Zum vorigen Lied scrollen: {songName}",
            SELECT_SONG: "Lied auswhlen: {songName}"
        },
        Jhe = {
            BASS: "Bass",
            MELODY: "Melodie",
            COUNTER: "Gegenstimme",
            DRUMS: "Schlagzeug",
            PERCUSSION: "Perkussion",
            HARMONY: "Harmonie",
            SIGNATURE: "Sonderinstrument"
        },
        Qhe = {
            WHEN: "Wenn auf dem Bildschirm steht:",
            GET_READY: "Bereitmachen",
            TAP_HERE: "DRCKE[break][/break]HIER[break][/break][info](ODER DRCKE DIE LEERTASTE)[/info]",
            TAP: "DRCK",
            SYNCED: "Synchronisiert",
            SYNCING: "Synchronisierung luft"
        },
        efe = {
            SHARE: "Teile eure Musik"
        },
        tfe = {
            SURVIVED: "berlebt",
            EATEN: "Gefressen"
        },
        nfe = {
            VERY_EASY: "Supereinfach",
            EASY: "Einfach",
            MEDIUM: "Mittel",
            HARD: "Schwer",
            VERY_HARD: "Superschwer"
        },
        rfe = {
            BACK_TO_MENU: "Zurck zum Spielmen",
            BEST_SCORE: "Bester Punktestand",
            CHANGE_HOST: "Gastgeber[break][/break]wechseln?",
            CHOOSE_HOST: "Neuen Gastgeber whlen",
            CHOOSE_INSTRUMENT: "Instrument whlen",
            CHOOSE_SONG: "Lied whlen",
            COMPLETED_PARTS: "berlebte Abschnitte",
            DIFFICULTY: "Schwierigkeitsgrad",
            END_SESSION: "Konzert beenden",
            LANES: "Spuren",
            LOADING: "Lade",
            NEVERMIND: "Schon gut",
            NEW_SONG: "Neues Lied",
            RETRY_SONG: "Lied erneut versuchen",
            SELECT_SONG: "Lied auswhlen",
            SONG_PART: "Lied-Abschnitt",
            START_SONG: "Lied starten",
            TEST_IT: "Ausprobieren",
            THANKS: "Danke frs Spielen",
            VOTE_SONG: "Stimme fr ein Lied ab",
            WAITING_FOR: "Warte auf {vipName}",
            WHAT_NEXT: "Was jetzt?"
        },
        sfe = {
            WELCOME: "Willkommen zu Dodo Re Mi",
            SILENT: "Bitte stelle sicher, dass dein Gert nicht stumm geschaltet ist",
            VOLUME: "Mach dein Gert LAUTER",
            POWER_SAVER: "Stell sicher, dass dein Gert NICHT im Akkusparmodus ist",
            TEST: "TESTE DEINE AUDIOAUSGABE ",
            GO: "Los geht's"
        },
        ife = {
            ALT: Zhe,
            ARIA: Xhe,
            BEATMAPS: Jhe,
            COUNT_IN: Qhe,
            CREDITS: efe,
            RESULTS: tfe,
            DIFFICULTY: nfe,
            MENU: rfe,
            WELCOME: sfe
        },
        ofe = {
            AVATARS: {
                0: "pjaro sereno de color verde claro con una sola pluma verde oscuro en la cabeza",
                1: "pjaro amarillo macarra con plumas amarillas que parecen un peinado mohicano",
                2: "pjaro elegante con plumas amarillas redondas en la cabeza y la cola",
                3: "pjaro rojo distinguido con la cabeza puntiaguda y una cola negra rizada",
                4: "pjaro verde con muchas plumas y alas amarillas",
                5: "pjaro silvestre magenta con plumas rosa claro despeinadas en la cabeza",
                6: "pjaro blanco dramtico con plumas negras angulares a modo de ceja",
                7: "pjaro morado extravagante con plumas hacia delante en la cabeza y una gran cola rizada",
                8: "pjaro marrn tranquilo con cola de zorro",
                9: "pjaro rosa bonito con una cola que parece unos cucuruchos de helado",
                10: "pjaro azul tontorrn con un peinado ideal",
                11: "pjaro rosa emo con plumas peinadas hacia delante en la cabeza"
            },
            CHANGE_AVATAR: "Cambiar avatar",
            LOGO: "el logotipo de Dodo Re Mi"
        },
        afe = {
            CHANGE_AVATAR: "cambiar avatar",
            SONG_DOWN: "ir a la cancin siguiente {songName}",
            SONG_UP: "volver a la cancin anterior {songName}",
            SELECT_SONG: "elegir cancin {songName}"
        },
        cfe = {
            BASS: "Bajo",
            MELODY: "Meloda",
            COUNTER: "Contrapunto",
            DRUMS: "Batera",
            PERCUSSION: "Percusin",
            HARMONY: "Armona",
            SIGNATURE: "Comps"
        },
        lfe = {
            WHEN: "Cuando lo indique la pantalla",
            GET_READY: "Preprate",
            TAP_HERE: "TOCA[break][/break]AQU[break][/break][info](O DALE A LA BARRA ESPACIADORA)[/info]",
            TAP: "toque",
            SYNCED: "sincronizado",
            SYNCING: "Sincronizando"
        },
        ufe = {
            SHARE: "Compartir la msica"
        },
        hfe = {
            SURVIVED: "Superviviente",
            EATEN: "Devorado"
        },
        ffe = {
            VERY_EASY: "Muy fcil",
            EASY: "Fcil",
            MEDIUM: "Normal",
            HARD: "Difcil",
            VERY_HARD: "Muy difcil"
        },
        dfe = {
            BACK_TO_MENU: "Volver al men del juego",
            BEST_SCORE: "Mejor puntuacin",
            CHANGE_HOST: "Cambiar[break][/break]anfitrin?",
            CHOOSE_HOST: "Elige un nuevo anfitrin",
            CHOOSE_INSTRUMENT: "Elegir instrumento",
            CHOOSE_SONG: "Elegir cancin",
            COMPLETED_PARTS: "Partes sobrevividas",
            DIFFICULTY: "Dificultad",
            END_SESSION: "Finalizar sesin",
            LANES: "Pistas",
            LOADING: "Cargando",
            NEVERMIND: "Da igual",
            NEW_SONG: "Nueva cancin",
            RETRY_SONG: "Volver a intentar",
            SELECT_SONG: "Seleccionar cancin",
            SONG_PART: "Parte de la cancin",
            START_SONG: "Empezar cancin",
            TEST_IT: "Probar",
            THANKS: "Gracias por jugar",
            VOTE_SONG: "Vota una cancin",
            WAITING_FOR: "Esperando a {vipName}",
            WHAT_NEXT: "Qu hay a continuacin?"
        },
        pfe = {
            WELCOME: "Os doy la bienvenida a Dodo Re Mi",
            SILENT: "Desactivad el modo silencio de vuestro dispositivo",
            VOLUME: "Y SUBID bien el volumen",
            POWER_SAVER: "Aseguraos de que vuestro dispositivo NO est en modo ahorro de energa",
            TEST: "PROBAD EL SONIDO ",
            GO: "Vamos"
        },
        mfe = {
            ALT: ofe,
            ARIA: afe,
            BEATMAPS: cfe,
            COUNT_IN: lfe,
            CREDITS: ufe,
            RESULTS: hfe,
            DIFFICULTY: ffe,
            MENU: dfe,
            WELCOME: pfe
        },
        gfe = {
            AVATARS: {
                0: "ave tranquila de color verde claro con una sola pluma verde oscura en la cabeza",
                1: "ave amarilla con plumas amarillas en forma de cresta punk",
                2: "ave distinguida verde azulada con plumas amarillas en la cabeza y cola",
                3: "ave roja elegante con la cabeza puntiaguda y cola negra enrulada",
                4: "ave verde con copete y alas amarillas",
                5: "ave magenta con tonos rosados y plumas alborotadas en la cabeza",
                6: "ave blanca impresionante con cejas angulares de plumas negras",
                7: "ave violeta llamativa con plumas hacia adelante en la cabeza y una cola larga y enrulada",
                8: "ave marrn tranquila con cola de zorro",
                9: "ave rosa adorable con una cola que parece un cono de helado",
                10: "ave azul tonta con cabello perfecto",
                11: "ave rosa rebelde con plumas peinadas hacia adelante en la cabeza"
            },
            CHANGE_AVATAR: "Cambiar avatar",
            LOGO: "el logotipo de Dodo Re Mi"
        },
        _fe = {
            CHANGE_AVATAR: "cambiar avatar",
            SONG_DOWN: "avanza a la siguiente cancin {songName}",
            SONG_UP: "retrocede a la siguiente cancin {songName}",
            SELECT_SONG: "elige la cancin {songName}"
        },
        yfe = {
            BASS: "Bajo",
            MELODY: "Meloda",
            COUNTER: "Contra",
            DRUMS: "Batera",
            PERCUSSION: "Percusin",
            HARMONY: "Armona",
            SIGNATURE: "Armadura"
        },
        vfe = {
            WHEN: "Cuando la pantalla dice",
            GET_READY: "Preprate",
            TAP_HERE: "TOCA[break][/break]AQU[break][/break][info](O TOCA LA BARRA ESPACIADORA)[/info]",
            TAP: "toca",
            SYNCED: "sincronizado",
            SYNCING: "Sincronizando"
        },
        bfe = {
            SHARE: "Comparte la msica"
        },
        Efe = {
            SURVIVED: "Sobreviviste",
            EATEN: "Te comieron"
        },
        Tfe = {
            VERY_EASY: "Superfcil",
            EASY: "Fcil",
            MEDIUM: "Medio",
            HARD: "Difcil",
            VERY_HARD: "Superdifcil"
        },
        Sfe = {
            BACK_TO_MENU: "Volver al men del juego",
            BEST_SCORE: "Mejor puntuacin",
            CHANGE_HOST: "Cambiar[break][/break]anfitrin?",
            CHOOSE_HOST: "Elegir nuevo anfitrin",
            CHOOSE_INSTRUMENT: "Elige un instrumento",
            CHOOSE_SONG: "Elige una cancin",
            COMPLETED_PARTS: "Partes sobrevividas",
            DIFFICULTY: "Dificultad",
            END_SESSION: "Finalizar sesin",
            LANES: "Pistas",
            LOADING: "Cargando",
            NEVERMIND: "Olvidar",
            NEW_SONG: "Nueva cancin",
            RETRY_SONG: "Volver a intentar la cancin",
            SELECT_SONG: "Elegir la cancin",
            SONG_PART: "Parte de la cancin",
            START_SONG: "Comenzar cancin",
            TEST_IT: "Intento de prueba",
            THANKS: "Gracias por jugar",
            VOTE_SONG: "Votar por una cancin",
            WAITING_FOR: "Esperando a {vipName}",
            WHAT_NEXT: "Qu sigue?"
        },
        wfe = {
            WELCOME: "Bienvenidos a Dodo Re Mi",
            SILENT: "Quita el modo silencioso de tu dispositivo",
            VOLUME: "SUBE el volumen",
            POWER_SAVER: "Asegrate de que tu dispositivo NO est usando ahorro de batera",
            TEST: "PRUEBA TU SONIDO ",
            GO: "Vamos"
        },
        Ofe = {
            ALT: gfe,
            ARIA: _fe,
            BEATMAPS: yfe,
            COUNT_IN: vfe,
            CREDITS: bfe,
            RESULTS: Efe,
            DIFFICULTY: Tfe,
            MENU: Sfe,
            WELCOME: wfe
        },
        Afe = {
            en: Ihe,
            fr: Uhe,
            it: zhe,
            de: ife,
            es: mfe,
            "es-XL": Ofe
        },
        Cfe = mt({
            props: {
                avatar: {
                    type: Number,
                    required: !0
                }
            }
        }),
        bt = t => (Ns("data-v-762a6505"), t = t(), xs(), t),
        kfe = bt(() => B("path", {
            class: "legs",
            d: "m260.33,479.5c.14,9.96-15.51,9.97-15.36,0,0,0,0-69.65,0-69.65h15.36v69.65Zm45.85-69.65h-15.49v69.65c0,4.24,3.44,7.68,7.68,7.68s7.68-3.44,7.68-7.68l.13-69.65Z"
        }, null, -1)),
        Ife = {
            class: "dancer"
        },
        Nfe = {
            key: 0
        },
        xfe = bt(() => B("path", {
            class: "body",
            d: "m427.34,191.3c-31.47-32.8-78.21-44.55-122.57-35.13-107.61,20.57-142.69,175.09-176.04,263.77,40.53,20.16,86.68,26.16,131.6,24.48,40.59-.35,85.58-5.03,121.13-23.13,85.67-37.54,106.25-162.21,45.88-229.98"
        }, null, -1)),
        Pfe = bt(() => B("path", {
            class: "feathers",
            d: "m91.21,270.01c-14.4-23.74-23.13-39.67-26.2-47.8-13.81,47.97-3.21,102.5,25.15,143.21-14.53-7.92-28.44-16.34-41.47-25.82,7.83,39.15,45.74,69,83.16,81.3,0,0,12.37-46.11,20.31-68.63-27.13-32.83-47.45-60.25-60.95-82.26m141.58,11.04c-67.49-1.5-131.89,229.74-27.26,87.83-.19,4.84-6.88,27.27-2.78,30.81,13.63,7.21,40.81-25.98,47.61-36.28,6.28-10.33,11.81-21.51,14.88-33.31,4.93-22.08-7.48-49.46-32.44-49.05m74.29-176.81c-4.9-17.55-9.09-40.99-26.39-49.82-18.45-7.86-31.49,15.17-24.67,30.91,1.85,4.86,6.08,11.01,12.67,18.43,19.77,19.58,31.8,37.05,36.09,52.41-.14,1.98,5.89-.63,7.68-.34-.18-15.36-2.8-40.04-5.38-51.58Z"
        }, null, -1)),
        Rfe = [xfe, Pfe],
        Mfe = {
            key: 1
        },
        Dfe = bt(() => B("path", {
            class: "body",
            d: "m341.25,153.29c-38.56-1.39-79.06,10.63-104.91,40.51-57.31,63.16-79.73,147.99-108.6,226.14,41.16,19.52,87.26,26.43,132.6,24.48,40.58-.35,85.58-5.04,121.13-23.13,121.51-54.31,102.75-263.79-40.22-267.99"
        }, null, -1)),
        $fe = bt(() => B("path", {
            class: "feathers",
            d: "m109.06,219.14c2.5-5.46-5.75-4.52-9.79-4.03-39.06,7.01-61.12,54.76-56.25,92.05-10.25-10.47-21.39-18.52-38.49-23.61-1.06,67.22,62.63,119.11,124.2,136.4,2.69-8,5.44-15.97,8.25-23.9-39.64-30.25-28.75-114.47,21.6-125.36-18.53-30.58-55.85-19.23-67.38,10.27.68-21.55,7.69-42.59,17.85-61.81m102.42,62.49c-18.35,3.35-34.86,26.3-42.33,44.35l-.19.1c6.44-2.87,12.27-5.83,19.39-9.98-21.03,34.19-27.3,44.35-32.44,53.46.63-.75-4.81,9.27-.86,6.72,8.01-3.54,16.45-5.93,24.09-10.17-2.68,4.18-30.04,48.15-32.06,50.87,3.15,5.9,23.87-3.26,31.67-5.57,26.97-10.75,40.36-14.32,58.26-31.68,33.96-27.61,29.19-109.02-25.53-98.1m97.23-249.52c.05-8.48-8.66,3.14-10.27,4.42-26.13,30.97-44.83,73.77-50.1,113.07-4-22.91-5.67-51.71-7.97-73.62-1.08-1.87-2.69-1.12-3.74.67-20.11,31.18-32.02,77.36-29.56,118.83-2.19-2.56-9.77-28.42-14.59-26.78-12.68,16.3-9.49,63.01,7.1,76.12,32.21-56.04,73.46-93.81,141.67-90.51,3.25-43.42,14.66-93.2,32.73-129.29,1.15-2.18,1.15-3.62,0-4.32-35.94,14.1-58.18,56.83-71.12,94.16.45-27.58,2.4-55.16,5.86-82.74Z"
        }, null, -1)),
        Lfe = [Dfe, $fe],
        Ffe = {
            key: 2
        },
        Ufe = bt(() => B("path", {
            class: "body",
            d: "m351.9,153.06c-145.64-15.71-184.78,160.75-224.16,266.88,89.43,38.11,223.82,39.36,297.02-31.42,70.05-74.69,38.65-225.27-72.85-235.46"
        }, null, -1)),
        Bfe = bt(() => B("path", {
            class: "feathers",
            d: "m113.47,246.69c-35.76-6.86-45.17,27.33-34.07,56.15-55.31-80.2-106.43,21.56-23.32,54.52-32.26-8.59-45.14,25.83-20.93,44.63,24.52,17.96,67.15,21.49,106.26,23.8l-12.67-5.86c.45-1.41,23.77-68.79,25.05-72.37-6.65-15.19-11.54-31.26-16.03-47.13-6.5-17.76-4.85-45.92-24.28-53.75m170.18,86.68c-2.51-10.55-4.98-18.29-9.69-26.3.7,1.66-80.95-2.59-74.68-7.97-15.37,9.52-35.22,22.73-42.14,39.16-11.36,22.64,12.88,37.22,32.25,24.86-29.74,49.46,39.51,65.92,45.21,8.16,8.34,55.32,69.47,40.79,49.05-37.91m80.44-177.38c33.47-101.26-65.61-124.6-59.32-41.85-13.57-88.04-114.45-68.93-60.76,22.27-47.46-62.94-91.28,31.16-17.66,68.92,33.85-47.51,91.74-58.07,137.74-49.34Z"
        }, null, -1)),
        qfe = bt(() => B("path", {
            class: "feathers top",
            d: "m113.09,283.64c-11.66-9.82-20.87,2.23-21.4,15.84-2.52,11.61,10.17,38.26,15.93,45.5-8.19-8.89-16.8-16.89-25.82-24-14.93-9.86-17.88-18.87-31.48-12.29-24.95,23.13,25.18,53.01,47.8,63.93-19.74-2.81-53.5-15.77-53.75,12.48,2.89,24.52,63.86,26.44,85.81,30.62,6.53-19.13,13.15-38.23,19.87-57.3-9.24-22.94-33.37-75.14-36.95-74.77m162.79,28.8c-13.93-42.75-71.8-26.05-92.14,1.83-21.19,24.14,3.54,44.63,25.05,20.44-27.69,53.52,25.56,52.2,27.64-3.17,5.59,51.37,62.08,38.4,39.45-19.1m-9.69-142.64c-12.78-8.26-26.29-22.61-41.66-22.37-8.73,1.79-12.37,10.44-12.29,19.97.19,9.66,7.39,19.39,21.6,29.18,9.47-10.69,19.83-20.23,32.35-26.78m9.21-71.32c-38.71-1.94-22.95,39.69-4.51,68.92,12.13-5.97,25.37-10.09,38.97-12.19-11.64-26.16-14.25-50.99-34.46-56.73m74.29,7.77c-26.28-31.77-36.59,28.66-37.63,48.66,13.13-1.8,26.98-2.43,39.83-.86,2.9-14.29,6.18-36.66-2.21-47.8Z"
        }, null, -1)),
        jfe = [Ufe, Bfe, qfe],
        Vfe = {
            key: 3
        },
        Gfe = bt(() => B("path", {
            class: "body",
            d: "m218.19,214.53c-2.01,3.1-8.51,12.63-10.27,15.65h-.19l.1.1-1.34,2.11c.13-.13.26-.26.38-.38-36.49,57.91-56.56,123.97-79.13,187.94,45.57,23.03,98.75,26.56,149.01,24.09,55.1-1.7,113.65-15.19,150.6-57.3,41.89-47.62,45.66-127.64,11.71-180.16-37.62-55.4-91.5-94.41-141.87-134-2.55,36.93-61.38,111.5-79,141.96"
        }, null, -1)),
        Wfe = bt(() => B("path", {
            class: "feathers",
            d: "m149.66,293.53c-36.47-63.88-136.29-26.41-129.96,43.87,5.24,58.16,71.55,74.35,119.5,87.35l-10.46-4.8c1.47-4.29,2.94-8.54,4.42-12.77-30.44-9.38-86.83-38.82-57.21-76.21,12.46-14.48,21.62-18.29,36.67-18.81,18.61-.52,23.87,13.07,11.23,26.11-4.66,5.37-16.09,6.29-24.48,6.05-6.27-1.15-4.03.83,6.72,5.95,11.46,6.39,23.46,2.01,31.58-7.1,13.11-12.5,21.09-32.75,12-49.62m100.11-14.21c-.64-3.01-1.54-5.7-2.69-8.06-22.95,16.23-44.73,30.18-59.41,52.89-10.37,15.58-17.59,33.56-20.25,52.02-.1,7.77-5.13,21.57-1.73,27.84,53.71-15.65,98.83-66.1,84.08-124.69"
        }, null, -1)),
        Hfe = [Gfe, Wfe],
        Kfe = {
            key: 4
        },
        Yfe = bt(() => B("path", {
            class: "body",
            d: "m236.81,193.32c-25.47,27.04-43.71,59.29-58.65,93.01.62,4.16-33.49,89.64-44.92,93.11-91.3,60.83,6.69,77.13,46.26,58.26,59.52,12.23,147.51,10.47,201.95-16.41,88.43-38.42,108.35-172.68,38.49-236.8,15.99-26.52,13.5-68-9.21-89.56-.83,0-1.67.67-2.5,2.02-4.99,8.77-11.1,16.54-18.33,23.32-.53-18.07-16.16-50.56-31.67-61.34-23.32,43.95-87.93,93.72-121.42,134.38"
        }, null, -1)),
        zfe = bt(() => B("path", {
            class: "feathers",
            d: "m125.95,386.92c2.69-2.94,5.12-5.44,7.29-7.49-25.92,22.78-53.87,32.94-89.07,39.55-2.35.51-3.73.72-4.22,2.69,15.36,7.61,22.66,9.68,38.3,9.98,19.43,23.65,67.84,17.75,93.01,9.5-4.3,1.11-18.17,3.42-23.61,2.78-11.83-.19-36.01-5.54-15.36-17.28,9.01-5.54-11.97-1.77-19.01-3.94-15.2-3.06-16.9-3.87-6.34-14.59,8.02-8.31,11.21-13.04,19-21.21m115.47-52.12c19.73-22.74,8.47-65.6-22.75-69.3-17.45-2.73-28.01,9.35-40.51,20.83-10.28,9.48-29.76,29-43.58,42.91-31.37,36.38,62.93,46.26,80.34,32.35,10.17-7.68,19-16.61,26.49-26.78"
        }, null, -1)),
        Zfe = bt(() => B("path", {
            class: "feathers top",
            d: "m129.7,344.21c-.38-3.78,1.25-8.77,4.9-14.97-13.25,13.12-24.16,23.26-32.73,30.43-3.08,3.03-12.92,9.59-12.67,13.82,5.11,18.76,51.8-.95,64.79-9.21-20.41,22.94-2.16,24.48,17.85,18.81,15.42-4.24,30.06-11.63,43.1-21.5-25.22,10.86-45.21,9.97-34.84-21.21-11.24,5.83-19.16,11.6-30.33,12.86-8.86.91-18.5.02-20.06-9.02m50.68-4.51c-.06.19-.16.42-.29.67.06-.06.16-.13.29-.19v-.48Z"
        }, null, -1)),
        Xfe = [Yfe, zfe, Zfe],
        Jfe = {
            key: 5
        },
        Qfe = bt(() => B("path", {
            class: "body",
            d: "m210.84,442.81c56.23,3.81,119.7,3.04,170.61-21.7,127.76-57.95,98.22-278.38-53.96-267.87-124.91,2.33-161.79,162.01-198.83,266.52-.26.73,5.97,2.68,6.82,3.07,0,0,75.37,19.97,75.37,19.97Z"
        }, null, -1)),
        ede = bt(() => B("path", {
            class: "feathers",
            d: "m69.51,236.77c-6.08-11.91-11.43-24.16-16.03-36.77-.45-1.22-1.28-1.6-2.5-1.15-6.1,32.73-6.78,67.49.67,99.95,29.91,33.07,59.43,58.91,83.91,84.78v.1c-36.59-23-90.98-58.41-135.56-86.12l4.61,12.1-.1-.58c8.02,18.4,14.88,40.8,32.26,52.52,30.96,15.16,62.04,22.62,95.72,32.07l-126.44-11.04c6.25,8.57,24.48,21.37,33.03,26.69,23.12,4.87,62.57-5.34,92.55-7.59-13.84,4.1-22.19,6.91-44.84,12.87-25.53,7.9-35.73,6.36-51.94,15.46,18.83,3.91,37.99,7.04,56.93,10.56,2.05.58,3.97.29,5.76-.86,10.69-6.66,21.47-13.12,32.36-19.39l-1.25-.58c5.31-15.68,10.72-31.33,16.23-46.95-15.75-25.47-62.28-109.7-75.37-136.05m184.05,165.23c10.01,10.73,1.55-48.09,1.54-52.23,2.76-9.07-58.64-42.27-66.82-43.4-.75-.78-3.22,1.31-3.26,2.59-21.55,38.38-45.37,105.85-65,151.89-5.42,14.97,35.22-28.17,37.93-29.09,7.42-7.62,18.05-15.61,23.81-23.91,3.93-19.53,4.6-47.2,6.14-66.63,3.29,43.42,4.8,65.46,9.5,99.66,1.16,3.18,2.05,28.71,5.95,20.93,11.7-25.41,16.85-52.07,22.75-76.91-.26-3.69-.83-4.18-2.98-8.83-4.84-11.49-7.08-21.11-13.35-31.88,14.42,19.85,29.11,39.13,43.78,57.8m3.36-226.97c3.2-2.11,6.5-4.03,9.89-5.76-76.57-56.32-89.3-76.68-161.39-47.24,46.55,20.93,91.14,32.88,138.64,62.31-61.65-16.4-66.5-17.49-99.37,3.46-7.23,4.03-20.29,13.06-39.17,27.07,31.02-6.67,82.11-7.93,120.11-8.93,9.11-11.37,19.6-22.5,31.3-30.92m45.12-53c-8.19-27.91-14.05-45.6-17.57-53.09-5.21-14.4-55.62-48.65-66.63-57.7-3.28-2.83-5.22-3.03-6.82-6.05-.77-1.09-.74-.7.1,1.15,11.19,21.92,49.99,96.01,65.29,133.65,12.61,29.19,9.12,26.05-10.46-9.41-34.28-66.82-60.17-72.27-117.23-75.75,38.17,29.82,89,75.59,118.96,113.96,13.94-7.46,29.6-12.23,45.51-14.31-3.46-8.13-7.17-18.95-11.14-32.45Z"
        }, null, -1)),
        tde = [Qfe, ede],
        nde = {
            key: 6
        },
        rde = bt(() => B("path", {
            class: "body",
            d: "m279.24,163.66c-94.04,38.57-119.14,172.16-150.5,256.28,40.52,20.19,86.68,26.14,131.6,24.48,40.58-.35,85.58-5.04,121.13-23.13,89.04-38.68,108.55-174.44,37.15-238.04,0,0-52.8-55.08-139.37-19.58Z"
        }, null, -1)),
        sde = bt(() => B("path", {
            class: "feathers",
            d: "m89.48,240.93c-15.29-20,19.54,103.96,24.96,131.79l-106.16-10.85c-2.18-.13-3.42.42-3.74,1.63-.32,1.15.51,2.21,2.5,3.17,56.28,27.25,78.63,38.72,125.16,54.9l-3.46-1.63c7.55-22.14,15.2-44.25,22.94-66.33-.58-1.09-1.18-2.21-1.82-3.36l-60.37-109.33m110,41.95l1.92,26.4c-13.79,22.54-35.56,62.51-46.84,84.76-.89,2.37-2.72,6.21-5.47,11.52-2.75,5.31-2.37,6.14,1.15,2.5s12.16-9.79,25.92-18.43c13.55-8.07,69.55-45.6,80.24-51.26-8.25-14.69-36.13-39.68-56.92-55.48m116.62-128.53c-38.44-20.67-78.72-41.12-112.11-54.71,12.58,19.44,52.13,46.81,75.25,64.02,46.91,33.09,55.9,37.67,111.34,74.1,25.45-43.3,55.02-106.52,55.58-157.7-9.4,16.01-55.43,94.59-63.83,108.75-17.53-8.83-39.61-20.32-66.23-34.46Z"
        }, null, -1)),
        ide = [rde, sde],
        ode = {
            key: 7
        },
        ade = bt(() => B("path", {
            class: "body",
            d: "m427.34,191.3c-3.93-4.1-24.27-43.38-24.27-43.38l-12.67,17.12c-177.99-49.1-214.07,124.01-261.67,254.9,76.87,34.7,175.82,33.8,252.73,1.35,85.67-37.55,106.25-162.22,45.88-229.99"
        }, null, -1)),
        cde = bt(() => B("path", {
            class: "feathers",
            d: "m252.65,330.67c-.89-4.25,4.64-7.56,6.43-2.98,1.17,3.77-.51,18.08-.19,28.32,3.82,10.62,19.04,17.95,28.41,9.5,11.85-12.62,8.2-33.24,6.14-52.02-3.07-41.9-77.78-31.47-114.03-28.99-21.54,2.88-37.88,19.02-43.19,40.12-2.84,13.98-4.55,36.58,10.84,43.19,8.6,4,21.41-2.57,24.09-12.19,1.16-6.18-.1-20.03-.58-26.11-.71-5.9,6.44-5.67,5.86-.1.71,10.39-1.9,21.55,2.21,31.39,3.68,10.54,17.88,12.96,25.92,5.76,11.01-8.2,5.84-28.29,7.01-40.03,1.46-2.64,5.15-2.13,7.01-.1h-.19c1.26,12.97-4.11,30.53,7.01,40.12,11.08,8.7,25.07,2.28,27.36-11.14,0,0-.1-24.76-.1-24.76m-18.43-143.4c-5.47,12.61-7.58,13.09-7.01,17.85l.58-.1v-.38c64.9-65.28,104.61-6.53,177.28-22.08-5.12-7.53-5.21-18.59-4.13-27.55,4.6-1.13,1.62,2.86,1.82,5.85.12,6.78.35,15.84,5.18,20.93.83-.26.1.1.1.1,20.17,26.14,55.37,20.23,68.25-9.79,5.93-15.28,3.61-44.77-18.72-42.62-15.78-1.06-30.92,4.21-47.03,2.4-64.37-15.42-142.41-6.61-176.32,55.39M160.12,7.97C-17.74,62.21-69.08,370.46,138.53,424.26l-9.41-4.32c2.11-6.14,4.22-12.29,6.33-18.43-92.51-58.72-102.12-224.9-5.28-280.76,19.54-10.9,61.56-19.46,67.29,7.2-.62,14.86-20.8,20.17-33.12,16.8l-.48,1.54c31.8,21.92,74.81,6.62,104.62-13.24,42.89-26.56,43.68-88.53,3.07-116.91C239.63-5.74,196.6-2.13,160.12,7.97Z"
        }, null, -1)),
        lde = [ade, cde],
        ude = {
            key: 8
        },
        hde = bt(() => B("path", {
            class: "body",
            d: "m427.34,191.3c-169.76-133.72-259.43,94.21-298.61,228.64,76.87,34.7,175.82,33.8,252.73,1.35,85.67-37.55,106.25-162.22,45.88-229.99"
        }, null, -1)),
        fde = bt(() => B("path", {
            class: "feathers",
            d: "m53.77,206.95c-14.84,11.47-32.03,24.91-37.15,42.14,0,.58.1,1.12.29,1.63,17.91-9.5,38.82-6.5,17.66,14.88-90.52,75.1,23.6,135.74,94.16,154.35,1.54-4.54,3.1-9.09,4.7-13.63-70.15-39.32-.62-99.2,24-144.55,40.99-85.66-48.79-97.97-103.67-54.81M372.82,65.37c-18.71-5.95-30.65,16.2-34.36,30.91-2.13,14.27.12,19.63,6.53,38.78-21.17-33.93-55.37-11.29-43.96,21.79,11.6,26.94,38.47,44.71,60.95,61.72,7.44,4.27,15.13,13.57,24.28,9.6,1.15.77,4.61-3.36,10.37-12.38,13.2-21.74,24.77-40.42,32.64-63.83,9.14-28.96-14.31-65.94-31.39-18.62.1-23.91,1.51-57.98-25.05-67.96Z"
        }, null, -1)),
        dde = bt(() => B("path", {
            class: "feathers top",
            d: "m245.82,340.95c5.44-5,6.11-7.18,10.65-11.71,5.58,2.14-19.15,22.58-22.75,28.41-1.48,1.41-35.64,41.3-36.67,40.99,223.36-26.37-65.09-269.62-50.87-27.36,14.51-32.07,31.31-54.8,58.07-77.75l2.3.58c-23.88,20.74-44.08,47.68-60.18,79.57,1.38,7.84,1.25,17.4,5.76,23.61,12.88,4.69,26.95,2.53,43.87,1.44,10.38-14.71,37.56-42.46,49.82-57.78"
        }, null, -1)),
        pde = [hde, fde, dde],
        mde = {
            key: 9
        },
        gde = bt(() => B("path", {
            class: "body",
            d: "m427.34,191.3c-31.47-32.8-78.21-44.55-122.57-35.13-107.61,20.57-142.69,175.09-176.04,263.77,40.53,20.16,86.68,26.16,131.6,24.48,40.59-.35,85.58-5.03,121.13-23.13,85.67-37.54,106.25-162.21,45.88-229.98"
        }, null, -1)),
        _de = bt(() => B("path", {
            class: "feathers",
            d: "m152.25,296.79l.1-.48-.1-.19.19-.19-60.95,5.18c-.55.67,36.59,103.62,36.57,104.34-.38-.86-44.88-99.04-45.21-99.83l-48.47,37.15c-.54.91,94.93,74.25,95.12,74.87,10.52-18.22,19.47-99.49,22.75-120.85m92.15-5.47l-.48-.29-88.11,50.97-6.05,3.46v.1h-.29c21.05,12.82,72.74,44.28,93.11,56.73h.38l1.44-110.96m115.57-190.34c-.1-21.6-29.46-29.99-44.15-16.7-7.52,7.49-21.91,24.83-18.05,33.88l.96-.19c.06-.19.16-.38.29-.58,0-.06.06-.1.19-.1,4.17-9.11,12.59-17.97,23.13-18.72,7.76.07,13.21,9.5,9.21,16.22-6.02,13.51-21.52,6.14-31.48,4.7-2.95,1.02-7.64-.17-10.65,1.06h.77c-8.92,1.79-12.56,5.87-20.54,6.34-10.25.77-19.94-11.87-11.61-20.25,0-.06.03-.1.1-.1,10.51-6.97,24.71,3.65,31,12.19h1.06c2.06-7.6-9.77-17.59-17.28-24.38-14.86-14.78-42.09-8.82-47.32,11.71-4.32,33.31,36.57,48.46,59.41,28.32l3.26,26.01c6.33-2.13,13-3.72,19.68-4.9l-1.92-23.04c22.25,12.91,57.49-2.85,53.94-31.48Z"
        }, null, -1)),
        yde = bt(() => B("path", {
            class: "feathers top",
            d: "m74.89,281.05c-47.97-52.91-107.51,40.7-40.22,62.39l-.29-.29v-.38l48.47-37.15c.02.24.25.67.38.86.38-9.34-2.4-17.82-8.35-25.44m74.48,64.41c-.06.06-.1.13-.1.19-.13,0-.16.06-.1.19-12.81,22.8,14.73,40.89,30.24,19.29-11.83,24.16,16.97,39.93,31.39,17.76-.1-.1-61.38-37.3-61.43-37.43m-4.51-101.27c-38.78-30.78-87.09,21.68-53.37,57.69-.09-.2-.09-.57,0-.77l60.95-5.18-.19.19.1.19-.1.48c11.51-16.08,8.25-40.4-7.39-52.6m96.37,158.86c.33-.37.51-.82.77-1.15l-30.81-18.72v.1c-.13,0-.16.06-.1.19-12.89,22.44,14.76,40.75,30.14,19.58Z"
        }, null, -1)),
        vde = [gde, _de, yde],
        bde = {
            key: 10
        },
        Ede = bt(() => B("path", {
            class: "body",
            d: "m304.87,156.08c-94.26,18.24-129.7,135.36-159.05,214.34-28.49-43.69-51.63-89.82-71.56-136.34l-2.44.81c-18.73,13.21-35.38,31.72-44.06,53.18.1.19,21.13,22.6,21.12,22.84h-.1l-.1.1c26.15,27.64,55.01,56.67,88.69,83.89-2.91,8.36-5.8,16.69-8.64,25.05,54.48,27.37,117.77,27.38,177.19,21.98,46.2-4.96,90.89-20.74,121.42-55.19,79.89-98.68,16.6-258.5-122.48-230.65"
        }, null, -1)),
        Tde = bt(() => B("path", {
            class: "feathers",
            d: "m89.04,403.38c17.26,7.98,27.6,12.45,40.99,16.7,2.75-8.06,5.54-16.13,8.35-24.19-33.66-27.2-62.56-56.27-88.69-83.89l.1-.1h.1l-.1-.19c-11.15,15.21-30.54,39.24-29.37,50.97,17.33,15.15,44.04,29.03,68.63,40.7m42.04-156.07c-.32-.96-.8-1.5-1.44-1.63l-.1-.48c-13.48,6.6-26.19,14.97-39.35,25.92,14.37,31.47,36.86,69.44,56.63,100.31,3.77-10.75,7.38-21.51,11.33-32.16-8.28-29.01-17.06-65.48-27.07-91.95m115.05,122.25c6.13-36.91-27.08-33.22-39.16-6.72,8.07-48.16-29.3-25.38-46.75-1.06-26.41,72.58,4.08,65.57,45.31,7.1-.28,4.96-6.81,27.18-2.78,30.81,12.53,6.73,35.55-20.75,43.39-30.14m135.43-254.8c2.95-43.91-102.06-29.37-125.26-13.73-6.2,3.41-13.67,9.14-11.33,17.38,3.07,20.6,5.14,41.44,6.05,62.49,35.81-27.95,90.1-34.1,131.69-18.24.38-15.93,0-31.9-1.15-47.9Z"
        }, null, -1)),
        Sde = bt(() => B("path", {
            class: "feathers top",
            d: "m260,343.38c16.26-30.58-6.86-74.89-43.87-57.49-29.05,14.9-44.25,46-56.92,76.88,8-11.73,35.66-38.3,46.36-22.56,1.26,3.73,1.06,20.48.38,23.61,12.12-26.55,45.3-30.14,39.16,6.72,6.13-8.51,11.06-17.36,14.88-27.16"
        }, null, -1)),
        wde = [Ede, Tde, Sde],
        Ode = {
            key: 11
        },
        Ade = bt(() => B("path", {
            class: "body",
            d: "m304.87,155.69c-85.74,16.74-119.78,111.87-148.39,183.91-6.33,17.8-12.45,35.72-18.62,53.56-8.48,14.16-18.75,34.65-27.55,47.8-24.06,34.26,7.13,7.01,18.14,1.25.64,1.76-28.12,58.72-21.79,57.88,16.92-11.3,32.49-32.36,46.46-46.55,1.4,2.36,3.01,27.01,7.77,25.44,8.99-13.85,14.43-30.22,19.77-41.47,59.1,12.05,146.8,10.1,200.8-16.6,138.74-67.15,89.2-299.08-76.6-265.21"
        }, null, -1)),
        Cde = bt(() => B("path", {
            class: "eyes emo",
            d: "m439.63,242.46c1.85-14.67-22.74-14.91-22.75,0,0,7.63,20.64,16.7,22.75,0Zm-129.77,5.57c0,14.91,23.17,14.78,22.75,0-.45-15.75-22.75-14.32-22.75,0Z"
        }, null, -1)),
        kde = bt(() => B("path", {
            class: "feathers",
            d: "m276.74,343.92c1.35-1.72,1.91-2.45,1.63-3.94-9.73,4.74-23.71,12.96-41.95,24.67,2.97-3.38,2.62-21.3,5.28-24.86l-29.76,11.04c-2.3.75,10.79-26.92,8.93-26.2l-19.48,1.63,12.86-27.93-.1.48c.79-2.14,1.71-4.69,2.5-6.43-24.13,17.33-45.57,41.59-65.56,62.58v.1c-4.15,6.18,37.59-10.12,38.01-9.21-59.33,95.27-48.45,72.61,30.72,23.61.19,19.01.13,30.52-.19,34.55-.06,4.03.42,5.57,1.44,4.61,18.29-22.35,35.51-39.67,55.67-64.69m115.85-160.58c-.9-.7-.64.35.77,3.17,1.81,3.02,7.33,19.65,9.02,27.07-16.92-11.48-36.93-27.72-53.66-36.28,1.87,3.82,7.79,24.53,8.73,25.34-10.82-5.54-26.29-13.25-35.8-13.53-.26,0-.48.03-.67.1.26.19.54.35.86.48v.1c18.92,11.21,36.79,24.41,53.56,39.16,3.46.81-10.11-24.38-9.79-25.15,21.98,14.47,41.22,33.92,60.76,50.97,2.53-1.85-2.32-13.06-3.74-20.35-.13,0-.64-1.86-.58-1.92-1.79-6.21-3.74-12.32-5.86-18.33,9.02,5.12,17.63,10.24,25.82,15.36,4.88,2.35,1.92-4.41.19-7.1-6.54-12.54-19.62-35.37-33.21-40.31,3.14,4.03,8.06,11.68,14.78,22.94-6.85-6.33-23.64-16.66-31.2-21.69Z"
        }, null, -1)),
        Ide = [Ade, Cde, kde],
        Nde = {
            key: 12
        },
        xde = bt(() => B("path", {
            class: "body",
            d: "m402.51,289.92c0,89.27-38.24,154.39-125.03,154.39s-125.03-65.11-125.03-154.39,51.05-172.02,125.03-172.02,125.03,82.74,125.03,172.02Z"
        }, null, -1)),
        Pde = bt(() => B("path", {
            class: "feathers",
            d: "m236.37,386.86c0,6.79-5.51,12.3-12.3,12.3s-12.3-5.51-12.3-12.3,5.51-12.3,12.3-12.3,12.3,5.51,12.3,12.3Zm-44.51-59.29c-9.06,0-16.4,7.34-16.4,16.4s7.34,16.4,16.4,16.4,16.4-7.34,16.4-16.4-7.34-16.4-16.4-16.4Zm158.83,25.17c-5.13,0-9.28,4.16-9.28,9.28s4.16,9.28,9.28,9.28,9.28-4.16,9.28-9.28-4.16-9.28-9.28-9.28Zm-43.44,46.42c-7.74,0-14.01,6.27-14.01,14.01s6.27,14.01,14.01,14.01,14.01-6.27,14.01-14.01-6.27-14.01-14.01-14.01Zm-63.48-115.75c-5.47,0-9.91,4.44-9.91,9.91s4.44,9.91,9.91,9.91,9.91-4.44,9.91-9.91-4.44-9.91-9.91-9.91Zm53.57,35.27c-8.5,0-15.38,6.89-15.38,15.38s6.89,15.38,15.38,15.38,15.38-6.89,15.38-15.38-6.89-15.38-15.38-15.38Zm-106.49-45.59c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm17.41-101.68c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm62.43,244.03c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm52.32-122.12c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm-66.44,63.85c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm25.37-109.33c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm30.77-112.84c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Z"
        }, null, -1)),
        Rde = [xde, Pde],
        Mde = bt(() => B("path", {
            class: "eyes",
            d: "m439.63,242.46c.33-14.78-23.12-14.9-22.75,0-.4,14.8,23.1,14.68,22.75,0Zm-129.77,5.57c0,14.91,23.17,14.78,22.75,0-.45-15.75-22.75-14.32-22.75,0Z"
        }, null, -1)),
        Dde = bt(() => B("path", {
            class: "beak",
            d: "m345.85,298.42c5.42,46.48,82.83,42.85,88.98-.77l4.13-2.88c2.94-.32,4.77-1.09,5.47-2.3.17-15.23-11.4-29.2-23.04-37.82-30.82-20.14-79.86,6.01-75.54,43.77Z"
        }, null, -1)),
        $de = bt(() => B("path", {
            class: "mouth",
            d: "m437.81,295.45l.19-.19h.19c-1.11-1.38-107.2-1.04-91.76,3.36,24.28.89,66.94-1.43,89.17-1.34-.1-.42.77-.8,1.06-.96.32-.35.56-.69.96-.67.06-.13.13-.19.19-.19Z"
        }, null, -1));

    function Lde(t, e, n, r, s, i) {
        return G(), H("svg", {
            viewBox: "0 0 500 500",
            class: Xe(["avatar", `avatar-${t.avatar}`])
        }, [kfe, B("g", Ife, [t.avatar === 0 ? (G(), H("g", Nfe, Rfe)) : t.avatar === 1 ? (G(), H("g", Mfe, Lfe)) : t.avatar === 2 ? (G(), H("g", Ffe, jfe)) : t.avatar === 3 ? (G(), H("g", Vfe, Hfe)) : t.avatar === 4 ? (G(), H("g", Kfe, Xfe)) : t.avatar === 5 ? (G(), H("g", Jfe, tde)) : t.avatar === 6 ? (G(), H("g", nde, ide)) : t.avatar === 7 ? (G(), H("g", ode, lde)) : t.avatar === 8 ? (G(), H("g", ude, pde)) : t.avatar === 9 ? (G(), H("g", mde, vde)) : t.avatar === 10 ? (G(), H("g", bde, wde)) : t.avatar === 11 ? (G(), H("g", Ode, Ide)) : t.avatar === 99 ? (G(), H("g", Nde, Rde)) : Be("", !0), Mde, Dde, $de])], 2)
    }
    const g0 = ot(Cfe, [
            ["render", Lde],
            ["__scopeId", "data-v-762a6505"]
        ]),
        Fde = mt({
            props: {
                title: {
                    type: String,
                    required: !1
                },
                titleKey: {
                    type: String,
                    required: !1
                }
            },
            emits: {
                didRequestClose: () => !0
            },
            methods: {
                onCloseClick() {
                    this.$emit("didRequestClose")
                }
            }
        }),
        VC = t => (Ns("data-v-626bed06"), t = t(), xs(), t),
        Ude = {
            class: "contents"
        },
        Bde = {
            class: "title-container"
        },
        qde = VC(() => B("svg", {
            class: "bg",
            viewBox: "0 0 400 50",
            preserveAspectRatio: "none"
        }, [B("polygon", {
            class: "shadow",
            points: "15.78 3.27 .78 17.86 0 30.06 13.2 46.13 383.7 48.21 400 31.55 398.45 17.56 385.51 4.46 15.78 3.27"
        }), B("polygon", {
            class: "foreground",
            points: "21.99 0 3.48 19.05 2.73 29.03 21.08 50 378.53 50 397.15 29.76 395.32 19.64 378.53 1.05 21.99 0"
        })], -1)),
        jde = {
            key: 0,
            class: "title"
        },
        Vde = {
            key: 1,
            class: "title"
        },
        Gde = {
            class: "content-container"
        },
        Wde = VC(() => B("svg", {
            class: "bg",
            viewBox: "0 0 400 200",
            preserveAspectRatio: "none"
        }, [B("polygon", {
            class: "shadow",
            points: "30.1 1.94 4.54 19.13 0 180.59 11.36 192.24 386.65 197.78 400 183.64 400 21.35 372.45 5.55 30.1 1.94"
        }), B("polygon", {
            class: "foreground",
            points: "38.91 0 7.38 20.24 7.38 180.87 18.74 194.73 381.82 200 395.46 184.75 394.6 24.12 365.35 2.77 38.91 0"
        })], -1));

    function Hde(t, e, n, r, s, i) {
        const a = On("t");
        return G(), H("div", {
            class: "modal",
            onClick: e[0] || (e[0] = Pi((...c) => t.onCloseClick && t.onCloseClick(...c), ["self"])),
            onKeyup: e[1] || (e[1] = Wy((...c) => t.onCloseClick && t.onCloseClick(...c), ["esc"]))
        }, [B("div", Ude, [B("div", Bde, [qde, t.title ? (G(), H("h3", jde, vt(t.title), 1)) : Be("", !0), t.titleKey ? Ke((G(), H("h3", Vde, null, 512)), [
            [a, t.titleKey]
        ]) : Be("", !0)]), B("div", Gde, [Wde, $M(t.$slots, "default", {}, void 0, !0)])])], 32)
    }
    const GC = ot(Fde, [
            ["render", Hde],
            ["__scopeId", "data-v-626bed06"]
        ]),
        Kde = mt({
            components: {
                AvatarSVG: g0,
                BaseModal: GC
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                players: {
                    type: Object,
                    required: !0
                },
                responseKey: {
                    type: String,
                    required: !0
                }
            },
            emits: {
                didRequestClose: () => !0
            },
            computed: {
                choices() {
                    return Object.keys(this.players).filter(t => !(t === `${this.info.id}` || this.info.inSong && this.players[t].inSong === !1)).map(t => {
                        const e = this.players[t];
                        return {
                            avatar: e.avatar,
                            id: parseInt(t, 10),
                            label: e.name
                        }
                    })
                }
            },
            methods: {
                onCloseClick() {
                    this.$emit("didRequestClose")
                },
                async onChoiceClick(t) {
                    try {
                        await this.$ecast.updateObject(this.responseKey, {
                            changeVip: t
                        })
                    } catch (e) {
                        this.$handleEcastError(e)
                    }
                    this.$emit("didRequestClose")
                }
            }
        }),
        Yde = ["onClick"];

    function zde(t, e, n, r, s, i) {
        const a = st("AvatarSVG"),
            c = st("BaseModal"),
            u = On("t");
        return G(), Ut(c, {
            "title-key": "MENU.CHOOSE_HOST"
        }, {
            default: si(() => [(G(!0), H(Tt, null, $n(t.choices, (h, d) => (G(), H("button", {
                key: d,
                class: "choice has-icon",
                onClick: Pi(p => t.onChoiceClick(h.id), ["prevent"])
            }, [Nn(vt(h.label) + " ", 1), Je(a, {
                focusable: "false",
                avatar: h.avatar,
                class: "icon"
            }, null, 8, ["avatar"])], 8, Yde))), 128)), Ke(B("button", {
                class: "secondary close",
                onClick: e[0] || (e[0] = (...h) => t.onCloseClick && t.onCloseClick(...h))
            }, null, 512), [
                [u, "NEVERMIND"]
            ])]),
            _: 1
        }, 8, ["title-key"])
    }
    const vm = ot(Kde, [
            ["render", zde]
        ]),
        Zde = mt({
            components: {
                AvatarSVG: g0
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                isVip: {
                    type: Boolean,
                    default: () => !1
                },
                players: {
                    type: Object,
                    required: !1
                },
                responseKey: {
                    type: String,
                    required: !1
                }
            },
            emits: {
                didRequestChangeVip: () => !0
            },
            methods: {
                async onAvatarClick() {
                    if (!this.players || !this.responseKey) return;
                    const t = Object.values(this.players).map(s => s.avatar),
                        e = [],
                        n = [];
                    let r = this.info.avatar;
                    for (let s = 0; s < 12; s++) t.includes(s) || (s < this.info.avatar ? e.push(s) : n.push(s));
                    n.length ? r = n[0] : e.length && (r = e[0]);
                    try {
                        await this.$ecast.updateObject(this.responseKey, {
                            changeAvatar: r
                        })
                    } catch (s) {
                        this.$handleEcastError(s)
                    }
                },
                onChangeHostClick() {
                    this.isVip && this.$emit("didRequestChangeVip")
                }
            }
        }),
        Xde = {
            class: "player-header"
        },
        Jde = {
            class: "constrain"
        },
        Qde = {
            key: 0,
            class: "name"
        },
        epe = {
            key: 1,
            class: "name"
        },
        tpe = ["aria-label", "disabled"];

    function npe(t, e, n, r, s, i) {
        const a = st("AvatarSVG"),
            c = On("t"),
            u = On("bb");
        return G(), H("div", Xde, [B("div", Jde, [t.info.isAudience ? Ke((G(), H("p", Qde, null, 512)), [
            [c, "AUDIENCE.NAME"]
        ]) : (G(), H("p", epe, vt(t.info.name), 1)), B("button", {
            class: "change-avatar",
            "aria-label": t.$t("ARIA.CHANGE_AVATAR"),
            disabled: !t.responseKey,
            onClick: e[0] || (e[0] = (...h) => t.onAvatarClick && t.onAvatarClick(...h))
        }, [Je(a, {
            focusable: "false",
            avatar: t.info.avatar
        }, null, 8, ["avatar"])], 8, tpe), t.isVip ? Ke((G(), H("button", {
            key: 2,
            class: "change-host",
            onClick: e[1] || (e[1] = (...h) => t.onChangeHostClick && t.onChangeHostClick(...h))
        }, null, 512)), [
            [u, t.$t("MENU.CHANGE_HOST")]
        ]) : Be("", !0)])])
    }
    const fl = ot(Zde, [
            ["render", npe],
            ["__scopeId", "data-v-8ebc1bd5"]
        ]),
        rpe = mt({
            components: {
                ChangeVIP: vm,
                PlayerHeader: fl
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                },
                players: {
                    type: Object,
                    required: !0
                },
                renders: {
                    type: Array,
                    required: !0
                }
            },
            data() {
                return {
                    showChangeVIP: !1
                }
            },
            computed: {
                vipName() {
                    const t = Object.keys(this.players).find(e => this.players[e].isVip);
                    return t !== void 0 ? this.players[t].name : ""
                }
            },
            methods: {
                onDidRequestChangeVIP() {
                    this.showChangeVIP = !0
                },
                onDidRequestModalClose() {
                    this.showChangeVIP = !1
                },
                async onChoiceClick(t) {
                    if (this.player.responseKey) try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            [t]: !0
                        })
                    } catch (e) {
                        this.$handleEcastError(e)
                    }
                },
                async onShareClick(t) {
                    const e = {
                        title: t.title,
                        text: t.survived ? "WE SURVIVED" : "WE WERE LUNCH",
                        url: t.renderUrl
                    };
                    try {
                        const n = await navigator.share(e)
                    } catch (n) {
                        console.warn(n)
                    }
                }
            }
        }),
        spe = {
            class: "credits"
        },
        ipe = {
            class: "constrain menu has-header"
        },
        ope = {
            class: "title-wrapper"
        },
        ape = {
            key: 0,
            class: "title"
        },
        cpe = {
            key: 0,
            class: "choices-wrapper"
        },
        lpe = {
            class: "choices"
        },
        upe = {
            class: "title"
        },
        hpe = {
            class: "shareables"
        },
        fpe = {
            class: "name"
        },
        dpe = {
            preload: "none",
            controls: ""
        },
        ppe = ["src"],
        mpe = ["onClick"];

    function gpe(t, e, n, r, s, i) {
        const a = st("PlayerHeader"),
            c = st("ChangeVIP"),
            u = On("t");
        return G(), H("div", spe, [B("div", ipe, [B("div", ope, [t.info.isVip ? Ke((G(), H("h3", ape, null, 512)), [
            [u, "POST_GAME.PLAY_AGAIN"]
        ]) : Be("", !0)]), t.info.isVip ? (G(), H("div", cpe, [B("div", lpe, [Ke(B("button", {
            onClick: e[0] || (e[0] = h => t.onChoiceClick("back"))
        }, null, 512), [
            [u, "MENU.BACK_TO_MENU"]
        ])])])) : Be("", !0), Ke(B("h3", upe, null, 512), [
            [u, "CREDITS.SHARE"]
        ]), B("div", hpe, [(G(!0), H(Tt, null, $n(t.renders, (h, d) => (G(), H("div", {
            key: d,
            class: "sharable"
        }, [B("p", fpe, vt(h.title), 1), B("audio", dpe, [B("source", {
            src: h.renderUrl,
            type: "audio/mpeg"
        }, null, 8, ppe)]), B("button", {
            onClick: p => t.onShareClick(h)
        }, "SHARE", 8, mpe)]))), 128))])]), Je(a, {
            info: t.info,
            "is-vip": t.info.isVip && !t.info.isSolo,
            players: t.players,
            "response-key": t.player.responseKey,
            onDidRequestChangeVip: t.onDidRequestChangeVIP
        }, null, 8, ["info", "is-vip", "players", "response-key", "onDidRequestChangeVip"]), Je(Li, {
            name: "modal"
        }, {
            default: si(() => [t.showChangeVIP ? (G(), Ut(c, {
                key: 0,
                info: t.info,
                players: t.players,
                "response-key": t.player.responseKey,
                onDidRequestClose: t.onDidRequestModalClose
            }, null, 8, ["info", "players", "response-key", "onDidRequestClose"])) : Be("", !0)]),
            _: 1
        })])
    }
    const _pe = ot(rpe, [
        ["render", gpe]
    ]);
    class Ii {
        static difficultyI18ByNumber(e) {
            return this.difficulty.numberToI18n[e]
        }
        static categoryI18nBySlug(e) {
            return this.category.slugToI18n[e]
        }
        static categoryI18ByKey(e) {
            return this.category.keyToI18n[e]
        }
        static categoryKeyBySlug(e) {
            return this.category.slugToKey[e]
        }
        static categorySlugByKey(e) {
            return this.category.keyToSlug[e]
        }
        static instrumentIconBySlug(e) {
            return this.instrument.slugToIcon[e]
        }
    }
    Se(Ii, "difficulty", {
        numberToI18n: ["", "DIFFICULTY.VERY_EASY", "DIFFICULTY.EASY", "DIFFICULTY.MEDIUM", "DIFFICULTY.HARD", "DIFFICULTY.VERY_HARD"]
    }), Se(Ii, "category", {
        slugToI18n: {
            "aux-percussion": "BEATMAPS.PERCUSSION",
            bass: "BEATMAPS.BASS",
            "counter-melody": "BEATMAPS.COUNTER",
            drums: "BEATMAPS.DRUMS",
            harmony: "BEATMAPS.HARMONY",
            melody: "BEATMAPS.MELODY",
            signature: "BEATMAPS.SIGNATURE"
        },
        keyToI18n: {
            AuxPercussion: "BEATMAPS.PERCUSSION",
            Bass: "BEATMAPS.BASS",
            CounterMelody: "BEATMAPS.COUNTER",
            Drums: "BEATMAPS.DRUMS",
            Harmony: "BEATMAPS.HARMONY",
            Melody: "BEATMAPS.MELODY",
            Signature: "BEATMAPS.SIGNATURE"
        },
        slugToKey: {
            "aux-percussion": "AuxPercussion",
            bass: "Bass",
            "counter-melody": "CounterMelody",
            drums: "Drums",
            harmony: "Harmony",
            melody: "Melody",
            signature: "Signature"
        },
        keyToSlug: {
            AuxPercussion: "aux-percussion",
            Bass: "bass",
            CounterMelody: "counter-melody",
            Drums: "drums",
            Harmony: "harmony",
            Melody: "melody",
            Signature: "signature"
        }
    }), Se(Ii, "instrument", {
        slugToIcon: {
            "agnes-the-dog": "dog",
            "agnes-the-dog-howls": "dog",
            "alarm-clock": "clock",
            "arp-synth": "synth",
            banjo: "banjo",
            "bari-sax": "sax",
            "bass-flute": "flute",
            bassoon: "flute",
            beatbox: "mouth",
            bitdrums: "synth",
            bottlecaps: "shaker",
            "burpin-conga": "mouth",
            "burps-melody": "mouth",
            cajon: "woodblock",
            cannon: "canon",
            "car-alarm": "car",
            castanets: "castanets",
            "casual-saxophone": "sax",
            caxixi: "shaker",
            "cello-bowed": "cello",
            "cello-plucked": "cello",
            "cheeks-melody": "mouth",
            "cheeks-percussion": "mouth",
            clarinet: "flute",
            "constant-scream": "mouth",
            "continuous-doug": "mouth",
            "continuous-jan": "mouth",
            "continuous-kazoo": "kazoo",
            "continuous-natures-bugle": "poop",
            "contrabass-clarinet": "flute",
            "contrabass-flute": "flute",
            contrabassoon: "flute",
            "cow-bell": "bell",
            cussin: "mouth",
            didgeridoo: "whistle",
            "dinner-bell": "bell",
            "dj-drums": "synth",
            "double-bass-bowed": "cello",
            "double-bass-plucked": "cello",
            doug: "mouth",
            "drum-set-clean": "drumKit",
            "eb-soprano-clarinet": "flute",
            "electric-bass": "guitar",
            euphonium: "tuba",
            "extra-sloppy-horn": "trombone",
            "extra-tall-bongos": "tallBongo",
            "fast-food-cup": "cup",
            "field-drums": "snare",
            flugelhorn: "frenchHorn",
            flute: "flute",
            "french-horn-redo": "frenchHorn",
            gargles: "mouth",
            gong: "gong",
            "grandmas-piano": "piano",
            guiro: "fish",
            "guitar-acoustic-chords": "guitar",
            "guitar-acoustic-notes": "guitar",
            "guitar-electric-chords": "guitar",
            "guitar-electric-noamp": "guitar",
            "guitar-metal-chords": "guitar",
            "guitar-metal-notes": "guitar",
            "guitar-rock-chords": "guitar",
            "guitar-rock-notes": "guitar",
            "h0-ly-crap": "poop",
            "husky-clarinet": "flute",
            "jaw-harp": "mouth",
            "jazz-drums": "drumKit",
            kazoo: "kazoo",
            "kettle-drums": "snare",
            "kung-fu-drums": "hands",
            "lil-ukulele-friend-redo": "guitar",
            "lip-flipper": "mouth",
            "little-congas": "bongos",
            "marching-bass-drum": "snare",
            "marching-drums": "snare",
            marimba: "xylophone",
            mario: "mouth",
            "mommy-sax": "sax",
            "music-box": "woodblock",
            oboe: "flute",
            ocarina: "ocarina",
            piccolo: "flute",
            "piccolo-trumpet": "trumpet",
            "pieces-of-wood": "sticks",
            "pluck-synth": "synth",
            "plucky-violin": "cello",
            "plucky-violins-cousin": "cello",
            "pots-n-pans": "pots",
            "rain-stick": "whistle",
            "rave-synth": "synth",
            rhodes: "piano",
            "robot-synth": "synth",
            "shaky-shaker": "shaker",
            "shy-flute": "flute",
            "sloppy-horn-sampler": "trombone",
            "sloppy-horn-senior": "trombone",
            "snap-clap-stomp": "hands",
            "snare-drum": "snare",
            "squeeze-box": "accordion",
            "tall-bongos": "tallBongo",
            tamborine: "tamborine",
            "taz-the-cat": "cat",
            "the-beef": "synth",
            tootsaphone: "sax",
            trumpet: "trumpet",
            tuba: "tuba",
            tutorial: "cap",
            "uncle-sax": "sax",
            vibes: "xylophone",
            vibraslap: "vibraslap",
            violin: "cello",
            "violins-cousin": "cello",
            "voice-alto": "mouth",
            "voice-soprano": "mouth",
            "weird-oboe": "flute",
            whistle: "mouth",
            "wind-chimes": "chimes",
            "wobble-bass": "guitar",
            "wood-block": "woodblock"
        }
    });
    const WC = "14.7.77",
        w3 = (t, e, n) => ({
            endTime: e,
            insertTime: n,
            type: "exponentialRampToValue",
            value: t
        }),
        O3 = (t, e, n) => ({
            endTime: e,
            insertTime: n,
            type: "linearRampToValue",
            value: t
        }),
        oy = (t, e) => ({
            startTime: e,
            type: "setValue",
            value: t
        }),
        HC = (t, e, n) => ({
            duration: n,
            startTime: e,
            type: "setValueCurve",
            values: t
        }),
        KC = (t, e, {
            startTime: n,
            target: r,
            timeConstant: s
        }) => r + (e - r) * Math.exp((n - t) / s),
        hc = t => t.type === "exponentialRampToValue",
        Nd = t => t.type === "linearRampToValue",
        ao = t => hc(t) || Nd(t),
        _0 = t => t.type === "setValue",
        wi = t => t.type === "setValueCurve",
        xd = (t, e, n, r) => {
            const s = t[e];
            return s === void 0 ? r : ao(s) || _0(s) ? s.value : wi(s) ? s.values[s.values.length - 1] : KC(n, xd(t, e - 1, s.startTime, r), s)
        },
        A3 = (t, e, n, r, s) => n === void 0 ? [r.insertTime, s] : ao(n) ? [n.endTime, n.value] : _0(n) ? [n.startTime, n.value] : wi(n) ? [n.startTime + n.duration, n.values[n.values.length - 1]] : [n.startTime, xd(t, e - 1, n.startTime, s)],
        ay = t => t.type === "cancelAndHold",
        cy = t => t.type === "cancelScheduledValues",
        ro = t => ay(t) || cy(t) ? t.cancelTime : hc(t) || Nd(t) ? t.endTime : t.startTime,
        C3 = (t, e, n, {
            endTime: r,
            value: s
        }) => n === s ? s : 0 < n && 0 < s || n < 0 && s < 0 ? n * (s / n) ** ((t - e) / (r - e)) : 0,
        k3 = (t, e, n, {
            endTime: r,
            value: s
        }) => n + (t - e) / (r - e) * (s - n),
        ype = (t, e) => {
            const n = Math.floor(e),
                r = Math.ceil(e);
            return n === r ? t[n] : (1 - (e - n)) * t[n] + (1 - (r - e)) * t[r]
        },
        vpe = (t, {
            duration: e,
            startTime: n,
            values: r
        }) => {
            const s = (t - n) / e * (r.length - 1);
            return ype(r, s)
        },
        Ff = t => t.type === "setTarget";
    class bpe {
        constructor(e) {
            this._automationEvents = [], this._currenTime = 0, this._defaultValue = e
        } [Symbol.iterator]() {
            return this._automationEvents[Symbol.iterator]()
        }
        add(e) {
            const n = ro(e);
            if (ay(e) || cy(e)) {
                const r = this._automationEvents.findIndex(i => cy(e) && wi(i) ? i.startTime + i.duration >= n : ro(i) >= n),
                    s = this._automationEvents[r];
                if (r !== -1 && (this._automationEvents = this._automationEvents.slice(0, r)), ay(e)) {
                    const i = this._automationEvents[this._automationEvents.length - 1];
                    if (s !== void 0 && ao(s)) {
                        if (Ff(i)) throw new Error("The internal list is malformed.");
                        const a = wi(i) ? i.startTime + i.duration : ro(i),
                            c = wi(i) ? i.values[i.values.length - 1] : i.value,
                            u = hc(s) ? C3(n, a, c, s) : k3(n, a, c, s),
                            h = hc(s) ? w3(u, n, this._currenTime) : O3(u, n, this._currenTime);
                        this._automationEvents.push(h)
                    }
                    i !== void 0 && Ff(i) && this._automationEvents.push(oy(this.getValue(n), n)), i !== void 0 && wi(i) && i.startTime + i.duration > n && (this._automationEvents[this._automationEvents.length - 1] = HC(new Float32Array([6, 7]), i.startTime, n - i.startTime))
                }
            } else {
                const r = this._automationEvents.findIndex(a => ro(a) > n),
                    s = r === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[r - 1];
                if (s !== void 0 && wi(s) && ro(s) + s.duration > n) return !1;
                const i = hc(e) ? w3(e.value, e.endTime, this._currenTime) : Nd(e) ? O3(e.value, n, this._currenTime) : e;
                if (r === -1) this._automationEvents.push(i);
                else {
                    if (wi(e) && n + e.duration > ro(this._automationEvents[r])) return !1;
                    this._automationEvents.splice(r, 0, i)
                }
            }
            return !0
        }
        flush(e) {
            const n = this._automationEvents.findIndex(r => ro(r) > e);
            if (n > 1) {
                const r = this._automationEvents.slice(n - 1),
                    s = r[0];
                Ff(s) && r.unshift(oy(xd(this._automationEvents, n - 2, s.startTime, this._defaultValue), s.startTime)), this._automationEvents = r
            }
        }
        getValue(e) {
            if (this._automationEvents.length === 0) return this._defaultValue;
            const n = this._automationEvents.findIndex(a => ro(a) > e),
                r = this._automationEvents[n],
                s = (n === -1 ? this._automationEvents.length : n) - 1,
                i = this._automationEvents[s];
            if (i !== void 0 && Ff(i) && (r === void 0 || !ao(r) || r.insertTime > e)) return KC(e, xd(this._automationEvents, s - 1, i.startTime, this._defaultValue), i);
            if (i !== void 0 && _0(i) && (r === void 0 || !ao(r))) return i.value;
            if (i !== void 0 && wi(i) && (r === void 0 || !ao(r) || i.startTime + i.duration > e)) return e < i.startTime + i.duration ? vpe(e, i) : i.values[i.values.length - 1];
            if (i !== void 0 && ao(i) && (r === void 0 || !ao(r))) return i.value;
            if (r !== void 0 && hc(r)) {
                const [a, c] = A3(this._automationEvents, s, i, r, this._defaultValue);
                return C3(e, a, c, r)
            }
            if (r !== void 0 && Nd(r)) {
                const [a, c] = A3(this._automationEvents, s, i, r, this._defaultValue);
                return k3(e, a, c, r)
            }
            return this._defaultValue
        }
    }
    const Epe = t => ({
            cancelTime: t,
            type: "cancelAndHold"
        }),
        Tpe = t => ({
            cancelTime: t,
            type: "cancelScheduledValues"
        }),
        Spe = (t, e) => ({
            endTime: e,
            type: "exponentialRampToValue",
            value: t
        }),
        wpe = (t, e) => ({
            endTime: e,
            type: "linearRampToValue",
            value: t
        }),
        Ope = (t, e, n) => ({
            startTime: e,
            target: t,
            timeConstant: n,
            type: "setTarget"
        }),
        Ape = () => new DOMException("", "AbortError"),
        Cpe = t => (e, n, [r, s, i], a) => {
            t(e[s], [n, r, i], c => c[0] === n && c[1] === r, a)
        },
        kpe = t => (e, n, r) => {
            const s = [];
            for (let i = 0; i < r.numberOfInputs; i += 1) s.push(new Set);
            t.set(e, {
                activeInputs: s,
                outputs: new Set,
                passiveInputs: new WeakMap,
                renderer: n
            })
        },
        Ipe = t => (e, n) => {
            t.set(e, {
                activeInputs: new Set,
                passiveInputs: new WeakMap,
                renderer: n
            })
        },
        Bc = new WeakSet,
        YC = new WeakMap,
        y0 = new WeakMap,
        zC = new WeakMap,
        v0 = new WeakMap,
        bm = new WeakMap,
        ZC = new WeakMap,
        ly = new WeakMap,
        uy = new WeakMap,
        hy = new WeakMap,
        XC = {
            construct() {
                return XC
            }
        },
        Npe = t => {
            try {
                const e = new Proxy(t, XC);
                new e
            } catch {
                return !1
            }
            return !0
        },
        I3 = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/,
        N3 = (t, e) => {
            const n = [];
            let r = t.replace(/^[\s]+/, ""),
                s = r.match(I3);
            for (; s !== null;) {
                const i = s[1].slice(1, -1),
                    a = s[0].replace(/([\s]+)?;?$/, "").replace(i, new URL(i, e).toString());
                n.push(a), r = r.slice(s[0].length).replace(/^[\s]+/, ""), s = r.match(I3)
            }
            return [n.join(";"), r]
        },
        x3 = t => {
            if (t !== void 0 && !Array.isArray(t)) throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")
        },
        P3 = t => {
            if (!Npe(t)) throw new TypeError("The given value for processorCtor should be a constructor.");
            if (t.prototype === null || typeof t.prototype != "object") throw new TypeError("The given value for processorCtor should have a prototype.")
        },
        xpe = (t, e, n, r, s, i, a, c, u, h, d, p, m) => {
            let _ = 0;
            return (y, v, w = {
                credentials: "omit"
            }) => {
                const b = d.get(y);
                if (b !== void 0 && b.has(v)) return Promise.resolve();
                const I = h.get(y);
                if (I !== void 0) {
                    const O = I.get(v);
                    if (O !== void 0) return O
                }
                const F = i(y),
                    x = F.audioWorklet === void 0 ? s(v).then(([O, M]) => {
                        const [$, j] = N3(O, M), ee = `${$};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${j}
})})(window,'_AWGS')`;
                        return n(ee)
                    }).then(() => {
                        const O = m._AWGS.pop();
                        if (O === void 0) throw new SyntaxError;
                        r(F.currentTime, F.sampleRate, () => O(class {}, void 0, (M, $) => {
                            if (M.trim() === "") throw e();
                            const j = uy.get(F);
                            if (j !== void 0) {
                                if (j.has(M)) throw e();
                                P3($), x3($.parameterDescriptors), j.set(M, $)
                            } else P3($), x3($.parameterDescriptors), uy.set(F, new Map([
                                [M, $]
                            ]))
                        }, F.sampleRate, void 0, void 0))
                    }) : Promise.all([s(v), Promise.resolve(t(p, p))]).then(([
                        [O, M], $
                    ]) => {
                        const j = _ + 1;
                        _ = j;
                        const [ee, se] = N3(O, M), q = `${ee};((AudioWorkletProcessor,registerProcessor)=>{${se}
})(${$?"AudioWorkletProcessor":"class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${$?"":"__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${$?"":"i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${j}',class extends AudioWorkletProcessor{process(){return !1}})`, ie = new Blob([q], {
                            type: "application/javascript; charset=utf-8"
                        }), ae = URL.createObjectURL(ie);
                        return F.audioWorklet.addModule(ae, w).then(() => {
                            if (c(F)) return F;
                            const he = a(F);
                            return he.audioWorklet.addModule(ae, w).then(() => he)
                        }).then(he => {
                            if (u === null) throw new SyntaxError;
                            try {
                                new u(he, `__sac${j}`)
                            } catch {
                                throw new SyntaxError
                            }
                        }).finally(() => URL.revokeObjectURL(ae))
                    });
                return I === void 0 ? h.set(y, new Map([
                    [v, x]
                ])) : I.set(v, x), x.then(() => {
                    const O = d.get(y);
                    O === void 0 ? d.set(y, new Set([v])) : O.add(v)
                }).finally(() => {
                    const O = h.get(y);
                    O !== void 0 && O.delete(v)
                }), x
            }
        },
        Os = (t, e) => {
            const n = t.get(e);
            if (n === void 0) throw new Error("A value with the given key could not be found.");
            return n
        },
        Em = (t, e) => {
            const n = Array.from(t).filter(e);
            if (n.length > 1) throw Error("More than one element was found.");
            if (n.length === 0) throw Error("No element was found.");
            const [r] = n;
            return t.delete(r), r
        },
        JC = (t, e, n, r) => {
            const s = Os(t, e),
                i = Em(s, a => a[0] === n && a[1] === r);
            return s.size === 0 && t.delete(e), i
        },
        ch = t => Os(ZC, t),
        qc = t => {
            if (Bc.has(t)) throw new Error("The AudioNode is already stored.");
            Bc.add(t), ch(t).forEach(e => e(!0))
        },
        QC = t => "port" in t,
        lh = t => {
            if (!Bc.has(t)) throw new Error("The AudioNode is not stored.");
            Bc.delete(t), ch(t).forEach(e => e(!1))
        },
        fy = (t, e) => {
            !QC(t) && e.every(n => n.size === 0) && lh(t)
        },
        Ppe = (t, e, n, r, s, i, a, c, u, h, d, p, m) => {
            const _ = new WeakMap;
            return (y, v, w, b, I) => {
                const {
                    activeInputs: F,
                    passiveInputs: x
                } = i(v), {
                    outputs: O
                } = i(y), M = c(y), $ = j => {
                    const ee = u(v),
                        se = u(y);
                    if (j) {
                        const oe = JC(x, y, w, b);
                        t(F, y, oe, !1), !I && !p(y) && n(se, ee, w, b), m(v) && qc(v)
                    } else {
                        const oe = r(F, y, w, b);
                        e(x, b, oe, !1), !I && !p(y) && s(se, ee, w, b);
                        const Z = a(v);
                        if (Z === 0) d(v) && fy(v, F);
                        else {
                            const de = _.get(v);
                            de !== void 0 && clearTimeout(de), _.set(v, setTimeout(() => {
                                d(v) && fy(v, F)
                            }, Z * 1e3))
                        }
                    }
                };
                return h(O, [v, w, b], j => j[0] === v && j[1] === w && j[2] === b, !0) ? (M.add($), d(y) ? t(F, y, [w, b, $], !0) : e(x, b, [y, w, $], !0), !0) : !1
            }
        },
        Rpe = t => (e, n, [r, s, i], a) => {
            const c = e.get(r);
            c === void 0 ? e.set(r, new Set([
                [s, n, i]
            ])) : t(c, [s, n, i], u => u[0] === s && u[1] === n, a)
        },
        Mpe = t => (e, n) => {
            const r = t(e, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                gain: 0
            });
            n.connect(r).connect(e.destination);
            const s = () => {
                n.removeEventListener("ended", s), n.disconnect(r), r.disconnect()
            };
            n.addEventListener("ended", s)
        },
        Dpe = t => (e, n) => {
            t(e).add(n)
        },
        $pe = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            fftSize: 2048,
            maxDecibels: -30,
            minDecibels: -100,
            smoothingTimeConstant: .8
        },
        Lpe = (t, e, n, r, s, i) => class extends t {
            constructor(c, u) {
                const h = s(c),
                    d = {
                        ...$pe,
                        ...u
                    },
                    p = r(h, d),
                    m = i(h) ? e() : null;
                super(c, !1, p, m), this._nativeAnalyserNode = p
            }
            get fftSize() {
                return this._nativeAnalyserNode.fftSize
            }
            set fftSize(c) {
                this._nativeAnalyserNode.fftSize = c
            }
            get frequencyBinCount() {
                return this._nativeAnalyserNode.frequencyBinCount
            }
            get maxDecibels() {
                return this._nativeAnalyserNode.maxDecibels
            }
            set maxDecibels(c) {
                const u = this._nativeAnalyserNode.maxDecibels;
                if (this._nativeAnalyserNode.maxDecibels = c, !(c > this._nativeAnalyserNode.minDecibels)) throw this._nativeAnalyserNode.maxDecibels = u, n()
            }
            get minDecibels() {
                return this._nativeAnalyserNode.minDecibels
            }
            set minDecibels(c) {
                const u = this._nativeAnalyserNode.minDecibels;
                if (this._nativeAnalyserNode.minDecibels = c, !(this._nativeAnalyserNode.maxDecibels > c)) throw this._nativeAnalyserNode.minDecibels = u, n()
            }
            get smoothingTimeConstant() {
                return this._nativeAnalyserNode.smoothingTimeConstant
            }
            set smoothingTimeConstant(c) {
                this._nativeAnalyserNode.smoothingTimeConstant = c
            }
            getByteFrequencyData(c) {
                this._nativeAnalyserNode.getByteFrequencyData(c)
            }
            getByteTimeDomainData(c) {
                this._nativeAnalyserNode.getByteTimeDomainData(c)
            }
            getFloatFrequencyData(c) {
                this._nativeAnalyserNode.getFloatFrequencyData(c)
            }
            getFloatTimeDomainData(c) {
                this._nativeAnalyserNode.getFloatTimeDomainData(c)
            }
        },
        ir = (t, e) => t.context === e,
        Fpe = (t, e, n) => () => {
            const r = new WeakMap,
                s = async (i, a) => {
                    let c = e(i);
                    if (!ir(c, a)) {
                        const h = {
                            channelCount: c.channelCount,
                            channelCountMode: c.channelCountMode,
                            channelInterpretation: c.channelInterpretation,
                            fftSize: c.fftSize,
                            maxDecibels: c.maxDecibels,
                            minDecibels: c.minDecibels,
                            smoothingTimeConstant: c.smoothingTimeConstant
                        };
                        c = t(a, h)
                    }
                    return r.set(a, c), await n(i, a, c), c
                };
            return {
                render(i, a) {
                    const c = r.get(a);
                    return c !== void 0 ? Promise.resolve(c) : s(i, a)
                }
            }
        },
        Pd = t => {
            try {
                t.copyToChannel(new Float32Array(1), 0, -1)
            } catch {
                return !1
            }
            return !0
        },
        oi = () => new DOMException("", "IndexSizeError"),
        b0 = t => {
            t.getChannelData = (e => n => {
                try {
                    return e.call(t, n)
                } catch (r) {
                    throw r.code === 12 ? oi() : r
                }
            })(t.getChannelData)
        },
        Upe = {
            numberOfChannels: 1
        },
        Bpe = (t, e, n, r, s, i, a, c) => {
            let u = null;
            return class ek {
                constructor(d) {
                    if (s === null) throw new Error("Missing the native OfflineAudioContext constructor.");
                    const {
                        length: p,
                        numberOfChannels: m,
                        sampleRate: _
                    } = {
                        ...Upe,
                        ...d
                    };
                    u === null && (u = new s(1, 1, 44100));
                    const y = r !== null && e(i, i) ? new r({
                        length: p,
                        numberOfChannels: m,
                        sampleRate: _
                    }) : u.createBuffer(m, p, _);
                    if (y.numberOfChannels === 0) throw n();
                    return typeof y.copyFromChannel != "function" ? (a(y), b0(y)) : e(Pd, () => Pd(y)) || c(y), t.add(y), y
                }
                static[Symbol.hasInstance](d) {
                    return d !== null && typeof d == "object" && Object.getPrototypeOf(d) === ek.prototype || t.has(d)
                }
            }
        },
        Sr = -34028234663852886e22,
        hr = -Sr,
        Ni = t => Bc.has(t),
        qpe = {
            buffer: null,
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            loop: !1,
            loopEnd: 0,
            loopStart: 0,
            playbackRate: 1
        },
        jpe = (t, e, n, r, s, i, a, c) => class extends t {
            constructor(h, d) {
                const p = i(h),
                    m = {
                        ...qpe,
                        ...d
                    },
                    _ = s(p, m),
                    y = a(p),
                    v = y ? e() : null;
                super(h, !1, _, v), this._audioBufferSourceNodeRenderer = v, this._isBufferNullified = !1, this._isBufferSet = m.buffer !== null, this._nativeAudioBufferSourceNode = _, this._onended = null, this._playbackRate = n(this, y, _.playbackRate, hr, Sr)
            }
            get buffer() {
                return this._isBufferNullified ? null : this._nativeAudioBufferSourceNode.buffer
            }
            set buffer(h) {
                if (this._nativeAudioBufferSourceNode.buffer = h, h !== null) {
                    if (this._isBufferSet) throw r();
                    this._isBufferSet = !0
                }
            }
            get loop() {
                return this._nativeAudioBufferSourceNode.loop
            }
            set loop(h) {
                this._nativeAudioBufferSourceNode.loop = h
            }
            get loopEnd() {
                return this._nativeAudioBufferSourceNode.loopEnd
            }
            set loopEnd(h) {
                this._nativeAudioBufferSourceNode.loopEnd = h
            }
            get loopStart() {
                return this._nativeAudioBufferSourceNode.loopStart
            }
            set loopStart(h) {
                this._nativeAudioBufferSourceNode.loopStart = h
            }
            get onended() {
                return this._onended
            }
            set onended(h) {
                const d = typeof h == "function" ? c(this, h) : null;
                this._nativeAudioBufferSourceNode.onended = d;
                const p = this._nativeAudioBufferSourceNode.onended;
                this._onended = p !== null && p === d ? h : p
            }
            get playbackRate() {
                return this._playbackRate
            }
            start(h = 0, d = 0, p) {
                if (this._nativeAudioBufferSourceNode.start(h, d, p), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.start = p === void 0 ? [h, d] : [h, d, p]), this.context.state !== "closed") {
                    qc(this);
                    const m = () => {
                        this._nativeAudioBufferSourceNode.removeEventListener("ended", m), Ni(this) && lh(this)
                    };
                    this._nativeAudioBufferSourceNode.addEventListener("ended", m)
                }
            }
            stop(h = 0) {
                this._nativeAudioBufferSourceNode.stop(h), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.stop = h)
            }
        },
        Vpe = (t, e, n, r, s) => () => {
            const i = new WeakMap;
            let a = null,
                c = null;
            const u = async (h, d) => {
                let p = n(h);
                const m = ir(p, d);
                if (!m) {
                    const _ = {
                        buffer: p.buffer,
                        channelCount: p.channelCount,
                        channelCountMode: p.channelCountMode,
                        channelInterpretation: p.channelInterpretation,
                        loop: p.loop,
                        loopEnd: p.loopEnd,
                        loopStart: p.loopStart,
                        playbackRate: p.playbackRate.value
                    };
                    p = e(d, _), a !== null && p.start(...a), c !== null && p.stop(c)
                }
                return i.set(d, p), m ? await t(d, h.playbackRate, p.playbackRate) : await r(d, h.playbackRate, p.playbackRate), await s(h, d, p), p
            };
            return {
                set start(h) {
                    a = h
                },
                set stop(h) {
                    c = h
                },
                render(h, d) {
                    const p = i.get(d);
                    return p !== void 0 ? Promise.resolve(p) : u(h, d)
                }
            }
        },
        Gpe = t => "playbackRate" in t,
        Wpe = t => "frequency" in t && "gain" in t,
        Hpe = t => "offset" in t,
        Kpe = t => !("frequency" in t) && "gain" in t,
        Ype = t => "detune" in t && "frequency" in t,
        zpe = t => "pan" in t,
        fr = t => Os(YC, t),
        uh = t => Os(zC, t),
        dy = (t, e) => {
            const {
                activeInputs: n
            } = fr(t);
            n.forEach(s => s.forEach(([i]) => {
                e.includes(t) || dy(i, [...e, t])
            }));
            const r = Gpe(t) ? [t.playbackRate] : QC(t) ? Array.from(t.parameters.values()) : Wpe(t) ? [t.Q, t.detune, t.frequency, t.gain] : Hpe(t) ? [t.offset] : Kpe(t) ? [t.gain] : Ype(t) ? [t.detune, t.frequency] : zpe(t) ? [t.pan] : [];
            for (const s of r) {
                const i = uh(s);
                i !== void 0 && i.activeInputs.forEach(([a]) => dy(a, e))
            }
            Ni(t) && lh(t)
        },
        tk = t => {
            dy(t.destination, [])
        },
        Zpe = t => t === void 0 || typeof t == "number" || typeof t == "string" && (t === "balanced" || t === "interactive" || t === "playback"),
        Xpe = (t, e, n, r, s, i, a, c, u) => class extends t {
            constructor(d = {}) {
                if (u === null) throw new Error("Missing the native AudioContext constructor.");
                let p;
                try {
                    p = new u(d)
                } catch (y) {
                    throw y.code === 12 && y.message === "sampleRate is not in range" ? n() : y
                }
                if (p === null) throw r();
                if (!Zpe(d.latencyHint)) throw new TypeError(`The provided value '${d.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
                if (d.sampleRate !== void 0 && p.sampleRate !== d.sampleRate) throw n();
                super(p, 2);
                const {
                    latencyHint: m
                } = d, {
                    sampleRate: _
                } = p;
                if (this._baseLatency = typeof p.baseLatency == "number" ? p.baseLatency : m === "balanced" ? 512 / _ : m === "interactive" || m === void 0 ? 256 / _ : m === "playback" ? 1024 / _ : Math.max(2, Math.min(128, Math.round(m * _ / 128))) * 128 / _, this._nativeAudioContext = p, u.name === "webkitAudioContext" ? (this._nativeGainNode = p.createGain(), this._nativeOscillatorNode = p.createOscillator(), this._nativeGainNode.gain.value = 1e-37, this._nativeOscillatorNode.connect(this._nativeGainNode).connect(p.destination), this._nativeOscillatorNode.start()) : (this._nativeGainNode = null, this._nativeOscillatorNode = null), this._state = null, p.state === "running") {
                    this._state = "suspended";
                    const y = () => {
                        this._state === "suspended" && (this._state = null), p.removeEventListener("statechange", y)
                    };
                    p.addEventListener("statechange", y)
                }
            }
            get baseLatency() {
                return this._baseLatency
            }
            get state() {
                return this._state !== null ? this._state : this._nativeAudioContext.state
            }
            close() {
                return this.state === "closed" ? this._nativeAudioContext.close().then(() => {
                    throw e()
                }) : (this._state === "suspended" && (this._state = null), this._nativeAudioContext.close().then(() => {
                    this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(), this._nativeGainNode.disconnect(), this._nativeOscillatorNode.disconnect()), tk(this)
                }))
            }
            createMediaElementSource(d) {
                return new s(this, {
                    mediaElement: d
                })
            }
            createMediaStreamDestination() {
                return new i(this)
            }
            createMediaStreamSource(d) {
                return new a(this, {
                    mediaStream: d
                })
            }
            createMediaStreamTrackSource(d) {
                return new c(this, {
                    mediaStreamTrack: d
                })
            }
            resume() {
                return this._state === "suspended" ? new Promise((d, p) => {
                    const m = () => {
                        this._nativeAudioContext.removeEventListener("statechange", m), this._nativeAudioContext.state === "running" ? d() : this.resume().then(d, p)
                    };
                    this._nativeAudioContext.addEventListener("statechange", m)
                }) : this._nativeAudioContext.resume().catch(d => {
                    throw d === void 0 || d.code === 15 ? e() : d
                })
            }
            suspend() {
                return this._nativeAudioContext.suspend().catch(d => {
                    throw d === void 0 ? e() : d
                })
            }
        },
        Jpe = (t, e, n, r, s, i, a, c) => class extends t {
            constructor(h, d) {
                const p = i(h),
                    m = a(p),
                    _ = s(p, d, m),
                    y = m ? e(c) : null;
                super(h, !1, _, y), this._isNodeOfNativeOfflineAudioContext = m, this._nativeAudioDestinationNode = _
            }
            get channelCount() {
                return this._nativeAudioDestinationNode.channelCount
            }
            set channelCount(h) {
                if (this._isNodeOfNativeOfflineAudioContext) throw r();
                if (h > this._nativeAudioDestinationNode.maxChannelCount) throw n();
                this._nativeAudioDestinationNode.channelCount = h
            }
            get channelCountMode() {
                return this._nativeAudioDestinationNode.channelCountMode
            }
            set channelCountMode(h) {
                if (this._isNodeOfNativeOfflineAudioContext) throw r();
                this._nativeAudioDestinationNode.channelCountMode = h
            }
            get maxChannelCount() {
                return this._nativeAudioDestinationNode.maxChannelCount
            }
        },
        Qpe = t => {
            const e = new WeakMap,
                n = async (r, s) => {
                    const i = s.destination;
                    return e.set(s, i), await t(r, s, i), i
                };
            return {
                render(r, s) {
                    const i = e.get(s);
                    return i !== void 0 ? Promise.resolve(i) : n(r, s)
                }
            }
        },
        eme = (t, e, n, r, s, i, a, c) => (u, h) => {
            const d = h.listener,
                p = () => {
                    const O = new Float32Array(1),
                        M = e(h, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "speakers",
                            numberOfInputs: 9
                        }),
                        $ = a(h);
                    let j = !1,
                        ee = [0, 0, -1, 0, 1, 0],
                        se = [0, 0, 0];
                    const oe = () => {
                            if (j) return;
                            j = !0;
                            const ie = r(h, 256, 9, 0);
                            ie.onaudioprocess = ({
                                inputBuffer: ae
                            }) => {
                                const he = [i(ae, O, 0), i(ae, O, 1), i(ae, O, 2), i(ae, O, 3), i(ae, O, 4), i(ae, O, 5)];
                                he.some((be, Ae) => be !== ee[Ae]) && (d.setOrientation(...he), ee = he);
                                const ve = [i(ae, O, 6), i(ae, O, 7), i(ae, O, 8)];
                                ve.some((be, Ae) => be !== se[Ae]) && (d.setPosition(...ve), se = ve)
                            }, M.connect(ie)
                        },
                        Z = ie => ae => {
                            ae !== ee[ie] && (ee[ie] = ae, d.setOrientation(...ee))
                        },
                        de = ie => ae => {
                            ae !== se[ie] && (se[ie] = ae, d.setPosition(...se))
                        },
                        q = (ie, ae, he) => {
                            const ve = n(h, {
                                channelCount: 1,
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                offset: ae
                            });
                            ve.connect(M, 0, ie), ve.start(), Object.defineProperty(ve.offset, "defaultValue", {
                                get() {
                                    return ae
                                }
                            });
                            const be = t({
                                context: u
                            }, $, ve.offset, hr, Sr);
                            return c(be, "value", Ae => () => Ae.call(be), Ae => we => {
                                try {
                                    Ae.call(be, we)
                                } catch (Me) {
                                    if (Me.code !== 9) throw Me
                                }
                                oe(), $ && he(we)
                            }), be.cancelAndHoldAtTime = (Ae => $ ? () => {
                                throw s()
                            } : (...we) => {
                                const Me = Ae.apply(be, we);
                                return oe(), Me
                            })(be.cancelAndHoldAtTime), be.cancelScheduledValues = (Ae => $ ? () => {
                                throw s()
                            } : (...we) => {
                                const Me = Ae.apply(be, we);
                                return oe(), Me
                            })(be.cancelScheduledValues), be.exponentialRampToValueAtTime = (Ae => $ ? () => {
                                throw s()
                            } : (...we) => {
                                const Me = Ae.apply(be, we);
                                return oe(), Me
                            })(be.exponentialRampToValueAtTime), be.linearRampToValueAtTime = (Ae => $ ? () => {
                                throw s()
                            } : (...we) => {
                                const Me = Ae.apply(be, we);
                                return oe(), Me
                            })(be.linearRampToValueAtTime), be.setTargetAtTime = (Ae => $ ? () => {
                                throw s()
                            } : (...we) => {
                                const Me = Ae.apply(be, we);
                                return oe(), Me
                            })(be.setTargetAtTime), be.setValueAtTime = (Ae => $ ? () => {
                                throw s()
                            } : (...we) => {
                                const Me = Ae.apply(be, we);
                                return oe(), Me
                            })(be.setValueAtTime), be.setValueCurveAtTime = (Ae => $ ? () => {
                                throw s()
                            } : (...we) => {
                                const Me = Ae.apply(be, we);
                                return oe(), Me
                            })(be.setValueCurveAtTime), be
                        };
                    return {
                        forwardX: q(0, 0, Z(0)),
                        forwardY: q(1, 0, Z(1)),
                        forwardZ: q(2, -1, Z(2)),
                        positionX: q(6, 0, de(0)),
                        positionY: q(7, 0, de(1)),
                        positionZ: q(8, 0, de(2)),
                        upX: q(3, 0, Z(3)),
                        upY: q(4, 1, Z(4)),
                        upZ: q(5, 0, Z(5))
                    }
                },
                {
                    forwardX: m,
                    forwardY: _,
                    forwardZ: y,
                    positionX: v,
                    positionY: w,
                    positionZ: b,
                    upX: I,
                    upY: F,
                    upZ: x
                } = d.forwardX === void 0 ? p() : d;
            return {
                get forwardX() {
                    return m
                },
                get forwardY() {
                    return _
                },
                get forwardZ() {
                    return y
                },
                get positionX() {
                    return v
                },
                get positionY() {
                    return w
                },
                get positionZ() {
                    return b
                },
                get upX() {
                    return I
                },
                get upY() {
                    return F
                },
                get upZ() {
                    return x
                }
            }
        },
        Rd = t => "context" in t,
        hh = t => Rd(t[0]),
        Ra = (t, e, n, r) => {
            for (const s of t)
                if (n(s)) {
                    if (r) return !1;
                    throw Error("The set contains at least one similar element.")
                } return t.add(e), !0
        },
        R3 = (t, e, [n, r], s) => {
            Ra(t, [e, n, r], i => i[0] === e && i[1] === n, s)
        },
        M3 = (t, [e, n, r], s) => {
            const i = t.get(e);
            i === void 0 ? t.set(e, new Set([
                [n, r]
            ])) : Ra(i, [n, r], a => a[0] === n, s)
        },
        dl = t => "inputs" in t,
        Md = (t, e, n, r) => {
            if (dl(e)) {
                const s = e.inputs[r];
                return t.connect(s, n, 0), [s, n, 0]
            }
            return t.connect(e, n, r), [e, n, r]
        },
        nk = (t, e, n) => {
            for (const r of t)
                if (r[0] === e && r[1] === n) return t.delete(r), r;
            return null
        },
        tme = (t, e, n) => Em(t, r => r[0] === e && r[1] === n),
        rk = (t, e) => {
            if (!ch(t).delete(e)) throw new Error("Missing the expected event listener.")
        },
        sk = (t, e, n) => {
            const r = Os(t, e),
                s = Em(r, i => i[0] === n);
            return r.size === 0 && t.delete(e), s
        },
        Dd = (t, e, n, r) => {
            dl(e) ? t.disconnect(e.inputs[r], n, 0) : t.disconnect(e, n, r)
        },
        Qt = t => Os(y0, t),
        Tu = t => Os(v0, t),
        wa = t => ly.has(t),
        Jf = t => !Bc.has(t),
        D3 = (t, e) => new Promise(n => {
            if (e !== null) n(!0);
            else {
                const r = t.createScriptProcessor(256, 1, 1),
                    s = t.createGain(),
                    i = t.createBuffer(1, 2, 44100),
                    a = i.getChannelData(0);
                a[0] = 1, a[1] = 1;
                const c = t.createBufferSource();
                c.buffer = i, c.loop = !0, c.connect(r).connect(t.destination), c.connect(s), c.disconnect(s), r.onaudioprocess = u => {
                    const h = u.inputBuffer.getChannelData(0);
                    Array.prototype.some.call(h, d => d === 1) ? n(!0) : n(!1), c.stop(), r.onaudioprocess = null, c.disconnect(r), r.disconnect(t.destination)
                }, c.start()
            }
        }),
        H_ = (t, e) => {
            const n = new Map;
            for (const r of t)
                for (const s of r) {
                    const i = n.get(s);
                    n.set(s, i === void 0 ? 1 : i + 1)
                }
            n.forEach((r, s) => e(s, r))
        },
        $d = t => "context" in t,
        nme = t => {
            const e = new Map;
            t.connect = (n => (r, s = 0, i = 0) => {
                const a = $d(r) ? n(r, s, i) : n(r, s),
                    c = e.get(r);
                return c === void 0 ? e.set(r, [{
                    input: i,
                    output: s
                }]) : c.every(u => u.input !== i || u.output !== s) && c.push({
                    input: i,
                    output: s
                }), a
            })(t.connect.bind(t)), t.disconnect = (n => (r, s, i) => {
                if (n.apply(t), r === void 0) e.clear();
                else if (typeof r == "number")
                    for (const [a, c] of e) {
                        const u = c.filter(h => h.output !== r);
                        u.length === 0 ? e.delete(a) : e.set(a, u)
                    } else if (e.has(r))
                        if (s === void 0) e.delete(r);
                        else {
                            const a = e.get(r);
                            if (a !== void 0) {
                                const c = a.filter(u => u.output !== s && (u.input !== i || i === void 0));
                                c.length === 0 ? e.delete(r) : e.set(r, c)
                            }
                        } for (const [a, c] of e) c.forEach(u => {
                    $d(a) ? t.connect(a, u.output, u.input) : t.connect(a, u.output)
                })
            })(t.disconnect)
        },
        rme = (t, e, n, r) => {
            const {
                activeInputs: s,
                passiveInputs: i
            } = uh(e), {
                outputs: a
            } = fr(t), c = ch(t), u = h => {
                const d = Qt(t),
                    p = Tu(e);
                if (h) {
                    const m = sk(i, t, n);
                    R3(s, t, m, !1), !r && !wa(t) && d.connect(p, n)
                } else {
                    const m = tme(s, t, n);
                    M3(i, m, !1), !r && !wa(t) && d.disconnect(p, n)
                }
            };
            return Ra(a, [e, n], h => h[0] === e && h[1] === n, !0) ? (c.add(u), Ni(t) ? R3(s, t, [n, u], !0) : M3(i, [t, n, u], !0), !0) : !1
        },
        sme = (t, e, n, r) => {
            const {
                activeInputs: s,
                passiveInputs: i
            } = fr(e), a = nk(s[r], t, n);
            return a === null ? [JC(i, t, n, r)[2], !1] : [a[2], !0]
        },
        ime = (t, e, n) => {
            const {
                activeInputs: r,
                passiveInputs: s
            } = uh(e), i = nk(r, t, n);
            return i === null ? [sk(s, t, n)[1], !1] : [i[2], !0]
        },
        E0 = (t, e, n, r, s) => {
            const [i, a] = sme(t, n, r, s);
            if (i !== null && (rk(t, i), a && !e && !wa(t) && Dd(Qt(t), Qt(n), r, s)), Ni(n)) {
                const {
                    activeInputs: c
                } = fr(n);
                fy(n, c)
            }
        },
        T0 = (t, e, n, r) => {
            const [s, i] = ime(t, n, r);
            s !== null && (rk(t, s), i && !e && !wa(t) && Qt(t).disconnect(Tu(n), r))
        },
        ome = (t, e) => {
            const n = fr(t),
                r = [];
            for (const s of n.outputs) hh(s) ? E0(t, e, ...s) : T0(t, e, ...s), r.push(s[0]);
            return n.outputs.clear(), r
        },
        ame = (t, e, n) => {
            const r = fr(t),
                s = [];
            for (const i of r.outputs) i[1] === n && (hh(i) ? E0(t, e, ...i) : T0(t, e, ...i), s.push(i[0]), r.outputs.delete(i));
            return s
        },
        cme = (t, e, n, r, s) => {
            const i = fr(t);
            return Array.from(i.outputs).filter(a => a[0] === n && (r === void 0 || a[1] === r) && (s === void 0 || a[2] === s)).map(a => (hh(a) ? E0(t, e, ...a) : T0(t, e, ...a), i.outputs.delete(a), a[0]))
        },
        lme = (t, e, n, r, s, i, a, c, u, h, d, p, m, _, y, v) => class extends h {
            constructor(b, I, F, x) {
                super(F), this._context = b, this._nativeAudioNode = F;
                const O = d(b);
                p(O) && n(D3, () => D3(O, v)) !== !0 && nme(F), y0.set(this, F), ZC.set(this, new Set), b.state !== "closed" && I && qc(this), t(this, x, F)
            }
            get channelCount() {
                return this._nativeAudioNode.channelCount
            }
            set channelCount(b) {
                this._nativeAudioNode.channelCount = b
            }
            get channelCountMode() {
                return this._nativeAudioNode.channelCountMode
            }
            set channelCountMode(b) {
                this._nativeAudioNode.channelCountMode = b
            }
            get channelInterpretation() {
                return this._nativeAudioNode.channelInterpretation
            }
            set channelInterpretation(b) {
                this._nativeAudioNode.channelInterpretation = b
            }
            get context() {
                return this._context
            }
            get numberOfInputs() {
                return this._nativeAudioNode.numberOfInputs
            }
            get numberOfOutputs() {
                return this._nativeAudioNode.numberOfOutputs
            }
            connect(b, I = 0, F = 0) {
                if (I < 0 || I >= this._nativeAudioNode.numberOfOutputs) throw s();
                const x = d(this._context),
                    O = y(x);
                if (m(b) || _(b)) throw i();
                if (Rd(b)) {
                    const j = Qt(b);
                    try {
                        const se = Md(this._nativeAudioNode, j, I, F),
                            oe = Jf(this);
                        (O || oe) && this._nativeAudioNode.disconnect(...se), this.context.state !== "closed" && !oe && Jf(b) && qc(b)
                    } catch (se) {
                        throw se.code === 12 ? i() : se
                    }
                    if (e(this, b, I, F, O)) {
                        const se = u([this], b);
                        H_(se, r(O))
                    }
                    return b
                }
                const M = Tu(b);
                if (M.name === "playbackRate" && M.maxValue === 1024) throw a();
                try {
                    this._nativeAudioNode.connect(M, I), (O || Jf(this)) && this._nativeAudioNode.disconnect(M, I)
                } catch (j) {
                    throw j.code === 12 ? i() : j
                }
                if (rme(this, b, I, O)) {
                    const j = u([this], b);
                    H_(j, r(O))
                }
            }
            disconnect(b, I, F) {
                let x;
                const O = d(this._context),
                    M = y(O);
                if (b === void 0) x = ome(this, M);
                else if (typeof b == "number") {
                    if (b < 0 || b >= this.numberOfOutputs) throw s();
                    x = ame(this, M, b)
                } else {
                    if (I !== void 0 && (I < 0 || I >= this.numberOfOutputs) || Rd(b) && F !== void 0 && (F < 0 || F >= b.numberOfInputs)) throw s();
                    if (x = cme(this, M, b, I, F), x.length === 0) throw i()
                }
                for (const $ of x) {
                    const j = u([this], $);
                    H_(j, c)
                }
            }
        },
        ume = (t, e, n, r, s, i, a, c, u, h, d, p, m) => (_, y, v, w = null, b = null) => {
            const I = new bpe(v.defaultValue),
                F = y ? r(I) : null,
                x = {
                    get defaultValue() {
                        return v.defaultValue
                    },
                    get maxValue() {
                        return w === null ? v.maxValue : w
                    },
                    get minValue() {
                        return b === null ? v.minValue : b
                    },
                    get value() {
                        return v.value
                    },
                    set value(O) {
                        v.value = O, x.setValueAtTime(O, _.context.currentTime)
                    },
                    cancelAndHoldAtTime(O) {
                        if (typeof v.cancelAndHoldAtTime == "function") F === null && I.flush(_.context.currentTime), I.add(s(O)), v.cancelAndHoldAtTime(O);
                        else {
                            const M = Array.from(I).pop();
                            F === null && I.flush(_.context.currentTime), I.add(s(O));
                            const $ = Array.from(I).pop();
                            v.cancelScheduledValues(O), M !== $ && $ !== void 0 && ($.type === "exponentialRampToValue" ? v.exponentialRampToValueAtTime($.value, $.endTime) : $.type === "linearRampToValue" ? v.linearRampToValueAtTime($.value, $.endTime) : $.type === "setValue" ? v.setValueAtTime($.value, $.startTime) : $.type === "setValueCurve" && v.setValueCurveAtTime($.values, $.startTime, $.duration))
                        }
                        return x
                    },
                    cancelScheduledValues(O) {
                        return F === null && I.flush(_.context.currentTime), I.add(i(O)), v.cancelScheduledValues(O), x
                    },
                    exponentialRampToValueAtTime(O, M) {
                        if (O === 0) throw new RangeError;
                        if (!Number.isFinite(M) || M < 0) throw new RangeError;
                        return F === null && I.flush(_.context.currentTime), I.add(a(O, M)), v.exponentialRampToValueAtTime(O, M), x
                    },
                    linearRampToValueAtTime(O, M) {
                        return F === null && I.flush(_.context.currentTime), I.add(c(O, M)), v.linearRampToValueAtTime(O, M), x
                    },
                    setTargetAtTime(O, M, $) {
                        return F === null && I.flush(_.context.currentTime), I.add(u(O, M, $)), v.setTargetAtTime(O, M, $), x
                    },
                    setValueAtTime(O, M) {
                        return F === null && I.flush(_.context.currentTime), I.add(h(O, M)), v.setValueAtTime(O, M), x
                    },
                    setValueCurveAtTime(O, M, $) {
                        const j = O instanceof Float32Array ? O : new Float32Array(O);
                        if (p !== null && p.name === "webkitAudioContext") {
                            const ee = M + $,
                                se = _.context.sampleRate,
                                oe = Math.ceil(M * se),
                                Z = Math.floor(ee * se),
                                de = Z - oe,
                                q = new Float32Array(de);
                            for (let ae = 0; ae < de; ae += 1) {
                                const he = (j.length - 1) / $ * ((oe + ae) / se - M),
                                    ve = Math.floor(he),
                                    be = Math.ceil(he);
                                q[ae] = ve === be ? j[ve] : (1 - (he - ve)) * j[ve] + (1 - (be - he)) * j[be]
                            }
                            F === null && I.flush(_.context.currentTime), I.add(d(q, M, $)), v.setValueCurveAtTime(q, M, $);
                            const ie = Z / se;
                            ie < ee && m(x, q[q.length - 1], ie), m(x, j[j.length - 1], ee)
                        } else F === null && I.flush(_.context.currentTime), I.add(d(j, M, $)), v.setValueCurveAtTime(j, M, $);
                        return x
                    }
                };
            return n.set(x, v), e.set(x, _), t(x, F), x
        },
        hme = t => ({
            replay(e) {
                for (const n of t)
                    if (n.type === "exponentialRampToValue") {
                        const {
                            endTime: r,
                            value: s
                        } = n;
                        e.exponentialRampToValueAtTime(s, r)
                    } else if (n.type === "linearRampToValue") {
                    const {
                        endTime: r,
                        value: s
                    } = n;
                    e.linearRampToValueAtTime(s, r)
                } else if (n.type === "setTarget") {
                    const {
                        startTime: r,
                        target: s,
                        timeConstant: i
                    } = n;
                    e.setTargetAtTime(s, r, i)
                } else if (n.type === "setValue") {
                    const {
                        startTime: r,
                        value: s
                    } = n;
                    e.setValueAtTime(s, r)
                } else if (n.type === "setValueCurve") {
                    const {
                        duration: r,
                        startTime: s,
                        values: i
                    } = n;
                    e.setValueCurveAtTime(i, s, r)
                } else throw new Error("Can't apply an unknown automation.")
            }
        });
    class ik {
        constructor(e) {
            this._map = new Map(e)
        }
        get size() {
            return this._map.size
        }
        entries() {
            return this._map.entries()
        }
        forEach(e, n = null) {
            return this._map.forEach((r, s) => e.call(n, r, s, this))
        }
        get(e) {
            return this._map.get(e)
        }
        has(e) {
            return this._map.has(e)
        }
        keys() {
            return this._map.keys()
        }
        values() {
            return this._map.values()
        }
    }
    const fme = {
            channelCount: 2,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: 1,
            numberOfOutputs: 1,
            parameterData: {},
            processorOptions: {}
        },
        dme = (t, e, n, r, s, i, a, c, u, h, d, p, m, _) => class extends e {
            constructor(v, w, b) {
                var I;
                const F = c(v),
                    x = u(F),
                    O = d({
                        ...fme,
                        ...b
                    });
                m(O);
                const M = uy.get(F),
                    $ = M == null ? void 0 : M.get(w),
                    j = x || F.state !== "closed" ? F : (I = a(F)) !== null && I !== void 0 ? I : F,
                    ee = s(j, x ? null : v.baseLatency, h, w, $, O),
                    se = x ? r(w, O, $) : null;
                super(v, !0, ee, se);
                const oe = [];
                ee.parameters.forEach((de, q) => {
                    const ie = n(this, x, de);
                    oe.push([q, ie])
                }), this._nativeAudioWorkletNode = ee, this._onprocessorerror = null, this._parameters = new ik(oe), x && t(F, this);
                const {
                    activeInputs: Z
                } = i(this);
                p(ee, Z)
            }
            get onprocessorerror() {
                return this._onprocessorerror
            }
            set onprocessorerror(v) {
                const w = typeof v == "function" ? _(this, v) : null;
                this._nativeAudioWorkletNode.onprocessorerror = w;
                const b = this._nativeAudioWorkletNode.onprocessorerror;
                this._onprocessorerror = b !== null && b === w ? v : b
            }
            get parameters() {
                return this._parameters === null ? this._nativeAudioWorkletNode.parameters : this._parameters
            }
            get port() {
                return this._nativeAudioWorkletNode.port
            }
        };

    function Ld(t, e, n, r, s) {
        if (typeof t.copyFromChannel == "function") e[n].byteLength === 0 && (e[n] = new Float32Array(128)), t.copyFromChannel(e[n], r, s);
        else {
            const i = t.getChannelData(r);
            if (e[n].byteLength === 0) e[n] = i.slice(s, s + 128);
            else {
                const a = new Float32Array(i.buffer, s * Float32Array.BYTES_PER_ELEMENT, 128);
                e[n].set(a)
            }
        }
    }
    const ok = (t, e, n, r, s) => {
            typeof t.copyToChannel == "function" ? e[n].byteLength !== 0 && t.copyToChannel(e[n], r, s) : e[n].byteLength !== 0 && t.getChannelData(r).set(e[n], s)
        },
        Fd = (t, e) => {
            const n = [];
            for (let r = 0; r < t; r += 1) {
                const s = [],
                    i = typeof e == "number" ? e : e[r];
                for (let a = 0; a < i; a += 1) s.push(new Float32Array(128));
                n.push(s)
            }
            return n
        },
        pme = (t, e) => {
            const n = Os(hy, t),
                r = Qt(e);
            return Os(n, r)
        },
        mme = async (t, e, n, r, s, i, a) => {
            const c = e === null ? Math.ceil(t.context.length / 128) * 128 : e.length,
                u = r.channelCount * r.numberOfInputs,
                h = s.reduce((w, b) => w + b, 0),
                d = h === 0 ? null : n.createBuffer(h, c, n.sampleRate);
            if (i === void 0) throw new Error("Missing the processor constructor.");
            const p = fr(t),
                m = await pme(n, t),
                _ = Fd(r.numberOfInputs, r.channelCount),
                y = Fd(r.numberOfOutputs, s),
                v = Array.from(t.parameters.keys()).reduce((w, b) => ({
                    ...w,
                    [b]: new Float32Array(128)
                }), {});
            for (let w = 0; w < c; w += 128) {
                if (r.numberOfInputs > 0 && e !== null)
                    for (let b = 0; b < r.numberOfInputs; b += 1)
                        for (let I = 0; I < r.channelCount; I += 1) Ld(e, _[b], I, I, w);
                i.parameterDescriptors !== void 0 && e !== null && i.parameterDescriptors.forEach(({
                    name: b
                }, I) => {
                    Ld(e, v, b, u + I, w)
                });
                for (let b = 0; b < r.numberOfInputs; b += 1)
                    for (let I = 0; I < s[b]; I += 1) y[b][I].byteLength === 0 && (y[b][I] = new Float32Array(128));
                try {
                    const b = _.map((F, x) => p.activeInputs[x].size === 0 ? [] : F),
                        I = a(w / n.sampleRate, n.sampleRate, () => m.process(b, y, v));
                    if (d !== null)
                        for (let F = 0, x = 0; F < r.numberOfOutputs; F += 1) {
                            for (let O = 0; O < s[F]; O += 1) ok(d, y[F], O, x + O, w);
                            x += s[F]
                        }
                    if (!I) break
                } catch (b) {
                    t.dispatchEvent(new ErrorEvent("processorerror", {
                        colno: b.colno,
                        filename: b.filename,
                        lineno: b.lineno,
                        message: b.message
                    }));
                    break
                }
            }
            return d
        }, gme = (t, e, n, r, s, i, a, c, u, h, d, p, m, _, y, v) => (w, b, I) => {
            const F = new WeakMap;
            let x = null;
            const O = async (M, $) => {
                let j = d(M),
                    ee = null;
                const se = ir(j, $),
                    oe = Array.isArray(b.outputChannelCount) ? b.outputChannelCount : Array.from(b.outputChannelCount);
                if (p === null) {
                    const Z = oe.reduce((ae, he) => ae + he, 0),
                        de = s($, {
                            channelCount: Math.max(1, Z),
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            numberOfOutputs: Math.max(1, Z)
                        }),
                        q = [];
                    for (let ae = 0; ae < M.numberOfOutputs; ae += 1) q.push(r($, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "speakers",
                        numberOfInputs: oe[ae]
                    }));
                    const ie = a($, {
                        channelCount: b.channelCount,
                        channelCountMode: b.channelCountMode,
                        channelInterpretation: b.channelInterpretation,
                        gain: 1
                    });
                    ie.connect = e.bind(null, q), ie.disconnect = u.bind(null, q), ee = [de, q, ie]
                } else se || (j = new p($, w));
                if (F.set($, ee === null ? j : ee[2]), ee !== null) {
                    if (x === null) {
                        if (I === void 0) throw new Error("Missing the processor constructor.");
                        if (m === null) throw new Error("Missing the native OfflineAudioContext constructor.");
                        const he = M.channelCount * M.numberOfInputs,
                            ve = I.parameterDescriptors === void 0 ? 0 : I.parameterDescriptors.length,
                            be = he + ve;
                        x = mme(M, be === 0 ? null : await (async () => {
                            const we = new m(be, Math.ceil(M.context.length / 128) * 128, $.sampleRate),
                                Me = [],
                                Nt = [];
                            for (let Ye = 0; Ye < b.numberOfInputs; Ye += 1) Me.push(a(we, {
                                channelCount: b.channelCount,
                                channelCountMode: b.channelCountMode,
                                channelInterpretation: b.channelInterpretation,
                                gain: 1
                            })), Nt.push(s(we, {
                                channelCount: b.channelCount,
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                numberOfOutputs: b.channelCount
                            }));
                            const jt = await Promise.all(Array.from(M.parameters.values()).map(async Ye => {
                                    const at = i(we, {
                                        channelCount: 1,
                                        channelCountMode: "explicit",
                                        channelInterpretation: "discrete",
                                        offset: Ye.value
                                    });
                                    return await _(we, Ye, at.offset), at
                                })),
                                Ue = r(we, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "speakers",
                                    numberOfInputs: Math.max(1, he + ve)
                                });
                            for (let Ye = 0; Ye < b.numberOfInputs; Ye += 1) {
                                Me[Ye].connect(Nt[Ye]);
                                for (let at = 0; at < b.channelCount; at += 1) Nt[Ye].connect(Ue, at, Ye * b.channelCount + at)
                            }
                            for (const [Ye, at] of jt.entries()) at.connect(Ue, 0, he + Ye), at.start(0);
                            return Ue.connect(we.destination), await Promise.all(Me.map(Ye => y(M, we, Ye))), v(we)
                        })(), $, b, oe, I, h)
                    }
                    const Z = await x,
                        de = n($, {
                            buffer: null,
                            channelCount: 2,
                            channelCountMode: "max",
                            channelInterpretation: "speakers",
                            loop: !1,
                            loopEnd: 0,
                            loopStart: 0,
                            playbackRate: 1
                        }),
                        [q, ie, ae] = ee;
                    Z !== null && (de.buffer = Z, de.start(0)), de.connect(q);
                    for (let he = 0, ve = 0; he < M.numberOfOutputs; he += 1) {
                        const be = ie[he];
                        for (let Ae = 0; Ae < oe[he]; Ae += 1) q.connect(be, ve + Ae, Ae);
                        ve += oe[he]
                    }
                    return ae
                }
                if (se)
                    for (const [Z, de] of M.parameters.entries()) await t($, de, j.parameters.get(Z));
                else
                    for (const [Z, de] of M.parameters.entries()) await _($, de, j.parameters.get(Z));
                return await y(M, $, j), j
            };
            return {
                render(M, $) {
                    c($, M);
                    const j = F.get($);
                    return j !== void 0 ? Promise.resolve(j) : O(M, $)
                }
            }
        }, _me = (t, e, n, r, s, i, a, c, u, h, d, p, m, _, y, v, w, b, I, F) => class extends y {
            constructor(O, M) {
                super(O, M), this._nativeContext = O, this._audioWorklet = t === void 0 ? void 0 : {
                    addModule: ($, j) => t(this, $, j)
                }
            }
            get audioWorklet() {
                return this._audioWorklet
            }
            createAnalyser() {
                return new e(this)
            }
            createBiquadFilter() {
                return new s(this)
            }
            createBuffer(O, M, $) {
                return new n({
                    length: M,
                    numberOfChannels: O,
                    sampleRate: $
                })
            }
            createBufferSource() {
                return new r(this)
            }
            createChannelMerger(O = 6) {
                return new i(this, {
                    numberOfInputs: O
                })
            }
            createChannelSplitter(O = 6) {
                return new a(this, {
                    numberOfOutputs: O
                })
            }
            createConstantSource() {
                return new c(this)
            }
            createConvolver() {
                return new u(this)
            }
            createDelay(O = 1) {
                return new d(this, {
                    maxDelayTime: O
                })
            }
            createDynamicsCompressor() {
                return new p(this)
            }
            createGain() {
                return new m(this)
            }
            createIIRFilter(O, M) {
                return new _(this, {
                    feedback: M,
                    feedforward: O
                })
            }
            createOscillator() {
                return new v(this)
            }
            createPanner() {
                return new w(this)
            }
            createPeriodicWave(O, M, $ = {
                disableNormalization: !1
            }) {
                return new b(this, {
                    ...$,
                    imag: M,
                    real: O
                })
            }
            createStereoPanner() {
                return new I(this)
            }
            createWaveShaper() {
                return new F(this)
            }
            decodeAudioData(O, M, $) {
                return h(this._nativeContext, O).then(j => (typeof M == "function" && M(j), j), j => {
                    throw typeof $ == "function" && $(j), j
                })
            }
        }, yme = {
            Q: 1,
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            detune: 0,
            frequency: 350,
            gain: 0,
            type: "lowpass"
        }, vme = (t, e, n, r, s, i, a, c) => class extends t {
            constructor(h, d) {
                const p = i(h),
                    m = {
                        ...yme,
                        ...d
                    },
                    _ = s(p, m),
                    y = a(p),
                    v = y ? n() : null;
                super(h, !1, _, v), this._Q = e(this, y, _.Q, hr, Sr), this._detune = e(this, y, _.detune, 1200 * Math.log2(hr), -1200 * Math.log2(hr)), this._frequency = e(this, y, _.frequency, h.sampleRate / 2, 0), this._gain = e(this, y, _.gain, 40 * Math.log10(hr), Sr), this._nativeBiquadFilterNode = _, c(this, 1)
            }
            get detune() {
                return this._detune
            }
            get frequency() {
                return this._frequency
            }
            get gain() {
                return this._gain
            }
            get Q() {
                return this._Q
            }
            get type() {
                return this._nativeBiquadFilterNode.type
            }
            set type(h) {
                this._nativeBiquadFilterNode.type = h
            }
            getFrequencyResponse(h, d, p) {
                try {
                    this._nativeBiquadFilterNode.getFrequencyResponse(h, d, p)
                } catch (m) {
                    throw m.code === 11 ? r() : m
                }
                if (h.length !== d.length || d.length !== p.length) throw r()
            }
        }, bme = (t, e, n, r, s) => () => {
            const i = new WeakMap,
                a = async (c, u) => {
                    let h = n(c);
                    const d = ir(h, u);
                    if (!d) {
                        const p = {
                            Q: h.Q.value,
                            channelCount: h.channelCount,
                            channelCountMode: h.channelCountMode,
                            channelInterpretation: h.channelInterpretation,
                            detune: h.detune.value,
                            frequency: h.frequency.value,
                            gain: h.gain.value,
                            type: h.type
                        };
                        h = e(u, p)
                    }
                    return i.set(u, h), d ? (await t(u, c.Q, h.Q), await t(u, c.detune, h.detune), await t(u, c.frequency, h.frequency), await t(u, c.gain, h.gain)) : (await r(u, c.Q, h.Q), await r(u, c.detune, h.detune), await r(u, c.frequency, h.frequency), await r(u, c.gain, h.gain)), await s(c, u, h), h
                };
            return {
                render(c, u) {
                    const h = i.get(u);
                    return h !== void 0 ? Promise.resolve(h) : a(c, u)
                }
            }
        }, Eme = (t, e) => (n, r) => {
            const s = e.get(n);
            if (s !== void 0) return s;
            const i = t.get(n);
            if (i !== void 0) return i;
            try {
                const a = r();
                return a instanceof Promise ? (t.set(n, a), a.catch(() => !1).then(c => (t.delete(n), e.set(n, c), c))) : (e.set(n, a), a)
            } catch {
                return e.set(n, !1), !1
            }
        }, Tme = {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: 6
        }, Sme = (t, e, n, r, s) => class extends t {
            constructor(a, c) {
                const u = r(a),
                    h = {
                        ...Tme,
                        ...c
                    },
                    d = n(u, h),
                    p = s(u) ? e() : null;
                super(a, !1, d, p)
            }
        }, wme = (t, e, n) => () => {
            const r = new WeakMap,
                s = async (i, a) => {
                    let c = e(i);
                    if (!ir(c, a)) {
                        const h = {
                            channelCount: c.channelCount,
                            channelCountMode: c.channelCountMode,
                            channelInterpretation: c.channelInterpretation,
                            numberOfInputs: c.numberOfInputs
                        };
                        c = t(a, h)
                    }
                    return r.set(a, c), await n(i, a, c), c
                };
            return {
                render(i, a) {
                    const c = r.get(a);
                    return c !== void 0 ? Promise.resolve(c) : s(i, a)
                }
            }
        }, Ome = {
            channelCount: 6,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            numberOfOutputs: 6
        }, Ame = (t, e, n, r, s, i) => class extends t {
            constructor(c, u) {
                const h = r(c),
                    d = i({
                        ...Ome,
                        ...u
                    }),
                    p = n(h, d),
                    m = s(h) ? e() : null;
                super(c, !1, p, m)
            }
        }, Cme = (t, e, n) => () => {
            const r = new WeakMap,
                s = async (i, a) => {
                    let c = e(i);
                    if (!ir(c, a)) {
                        const h = {
                            channelCount: c.channelCount,
                            channelCountMode: c.channelCountMode,
                            channelInterpretation: c.channelInterpretation,
                            numberOfOutputs: c.numberOfOutputs
                        };
                        c = t(a, h)
                    }
                    return r.set(a, c), await n(i, a, c), c
                };
            return {
                render(i, a) {
                    const c = r.get(a);
                    return c !== void 0 ? Promise.resolve(c) : s(i, a)
                }
            }
        }, kme = t => (e, n, r) => t(n, e, r), Ime = t => (e, n, r = 0, s = 0) => {
            const i = e[r];
            if (i === void 0) throw t();
            return $d(n) ? i.connect(n, 0, s) : i.connect(n, 0)
        }, Nme = t => (e, n) => {
            const r = t(e, {
                    buffer: null,
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    loop: !1,
                    loopEnd: 0,
                    loopStart: 0,
                    playbackRate: 1
                }),
                s = e.createBuffer(1, 2, 44100);
            return r.buffer = s, r.loop = !0, r.connect(n), r.start(), () => {
                r.stop(), r.disconnect(n)
            }
        }, xme = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            offset: 1
        }, Pme = (t, e, n, r, s, i, a) => class extends t {
            constructor(u, h) {
                const d = s(u),
                    p = {
                        ...xme,
                        ...h
                    },
                    m = r(d, p),
                    _ = i(d),
                    y = _ ? n() : null;
                super(u, !1, m, y), this._constantSourceNodeRenderer = y, this._nativeConstantSourceNode = m, this._offset = e(this, _, m.offset, hr, Sr), this._onended = null
            }
            get offset() {
                return this._offset
            }
            get onended() {
                return this._onended
            }
            set onended(u) {
                const h = typeof u == "function" ? a(this, u) : null;
                this._nativeConstantSourceNode.onended = h;
                const d = this._nativeConstantSourceNode.onended;
                this._onended = d !== null && d === h ? u : d
            }
            start(u = 0) {
                if (this._nativeConstantSourceNode.start(u), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.start = u), this.context.state !== "closed") {
                    qc(this);
                    const h = () => {
                        this._nativeConstantSourceNode.removeEventListener("ended", h), Ni(this) && lh(this)
                    };
                    this._nativeConstantSourceNode.addEventListener("ended", h)
                }
            }
            stop(u = 0) {
                this._nativeConstantSourceNode.stop(u), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.stop = u)
            }
        }, Rme = (t, e, n, r, s) => () => {
            const i = new WeakMap;
            let a = null,
                c = null;
            const u = async (h, d) => {
                let p = n(h);
                const m = ir(p, d);
                if (!m) {
                    const _ = {
                        channelCount: p.channelCount,
                        channelCountMode: p.channelCountMode,
                        channelInterpretation: p.channelInterpretation,
                        offset: p.offset.value
                    };
                    p = e(d, _), a !== null && p.start(a), c !== null && p.stop(c)
                }
                return i.set(d, p), m ? await t(d, h.offset, p.offset) : await r(d, h.offset, p.offset), await s(h, d, p), p
            };
            return {
                set start(h) {
                    a = h
                },
                set stop(h) {
                    c = h
                },
                render(h, d) {
                    const p = i.get(d);
                    return p !== void 0 ? Promise.resolve(p) : u(h, d)
                }
            }
        }, Mme = t => e => (t[0] = e, t[0]), Dme = {
            buffer: null,
            channelCount: 2,
            channelCountMode: "clamped-max",
            channelInterpretation: "speakers",
            disableNormalization: !1
        }, $me = (t, e, n, r, s, i) => class extends t {
            constructor(c, u) {
                const h = r(c),
                    d = {
                        ...Dme,
                        ...u
                    },
                    p = n(h, d),
                    _ = s(h) ? e() : null;
                super(c, !1, p, _), this._isBufferNullified = !1, this._nativeConvolverNode = p, d.buffer !== null && i(this, d.buffer.duration)
            }
            get buffer() {
                return this._isBufferNullified ? null : this._nativeConvolverNode.buffer
            }
            set buffer(c) {
                if (this._nativeConvolverNode.buffer = c, c === null && this._nativeConvolverNode.buffer !== null) {
                    const u = this._nativeConvolverNode.context;
                    this._nativeConvolverNode.buffer = u.createBuffer(1, 1, u.sampleRate), this._isBufferNullified = !0, i(this, 0)
                } else this._isBufferNullified = !1, i(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration)
            }
            get normalize() {
                return this._nativeConvolverNode.normalize
            }
            set normalize(c) {
                this._nativeConvolverNode.normalize = c
            }
        }, Lme = (t, e, n) => () => {
            const r = new WeakMap,
                s = async (i, a) => {
                    let c = e(i);
                    if (!ir(c, a)) {
                        const h = {
                            buffer: c.buffer,
                            channelCount: c.channelCount,
                            channelCountMode: c.channelCountMode,
                            channelInterpretation: c.channelInterpretation,
                            disableNormalization: !c.normalize
                        };
                        c = t(a, h)
                    }
                    return r.set(a, c), dl(c) ? await n(i, a, c.inputs[0]) : await n(i, a, c), c
                };
            return {
                render(i, a) {
                    const c = r.get(a);
                    return c !== void 0 ? Promise.resolve(c) : s(i, a)
                }
            }
        }, Fme = (t, e) => (n, r, s) => {
            if (e === null) throw new Error("Missing the native OfflineAudioContext constructor.");
            try {
                return new e(n, r, s)
            } catch (i) {
                throw i.name === "SyntaxError" ? t() : i
            }
        }, Ume = () => new DOMException("", "DataCloneError"), $3 = t => {
            const {
                port1: e,
                port2: n
            } = new MessageChannel;
            return new Promise(r => {
                const s = () => {
                    n.onmessage = null, e.close(), n.close(), r()
                };
                n.onmessage = () => s();
                try {
                    e.postMessage(t, [t])
                } finally {
                    s()
                }
            })
        }, Bme = (t, e, n, r, s, i, a, c, u, h, d) => (p, m) => {
            const _ = a(p) ? p : i(p);
            if (s.has(m)) {
                const y = n();
                return Promise.reject(y)
            }
            try {
                s.add(m)
            } catch {}
            return e(u, () => u(_)) ? _.decodeAudioData(m).then(y => ($3(m).catch(() => {}), e(c, () => c(y)) || d(y), t.add(y), y)) : new Promise((y, v) => {
                const w = async () => {
                    try {
                        await $3(m)
                    } catch {}
                }, b = I => {
                    v(I), w()
                };
                try {
                    _.decodeAudioData(m, I => {
                        typeof I.copyFromChannel != "function" && (h(I), b0(I)), t.add(I), w().then(() => y(I))
                    }, I => {
                        b(I === null ? r() : I)
                    })
                } catch (I) {
                    b(I)
                }
            })
        }, qme = (t, e, n, r, s, i, a, c) => (u, h) => {
            const d = e.get(u);
            if (d === void 0) throw new Error("Missing the expected cycle count.");
            const p = i(u.context),
                m = c(p);
            if (d === h) {
                if (e.delete(u), !m && a(u)) {
                    const _ = r(u),
                        {
                            outputs: y
                        } = n(u);
                    for (const v of y)
                        if (hh(v)) {
                            const w = r(v[0]);
                            t(_, w, v[1], v[2])
                        } else {
                            const w = s(v[0]);
                            _.connect(w, v[1])
                        }
                }
            } else e.set(u, d - h)
        }, jme = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            delayTime: 0,
            maxDelayTime: 1
        }, Vme = (t, e, n, r, s, i, a) => class extends t {
            constructor(u, h) {
                const d = s(u),
                    p = {
                        ...jme,
                        ...h
                    },
                    m = r(d, p),
                    _ = i(d),
                    y = _ ? n(p.maxDelayTime) : null;
                super(u, !1, m, y), this._delayTime = e(this, _, m.delayTime), a(this, p.maxDelayTime)
            }
            get delayTime() {
                return this._delayTime
            }
        }, Gme = (t, e, n, r, s) => i => {
            const a = new WeakMap,
                c = async (u, h) => {
                    let d = n(u);
                    const p = ir(d, h);
                    if (!p) {
                        const m = {
                            channelCount: d.channelCount,
                            channelCountMode: d.channelCountMode,
                            channelInterpretation: d.channelInterpretation,
                            delayTime: d.delayTime.value,
                            maxDelayTime: i
                        };
                        d = e(h, m)
                    }
                    return a.set(h, d), p ? await t(h, u.delayTime, d.delayTime) : await r(h, u.delayTime, d.delayTime), await s(u, h, d), d
                };
            return {
                render(u, h) {
                    const d = a.get(h);
                    return d !== void 0 ? Promise.resolve(d) : c(u, h)
                }
            }
        }, Wme = t => (e, n, r, s) => t(e[s], i => i[0] === n && i[1] === r), Hme = t => (e, n) => {
            t(e).delete(n)
        }, Kme = t => "delayTime" in t, Yme = (t, e, n) => function r(s, i) {
            const a = Rd(i) ? i : n(t, i);
            if (Kme(a)) return [];
            if (s[0] === a) return [s];
            if (s.includes(a)) return [];
            const {
                outputs: c
            } = e(a);
            return Array.from(c).map(u => r([...s, a], u[0])).reduce((u, h) => u.concat(h), [])
        }, Uf = (t, e, n) => {
            const r = e[n];
            if (r === void 0) throw t();
            return r
        }, zme = t => (e, n = void 0, r = void 0, s = 0) => n === void 0 ? e.forEach(i => i.disconnect()) : typeof n == "number" ? Uf(t, e, n).disconnect() : $d(n) ? r === void 0 ? e.forEach(i => i.disconnect(n)) : s === void 0 ? Uf(t, e, r).disconnect(n, 0) : Uf(t, e, r).disconnect(n, 0, s) : r === void 0 ? e.forEach(i => i.disconnect(n)) : Uf(t, e, r).disconnect(n, 0), Zme = {
            attack: .003,
            channelCount: 2,
            channelCountMode: "clamped-max",
            channelInterpretation: "speakers",
            knee: 30,
            ratio: 12,
            release: .25,
            threshold: -24
        }, Xme = (t, e, n, r, s, i, a, c) => class extends t {
            constructor(h, d) {
                const p = i(h),
                    m = {
                        ...Zme,
                        ...d
                    },
                    _ = r(p, m),
                    y = a(p),
                    v = y ? n() : null;
                super(h, !1, _, v), this._attack = e(this, y, _.attack), this._knee = e(this, y, _.knee), this._nativeDynamicsCompressorNode = _, this._ratio = e(this, y, _.ratio), this._release = e(this, y, _.release), this._threshold = e(this, y, _.threshold), c(this, .006)
            }
            get attack() {
                return this._attack
            }
            get channelCount() {
                return this._nativeDynamicsCompressorNode.channelCount
            }
            set channelCount(h) {
                const d = this._nativeDynamicsCompressorNode.channelCount;
                if (this._nativeDynamicsCompressorNode.channelCount = h, h > 2) throw this._nativeDynamicsCompressorNode.channelCount = d, s()
            }
            get channelCountMode() {
                return this._nativeDynamicsCompressorNode.channelCountMode
            }
            set channelCountMode(h) {
                const d = this._nativeDynamicsCompressorNode.channelCountMode;
                if (this._nativeDynamicsCompressorNode.channelCountMode = h, h === "max") throw this._nativeDynamicsCompressorNode.channelCountMode = d, s()
            }
            get knee() {
                return this._knee
            }
            get ratio() {
                return this._ratio
            }
            get reduction() {
                return typeof this._nativeDynamicsCompressorNode.reduction.value == "number" ? this._nativeDynamicsCompressorNode.reduction.value : this._nativeDynamicsCompressorNode.reduction
            }
            get release() {
                return this._release
            }
            get threshold() {
                return this._threshold
            }
        }, Jme = (t, e, n, r, s) => () => {
            const i = new WeakMap,
                a = async (c, u) => {
                    let h = n(c);
                    const d = ir(h, u);
                    if (!d) {
                        const p = {
                            attack: h.attack.value,
                            channelCount: h.channelCount,
                            channelCountMode: h.channelCountMode,
                            channelInterpretation: h.channelInterpretation,
                            knee: h.knee.value,
                            ratio: h.ratio.value,
                            release: h.release.value,
                            threshold: h.threshold.value
                        };
                        h = e(u, p)
                    }
                    return i.set(u, h), d ? (await t(u, c.attack, h.attack), await t(u, c.knee, h.knee), await t(u, c.ratio, h.ratio), await t(u, c.release, h.release), await t(u, c.threshold, h.threshold)) : (await r(u, c.attack, h.attack), await r(u, c.knee, h.knee), await r(u, c.ratio, h.ratio), await r(u, c.release, h.release), await r(u, c.threshold, h.threshold)), await s(c, u, h), h
                };
            return {
                render(c, u) {
                    const h = i.get(u);
                    return h !== void 0 ? Promise.resolve(h) : a(c, u)
                }
            }
        }, Qme = () => new DOMException("", "EncodingError"), ege = t => e => new Promise((n, r) => {
            if (t === null) {
                r(new SyntaxError);
                return
            }
            const s = t.document.head;
            if (s === null) r(new SyntaxError);
            else {
                const i = t.document.createElement("script"),
                    a = new Blob([e], {
                        type: "application/javascript"
                    }),
                    c = URL.createObjectURL(a),
                    u = t.onerror,
                    h = () => {
                        t.onerror = u, URL.revokeObjectURL(c)
                    };
                t.onerror = (d, p, m, _, y) => {
                    if (p === c || p === t.location.href && m === 1 && _ === 1) return h(), r(y), !1;
                    if (u !== null) return u(d, p, m, _, y)
                }, i.onerror = () => {
                    h(), r(new SyntaxError)
                }, i.onload = () => {
                    h(), n()
                }, i.src = c, i.type = "module", s.appendChild(i)
            }
        }), tge = t => class {
            constructor(n) {
                this._nativeEventTarget = n, this._listeners = new WeakMap
            }
            addEventListener(n, r, s) {
                if (r !== null) {
                    let i = this._listeners.get(r);
                    i === void 0 && (i = t(this, r), typeof r == "function" && this._listeners.set(r, i)), this._nativeEventTarget.addEventListener(n, i, s)
                }
            }
            dispatchEvent(n) {
                return this._nativeEventTarget.dispatchEvent(n)
            }
            removeEventListener(n, r, s) {
                const i = r === null ? void 0 : this._listeners.get(r);
                this._nativeEventTarget.removeEventListener(n, i === void 0 ? null : i, s)
            }
        }, nge = t => (e, n, r) => {
            Object.defineProperties(t, {
                currentFrame: {
                    configurable: !0,
                    get() {
                        return Math.round(e * n)
                    }
                },
                currentTime: {
                    configurable: !0,
                    get() {
                        return e
                    }
                }
            });
            try {
                return r()
            } finally {
                t !== null && (delete t.currentFrame, delete t.currentTime)
            }
        }, rge = t => async e => {
            try {
                const n = await fetch(e);
                if (n.ok) return [await n.text(), n.url]
            } catch {}
            throw t()
        }, sge = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            gain: 1
        }, ige = (t, e, n, r, s, i) => class extends t {
            constructor(c, u) {
                const h = s(c),
                    d = {
                        ...sge,
                        ...u
                    },
                    p = r(h, d),
                    m = i(h),
                    _ = m ? n() : null;
                super(c, !1, p, _), this._gain = e(this, m, p.gain, hr, Sr)
            }
            get gain() {
                return this._gain
            }
        }, oge = (t, e, n, r, s) => () => {
            const i = new WeakMap,
                a = async (c, u) => {
                    let h = n(c);
                    const d = ir(h, u);
                    if (!d) {
                        const p = {
                            channelCount: h.channelCount,
                            channelCountMode: h.channelCountMode,
                            channelInterpretation: h.channelInterpretation,
                            gain: h.gain.value
                        };
                        h = e(u, p)
                    }
                    return i.set(u, h), d ? await t(u, c.gain, h.gain) : await r(u, c.gain, h.gain), await s(c, u, h), h
                };
            return {
                render(c, u) {
                    const h = i.get(u);
                    return h !== void 0 ? Promise.resolve(h) : a(c, u)
                }
            }
        }, age = (t, e) => n => e(t, n), cge = t => e => {
            const n = t(e);
            if (n.renderer === null) throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
            return n.renderer
        }, lge = t => e => {
            var n;
            return (n = t.get(e)) !== null && n !== void 0 ? n : 0
        }, uge = t => e => {
            const n = t(e);
            if (n.renderer === null) throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
            return n.renderer
        }, hge = t => e => t.get(e), Fn = () => new DOMException("", "InvalidStateError"), fge = t => e => {
            const n = t.get(e);
            if (n === void 0) throw Fn();
            return n
        }, dge = (t, e) => n => {
            let r = t.get(n);
            if (r !== void 0) return r;
            if (e === null) throw new Error("Missing the native OfflineAudioContext constructor.");
            return r = new e(1, 1, 44100), t.set(n, r), r
        }, pge = t => e => {
            const n = t.get(e);
            if (n === void 0) throw new Error("The context has no set of AudioWorkletNodes.");
            return n
        }, Tm = () => new DOMException("", "InvalidAccessError"), mge = t => {
            t.getFrequencyResponse = (e => (n, r, s) => {
                if (n.length !== r.length || r.length !== s.length) throw Tm();
                return e.call(t, n, r, s)
            })(t.getFrequencyResponse)
        }, gge = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers"
        }, _ge = (t, e, n, r, s, i) => class extends t {
            constructor(c, u) {
                const h = r(c),
                    d = s(h),
                    p = {
                        ...gge,
                        ...u
                    },
                    m = e(h, d ? null : c.baseLatency, p),
                    _ = d ? n(p.feedback, p.feedforward) : null;
                super(c, !1, m, _), mge(m), this._nativeIIRFilterNode = m, i(this, 1)
            }
            getFrequencyResponse(c, u, h) {
                return this._nativeIIRFilterNode.getFrequencyResponse(c, u, h)
            }
        }, ak = (t, e, n, r, s, i, a, c, u, h, d) => {
            const p = h.length;
            let m = c;
            for (let _ = 0; _ < p; _ += 1) {
                let y = n[0] * h[_];
                for (let v = 1; v < s; v += 1) {
                    const w = m - v & u - 1;
                    y += n[v] * i[w], y -= t[v] * a[w]
                }
                for (let v = s; v < r; v += 1) y += n[v] * i[m - v & u - 1];
                for (let v = s; v < e; v += 1) y -= t[v] * a[m - v & u - 1];
                i[m] = h[_], a[m] = y, m = m + 1 & u - 1, d[_] = y
            }
            return m
        }, yge = (t, e, n, r) => {
            const s = n instanceof Float64Array ? n : new Float64Array(n),
                i = r instanceof Float64Array ? r : new Float64Array(r),
                a = s.length,
                c = i.length,
                u = Math.min(a, c);
            if (s[0] !== 1) {
                for (let y = 0; y < a; y += 1) i[y] /= s[0];
                for (let y = 1; y < c; y += 1) s[y] /= s[0]
            }
            const h = 32,
                d = new Float32Array(h),
                p = new Float32Array(h),
                m = e.createBuffer(t.numberOfChannels, t.length, t.sampleRate),
                _ = t.numberOfChannels;
            for (let y = 0; y < _; y += 1) {
                const v = t.getChannelData(y),
                    w = m.getChannelData(y);
                d.fill(0), p.fill(0), ak(s, a, i, c, u, d, p, 0, h, v, w)
            }
            return m
        }, vge = (t, e, n, r, s) => (i, a) => {
            const c = new WeakMap;
            let u = null;
            const h = async (d, p) => {
                let m = null,
                    _ = e(d);
                const y = ir(_, p);
                if (p.createIIRFilter === void 0 ? m = t(p, {
                        buffer: null,
                        channelCount: 2,
                        channelCountMode: "max",
                        channelInterpretation: "speakers",
                        loop: !1,
                        loopEnd: 0,
                        loopStart: 0,
                        playbackRate: 1
                    }) : y || (_ = p.createIIRFilter(a, i)), c.set(p, m === null ? _ : m), m !== null) {
                    if (u === null) {
                        if (n === null) throw new Error("Missing the native OfflineAudioContext constructor.");
                        const w = new n(d.context.destination.channelCount, d.context.length, p.sampleRate);
                        u = (async () => {
                            await r(d, w, w.destination);
                            const b = await s(w);
                            return yge(b, p, i, a)
                        })()
                    }
                    const v = await u;
                    return m.buffer = v, m.start(0), m
                }
                return await r(d, p, _), _
            };
            return {
                render(d, p) {
                    const m = c.get(p);
                    return m !== void 0 ? Promise.resolve(m) : h(d, p)
                }
            }
        }, bge = (t, e, n, r, s, i) => a => (c, u) => {
            const h = t.get(c);
            if (h === void 0) {
                if (!a && i(c)) {
                    const d = r(c),
                        {
                            outputs: p
                        } = n(c);
                    for (const m of p)
                        if (hh(m)) {
                            const _ = r(m[0]);
                            e(d, _, m[1], m[2])
                        } else {
                            const _ = s(m[0]);
                            d.disconnect(_, m[1])
                        }
                }
                t.set(c, u)
            } else t.set(c, h + u)
        }, Ege = (t, e) => n => {
            const r = t.get(n);
            return e(r) || e(n)
        }, Tge = (t, e) => n => t.has(n) || e(n), Sge = (t, e) => n => t.has(n) || e(n), wge = (t, e) => n => {
            const r = t.get(n);
            return e(r) || e(n)
        }, Oge = t => e => t !== null && e instanceof t, Age = t => e => t !== null && typeof t.AudioNode == "function" && e instanceof t.AudioNode, Cge = t => e => t !== null && typeof t.AudioParam == "function" && e instanceof t.AudioParam, kge = (t, e) => n => t(n) || e(n), Ige = t => e => t !== null && e instanceof t, Nge = t => t !== null && t.isSecureContext, xge = (t, e, n, r) => class extends t {
            constructor(i, a) {
                const c = n(i),
                    u = e(c, a);
                if (r(c)) throw TypeError();
                super(i, !0, u, null), this._nativeMediaElementAudioSourceNode = u
            }
            get mediaElement() {
                return this._nativeMediaElementAudioSourceNode.mediaElement
            }
        }, Pge = {
            channelCount: 2,
            channelCountMode: "explicit",
            channelInterpretation: "speakers"
        }, Rge = (t, e, n, r) => class extends t {
            constructor(i, a) {
                const c = n(i);
                if (r(c)) throw new TypeError;
                const u = {
                        ...Pge,
                        ...a
                    },
                    h = e(c, u);
                super(i, !1, h, null), this._nativeMediaStreamAudioDestinationNode = h
            }
            get stream() {
                return this._nativeMediaStreamAudioDestinationNode.stream
            }
        }, Mge = (t, e, n, r) => class extends t {
            constructor(i, a) {
                const c = n(i),
                    u = e(c, a);
                if (r(c)) throw new TypeError;
                super(i, !0, u, null), this._nativeMediaStreamAudioSourceNode = u
            }
            get mediaStream() {
                return this._nativeMediaStreamAudioSourceNode.mediaStream
            }
        }, Dge = (t, e, n) => class extends t {
            constructor(s, i) {
                const a = n(s),
                    c = e(a, i);
                super(s, !0, c, null)
            }
        }, $ge = (t, e, n, r, s, i) => class extends n {
            constructor(c, u) {
                super(c), this._nativeContext = c, bm.set(this, c), r(c) && s.set(c, new Set), this._destination = new t(this, u), this._listener = e(this, c), this._onstatechange = null
            }
            get currentTime() {
                return this._nativeContext.currentTime
            }
            get destination() {
                return this._destination
            }
            get listener() {
                return this._listener
            }
            get onstatechange() {
                return this._onstatechange
            }
            set onstatechange(c) {
                const u = typeof c == "function" ? i(this, c) : null;
                this._nativeContext.onstatechange = u;
                const h = this._nativeContext.onstatechange;
                this._onstatechange = h !== null && h === u ? c : h
            }
            get sampleRate() {
                return this._nativeContext.sampleRate
            }
            get state() {
                return this._nativeContext.state
            }
        }, Su = t => {
            const e = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
            try {
                const n = t.decodeAudioData(e.buffer, () => {});
                return n === void 0 ? !1 : (n.catch(() => {}), !0)
            } catch {}
            return !1
        }, Lge = (t, e) => (n, r, s) => {
            const i = new Set;
            return n.connect = (a => (c, u = 0, h = 0) => {
                const d = i.size === 0;
                if (e(c)) return a.call(n, c, u, h), t(i, [c, u, h], p => p[0] === c && p[1] === u && p[2] === h, !0), d && r(), c;
                a.call(n, c, u), t(i, [c, u], p => p[0] === c && p[1] === u, !0), d && r()
            })(n.connect), n.disconnect = (a => (c, u, h) => {
                const d = i.size > 0;
                if (c === void 0) a.apply(n), i.clear();
                else if (typeof c == "number") {
                    a.call(n, c);
                    for (const m of i) m[1] === c && i.delete(m)
                } else {
                    e(c) ? a.call(n, c, u, h) : a.call(n, c, u);
                    for (const m of i) m[0] === c && (u === void 0 || m[1] === u) && (h === void 0 || m[2] === h) && i.delete(m)
                }
                const p = i.size === 0;
                d && p && s()
            })(n.disconnect), n
        }, nn = (t, e, n) => {
            const r = e[n];
            r !== void 0 && r !== t[n] && (t[n] = r)
        }, Pn = (t, e) => {
            nn(t, e, "channelCount"), nn(t, e, "channelCountMode"), nn(t, e, "channelInterpretation")
        }, L3 = t => typeof t.getFloatTimeDomainData == "function", Fge = t => {
            t.getFloatTimeDomainData = e => {
                const n = new Uint8Array(e.length);
                t.getByteTimeDomainData(n);
                const r = Math.max(n.length, t.fftSize);
                for (let s = 0; s < r; s += 1) e[s] = (n[s] - 128) * .0078125;
                return e
            }
        }, Uge = (t, e) => (n, r) => {
            const s = n.createAnalyser();
            if (Pn(s, r), !(r.maxDecibels > r.minDecibels)) throw e();
            return nn(s, r, "fftSize"), nn(s, r, "maxDecibels"), nn(s, r, "minDecibels"), nn(s, r, "smoothingTimeConstant"), t(L3, () => L3(s)) || Fge(s), s
        }, Bge = t => t === null ? null : t.hasOwnProperty("AudioBuffer") ? t.AudioBuffer : null, un = (t, e, n) => {
            const r = e[n];
            r !== void 0 && r !== t[n].value && (t[n].value = r)
        }, qge = t => {
            t.start = (e => {
                let n = !1;
                return (r = 0, s = 0, i) => {
                    if (n) throw Fn();
                    e.call(t, r, s, i), n = !0
                }
            })(t.start)
        }, S0 = t => {
            t.start = (e => (n = 0, r = 0, s) => {
                if (typeof s == "number" && s < 0 || r < 0 || n < 0) throw new RangeError("The parameters can't be negative.");
                e.call(t, n, r, s)
            })(t.start)
        }, w0 = t => {
            t.stop = (e => (n = 0) => {
                if (n < 0) throw new RangeError("The parameter can't be negative.");
                e.call(t, n)
            })(t.stop)
        }, jge = (t, e, n, r, s, i, a, c, u, h, d) => (p, m) => {
            const _ = p.createBufferSource();
            return Pn(_, m), un(_, m, "playbackRate"), nn(_, m, "buffer"), nn(_, m, "loop"), nn(_, m, "loopEnd"), nn(_, m, "loopStart"), e(n, () => n(p)) || qge(_), e(r, () => r(p)) || u(_), e(s, () => s(p)) || h(_, p), e(i, () => i(p)) || S0(_), e(a, () => a(p)) || d(_, p), e(c, () => c(p)) || w0(_), t(p, _), _
        }, Vge = t => t === null ? null : t.hasOwnProperty("AudioContext") ? t.AudioContext : t.hasOwnProperty("webkitAudioContext") ? t.webkitAudioContext : null, Gge = (t, e) => (n, r, s) => {
            const i = n.destination;
            if (i.channelCount !== r) try {
                i.channelCount = r
            } catch {}
            s && i.channelCountMode !== "explicit" && (i.channelCountMode = "explicit"), i.maxChannelCount === 0 && Object.defineProperty(i, "maxChannelCount", {
                value: r
            });
            const a = t(n, {
                channelCount: r,
                channelCountMode: i.channelCountMode,
                channelInterpretation: i.channelInterpretation,
                gain: 1
            });
            return e(a, "channelCount", c => () => c.call(a), c => u => {
                c.call(a, u);
                try {
                    i.channelCount = u
                } catch (h) {
                    if (u > i.maxChannelCount) throw h
                }
            }), e(a, "channelCountMode", c => () => c.call(a), c => u => {
                c.call(a, u), i.channelCountMode = u
            }), e(a, "channelInterpretation", c => () => c.call(a), c => u => {
                c.call(a, u), i.channelInterpretation = u
            }), Object.defineProperty(a, "maxChannelCount", {
                get: () => i.maxChannelCount
            }), a.connect(i), a
        }, Wge = t => t === null ? null : t.hasOwnProperty("AudioWorkletNode") ? t.AudioWorkletNode : null, Hge = t => {
            const {
                port1: e
            } = new MessageChannel;
            try {
                e.postMessage(t)
            } finally {
                e.close()
            }
        }, Kge = (t, e, n, r, s) => (i, a, c, u, h, d) => {
            if (c !== null) try {
                const p = new c(i, u, d),
                    m = new Map;
                let _ = null;
                if (Object.defineProperties(p, {
                        channelCount: {
                            get: () => d.channelCount,
                            set: () => {
                                throw t()
                            }
                        },
                        channelCountMode: {
                            get: () => "explicit",
                            set: () => {
                                throw t()
                            }
                        },
                        onprocessorerror: {
                            get: () => _,
                            set: y => {
                                typeof _ == "function" && p.removeEventListener("processorerror", _), _ = typeof y == "function" ? y : null, typeof _ == "function" && p.addEventListener("processorerror", _)
                            }
                        }
                    }), p.addEventListener = (y => (...v) => {
                        if (v[0] === "processorerror") {
                            const w = typeof v[1] == "function" ? v[1] : typeof v[1] == "object" && v[1] !== null && typeof v[1].handleEvent == "function" ? v[1].handleEvent : null;
                            if (w !== null) {
                                const b = m.get(v[1]);
                                b !== void 0 ? v[1] = b : (v[1] = I => {
                                    I.type === "error" ? (Object.defineProperties(I, {
                                        type: {
                                            value: "processorerror"
                                        }
                                    }), w(I)) : w(new ErrorEvent(v[0], {
                                        ...I
                                    }))
                                }, m.set(w, v[1]))
                            }
                        }
                        return y.call(p, "error", v[1], v[2]), y.call(p, ...v)
                    })(p.addEventListener), p.removeEventListener = (y => (...v) => {
                        if (v[0] === "processorerror") {
                            const w = m.get(v[1]);
                            w !== void 0 && (m.delete(v[1]), v[1] = w)
                        }
                        return y.call(p, "error", v[1], v[2]), y.call(p, v[0], v[1], v[2])
                    })(p.removeEventListener), d.numberOfOutputs !== 0) {
                    const y = n(i, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    });
                    return p.connect(y).connect(i.destination), s(p, () => y.disconnect(), () => y.connect(i.destination))
                }
                return p
            } catch (p) {
                throw p.code === 11 ? r() : p
            }
            if (h === void 0) throw r();
            return Hge(d), e(i, a, h, d)
        }, ck = (t, e) => t === null ? 512 : Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(t * e))))), Yge = t => new Promise((e, n) => {
            const {
                port1: r,
                port2: s
            } = new MessageChannel;
            r.onmessage = ({
                data: i
            }) => {
                r.close(), s.close(), e(i)
            }, r.onmessageerror = ({
                data: i
            }) => {
                r.close(), s.close(), n(i)
            }, s.postMessage(t)
        }), zge = async (t, e) => {
            const n = await Yge(e);
            return new t(n)
        }, Zge = (t, e, n, r) => {
            let s = hy.get(t);
            s === void 0 && (s = new WeakMap, hy.set(t, s));
            const i = zge(n, r);
            return s.set(e, i), i
        }, Xge = (t, e, n, r, s, i, a, c, u, h, d, p, m) => (_, y, v, w) => {
            if (w.numberOfInputs === 0 && w.numberOfOutputs === 0) throw u();
            const b = Array.isArray(w.outputChannelCount) ? w.outputChannelCount : Array.from(w.outputChannelCount);
            if (b.some(N => N < 1)) throw u();
            if (b.length !== w.numberOfOutputs) throw e();
            if (w.channelCountMode !== "explicit") throw u();
            const I = w.channelCount * w.numberOfInputs,
                F = b.reduce((N, V) => N + V, 0),
                x = v.parameterDescriptors === void 0 ? 0 : v.parameterDescriptors.length;
            if (I + x > 6 || F > 6) throw u();
            const O = new MessageChannel,
                M = [],
                $ = [];
            for (let N = 0; N < w.numberOfInputs; N += 1) M.push(a(_, {
                channelCount: w.channelCount,
                channelCountMode: w.channelCountMode,
                channelInterpretation: w.channelInterpretation,
                gain: 1
            })), $.push(s(_, {
                channelCount: w.channelCount,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                numberOfOutputs: w.channelCount
            }));
            const j = [];
            if (v.parameterDescriptors !== void 0)
                for (const {
                        defaultValue: N,
                        maxValue: V,
                        minValue: te,
                        name: re
                    }
                    of v.parameterDescriptors) {
                    const ue = i(_, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        offset: w.parameterData[re] !== void 0 ? w.parameterData[re] : N === void 0 ? 0 : N
                    });
                    Object.defineProperties(ue.offset, {
                        defaultValue: {
                            get: () => N === void 0 ? 0 : N
                        },
                        maxValue: {
                            get: () => V === void 0 ? hr : V
                        },
                        minValue: {
                            get: () => te === void 0 ? Sr : te
                        }
                    }), j.push(ue)
                }
            const ee = r(_, {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers",
                    numberOfInputs: Math.max(1, I + x)
                }),
                se = ck(y, _.sampleRate),
                oe = c(_, se, I + x, Math.max(1, F)),
                Z = s(_, {
                    channelCount: Math.max(1, F),
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    numberOfOutputs: Math.max(1, F)
                }),
                de = [];
            for (let N = 0; N < w.numberOfOutputs; N += 1) de.push(r(_, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "speakers",
                numberOfInputs: b[N]
            }));
            for (let N = 0; N < w.numberOfInputs; N += 1) {
                M[N].connect($[N]);
                for (let V = 0; V < w.channelCount; V += 1) $[N].connect(ee, V, N * w.channelCount + V)
            }
            const q = new ik(v.parameterDescriptors === void 0 ? [] : v.parameterDescriptors.map(({
                name: N
            }, V) => {
                const te = j[V];
                return te.connect(ee, 0, I + V), te.start(0), [N, te.offset]
            }));
            ee.connect(oe);
            let ie = w.channelInterpretation,
                ae = null;
            const he = w.numberOfOutputs === 0 ? [oe] : de,
                ve = {
                    get bufferSize() {
                        return se
                    },
                    get channelCount() {
                        return w.channelCount
                    },
                    set channelCount(N) {
                        throw n()
                    },
                    get channelCountMode() {
                        return w.channelCountMode
                    },
                    set channelCountMode(N) {
                        throw n()
                    },
                    get channelInterpretation() {
                        return ie
                    },
                    set channelInterpretation(N) {
                        for (const V of M) V.channelInterpretation = N;
                        ie = N
                    },
                    get context() {
                        return oe.context
                    },
                    get inputs() {
                        return M
                    },
                    get numberOfInputs() {
                        return w.numberOfInputs
                    },
                    get numberOfOutputs() {
                        return w.numberOfOutputs
                    },
                    get onprocessorerror() {
                        return ae
                    },
                    set onprocessorerror(N) {
                        typeof ae == "function" && ve.removeEventListener("processorerror", ae), ae = typeof N == "function" ? N : null, typeof ae == "function" && ve.addEventListener("processorerror", ae)
                    },
                    get parameters() {
                        return q
                    },
                    get port() {
                        return O.port2
                    },
                    addEventListener(...N) {
                        return oe.addEventListener(N[0], N[1], N[2])
                    },
                    connect: t.bind(null, he),
                    disconnect: h.bind(null, he),
                    dispatchEvent(...N) {
                        return oe.dispatchEvent(N[0])
                    },
                    removeEventListener(...N) {
                        return oe.removeEventListener(N[0], N[1], N[2])
                    }
                },
                be = new Map;
            O.port1.addEventListener = (N => (...V) => {
                if (V[0] === "message") {
                    const te = typeof V[1] == "function" ? V[1] : typeof V[1] == "object" && V[1] !== null && typeof V[1].handleEvent == "function" ? V[1].handleEvent : null;
                    if (te !== null) {
                        const re = be.get(V[1]);
                        re !== void 0 ? V[1] = re : (V[1] = ue => {
                            d(_.currentTime, _.sampleRate, () => te(ue))
                        }, be.set(te, V[1]))
                    }
                }
                return N.call(O.port1, V[0], V[1], V[2])
            })(O.port1.addEventListener), O.port1.removeEventListener = (N => (...V) => {
                if (V[0] === "message") {
                    const te = be.get(V[1]);
                    te !== void 0 && (be.delete(V[1]), V[1] = te)
                }
                return N.call(O.port1, V[0], V[1], V[2])
            })(O.port1.removeEventListener);
            let Ae = null;
            Object.defineProperty(O.port1, "onmessage", {
                get: () => Ae,
                set: N => {
                    typeof Ae == "function" && O.port1.removeEventListener("message", Ae), Ae = typeof N == "function" ? N : null, typeof Ae == "function" && (O.port1.addEventListener("message", Ae), O.port1.start())
                }
            }), v.prototype.port = O.port1;
            let we = null;
            Zge(_, ve, v, w).then(N => we = N);
            const Nt = Fd(w.numberOfInputs, w.channelCount),
                jt = Fd(w.numberOfOutputs, b),
                Ue = v.parameterDescriptors === void 0 ? [] : v.parameterDescriptors.reduce((N, {
                    name: V
                }) => ({
                    ...N,
                    [V]: new Float32Array(128)
                }), {});
            let Ye = !0;
            const at = () => {
                    w.numberOfOutputs > 0 && oe.disconnect(Z);
                    for (let N = 0, V = 0; N < w.numberOfOutputs; N += 1) {
                        const te = de[N];
                        for (let re = 0; re < b[N]; re += 1) Z.disconnect(te, V + re, re);
                        V += b[N]
                    }
                },
                ke = new Map;
            oe.onaudioprocess = ({
                inputBuffer: N,
                outputBuffer: V
            }) => {
                if (we !== null) {
                    const te = p(ve);
                    for (let re = 0; re < se; re += 128) {
                        for (let ue = 0; ue < w.numberOfInputs; ue += 1)
                            for (let pe = 0; pe < w.channelCount; pe += 1) Ld(N, Nt[ue], pe, pe, re);
                        v.parameterDescriptors !== void 0 && v.parameterDescriptors.forEach(({
                            name: ue
                        }, pe) => {
                            Ld(N, Ue, ue, I + pe, re)
                        });
                        for (let ue = 0; ue < w.numberOfInputs; ue += 1)
                            for (let pe = 0; pe < b[ue]; pe += 1) jt[ue][pe].byteLength === 0 && (jt[ue][pe] = new Float32Array(128));
                        try {
                            const ue = Nt.map((ce, J) => {
                                if (te[J].size > 0) return ke.set(J, se / 128), ce;
                                const Ne = ke.get(J);
                                return Ne === void 0 ? [] : (ce.every(Pe => Pe.every(ze => ze === 0)) && (Ne === 1 ? ke.delete(J) : ke.set(J, Ne - 1)), ce)
                            });
                            Ye = d(_.currentTime + re / _.sampleRate, _.sampleRate, () => we.process(ue, jt, Ue));
                            for (let ce = 0, J = 0; ce < w.numberOfOutputs; ce += 1) {
                                for (let ne = 0; ne < b[ce]; ne += 1) ok(V, jt[ce], ne, J + ne, re);
                                J += b[ce]
                            }
                        } catch (ue) {
                            Ye = !1, ve.dispatchEvent(new ErrorEvent("processorerror", {
                                colno: ue.colno,
                                filename: ue.filename,
                                lineno: ue.lineno,
                                message: ue.message
                            }))
                        }
                        if (!Ye) {
                            for (let ue = 0; ue < w.numberOfInputs; ue += 1) {
                                M[ue].disconnect($[ue]);
                                for (let pe = 0; pe < w.channelCount; pe += 1) $[re].disconnect(ee, pe, ue * w.channelCount + pe)
                            }
                            if (v.parameterDescriptors !== void 0) {
                                const ue = v.parameterDescriptors.length;
                                for (let pe = 0; pe < ue; pe += 1) {
                                    const ce = j[pe];
                                    ce.disconnect(ee, 0, I + pe), ce.stop()
                                }
                            }
                            ee.disconnect(oe), oe.onaudioprocess = null, rt ? at() : U();
                            break
                        }
                    }
                }
            };
            let rt = !1;
            const Yt = a(_, {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    gain: 0
                }),
                zt = () => oe.connect(Yt).connect(_.destination),
                U = () => {
                    oe.disconnect(Yt), Yt.disconnect()
                },
                T = () => {
                    if (Ye) {
                        U(), w.numberOfOutputs > 0 && oe.connect(Z);
                        for (let N = 0, V = 0; N < w.numberOfOutputs; N += 1) {
                            const te = de[N];
                            for (let re = 0; re < b[N]; re += 1) Z.connect(te, V + re, re);
                            V += b[N]
                        }
                    }
                    rt = !0
                },
                S = () => {
                    Ye && (zt(), at()), rt = !1
                };
            return zt(), m(ve, T, S)
        }, lk = (t, e) => {
            const n = t.createBiquadFilter();
            return Pn(n, e), un(n, e, "Q"), un(n, e, "detune"), un(n, e, "frequency"), un(n, e, "gain"), nn(n, e, "type"), n
        }, Jge = (t, e) => (n, r) => {
            const s = n.createChannelMerger(r.numberOfInputs);
            return t !== null && t.name === "webkitAudioContext" && e(n, s), Pn(s, r), s
        }, Qge = t => {
            const e = t.numberOfOutputs;
            Object.defineProperty(t, "channelCount", {
                get: () => e,
                set: n => {
                    if (n !== e) throw Fn()
                }
            }), Object.defineProperty(t, "channelCountMode", {
                get: () => "explicit",
                set: n => {
                    if (n !== "explicit") throw Fn()
                }
            }), Object.defineProperty(t, "channelInterpretation", {
                get: () => "discrete",
                set: n => {
                    if (n !== "discrete") throw Fn()
                }
            })
        }, fh = (t, e) => {
            const n = t.createChannelSplitter(e.numberOfOutputs);
            return Pn(n, e), Qge(n), n
        }, e_e = (t, e, n, r, s) => (i, a) => {
            if (i.createConstantSource === void 0) return n(i, a);
            const c = i.createConstantSource();
            return Pn(c, a), un(c, a, "offset"), e(r, () => r(i)) || S0(c), e(s, () => s(i)) || w0(c), t(i, c), c
        }, pl = (t, e) => (t.connect = e.connect.bind(e), t.disconnect = e.disconnect.bind(e), t), t_e = (t, e, n, r) => (s, {
            offset: i,
            ...a
        }) => {
            const c = s.createBuffer(1, 2, 44100),
                u = e(s, {
                    buffer: null,
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    loop: !1,
                    loopEnd: 0,
                    loopStart: 0,
                    playbackRate: 1
                }),
                h = n(s, {
                    ...a,
                    gain: i
                }),
                d = c.getChannelData(0);
            d[0] = 1, d[1] = 1, u.buffer = c, u.loop = !0;
            const p = {
                    get bufferSize() {},
                    get channelCount() {
                        return h.channelCount
                    },
                    set channelCount(y) {
                        h.channelCount = y
                    },
                    get channelCountMode() {
                        return h.channelCountMode
                    },
                    set channelCountMode(y) {
                        h.channelCountMode = y
                    },
                    get channelInterpretation() {
                        return h.channelInterpretation
                    },
                    set channelInterpretation(y) {
                        h.channelInterpretation = y
                    },
                    get context() {
                        return h.context
                    },
                    get inputs() {
                        return []
                    },
                    get numberOfInputs() {
                        return u.numberOfInputs
                    },
                    get numberOfOutputs() {
                        return h.numberOfOutputs
                    },
                    get offset() {
                        return h.gain
                    },
                    get onended() {
                        return u.onended
                    },
                    set onended(y) {
                        u.onended = y
                    },
                    addEventListener(...y) {
                        return u.addEventListener(y[0], y[1], y[2])
                    },
                    dispatchEvent(...y) {
                        return u.dispatchEvent(y[0])
                    },
                    removeEventListener(...y) {
                        return u.removeEventListener(y[0], y[1], y[2])
                    },
                    start(y = 0) {
                        u.start.call(u, y)
                    },
                    stop(y = 0) {
                        u.stop.call(u, y)
                    }
                },
                m = () => u.connect(h),
                _ = () => u.disconnect(h);
            return t(s, u), r(pl(p, h), m, _)
        }, n_e = (t, e) => (n, r) => {
            const s = n.createConvolver();
            if (Pn(s, r), r.disableNormalization === s.normalize && (s.normalize = !r.disableNormalization), nn(s, r, "buffer"), r.channelCount > 2 || (e(s, "channelCount", i => () => i.call(s), i => a => {
                    if (a > 2) throw t();
                    return i.call(s, a)
                }), r.channelCountMode === "max")) throw t();
            return e(s, "channelCountMode", i => () => i.call(s), i => a => {
                if (a === "max") throw t();
                return i.call(s, a)
            }), s
        }, uk = (t, e) => {
            const n = t.createDelay(e.maxDelayTime);
            return Pn(n, e), un(n, e, "delayTime"), n
        }, r_e = t => (e, n) => {
            const r = e.createDynamicsCompressor();
            if (Pn(r, n), n.channelCount > 2 || n.channelCountMode === "max") throw t();
            return un(r, n, "attack"), un(r, n, "knee"), un(r, n, "ratio"), un(r, n, "release"), un(r, n, "threshold"), r
        }, Cr = (t, e) => {
            const n = t.createGain();
            return Pn(n, e), un(n, e, "gain"), n
        }, s_e = t => (e, n, r) => {
            if (e.createIIRFilter === void 0) return t(e, n, r);
            const s = e.createIIRFilter(r.feedforward, r.feedback);
            return Pn(s, r), s
        };

    function i_e(t, e) {
        const n = e[0] * e[0] + e[1] * e[1];
        return [(t[0] * e[0] + t[1] * e[1]) / n, (t[1] * e[0] - t[0] * e[1]) / n]
    }

    function o_e(t, e) {
        return [t[0] * e[0] - t[1] * e[1], t[0] * e[1] + t[1] * e[0]]
    }

    function F3(t, e) {
        let n = [0, 0];
        for (let r = t.length - 1; r >= 0; r -= 1) n = o_e(n, e), n[0] += t[r];
        return n
    }
    const a_e = (t, e, n, r) => (s, i, {
            channelCount: a,
            channelCountMode: c,
            channelInterpretation: u,
            feedback: h,
            feedforward: d
        }) => {
            const p = ck(i, s.sampleRate),
                m = h instanceof Float64Array ? h : new Float64Array(h),
                _ = d instanceof Float64Array ? d : new Float64Array(d),
                y = m.length,
                v = _.length,
                w = Math.min(y, v);
            if (y === 0 || y > 20) throw r();
            if (m[0] === 0) throw e();
            if (v === 0 || v > 20) throw r();
            if (_[0] === 0) throw e();
            if (m[0] !== 1) {
                for (let j = 0; j < v; j += 1) _[j] /= m[0];
                for (let j = 1; j < y; j += 1) m[j] /= m[0]
            }
            const b = n(s, p, a, a);
            b.channelCount = a, b.channelCountMode = c, b.channelInterpretation = u;
            const I = 32,
                F = [],
                x = [],
                O = [];
            for (let j = 0; j < a; j += 1) {
                F.push(0);
                const ee = new Float32Array(I),
                    se = new Float32Array(I);
                ee.fill(0), se.fill(0), x.push(ee), O.push(se)
            }
            b.onaudioprocess = j => {
                const ee = j.inputBuffer,
                    se = j.outputBuffer,
                    oe = ee.numberOfChannels;
                for (let Z = 0; Z < oe; Z += 1) {
                    const de = ee.getChannelData(Z),
                        q = se.getChannelData(Z);
                    F[Z] = ak(m, y, _, v, w, x[Z], O[Z], F[Z], I, de, q)
                }
            };
            const M = s.sampleRate / 2;
            return pl({
                get bufferSize() {
                    return p
                },
                get channelCount() {
                    return b.channelCount
                },
                set channelCount(j) {
                    b.channelCount = j
                },
                get channelCountMode() {
                    return b.channelCountMode
                },
                set channelCountMode(j) {
                    b.channelCountMode = j
                },
                get channelInterpretation() {
                    return b.channelInterpretation
                },
                set channelInterpretation(j) {
                    b.channelInterpretation = j
                },
                get context() {
                    return b.context
                },
                get inputs() {
                    return [b]
                },
                get numberOfInputs() {
                    return b.numberOfInputs
                },
                get numberOfOutputs() {
                    return b.numberOfOutputs
                },
                addEventListener(...j) {
                    return b.addEventListener(j[0], j[1], j[2])
                },
                dispatchEvent(...j) {
                    return b.dispatchEvent(j[0])
                },
                getFrequencyResponse(j, ee, se) {
                    if (j.length !== ee.length || ee.length !== se.length) throw t();
                    const oe = j.length;
                    for (let Z = 0; Z < oe; Z += 1) {
                        const de = -Math.PI * (j[Z] / M),
                            q = [Math.cos(de), Math.sin(de)],
                            ie = F3(_, q),
                            ae = F3(m, q),
                            he = i_e(ie, ae);
                        ee[Z] = Math.sqrt(he[0] * he[0] + he[1] * he[1]), se[Z] = Math.atan2(he[1], he[0])
                    }
                },
                removeEventListener(...j) {
                    return b.removeEventListener(j[0], j[1], j[2])
                }
            }, b)
        },
        c_e = (t, e) => t.createMediaElementSource(e.mediaElement),
        l_e = (t, e) => {
            const n = t.createMediaStreamDestination();
            return Pn(n, e), n.numberOfOutputs === 1 && Object.defineProperty(n, "numberOfOutputs", {
                get: () => 0
            }), n
        },
        u_e = (t, {
            mediaStream: e
        }) => {
            const n = e.getAudioTracks();
            n.sort((i, a) => i.id < a.id ? -1 : i.id > a.id ? 1 : 0);
            const r = n.slice(0, 1),
                s = t.createMediaStreamSource(new MediaStream(r));
            return Object.defineProperty(s, "mediaStream", {
                value: e
            }), s
        },
        h_e = (t, e) => (n, {
            mediaStreamTrack: r
        }) => {
            if (typeof n.createMediaStreamTrackSource == "function") return n.createMediaStreamTrackSource(r);
            const s = new MediaStream([r]),
                i = n.createMediaStreamSource(s);
            if (r.kind !== "audio") throw t();
            if (e(n)) throw new TypeError;
            return i
        },
        f_e = t => t === null ? null : t.hasOwnProperty("OfflineAudioContext") ? t.OfflineAudioContext : t.hasOwnProperty("webkitOfflineAudioContext") ? t.webkitOfflineAudioContext : null,
        d_e = (t, e, n, r, s, i) => (a, c) => {
            const u = a.createOscillator();
            return Pn(u, c), un(u, c, "detune"), un(u, c, "frequency"), c.periodicWave !== void 0 ? u.setPeriodicWave(c.periodicWave) : nn(u, c, "type"), e(n, () => n(a)) || S0(u), e(r, () => r(a)) || i(u, a), e(s, () => s(a)) || w0(u), t(a, u), u
        },
        p_e = t => (e, n) => {
            const r = e.createPanner();
            return r.orientationX === void 0 ? t(e, n) : (Pn(r, n), un(r, n, "orientationX"), un(r, n, "orientationY"), un(r, n, "orientationZ"), un(r, n, "positionX"), un(r, n, "positionY"), un(r, n, "positionZ"), nn(r, n, "coneInnerAngle"), nn(r, n, "coneOuterAngle"), nn(r, n, "coneOuterGain"), nn(r, n, "distanceModel"), nn(r, n, "maxDistance"), nn(r, n, "panningModel"), nn(r, n, "refDistance"), nn(r, n, "rolloffFactor"), r)
        },
        m_e = (t, e, n, r, s, i, a, c, u, h) => (d, {
            coneInnerAngle: p,
            coneOuterAngle: m,
            coneOuterGain: _,
            distanceModel: y,
            maxDistance: v,
            orientationX: w,
            orientationY: b,
            orientationZ: I,
            panningModel: F,
            positionX: x,
            positionY: O,
            positionZ: M,
            refDistance: $,
            rolloffFactor: j,
            ...ee
        }) => {
            const se = d.createPanner();
            if (ee.channelCount > 2 || ee.channelCountMode === "max") throw a();
            Pn(se, ee);
            const oe = {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete"
                },
                Z = n(d, {
                    ...oe,
                    channelInterpretation: "speakers",
                    numberOfInputs: 6
                }),
                de = r(d, {
                    ...ee,
                    gain: 1
                }),
                q = r(d, {
                    ...oe,
                    gain: 1
                }),
                ie = r(d, {
                    ...oe,
                    gain: 0
                }),
                ae = r(d, {
                    ...oe,
                    gain: 0
                }),
                he = r(d, {
                    ...oe,
                    gain: 0
                }),
                ve = r(d, {
                    ...oe,
                    gain: 0
                }),
                be = r(d, {
                    ...oe,
                    gain: 0
                }),
                Ae = s(d, 256, 6, 1),
                we = i(d, {
                    ...oe,
                    curve: new Float32Array([1, 1]),
                    oversample: "none"
                });
            let Me = [w, b, I],
                Nt = [x, O, M];
            const jt = new Float32Array(1);
            Ae.onaudioprocess = ({
                inputBuffer: ke
            }) => {
                const rt = [u(ke, jt, 0), u(ke, jt, 1), u(ke, jt, 2)];
                rt.some((zt, U) => zt !== Me[U]) && (se.setOrientation(...rt), Me = rt);
                const Yt = [u(ke, jt, 3), u(ke, jt, 4), u(ke, jt, 5)];
                Yt.some((zt, U) => zt !== Nt[U]) && (se.setPosition(...Yt), Nt = Yt)
            }, Object.defineProperty(ie.gain, "defaultValue", {
                get: () => 0
            }), Object.defineProperty(ae.gain, "defaultValue", {
                get: () => 0
            }), Object.defineProperty(he.gain, "defaultValue", {
                get: () => 0
            }), Object.defineProperty(ve.gain, "defaultValue", {
                get: () => 0
            }), Object.defineProperty(be.gain, "defaultValue", {
                get: () => 0
            });
            const Ue = {
                get bufferSize() {},
                get channelCount() {
                    return se.channelCount
                },
                set channelCount(ke) {
                    if (ke > 2) throw a();
                    de.channelCount = ke, se.channelCount = ke
                },
                get channelCountMode() {
                    return se.channelCountMode
                },
                set channelCountMode(ke) {
                    if (ke === "max") throw a();
                    de.channelCountMode = ke, se.channelCountMode = ke
                },
                get channelInterpretation() {
                    return se.channelInterpretation
                },
                set channelInterpretation(ke) {
                    de.channelInterpretation = ke, se.channelInterpretation = ke
                },
                get coneInnerAngle() {
                    return se.coneInnerAngle
                },
                set coneInnerAngle(ke) {
                    se.coneInnerAngle = ke
                },
                get coneOuterAngle() {
                    return se.coneOuterAngle
                },
                set coneOuterAngle(ke) {
                    se.coneOuterAngle = ke
                },
                get coneOuterGain() {
                    return se.coneOuterGain
                },
                set coneOuterGain(ke) {
                    if (ke < 0 || ke > 1) throw e();
                    se.coneOuterGain = ke
                },
                get context() {
                    return se.context
                },
                get distanceModel() {
                    return se.distanceModel
                },
                set distanceModel(ke) {
                    se.distanceModel = ke
                },
                get inputs() {
                    return [de]
                },
                get maxDistance() {
                    return se.maxDistance
                },
                set maxDistance(ke) {
                    if (ke < 0) throw new RangeError;
                    se.maxDistance = ke
                },
                get numberOfInputs() {
                    return se.numberOfInputs
                },
                get numberOfOutputs() {
                    return se.numberOfOutputs
                },
                get orientationX() {
                    return q.gain
                },
                get orientationY() {
                    return ie.gain
                },
                get orientationZ() {
                    return ae.gain
                },
                get panningModel() {
                    return se.panningModel
                },
                set panningModel(ke) {
                    se.panningModel = ke
                },
                get positionX() {
                    return he.gain
                },
                get positionY() {
                    return ve.gain
                },
                get positionZ() {
                    return be.gain
                },
                get refDistance() {
                    return se.refDistance
                },
                set refDistance(ke) {
                    if (ke < 0) throw new RangeError;
                    se.refDistance = ke
                },
                get rolloffFactor() {
                    return se.rolloffFactor
                },
                set rolloffFactor(ke) {
                    if (ke < 0) throw new RangeError;
                    se.rolloffFactor = ke
                },
                addEventListener(...ke) {
                    return de.addEventListener(ke[0], ke[1], ke[2])
                },
                dispatchEvent(...ke) {
                    return de.dispatchEvent(ke[0])
                },
                removeEventListener(...ke) {
                    return de.removeEventListener(ke[0], ke[1], ke[2])
                }
            };
            p !== Ue.coneInnerAngle && (Ue.coneInnerAngle = p), m !== Ue.coneOuterAngle && (Ue.coneOuterAngle = m), _ !== Ue.coneOuterGain && (Ue.coneOuterGain = _), y !== Ue.distanceModel && (Ue.distanceModel = y), v !== Ue.maxDistance && (Ue.maxDistance = v), w !== Ue.orientationX.value && (Ue.orientationX.value = w), b !== Ue.orientationY.value && (Ue.orientationY.value = b), I !== Ue.orientationZ.value && (Ue.orientationZ.value = I), F !== Ue.panningModel && (Ue.panningModel = F), x !== Ue.positionX.value && (Ue.positionX.value = x), O !== Ue.positionY.value && (Ue.positionY.value = O), M !== Ue.positionZ.value && (Ue.positionZ.value = M), $ !== Ue.refDistance && (Ue.refDistance = $), j !== Ue.rolloffFactor && (Ue.rolloffFactor = j), (Me[0] !== 1 || Me[1] !== 0 || Me[2] !== 0) && se.setOrientation(...Me), (Nt[0] !== 0 || Nt[1] !== 0 || Nt[2] !== 0) && se.setPosition(...Nt);
            const Ye = () => {
                    de.connect(se), t(de, we, 0, 0), we.connect(q).connect(Z, 0, 0), we.connect(ie).connect(Z, 0, 1), we.connect(ae).connect(Z, 0, 2), we.connect(he).connect(Z, 0, 3), we.connect(ve).connect(Z, 0, 4), we.connect(be).connect(Z, 0, 5), Z.connect(Ae).connect(d.destination)
                },
                at = () => {
                    de.disconnect(se), c(de, we, 0, 0), we.disconnect(q), q.disconnect(Z), we.disconnect(ie), ie.disconnect(Z), we.disconnect(ae), ae.disconnect(Z), we.disconnect(he), he.disconnect(Z), we.disconnect(ve), ve.disconnect(Z), we.disconnect(be), be.disconnect(Z), Z.disconnect(Ae), Ae.disconnect(d.destination)
                };
            return h(pl(Ue, se), Ye, at)
        },
        g_e = t => (e, {
            disableNormalization: n,
            imag: r,
            real: s
        }) => {
            const i = r instanceof Float32Array ? r : new Float32Array(r),
                a = s instanceof Float32Array ? s : new Float32Array(s),
                c = e.createPeriodicWave(a, i, {
                    disableNormalization: n
                });
            if (Array.from(r).length < 2) throw t();
            return c
        },
        dh = (t, e, n, r) => t.createScriptProcessor(e, n, r),
        __e = (t, e) => (n, r) => {
            const s = r.channelCountMode;
            if (s === "clamped-max") throw e();
            if (n.createStereoPanner === void 0) return t(n, r);
            const i = n.createStereoPanner();
            return Pn(i, r), un(i, r, "pan"), Object.defineProperty(i, "channelCountMode", {
                get: () => s,
                set: a => {
                    if (a !== s) throw e()
                }
            }), i
        },
        y_e = (t, e, n, r, s, i) => {
            const c = new Float32Array([1, 1]),
                u = Math.PI / 2,
                h = {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete"
                },
                d = {
                    ...h,
                    oversample: "none"
                },
                p = (y, v, w, b) => {
                    const I = new Float32Array(16385),
                        F = new Float32Array(16385);
                    for (let ee = 0; ee < 16385; ee += 1) {
                        const se = ee / 16384 * u;
                        I[ee] = Math.cos(se), F[ee] = Math.sin(se)
                    }
                    const x = n(y, {
                            ...h,
                            gain: 0
                        }),
                        O = r(y, {
                            ...d,
                            curve: I
                        }),
                        M = r(y, {
                            ...d,
                            curve: c
                        }),
                        $ = n(y, {
                            ...h,
                            gain: 0
                        }),
                        j = r(y, {
                            ...d,
                            curve: F
                        });
                    return {
                        connectGraph() {
                            v.connect(x), v.connect(M.inputs === void 0 ? M : M.inputs[0]), v.connect($), M.connect(w), w.connect(O.inputs === void 0 ? O : O.inputs[0]), w.connect(j.inputs === void 0 ? j : j.inputs[0]), O.connect(x.gain), j.connect($.gain), x.connect(b, 0, 0), $.connect(b, 0, 1)
                        },
                        disconnectGraph() {
                            v.disconnect(x), v.disconnect(M.inputs === void 0 ? M : M.inputs[0]), v.disconnect($), M.disconnect(w), w.disconnect(O.inputs === void 0 ? O : O.inputs[0]), w.disconnect(j.inputs === void 0 ? j : j.inputs[0]), O.disconnect(x.gain), j.disconnect($.gain), x.disconnect(b, 0, 0), $.disconnect(b, 0, 1)
                        }
                    }
                },
                m = (y, v, w, b) => {
                    const I = new Float32Array(16385),
                        F = new Float32Array(16385),
                        x = new Float32Array(16385),
                        O = new Float32Array(16385),
                        M = Math.floor(16385 / 2);
                    for (let he = 0; he < 16385; he += 1)
                        if (he > M) {
                            const ve = (he - M) / (16384 - M) * u;
                            I[he] = Math.cos(ve), F[he] = Math.sin(ve), x[he] = 0, O[he] = 1
                        } else {
                            const ve = he / (16384 - M) * u;
                            I[he] = 1, F[he] = 0, x[he] = Math.cos(ve), O[he] = Math.sin(ve)
                        } const $ = e(y, {
                            channelCount: 2,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            numberOfOutputs: 2
                        }),
                        j = n(y, {
                            ...h,
                            gain: 0
                        }),
                        ee = r(y, {
                            ...d,
                            curve: I
                        }),
                        se = n(y, {
                            ...h,
                            gain: 0
                        }),
                        oe = r(y, {
                            ...d,
                            curve: F
                        }),
                        Z = r(y, {
                            ...d,
                            curve: c
                        }),
                        de = n(y, {
                            ...h,
                            gain: 0
                        }),
                        q = r(y, {
                            ...d,
                            curve: x
                        }),
                        ie = n(y, {
                            ...h,
                            gain: 0
                        }),
                        ae = r(y, {
                            ...d,
                            curve: O
                        });
                    return {
                        connectGraph() {
                            v.connect($), v.connect(Z.inputs === void 0 ? Z : Z.inputs[0]), $.connect(j, 0), $.connect(se, 0), $.connect(de, 1), $.connect(ie, 1), Z.connect(w), w.connect(ee.inputs === void 0 ? ee : ee.inputs[0]), w.connect(oe.inputs === void 0 ? oe : oe.inputs[0]), w.connect(q.inputs === void 0 ? q : q.inputs[0]), w.connect(ae.inputs === void 0 ? ae : ae.inputs[0]), ee.connect(j.gain), oe.connect(se.gain), q.connect(de.gain), ae.connect(ie.gain), j.connect(b, 0, 0), de.connect(b, 0, 0), se.connect(b, 0, 1), ie.connect(b, 0, 1)
                        },
                        disconnectGraph() {
                            v.disconnect($), v.disconnect(Z.inputs === void 0 ? Z : Z.inputs[0]), $.disconnect(j, 0), $.disconnect(se, 0), $.disconnect(de, 1), $.disconnect(ie, 1), Z.disconnect(w), w.disconnect(ee.inputs === void 0 ? ee : ee.inputs[0]), w.disconnect(oe.inputs === void 0 ? oe : oe.inputs[0]), w.disconnect(q.inputs === void 0 ? q : q.inputs[0]), w.disconnect(ae.inputs === void 0 ? ae : ae.inputs[0]), ee.disconnect(j.gain), oe.disconnect(se.gain), q.disconnect(de.gain), ae.disconnect(ie.gain), j.disconnect(b, 0, 0), de.disconnect(b, 0, 0), se.disconnect(b, 0, 1), ie.disconnect(b, 0, 1)
                        }
                    }
                },
                _ = (y, v, w, b, I) => {
                    if (v === 1) return p(y, w, b, I);
                    if (v === 2) return m(y, w, b, I);
                    throw s()
                };
            return (y, {
                channelCount: v,
                channelCountMode: w,
                pan: b,
                ...I
            }) => {
                if (w === "max") throw s();
                const F = t(y, {
                        ...I,
                        channelCount: 1,
                        channelCountMode: w,
                        numberOfInputs: 2
                    }),
                    x = n(y, {
                        ...I,
                        channelCount: v,
                        channelCountMode: w,
                        gain: 1
                    }),
                    O = n(y, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: b
                    });
                let {
                    connectGraph: M,
                    disconnectGraph: $
                } = _(y, v, x, O, F);
                Object.defineProperty(O.gain, "defaultValue", {
                    get: () => 0
                }), Object.defineProperty(O.gain, "maxValue", {
                    get: () => 1
                }), Object.defineProperty(O.gain, "minValue", {
                    get: () => -1
                });
                const j = {
                    get bufferSize() {},
                    get channelCount() {
                        return x.channelCount
                    },
                    set channelCount(Z) {
                        x.channelCount !== Z && (ee && $(), {
                            connectGraph: M,
                            disconnectGraph: $
                        } = _(y, Z, x, O, F), ee && M()), x.channelCount = Z
                    },
                    get channelCountMode() {
                        return x.channelCountMode
                    },
                    set channelCountMode(Z) {
                        if (Z === "clamped-max" || Z === "max") throw s();
                        x.channelCountMode = Z
                    },
                    get channelInterpretation() {
                        return x.channelInterpretation
                    },
                    set channelInterpretation(Z) {
                        x.channelInterpretation = Z
                    },
                    get context() {
                        return x.context
                    },
                    get inputs() {
                        return [x]
                    },
                    get numberOfInputs() {
                        return x.numberOfInputs
                    },
                    get numberOfOutputs() {
                        return x.numberOfOutputs
                    },
                    get pan() {
                        return O.gain
                    },
                    addEventListener(...Z) {
                        return x.addEventListener(Z[0], Z[1], Z[2])
                    },
                    dispatchEvent(...Z) {
                        return x.dispatchEvent(Z[0])
                    },
                    removeEventListener(...Z) {
                        return x.removeEventListener(Z[0], Z[1], Z[2])
                    }
                };
                let ee = !1;
                const se = () => {
                        M(), ee = !0
                    },
                    oe = () => {
                        $(), ee = !1
                    };
                return i(pl(j, F), se, oe)
            }
        },
        v_e = (t, e, n, r, s, i, a) => (c, u) => {
            const h = c.createWaveShaper();
            if (i !== null && i.name === "webkitAudioContext" && c.createGain().gain.automationRate === void 0) return n(c, u);
            Pn(h, u);
            const d = u.curve === null || u.curve instanceof Float32Array ? u.curve : new Float32Array(u.curve);
            if (d !== null && d.length < 2) throw e();
            nn(h, {
                curve: d
            }, "curve"), nn(h, u, "oversample");
            let p = null,
                m = !1;
            return a(h, "curve", v => () => v.call(h), v => w => (v.call(h, w), m && (r(w) && p === null ? p = t(c, h) : !r(w) && p !== null && (p(), p = null)), w)), s(h, () => {
                m = !0, r(h.curve) && (p = t(c, h))
            }, () => {
                m = !1, p !== null && (p(), p = null)
            })
        },
        b_e = (t, e, n, r, s) => (i, {
            curve: a,
            oversample: c,
            ...u
        }) => {
            const h = i.createWaveShaper(),
                d = i.createWaveShaper();
            Pn(h, u), Pn(d, u);
            const p = n(i, {
                    ...u,
                    gain: 1
                }),
                m = n(i, {
                    ...u,
                    gain: -1
                }),
                _ = n(i, {
                    ...u,
                    gain: 1
                }),
                y = n(i, {
                    ...u,
                    gain: -1
                });
            let v = null,
                w = !1,
                b = null;
            const I = {
                get bufferSize() {},
                get channelCount() {
                    return h.channelCount
                },
                set channelCount(O) {
                    p.channelCount = O, m.channelCount = O, h.channelCount = O, _.channelCount = O, d.channelCount = O, y.channelCount = O
                },
                get channelCountMode() {
                    return h.channelCountMode
                },
                set channelCountMode(O) {
                    p.channelCountMode = O, m.channelCountMode = O, h.channelCountMode = O, _.channelCountMode = O, d.channelCountMode = O, y.channelCountMode = O
                },
                get channelInterpretation() {
                    return h.channelInterpretation
                },
                set channelInterpretation(O) {
                    p.channelInterpretation = O, m.channelInterpretation = O, h.channelInterpretation = O, _.channelInterpretation = O, d.channelInterpretation = O, y.channelInterpretation = O
                },
                get context() {
                    return h.context
                },
                get curve() {
                    return b
                },
                set curve(O) {
                    if (O !== null && O.length < 2) throw e();
                    if (O === null) h.curve = O, d.curve = O;
                    else {
                        const M = O.length,
                            $ = new Float32Array(M + 2 - M % 2),
                            j = new Float32Array(M + 2 - M % 2);
                        $[0] = O[0], j[0] = -O[M - 1];
                        const ee = Math.ceil((M + 1) / 2),
                            se = (M + 1) / 2 - 1;
                        for (let oe = 1; oe < ee; oe += 1) {
                            const Z = oe / ee * se,
                                de = Math.floor(Z),
                                q = Math.ceil(Z);
                            $[oe] = de === q ? O[de] : (1 - (Z - de)) * O[de] + (1 - (q - Z)) * O[q], j[oe] = de === q ? -O[M - 1 - de] : -((1 - (Z - de)) * O[M - 1 - de]) - (1 - (q - Z)) * O[M - 1 - q]
                        }
                        $[ee] = M % 2 === 1 ? O[ee - 1] : (O[ee - 2] + O[ee - 1]) / 2, h.curve = $, d.curve = j
                    }
                    b = O, w && (r(b) && v === null ? v = t(i, p) : v !== null && (v(), v = null))
                },
                get inputs() {
                    return [p]
                },
                get numberOfInputs() {
                    return h.numberOfInputs
                },
                get numberOfOutputs() {
                    return h.numberOfOutputs
                },
                get oversample() {
                    return h.oversample
                },
                set oversample(O) {
                    h.oversample = O, d.oversample = O
                },
                addEventListener(...O) {
                    return p.addEventListener(O[0], O[1], O[2])
                },
                dispatchEvent(...O) {
                    return p.dispatchEvent(O[0])
                },
                removeEventListener(...O) {
                    return p.removeEventListener(O[0], O[1], O[2])
                }
            };
            a !== null && (I.curve = a instanceof Float32Array ? a : new Float32Array(a)), c !== I.oversample && (I.oversample = c);
            const F = () => {
                    p.connect(h).connect(_), p.connect(m).connect(d).connect(y).connect(_), w = !0, r(b) && (v = t(i, p))
                },
                x = () => {
                    p.disconnect(h), h.disconnect(_), p.disconnect(m), m.disconnect(d), d.disconnect(y), y.disconnect(_), w = !1, v !== null && (v(), v = null)
                };
            return s(pl(I, _), F, x)
        },
        mr = () => new DOMException("", "NotSupportedError"),
        E_e = {
            numberOfChannels: 1
        },
        T_e = (t, e, n, r, s) => class extends t {
            constructor(a, c, u) {
                let h;
                if (typeof a == "number" && c !== void 0 && u !== void 0) h = {
                    length: c,
                    numberOfChannels: a,
                    sampleRate: u
                };
                else if (typeof a == "object") h = a;
                else throw new Error("The given parameters are not valid.");
                const {
                    length: d,
                    numberOfChannels: p,
                    sampleRate: m
                } = {
                    ...E_e,
                    ...h
                }, _ = r(p, d, m);
                e(Su, () => Su(_)) || _.addEventListener("statechange", (() => {
                    let y = 0;
                    const v = w => {
                        this._state === "running" && (y > 0 ? (_.removeEventListener("statechange", v), w.stopImmediatePropagation(), this._waitForThePromiseToSettle(w)) : y += 1)
                    };
                    return v
                })()), super(_, p), this._length = d, this._nativeOfflineAudioContext = _, this._state = null
            }
            get length() {
                return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length
            }
            get state() {
                return this._state === null ? this._nativeOfflineAudioContext.state : this._state
            }
            startRendering() {
                return this._state === "running" ? Promise.reject(n()) : (this._state = "running", s(this.destination, this._nativeOfflineAudioContext).finally(() => {
                    this._state = null, tk(this)
                }))
            }
            _waitForThePromiseToSettle(a) {
                this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(a) : setTimeout(() => this._waitForThePromiseToSettle(a))
            }
        },
        S_e = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            detune: 0,
            frequency: 440,
            periodicWave: void 0,
            type: "sine"
        },
        w_e = (t, e, n, r, s, i, a) => class extends t {
            constructor(u, h) {
                const d = s(u),
                    p = {
                        ...S_e,
                        ...h
                    },
                    m = n(d, p),
                    _ = i(d),
                    y = _ ? r() : null,
                    v = u.sampleRate / 2;
                super(u, !1, m, y), this._detune = e(this, _, m.detune, 153600, -153600), this._frequency = e(this, _, m.frequency, v, -v), this._nativeOscillatorNode = m, this._onended = null, this._oscillatorNodeRenderer = y, this._oscillatorNodeRenderer !== null && p.periodicWave !== void 0 && (this._oscillatorNodeRenderer.periodicWave = p.periodicWave)
            }
            get detune() {
                return this._detune
            }
            get frequency() {
                return this._frequency
            }
            get onended() {
                return this._onended
            }
            set onended(u) {
                const h = typeof u == "function" ? a(this, u) : null;
                this._nativeOscillatorNode.onended = h;
                const d = this._nativeOscillatorNode.onended;
                this._onended = d !== null && d === h ? u : d
            }
            get type() {
                return this._nativeOscillatorNode.type
            }
            set type(u) {
                this._nativeOscillatorNode.type = u, this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = null)
            }
            setPeriodicWave(u) {
                this._nativeOscillatorNode.setPeriodicWave(u), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = u)
            }
            start(u = 0) {
                if (this._nativeOscillatorNode.start(u), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.start = u), this.context.state !== "closed") {
                    qc(this);
                    const h = () => {
                        this._nativeOscillatorNode.removeEventListener("ended", h), Ni(this) && lh(this)
                    };
                    this._nativeOscillatorNode.addEventListener("ended", h)
                }
            }
            stop(u = 0) {
                this._nativeOscillatorNode.stop(u), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.stop = u)
            }
        },
        O_e = (t, e, n, r, s) => () => {
            const i = new WeakMap;
            let a = null,
                c = null,
                u = null;
            const h = async (d, p) => {
                let m = n(d);
                const _ = ir(m, p);
                if (!_) {
                    const y = {
                        channelCount: m.channelCount,
                        channelCountMode: m.channelCountMode,
                        channelInterpretation: m.channelInterpretation,
                        detune: m.detune.value,
                        frequency: m.frequency.value,
                        periodicWave: a === null ? void 0 : a,
                        type: m.type
                    };
                    m = e(p, y), c !== null && m.start(c), u !== null && m.stop(u)
                }
                return i.set(p, m), _ ? (await t(p, d.detune, m.detune), await t(p, d.frequency, m.frequency)) : (await r(p, d.detune, m.detune), await r(p, d.frequency, m.frequency)), await s(d, p, m), m
            };
            return {
                set periodicWave(d) {
                    a = d
                },
                set start(d) {
                    c = d
                },
                set stop(d) {
                    u = d
                },
                render(d, p) {
                    const m = i.get(p);
                    return m !== void 0 ? Promise.resolve(m) : h(d, p)
                }
            }
        },
        A_e = {
            channelCount: 2,
            channelCountMode: "clamped-max",
            channelInterpretation: "speakers",
            coneInnerAngle: 360,
            coneOuterAngle: 360,
            coneOuterGain: 0,
            distanceModel: "inverse",
            maxDistance: 1e4,
            orientationX: 1,
            orientationY: 0,
            orientationZ: 0,
            panningModel: "equalpower",
            positionX: 0,
            positionY: 0,
            positionZ: 0,
            refDistance: 1,
            rolloffFactor: 1
        },
        C_e = (t, e, n, r, s, i, a) => class extends t {
            constructor(u, h) {
                const d = s(u),
                    p = {
                        ...A_e,
                        ...h
                    },
                    m = n(d, p),
                    _ = i(d),
                    y = _ ? r() : null;
                super(u, !1, m, y), this._nativePannerNode = m, this._orientationX = e(this, _, m.orientationX, hr, Sr), this._orientationY = e(this, _, m.orientationY, hr, Sr), this._orientationZ = e(this, _, m.orientationZ, hr, Sr), this._positionX = e(this, _, m.positionX, hr, Sr), this._positionY = e(this, _, m.positionY, hr, Sr), this._positionZ = e(this, _, m.positionZ, hr, Sr), a(this, 1)
            }
            get coneInnerAngle() {
                return this._nativePannerNode.coneInnerAngle
            }
            set coneInnerAngle(u) {
                this._nativePannerNode.coneInnerAngle = u
            }
            get coneOuterAngle() {
                return this._nativePannerNode.coneOuterAngle
            }
            set coneOuterAngle(u) {
                this._nativePannerNode.coneOuterAngle = u
            }
            get coneOuterGain() {
                return this._nativePannerNode.coneOuterGain
            }
            set coneOuterGain(u) {
                this._nativePannerNode.coneOuterGain = u
            }
            get distanceModel() {
                return this._nativePannerNode.distanceModel
            }
            set distanceModel(u) {
                this._nativePannerNode.distanceModel = u
            }
            get maxDistance() {
                return this._nativePannerNode.maxDistance
            }
            set maxDistance(u) {
                this._nativePannerNode.maxDistance = u
            }
            get orientationX() {
                return this._orientationX
            }
            get orientationY() {
                return this._orientationY
            }
            get orientationZ() {
                return this._orientationZ
            }
            get panningModel() {
                return this._nativePannerNode.panningModel
            }
            set panningModel(u) {
                this._nativePannerNode.panningModel = u
            }
            get positionX() {
                return this._positionX
            }
            get positionY() {
                return this._positionY
            }
            get positionZ() {
                return this._positionZ
            }
            get refDistance() {
                return this._nativePannerNode.refDistance
            }
            set refDistance(u) {
                this._nativePannerNode.refDistance = u
            }
            get rolloffFactor() {
                return this._nativePannerNode.rolloffFactor
            }
            set rolloffFactor(u) {
                this._nativePannerNode.rolloffFactor = u
            }
        },
        k_e = (t, e, n, r, s, i, a, c, u, h) => () => {
            const d = new WeakMap;
            let p = null;
            const m = async (_, y) => {
                let v = null,
                    w = i(_);
                const b = {
                        channelCount: w.channelCount,
                        channelCountMode: w.channelCountMode,
                        channelInterpretation: w.channelInterpretation
                    },
                    I = {
                        ...b,
                        coneInnerAngle: w.coneInnerAngle,
                        coneOuterAngle: w.coneOuterAngle,
                        coneOuterGain: w.coneOuterGain,
                        distanceModel: w.distanceModel,
                        maxDistance: w.maxDistance,
                        panningModel: w.panningModel,
                        refDistance: w.refDistance,
                        rolloffFactor: w.rolloffFactor
                    },
                    F = ir(w, y);
                if ("bufferSize" in w) v = r(y, {
                    ...b,
                    gain: 1
                });
                else if (!F) {
                    const x = {
                        ...I,
                        orientationX: w.orientationX.value,
                        orientationY: w.orientationY.value,
                        orientationZ: w.orientationZ.value,
                        positionX: w.positionX.value,
                        positionY: w.positionY.value,
                        positionZ: w.positionZ.value
                    };
                    w = s(y, x)
                }
                if (d.set(y, v === null ? w : v), v !== null) {
                    if (p === null) {
                        if (a === null) throw new Error("Missing the native OfflineAudioContext constructor.");
                        const oe = new a(6, _.context.length, y.sampleRate),
                            Z = e(oe, {
                                channelCount: 1,
                                channelCountMode: "explicit",
                                channelInterpretation: "speakers",
                                numberOfInputs: 6
                            });
                        Z.connect(oe.destination), p = (async () => {
                            const de = await Promise.all([_.orientationX, _.orientationY, _.orientationZ, _.positionX, _.positionY, _.positionZ].map(async (q, ie) => {
                                const ae = n(oe, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "discrete",
                                    offset: ie === 0 ? 1 : 0
                                });
                                return await c(oe, q, ae.offset), ae
                            }));
                            for (let q = 0; q < 6; q += 1) de[q].connect(Z, 0, q), de[q].start(0);
                            return h(oe)
                        })()
                    }
                    const x = await p,
                        O = r(y, {
                            ...b,
                            gain: 1
                        });
                    await u(_, y, O);
                    const M = [];
                    for (let oe = 0; oe < x.numberOfChannels; oe += 1) M.push(x.getChannelData(oe));
                    let $ = [M[0][0], M[1][0], M[2][0]],
                        j = [M[3][0], M[4][0], M[5][0]],
                        ee = r(y, {
                            ...b,
                            gain: 1
                        }),
                        se = s(y, {
                            ...I,
                            orientationX: $[0],
                            orientationY: $[1],
                            orientationZ: $[2],
                            positionX: j[0],
                            positionY: j[1],
                            positionZ: j[2]
                        });
                    O.connect(ee).connect(se.inputs[0]), se.connect(v);
                    for (let oe = 128; oe < x.length; oe += 128) {
                        const Z = [M[0][oe], M[1][oe], M[2][oe]],
                            de = [M[3][oe], M[4][oe], M[5][oe]];
                        if (Z.some((q, ie) => q !== $[ie]) || de.some((q, ie) => q !== j[ie])) {
                            $ = Z, j = de;
                            const q = oe / y.sampleRate;
                            ee.gain.setValueAtTime(0, q), ee = r(y, {
                                ...b,
                                gain: 0
                            }), se = s(y, {
                                ...I,
                                orientationX: $[0],
                                orientationY: $[1],
                                orientationZ: $[2],
                                positionX: j[0],
                                positionY: j[1],
                                positionZ: j[2]
                            }), ee.gain.setValueAtTime(1, q), O.connect(ee).connect(se.inputs[0]), se.connect(v)
                        }
                    }
                    return v
                }
                return F ? (await t(y, _.orientationX, w.orientationX), await t(y, _.orientationY, w.orientationY), await t(y, _.orientationZ, w.orientationZ), await t(y, _.positionX, w.positionX), await t(y, _.positionY, w.positionY), await t(y, _.positionZ, w.positionZ)) : (await c(y, _.orientationX, w.orientationX), await c(y, _.orientationY, w.orientationY), await c(y, _.orientationZ, w.orientationZ), await c(y, _.positionX, w.positionX), await c(y, _.positionY, w.positionY), await c(y, _.positionZ, w.positionZ)), dl(w) ? await u(_, y, w.inputs[0]) : await u(_, y, w), w
            };
            return {
                render(_, y) {
                    const v = d.get(y);
                    return v !== void 0 ? Promise.resolve(v) : m(_, y)
                }
            }
        },
        I_e = {
            disableNormalization: !1
        },
        N_e = (t, e, n, r) => class hk {
            constructor(i, a) {
                const c = e(i),
                    u = r({
                        ...I_e,
                        ...a
                    }),
                    h = t(c, u);
                return n.add(h), h
            }
            static[Symbol.hasInstance](i) {
                return i !== null && typeof i == "object" && Object.getPrototypeOf(i) === hk.prototype || n.has(i)
            }
        },
        x_e = (t, e) => (n, r, s) => (t(r).replay(s), e(r, n, s)),
        P_e = (t, e, n) => async (r, s, i) => {
            const a = t(r);
            await Promise.all(a.activeInputs.map((c, u) => Array.from(c).map(async ([h, d]) => {
                const m = await e(h).render(h, s),
                    _ = r.context.destination;
                !n(h) && (r !== _ || !n(r)) && m.connect(i, d, u)
            })).reduce((c, u) => [...c, ...u], []))
        }, R_e = (t, e, n) => async (r, s, i) => {
            const a = e(r);
            await Promise.all(Array.from(a.activeInputs).map(async ([c, u]) => {
                const d = await t(c).render(c, s);
                n(c) || d.connect(i, u)
            }))
        }, M_e = (t, e, n, r) => s => t(Su, () => Su(s)) ? Promise.resolve(t(r, r)).then(i => {
            if (!i) {
                const a = n(s, 512, 0, 1);
                s.oncomplete = () => {
                    a.onaudioprocess = null, a.disconnect()
                }, a.onaudioprocess = () => s.currentTime, a.connect(s.destination)
            }
            return s.startRendering()
        }) : new Promise(i => {
            const a = e(s, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                gain: 0
            });
            s.oncomplete = c => {
                a.disconnect(), i(c.renderedBuffer)
            }, a.connect(s.destination), s.startRendering()
        }), D_e = t => (e, n) => {
            t.set(e, n)
        }, $_e = t => (e, n) => t.set(e, n), L_e = (t, e, n, r, s, i, a, c) => (u, h) => n(u).render(u, h).then(() => Promise.all(Array.from(r(h)).map(d => n(d).render(d, h)))).then(() => s(h)).then(d => (typeof d.copyFromChannel != "function" ? (a(d), b0(d)) : e(i, () => i(d)) || c(d), t.add(d), d)), F_e = {
            channelCount: 2,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            pan: 0
        }, U_e = (t, e, n, r, s, i) => class extends t {
            constructor(c, u) {
                const h = s(c),
                    d = {
                        ...F_e,
                        ...u
                    },
                    p = n(h, d),
                    m = i(h),
                    _ = m ? r() : null;
                super(c, !1, p, _), this._pan = e(this, m, p.pan)
            }
            get pan() {
                return this._pan
            }
        }, B_e = (t, e, n, r, s) => () => {
            const i = new WeakMap,
                a = async (c, u) => {
                    let h = n(c);
                    const d = ir(h, u);
                    if (!d) {
                        const p = {
                            channelCount: h.channelCount,
                            channelCountMode: h.channelCountMode,
                            channelInterpretation: h.channelInterpretation,
                            pan: h.pan.value
                        };
                        h = e(u, p)
                    }
                    return i.set(u, h), d ? await t(u, c.pan, h.pan) : await r(u, c.pan, h.pan), dl(h) ? await s(c, u, h.inputs[0]) : await s(c, u, h), h
                };
            return {
                render(c, u) {
                    const h = i.get(u);
                    return h !== void 0 ? Promise.resolve(h) : a(c, u)
                }
            }
        }, q_e = t => () => {
            if (t === null) return !1;
            try {
                new t({
                    length: 1,
                    sampleRate: 44100
                })
            } catch {
                return !1
            }
            return !0
        }, j_e = (t, e) => async () => {
            if (t === null) return !0;
            if (e === null) return !1;
            const n = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
                    type: "application/javascript; charset=utf-8"
                }),
                r = new e(1, 128, 44100),
                s = URL.createObjectURL(n);
            let i = !1,
                a = !1;
            try {
                await r.audioWorklet.addModule(s);
                const c = new t(r, "a", {
                        numberOfOutputs: 0
                    }),
                    u = r.createOscillator();
                c.port.onmessage = () => i = !0, c.onprocessorerror = () => a = !0, u.connect(c), u.start(0), await r.startRendering()
            } catch {} finally {
                URL.revokeObjectURL(s)
            }
            return i && !a
        }, V_e = (t, e) => () => {
            if (e === null) return Promise.resolve(!1);
            const n = new e(1, 1, 44100),
                r = t(n, {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    gain: 0
                });
            return new Promise(s => {
                n.oncomplete = () => {
                    r.disconnect(), s(n.currentTime !== 0)
                }, n.startRendering()
            })
        }, G_e = () => new DOMException("", "UnknownError"), W_e = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            curve: null,
            oversample: "none"
        }, H_e = (t, e, n, r, s, i, a) => class extends t {
            constructor(u, h) {
                const d = s(u),
                    p = {
                        ...W_e,
                        ...h
                    },
                    m = n(d, p),
                    y = i(d) ? r() : null;
                super(u, !0, m, y), this._isCurveNullified = !1, this._nativeWaveShaperNode = m, a(this, 1)
            }
            get curve() {
                return this._isCurveNullified ? null : this._nativeWaveShaperNode.curve
            }
            set curve(u) {
                if (u === null) this._isCurveNullified = !0, this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
                else {
                    if (u.length < 2) throw e();
                    this._isCurveNullified = !1, this._nativeWaveShaperNode.curve = u
                }
            }
            get oversample() {
                return this._nativeWaveShaperNode.oversample
            }
            set oversample(u) {
                this._nativeWaveShaperNode.oversample = u
            }
        }, K_e = (t, e, n) => () => {
            const r = new WeakMap,
                s = async (i, a) => {
                    let c = e(i);
                    if (!ir(c, a)) {
                        const h = {
                            channelCount: c.channelCount,
                            channelCountMode: c.channelCountMode,
                            channelInterpretation: c.channelInterpretation,
                            curve: c.curve,
                            oversample: c.oversample
                        };
                        c = t(a, h)
                    }
                    return r.set(a, c), dl(c) ? await n(i, a, c.inputs[0]) : await n(i, a, c), c
                };
            return {
                render(i, a) {
                    const c = r.get(a);
                    return c !== void 0 ? Promise.resolve(c) : s(i, a)
                }
            }
        }, Y_e = () => typeof window > "u" ? null : window, z_e = (t, e) => n => {
            n.copyFromChannel = (r, s, i = 0) => {
                const a = t(i),
                    c = t(s);
                if (c >= n.numberOfChannels) throw e();
                const u = n.length,
                    h = n.getChannelData(c),
                    d = r.length;
                for (let p = a < 0 ? -a : 0; p + a < u && p < d; p += 1) r[p] = h[p + a]
            }, n.copyToChannel = (r, s, i = 0) => {
                const a = t(i),
                    c = t(s);
                if (c >= n.numberOfChannels) throw e();
                const u = n.length,
                    h = n.getChannelData(c),
                    d = r.length;
                for (let p = a < 0 ? -a : 0; p + a < u && p < d; p += 1) h[p + a] = r[p]
            }
        }, Z_e = t => e => {
            e.copyFromChannel = (n => (r, s, i = 0) => {
                const a = t(i),
                    c = t(s);
                if (a < e.length) return n.call(e, r, c, a)
            })(e.copyFromChannel), e.copyToChannel = (n => (r, s, i = 0) => {
                const a = t(i),
                    c = t(s);
                if (a < e.length) return n.call(e, r, c, a)
            })(e.copyToChannel)
        }, X_e = t => (e, n) => {
            const r = n.createBuffer(1, 1, 44100);
            e.buffer === null && (e.buffer = r), t(e, "buffer", s => () => {
                const i = s.call(e);
                return i === r ? null : i
            }, s => i => s.call(e, i === null ? r : i))
        }, J_e = (t, e) => (n, r) => {
            r.channelCount = 1, r.channelCountMode = "explicit", Object.defineProperty(r, "channelCount", {
                get: () => 1,
                set: () => {
                    throw t()
                }
            }), Object.defineProperty(r, "channelCountMode", {
                get: () => "explicit",
                set: () => {
                    throw t()
                }
            });
            const s = n.createBufferSource();
            e(r, () => {
                const c = r.numberOfInputs;
                for (let u = 0; u < c; u += 1) s.connect(r, 0, u)
            }, () => s.disconnect(r))
        }, fk = (t, e, n) => t.copyFromChannel === void 0 ? t.getChannelData(n)[0] : (t.copyFromChannel(e, n), e[0]), dk = t => {
            if (t === null) return !1;
            const e = t.length;
            return e % 2 !== 0 ? t[Math.floor(e / 2)] !== 0 : t[e / 2 - 1] + t[e / 2] !== 0
        }, ph = (t, e, n, r) => {
            let s = t;
            for (; !s.hasOwnProperty(e);) s = Object.getPrototypeOf(s);
            const {
                get: i,
                set: a
            } = Object.getOwnPropertyDescriptor(s, e);
            Object.defineProperty(t, e, {
                get: n(i),
                set: r(a)
            })
        }, Q_e = t => ({
            ...t,
            outputChannelCount: t.outputChannelCount !== void 0 ? t.outputChannelCount : t.numberOfInputs === 1 && t.numberOfOutputs === 1 ? [t.channelCount] : Array.from({
                length: t.numberOfOutputs
            }, () => 1)
        }), e1e = t => ({
            ...t,
            channelCount: t.numberOfOutputs
        }), t1e = t => {
            const {
                imag: e,
                real: n
            } = t;
            return e === void 0 ? n === void 0 ? {
                ...t,
                imag: [0, 0],
                real: [0, 0]
            } : {
                ...t,
                imag: Array.from(n, () => 0),
                real: n
            } : n === void 0 ? {
                ...t,
                imag: e,
                real: Array.from(e, () => 0)
            } : {
                ...t,
                imag: e,
                real: n
            }
        }, pk = (t, e, n) => {
            try {
                t.setValueAtTime(e, n)
            } catch (r) {
                if (r.code !== 9) throw r;
                pk(t, e, n + 1e-7)
            }
        }, n1e = t => {
            const e = t.createBufferSource();
            e.start();
            try {
                e.start()
            } catch {
                return !0
            }
            return !1
        }, r1e = t => {
            const e = t.createBufferSource(),
                n = t.createBuffer(1, 1, 44100);
            e.buffer = n;
            try {
                e.start(0, 1)
            } catch {
                return !1
            }
            return !0
        }, s1e = t => {
            const e = t.createBufferSource();
            e.start();
            try {
                e.stop()
            } catch {
                return !1
            }
            return !0
        }, O0 = t => {
            const e = t.createOscillator();
            try {
                e.start(-1)
            } catch (n) {
                return n instanceof RangeError
            }
            return !1
        }, mk = t => {
            const e = t.createBuffer(1, 1, 44100),
                n = t.createBufferSource();
            n.buffer = e, n.start(), n.stop();
            try {
                return n.stop(), !0
            } catch {
                return !1
            }
        }, A0 = t => {
            const e = t.createOscillator();
            try {
                e.stop(-1)
            } catch (n) {
                return n instanceof RangeError
            }
            return !1
        }, i1e = t => {
            const {
                port1: e,
                port2: n
            } = new MessageChannel;
            try {
                e.postMessage(t)
            } finally {
                e.close(), n.close()
            }
        }, o1e = t => {
            t.start = (e => (n = 0, r = 0, s) => {
                const i = t.buffer,
                    a = i === null ? r : Math.min(i.duration, r);
                i !== null && a > i.duration - .5 / t.context.sampleRate ? e.call(t, n, 0, 0) : e.call(t, n, a, s)
            })(t.start)
        }, gk = (t, e) => {
            const n = e.createGain();
            t.connect(n);
            const r = (s => () => {
                s.call(t, n), t.removeEventListener("ended", r)
            })(t.disconnect);
            t.addEventListener("ended", r), pl(t, n), t.stop = (s => {
                let i = !1;
                return (a = 0) => {
                    if (i) try {
                        s.call(t, a)
                    } catch {
                        n.gain.setValueAtTime(0, a)
                    } else s.call(t, a), i = !0
                }
            })(t.stop)
        }, ml = (t, e) => n => {
            const r = {
                value: t
            };
            return Object.defineProperties(n, {
                currentTarget: r,
                target: r
            }), typeof e == "function" ? e.call(t, n) : e.handleEvent.call(t, n)
        }, a1e = Cpe(Ra), c1e = Rpe(Ra), l1e = Wme(Em), _k = new WeakMap, u1e = lge(_k), Ms = Eme(new Map, new WeakMap), Zs = Y_e(), yk = Uge(Ms, oi), C0 = cge(fr), zn = P_e(fr, C0, wa), h1e = Fpe(yk, Qt, zn), Kt = fge(bm), Bi = f_e(Zs), $t = Ige(Bi), vk = new WeakMap, bk = tge(ml), mh = Vge(Zs), k0 = Oge(mh), I0 = Age(Zs), Ek = Cge(Zs), wu = Wge(Zs), bn = lme(kpe(YC), Ppe(a1e, c1e, Md, l1e, Dd, fr, u1e, ch, Qt, Ra, Ni, wa, Jf), Ms, bge(ly, Dd, fr, Qt, Tu, Ni), oi, Tm, mr, qme(Md, ly, fr, Qt, Tu, Kt, Ni, $t), Yme(vk, fr, Os), bk, Kt, k0, I0, Ek, $t, wu), f1e = Lpe(bn, h1e, oi, yk, Kt, $t), N0 = new WeakSet, U3 = Bge(Zs), Tk = Mme(new Uint32Array(1)), x0 = z_e(Tk, oi), P0 = Z_e(Tk), d1e = Bpe(N0, Ms, mr, U3, Bi, q_e(U3), x0, P0), Sm = Mpe(Cr), Sk = R_e(C0, uh, wa), ai = kme(Sk), gl = jge(Sm, Ms, n1e, r1e, s1e, O0, mk, A0, o1e, X_e(ph), gk), ci = x_e(uge(uh), Sk), p1e = Vpe(ai, gl, Qt, ci, zn), Ds = ume(Ipe(zC), vk, v0, hme, Epe, Tpe, Spe, wpe, Ope, oy, HC, mh, pk), m1e = jpe(bn, p1e, Ds, Fn, gl, Kt, $t, ml), g1e = Jpe(bn, Qpe, oi, Fn, Gge(Cr, ph), Kt, $t, zn), _1e = bme(ai, lk, Qt, ci, zn), Ma = $_e(_k), y1e = vme(bn, Ds, _1e, Tm, lk, Kt, $t, Ma), qo = Lge(Ra, I0), v1e = J_e(Fn, qo), jo = Jge(mh, v1e), b1e = wme(jo, Qt, zn), E1e = Sme(bn, b1e, jo, Kt, $t), T1e = Cme(fh, Qt, zn), S1e = Ame(bn, T1e, fh, Kt, $t, e1e), w1e = t_e(Sm, gl, Cr, qo), _l = e_e(Sm, Ms, w1e, O0, A0), O1e = Rme(ai, _l, Qt, ci, zn), A1e = Pme(bn, Ds, O1e, _l, Kt, $t, ml), wk = n_e(mr, ph), C1e = Lme(wk, Qt, zn), k1e = $me(bn, C1e, wk, Kt, $t, Ma), I1e = Gme(ai, uk, Qt, ci, zn), N1e = Vme(bn, Ds, I1e, uk, Kt, $t, Ma), Ok = r_e(mr), x1e = Jme(ai, Ok, Qt, ci, zn), P1e = Xme(bn, Ds, x1e, Ok, mr, Kt, $t, Ma), R1e = oge(ai, Cr, Qt, ci, zn), M1e = ige(bn, Ds, R1e, Cr, Kt, $t), D1e = a_e(Tm, Fn, dh, mr), wm = M_e(Ms, Cr, dh, V_e(Cr, Bi)), $1e = vge(gl, Qt, Bi, zn, wm), L1e = s_e(D1e), F1e = _ge(bn, L1e, $1e, Kt, $t, Ma), U1e = eme(Ds, jo, _l, dh, mr, fk, $t, ph), Ak = new WeakMap, B1e = $ge(g1e, U1e, bk, $t, Ak, ml), Ck = d_e(Sm, Ms, O0, mk, A0, gk), q1e = O_e(ai, Ck, Qt, ci, zn), j1e = w_e(bn, Ds, Ck, q1e, Kt, $t, ml), kk = Nme(gl), V1e = b_e(kk, Fn, Cr, dk, qo), Om = v_e(kk, Fn, V1e, dk, qo, mh, ph), G1e = m_e(Md, Fn, jo, Cr, dh, Om, mr, Dd, fk, qo), Ik = p_e(G1e), W1e = k_e(ai, jo, _l, Cr, Ik, Qt, Bi, ci, zn, wm), H1e = C_e(bn, Ds, Ik, W1e, Kt, $t, Ma), K1e = g_e(oi), Y1e = N_e(K1e, Kt, new WeakSet, t1e), z1e = y_e(jo, fh, Cr, Om, mr, qo), Nk = __e(z1e, mr), Z1e = B_e(ai, Nk, Qt, ci, zn), X1e = U_e(bn, Ds, Nk, Z1e, Kt, $t), J1e = K_e(Om, Qt, zn), Q1e = H_e(bn, Fn, Om, J1e, Kt, $t, Ma), xk = Nge(Zs), R0 = nge(Zs), Pk = new WeakMap, eye = dge(Pk, Bi), tye = xk ? xpe(Ms, mr, ege(Zs), R0, rge(Ape), Kt, eye, $t, wu, new WeakMap, new WeakMap, j_e(wu, Bi), Zs) : void 0, nye = kge(k0, $t), rye = Bme(N0, Ms, Ume, Qme, new WeakSet, Kt, nye, Pd, Su, x0, P0), Rk = _me(tye, f1e, d1e, m1e, y1e, E1e, S1e, A1e, k1e, rye, N1e, P1e, M1e, F1e, B1e, j1e, H1e, Y1e, X1e, Q1e), sye = xge(bn, c_e, Kt, $t), iye = Rge(bn, l_e, Kt, $t), oye = Mge(bn, u_e, Kt, $t), aye = h_e(Fn, $t), cye = Dge(bn, aye, Kt), lye = Xpe(Rk, Fn, mr, G_e, sye, iye, oye, cye, mh), M0 = pge(Ak), uye = Dpe(M0), Mk = Ime(oi), hye = Hme(M0), Dk = zme(oi), $k = new WeakMap, fye = age($k, Os), dye = Xge(Mk, oi, Fn, jo, fh, _l, Cr, dh, mr, Dk, R0, fye, qo), pye = Kge(Fn, dye, Cr, mr, qo), mye = gme(ai, Mk, gl, jo, fh, _l, Cr, hye, Dk, R0, Qt, wu, Bi, ci, zn, wm), gye = hge(Pk), _ye = D_e($k), B3 = xk ? dme(uye, bn, Ds, mye, pye, fr, gye, Kt, $t, wu, Q_e, _ye, i1e, ml) : void 0, yye = Fme(mr, Bi), vye = L_e(N0, Ms, C0, M0, wm, Pd, x0, P0), bye = T_e(Rk, Ms, Fn, yye, vye), Eye = Ege(bm, k0), Tye = Tge(y0, I0), Sye = Sge(v0, Ek), wye = wge(bm, $t);

    function Ve(t, e) {
        if (!t) throw new Error(e)
    }

    function As(t, e, n = 1 / 0) {
        if (!(e <= t && t <= n)) throw new RangeError(`Value must be within [${e}, ${n}], got: ${t}`)
    }

    function Lk(t) {
        !t.isOffline && t.state !== "running" && D0('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.')
    }
    let Fk = console;

    function Oye(...t) {
        Fk.log(...t)
    }

    function D0(...t) {
        Fk.warn(...t)
    }

    function rs(t) {
        return typeof t > "u"
    }

    function yt(t) {
        return !rs(t)
    }

    function Aye(t) {
        return typeof t == "function"
    }

    function Mi(t) {
        return typeof t == "number"
    }

    function va(t) {
        return Object.prototype.toString.call(t) === "[object Object]" && t.constructor === Object
    }

    function Cye(t) {
        return typeof t == "boolean"
    }

    function Fr(t) {
        return Array.isArray(t)
    }

    function Xs(t) {
        return typeof t == "string"
    }

    function Bf(t) {
        return Xs(t) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(t)
    }

    function kye(t) {
        return new lye(t)
    }

    function Iye(t, e, n) {
        return new bye(t, e, n)
    }
    const ba = typeof self == "object" ? self : null,
        Nye = ba && (ba.hasOwnProperty("AudioContext") || ba.hasOwnProperty("webkitAudioContext"));

    function xye(t, e, n) {
        return Ve(yt(B3), "This node only works in a secure context (https or localhost)"), new B3(t, e, n)
    }

    function $s(t, e, n, r) {
        var s = arguments.length,
            i = s < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
            a;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") i = Reflect.decorate(t, e, n, r);
        else
            for (var c = t.length - 1; c >= 0; c--)(a = t[c]) && (i = (s < 3 ? a(i) : s > 3 ? a(e, n, i) : a(e, n)) || i);
        return s > 3 && i && Object.defineProperty(e, n, i), i
    }

    function yn(t, e, n, r) {
        function s(i) {
            return i instanceof n ? i : new n(function(a) {
                a(i)
            })
        }
        return new(n || (n = Promise))(function(i, a) {
            function c(d) {
                try {
                    h(r.next(d))
                } catch (p) {
                    a(p)
                }
            }

            function u(d) {
                try {
                    h(r.throw(d))
                } catch (p) {
                    a(p)
                }
            }

            function h(d) {
                d.done ? i(d.value) : s(d.value).then(c, u)
            }
            h((r = r.apply(t, e || [])).next())
        })
    }
    class Pye {
        constructor(e, n, r) {
            this._callback = e, this._type = n, this._updateInterval = r, this._createClock()
        }
        _createWorker() {
            const e = new Blob([`
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval*1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`], {
                    type: "text/javascript"
                }),
                n = URL.createObjectURL(e),
                r = new Worker(n);
            r.onmessage = this._callback.bind(this), this._worker = r
        }
        _createTimeout() {
            this._timeout = setTimeout(() => {
                this._createTimeout(), this._callback()
            }, this._updateInterval * 1e3)
        }
        _createClock() {
            if (this._type === "worker") try {
                this._createWorker()
            } catch {
                this._type = "timeout", this._createClock()
            } else this._type === "timeout" && this._createTimeout()
        }
        _disposeClock() {
            this._timeout && (clearTimeout(this._timeout), this._timeout = 0), this._worker && (this._worker.terminate(), this._worker.onmessage = null)
        }
        get updateInterval() {
            return this._updateInterval
        }
        set updateInterval(e) {
            this._updateInterval = Math.max(e, 128 / 44100), this._type === "worker" && this._worker.postMessage(Math.max(e * 1e3, 1))
        }
        get type() {
            return this._type
        }
        set type(e) {
            this._disposeClock(), this._type = e, this._createClock()
        }
        dispose() {
            this._disposeClock()
        }
    }

    function Oa(t) {
        return Sye(t)
    }

    function yo(t) {
        return Tye(t)
    }

    function Qf(t) {
        return wye(t)
    }

    function ic(t) {
        return Eye(t)
    }

    function Uk(t) {
        return t instanceof AudioBuffer
    }

    function Rye(t, e) {
        return t === "value" || Oa(e) || yo(e) || Uk(e)
    }

    function ss(t, ...e) {
        if (!e.length) return t;
        const n = e.shift();
        if (va(t) && va(n))
            for (const r in n) Rye(r, n[r]) ? t[r] = n[r] : va(n[r]) ? (t[r] || Object.assign(t, {
                [r]: {}
            }), ss(t[r], n[r])) : Object.assign(t, {
                [r]: n[r]
            });
        return ss(t, ...e)
    }

    function Mye(t, e) {
        return t.length === e.length && t.every((n, r) => e[r] === n)
    }

    function Y(t, e, n = [], r) {
        const s = {},
            i = Array.from(e);
        if (va(i[0]) && r && !Reflect.has(i[0], r) && (Object.keys(i[0]).some(c => Reflect.has(t, c)) || (ss(s, {
                [r]: i[0]
            }), n.splice(n.indexOf(r), 1), i.shift())), i.length === 1 && va(i[0])) ss(s, i[0]);
        else
            for (let a = 0; a < n.length; a++) yt(i[a]) && (s[n[a]] = i[a]);
        return ss(t, s)
    }

    function Dye(t) {
        return t.constructor.getDefaults()
    }

    function kc(t, e) {
        return rs(t) ? e : t
    }

    function tr(t, e) {
        return e.forEach(n => {
            Reflect.has(t, n) && delete t[n]
        }), t
    }
    /**
     * Tone.js
     * @author Yotam Mann
     * @license http://opensource.org/licenses/MIT MIT License
     * @copyright 2014-2019 Yotam Mann
     */
    class qi {
        constructor() {
            this.debug = !1, this._wasDisposed = !1
        }
        static getDefaults() {
            return {}
        }
        log(...e) {
            (this.debug || ba && this.toString() === ba.TONE_DEBUG_CLASS) && Oye(this, ...e)
        }
        dispose() {
            return this._wasDisposed = !0, this
        }
        get disposed() {
            return this._wasDisposed
        }
        toString() {
            return this.name
        }
    }
    qi.version = WC;
    const $0 = 1e-6;

    function Ud(t, e) {
        return t > e + $0
    }

    function py(t, e) {
        return Ud(t, e) || _s(t, e)
    }

    function Bk(t, e) {
        return t + $0 < e
    }

    function _s(t, e) {
        return Math.abs(t - e) < $0
    }

    function $ye(t, e, n) {
        return Math.max(Math.min(t, n), e)
    }
    class li extends qi {
        constructor() {
            super(), this.name = "Timeline", this._timeline = [];
            const e = Y(li.getDefaults(), arguments, ["memory"]);
            this.memory = e.memory, this.increasing = e.increasing
        }
        static getDefaults() {
            return {
                memory: 1 / 0,
                increasing: !1
            }
        }
        get length() {
            return this._timeline.length
        }
        add(e) {
            if (Ve(Reflect.has(e, "time"), "Timeline: events must have a time attribute"), e.time = e.time.valueOf(), this.increasing && this.length) {
                const n = this._timeline[this.length - 1];
                Ve(py(e.time, n.time), "The time must be greater than or equal to the last scheduled time"), this._timeline.push(e)
            } else {
                const n = this._search(e.time);
                this._timeline.splice(n + 1, 0, e)
            }
            if (this.length > this.memory) {
                const n = this.length - this.memory;
                this._timeline.splice(0, n)
            }
            return this
        }
        remove(e) {
            const n = this._timeline.indexOf(e);
            return n !== -1 && this._timeline.splice(n, 1), this
        }
        get(e, n = "time") {
            const r = this._search(e, n);
            return r !== -1 ? this._timeline[r] : null
        }
        peek() {
            return this._timeline[0]
        }
        shift() {
            return this._timeline.shift()
        }
        getAfter(e, n = "time") {
            const r = this._search(e, n);
            return r + 1 < this._timeline.length ? this._timeline[r + 1] : null
        }
        getBefore(e) {
            const n = this._timeline.length;
            if (n > 0 && this._timeline[n - 1].time < e) return this._timeline[n - 1];
            const r = this._search(e);
            return r - 1 >= 0 ? this._timeline[r - 1] : null
        }
        cancel(e) {
            if (this._timeline.length > 1) {
                let n = this._search(e);
                if (n >= 0)
                    if (_s(this._timeline[n].time, e)) {
                        for (let r = n; r >= 0 && _s(this._timeline[r].time, e); r--) n = r;
                        this._timeline = this._timeline.slice(0, n)
                    } else this._timeline = this._timeline.slice(0, n + 1);
                else this._timeline = []
            } else this._timeline.length === 1 && py(this._timeline[0].time, e) && (this._timeline = []);
            return this
        }
        cancelBefore(e) {
            const n = this._search(e);
            return n >= 0 && (this._timeline = this._timeline.slice(n + 1)), this
        }
        previousEvent(e) {
            const n = this._timeline.indexOf(e);
            return n > 0 ? this._timeline[n - 1] : null
        }
        _search(e, n = "time") {
            if (this._timeline.length === 0) return -1;
            let r = 0;
            const s = this._timeline.length;
            let i = s;
            if (s > 0 && this._timeline[s - 1][n] <= e) return s - 1;
            for (; r < i;) {
                let a = Math.floor(r + (i - r) / 2);
                const c = this._timeline[a],
                    u = this._timeline[a + 1];
                if (_s(c[n], e)) {
                    for (let h = a; h < this._timeline.length; h++) {
                        const d = this._timeline[h];
                        if (_s(d[n], e)) a = h;
                        else break
                    }
                    return a
                } else {
                    if (Bk(c[n], e) && Ud(u[n], e)) return a;
                    Ud(c[n], e) ? i = a : r = a + 1
                }
            }
            return -1
        }
        _iterate(e, n = 0, r = this._timeline.length - 1) {
            this._timeline.slice(n, r + 1).forEach(e)
        }
        forEach(e) {
            return this._iterate(e), this
        }
        forEachBefore(e, n) {
            const r = this._search(e);
            return r !== -1 && this._iterate(n, 0, r), this
        }
        forEachAfter(e, n) {
            const r = this._search(e);
            return this._iterate(n, r + 1), this
        }
        forEachBetween(e, n, r) {
            let s = this._search(e),
                i = this._search(n);
            return s !== -1 && i !== -1 ? (this._timeline[s].time !== e && (s += 1), this._timeline[i].time === n && (i -= 1), this._iterate(r, s, i)) : s === -1 && this._iterate(r, 0, i), this
        }
        forEachFrom(e, n) {
            let r = this._search(e);
            for (; r >= 0 && this._timeline[r].time >= e;) r--;
            return this._iterate(n, r + 1), this
        }
        forEachAtTime(e, n) {
            const r = this._search(e);
            if (r !== -1 && _s(this._timeline[r].time, e)) {
                let s = r;
                for (let i = r; i >= 0 && _s(this._timeline[i].time, e); i--) s = i;
                this._iterate(i => {
                    n(i)
                }, s, r)
            }
            return this
        }
        dispose() {
            return super.dispose(), this._timeline = [], this
        }
    }
    const qk = [];

    function Am(t) {
        qk.push(t)
    }

    function Lye(t) {
        qk.forEach(e => e(t))
    }
    const jk = [];

    function Cm(t) {
        jk.push(t)
    }

    function Fye(t) {
        jk.forEach(e => e(t))
    }
    class gh extends qi {
        constructor() {
            super(...arguments), this.name = "Emitter"
        }
        on(e, n) {
            return e.split(/\W+/).forEach(s => {
                rs(this._events) && (this._events = {}), this._events.hasOwnProperty(s) || (this._events[s] = []), this._events[s].push(n)
            }), this
        }
        once(e, n) {
            const r = (...s) => {
                n(...s), this.off(e, r)
            };
            return this.on(e, r), this
        }
        off(e, n) {
            return e.split(/\W+/).forEach(s => {
                if (rs(this._events) && (this._events = {}), this._events.hasOwnProperty(e))
                    if (rs(n)) this._events[e] = [];
                    else {
                        const i = this._events[e];
                        for (let a = i.length - 1; a >= 0; a--) i[a] === n && i.splice(a, 1)
                    }
            }), this
        }
        emit(e, ...n) {
            if (this._events && this._events.hasOwnProperty(e)) {
                const r = this._events[e].slice(0);
                for (let s = 0, i = r.length; s < i; s++) r[s].apply(this, n)
            }
            return this
        }
        static mixin(e) {
            ["on", "once", "off", "emit"].forEach(n => {
                const r = Object.getOwnPropertyDescriptor(gh.prototype, n);
                Object.defineProperty(e.prototype, n, r)
            })
        }
        dispose() {
            return super.dispose(), this._events = void 0, this
        }
    }
    class Vk extends gh {
        constructor() {
            super(...arguments), this.isOffline = !1
        }
        toJSON() {
            return {}
        }
    }
    class _h extends Vk {
        constructor() {
            super(), this.name = "Context", this._constants = new Map, this._timeouts = new li, this._timeoutIds = 0, this._initialized = !1, this.isOffline = !1, this._workletModules = new Map;
            const e = Y(_h.getDefaults(), arguments, ["context"]);
            e.context ? this._context = e.context : this._context = kye({
                latencyHint: e.latencyHint
            }), this._ticker = new Pye(this.emit.bind(this, "tick"), e.clockSource, e.updateInterval), this.on("tick", this._timeoutLoop.bind(this)), this._context.onstatechange = () => {
                this.emit("statechange", this.state)
            }, this._setLatencyHint(e.latencyHint), this.lookAhead = e.lookAhead
        }
        static getDefaults() {
            return {
                clockSource: "worker",
                latencyHint: "interactive",
                lookAhead: .1,
                updateInterval: .05
            }
        }
        initialize() {
            return this._initialized || (Lye(this), this._initialized = !0), this
        }
        createAnalyser() {
            return this._context.createAnalyser()
        }
        createOscillator() {
            return this._context.createOscillator()
        }
        createBufferSource() {
            return this._context.createBufferSource()
        }
        createBiquadFilter() {
            return this._context.createBiquadFilter()
        }
        createBuffer(e, n, r) {
            return this._context.createBuffer(e, n, r)
        }
        createChannelMerger(e) {
            return this._context.createChannelMerger(e)
        }
        createChannelSplitter(e) {
            return this._context.createChannelSplitter(e)
        }
        createConstantSource() {
            return this._context.createConstantSource()
        }
        createConvolver() {
            return this._context.createConvolver()
        }
        createDelay(e) {
            return this._context.createDelay(e)
        }
        createDynamicsCompressor() {
            return this._context.createDynamicsCompressor()
        }
        createGain() {
            return this._context.createGain()
        }
        createIIRFilter(e, n) {
            return this._context.createIIRFilter(e, n)
        }
        createPanner() {
            return this._context.createPanner()
        }
        createPeriodicWave(e, n, r) {
            return this._context.createPeriodicWave(e, n, r)
        }
        createStereoPanner() {
            return this._context.createStereoPanner()
        }
        createWaveShaper() {
            return this._context.createWaveShaper()
        }
        createMediaStreamSource(e) {
            return Ve(ic(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamSource(e)
        }
        createMediaElementSource(e) {
            return Ve(ic(this._context), "Not available if OfflineAudioContext"), this._context.createMediaElementSource(e)
        }
        createMediaStreamDestination() {
            return Ve(ic(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamDestination()
        }
        decodeAudioData(e) {
            return this._context.decodeAudioData(e)
        }
        get currentTime() {
            return this._context.currentTime
        }
        get state() {
            return this._context.state
        }
        get sampleRate() {
            return this._context.sampleRate
        }
        get listener() {
            return this.initialize(), this._listener
        }
        set listener(e) {
            Ve(!this._initialized, "The listener cannot be set after initialization."), this._listener = e
        }
        get transport() {
            return this.initialize(), this._transport
        }
        set transport(e) {
            Ve(!this._initialized, "The transport cannot be set after initialization."), this._transport = e
        }
        get draw() {
            return this.initialize(), this._draw
        }
        set draw(e) {
            Ve(!this._initialized, "Draw cannot be set after initialization."), this._draw = e
        }
        get destination() {
            return this.initialize(), this._destination
        }
        set destination(e) {
            Ve(!this._initialized, "The destination cannot be set after initialization."), this._destination = e
        }
        createAudioWorkletNode(e, n) {
            return xye(this.rawContext, e, n)
        }
        addAudioWorkletModule(e, n) {
            return yn(this, void 0, void 0, function*() {
                Ve(yt(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)"), this._workletModules.has(n) || this._workletModules.set(n, this.rawContext.audioWorklet.addModule(e)), yield this._workletModules.get(n)
            })
        }
        workletsAreReady() {
            return yn(this, void 0, void 0, function*() {
                const e = [];
                this._workletModules.forEach(n => e.push(n)), yield Promise.all(e)
            })
        }
        get updateInterval() {
            return this._ticker.updateInterval
        }
        set updateInterval(e) {
            this._ticker.updateInterval = e
        }
        get clockSource() {
            return this._ticker.type
        }
        set clockSource(e) {
            this._ticker.type = e
        }
        get latencyHint() {
            return this._latencyHint
        }
        _setLatencyHint(e) {
            let n = 0;
            if (this._latencyHint = e, Xs(e)) switch (e) {
                case "interactive":
                    n = .1;
                    break;
                case "playback":
                    n = .5;
                    break;
                case "balanced":
                    n = .25;
                    break
            }
            this.lookAhead = n, this.updateInterval = n / 2
        }
        get rawContext() {
            return this._context
        }
        now() {
            return this._context.currentTime + this.lookAhead
        }
        immediate() {
            return this._context.currentTime
        }
        resume() {
            return ic(this._context) ? this._context.resume() : Promise.resolve()
        }
        close() {
            return yn(this, void 0, void 0, function*() {
                ic(this._context) && (yield this._context.close()), this._initialized && Fye(this)
            })
        }
        getConstant(e) {
            if (this._constants.has(e)) return this._constants.get(e); {
                const n = this._context.createBuffer(1, 128, this._context.sampleRate),
                    r = n.getChannelData(0);
                for (let i = 0; i < r.length; i++) r[i] = e;
                const s = this._context.createBufferSource();
                return s.channelCount = 1, s.channelCountMode = "explicit", s.buffer = n, s.loop = !0, s.start(0), this._constants.set(e, s), s
            }
        }
        dispose() {
            return super.dispose(), this._ticker.dispose(), this._timeouts.dispose(), Object.keys(this._constants).map(e => this._constants[e].disconnect()), this
        }
        _timeoutLoop() {
            const e = this.now();
            let n = this._timeouts.peek();
            for (; this._timeouts.length && n && n.time <= e;) n.callback(), this._timeouts.shift(), n = this._timeouts.peek()
        }
        setTimeout(e, n) {
            this._timeoutIds++;
            const r = this.now();
            return this._timeouts.add({
                callback: e,
                id: this._timeoutIds,
                time: r + n
            }), this._timeoutIds
        }
        clearTimeout(e) {
            return this._timeouts.forEach(n => {
                n.id === e && this._timeouts.remove(n)
            }), this
        }
        clearInterval(e) {
            return this.clearTimeout(e)
        }
        setInterval(e, n) {
            const r = ++this._timeoutIds,
                s = () => {
                    const i = this.now();
                    this._timeouts.add({
                        callback: () => {
                            e(), s()
                        },
                        id: r,
                        time: i + n
                    })
                };
            return s(), r
        }
    }
    class Uye extends Vk {
        constructor() {
            super(...arguments), this.lookAhead = 0, this.latencyHint = 0, this.isOffline = !1
        }
        createAnalyser() {
            return {}
        }
        createOscillator() {
            return {}
        }
        createBufferSource() {
            return {}
        }
        createBiquadFilter() {
            return {}
        }
        createBuffer(e, n, r) {
            return {}
        }
        createChannelMerger(e) {
            return {}
        }
        createChannelSplitter(e) {
            return {}
        }
        createConstantSource() {
            return {}
        }
        createConvolver() {
            return {}
        }
        createDelay(e) {
            return {}
        }
        createDynamicsCompressor() {
            return {}
        }
        createGain() {
            return {}
        }
        createIIRFilter(e, n) {
            return {}
        }
        createPanner() {
            return {}
        }
        createPeriodicWave(e, n, r) {
            return {}
        }
        createStereoPanner() {
            return {}
        }
        createWaveShaper() {
            return {}
        }
        createMediaStreamSource(e) {
            return {}
        }
        createMediaElementSource(e) {
            return {}
        }
        createMediaStreamDestination() {
            return {}
        }
        decodeAudioData(e) {
            return Promise.resolve({})
        }
        createAudioWorkletNode(e, n) {
            return {}
        }
        get rawContext() {
            return {}
        }
        addAudioWorkletModule(e, n) {
            return yn(this, void 0, void 0, function*() {
                return Promise.resolve()
            })
        }
        resume() {
            return Promise.resolve()
        }
        setTimeout(e, n) {
            return 0
        }
        clearTimeout(e) {
            return this
        }
        setInterval(e, n) {
            return 0
        }
        clearInterval(e) {
            return this
        }
        getConstant(e) {
            return {}
        }
        get currentTime() {
            return 0
        }
        get state() {
            return {}
        }
        get sampleRate() {
            return 0
        }
        get listener() {
            return {}
        }
        get transport() {
            return {}
        }
        get draw() {
            return {}
        }
        set draw(e) {}
        get destination() {
            return {}
        }
        set destination(e) {}
        now() {
            return 0
        }
        immediate() {
            return 0
        }
    }

    function Fe(t, e) {
        Fr(e) ? e.forEach(n => Fe(t, n)) : Object.defineProperty(t, e, {
            enumerable: !0,
            writable: !1
        })
    }

    function yh(t, e) {
        Fr(e) ? e.forEach(n => yh(t, n)) : Object.defineProperty(t, e, {
            writable: !0
        })
    }
    const ht = () => {};
    class Ot extends qi {
        constructor() {
            super(), this.name = "ToneAudioBuffer", this.onload = ht;
            const e = Y(Ot.getDefaults(), arguments, ["url", "onload", "onerror"]);
            this.reverse = e.reverse, this.onload = e.onload, e.url && Uk(e.url) || e.url instanceof Ot ? this.set(e.url) : Xs(e.url) && this.load(e.url).catch(e.onerror)
        }
        static getDefaults() {
            return {
                onerror: ht,
                onload: ht,
                reverse: !1
            }
        }
        get sampleRate() {
            return this._buffer ? this._buffer.sampleRate : es().sampleRate
        }
        set(e) {
            return e instanceof Ot ? e.loaded ? this._buffer = e.get() : e.onload = () => {
                this.set(e), this.onload(this)
            } : this._buffer = e, this._reversed && this._reverse(), this
        }
        get() {
            return this._buffer
        }
        load(e) {
            return yn(this, void 0, void 0, function*() {
                const n = Ot.load(e).then(r => {
                    this.set(r), this.onload(this)
                });
                Ot.downloads.push(n);
                try {
                    yield n
                } finally {
                    const r = Ot.downloads.indexOf(n);
                    Ot.downloads.splice(r, 1)
                }
                return this
            })
        }
        dispose() {
            return super.dispose(), this._buffer = void 0, this
        }
        fromArray(e) {
            const n = Fr(e) && e[0].length > 0,
                r = n ? e.length : 1,
                s = n ? e[0].length : e.length,
                i = es(),
                a = i.createBuffer(r, s, i.sampleRate),
                c = !n && r === 1 ? [e] : e;
            for (let u = 0; u < r; u++) a.copyToChannel(c[u], u);
            return this._buffer = a, this
        }
        toMono(e) {
            if (Mi(e)) this.fromArray(this.toArray(e));
            else {
                let n = new Float32Array(this.length);
                const r = this.numberOfChannels;
                for (let s = 0; s < r; s++) {
                    const i = this.toArray(s);
                    for (let a = 0; a < i.length; a++) n[a] += i[a]
                }
                n = n.map(s => s / r), this.fromArray(n)
            }
            return this
        }
        toArray(e) {
            if (Mi(e)) return this.getChannelData(e);
            if (this.numberOfChannels === 1) return this.toArray(0); {
                const n = [];
                for (let r = 0; r < this.numberOfChannels; r++) n[r] = this.getChannelData(r);
                return n
            }
        }
        getChannelData(e) {
            return this._buffer ? this._buffer.getChannelData(e) : new Float32Array(0)
        }
        slice(e, n = this.duration) {
            const r = Math.floor(e * this.sampleRate),
                s = Math.floor(n * this.sampleRate);
            Ve(r < s, "The start time must be less than the end time");
            const i = s - r,
                a = es().createBuffer(this.numberOfChannels, i, this.sampleRate);
            for (let c = 0; c < this.numberOfChannels; c++) a.copyToChannel(this.getChannelData(c).subarray(r, s), c);
            return new Ot(a)
        }
        _reverse() {
            if (this.loaded)
                for (let e = 0; e < this.numberOfChannels; e++) this.getChannelData(e).reverse();
            return this
        }
        get loaded() {
            return this.length > 0
        }
        get duration() {
            return this._buffer ? this._buffer.duration : 0
        }
        get length() {
            return this._buffer ? this._buffer.length : 0
        }
        get numberOfChannels() {
            return this._buffer ? this._buffer.numberOfChannels : 0
        }
        get reverse() {
            return this._reversed
        }
        set reverse(e) {
            this._reversed !== e && (this._reversed = e, this._reverse())
        }
        static fromArray(e) {
            return new Ot().fromArray(e)
        }
        static fromUrl(e) {
            return yn(this, void 0, void 0, function*() {
                return yield new Ot().load(e)
            })
        }
        static load(e) {
            return yn(this, void 0, void 0, function*() {
                const n = e.match(/\[([^\]\[]+\|.+)\]$/);
                if (n) {
                    const c = n[1].split("|");
                    let u = c[0];
                    for (const h of c)
                        if (Ot.supportsType(h)) {
                            u = h;
                            break
                        } e = e.replace(n[0], u)
                }
                const r = Ot.baseUrl === "" || Ot.baseUrl.endsWith("/") ? Ot.baseUrl : Ot.baseUrl + "/",
                    s = yield fetch(r + e);
                if (!s.ok) throw new Error(`could not load url: ${e}`);
                const i = yield s.arrayBuffer();
                return yield es().decodeAudioData(i)
            })
        }
        static supportsType(e) {
            const n = e.split("."),
                r = n[n.length - 1];
            return document.createElement("audio").canPlayType("audio/" + r) !== ""
        }
        static loaded() {
            return yn(this, void 0, void 0, function*() {
                for (yield Promise.resolve(); Ot.downloads.length;) yield Ot.downloads[0]
            })
        }
    }
    Ot.baseUrl = "";
    Ot.downloads = [];
    class km extends _h {
        constructor() {
            super({
                clockSource: "offline",
                context: Qf(arguments[0]) ? arguments[0] : Iye(arguments[0], arguments[1] * arguments[2], arguments[2]),
                lookAhead: 0,
                updateInterval: Qf(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
            }), this.name = "OfflineContext", this._currentTime = 0, this.isOffline = !0, this._duration = Qf(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1]
        }
        now() {
            return this._currentTime
        }
        get currentTime() {
            return this._currentTime
        }
        _renderClock(e) {
            return yn(this, void 0, void 0, function*() {
                let n = 0;
                for (; this._duration - this._currentTime >= 0;) {
                    this.emit("tick"), this._currentTime += 128 / this.sampleRate, n++;
                    const r = Math.floor(this.sampleRate / 128);
                    e && n % r === 0 && (yield new Promise(s => setTimeout(s, 1)))
                }
            })
        }
        render(e = !0) {
            return yn(this, void 0, void 0, function*() {
                yield this.workletsAreReady(), yield this._renderClock(e);
                const n = yield this._context.startRendering();
                return new Ot(n)
            })
        }
        close() {
            return Promise.resolve()
        }
    }
    const Gk = new Uye;
    let Ic = Gk;

    function es() {
        return Ic === Gk && Nye && Bye(new _h), Ic
    }

    function Bye(t) {
        ic(t) ? Ic = new _h(t) : Qf(t) ? Ic = new km(t) : Ic = t
    }

    function Wk() {
        return Ic.resume()
    }
    if (ba && !ba.TONE_SILENCE_LOGGING) {
        const e = ` * Tone.js v${WC} * `;
        console.log(`%c${e}`, "background: #000; color: #fff")
    }

    function Bd(t) {
        return Math.pow(10, t / 20)
    }

    function L0(t) {
        return 20 * (Math.log(t) / Math.LN10)
    }

    function Aa(t) {
        return Math.pow(2, t / 12)
    }
    let Im = 440;

    function qye() {
        return Im
    }

    function jye(t) {
        Im = t
    }

    function fa(t) {
        return Math.round(Nm(t))
    }

    function Nm(t) {
        return 69 + 12 * Math.log2(t / Im)
    }

    function Hk(t) {
        return Im * Math.pow(2, (t - 69) / 12)
    }
    class F0 extends qi {
        constructor(e, n, r) {
            super(), this.defaultUnits = "s", this._val = n, this._units = r, this.context = e, this._expressions = this._getExpressions()
        }
        _getExpressions() {
            return {
                hz: {
                    method: e => this._frequencyToUnits(parseFloat(e)),
                    regexp: /^(\d+(?:\.\d+)?)hz$/i
                },
                i: {
                    method: e => this._ticksToUnits(parseInt(e, 10)),
                    regexp: /^(\d+)i$/i
                },
                m: {
                    method: e => this._beatsToUnits(parseInt(e, 10) * this._getTimeSignature()),
                    regexp: /^(\d+)m$/i
                },
                n: {
                    method: (e, n) => {
                        const r = parseInt(e, 10),
                            s = n === "." ? 1.5 : 1;
                        return r === 1 ? this._beatsToUnits(this._getTimeSignature()) * s : this._beatsToUnits(4 / r) * s
                    },
                    regexp: /^(\d+)n(\.?)$/i
                },
                number: {
                    method: e => this._expressions[this.defaultUnits].method.call(this, e),
                    regexp: /^(\d+(?:\.\d+)?)$/
                },
                s: {
                    method: e => this._secondsToUnits(parseFloat(e)),
                    regexp: /^(\d+(?:\.\d+)?)s$/
                },
                samples: {
                    method: e => parseInt(e, 10) / this.context.sampleRate,
                    regexp: /^(\d+)samples$/
                },
                t: {
                    method: e => {
                        const n = parseInt(e, 10);
                        return this._beatsToUnits(8 / (Math.floor(n) * 3))
                    },
                    regexp: /^(\d+)t$/i
                },
                tr: {
                    method: (e, n, r) => {
                        let s = 0;
                        return e && e !== "0" && (s += this._beatsToUnits(this._getTimeSignature() * parseFloat(e))), n && n !== "0" && (s += this._beatsToUnits(parseFloat(n))), r && r !== "0" && (s += this._beatsToUnits(parseFloat(r) / 4)), s
                    },
                    regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
                }
            }
        }
        valueOf() {
            if (this._val instanceof F0 && this.fromType(this._val), rs(this._val)) return this._noArg();
            if (Xs(this._val) && rs(this._units)) {
                for (const e in this._expressions)
                    if (this._expressions[e].regexp.test(this._val.trim())) {
                        this._units = e;
                        break
                    }
            } else if (va(this._val)) {
                let e = 0;
                for (const n in this._val)
                    if (yt(this._val[n])) {
                        const r = this._val[n],
                            s = new this.constructor(this.context, n).valueOf() * r;
                        e += s
                    } return e
            }
            if (yt(this._units)) {
                const e = this._expressions[this._units],
                    n = this._val.toString().trim().match(e.regexp);
                return n ? e.method.apply(this, n.slice(1)) : e.method.call(this, this._val)
            } else return Xs(this._val) ? parseFloat(this._val) : this._val
        }
        _frequencyToUnits(e) {
            return 1 / e
        }
        _beatsToUnits(e) {
            return 60 / this._getBpm() * e
        }
        _secondsToUnits(e) {
            return e
        }
        _ticksToUnits(e) {
            return e * this._beatsToUnits(1) / this._getPPQ()
        }
        _noArg() {
            return this._now()
        }
        _getBpm() {
            return this.context.transport.bpm.value
        }
        _getTimeSignature() {
            return this.context.transport.timeSignature
        }
        _getPPQ() {
            return this.context.transport.PPQ
        }
        fromType(e) {
            switch (this._units = void 0, this.defaultUnits) {
                case "s":
                    this._val = e.toSeconds();
                    break;
                case "i":
                    this._val = e.toTicks();
                    break;
                case "hz":
                    this._val = e.toFrequency();
                    break;
                case "midi":
                    this._val = e.toMidi();
                    break
            }
            return this
        }
        toFrequency() {
            return 1 / this.toSeconds()
        }
        toSamples() {
            return this.toSeconds() * this.context.sampleRate
        }
        toMilliseconds() {
            return this.toSeconds() * 1e3
        }
    }
    class Es extends F0 {
        constructor() {
            super(...arguments), this.name = "TimeClass"
        }
        _getExpressions() {
            return Object.assign(super._getExpressions(), {
                now: {
                    method: e => this._now() + new this.constructor(this.context, e).valueOf(),
                    regexp: /^\+(.+)/
                },
                quantize: {
                    method: e => {
                        const n = new Es(this.context, e).valueOf();
                        return this._secondsToUnits(this.context.transport.nextSubdivision(n))
                    },
                    regexp: /^@(.+)/
                }
            })
        }
        quantize(e, n = 1) {
            const r = new this.constructor(this.context, e).valueOf(),
                s = this.valueOf(),
                c = Math.round(s / r) * r - s;
            return s + c * n
        }
        toNotation() {
            const e = this.toSeconds(),
                n = ["1m"];
            for (let i = 1; i < 9; i++) {
                const a = Math.pow(2, i);
                n.push(a + "n."), n.push(a + "n"), n.push(a + "t")
            }
            n.push("0");
            let r = n[0],
                s = new Es(this.context, n[0]).toSeconds();
            return n.forEach(i => {
                const a = new Es(this.context, i).toSeconds();
                Math.abs(a - e) < Math.abs(s - e) && (r = i, s = a)
            }), r
        }
        toBarsBeatsSixteenths() {
            const e = this._beatsToUnits(1);
            let n = this.valueOf() / e;
            n = parseFloat(n.toFixed(4));
            const r = Math.floor(n / this._getTimeSignature());
            let s = n % 1 * 4;
            n = Math.floor(n) % this._getTimeSignature();
            const i = s.toString();
            return i.length > 3 && (s = parseFloat(parseFloat(i).toFixed(3))), [r, n, s].join(":")
        }
        toTicks() {
            const e = this._beatsToUnits(1),
                n = this.valueOf() / e;
            return Math.round(n * this._getPPQ())
        }
        toSeconds() {
            return this.valueOf()
        }
        toMidi() {
            return fa(this.toFrequency())
        }
        _now() {
            return this.context.now()
        }
    }
    class Wn extends Es {
        constructor() {
            super(...arguments), this.name = "Frequency", this.defaultUnits = "hz"
        }
        static get A4() {
            return qye()
        }
        static set A4(e) {
            jye(e)
        }
        _getExpressions() {
            return Object.assign({}, super._getExpressions(), {
                midi: {
                    regexp: /^(\d+(?:\.\d+)?midi)/,
                    method(e) {
                        return this.defaultUnits === "midi" ? e : Wn.mtof(e)
                    }
                },
                note: {
                    regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,
                    method(e, n) {
                        const s = Vye[e.toLowerCase()] + (parseInt(n, 10) + 1) * 12;
                        return this.defaultUnits === "midi" ? s : Wn.mtof(s)
                    }
                },
                tr: {
                    regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
                    method(e, n, r) {
                        let s = 1;
                        return e && e !== "0" && (s *= this._beatsToUnits(this._getTimeSignature() * parseFloat(e))), n && n !== "0" && (s *= this._beatsToUnits(parseFloat(n))), r && r !== "0" && (s *= this._beatsToUnits(parseFloat(r) / 4)), s
                    }
                }
            })
        }
        transpose(e) {
            return new Wn(this.context, this.valueOf() * Aa(e))
        }
        harmonize(e) {
            return e.map(n => this.transpose(n))
        }
        toMidi() {
            return fa(this.valueOf())
        }
        toNote() {
            const e = this.toFrequency(),
                n = Math.log2(e / Wn.A4);
            let r = Math.round(12 * n) + 57;
            const s = Math.floor(r / 12);
            return s < 0 && (r += -12 * s), Gye[r % 12] + s.toString()
        }
        toSeconds() {
            return 1 / super.toSeconds()
        }
        toTicks() {
            const e = this._beatsToUnits(1),
                n = this.valueOf() / e;
            return Math.floor(n * this._getPPQ())
        }
        _noArg() {
            return 0
        }
        _frequencyToUnits(e) {
            return e
        }
        _ticksToUnits(e) {
            return 1 / (e * 60 / (this._getBpm() * this._getPPQ()))
        }
        _beatsToUnits(e) {
            return 1 / super._beatsToUnits(e)
        }
        _secondsToUnits(e) {
            return 1 / e
        }
        static mtof(e) {
            return Hk(e)
        }
        static ftom(e) {
            return fa(e)
        }
    }
    const Vye = {
            cbb: -2,
            cb: -1,
            c: 0,
            "c#": 1,
            cx: 2,
            dbb: 0,
            db: 1,
            d: 2,
            "d#": 3,
            dx: 4,
            ebb: 2,
            eb: 3,
            e: 4,
            "e#": 5,
            ex: 6,
            fbb: 3,
            fb: 4,
            f: 5,
            "f#": 6,
            fx: 7,
            gbb: 5,
            gb: 6,
            g: 7,
            "g#": 8,
            gx: 9,
            abb: 7,
            ab: 8,
            a: 9,
            "a#": 10,
            ax: 11,
            bbb: 9,
            bb: 10,
            b: 11,
            "b#": 12,
            bx: 13
        },
        Gye = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

    function qd(t, e) {
        return new Wn(es(), t, e)
    }
    class iu extends Es {
        constructor() {
            super(...arguments), this.name = "TransportTime"
        }
        _now() {
            return this.context.transport.seconds
        }
    }
    class Or extends qi {
        constructor() {
            super();
            const e = Y(Or.getDefaults(), arguments, ["context"]);
            this.defaultContext ? this.context = this.defaultContext : this.context = e.context
        }
        static getDefaults() {
            return {
                context: es()
            }
        }
        now() {
            return this.context.currentTime + this.context.lookAhead
        }
        immediate() {
            return this.context.currentTime
        }
        get sampleTime() {
            return 1 / this.context.sampleRate
        }
        get blockTime() {
            return 128 / this.context.sampleRate
        }
        toSeconds(e) {
            return new Es(this.context, e).toSeconds()
        }
        toFrequency(e) {
            return new Wn(this.context, e).toFrequency()
        }
        toTicks(e) {
            return new iu(this.context, e).toTicks()
        }
        _getPartialProperties(e) {
            const n = this.get();
            return Object.keys(n).forEach(r => {
                rs(e[r]) && delete n[r]
            }), n
        }
        get() {
            const e = Dye(this);
            return Object.keys(e).forEach(n => {
                if (Reflect.has(this, n)) {
                    const r = this[n];
                    yt(r) && yt(r.value) && yt(r.setValueAtTime) ? e[n] = r.value : r instanceof Or ? e[n] = r._getPartialProperties(e[n]) : Fr(r) || Mi(r) || Xs(r) || Cye(r) ? e[n] = r : delete e[n]
                }
            }), e
        }
        set(e) {
            return Object.keys(e).forEach(n => {
                Reflect.has(this, n) && yt(this[n]) && (this[n] && yt(this[n].value) && yt(this[n].setValueAtTime) ? this[n].value !== e[n] && (this[n].value = e[n]) : this[n] instanceof Or ? this[n].set(e[n]) : this[n] = e[n])
            }), this
        }
    }
    class U0 extends li {
        constructor(e = "stopped") {
            super(), this.name = "StateTimeline", this._initial = e, this.setStateAtTime(this._initial, 0)
        }
        getValueAtTime(e) {
            const n = this.get(e);
            return n !== null ? n.state : this._initial
        }
        setStateAtTime(e, n, r) {
            return As(n, 0), this.add(Object.assign({}, r, {
                state: e,
                time: n
            })), this
        }
        getLastState(e, n) {
            const r = this._search(n);
            for (let s = r; s >= 0; s--) {
                const i = this._timeline[s];
                if (i.state === e) return i
            }
        }
        getNextState(e, n) {
            const r = this._search(n);
            if (r !== -1)
                for (let s = r; s < this._timeline.length; s++) {
                    const i = this._timeline[s];
                    if (i.state === e) return i
                }
        }
    }
    class it extends Or {
        constructor() {
            super(Y(it.getDefaults(), arguments, ["param", "units", "convert"])), this.name = "Param", this.overridden = !1, this._minOutput = 1e-7;
            const e = Y(it.getDefaults(), arguments, ["param", "units", "convert"]);
            for (Ve(yt(e.param) && (Oa(e.param) || e.param instanceof it), "param must be an AudioParam"); !Oa(e.param);) e.param = e.param._param;
            this._swappable = yt(e.swappable) ? e.swappable : !1, this._swappable ? (this.input = this.context.createGain(), this._param = e.param, this.input.connect(this._param)) : this._param = this.input = e.param, this._events = new li(1e3), this._initialValue = this._param.defaultValue, this.units = e.units, this.convert = e.convert, this._minValue = e.minValue, this._maxValue = e.maxValue, yt(e.value) && e.value !== this._toType(this._initialValue) && this.setValueAtTime(e.value, 0)
        }
        static getDefaults() {
            return Object.assign(Or.getDefaults(), {
                convert: !0,
                units: "number"
            })
        }
        get value() {
            const e = this.now();
            return this.getValueAtTime(e)
        }
        set value(e) {
            this.cancelScheduledValues(this.now()), this.setValueAtTime(e, this.now())
        }
        get minValue() {
            return yt(this._minValue) ? this._minValue : this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples" ? 0 : this.units === "audioRange" ? -1 : this.units === "decibels" ? -1 / 0 : this._param.minValue
        }
        get maxValue() {
            return yt(this._maxValue) ? this._maxValue : this.units === "normalRange" || this.units === "audioRange" ? 1 : this._param.maxValue
        }
        _is(e, n) {
            return this.units === n
        }
        _assertRange(e) {
            return yt(this.maxValue) && yt(this.minValue) && As(e, this._fromType(this.minValue), this._fromType(this.maxValue)), e
        }
        _fromType(e) {
            return this.convert && !this.overridden ? this._is(e, "time") ? this.toSeconds(e) : this._is(e, "decibels") ? Bd(e) : this._is(e, "frequency") ? this.toFrequency(e) : e : this.overridden ? 0 : e
        }
        _toType(e) {
            return this.convert && this.units === "decibels" ? L0(e) : e
        }
        setValueAtTime(e, n) {
            const r = this.toSeconds(n),
                s = this._fromType(e);
            return Ve(isFinite(s) && isFinite(r), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`), this._assertRange(s), this.log(this.units, "setValueAtTime", e, r), this._events.add({
                time: r,
                type: "setValueAtTime",
                value: s
            }), this._param.setValueAtTime(s, r), this
        }
        getValueAtTime(e) {
            const n = Math.max(this.toSeconds(e), 0),
                r = this._events.getAfter(n),
                s = this._events.get(n);
            let i = this._initialValue;
            if (s === null) i = this._initialValue;
            else if (s.type === "setTargetAtTime" && (r === null || r.type === "setValueAtTime")) {
                const a = this._events.getBefore(s.time);
                let c;
                a === null ? c = this._initialValue : c = a.value, s.type === "setTargetAtTime" && (i = this._exponentialApproach(s.time, c, s.value, s.constant, n))
            } else if (r === null) i = s.value;
            else if (r.type === "linearRampToValueAtTime" || r.type === "exponentialRampToValueAtTime") {
                let a = s.value;
                if (s.type === "setTargetAtTime") {
                    const c = this._events.getBefore(s.time);
                    c === null ? a = this._initialValue : a = c.value
                }
                r.type === "linearRampToValueAtTime" ? i = this._linearInterpolate(s.time, a, r.time, r.value, n) : i = this._exponentialInterpolate(s.time, a, r.time, r.value, n)
            } else i = s.value;
            return this._toType(i)
        }
        setRampPoint(e) {
            e = this.toSeconds(e);
            let n = this.getValueAtTime(e);
            return this.cancelAndHoldAtTime(e), this._fromType(n) === 0 && (n = this._toType(this._minOutput)), this.setValueAtTime(n, e), this
        }
        linearRampToValueAtTime(e, n) {
            const r = this._fromType(e),
                s = this.toSeconds(n);
            return Ve(isFinite(r) && isFinite(s), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`), this._assertRange(r), this._events.add({
                time: s,
                type: "linearRampToValueAtTime",
                value: r
            }), this.log(this.units, "linearRampToValueAtTime", e, s), this._param.linearRampToValueAtTime(r, s), this
        }
        exponentialRampToValueAtTime(e, n) {
            let r = this._fromType(e);
            r = _s(r, 0) ? this._minOutput : r, this._assertRange(r);
            const s = this.toSeconds(n);
            return Ve(isFinite(r) && isFinite(s), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`), this._events.add({
                time: s,
                type: "exponentialRampToValueAtTime",
                value: r
            }), this.log(this.units, "exponentialRampToValueAtTime", e, s), this._param.exponentialRampToValueAtTime(r, s), this
        }
        exponentialRampTo(e, n, r) {
            return r = this.toSeconds(r), this.setRampPoint(r), this.exponentialRampToValueAtTime(e, r + this.toSeconds(n)), this
        }
        linearRampTo(e, n, r) {
            return r = this.toSeconds(r), this.setRampPoint(r), this.linearRampToValueAtTime(e, r + this.toSeconds(n)), this
        }
        targetRampTo(e, n, r) {
            return r = this.toSeconds(r), this.setRampPoint(r), this.exponentialApproachValueAtTime(e, r, n), this
        }
        exponentialApproachValueAtTime(e, n, r) {
            n = this.toSeconds(n), r = this.toSeconds(r);
            const s = Math.log(r + 1) / Math.log(200);
            return this.setTargetAtTime(e, n, s), this.cancelAndHoldAtTime(n + r * .9), this.linearRampToValueAtTime(e, n + r), this
        }
        setTargetAtTime(e, n, r) {
            const s = this._fromType(e);
            Ve(isFinite(r) && r > 0, "timeConstant must be a number greater than 0");
            const i = this.toSeconds(n);
            return this._assertRange(s), Ve(isFinite(s) && isFinite(i), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`), this._events.add({
                constant: r,
                time: i,
                type: "setTargetAtTime",
                value: s
            }), this.log(this.units, "setTargetAtTime", e, i, r), this._param.setTargetAtTime(s, i, r), this
        }
        setValueCurveAtTime(e, n, r, s = 1) {
            r = this.toSeconds(r), n = this.toSeconds(n);
            const i = this._fromType(e[0]) * s;
            this.setValueAtTime(this._toType(i), n);
            const a = r / (e.length - 1);
            for (let c = 1; c < e.length; c++) {
                const u = this._fromType(e[c]) * s;
                this.linearRampToValueAtTime(this._toType(u), n + c * a)
            }
            return this
        }
        cancelScheduledValues(e) {
            const n = this.toSeconds(e);
            return Ve(isFinite(n), `Invalid argument to cancelScheduledValues: ${JSON.stringify(e)}`), this._events.cancel(n), this._param.cancelScheduledValues(n), this.log(this.units, "cancelScheduledValues", n), this
        }
        cancelAndHoldAtTime(e) {
            const n = this.toSeconds(e),
                r = this._fromType(this.getValueAtTime(n));
            Ve(isFinite(n), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(e)}`), this.log(this.units, "cancelAndHoldAtTime", n, "value=" + r);
            const s = this._events.get(n),
                i = this._events.getAfter(n);
            return s && _s(s.time, n) ? i ? (this._param.cancelScheduledValues(i.time), this._events.cancel(i.time)) : (this._param.cancelAndHoldAtTime(n), this._events.cancel(n + this.sampleTime)) : i && (this._param.cancelScheduledValues(i.time), this._events.cancel(i.time), i.type === "linearRampToValueAtTime" ? this.linearRampToValueAtTime(this._toType(r), n) : i.type === "exponentialRampToValueAtTime" && this.exponentialRampToValueAtTime(this._toType(r), n)), this._events.add({
                time: n,
                type: "setValueAtTime",
                value: r
            }), this._param.setValueAtTime(r, n), this
        }
        rampTo(e, n = .1, r) {
            return this.units === "frequency" || this.units === "bpm" || this.units === "decibels" ? this.exponentialRampTo(e, n, r) : this.linearRampTo(e, n, r), this
        }
        apply(e) {
            const n = this.context.currentTime;
            e.setValueAtTime(this.getValueAtTime(n), n);
            const r = this._events.get(n);
            if (r && r.type === "setTargetAtTime") {
                const s = this._events.getAfter(r.time),
                    i = s ? s.time : n + 2,
                    a = (i - n) / 10;
                for (let c = n; c < i; c += a) e.linearRampToValueAtTime(this.getValueAtTime(c), c)
            }
            return this._events.forEachAfter(this.context.currentTime, s => {
                s.type === "cancelScheduledValues" ? e.cancelScheduledValues(s.time) : s.type === "setTargetAtTime" ? e.setTargetAtTime(s.value, s.time, s.constant) : e[s.type](s.value, s.time)
            }), this
        }
        setParam(e) {
            Ve(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
            const n = this.input;
            return n.disconnect(this._param), this.apply(e), this._param = e, n.connect(this._param), this
        }
        dispose() {
            return super.dispose(), this._events.dispose(), this
        }
        get defaultValue() {
            return this._toType(this._param.defaultValue)
        }
        _exponentialApproach(e, n, r, s, i) {
            return r + (n - r) * Math.exp(-(i - e) / s)
        }
        _linearInterpolate(e, n, r, s, i) {
            return n + (s - n) * ((i - e) / (r - e))
        }
        _exponentialInterpolate(e, n, r, s, i) {
            return n * Math.pow(s / n, (i - e) / (r - e))
        }
    }
    class Oe extends Or {
        constructor() {
            super(...arguments), this.name = "ToneAudioNode", this._internalChannels = []
        }
        get numberOfInputs() {
            return yt(this.input) ? Oa(this.input) || this.input instanceof it ? 1 : this.input.numberOfInputs : 0
        }
        get numberOfOutputs() {
            return yt(this.output) ? this.output.numberOfOutputs : 0
        }
        _isAudioNode(e) {
            return yt(e) && (e instanceof Oe || yo(e))
        }
        _getInternalNodes() {
            const e = this._internalChannels.slice(0);
            return this._isAudioNode(this.input) && e.push(this.input), this._isAudioNode(this.output) && this.input !== this.output && e.push(this.output), e
        }
        _setChannelProperties(e) {
            this._getInternalNodes().forEach(r => {
                r.channelCount = e.channelCount, r.channelCountMode = e.channelCountMode, r.channelInterpretation = e.channelInterpretation
            })
        }
        _getChannelProperties() {
            const e = this._getInternalNodes();
            Ve(e.length > 0, "ToneAudioNode does not have any internal nodes");
            const n = e[0];
            return {
                channelCount: n.channelCount,
                channelCountMode: n.channelCountMode,
                channelInterpretation: n.channelInterpretation
            }
        }
        get channelCount() {
            return this._getChannelProperties().channelCount
        }
        set channelCount(e) {
            const n = this._getChannelProperties();
            this._setChannelProperties(Object.assign(n, {
                channelCount: e
            }))
        }
        get channelCountMode() {
            return this._getChannelProperties().channelCountMode
        }
        set channelCountMode(e) {
            const n = this._getChannelProperties();
            this._setChannelProperties(Object.assign(n, {
                channelCountMode: e
            }))
        }
        get channelInterpretation() {
            return this._getChannelProperties().channelInterpretation
        }
        set channelInterpretation(e) {
            const n = this._getChannelProperties();
            this._setChannelProperties(Object.assign(n, {
                channelInterpretation: e
            }))
        }
        connect(e, n = 0, r = 0) {
            return os(this, e, n, r), this
        }
        toDestination() {
            return this.connect(this.context.destination), this
        }
        toMaster() {
            return D0("toMaster() has been renamed toDestination()"), this.toDestination()
        }
        disconnect(e, n = 0, r = 0) {
            return Kk(this, e, n, r), this
        }
        chain(...e) {
            return is(this, ...e), this
        }
        fan(...e) {
            return e.forEach(n => this.connect(n)), this
        }
        dispose() {
            return super.dispose(), yt(this.input) && (this.input instanceof Oe ? this.input.dispose() : yo(this.input) && this.input.disconnect()), yt(this.output) && (this.output instanceof Oe ? this.output.dispose() : yo(this.output) && this.output.disconnect()), this._internalChannels = [], this
        }
    }

    function is(...t) {
        const e = t.shift();
        t.reduce((n, r) => (n instanceof Oe ? n.connect(r) : yo(n) && os(n, r), r), e)
    }

    function os(t, e, n = 0, r = 0) {
        for (Ve(yt(t), "Cannot connect from undefined node"), Ve(yt(e), "Cannot connect to undefined node"), (e instanceof Oe || yo(e)) && Ve(e.numberOfInputs > 0, "Cannot connect to node with no inputs"), Ve(t.numberOfOutputs > 0, "Cannot connect from node with no outputs"); e instanceof Oe || e instanceof it;) yt(e.input) && (e = e.input);
        for (; t instanceof Oe;) yt(t.output) && (t = t.output);
        Oa(e) ? t.connect(e, n) : t.connect(e, n, r)
    }

    function Kk(t, e, n = 0, r = 0) {
        if (yt(e))
            for (; e instanceof Oe;) e = e.input;
        for (; !yo(t);) yt(t.output) && (t = t.output);
        Oa(e) ? t.disconnect(e, n) : yo(e) ? t.disconnect(e, n, r) : t.disconnect()
    }
    class Le extends Oe {
        constructor() {
            super(Y(Le.getDefaults(), arguments, ["gain", "units"])), this.name = "Gain", this._gainNode = this.context.createGain(), this.input = this._gainNode, this.output = this._gainNode;
            const e = Y(Le.getDefaults(), arguments, ["gain", "units"]);
            this.gain = new it({
                context: this.context,
                convert: e.convert,
                param: this._gainNode.gain,
                units: e.units,
                value: e.gain,
                minValue: e.minValue,
                maxValue: e.maxValue
            }), Fe(this, "gain")
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                convert: !0,
                gain: 1,
                units: "gain"
            })
        }
        dispose() {
            return super.dispose(), this._gainNode.disconnect(), this.gain.dispose(), this
        }
    }
    class jc extends Oe {
        constructor(e) {
            super(e), this.onended = ht, this._startTime = -1, this._stopTime = -1, this._timeout = -1, this.output = new Le({
                context: this.context,
                gain: 0
            }), this._gainNode = this.output, this.getStateAtTime = function(n) {
                const r = this.toSeconds(n);
                return this._startTime !== -1 && r >= this._startTime && (this._stopTime === -1 || r <= this._stopTime) ? "started" : "stopped"
            }, this._fadeIn = e.fadeIn, this._fadeOut = e.fadeOut, this._curve = e.curve, this.onended = e.onended
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                curve: "linear",
                fadeIn: 0,
                fadeOut: 0,
                onended: ht
            })
        }
        _startGain(e, n = 1) {
            Ve(this._startTime === -1, "Source cannot be started more than once");
            const r = this.toSeconds(this._fadeIn);
            return this._startTime = e + r, this._startTime = Math.max(this._startTime, this.context.currentTime), r > 0 ? (this._gainNode.gain.setValueAtTime(0, e), this._curve === "linear" ? this._gainNode.gain.linearRampToValueAtTime(n, e + r) : this._gainNode.gain.exponentialApproachValueAtTime(n, e, r)) : this._gainNode.gain.setValueAtTime(n, e), this
        }
        stop(e) {
            return this.log("stop", e), this._stopGain(this.toSeconds(e)), this
        }
        _stopGain(e) {
            Ve(this._startTime !== -1, "'start' must be called before 'stop'"), this.cancelStop();
            const n = this.toSeconds(this._fadeOut);
            return this._stopTime = this.toSeconds(e) + n, this._stopTime = Math.max(this._stopTime, this.context.currentTime), n > 0 ? this._curve === "linear" ? this._gainNode.gain.linearRampTo(0, n, e) : this._gainNode.gain.targetRampTo(0, n, e) : (this._gainNode.gain.cancelAndHoldAtTime(e), this._gainNode.gain.setValueAtTime(0, e)), this.context.clearTimeout(this._timeout), this._timeout = this.context.setTimeout(() => {
                const r = this._curve === "exponential" ? n * 2 : 0;
                this._stopSource(this.now() + r), this._onended()
            }, this._stopTime - this.context.currentTime), this
        }
        _onended() {
            if (this.onended !== ht && (this.onended(this), this.onended = ht, !this.context.isOffline)) {
                const e = () => this.dispose();
                typeof window.requestIdleCallback < "u" ? window.requestIdleCallback(e) : setTimeout(e, 1e3)
            }
        }
        get state() {
            return this.getStateAtTime(this.now())
        }
        cancelStop() {
            return this.log("cancelStop"), Ve(this._startTime !== -1, "Source is not started"), this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime), this.context.clearTimeout(this._timeout), this._stopTime = -1, this
        }
        dispose() {
            return super.dispose(), this._gainNode.disconnect(), this
        }
    }
    class jd extends jc {
        constructor() {
            super(Y(jd.getDefaults(), arguments, ["offset"])), this.name = "ToneConstantSource", this._source = this.context.createConstantSource();
            const e = Y(jd.getDefaults(), arguments, ["offset"]);
            os(this._source, this._gainNode), this.offset = new it({
                context: this.context,
                convert: e.convert,
                param: this._source.offset,
                units: e.units,
                value: e.offset,
                minValue: e.minValue,
                maxValue: e.maxValue
            })
        }
        static getDefaults() {
            return Object.assign(jc.getDefaults(), {
                convert: !0,
                offset: 1,
                units: "number"
            })
        }
        start(e) {
            const n = this.toSeconds(e);
            return this.log("start", n), this._startGain(n), this._source.start(n), this
        }
        _stopSource(e) {
            this._source.stop(e)
        }
        dispose() {
            return super.dispose(), this.state === "started" && this.stop(), this._source.disconnect(), this.offset.dispose(), this
        }
    }
    class Ge extends Oe {
        constructor() {
            super(Y(Ge.getDefaults(), arguments, ["value", "units"])), this.name = "Signal", this.override = !0;
            const e = Y(Ge.getDefaults(), arguments, ["value", "units"]);
            this.output = this._constantSource = new jd({
                context: this.context,
                convert: e.convert,
                offset: e.value,
                units: e.units,
                minValue: e.minValue,
                maxValue: e.maxValue
            }), this._constantSource.start(0), this.input = this._param = this._constantSource.offset
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                convert: !0,
                units: "number",
                value: 0
            })
        }
        connect(e, n = 0, r = 0) {
            return xm(this, e, n, r), this
        }
        dispose() {
            return super.dispose(), this._param.dispose(), this._constantSource.dispose(), this
        }
        setValueAtTime(e, n) {
            return this._param.setValueAtTime(e, n), this
        }
        getValueAtTime(e) {
            return this._param.getValueAtTime(e)
        }
        setRampPoint(e) {
            return this._param.setRampPoint(e), this
        }
        linearRampToValueAtTime(e, n) {
            return this._param.linearRampToValueAtTime(e, n), this
        }
        exponentialRampToValueAtTime(e, n) {
            return this._param.exponentialRampToValueAtTime(e, n), this
        }
        exponentialRampTo(e, n, r) {
            return this._param.exponentialRampTo(e, n, r), this
        }
        linearRampTo(e, n, r) {
            return this._param.linearRampTo(e, n, r), this
        }
        targetRampTo(e, n, r) {
            return this._param.targetRampTo(e, n, r), this
        }
        exponentialApproachValueAtTime(e, n, r) {
            return this._param.exponentialApproachValueAtTime(e, n, r), this
        }
        setTargetAtTime(e, n, r) {
            return this._param.setTargetAtTime(e, n, r), this
        }
        setValueCurveAtTime(e, n, r, s) {
            return this._param.setValueCurveAtTime(e, n, r, s), this
        }
        cancelScheduledValues(e) {
            return this._param.cancelScheduledValues(e), this
        }
        cancelAndHoldAtTime(e) {
            return this._param.cancelAndHoldAtTime(e), this
        }
        rampTo(e, n, r) {
            return this._param.rampTo(e, n, r), this
        }
        get value() {
            return this._param.value
        }
        set value(e) {
            this._param.value = e
        }
        get convert() {
            return this._param.convert
        }
        set convert(e) {
            this._param.convert = e
        }
        get units() {
            return this._param.units
        }
        get overridden() {
            return this._param.overridden
        }
        set overridden(e) {
            this._param.overridden = e
        }
        get maxValue() {
            return this._param.maxValue
        }
        get minValue() {
            return this._param.minValue
        }
        apply(e) {
            return this._param.apply(e), this
        }
    }

    function xm(t, e, n, r) {
        (e instanceof it || Oa(e) || e instanceof Ge && e.override) && (e.cancelScheduledValues(0), e.setValueAtTime(0, 0), e instanceof Ge && (e.overridden = !0)), os(t, e, n, r)
    }
    class Vd extends it {
        constructor() {
            super(Y(Vd.getDefaults(), arguments, ["value"])), this.name = "TickParam", this._events = new li(1 / 0), this._multiplier = 1;
            const e = Y(Vd.getDefaults(), arguments, ["value"]);
            this._multiplier = e.multiplier, this._events.cancel(0), this._events.add({
                ticks: 0,
                time: 0,
                type: "setValueAtTime",
                value: this._fromType(e.value)
            }), this.setValueAtTime(e.value, 0)
        }
        static getDefaults() {
            return Object.assign(it.getDefaults(), {
                multiplier: 1,
                units: "hertz",
                value: 1
            })
        }
        setTargetAtTime(e, n, r) {
            n = this.toSeconds(n), this.setRampPoint(n);
            const s = this._fromType(e),
                i = this._events.get(n),
                a = Math.round(Math.max(1 / r, 1));
            for (let c = 0; c <= a; c++) {
                const u = r * c + n,
                    h = this._exponentialApproach(i.time, i.value, s, r, u);
                this.linearRampToValueAtTime(this._toType(h), u)
            }
            return this
        }
        setValueAtTime(e, n) {
            const r = this.toSeconds(n);
            super.setValueAtTime(e, n);
            const s = this._events.get(r),
                i = this._events.previousEvent(s),
                a = this._getTicksUntilEvent(i, r);
            return s.ticks = Math.max(a, 0), this
        }
        linearRampToValueAtTime(e, n) {
            const r = this.toSeconds(n);
            super.linearRampToValueAtTime(e, n);
            const s = this._events.get(r),
                i = this._events.previousEvent(s),
                a = this._getTicksUntilEvent(i, r);
            return s.ticks = Math.max(a, 0), this
        }
        exponentialRampToValueAtTime(e, n) {
            n = this.toSeconds(n);
            const r = this._fromType(e),
                s = this._events.get(n),
                i = Math.round(Math.max((n - s.time) * 10, 1)),
                a = (n - s.time) / i;
            for (let c = 0; c <= i; c++) {
                const u = a * c + s.time,
                    h = this._exponentialInterpolate(s.time, s.value, n, r, u);
                this.linearRampToValueAtTime(this._toType(h), u)
            }
            return this
        }
        _getTicksUntilEvent(e, n) {
            if (e === null) e = {
                ticks: 0,
                time: 0,
                type: "setValueAtTime",
                value: 0
            };
            else if (rs(e.ticks)) {
                const a = this._events.previousEvent(e);
                e.ticks = this._getTicksUntilEvent(a, e.time)
            }
            const r = this._fromType(this.getValueAtTime(e.time));
            let s = this._fromType(this.getValueAtTime(n));
            const i = this._events.get(n);
            return i && i.time === n && i.type === "setValueAtTime" && (s = this._fromType(this.getValueAtTime(n - this.sampleTime))), .5 * (n - e.time) * (r + s) + e.ticks
        }
        getTicksAtTime(e) {
            const n = this.toSeconds(e),
                r = this._events.get(n);
            return Math.max(this._getTicksUntilEvent(r, n), 0)
        }
        getDurationOfTicks(e, n) {
            const r = this.toSeconds(n),
                s = this.getTicksAtTime(n);
            return this.getTimeOfTick(s + e) - r
        }
        getTimeOfTick(e) {
            const n = this._events.get(e, "ticks"),
                r = this._events.getAfter(e, "ticks");
            if (n && n.ticks === e) return n.time;
            if (n && r && r.type === "linearRampToValueAtTime" && n.value !== r.value) {
                const s = this._fromType(this.getValueAtTime(n.time)),
                    a = (this._fromType(this.getValueAtTime(r.time)) - s) / (r.time - n.time),
                    c = Math.sqrt(Math.pow(s, 2) - 2 * a * (n.ticks - e)),
                    u = (-s + c) / a,
                    h = (-s - c) / a;
                return (u > 0 ? u : h) + n.time
            } else return n ? n.value === 0 ? 1 / 0 : n.time + (e - n.ticks) / n.value : e / this._initialValue
        }
        ticksToTime(e, n) {
            return this.getDurationOfTicks(e, n)
        }
        timeToTicks(e, n) {
            const r = this.toSeconds(n),
                s = this.toSeconds(e),
                i = this.getTicksAtTime(r);
            return this.getTicksAtTime(r + s) - i
        }
        _fromType(e) {
            return this.units === "bpm" && this.multiplier ? 1 / (60 / e / this.multiplier) : super._fromType(e)
        }
        _toType(e) {
            return this.units === "bpm" && this.multiplier ? e / this.multiplier * 60 : super._toType(e)
        }
        get multiplier() {
            return this._multiplier
        }
        set multiplier(e) {
            const n = this.value;
            this._multiplier = e, this.cancelScheduledValues(0), this.setValueAtTime(n, 0)
        }
    }
    class Gd extends Ge {
        constructor() {
            super(Y(Gd.getDefaults(), arguments, ["value"])), this.name = "TickSignal";
            const e = Y(Gd.getDefaults(), arguments, ["value"]);
            this.input = this._param = new Vd({
                context: this.context,
                convert: e.convert,
                multiplier: e.multiplier,
                param: this._constantSource.offset,
                units: e.units,
                value: e.value
            })
        }
        static getDefaults() {
            return Object.assign(Ge.getDefaults(), {
                multiplier: 1,
                units: "hertz",
                value: 1
            })
        }
        ticksToTime(e, n) {
            return this._param.ticksToTime(e, n)
        }
        timeToTicks(e, n) {
            return this._param.timeToTicks(e, n)
        }
        getTimeOfTick(e) {
            return this._param.getTimeOfTick(e)
        }
        getDurationOfTicks(e, n) {
            return this._param.getDurationOfTicks(e, n)
        }
        getTicksAtTime(e) {
            return this._param.getTicksAtTime(e)
        }
        get multiplier() {
            return this._param.multiplier
        }
        set multiplier(e) {
            this._param.multiplier = e
        }
        dispose() {
            return super.dispose(), this._param.dispose(), this
        }
    }
    class Wd extends Or {
        constructor() {
            super(Y(Wd.getDefaults(), arguments, ["frequency"])), this.name = "TickSource", this._state = new U0, this._tickOffset = new li;
            const e = Y(Wd.getDefaults(), arguments, ["frequency"]);
            this.frequency = new Gd({
                context: this.context,
                units: e.units,
                value: e.frequency
            }), Fe(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.setTicksAtTime(0, 0)
        }
        static getDefaults() {
            return Object.assign({
                frequency: 1,
                units: "hertz"
            }, Or.getDefaults())
        }
        get state() {
            return this.getStateAtTime(this.now())
        }
        start(e, n) {
            const r = this.toSeconds(e);
            return this._state.getValueAtTime(r) !== "started" && (this._state.setStateAtTime("started", r), yt(n) && this.setTicksAtTime(n, r)), this
        }
        stop(e) {
            const n = this.toSeconds(e);
            if (this._state.getValueAtTime(n) === "stopped") {
                const r = this._state.get(n);
                r && r.time > 0 && (this._tickOffset.cancel(r.time), this._state.cancel(r.time))
            }
            return this._state.cancel(n), this._state.setStateAtTime("stopped", n), this.setTicksAtTime(0, n), this
        }
        pause(e) {
            const n = this.toSeconds(e);
            return this._state.getValueAtTime(n) === "started" && this._state.setStateAtTime("paused", n), this
        }
        cancel(e) {
            return e = this.toSeconds(e), this._state.cancel(e), this._tickOffset.cancel(e), this
        }
        getTicksAtTime(e) {
            const n = this.toSeconds(e),
                r = this._state.getLastState("stopped", n),
                s = {
                    state: "paused",
                    time: n
                };
            this._state.add(s);
            let i = r,
                a = 0;
            return this._state.forEachBetween(r.time, n + this.sampleTime, c => {
                let u = i.time;
                const h = this._tickOffset.get(c.time);
                h && h.time >= i.time && (a = h.ticks, u = h.time), i.state === "started" && c.state !== "started" && (a += this.frequency.getTicksAtTime(c.time) - this.frequency.getTicksAtTime(u)), i = c
            }), this._state.remove(s), a
        }
        get ticks() {
            return this.getTicksAtTime(this.now())
        }
        set ticks(e) {
            this.setTicksAtTime(e, this.now())
        }
        get seconds() {
            return this.getSecondsAtTime(this.now())
        }
        set seconds(e) {
            const n = this.now(),
                r = this.frequency.timeToTicks(e, n);
            this.setTicksAtTime(r, n)
        }
        getSecondsAtTime(e) {
            e = this.toSeconds(e);
            const n = this._state.getLastState("stopped", e),
                r = {
                    state: "paused",
                    time: e
                };
            this._state.add(r);
            let s = n,
                i = 0;
            return this._state.forEachBetween(n.time, e + this.sampleTime, a => {
                let c = s.time;
                const u = this._tickOffset.get(a.time);
                u && u.time >= s.time && (i = u.seconds, c = u.time), s.state === "started" && a.state !== "started" && (i += a.time - c), s = a
            }), this._state.remove(r), i
        }
        setTicksAtTime(e, n) {
            return n = this.toSeconds(n), this._tickOffset.cancel(n), this._tickOffset.add({
                seconds: this.frequency.getDurationOfTicks(e, n),
                ticks: e,
                time: n
            }), this
        }
        getStateAtTime(e) {
            return e = this.toSeconds(e), this._state.getValueAtTime(e)
        }
        getTimeOfTick(e, n = this.now()) {
            const r = this._tickOffset.get(n),
                s = this._state.get(n),
                i = Math.max(r.time, s.time),
                a = this.frequency.getTicksAtTime(i) + e - r.ticks;
            return this.frequency.getTimeOfTick(a)
        }
        forEachTickBetween(e, n, r) {
            let s = this._state.get(e);
            this._state.forEachBetween(e, n, a => {
                s && s.state === "started" && a.state !== "started" && this.forEachTickBetween(Math.max(s.time, e), a.time - this.sampleTime, r), s = a
            });
            let i = null;
            if (s && s.state === "started") {
                const a = Math.max(s.time, e),
                    c = this.frequency.getTicksAtTime(a),
                    u = this.frequency.getTicksAtTime(s.time),
                    h = c - u;
                let d = Math.ceil(h) - h;
                d = _s(d, 1) ? 0 : d;
                let p = this.frequency.getTimeOfTick(c + d);
                for (; p < n;) {
                    try {
                        r(p, Math.round(this.getTicksAtTime(p)))
                    } catch (m) {
                        i = m;
                        break
                    }
                    p += this.frequency.getDurationOfTicks(1, p)
                }
            }
            if (i) throw i;
            return this
        }
        dispose() {
            return super.dispose(), this._state.dispose(), this._tickOffset.dispose(), this.frequency.dispose(), this
        }
    }
    class Ou extends Or {
        constructor() {
            super(Y(Ou.getDefaults(), arguments, ["callback", "frequency"])), this.name = "Clock", this.callback = ht, this._lastUpdate = 0, this._state = new U0("stopped"), this._boundLoop = this._loop.bind(this);
            const e = Y(Ou.getDefaults(), arguments, ["callback", "frequency"]);
            this.callback = e.callback, this._tickSource = new Wd({
                context: this.context,
                frequency: e.frequency,
                units: e.units
            }), this._lastUpdate = 0, this.frequency = this._tickSource.frequency, Fe(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.context.on("tick", this._boundLoop)
        }
        static getDefaults() {
            return Object.assign(Or.getDefaults(), {
                callback: ht,
                frequency: 1,
                units: "hertz"
            })
        }
        get state() {
            return this._state.getValueAtTime(this.now())
        }
        start(e, n) {
            Lk(this.context);
            const r = this.toSeconds(e);
            return this.log("start", r), this._state.getValueAtTime(r) !== "started" && (this._state.setStateAtTime("started", r), this._tickSource.start(r, n), r < this._lastUpdate && this.emit("start", r, n)), this
        }
        stop(e) {
            const n = this.toSeconds(e);
            return this.log("stop", n), this._state.cancel(n), this._state.setStateAtTime("stopped", n), this._tickSource.stop(n), n < this._lastUpdate && this.emit("stop", n), this
        }
        pause(e) {
            const n = this.toSeconds(e);
            return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n), this._tickSource.pause(n), n < this._lastUpdate && this.emit("pause", n)), this
        }
        get ticks() {
            return Math.ceil(this.getTicksAtTime(this.now()))
        }
        set ticks(e) {
            this._tickSource.ticks = e
        }
        get seconds() {
            return this._tickSource.seconds
        }
        set seconds(e) {
            this._tickSource.seconds = e
        }
        getSecondsAtTime(e) {
            return this._tickSource.getSecondsAtTime(e)
        }
        setTicksAtTime(e, n) {
            return this._tickSource.setTicksAtTime(e, n), this
        }
        getTimeOfTick(e, n = this.now()) {
            return this._tickSource.getTimeOfTick(e, n)
        }
        getTicksAtTime(e) {
            return this._tickSource.getTicksAtTime(e)
        }
        nextTickTime(e, n) {
            const r = this.toSeconds(n),
                s = this.getTicksAtTime(r);
            return this._tickSource.getTimeOfTick(s + e, r)
        }
        _loop() {
            const e = this._lastUpdate,
                n = this.now();
            this._lastUpdate = n, this.log("loop", e, n), e !== n && (this._state.forEachBetween(e, n, r => {
                switch (r.state) {
                    case "started":
                        const s = this._tickSource.getTicksAtTime(r.time);
                        this.emit("start", r.time, s);
                        break;
                    case "stopped":
                        r.time !== 0 && this.emit("stop", r.time);
                        break;
                    case "paused":
                        this.emit("pause", r.time);
                        break
                }
            }), this._tickSource.forEachTickBetween(e, n, (r, s) => {
                this.callback(r, s)
            }))
        }
        getStateAtTime(e) {
            const n = this.toSeconds(e);
            return this._state.getValueAtTime(n)
        }
        dispose() {
            return super.dispose(), this.context.off("tick", this._boundLoop), this._tickSource.dispose(), this._state.dispose(), this
        }
    }
    gh.mixin(Ou);
    class Ur extends Oe {
        constructor() {
            super(Y(Ur.getDefaults(), arguments, ["delayTime", "maxDelay"])), this.name = "Delay";
            const e = Y(Ur.getDefaults(), arguments, ["delayTime", "maxDelay"]),
                n = this.toSeconds(e.maxDelay);
            this._maxDelay = Math.max(n, this.toSeconds(e.delayTime)), this._delayNode = this.input = this.output = this.context.createDelay(n), this.delayTime = new it({
                context: this.context,
                param: this._delayNode.delayTime,
                units: "time",
                value: e.delayTime,
                minValue: 0,
                maxValue: this.maxDelay
            }), Fe(this, "delayTime")
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                delayTime: 0,
                maxDelay: 1
            })
        }
        get maxDelay() {
            return this._maxDelay
        }
        dispose() {
            return super.dispose(), this._delayNode.disconnect(), this.delayTime.dispose(), this
        }
    }
    class vh extends qi {
        constructor() {
            super(), this.name = "ToneAudioBuffers", this._buffers = new Map, this._loadingCount = 0;
            const e = Y(vh.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
            this.baseUrl = e.baseUrl, Object.keys(e.urls).forEach(n => {
                this._loadingCount++;
                const r = e.urls[n];
                this.add(n, r, this._bufferLoaded.bind(this, e.onload), e.onerror)
            })
        }
        static getDefaults() {
            return {
                baseUrl: "",
                onerror: ht,
                onload: ht,
                urls: {}
            }
        }
        has(e) {
            return this._buffers.has(e.toString())
        }
        get(e) {
            return Ve(this.has(e), `ToneAudioBuffers has no buffer named: ${e}`), this._buffers.get(e.toString())
        }
        _bufferLoaded(e) {
            this._loadingCount--, this._loadingCount === 0 && e && e()
        }
        get loaded() {
            return Array.from(this._buffers).every(([e, n]) => n.loaded)
        }
        add(e, n, r = ht, s = ht) {
            return Xs(n) ? this._buffers.set(e.toString(), new Ot(this.baseUrl + n, r, s)) : this._buffers.set(e.toString(), new Ot(n, r, s)), this
        }
        dispose() {
            return super.dispose(), this._buffers.forEach(e => e.dispose()), this._buffers.clear(), this
        }
    }
    class Hd extends Wn {
        constructor() {
            super(...arguments), this.name = "MidiClass", this.defaultUnits = "midi"
        }
        _frequencyToUnits(e) {
            return fa(super._frequencyToUnits(e))
        }
        _ticksToUnits(e) {
            return fa(super._ticksToUnits(e))
        }
        _beatsToUnits(e) {
            return fa(super._beatsToUnits(e))
        }
        _secondsToUnits(e) {
            return fa(super._secondsToUnits(e))
        }
        toMidi() {
            return this.valueOf()
        }
        toFrequency() {
            return Hk(this.toMidi())
        }
        transpose(e) {
            return new Hd(this.context, this.toMidi() + e)
        }
    }
    class Ci extends iu {
        constructor() {
            super(...arguments), this.name = "Ticks", this.defaultUnits = "i"
        }
        _now() {
            return this.context.transport.ticks
        }
        _beatsToUnits(e) {
            return this._getPPQ() * e
        }
        _secondsToUnits(e) {
            return Math.floor(e / (60 / this._getBpm()) * this._getPPQ())
        }
        _ticksToUnits(e) {
            return e
        }
        toTicks() {
            return this.valueOf()
        }
        toSeconds() {
            return this.valueOf() / this._getPPQ() * (60 / this._getBpm())
        }
    }
    class Wye extends Or {
        constructor() {
            super(...arguments), this.name = "Draw", this.expiration = .25, this.anticipation = .008, this._events = new li, this._boundDrawLoop = this._drawLoop.bind(this), this._animationFrame = -1
        }
        schedule(e, n) {
            return this._events.add({
                callback: e,
                time: this.toSeconds(n)
            }), this._events.length === 1 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)), this
        }
        cancel(e) {
            return this._events.cancel(this.toSeconds(e)), this
        }
        _drawLoop() {
            const e = this.context.currentTime;
            for (; this._events.length && this._events.peek().time - this.anticipation <= e;) {
                const n = this._events.shift();
                n && e - n.time <= this.expiration && n.callback()
            }
            this._events.length > 0 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop))
        }
        dispose() {
            return super.dispose(), this._events.dispose(), cancelAnimationFrame(this._animationFrame), this
        }
    }
    Am(t => {
        t.draw = new Wye({
            context: t
        })
    });
    Cm(t => {
        t.draw.dispose()
    });
    class Hye extends qi {
        constructor() {
            super(...arguments), this.name = "IntervalTimeline", this._root = null, this._length = 0
        }
        add(e) {
            Ve(yt(e.time), "Events must have a time property"), Ve(yt(e.duration), "Events must have a duration parameter"), e.time = e.time.valueOf();
            let n = new Kye(e.time, e.time + e.duration, e);
            for (this._root === null ? this._root = n : this._root.insert(n), this._length++; n !== null;) n.updateHeight(), n.updateMax(), this._rebalance(n), n = n.parent;
            return this
        }
        remove(e) {
            if (this._root !== null) {
                const n = [];
                this._root.search(e.time, n);
                for (const r of n)
                    if (r.event === e) {
                        this._removeNode(r), this._length--;
                        break
                    }
            }
            return this
        }
        get length() {
            return this._length
        }
        cancel(e) {
            return this.forEachFrom(e, n => this.remove(n)), this
        }
        _setRoot(e) {
            this._root = e, this._root !== null && (this._root.parent = null)
        }
        _replaceNodeInParent(e, n) {
            e.parent !== null ? (e.isLeftChild() ? e.parent.left = n : e.parent.right = n, this._rebalance(e.parent)) : this._setRoot(n)
        }
        _removeNode(e) {
            if (e.left === null && e.right === null) this._replaceNodeInParent(e, null);
            else if (e.right === null) this._replaceNodeInParent(e, e.left);
            else if (e.left === null) this._replaceNodeInParent(e, e.right);
            else {
                const n = e.getBalance();
                let r, s = null;
                if (n > 0)
                    if (e.left.right === null) r = e.left, r.right = e.right, s = r;
                    else {
                        for (r = e.left.right; r.right !== null;) r = r.right;
                        r.parent && (r.parent.right = r.left, s = r.parent, r.left = e.left, r.right = e.right)
                    }
                else if (e.right.left === null) r = e.right, r.left = e.left, s = r;
                else {
                    for (r = e.right.left; r.left !== null;) r = r.left;
                    r.parent && (r.parent.left = r.right, s = r.parent, r.left = e.left, r.right = e.right)
                }
                e.parent !== null ? e.isLeftChild() ? e.parent.left = r : e.parent.right = r : this._setRoot(r), s && this._rebalance(s)
            }
            e.dispose()
        }
        _rotateLeft(e) {
            const n = e.parent,
                r = e.isLeftChild(),
                s = e.right;
            s && (e.right = s.left, s.left = e), n !== null ? r ? n.left = s : n.right = s : this._setRoot(s)
        }
        _rotateRight(e) {
            const n = e.parent,
                r = e.isLeftChild(),
                s = e.left;
            s && (e.left = s.right, s.right = e), n !== null ? r ? n.left = s : n.right = s : this._setRoot(s)
        }
        _rebalance(e) {
            const n = e.getBalance();
            n > 1 && e.left ? e.left.getBalance() < 0 ? this._rotateLeft(e.left) : this._rotateRight(e) : n < -1 && e.right && (e.right.getBalance() > 0 ? this._rotateRight(e.right) : this._rotateLeft(e))
        }
        get(e) {
            if (this._root !== null) {
                const n = [];
                if (this._root.search(e, n), n.length > 0) {
                    let r = n[0];
                    for (let s = 1; s < n.length; s++) n[s].low > r.low && (r = n[s]);
                    return r.event
                }
            }
            return null
        }
        forEach(e) {
            if (this._root !== null) {
                const n = [];
                this._root.traverse(r => n.push(r)), n.forEach(r => {
                    r.event && e(r.event)
                })
            }
            return this
        }
        forEachAtTime(e, n) {
            if (this._root !== null) {
                const r = [];
                this._root.search(e, r), r.forEach(s => {
                    s.event && n(s.event)
                })
            }
            return this
        }
        forEachFrom(e, n) {
            if (this._root !== null) {
                const r = [];
                this._root.searchAfter(e, r), r.forEach(s => {
                    s.event && n(s.event)
                })
            }
            return this
        }
        dispose() {
            return super.dispose(), this._root !== null && this._root.traverse(e => e.dispose()), this._root = null, this
        }
    }
    class Kye {
        constructor(e, n, r) {
            this._left = null, this._right = null, this.parent = null, this.height = 0, this.event = r, this.low = e, this.high = n, this.max = this.high
        }
        insert(e) {
            e.low <= this.low ? this.left === null ? this.left = e : this.left.insert(e) : this.right === null ? this.right = e : this.right.insert(e)
        }
        search(e, n) {
            e > this.max || (this.left !== null && this.left.search(e, n), this.low <= e && this.high > e && n.push(this), !(this.low > e) && this.right !== null && this.right.search(e, n))
        }
        searchAfter(e, n) {
            this.low >= e && (n.push(this), this.left !== null && this.left.searchAfter(e, n)), this.right !== null && this.right.searchAfter(e, n)
        }
        traverse(e) {
            e(this), this.left !== null && this.left.traverse(e), this.right !== null && this.right.traverse(e)
        }
        updateHeight() {
            this.left !== null && this.right !== null ? this.height = Math.max(this.left.height, this.right.height) + 1 : this.right !== null ? this.height = this.right.height + 1 : this.left !== null ? this.height = this.left.height + 1 : this.height = 0
        }
        updateMax() {
            this.max = this.high, this.left !== null && (this.max = Math.max(this.max, this.left.max)), this.right !== null && (this.max = Math.max(this.max, this.right.max))
        }
        getBalance() {
            let e = 0;
            return this.left !== null && this.right !== null ? e = this.left.height - this.right.height : this.left !== null ? e = this.left.height + 1 : this.right !== null && (e = -(this.right.height + 1)), e
        }
        isLeftChild() {
            return this.parent !== null && this.parent.left === this
        }
        get left() {
            return this._left
        }
        set left(e) {
            this._left = e, e !== null && (e.parent = this), this.updateHeight(), this.updateMax()
        }
        get right() {
            return this._right
        }
        set right(e) {
            this._right = e, e !== null && (e.parent = this), this.updateHeight(), this.updateMax()
        }
        dispose() {
            this.parent = null, this._left = null, this._right = null, this.event = null
        }
    }
    class Js extends Oe {
        constructor() {
            super(Y(Js.getDefaults(), arguments, ["volume"])), this.name = "Volume";
            const e = Y(Js.getDefaults(), arguments, ["volume"]);
            this.input = this.output = new Le({
                context: this.context,
                gain: e.volume,
                units: "decibels"
            }), this.volume = this.output.gain, Fe(this, "volume"), this._unmutedVolume = e.volume, this.mute = e.mute
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                mute: !1,
                volume: 0
            })
        }
        get mute() {
            return this.volume.value === -1 / 0
        }
        set mute(e) {
            !this.mute && e ? (this._unmutedVolume = this.volume.value, this.volume.value = -1 / 0) : this.mute && !e && (this.volume.value = this._unmutedVolume)
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this.volume.dispose(), this
        }
    }
    class Kd extends Oe {
        constructor() {
            super(Y(Kd.getDefaults(), arguments)), this.name = "Destination", this.input = new Js({
                context: this.context
            }), this.output = new Le({
                context: this.context
            }), this.volume = this.input.volume;
            const e = Y(Kd.getDefaults(), arguments);
            is(this.input, this.output, this.context.rawContext.destination), this.mute = e.mute, this._internalChannels = [this.input, this.context.rawContext.destination, this.output]
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                mute: !1,
                volume: 0
            })
        }
        get mute() {
            return this.input.mute
        }
        set mute(e) {
            this.input.mute = e
        }
        chain(...e) {
            return this.input.disconnect(), e.unshift(this.input), e.push(this.output), is(...e), this
        }
        get maxChannelCount() {
            return this.context.rawContext.destination.maxChannelCount
        }
        dispose() {
            return super.dispose(), this.volume.dispose(), this
        }
    }
    Am(t => {
        t.destination = new Kd({
            context: t
        })
    });
    Cm(t => {
        t.destination.dispose()
    });
    class Yye extends qi {
        constructor(e) {
            super(), this.name = "TimelineValue", this._timeline = new li({
                memory: 10
            }), this._initialValue = e
        }
        set(e, n) {
            return this._timeline.add({
                value: e,
                time: n
            }), this
        }
        get(e) {
            const n = this._timeline.get(e);
            return n ? n.value : this._initialValue
        }
    }
    class Ao {
        constructor(e, n) {
            this.id = Ao._eventId++;
            const r = Object.assign(Ao.getDefaults(), n);
            this.transport = e, this.callback = r.callback, this._once = r.once, this.time = r.time
        }
        static getDefaults() {
            return {
                callback: ht,
                once: !1,
                time: 0
            }
        }
        invoke(e) {
            this.callback && (this.callback(e), this._once && this.transport.clear(this.id))
        }
        dispose() {
            return this.callback = void 0, this
        }
    }
    Ao._eventId = 0;
    class B0 extends Ao {
        constructor(e, n) {
            super(e, n), this._currentId = -1, this._nextId = -1, this._nextTick = this.time, this._boundRestart = this._restart.bind(this);
            const r = Object.assign(B0.getDefaults(), n);
            this.duration = new Ci(e.context, r.duration).valueOf(), this._interval = new Ci(e.context, r.interval).valueOf(), this._nextTick = r.time, this.transport.on("start", this._boundRestart), this.transport.on("loopStart", this._boundRestart), this.context = this.transport.context, this._restart()
        }
        static getDefaults() {
            return Object.assign({}, Ao.getDefaults(), {
                duration: 1 / 0,
                interval: 1,
                once: !1
            })
        }
        invoke(e) {
            this._createEvents(e), super.invoke(e)
        }
        _createEvents(e) {
            const n = this.transport.getTicksAtTime(e);
            n >= this.time && n >= this._nextTick && this._nextTick + this._interval < this.time + this.duration && (this._nextTick += this._interval, this._currentId = this._nextId, this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new Ci(this.context, this._nextTick).toSeconds()))
        }
        _restart(e) {
            this.transport.clear(this._currentId), this.transport.clear(this._nextId), this._nextTick = this.time;
            const n = this.transport.getTicksAtTime(e);
            n > this.time && (this._nextTick = this.time + Math.ceil((n - this.time) / this._interval) * this._interval), this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new Ci(this.context, this._nextTick).toSeconds()), this._nextTick += this._interval, this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new Ci(this.context, this._nextTick).toSeconds())
        }
        dispose() {
            return super.dispose(), this.transport.clear(this._currentId), this.transport.clear(this._nextId), this.transport.off("start", this._boundRestart), this.transport.off("loopStart", this._boundRestart), this
        }
    }
    class Au extends Or {
        constructor() {
            super(Y(Au.getDefaults(), arguments)), this.name = "Transport", this._loop = new Yye(!1), this._loopStart = 0, this._loopEnd = 0, this._scheduledEvents = {}, this._timeline = new li, this._repeatedEvents = new Hye, this._syncedSignals = [], this._swingAmount = 0;
            const e = Y(Au.getDefaults(), arguments);
            this._ppq = e.ppq, this._clock = new Ou({
                callback: this._processTick.bind(this),
                context: this.context,
                frequency: 0,
                units: "bpm"
            }), this._bindClockEvents(), this.bpm = this._clock.frequency, this._clock.frequency.multiplier = e.ppq, this.bpm.setValueAtTime(e.bpm, 0), Fe(this, "bpm"), this._timeSignature = e.timeSignature, this._swingTicks = e.ppq / 2
        }
        static getDefaults() {
            return Object.assign(Or.getDefaults(), {
                bpm: 120,
                loopEnd: "4m",
                loopStart: 0,
                ppq: 192,
                swing: 0,
                swingSubdivision: "8n",
                timeSignature: 4
            })
        }
        _processTick(e, n) {
            if (this._loop.get(e) && n >= this._loopEnd && (this.emit("loopEnd", e), this._clock.setTicksAtTime(this._loopStart, e), n = this._loopStart, this.emit("loopStart", e, this._clock.getSecondsAtTime(e)), this.emit("loop", e)), this._swingAmount > 0 && n % this._ppq !== 0 && n % (this._swingTicks * 2) !== 0) {
                const r = n % (this._swingTicks * 2) / (this._swingTicks * 2),
                    s = Math.sin(r * Math.PI) * this._swingAmount;
                e += new Ci(this.context, this._swingTicks * 2 / 3).toSeconds() * s
            }
            this._timeline.forEachAtTime(n, r => r.invoke(e))
        }
        schedule(e, n) {
            const r = new Ao(this, {
                callback: e,
                time: new iu(this.context, n).toTicks()
            });
            return this._addEvent(r, this._timeline)
        }
        scheduleRepeat(e, n, r, s = 1 / 0) {
            const i = new B0(this, {
                callback: e,
                duration: new Es(this.context, s).toTicks(),
                interval: new Es(this.context, n).toTicks(),
                time: new iu(this.context, r).toTicks()
            });
            return this._addEvent(i, this._repeatedEvents)
        }
        scheduleOnce(e, n) {
            const r = new Ao(this, {
                callback: e,
                once: !0,
                time: new iu(this.context, n).toTicks()
            });
            return this._addEvent(r, this._timeline)
        }
        clear(e) {
            if (this._scheduledEvents.hasOwnProperty(e)) {
                const n = this._scheduledEvents[e.toString()];
                n.timeline.remove(n.event), n.event.dispose(), delete this._scheduledEvents[e.toString()]
            }
            return this
        }
        _addEvent(e, n) {
            return this._scheduledEvents[e.id.toString()] = {
                event: e,
                timeline: n
            }, n.add(e), e.id
        }
        cancel(e = 0) {
            const n = this.toTicks(e);
            return this._timeline.forEachFrom(n, r => this.clear(r.id)), this._repeatedEvents.forEachFrom(n, r => this.clear(r.id)), this
        }
        _bindClockEvents() {
            this._clock.on("start", (e, n) => {
                n = new Ci(this.context, n).toSeconds(), this.emit("start", e, n)
            }), this._clock.on("stop", e => {
                this.emit("stop", e)
            }), this._clock.on("pause", e => {
                this.emit("pause", e)
            })
        }
        get state() {
            return this._clock.getStateAtTime(this.now())
        }
        start(e, n) {
            let r;
            return yt(n) && (r = this.toTicks(n)), this._clock.start(e, r), this
        }
        stop(e) {
            return this._clock.stop(e), this
        }
        pause(e) {
            return this._clock.pause(e), this
        }
        toggle(e) {
            return e = this.toSeconds(e), this._clock.getStateAtTime(e) !== "started" ? this.start(e) : this.stop(e), this
        }
        get timeSignature() {
            return this._timeSignature
        }
        set timeSignature(e) {
            Fr(e) && (e = e[0] / e[1] * 4), this._timeSignature = e
        }
        get loopStart() {
            return new Es(this.context, this._loopStart, "i").toSeconds()
        }
        set loopStart(e) {
            this._loopStart = this.toTicks(e)
        }
        get loopEnd() {
            return new Es(this.context, this._loopEnd, "i").toSeconds()
        }
        set loopEnd(e) {
            this._loopEnd = this.toTicks(e)
        }
        get loop() {
            return this._loop.get(this.now())
        }
        set loop(e) {
            this._loop.set(e, this.now())
        }
        setLoopPoints(e, n) {
            return this.loopStart = e, this.loopEnd = n, this
        }
        get swing() {
            return this._swingAmount
        }
        set swing(e) {
            this._swingAmount = e
        }
        get swingSubdivision() {
            return new Ci(this.context, this._swingTicks).toNotation()
        }
        set swingSubdivision(e) {
            this._swingTicks = this.toTicks(e)
        }
        get position() {
            const e = this.now(),
                n = this._clock.getTicksAtTime(e);
            return new Ci(this.context, n).toBarsBeatsSixteenths()
        }
        set position(e) {
            const n = this.toTicks(e);
            this.ticks = n
        }
        get seconds() {
            return this._clock.seconds
        }
        set seconds(e) {
            const n = this.now(),
                r = this._clock.frequency.timeToTicks(e, n);
            this.ticks = r
        }
        get progress() {
            if (this.loop) {
                const e = this.now();
                return (this._clock.getTicksAtTime(e) - this._loopStart) / (this._loopEnd - this._loopStart)
            } else return 0
        }
        get ticks() {
            return this._clock.ticks
        }
        set ticks(e) {
            if (this._clock.ticks !== e) {
                const n = this.now();
                if (this.state === "started") {
                    const r = this._clock.getTicksAtTime(n),
                        s = this._clock.frequency.getDurationOfTicks(Math.ceil(r) - r, n),
                        i = n + s;
                    this.emit("stop", i), this._clock.setTicksAtTime(e, i), this.emit("start", i, this._clock.getSecondsAtTime(i))
                } else this._clock.setTicksAtTime(e, n)
            }
        }
        getTicksAtTime(e) {
            return Math.round(this._clock.getTicksAtTime(e))
        }
        getSecondsAtTime(e) {
            return this._clock.getSecondsAtTime(e)
        }
        get PPQ() {
            return this._clock.frequency.multiplier
        }
        set PPQ(e) {
            this._clock.frequency.multiplier = e
        }
        nextSubdivision(e) {
            if (e = this.toTicks(e), this.state !== "started") return 0; {
                const n = this.now(),
                    r = this.getTicksAtTime(n),
                    s = e - r % e;
                return this._clock.nextTickTime(s, n)
            }
        }
        syncSignal(e, n) {
            if (!n) {
                const s = this.now();
                if (e.getValueAtTime(s) !== 0) {
                    const a = 1 / (60 / this.bpm.getValueAtTime(s) / this.PPQ);
                    n = e.getValueAtTime(s) / a
                } else n = 0
            }
            const r = new Le(n);
            return this.bpm.connect(r), r.connect(e._param), this._syncedSignals.push({
                initial: e.value,
                ratio: r,
                signal: e
            }), e.value = 0, this
        }
        unsyncSignal(e) {
            for (let n = this._syncedSignals.length - 1; n >= 0; n--) {
                const r = this._syncedSignals[n];
                r.signal === e && (r.ratio.dispose(), r.signal.value = r.initial, this._syncedSignals.splice(n, 1))
            }
            return this
        }
        dispose() {
            return super.dispose(), this._clock.dispose(), yh(this, "bpm"), this._timeline.dispose(), this._repeatedEvents.dispose(), this
        }
    }
    gh.mixin(Au);
    Am(t => {
        t.transport = new Au({
            context: t
        })
    });
    Cm(t => {
        t.transport.dispose()
    });
    class An extends Oe {
        constructor(e) {
            super(e), this.input = void 0, this._state = new U0("stopped"), this._synced = !1, this._scheduled = [], this._syncedStart = ht, this._syncedStop = ht, this._state.memory = 100, this._state.increasing = !0, this._volume = this.output = new Js({
                context: this.context,
                mute: e.mute,
                volume: e.volume
            }), this.volume = this._volume.volume, Fe(this, "volume"), this.onstop = e.onstop
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                mute: !1,
                onstop: ht,
                volume: 0
            })
        }
        get state() {
            return this._synced ? this.context.transport.state === "started" ? this._state.getValueAtTime(this.context.transport.seconds) : "stopped" : this._state.getValueAtTime(this.now())
        }
        get mute() {
            return this._volume.mute
        }
        set mute(e) {
            this._volume.mute = e
        }
        _clampToCurrentTime(e) {
            return this._synced ? e : Math.max(e, this.context.currentTime)
        }
        start(e, n, r) {
            let s = rs(e) && this._synced ? this.context.transport.seconds : this.toSeconds(e);
            if (s = this._clampToCurrentTime(s), !this._synced && this._state.getValueAtTime(s) === "started") Ve(Ud(s, this._state.get(s).time), "Start time must be strictly greater than previous start time"), this._state.cancel(s), this._state.setStateAtTime("started", s), this.log("restart", s), this.restart(s, n, r);
            else if (this.log("start", s), this._state.setStateAtTime("started", s), this._synced) {
                const i = this._state.get(s);
                i && (i.offset = this.toSeconds(kc(n, 0)), i.duration = r ? this.toSeconds(r) : void 0);
                const a = this.context.transport.schedule(c => {
                    this._start(c, n, r)
                }, s);
                this._scheduled.push(a), this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > s && this._syncedStart(this.now(), this.context.transport.seconds)
            } else Lk(this.context), this._start(s, n, r);
            return this
        }
        stop(e) {
            let n = rs(e) && this._synced ? this.context.transport.seconds : this.toSeconds(e);
            if (n = this._clampToCurrentTime(n), this._state.getValueAtTime(n) === "started" || yt(this._state.getNextState("started", n))) {
                if (this.log("stop", n), !this._synced) this._stop(n);
                else {
                    const r = this.context.transport.schedule(this._stop.bind(this), n);
                    this._scheduled.push(r)
                }
                this._state.cancel(n), this._state.setStateAtTime("stopped", n)
            }
            return this
        }
        restart(e, n, r) {
            return e = this.toSeconds(e), this._state.getValueAtTime(e) === "started" && (this._state.cancel(e), this._restart(e, n, r)), this
        }
        sync() {
            return this._synced || (this._synced = !0, this._syncedStart = (e, n) => {
                if (n > 0) {
                    const r = this._state.get(n);
                    if (r && r.state === "started" && r.time !== n) {
                        const s = n - this.toSeconds(r.time);
                        let i;
                        r.duration && (i = this.toSeconds(r.duration) - s), this._start(e, this.toSeconds(r.offset) + s, i)
                    }
                }
            }, this._syncedStop = e => {
                const n = this.context.transport.getSecondsAtTime(Math.max(e - this.sampleTime, 0));
                this._state.getValueAtTime(n) === "started" && this._stop(e)
            }, this.context.transport.on("start", this._syncedStart), this.context.transport.on("loopStart", this._syncedStart), this.context.transport.on("stop", this._syncedStop), this.context.transport.on("pause", this._syncedStop), this.context.transport.on("loopEnd", this._syncedStop)), this
        }
        unsync() {
            return this._synced && (this.context.transport.off("stop", this._syncedStop), this.context.transport.off("pause", this._syncedStop), this.context.transport.off("loopEnd", this._syncedStop), this.context.transport.off("start", this._syncedStart), this.context.transport.off("loopStart", this._syncedStart)), this._synced = !1, this._scheduled.forEach(e => this.context.transport.clear(e)), this._scheduled = [], this._state.cancel(0), this._stop(0), this
        }
        dispose() {
            return super.dispose(), this.onstop = ht, this.unsync(), this._volume.dispose(), this._state.dispose(), this
        }
    }
    class Qs extends jc {
        constructor() {
            super(Y(Qs.getDefaults(), arguments, ["url", "onload"])), this.name = "ToneBufferSource", this._source = this.context.createBufferSource(), this._internalChannels = [this._source], this._sourceStarted = !1, this._sourceStopped = !1;
            const e = Y(Qs.getDefaults(), arguments, ["url", "onload"]);
            os(this._source, this._gainNode), this._source.onended = () => this._stopSource(), this.playbackRate = new it({
                context: this.context,
                param: this._source.playbackRate,
                units: "positive",
                value: e.playbackRate
            }), this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this._buffer = new Ot(e.url, e.onload, e.onerror), this._internalChannels.push(this._source)
        }
        static getDefaults() {
            return Object.assign(jc.getDefaults(), {
                url: new Ot,
                loop: !1,
                loopEnd: 0,
                loopStart: 0,
                onload: ht,
                onerror: ht,
                playbackRate: 1
            })
        }
        get fadeIn() {
            return this._fadeIn
        }
        set fadeIn(e) {
            this._fadeIn = e
        }
        get fadeOut() {
            return this._fadeOut
        }
        set fadeOut(e) {
            this._fadeOut = e
        }
        get curve() {
            return this._curve
        }
        set curve(e) {
            this._curve = e
        }
        start(e, n, r, s = 1) {
            Ve(this.buffer.loaded, "buffer is either not set or not loaded");
            const i = this.toSeconds(e);
            this._startGain(i, s), this.loop ? n = kc(n, this.loopStart) : n = kc(n, 0);
            let a = Math.max(this.toSeconds(n), 0);
            if (this.loop) {
                const c = this.toSeconds(this.loopEnd) || this.buffer.duration,
                    u = this.toSeconds(this.loopStart),
                    h = c - u;
                py(a, c) && (a = (a - u) % h + u), _s(a, this.buffer.duration) && (a = 0)
            }
            if (this._source.buffer = this.buffer.get(), this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration, Bk(a, this.buffer.duration) && (this._sourceStarted = !0, this._source.start(i, a)), yt(r)) {
                let c = this.toSeconds(r);
                c = Math.max(c, 0), this.stop(i + c)
            }
            return this
        }
        _stopSource(e) {
            !this._sourceStopped && this._sourceStarted && (this._sourceStopped = !0, this._source.stop(this.toSeconds(e)), this._onended())
        }
        get loopStart() {
            return this._source.loopStart
        }
        set loopStart(e) {
            this._source.loopStart = this.toSeconds(e)
        }
        get loopEnd() {
            return this._source.loopEnd
        }
        set loopEnd(e) {
            this._source.loopEnd = this.toSeconds(e)
        }
        get buffer() {
            return this._buffer
        }
        set buffer(e) {
            this._buffer.set(e)
        }
        get loop() {
            return this._source.loop
        }
        set loop(e) {
            this._source.loop = e, this._sourceStarted && this.cancelStop()
        }
        dispose() {
            return super.dispose(), this._source.onended = null, this._source.disconnect(), this._buffer.dispose(), this.playbackRate.dispose(), this
        }
    }
    class Co extends An {
        constructor() {
            super(Y(Co.getDefaults(), arguments, ["type"])), this.name = "Noise", this._source = null;
            const e = Y(Co.getDefaults(), arguments, ["type"]);
            this._playbackRate = e.playbackRate, this.type = e.type, this._fadeIn = e.fadeIn, this._fadeOut = e.fadeOut
        }
        static getDefaults() {
            return Object.assign(An.getDefaults(), {
                fadeIn: 0,
                fadeOut: 0,
                playbackRate: 1,
                type: "white"
            })
        }
        get type() {
            return this._type
        }
        set type(e) {
            if (Ve(e in q3, "Noise: invalid type: " + e), this._type !== e && (this._type = e, this.state === "started")) {
                const n = this.now();
                this._stop(n), this._start(n)
            }
        }
        get playbackRate() {
            return this._playbackRate
        }
        set playbackRate(e) {
            this._playbackRate = e, this._source && (this._source.playbackRate.value = e)
        }
        _start(e) {
            const n = q3[this._type];
            this._source = new Qs({
                url: n,
                context: this.context,
                fadeIn: this._fadeIn,
                fadeOut: this._fadeOut,
                loop: !0,
                onended: () => this.onstop(this),
                playbackRate: this._playbackRate
            }).connect(this.output), this._source.start(this.toSeconds(e), Math.random() * (n.duration - .001))
        }
        _stop(e) {
            this._source && (this._source.stop(this.toSeconds(e)), this._source = null)
        }
        get fadeIn() {
            return this._fadeIn
        }
        set fadeIn(e) {
            this._fadeIn = e, this._source && (this._source.fadeIn = this._fadeIn)
        }
        get fadeOut() {
            return this._fadeOut
        }
        set fadeOut(e) {
            this._fadeOut = e, this._source && (this._source.fadeOut = this._fadeOut)
        }
        _restart(e) {
            this._stop(e), this._start(e)
        }
        dispose() {
            return super.dispose(), this._source && this._source.disconnect(), this
        }
    }
    const nc = 44100 * 5,
        K_ = 2,
        bi = {
            brown: null,
            pink: null,
            white: null
        },
        q3 = {
            get brown() {
                if (!bi.brown) {
                    const t = [];
                    for (let e = 0; e < K_; e++) {
                        const n = new Float32Array(nc);
                        t[e] = n;
                        let r = 0;
                        for (let s = 0; s < nc; s++) {
                            const i = Math.random() * 2 - 1;
                            n[s] = (r + .02 * i) / 1.02, r = n[s], n[s] *= 3.5
                        }
                    }
                    bi.brown = new Ot().fromArray(t)
                }
                return bi.brown
            },
            get pink() {
                if (!bi.pink) {
                    const t = [];
                    for (let e = 0; e < K_; e++) {
                        const n = new Float32Array(nc);
                        t[e] = n;
                        let r, s, i, a, c, u, h;
                        r = s = i = a = c = u = h = 0;
                        for (let d = 0; d < nc; d++) {
                            const p = Math.random() * 2 - 1;
                            r = .99886 * r + p * .0555179, s = .99332 * s + p * .0750759, i = .969 * i + p * .153852, a = .8665 * a + p * .3104856, c = .55 * c + p * .5329522, u = -.7616 * u - p * .016898, n[d] = r + s + i + a + c + u + h + p * .5362, n[d] *= .11, h = p * .115926
                        }
                    }
                    bi.pink = new Ot().fromArray(t)
                }
                return bi.pink
            },
            get white() {
                if (!bi.white) {
                    const t = [];
                    for (let e = 0; e < K_; e++) {
                        const n = new Float32Array(nc);
                        t[e] = n;
                        for (let r = 0; r < nc; r++) n[r] = Math.random() * 2 - 1
                    }
                    bi.white = new Ot().fromArray(t)
                }
                return bi.white
            }
        };

    function Da(t, e) {
        return yn(this, void 0, void 0, function*() {
            const n = e / t.context.sampleRate,
                r = new km(1, n, t.context.sampleRate);
            return new t.constructor(Object.assign(t.get(), {
                frequency: 2 / n,
                detune: 0,
                context: r
            })).toDestination().start(0), (yield r.render()).getChannelData(0)
        })
    }
    class Cu extends jc {
        constructor() {
            super(Y(Cu.getDefaults(), arguments, ["frequency", "type"])), this.name = "ToneOscillatorNode", this._oscillator = this.context.createOscillator(), this._internalChannels = [this._oscillator];
            const e = Y(Cu.getDefaults(), arguments, ["frequency", "type"]);
            os(this._oscillator, this._gainNode), this.type = e.type, this.frequency = new it({
                context: this.context,
                param: this._oscillator.frequency,
                units: "frequency",
                value: e.frequency
            }), this.detune = new it({
                context: this.context,
                param: this._oscillator.detune,
                units: "cents",
                value: e.detune
            }), Fe(this, ["frequency", "detune"])
        }
        static getDefaults() {
            return Object.assign(jc.getDefaults(), {
                detune: 0,
                frequency: 440,
                type: "sine"
            })
        }
        start(e) {
            const n = this.toSeconds(e);
            return this.log("start", n), this._startGain(n), this._oscillator.start(n), this
        }
        _stopSource(e) {
            this._oscillator.stop(e)
        }
        setPeriodicWave(e) {
            return this._oscillator.setPeriodicWave(e), this
        }
        get type() {
            return this._oscillator.type
        }
        set type(e) {
            this._oscillator.type = e
        }
        dispose() {
            return super.dispose(), this.state === "started" && this.stop(), this._oscillator.disconnect(), this.frequency.dispose(), this.detune.dispose(), this
        }
    }
    class rn extends An {
        constructor() {
            super(Y(rn.getDefaults(), arguments, ["frequency", "type"])), this.name = "Oscillator", this._oscillator = null;
            const e = Y(rn.getDefaults(), arguments, ["frequency", "type"]);
            this.frequency = new Ge({
                context: this.context,
                units: "frequency",
                value: e.frequency
            }), Fe(this, "frequency"), this.detune = new Ge({
                context: this.context,
                units: "cents",
                value: e.detune
            }), Fe(this, "detune"), this._partials = e.partials, this._partialCount = e.partialCount, this._type = e.type, e.partialCount && e.type !== "custom" && (this._type = this.baseType + e.partialCount.toString()), this.phase = e.phase
        }
        static getDefaults() {
            return Object.assign(An.getDefaults(), {
                detune: 0,
                frequency: 440,
                partialCount: 0,
                partials: [],
                phase: 0,
                type: "sine"
            })
        }
        _start(e) {
            const n = this.toSeconds(e),
                r = new Cu({
                    context: this.context,
                    onended: () => this.onstop(this)
                });
            this._oscillator = r, this._wave ? this._oscillator.setPeriodicWave(this._wave) : this._oscillator.type = this._type, this._oscillator.connect(this.output), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.start(n)
        }
        _stop(e) {
            const n = this.toSeconds(e);
            this._oscillator && this._oscillator.stop(n)
        }
        _restart(e) {
            const n = this.toSeconds(e);
            return this.log("restart", n), this._oscillator && this._oscillator.cancelStop(), this._state.cancel(n), this
        }
        syncFrequency() {
            return this.context.transport.syncSignal(this.frequency), this
        }
        unsyncFrequency() {
            return this.context.transport.unsyncSignal(this.frequency), this
        }
        _getCachedPeriodicWave() {
            if (this._type === "custom") return rn._periodicWaveCache.find(n => n.phase === this._phase && Mye(n.partials, this._partials)); {
                const e = rn._periodicWaveCache.find(n => n.type === this._type && n.phase === this._phase);
                return this._partialCount = e ? e.partialCount : this._partialCount, e
            }
        }
        get type() {
            return this._type
        }
        set type(e) {
            this._type = e;
            const n = ["sine", "square", "sawtooth", "triangle"].indexOf(e) !== -1;
            if (this._phase === 0 && n) this._wave = void 0, this._partialCount = 0, this._oscillator !== null && (this._oscillator.type = e);
            else {
                const r = this._getCachedPeriodicWave();
                if (yt(r)) {
                    const {
                        partials: s,
                        wave: i
                    } = r;
                    this._wave = i, this._partials = s, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave)
                } else {
                    const [s, i] = this._getRealImaginary(e, this._phase), a = this.context.createPeriodicWave(s, i);
                    this._wave = a, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave), rn._periodicWaveCache.push({
                        imag: i,
                        partialCount: this._partialCount,
                        partials: this._partials,
                        phase: this._phase,
                        real: s,
                        type: this._type,
                        wave: this._wave
                    }), rn._periodicWaveCache.length > 100 && rn._periodicWaveCache.shift()
                }
            }
        }
        get baseType() {
            return this._type.replace(this.partialCount.toString(), "")
        }
        set baseType(e) {
            this.partialCount && this._type !== "custom" && e !== "custom" ? this.type = e + this.partialCount : this.type = e
        }
        get partialCount() {
            return this._partialCount
        }
        set partialCount(e) {
            As(e, 0);
            let n = this._type;
            const r = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
            if (r && (n = r[1]), this._type !== "custom") e === 0 ? this.type = n : this.type = n + e.toString();
            else {
                const s = new Float32Array(e);
                this._partials.forEach((i, a) => s[a] = i), this._partials = Array.from(s), this.type = this._type
            }
        }
        _getRealImaginary(e, n) {
            let s = 2048;
            const i = new Float32Array(s),
                a = new Float32Array(s);
            let c = 1;
            if (e === "custom") {
                if (c = this._partials.length + 1, this._partialCount = this._partials.length, s = c, this._partials.length === 0) return [i, a]
            } else {
                const u = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(e);
                u ? (c = parseInt(u[2], 10) + 1, this._partialCount = parseInt(u[2], 10), e = u[1], c = Math.max(c, 2), s = c) : this._partialCount = 0, this._partials = []
            }
            for (let u = 1; u < s; ++u) {
                const h = 2 / (u * Math.PI);
                let d;
                switch (e) {
                    case "sine":
                        d = u <= c ? 1 : 0, this._partials[u - 1] = d;
                        break;
                    case "square":
                        d = u & 1 ? 2 * h : 0, this._partials[u - 1] = d;
                        break;
                    case "sawtooth":
                        d = h * (u & 1 ? 1 : -1), this._partials[u - 1] = d;
                        break;
                    case "triangle":
                        u & 1 ? d = 2 * (h * h) * (u - 1 >> 1 & 1 ? -1 : 1) : d = 0, this._partials[u - 1] = d;
                        break;
                    case "custom":
                        d = this._partials[u - 1];
                        break;
                    default:
                        throw new TypeError("Oscillator: invalid type: " + e)
                }
                d !== 0 ? (i[u] = -d * Math.sin(n * u), a[u] = d * Math.cos(n * u)) : (i[u] = 0, a[u] = 0)
            }
            return [i, a]
        }
        _inverseFFT(e, n, r) {
            let s = 0;
            const i = e.length;
            for (let a = 0; a < i; a++) s += e[a] * Math.cos(a * r) + n[a] * Math.sin(a * r);
            return s
        }
        getInitialValue() {
            const [e, n] = this._getRealImaginary(this._type, 0);
            let r = 0;
            const s = Math.PI * 2,
                i = 32;
            for (let a = 0; a < i; a++) r = Math.max(this._inverseFFT(e, n, a / i * s), r);
            return $ye(-this._inverseFFT(e, n, this._phase) / r, -1, 1)
        }
        get partials() {
            return this._partials.slice(0, this.partialCount)
        }
        set partials(e) {
            this._partials = e, this._partialCount = this._partials.length, e.length && (this.type = "custom")
        }
        get phase() {
            return this._phase * (180 / Math.PI)
        }
        set phase(e) {
            this._phase = e * Math.PI / 180, this.type = this._type
        }
        asArray(e = 1024) {
            return yn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this._oscillator !== null && this._oscillator.dispose(), this._wave = void 0, this.frequency.dispose(), this.detune.dispose(), this
        }
    }
    rn._periodicWaveCache = [];
    class Br extends Oe {
        constructor() {
            super(Object.assign(Y(Br.getDefaults(), arguments, ["context"])))
        }
        connect(e, n = 0, r = 0) {
            return xm(this, e, n, r), this
        }
    }
    class Cs extends Br {
        constructor() {
            super(Object.assign(Y(Cs.getDefaults(), arguments, ["mapping", "length"]))), this.name = "WaveShaper", this._shaper = this.context.createWaveShaper(), this.input = this._shaper, this.output = this._shaper;
            const e = Y(Cs.getDefaults(), arguments, ["mapping", "length"]);
            Fr(e.mapping) || e.mapping instanceof Float32Array ? this.curve = Float32Array.from(e.mapping) : Aye(e.mapping) && this.setMap(e.mapping, e.length)
        }
        static getDefaults() {
            return Object.assign(Ge.getDefaults(), {
                length: 1024
            })
        }
        setMap(e, n = 1024) {
            const r = new Float32Array(n);
            for (let s = 0, i = n; s < i; s++) {
                const a = s / (i - 1) * 2 - 1;
                r[s] = e(a, s)
            }
            return this.curve = r, this
        }
        get curve() {
            return this._shaper.curve
        }
        set curve(e) {
            this._shaper.curve = e
        }
        get oversample() {
            return this._shaper.oversample
        }
        set oversample(e) {
            const n = ["none", "2x", "4x"].some(r => r.includes(e));
            Ve(n, "oversampling must be either 'none', '2x', or '4x'"), this._shaper.oversample = e
        }
        dispose() {
            return super.dispose(), this._shaper.disconnect(), this
        }
    }
    class q0 extends Br {
        constructor() {
            super(...arguments), this.name = "AudioToGain", this._norm = new Cs({
                context: this.context,
                mapping: e => (e + 1) / 2
            }), this.input = this._norm, this.output = this._norm
        }
        dispose() {
            return super.dispose(), this._norm.dispose(), this
        }
    }
    class on extends Ge {
        constructor() {
            super(Object.assign(Y(on.getDefaults(), arguments, ["value"]))), this.name = "Multiply", this.override = !1;
            const e = Y(on.getDefaults(), arguments, ["value"]);
            this._mult = this.input = this.output = new Le({
                context: this.context,
                minValue: e.minValue,
                maxValue: e.maxValue
            }), this.factor = this._param = this._mult.gain, this.factor.setValueAtTime(e.value, 0)
        }
        static getDefaults() {
            return Object.assign(Ge.getDefaults(), {
                value: 0
            })
        }
        dispose() {
            return super.dispose(), this._mult.dispose(), this
        }
    }
    class ku extends An {
        constructor() {
            super(Y(ku.getDefaults(), arguments, ["frequency", "type", "modulationType"])), this.name = "AMOscillator", this._modulationScale = new q0({
                context: this.context
            }), this._modulationNode = new Le({
                context: this.context
            });
            const e = Y(ku.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
            this._carrier = new rn({
                context: this.context,
                detune: e.detune,
                frequency: e.frequency,
                onstop: () => this.onstop(this),
                phase: e.phase,
                type: e.type
            }), this.frequency = this._carrier.frequency, this.detune = this._carrier.detune, this._modulator = new rn({
                context: this.context,
                phase: e.phase,
                type: e.modulationType
            }), this.harmonicity = new on({
                context: this.context,
                units: "positive",
                value: e.harmonicity
            }), this.frequency.chain(this.harmonicity, this._modulator.frequency), this._modulator.chain(this._modulationScale, this._modulationNode.gain), this._carrier.chain(this._modulationNode, this.output), Fe(this, ["frequency", "detune", "harmonicity"])
        }
        static getDefaults() {
            return Object.assign(rn.getDefaults(), {
                harmonicity: 1,
                modulationType: "square"
            })
        }
        _start(e) {
            this._modulator.start(e), this._carrier.start(e)
        }
        _stop(e) {
            this._modulator.stop(e), this._carrier.stop(e)
        }
        _restart(e) {
            this._modulator.restart(e), this._carrier.restart(e)
        }
        get type() {
            return this._carrier.type
        }
        set type(e) {
            this._carrier.type = e
        }
        get baseType() {
            return this._carrier.baseType
        }
        set baseType(e) {
            this._carrier.baseType = e
        }
        get partialCount() {
            return this._carrier.partialCount
        }
        set partialCount(e) {
            this._carrier.partialCount = e
        }
        get modulationType() {
            return this._modulator.type
        }
        set modulationType(e) {
            this._modulator.type = e
        }
        get phase() {
            return this._carrier.phase
        }
        set phase(e) {
            this._carrier.phase = e, this._modulator.phase = e
        }
        get partials() {
            return this._carrier.partials
        }
        set partials(e) {
            this._carrier.partials = e
        }
        asArray(e = 1024) {
            return yn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this._modulationScale.dispose(), this
        }
    }
    class Vc extends An {
        constructor() {
            super(Y(Vc.getDefaults(), arguments, ["frequency", "type", "modulationType"])), this.name = "FMOscillator", this._modulationNode = new Le({
                context: this.context,
                gain: 0
            });
            const e = Y(Vc.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
            this._carrier = new rn({
                context: this.context,
                detune: e.detune,
                frequency: 0,
                onstop: () => this.onstop(this),
                phase: e.phase,
                type: e.type
            }), this.detune = this._carrier.detune, this.frequency = new Ge({
                context: this.context,
                units: "frequency",
                value: e.frequency
            }), this._modulator = new rn({
                context: this.context,
                phase: e.phase,
                type: e.modulationType
            }), this.harmonicity = new on({
                context: this.context,
                units: "positive",
                value: e.harmonicity
            }), this.modulationIndex = new on({
                context: this.context,
                units: "positive",
                value: e.modulationIndex
            }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.frequency.chain(this.modulationIndex, this._modulationNode), this._modulator.connect(this._modulationNode.gain), this._modulationNode.connect(this._carrier.frequency), this._carrier.connect(this.output), this.detune.connect(this._modulator.detune), Fe(this, ["modulationIndex", "frequency", "detune", "harmonicity"])
        }
        static getDefaults() {
            return Object.assign(rn.getDefaults(), {
                harmonicity: 1,
                modulationIndex: 2,
                modulationType: "square"
            })
        }
        _start(e) {
            this._modulator.start(e), this._carrier.start(e)
        }
        _stop(e) {
            this._modulator.stop(e), this._carrier.stop(e)
        }
        _restart(e) {
            return this._modulator.restart(e), this._carrier.restart(e), this
        }
        get type() {
            return this._carrier.type
        }
        set type(e) {
            this._carrier.type = e
        }
        get baseType() {
            return this._carrier.baseType
        }
        set baseType(e) {
            this._carrier.baseType = e
        }
        get partialCount() {
            return this._carrier.partialCount
        }
        set partialCount(e) {
            this._carrier.partialCount = e
        }
        get modulationType() {
            return this._modulator.type
        }
        set modulationType(e) {
            this._modulator.type = e
        }
        get phase() {
            return this._carrier.phase
        }
        set phase(e) {
            this._carrier.phase = e, this._modulator.phase = e
        }
        get partials() {
            return this._carrier.partials
        }
        set partials(e) {
            this._carrier.partials = e
        }
        asArray(e = 1024) {
            return yn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this.frequency.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this.modulationIndex.dispose(), this
        }
    }
    class Gc extends An {
        constructor() {
            super(Y(Gc.getDefaults(), arguments, ["frequency", "width"])), this.name = "PulseOscillator", this._widthGate = new Le({
                context: this.context,
                gain: 0
            }), this._thresh = new Cs({
                context: this.context,
                mapping: n => n <= 0 ? -1 : 1
            });
            const e = Y(Gc.getDefaults(), arguments, ["frequency", "width"]);
            this.width = new Ge({
                context: this.context,
                units: "audioRange",
                value: e.width
            }), this._triangle = new rn({
                context: this.context,
                detune: e.detune,
                frequency: e.frequency,
                onstop: () => this.onstop(this),
                phase: e.phase,
                type: "triangle"
            }), this.frequency = this._triangle.frequency, this.detune = this._triangle.detune, this._triangle.chain(this._thresh, this.output), this.width.chain(this._widthGate, this._thresh), Fe(this, ["width", "frequency", "detune"])
        }
        static getDefaults() {
            return Object.assign(An.getDefaults(), {
                detune: 0,
                frequency: 440,
                phase: 0,
                type: "pulse",
                width: .2
            })
        }
        _start(e) {
            e = this.toSeconds(e), this._triangle.start(e), this._widthGate.gain.setValueAtTime(1, e)
        }
        _stop(e) {
            e = this.toSeconds(e), this._triangle.stop(e), this._widthGate.gain.cancelScheduledValues(e), this._widthGate.gain.setValueAtTime(0, e)
        }
        _restart(e) {
            this._triangle.restart(e), this._widthGate.gain.cancelScheduledValues(e), this._widthGate.gain.setValueAtTime(1, e)
        }
        get phase() {
            return this._triangle.phase
        }
        set phase(e) {
            this._triangle.phase = e
        }
        get type() {
            return "pulse"
        }
        get baseType() {
            return "pulse"
        }
        get partials() {
            return []
        }
        get partialCount() {
            return 0
        }
        set carrierType(e) {
            this._triangle.type = e
        }
        asArray(e = 1024) {
            return yn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this._triangle.dispose(), this.width.dispose(), this._widthGate.dispose(), this._thresh.dispose(), this
        }
    }
    class Iu extends An {
        constructor() {
            super(Y(Iu.getDefaults(), arguments, ["frequency", "type", "spread"])), this.name = "FatOscillator", this._oscillators = [];
            const e = Y(Iu.getDefaults(), arguments, ["frequency", "type", "spread"]);
            this.frequency = new Ge({
                context: this.context,
                units: "frequency",
                value: e.frequency
            }), this.detune = new Ge({
                context: this.context,
                units: "cents",
                value: e.detune
            }), this._spread = e.spread, this._type = e.type, this._phase = e.phase, this._partials = e.partials, this._partialCount = e.partialCount, this.count = e.count, Fe(this, ["frequency", "detune"])
        }
        static getDefaults() {
            return Object.assign(rn.getDefaults(), {
                count: 3,
                spread: 20,
                type: "sawtooth"
            })
        }
        _start(e) {
            e = this.toSeconds(e), this._forEach(n => n.start(e))
        }
        _stop(e) {
            e = this.toSeconds(e), this._forEach(n => n.stop(e))
        }
        _restart(e) {
            this._forEach(n => n.restart(e))
        }
        _forEach(e) {
            for (let n = 0; n < this._oscillators.length; n++) e(this._oscillators[n], n)
        }
        get type() {
            return this._type
        }
        set type(e) {
            this._type = e, this._forEach(n => n.type = e)
        }
        get spread() {
            return this._spread
        }
        set spread(e) {
            if (this._spread = e, this._oscillators.length > 1) {
                const n = -e / 2,
                    r = e / (this._oscillators.length - 1);
                this._forEach((s, i) => s.detune.value = n + r * i)
            }
        }
        get count() {
            return this._oscillators.length
        }
        set count(e) {
            if (As(e, 1), this._oscillators.length !== e) {
                this._forEach(n => n.dispose()), this._oscillators = [];
                for (let n = 0; n < e; n++) {
                    const r = new rn({
                        context: this.context,
                        volume: -6 - e * 1.1,
                        type: this._type,
                        phase: this._phase + n / e * 360,
                        partialCount: this._partialCount,
                        onstop: n === 0 ? () => this.onstop(this) : ht
                    });
                    this.type === "custom" && (r.partials = this._partials), this.frequency.connect(r.frequency), this.detune.connect(r.detune), r.detune.overridden = !1, r.connect(this.output), this._oscillators[n] = r
                }
                this.spread = this._spread, this.state === "started" && this._forEach(n => n.start())
            }
        }
        get phase() {
            return this._phase
        }
        set phase(e) {
            this._phase = e, this._forEach((n, r) => n.phase = this._phase + r / this.count * 360)
        }
        get baseType() {
            return this._oscillators[0].baseType
        }
        set baseType(e) {
            this._forEach(n => n.baseType = e), this._type = this._oscillators[0].type
        }
        get partials() {
            return this._oscillators[0].partials
        }
        set partials(e) {
            this._partials = e, this._partialCount = this._partials.length, e.length && (this._type = "custom", this._forEach(n => n.partials = e))
        }
        get partialCount() {
            return this._oscillators[0].partialCount
        }
        set partialCount(e) {
            this._partialCount = e, this._forEach(n => n.partialCount = e), this._type = this._oscillators[0].type
        }
        asArray(e = 1024) {
            return yn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this._forEach(e => e.dispose()), this
        }
    }
    class Nu extends An {
        constructor() {
            super(Y(Nu.getDefaults(), arguments, ["frequency", "modulationFrequency"])), this.name = "PWMOscillator", this.sourceType = "pwm", this._scale = new on({
                context: this.context,
                value: 2
            });
            const e = Y(Nu.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
            this._pulse = new Gc({
                context: this.context,
                frequency: e.modulationFrequency
            }), this._pulse.carrierType = "sine", this.modulationFrequency = this._pulse.frequency, this._modulator = new rn({
                context: this.context,
                detune: e.detune,
                frequency: e.frequency,
                onstop: () => this.onstop(this),
                phase: e.phase
            }), this.frequency = this._modulator.frequency, this.detune = this._modulator.detune, this._modulator.chain(this._scale, this._pulse.width), this._pulse.connect(this.output), Fe(this, ["modulationFrequency", "frequency", "detune"])
        }
        static getDefaults() {
            return Object.assign(An.getDefaults(), {
                detune: 0,
                frequency: 440,
                modulationFrequency: .4,
                phase: 0,
                type: "pwm"
            })
        }
        _start(e) {
            e = this.toSeconds(e), this._modulator.start(e), this._pulse.start(e)
        }
        _stop(e) {
            e = this.toSeconds(e), this._modulator.stop(e), this._pulse.stop(e)
        }
        _restart(e) {
            this._modulator.restart(e), this._pulse.restart(e)
        }
        get type() {
            return "pwm"
        }
        get baseType() {
            return "pwm"
        }
        get partials() {
            return []
        }
        get partialCount() {
            return 0
        }
        get phase() {
            return this._modulator.phase
        }
        set phase(e) {
            this._modulator.phase = e
        }
        asArray(e = 1024) {
            return yn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this._pulse.dispose(), this._scale.dispose(), this._modulator.dispose(), this
        }
    }
    const j3 = {
        am: ku,
        fat: Iu,
        fm: Vc,
        oscillator: rn,
        pulse: Gc,
        pwm: Nu
    };
    class as extends An {
        constructor() {
            super(Y(as.getDefaults(), arguments, ["frequency", "type"])), this.name = "OmniOscillator";
            const e = Y(as.getDefaults(), arguments, ["frequency", "type"]);
            this.frequency = new Ge({
                context: this.context,
                units: "frequency",
                value: e.frequency
            }), this.detune = new Ge({
                context: this.context,
                units: "cents",
                value: e.detune
            }), Fe(this, ["frequency", "detune"]), this.set(e)
        }
        static getDefaults() {
            return Object.assign(rn.getDefaults(), Vc.getDefaults(), ku.getDefaults(), Iu.getDefaults(), Gc.getDefaults(), Nu.getDefaults())
        }
        _start(e) {
            this._oscillator.start(e)
        }
        _stop(e) {
            this._oscillator.stop(e)
        }
        _restart(e) {
            return this._oscillator.restart(e), this
        }
        get type() {
            let e = "";
            return ["am", "fm", "fat"].some(n => this._sourceType === n) && (e = this._sourceType), e + this._oscillator.type
        }
        set type(e) {
            e.substr(0, 2) === "fm" ? (this._createNewOscillator("fm"), this._oscillator = this._oscillator, this._oscillator.type = e.substr(2)) : e.substr(0, 2) === "am" ? (this._createNewOscillator("am"), this._oscillator = this._oscillator, this._oscillator.type = e.substr(2)) : e.substr(0, 3) === "fat" ? (this._createNewOscillator("fat"), this._oscillator = this._oscillator, this._oscillator.type = e.substr(3)) : e === "pwm" ? (this._createNewOscillator("pwm"), this._oscillator = this._oscillator) : e === "pulse" ? this._createNewOscillator("pulse") : (this._createNewOscillator("oscillator"), this._oscillator = this._oscillator, this._oscillator.type = e)
        }
        get partials() {
            return this._oscillator.partials
        }
        set partials(e) {
            !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partials = e)
        }
        get partialCount() {
            return this._oscillator.partialCount
        }
        set partialCount(e) {
            !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partialCount = e)
        }
        set(e) {
            return Reflect.has(e, "type") && e.type && (this.type = e.type), super.set(e), this
        }
        _createNewOscillator(e) {
            if (e !== this._sourceType) {
                this._sourceType = e;
                const n = j3[e],
                    r = this.now();
                if (this._oscillator) {
                    const s = this._oscillator;
                    s.stop(r), this.context.setTimeout(() => s.dispose(), this.blockTime)
                }
                this._oscillator = new n({
                    context: this.context
                }), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.connect(this.output), this._oscillator.onstop = () => this.onstop(this), this.state === "started" && this._oscillator.start(r)
            }
        }
        get phase() {
            return this._oscillator.phase
        }
        set phase(e) {
            this._oscillator.phase = e
        }
        get sourceType() {
            return this._sourceType
        }
        set sourceType(e) {
            let n = "sine";
            this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse" && (n = this._oscillator.type), e === "fm" ? this.type = "fm" + n : e === "am" ? this.type = "am" + n : e === "fat" ? this.type = "fat" + n : e === "oscillator" ? this.type = n : e === "pulse" ? this.type = "pulse" : e === "pwm" && (this.type = "pwm")
        }
        _getOscType(e, n) {
            return e instanceof j3[n]
        }
        get baseType() {
            return this._oscillator.baseType
        }
        set baseType(e) {
            !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && e !== "pulse" && e !== "pwm" && (this._oscillator.baseType = e)
        }
        get width() {
            if (this._getOscType(this._oscillator, "pulse")) return this._oscillator.width
        }
        get count() {
            if (this._getOscType(this._oscillator, "fat")) return this._oscillator.count
        }
        set count(e) {
            this._getOscType(this._oscillator, "fat") && Mi(e) && (this._oscillator.count = e)
        }
        get spread() {
            if (this._getOscType(this._oscillator, "fat")) return this._oscillator.spread
        }
        set spread(e) {
            this._getOscType(this._oscillator, "fat") && Mi(e) && (this._oscillator.spread = e)
        }
        get modulationType() {
            if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) return this._oscillator.modulationType
        }
        set modulationType(e) {
            (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && Xs(e) && (this._oscillator.modulationType = e)
        }
        get modulationIndex() {
            if (this._getOscType(this._oscillator, "fm")) return this._oscillator.modulationIndex
        }
        get harmonicity() {
            if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) return this._oscillator.harmonicity
        }
        get modulationFrequency() {
            if (this._getOscType(this._oscillator, "pwm")) return this._oscillator.modulationFrequency
        }
        asArray(e = 1024) {
            return yn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this.detune.dispose(), this.frequency.dispose(), this._oscillator.dispose(), this
        }
    }
    class yl extends Ge {
        constructor() {
            super(Object.assign(Y(yl.getDefaults(), arguments, ["value"]))), this.override = !1, this.name = "Add", this._sum = new Le({
                context: this.context
            }), this.input = this._sum, this.output = this._sum, this.addend = this._param, is(this._constantSource, this._sum)
        }
        static getDefaults() {
            return Object.assign(Ge.getDefaults(), {
                value: 0
            })
        }
        dispose() {
            return super.dispose(), this._sum.dispose(), this
        }
    }
    class Di extends Br {
        constructor() {
            super(Object.assign(Y(Di.getDefaults(), arguments, ["min", "max"]))), this.name = "Scale";
            const e = Y(Di.getDefaults(), arguments, ["min", "max"]);
            this._mult = this.input = new on({
                context: this.context,
                value: e.max - e.min
            }), this._add = this.output = new yl({
                context: this.context,
                value: e.min
            }), this._min = e.min, this._max = e.max, this.input.connect(this.output)
        }
        static getDefaults() {
            return Object.assign(Br.getDefaults(), {
                max: 1,
                min: 0
            })
        }
        get min() {
            return this._min
        }
        set min(e) {
            this._min = e, this._setRange()
        }
        get max() {
            return this._max
        }
        set max(e) {
            this._max = e, this._setRange()
        }
        _setRange() {
            this._add.value = this._min, this._mult.value = this._max - this._min
        }
        dispose() {
            return super.dispose(), this._add.dispose(), this._mult.dispose(), this
        }
    }
    class j0 extends Br {
        constructor() {
            super(Object.assign(Y(j0.getDefaults(), arguments))), this.name = "Zero", this._gain = new Le({
                context: this.context
            }), this.output = this._gain, this.input = void 0, os(this.context.getConstant(0), this._gain)
        }
        dispose() {
            return super.dispose(), Kk(this.context.getConstant(0), this._gain), this
        }
    }
    class dr extends Oe {
        constructor() {
            super(Y(dr.getDefaults(), arguments, ["frequency", "min", "max"])), this.name = "LFO", this._stoppedValue = 0, this._units = "number", this.convert = !0, this._fromType = it.prototype._fromType, this._toType = it.prototype._toType, this._is = it.prototype._is, this._clampValue = it.prototype._clampValue;
            const e = Y(dr.getDefaults(), arguments, ["frequency", "min", "max"]);
            this._oscillator = new rn(e), this.frequency = this._oscillator.frequency, this._amplitudeGain = new Le({
                context: this.context,
                gain: e.amplitude,
                units: "normalRange"
            }), this.amplitude = this._amplitudeGain.gain, this._stoppedSignal = new Ge({
                context: this.context,
                units: "audioRange",
                value: 0
            }), this._zeros = new j0({
                context: this.context
            }), this._a2g = new q0({
                context: this.context
            }), this._scaler = this.output = new Di({
                context: this.context,
                max: e.max,
                min: e.min
            }), this.units = e.units, this.min = e.min, this.max = e.max, this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler), this._zeros.connect(this._a2g), this._stoppedSignal.connect(this._a2g), Fe(this, ["amplitude", "frequency"]), this.phase = e.phase
        }
        static getDefaults() {
            return Object.assign(rn.getDefaults(), {
                amplitude: 1,
                frequency: "4n",
                max: 1,
                min: 0,
                type: "sine",
                units: "number"
            })
        }
        start(e) {
            return e = this.toSeconds(e), this._stoppedSignal.setValueAtTime(0, e), this._oscillator.start(e), this
        }
        stop(e) {
            return e = this.toSeconds(e), this._stoppedSignal.setValueAtTime(this._stoppedValue, e), this._oscillator.stop(e), this
        }
        sync() {
            return this._oscillator.sync(), this._oscillator.syncFrequency(), this
        }
        unsync() {
            return this._oscillator.unsync(), this._oscillator.unsyncFrequency(), this
        }
        _setStoppedValue() {
            this._stoppedValue = this._oscillator.getInitialValue(), this._stoppedSignal.value = this._stoppedValue
        }
        get min() {
            return this._toType(this._scaler.min)
        }
        set min(e) {
            e = this._fromType(e), this._scaler.min = e
        }
        get max() {
            return this._toType(this._scaler.max)
        }
        set max(e) {
            e = this._fromType(e), this._scaler.max = e
        }
        get type() {
            return this._oscillator.type
        }
        set type(e) {
            this._oscillator.type = e, this._setStoppedValue()
        }
        get partials() {
            return this._oscillator.partials
        }
        set partials(e) {
            this._oscillator.partials = e, this._setStoppedValue()
        }
        get phase() {
            return this._oscillator.phase
        }
        set phase(e) {
            this._oscillator.phase = e, this._setStoppedValue()
        }
        get units() {
            return this._units
        }
        set units(e) {
            const n = this.min,
                r = this.max;
            this._units = e, this.min = n, this.max = r
        }
        get state() {
            return this._oscillator.state
        }
        connect(e, n, r) {
            return (e instanceof it || e instanceof Ge) && (this.convert = e.convert, this.units = e.units), xm(this, e, n, r), this
        }
        dispose() {
            return super.dispose(), this._oscillator.dispose(), this._stoppedSignal.dispose(), this._zeros.dispose(), this._scaler.dispose(), this._a2g.dispose(), this._amplitudeGain.dispose(), this.amplitude.dispose(), this
        }
    }

    function Yk(t, e = 1 / 0) {
        const n = new WeakMap;
        return function(r, s) {
            Reflect.defineProperty(r, s, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    return n.get(this)
                },
                set: function(i) {
                    As(i, t, e), n.set(this, i)
                }
            })
        }
    }

    function ji(t, e = 1 / 0) {
        const n = new WeakMap;
        return function(r, s) {
            Reflect.defineProperty(r, s, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    return n.get(this)
                },
                set: function(i) {
                    As(this.toSeconds(i), t, e), n.set(this, i)
                }
            })
        }
    }
    class ko extends An {
        constructor() {
            super(Y(ko.getDefaults(), arguments, ["url", "onload"])), this.name = "Player", this._activeSources = new Set;
            const e = Y(ko.getDefaults(), arguments, ["url", "onload"]);
            this._buffer = new Ot({
                onload: this._onload.bind(this, e.onload),
                onerror: e.onerror,
                reverse: e.reverse,
                url: e.url
            }), this.autostart = e.autostart, this._loop = e.loop, this._loopStart = e.loopStart, this._loopEnd = e.loopEnd, this._playbackRate = e.playbackRate, this.fadeIn = e.fadeIn, this.fadeOut = e.fadeOut
        }
        static getDefaults() {
            return Object.assign(An.getDefaults(), {
                autostart: !1,
                fadeIn: 0,
                fadeOut: 0,
                loop: !1,
                loopEnd: 0,
                loopStart: 0,
                onload: ht,
                onerror: ht,
                playbackRate: 1,
                reverse: !1
            })
        }
        load(e) {
            return yn(this, void 0, void 0, function*() {
                return yield this._buffer.load(e), this._onload(), this
            })
        }
        _onload(e = ht) {
            e(), this.autostart && this.start()
        }
        _onSourceEnd(e) {
            this.onstop(this), this._activeSources.delete(e), this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started" && (this._state.cancel(this.now()), this._state.setStateAtTime("stopped", this.now()))
        }
        start(e, n, r) {
            return super.start(e, n, r), this
        }
        _start(e, n, r) {
            this._loop ? n = kc(n, this._loopStart) : n = kc(n, 0);
            const s = this.toSeconds(n),
                i = r;
            r = kc(r, Math.max(this._buffer.duration - s, 0));
            let a = this.toSeconds(r);
            a = a / this._playbackRate, e = this.toSeconds(e);
            const c = new Qs({
                url: this._buffer,
                context: this.context,
                fadeIn: this.fadeIn,
                fadeOut: this.fadeOut,
                loop: this._loop,
                loopEnd: this._loopEnd,
                loopStart: this._loopStart,
                onended: this._onSourceEnd.bind(this),
                playbackRate: this._playbackRate
            }).connect(this.output);
            !this._loop && !this._synced && (this._state.cancel(e + a), this._state.setStateAtTime("stopped", e + a, {
                implicitEnd: !0
            })), this._activeSources.add(c), this._loop && rs(i) ? c.start(e, s) : c.start(e, s, a - this.toSeconds(this.fadeOut))
        }
        _stop(e) {
            const n = this.toSeconds(e);
            this._activeSources.forEach(r => r.stop(n))
        }
        restart(e, n, r) {
            return super.restart(e, n, r), this
        }
        _restart(e, n, r) {
            this._stop(e), this._start(e, n, r)
        }
        seek(e, n) {
            const r = this.toSeconds(n);
            if (this._state.getValueAtTime(r) === "started") {
                const s = this.toSeconds(e);
                this._stop(r), this._start(r, s)
            }
            return this
        }
        setLoopPoints(e, n) {
            return this.loopStart = e, this.loopEnd = n, this
        }
        get loopStart() {
            return this._loopStart
        }
        set loopStart(e) {
            this._loopStart = e, this.buffer.loaded && As(this.toSeconds(e), 0, this.buffer.duration), this._activeSources.forEach(n => {
                n.loopStart = e
            })
        }
        get loopEnd() {
            return this._loopEnd
        }
        set loopEnd(e) {
            this._loopEnd = e, this.buffer.loaded && As(this.toSeconds(e), 0, this.buffer.duration), this._activeSources.forEach(n => {
                n.loopEnd = e
            })
        }
        get buffer() {
            return this._buffer
        }
        set buffer(e) {
            this._buffer.set(e)
        }
        get loop() {
            return this._loop
        }
        set loop(e) {
            if (this._loop !== e && (this._loop = e, this._activeSources.forEach(n => {
                    n.loop = e
                }), e)) {
                const n = this._state.getNextState("stopped", this.now());
                n && this._state.cancel(n.time)
            }
        }
        get playbackRate() {
            return this._playbackRate
        }
        set playbackRate(e) {
            this._playbackRate = e;
            const n = this.now(),
                r = this._state.getNextState("stopped", n);
            r && r.implicitEnd && (this._state.cancel(r.time), this._activeSources.forEach(s => s.cancelStop())), this._activeSources.forEach(s => {
                s.playbackRate.setValueAtTime(e, n)
            })
        }
        get reverse() {
            return this._buffer.reverse
        }
        set reverse(e) {
            this._buffer.reverse = e
        }
        get loaded() {
            return this._buffer.loaded
        }
        dispose() {
            return super.dispose(), this._activeSources.forEach(e => e.dispose()), this._activeSources.clear(), this._buffer.dispose(), this
        }
    }
    $s([ji(0)], ko.prototype, "fadeIn", void 0);
    $s([ji(0)], ko.prototype, "fadeOut", void 0);
    class Yd extends Oe {
        constructor() {
            super(Y(Yd.getDefaults(), arguments, ["urls", "onload"], "urls")), this.name = "Players", this.input = void 0, this._players = new Map;
            const e = Y(Yd.getDefaults(), arguments, ["urls", "onload"], "urls");
            this._volume = this.output = new Js({
                context: this.context,
                volume: e.volume
            }), this.volume = this._volume.volume, Fe(this, "volume"), this._buffers = new vh({
                urls: e.urls,
                onload: e.onload,
                baseUrl: e.baseUrl,
                onerror: e.onerror
            }), this.mute = e.mute, this._fadeIn = e.fadeIn, this._fadeOut = e.fadeOut
        }
        static getDefaults() {
            return Object.assign(An.getDefaults(), {
                baseUrl: "",
                fadeIn: 0,
                fadeOut: 0,
                mute: !1,
                onload: ht,
                onerror: ht,
                urls: {},
                volume: 0
            })
        }
        get mute() {
            return this._volume.mute
        }
        set mute(e) {
            this._volume.mute = e
        }
        get fadeIn() {
            return this._fadeIn
        }
        set fadeIn(e) {
            this._fadeIn = e, this._players.forEach(n => {
                n.fadeIn = e
            })
        }
        get fadeOut() {
            return this._fadeOut
        }
        set fadeOut(e) {
            this._fadeOut = e, this._players.forEach(n => {
                n.fadeOut = e
            })
        }
        get state() {
            return Array.from(this._players).some(([n, r]) => r.state === "started") ? "started" : "stopped"
        }
        has(e) {
            return this._buffers.has(e)
        }
        player(e) {
            if (Ve(this.has(e), `No Player with the name ${e} exists on this object`), !this._players.has(e)) {
                const n = new ko({
                    context: this.context,
                    fadeIn: this._fadeIn,
                    fadeOut: this._fadeOut,
                    url: this._buffers.get(e)
                }).connect(this.output);
                this._players.set(e, n)
            }
            return this._players.get(e)
        }
        get loaded() {
            return this._buffers.loaded
        }
        add(e, n, r) {
            return Ve(!this._buffers.has(e), "A buffer with that name already exists on this object"), this._buffers.add(e, n, r), this
        }
        stopAll(e) {
            return this._players.forEach(n => n.stop(e)), this
        }
        dispose() {
            return super.dispose(), this._volume.dispose(), this.volume.dispose(), this._players.forEach(e => e.dispose()), this._buffers.dispose(), this
        }
    }
    class zye extends Br {
        constructor() {
            super(...arguments), this.name = "Abs", this._abs = new Cs({
                context: this.context,
                mapping: e => Math.abs(e) < .001 ? 0 : Math.abs(e)
            }), this.input = this._abs, this.output = this._abs
        }
        dispose() {
            return super.dispose(), this._abs.dispose(), this
        }
    }
    class Zye extends Br {
        constructor() {
            super(...arguments), this.name = "GainToAudio", this._norm = new Cs({
                context: this.context,
                mapping: e => Math.abs(e) * 2 - 1
            }), this.input = this._norm, this.output = this._norm
        }
        dispose() {
            return super.dispose(), this._norm.dispose(), this
        }
    }
    class zk extends Br {
        constructor() {
            super(...arguments), this.name = "Negate", this._multiply = new on({
                context: this.context,
                value: -1
            }), this.input = this._multiply, this.output = this._multiply
        }
        dispose() {
            return super.dispose(), this._multiply.dispose(), this
        }
    }
    class vl extends Ge {
        constructor() {
            super(Object.assign(Y(vl.getDefaults(), arguments, ["value"]))), this.override = !1, this.name = "Subtract", this._sum = new Le({
                context: this.context
            }), this.input = this._sum, this.output = this._sum, this._neg = new zk({
                context: this.context
            }), this.subtrahend = this._param, is(this._constantSource, this._neg, this._sum)
        }
        static getDefaults() {
            return Object.assign(Ge.getDefaults(), {
                value: 0
            })
        }
        dispose() {
            return super.dispose(), this._neg.dispose(), this._sum.dispose(), this
        }
    }
    class V0 extends Br {
        constructor() {
            super(Object.assign(Y(V0.getDefaults(), arguments))), this.name = "GreaterThanZero", this._thresh = this.output = new Cs({
                context: this.context,
                length: 127,
                mapping: e => e <= 0 ? 0 : 1
            }), this._scale = this.input = new on({
                context: this.context,
                value: 1e4
            }), this._scale.connect(this._thresh)
        }
        dispose() {
            return super.dispose(), this._scale.dispose(), this._thresh.dispose(), this
        }
    }
    class zd extends Ge {
        constructor() {
            super(Object.assign(Y(zd.getDefaults(), arguments, ["value"]))), this.name = "GreaterThan", this.override = !1;
            const e = Y(zd.getDefaults(), arguments, ["value"]);
            this._subtract = this.input = new vl({
                context: this.context,
                value: e.value
            }), this._gtz = this.output = new V0({
                context: this.context
            }), this.comparator = this._param = this._subtract.subtrahend, Fe(this, "comparator"), this._subtract.connect(this._gtz)
        }
        static getDefaults() {
            return Object.assign(Ge.getDefaults(), {
                value: 0
            })
        }
        dispose() {
            return super.dispose(), this._gtz.dispose(), this._subtract.dispose(), this.comparator.dispose(), this
        }
    }
    class xu extends Br {
        constructor() {
            super(Object.assign(Y(xu.getDefaults(), arguments, ["value"]))), this.name = "Pow";
            const e = Y(xu.getDefaults(), arguments, ["value"]);
            this._exponentScaler = this.input = this.output = new Cs({
                context: this.context,
                mapping: this._expFunc(e.value),
                length: 8192
            }), this._exponent = e.value
        }
        static getDefaults() {
            return Object.assign(Br.getDefaults(), {
                value: 1
            })
        }
        _expFunc(e) {
            return n => Math.pow(Math.abs(n), e)
        }
        get value() {
            return this._exponent
        }
        set value(e) {
            this._exponent = e, this._exponentScaler.setMap(this._expFunc(this._exponent))
        }
        dispose() {
            return super.dispose(), this._exponentScaler.dispose(), this
        }
    }
    class Zd extends Di {
        constructor() {
            super(Object.assign(Y(Zd.getDefaults(), arguments, ["min", "max", "exponent"]))), this.name = "ScaleExp";
            const e = Y(Zd.getDefaults(), arguments, ["min", "max", "exponent"]);
            this.input = this._exp = new xu({
                context: this.context,
                value: e.exponent
            }), this._exp.connect(this._mult)
        }
        static getDefaults() {
            return Object.assign(Di.getDefaults(), {
                exponent: 1
            })
        }
        get exponent() {
            return this._exp.value
        }
        set exponent(e) {
            this._exp.value = e
        }
        dispose() {
            return super.dispose(), this._exp.dispose(), this
        }
    }
    class Yn extends Oe {
        constructor() {
            super(Y(Yn.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "Envelope", this._sig = new Ge({
                context: this.context,
                value: 0
            }), this.output = this._sig, this.input = void 0;
            const e = Y(Yn.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
            this.attack = e.attack, this.decay = e.decay, this.sustain = e.sustain, this.release = e.release, this.attackCurve = e.attackCurve, this.releaseCurve = e.releaseCurve, this.decayCurve = e.decayCurve
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                attack: .01,
                attackCurve: "linear",
                decay: .1,
                decayCurve: "exponential",
                release: 1,
                releaseCurve: "exponential",
                sustain: .5
            })
        }
        get value() {
            return this.getValueAtTime(this.now())
        }
        _getCurve(e, n) {
            if (Xs(e)) return e; {
                let r;
                for (r in qf)
                    if (qf[r][n] === e) return r;
                return e
            }
        }
        _setCurve(e, n, r) {
            if (Xs(r) && Reflect.has(qf, r)) {
                const s = qf[r];
                va(s) ? e !== "_decayCurve" && (this[e] = s[n]) : this[e] = s
            } else if (Fr(r) && e !== "_decayCurve") this[e] = r;
            else throw new Error("Envelope: invalid curve: " + r)
        }
        get attackCurve() {
            return this._getCurve(this._attackCurve, "In")
        }
        set attackCurve(e) {
            this._setCurve("_attackCurve", "In", e)
        }
        get releaseCurve() {
            return this._getCurve(this._releaseCurve, "Out")
        }
        set releaseCurve(e) {
            this._setCurve("_releaseCurve", "Out", e)
        }
        get decayCurve() {
            return this._decayCurve
        }
        set decayCurve(e) {
            Ve(["linear", "exponential"].some(n => n === e), `Invalid envelope curve: ${e}`), this._decayCurve = e
        }
        triggerAttack(e, n = 1) {
            this.log("triggerAttack", e, n), e = this.toSeconds(e);
            let s = this.toSeconds(this.attack);
            const i = this.toSeconds(this.decay),
                a = this.getValueAtTime(e);
            if (a > 0) {
                const c = 1 / s;
                s = (1 - a) / c
            }
            if (s < this.sampleTime) this._sig.cancelScheduledValues(e), this._sig.setValueAtTime(n, e);
            else if (this._attackCurve === "linear") this._sig.linearRampTo(n, s, e);
            else if (this._attackCurve === "exponential") this._sig.targetRampTo(n, s, e);
            else {
                this._sig.cancelAndHoldAtTime(e);
                let c = this._attackCurve;
                for (let u = 1; u < c.length; u++)
                    if (c[u - 1] <= a && a <= c[u]) {
                        c = this._attackCurve.slice(u), c[0] = a;
                        break
                    } this._sig.setValueCurveAtTime(c, e, s, n)
            }
            if (i && this.sustain < 1) {
                const c = n * this.sustain,
                    u = e + s;
                this.log("decay", u), this._decayCurve === "linear" ? this._sig.linearRampToValueAtTime(c, i + u) : this._sig.exponentialApproachValueAtTime(c, u, i)
            }
            return this
        }
        triggerRelease(e) {
            this.log("triggerRelease", e), e = this.toSeconds(e);
            const n = this.getValueAtTime(e);
            if (n > 0) {
                const r = this.toSeconds(this.release);
                r < this.sampleTime ? this._sig.setValueAtTime(0, e) : this._releaseCurve === "linear" ? this._sig.linearRampTo(0, r, e) : this._releaseCurve === "exponential" ? this._sig.targetRampTo(0, r, e) : (Ve(Fr(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array"), this._sig.cancelAndHoldAtTime(e), this._sig.setValueCurveAtTime(this._releaseCurve, e, r, n))
            }
            return this
        }
        getValueAtTime(e) {
            return this._sig.getValueAtTime(e)
        }
        triggerAttackRelease(e, n, r = 1) {
            return n = this.toSeconds(n), this.triggerAttack(n, r), this.triggerRelease(n + this.toSeconds(e)), this
        }
        cancel(e) {
            return this._sig.cancelScheduledValues(this.toSeconds(e)), this
        }
        connect(e, n = 0, r = 0) {
            return xm(this, e, n, r), this
        }
        asArray(e = 1024) {
            return yn(this, void 0, void 0, function*() {
                const n = e / this.context.sampleRate,
                    r = new km(1, n, this.context.sampleRate),
                    s = this.toSeconds(this.attack) + this.toSeconds(this.decay),
                    i = s + this.toSeconds(this.release),
                    a = i * .1,
                    c = i + a,
                    u = new this.constructor(Object.assign(this.get(), {
                        attack: n * this.toSeconds(this.attack) / c,
                        decay: n * this.toSeconds(this.decay) / c,
                        release: n * this.toSeconds(this.release) / c,
                        context: r
                    }));
                return u._sig.toDestination(), u.triggerAttackRelease(n * (s + a) / c, 0), (yield r.render()).getChannelData(0)
            })
        }
        dispose() {
            return super.dispose(), this._sig.dispose(), this
        }
    }
    $s([ji(0)], Yn.prototype, "attack", void 0);
    $s([ji(0)], Yn.prototype, "decay", void 0);
    $s([Yk(0, 1)], Yn.prototype, "sustain", void 0);
    $s([ji(0)], Yn.prototype, "release", void 0);
    const qf = (() => {
        let e, n;
        const r = [];
        for (e = 0; e < 128; e++) r[e] = Math.sin(e / (128 - 1) * (Math.PI / 2));
        const s = [],
            i = 6.4;
        for (e = 0; e < 128 - 1; e++) {
            n = e / (128 - 1);
            const m = Math.sin(n * (Math.PI * 2) * i - Math.PI / 2) + 1;
            s[e] = m / 10 + n * .83
        }
        s[128 - 1] = 1;
        const a = [],
            c = 5;
        for (e = 0; e < 128; e++) a[e] = Math.ceil(e / (128 - 1) * c) / c;
        const u = [];
        for (e = 0; e < 128; e++) n = e / (128 - 1), u[e] = .5 * (1 - Math.cos(Math.PI * n));
        const h = [];
        for (e = 0; e < 128; e++) {
            n = e / (128 - 1);
            const m = Math.pow(n, 3) * 4 + .2,
                _ = Math.cos(m * Math.PI * 2 * n);
            h[e] = Math.abs(_ * (1 - n))
        }

        function d(m) {
            const _ = new Array(m.length);
            for (let y = 0; y < m.length; y++) _[y] = 1 - m[y];
            return _
        }

        function p(m) {
            return m.slice(0).reverse()
        }
        return {
            bounce: {
                In: d(h),
                Out: h
            },
            cosine: {
                In: r,
                Out: p(r)
            },
            exponential: "exponential",
            linear: "linear",
            ripple: {
                In: s,
                Out: d(s)
            },
            sine: {
                In: u,
                Out: d(u)
            },
            step: {
                In: a,
                Out: d(a)
            }
        }
    })();
    let ei = class my extends Oe {
        constructor() {
            super(Y(my.getDefaults(), arguments)), this._scheduledEvents = [], this._synced = !1, this._original_triggerAttack = this.triggerAttack, this._original_triggerRelease = this.triggerRelease;
            const e = Y(my.getDefaults(), arguments);
            this._volume = this.output = new Js({
                context: this.context,
                volume: e.volume
            }), this.volume = this._volume.volume, Fe(this, "volume")
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                volume: 0
            })
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 0)), this
        }
        _syncState() {
            let e = !1;
            return this._synced || (this._synced = !0, e = !0), e
        }
        _syncMethod(e, n) {
            const r = this["_original_" + e] = this[e];
            this[e] = (...s) => {
                const i = s[n],
                    a = this.context.transport.schedule(c => {
                        s[n] = c, r.apply(this, s)
                    }, i);
                this._scheduledEvents.push(a)
            }
        }
        unsync() {
            return this._scheduledEvents.forEach(e => this.context.transport.clear(e)), this._scheduledEvents = [], this._synced && (this._synced = !1, this.triggerAttack = this._original_triggerAttack, this.triggerRelease = this._original_triggerRelease), this
        }
        triggerAttackRelease(e, n, r, s) {
            const i = this.toSeconds(r),
                a = this.toSeconds(n);
            return this.triggerAttack(e, i, s), this.triggerRelease(i + a), this
        }
        dispose() {
            return super.dispose(), this._volume.dispose(), this.unsync(), this._scheduledEvents = [], this
        }
    };
    class Hn extends ei {
        constructor() {
            super(Y(Hn.getDefaults(), arguments));
            const e = Y(Hn.getDefaults(), arguments);
            this.portamento = e.portamento, this.onsilence = e.onsilence
        }
        static getDefaults() {
            return Object.assign(ei.getDefaults(), {
                detune: 0,
                onsilence: ht,
                portamento: 0
            })
        }
        triggerAttack(e, n, r = 1) {
            this.log("triggerAttack", e, n, r);
            const s = this.toSeconds(n);
            return this._triggerEnvelopeAttack(s, r), this.setNote(e, s), this
        }
        triggerRelease(e) {
            this.log("triggerRelease", e);
            const n = this.toSeconds(e);
            return this._triggerEnvelopeRelease(n), this
        }
        setNote(e, n) {
            const r = this.toSeconds(n),
                s = e instanceof Wn ? e.toFrequency() : e;
            if (this.portamento > 0 && this.getLevelAtTime(r) > .05) {
                const i = this.toSeconds(this.portamento);
                this.frequency.exponentialRampTo(s, i, r)
            } else this.frequency.setValueAtTime(s, r);
            return this
        }
    }
    $s([ji(0)], Hn.prototype, "portamento", void 0);
    class bh extends Yn {
        constructor() {
            super(Y(bh.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "AmplitudeEnvelope", this._gainNode = new Le({
                context: this.context,
                gain: 0
            }), this.output = this._gainNode, this.input = this._gainNode, this._sig.connect(this._gainNode.gain), this.output = this._gainNode, this.input = this._gainNode
        }
        dispose() {
            return super.dispose(), this._gainNode.dispose(), this
        }
    }
    class ti extends Hn {
        constructor() {
            super(Y(ti.getDefaults(), arguments)), this.name = "Synth";
            const e = Y(ti.getDefaults(), arguments);
            this.oscillator = new as(Object.assign({
                context: this.context,
                detune: e.detune,
                onstop: () => this.onsilence(this)
            }, e.oscillator)), this.frequency = this.oscillator.frequency, this.detune = this.oscillator.detune, this.envelope = new bh(Object.assign({
                context: this.context
            }, e.envelope)), this.oscillator.chain(this.envelope, this.output), Fe(this, ["oscillator", "frequency", "detune", "envelope"])
        }
        static getDefaults() {
            return Object.assign(Hn.getDefaults(), {
                envelope: Object.assign(tr(Yn.getDefaults(), Object.keys(Oe.getDefaults())), {
                    attack: .005,
                    decay: .1,
                    release: 1,
                    sustain: .3
                }),
                oscillator: Object.assign(tr(as.getDefaults(), [...Object.keys(An.getDefaults()), "frequency", "detune"]), {
                    type: "triangle"
                })
            })
        }
        _triggerEnvelopeAttack(e, n) {
            if (this.envelope.triggerAttack(e, n), this.oscillator.start(e), this.envelope.sustain === 0) {
                const r = this.toSeconds(this.envelope.attack),
                    s = this.toSeconds(this.envelope.decay);
                this.oscillator.stop(e + r + s)
            }
        }
        _triggerEnvelopeRelease(e) {
            this.envelope.triggerRelease(e), this.oscillator.stop(e + this.toSeconds(this.envelope.release))
        }
        getLevelAtTime(e) {
            return e = this.toSeconds(e), this.envelope.getValueAtTime(e)
        }
        dispose() {
            return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this
        }
    }
    class Wc extends Hn {
        constructor() {
            super(Y(Wc.getDefaults(), arguments)), this.name = "ModulationSynth";
            const e = Y(Wc.getDefaults(), arguments);
            this._carrier = new ti({
                context: this.context,
                oscillator: e.oscillator,
                envelope: e.envelope,
                onsilence: () => this.onsilence(this),
                volume: -10
            }), this._modulator = new ti({
                context: this.context,
                oscillator: e.modulation,
                envelope: e.modulationEnvelope,
                volume: -10
            }), this.oscillator = this._carrier.oscillator, this.envelope = this._carrier.envelope, this.modulation = this._modulator.oscillator, this.modulationEnvelope = this._modulator.envelope, this.frequency = new Ge({
                context: this.context,
                units: "frequency"
            }), this.detune = new Ge({
                context: this.context,
                value: e.detune,
                units: "cents"
            }), this.harmonicity = new on({
                context: this.context,
                value: e.harmonicity,
                minValue: 0
            }), this._modulationNode = new Le({
                context: this.context,
                gain: 0
            }), Fe(this, ["frequency", "harmonicity", "oscillator", "envelope", "modulation", "modulationEnvelope", "detune"])
        }
        static getDefaults() {
            return Object.assign(Hn.getDefaults(), {
                harmonicity: 3,
                oscillator: Object.assign(tr(as.getDefaults(), [...Object.keys(An.getDefaults()), "frequency", "detune"]), {
                    type: "sine"
                }),
                envelope: Object.assign(tr(Yn.getDefaults(), Object.keys(Oe.getDefaults())), {
                    attack: .01,
                    decay: .01,
                    sustain: 1,
                    release: .5
                }),
                modulation: Object.assign(tr(as.getDefaults(), [...Object.keys(An.getDefaults()), "frequency", "detune"]), {
                    type: "square"
                }),
                modulationEnvelope: Object.assign(tr(Yn.getDefaults(), Object.keys(Oe.getDefaults())), {
                    attack: .5,
                    decay: 0,
                    sustain: 1,
                    release: .5
                })
            })
        }
        _triggerEnvelopeAttack(e, n) {
            this._carrier._triggerEnvelopeAttack(e, n), this._modulator._triggerEnvelopeAttack(e, n)
        }
        _triggerEnvelopeRelease(e) {
            return this._carrier._triggerEnvelopeRelease(e), this._modulator._triggerEnvelopeRelease(e), this
        }
        getLevelAtTime(e) {
            return e = this.toSeconds(e), this.envelope.getValueAtTime(e)
        }
        dispose() {
            return super.dispose(), this._carrier.dispose(), this._modulator.dispose(), this.frequency.dispose(), this.detune.dispose(), this.harmonicity.dispose(), this._modulationNode.dispose(), this
        }
    }
    class Pm extends Wc {
        constructor() {
            super(Y(Pm.getDefaults(), arguments)), this.name = "AMSynth", this._modulationScale = new q0({
                context: this.context
            }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.detune.fan(this._carrier.detune, this._modulator.detune), this._modulator.chain(this._modulationScale, this._modulationNode.gain), this._carrier.chain(this._modulationNode, this.output)
        }
        dispose() {
            return super.dispose(), this._modulationScale.dispose(), this
        }
    }
    class Pu extends Oe {
        constructor() {
            super(Y(Pu.getDefaults(), arguments, ["frequency", "type"])), this.name = "BiquadFilter";
            const e = Y(Pu.getDefaults(), arguments, ["frequency", "type"]);
            this._filter = this.context.createBiquadFilter(), this.input = this.output = this._filter, this.Q = new it({
                context: this.context,
                units: "number",
                value: e.Q,
                param: this._filter.Q
            }), this.frequency = new it({
                context: this.context,
                units: "frequency",
                value: e.frequency,
                param: this._filter.frequency
            }), this.detune = new it({
                context: this.context,
                units: "cents",
                value: e.detune,
                param: this._filter.detune
            }), this.gain = new it({
                context: this.context,
                units: "decibels",
                convert: !1,
                value: e.gain,
                param: this._filter.gain
            }), this.type = e.type
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                Q: 1,
                type: "lowpass",
                frequency: 350,
                detune: 0,
                gain: 0
            })
        }
        get type() {
            return this._filter.type
        }
        set type(e) {
            Ve(["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass", "peaking"].indexOf(e) !== -1, `Invalid filter type: ${e}`), this._filter.type = e
        }
        getFrequencyResponse(e = 128) {
            const n = new Float32Array(e);
            for (let a = 0; a < e; a++) {
                const u = Math.pow(a / e, 2) * (2e4 - 20) + 20;
                n[a] = u
            }
            const r = new Float32Array(e),
                s = new Float32Array(e),
                i = this.context.createBiquadFilter();
            return i.type = this.type, i.Q.value = this.Q.value, i.frequency.value = this.frequency.value, i.gain.value = this.gain.value, i.getFrequencyResponse(n, r, s), r
        }
        dispose() {
            return super.dispose(), this._filter.disconnect(), this.Q.dispose(), this.frequency.dispose(), this.gain.dispose(), this.detune.dispose(), this
        }
    }
    class wr extends Oe {
        constructor() {
            super(Y(wr.getDefaults(), arguments, ["frequency", "type", "rolloff"])), this.name = "Filter", this.input = new Le({
                context: this.context
            }), this.output = new Le({
                context: this.context
            }), this._filters = [];
            const e = Y(wr.getDefaults(), arguments, ["frequency", "type", "rolloff"]);
            this._filters = [], this.Q = new Ge({
                context: this.context,
                units: "positive",
                value: e.Q
            }), this.frequency = new Ge({
                context: this.context,
                units: "frequency",
                value: e.frequency
            }), this.detune = new Ge({
                context: this.context,
                units: "cents",
                value: e.detune
            }), this.gain = new Ge({
                context: this.context,
                units: "decibels",
                convert: !1,
                value: e.gain
            }), this._type = e.type, this.rolloff = e.rolloff, Fe(this, ["detune", "frequency", "gain", "Q"])
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                Q: 1,
                detune: 0,
                frequency: 350,
                gain: 0,
                rolloff: -12,
                type: "lowpass"
            })
        }
        get type() {
            return this._type
        }
        set type(e) {
            Ve(["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass", "peaking"].indexOf(e) !== -1, `Invalid filter type: ${e}`), this._type = e, this._filters.forEach(r => r.type = e)
        }
        get rolloff() {
            return this._rolloff
        }
        set rolloff(e) {
            const n = Mi(e) ? e : parseInt(e, 10),
                r = [-12, -24, -48, -96];
            let s = r.indexOf(n);
            Ve(s !== -1, `rolloff can only be ${r.join(", ")}`), s += 1, this._rolloff = n, this.input.disconnect(), this._filters.forEach(i => i.disconnect()), this._filters = new Array(s);
            for (let i = 0; i < s; i++) {
                const a = new Pu({
                    context: this.context
                });
                a.type = this._type, this.frequency.connect(a.frequency), this.detune.connect(a.detune), this.Q.connect(a.Q), this.gain.connect(a.gain), this._filters[i] = a
            }
            this._internalChannels = this._filters, is(this.input, ...this._internalChannels, this.output)
        }
        getFrequencyResponse(e = 128) {
            const n = new Pu({
                    frequency: this.frequency.value,
                    gain: this.gain.value,
                    Q: this.Q.value,
                    type: this._type,
                    detune: this.detune.value
                }),
                r = new Float32Array(e).map(() => 1);
            return this._filters.forEach(() => {
                n.getFrequencyResponse(e).forEach((i, a) => r[a] *= i)
            }), n.dispose(), r
        }
        dispose() {
            return super.dispose(), this._filters.forEach(e => {
                e.dispose()
            }), yh(this, ["detune", "frequency", "gain", "Q"]), this.frequency.dispose(), this.Q.dispose(), this.detune.dispose(), this.gain.dispose(), this
        }
    }
    class Ru extends Yn {
        constructor() {
            super(Y(Ru.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "FrequencyEnvelope";
            const e = Y(Ru.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
            this._octaves = e.octaves, this._baseFrequency = this.toFrequency(e.baseFrequency), this._exponent = this.input = new xu({
                context: this.context,
                value: e.exponent
            }), this._scale = this.output = new Di({
                context: this.context,
                min: this._baseFrequency,
                max: this._baseFrequency * Math.pow(2, this._octaves)
            }), this._sig.chain(this._exponent, this._scale)
        }
        static getDefaults() {
            return Object.assign(Yn.getDefaults(), {
                baseFrequency: 200,
                exponent: 1,
                octaves: 4
            })
        }
        get baseFrequency() {
            return this._baseFrequency
        }
        set baseFrequency(e) {
            const n = this.toFrequency(e);
            As(n, 0), this._baseFrequency = n, this._scale.min = this._baseFrequency, this.octaves = this._octaves
        }
        get octaves() {
            return this._octaves
        }
        set octaves(e) {
            this._octaves = e, this._scale.max = this._baseFrequency * Math.pow(2, e)
        }
        get exponent() {
            return this._exponent.value
        }
        set exponent(e) {
            this._exponent.value = e
        }
        dispose() {
            return super.dispose(), this._exponent.dispose(), this._scale.dispose(), this
        }
    }
    class ki extends Hn {
        constructor() {
            super(Y(ki.getDefaults(), arguments)), this.name = "MonoSynth";
            const e = Y(ki.getDefaults(), arguments);
            this.oscillator = new as(Object.assign(e.oscillator, {
                context: this.context,
                detune: e.detune,
                onstop: () => this.onsilence(this)
            })), this.frequency = this.oscillator.frequency, this.detune = this.oscillator.detune, this.filter = new wr(Object.assign(e.filter, {
                context: this.context
            })), this.filterEnvelope = new Ru(Object.assign(e.filterEnvelope, {
                context: this.context
            })), this.envelope = new bh(Object.assign(e.envelope, {
                context: this.context
            })), this.oscillator.chain(this.filter, this.envelope, this.output), this.filterEnvelope.connect(this.filter.frequency), Fe(this, ["oscillator", "frequency", "detune", "filter", "filterEnvelope", "envelope"])
        }
        static getDefaults() {
            return Object.assign(Hn.getDefaults(), {
                envelope: Object.assign(tr(Yn.getDefaults(), Object.keys(Oe.getDefaults())), {
                    attack: .005,
                    decay: .1,
                    release: 1,
                    sustain: .9
                }),
                filter: Object.assign(tr(wr.getDefaults(), Object.keys(Oe.getDefaults())), {
                    Q: 1,
                    rolloff: -12,
                    type: "lowpass"
                }),
                filterEnvelope: Object.assign(tr(Ru.getDefaults(), Object.keys(Oe.getDefaults())), {
                    attack: .6,
                    baseFrequency: 200,
                    decay: .2,
                    exponent: 2,
                    octaves: 3,
                    release: 2,
                    sustain: .5
                }),
                oscillator: Object.assign(tr(as.getDefaults(), Object.keys(An.getDefaults())), {
                    type: "sawtooth"
                })
            })
        }
        _triggerEnvelopeAttack(e, n = 1) {
            if (this.envelope.triggerAttack(e, n), this.filterEnvelope.triggerAttack(e), this.oscillator.start(e), this.envelope.sustain === 0) {
                const r = this.toSeconds(this.envelope.attack),
                    s = this.toSeconds(this.envelope.decay);
                this.oscillator.stop(e + r + s)
            }
        }
        _triggerEnvelopeRelease(e) {
            this.envelope.triggerRelease(e), this.filterEnvelope.triggerRelease(e), this.oscillator.stop(e + this.toSeconds(this.envelope.release))
        }
        getLevelAtTime(e) {
            return e = this.toSeconds(e), this.envelope.getValueAtTime(e)
        }
        dispose() {
            return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this.filterEnvelope.dispose(), this.filter.dispose(), this
        }
    }
    class Xd extends Hn {
        constructor() {
            super(Y(Xd.getDefaults(), arguments)), this.name = "DuoSynth";
            const e = Y(Xd.getDefaults(), arguments);
            this.voice0 = new ki(Object.assign(e.voice0, {
                context: this.context,
                onsilence: () => this.onsilence(this)
            })), this.voice1 = new ki(Object.assign(e.voice1, {
                context: this.context
            })), this.harmonicity = new on({
                context: this.context,
                units: "positive",
                value: e.harmonicity
            }), this._vibrato = new dr({
                frequency: e.vibratoRate,
                context: this.context,
                min: -50,
                max: 50
            }), this._vibrato.start(), this.vibratoRate = this._vibrato.frequency, this._vibratoGain = new Le({
                context: this.context,
                units: "normalRange",
                gain: e.vibratoAmount
            }), this.vibratoAmount = this._vibratoGain.gain, this.frequency = new Ge({
                context: this.context,
                units: "frequency",
                value: 440
            }), this.detune = new Ge({
                context: this.context,
                units: "cents",
                value: e.detune
            }), this.frequency.connect(this.voice0.frequency), this.frequency.chain(this.harmonicity, this.voice1.frequency), this._vibrato.connect(this._vibratoGain), this._vibratoGain.fan(this.voice0.detune, this.voice1.detune), this.detune.fan(this.voice0.detune, this.voice1.detune), this.voice0.connect(this.output), this.voice1.connect(this.output), Fe(this, ["voice0", "voice1", "frequency", "vibratoAmount", "vibratoRate"])
        }
        getLevelAtTime(e) {
            return e = this.toSeconds(e), this.voice0.envelope.getValueAtTime(e) + this.voice1.envelope.getValueAtTime(e)
        }
        static getDefaults() {
            return ss(Hn.getDefaults(), {
                vibratoAmount: .5,
                vibratoRate: 5,
                harmonicity: 1.5,
                voice0: ss(tr(ki.getDefaults(), Object.keys(Hn.getDefaults())), {
                    filterEnvelope: {
                        attack: .01,
                        decay: 0,
                        sustain: 1,
                        release: .5
                    },
                    envelope: {
                        attack: .01,
                        decay: 0,
                        sustain: 1,
                        release: .5
                    }
                }),
                voice1: ss(tr(ki.getDefaults(), Object.keys(Hn.getDefaults())), {
                    filterEnvelope: {
                        attack: .01,
                        decay: 0,
                        sustain: 1,
                        release: .5
                    },
                    envelope: {
                        attack: .01,
                        decay: 0,
                        sustain: 1,
                        release: .5
                    }
                })
            })
        }
        _triggerEnvelopeAttack(e, n) {
            this.voice0._triggerEnvelopeAttack(e, n), this.voice1._triggerEnvelopeAttack(e, n)
        }
        _triggerEnvelopeRelease(e) {
            return this.voice0._triggerEnvelopeRelease(e), this.voice1._triggerEnvelopeRelease(e), this
        }
        dispose() {
            return super.dispose(), this.voice0.dispose(), this.voice1.dispose(), this.frequency.dispose(), this.detune.dispose(), this._vibrato.dispose(), this.vibratoRate.dispose(), this._vibratoGain.dispose(), this.harmonicity.dispose(), this
        }
    }
    class Mu extends Wc {
        constructor() {
            super(Y(Mu.getDefaults(), arguments)), this.name = "FMSynth";
            const e = Y(Mu.getDefaults(), arguments);
            this.modulationIndex = new on({
                context: this.context,
                value: e.modulationIndex
            }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.frequency.chain(this.modulationIndex, this._modulationNode), this.detune.fan(this._carrier.detune, this._modulator.detune), this._modulator.connect(this._modulationNode.gain), this._modulationNode.connect(this._carrier.frequency), this._carrier.connect(this.output)
        }
        static getDefaults() {
            return Object.assign(Wc.getDefaults(), {
                modulationIndex: 10
            })
        }
        dispose() {
            return super.dispose(), this.modulationIndex.dispose(), this
        }
    }
    const V3 = [1, 1.483, 1.932, 2.546, 2.63, 3.897];
    class Jd extends Hn {
        constructor() {
            super(Y(Jd.getDefaults(), arguments)), this.name = "MetalSynth", this._oscillators = [], this._freqMultipliers = [];
            const e = Y(Jd.getDefaults(), arguments);
            this.detune = new Ge({
                context: this.context,
                units: "cents",
                value: e.detune
            }), this.frequency = new Ge({
                context: this.context,
                units: "frequency"
            }), this._amplitude = new Le({
                context: this.context,
                gain: 0
            }).connect(this.output), this._highpass = new wr({
                Q: 0,
                context: this.context,
                type: "highpass"
            }).connect(this._amplitude);
            for (let n = 0; n < V3.length; n++) {
                const r = new Vc({
                    context: this.context,
                    harmonicity: e.harmonicity,
                    modulationIndex: e.modulationIndex,
                    modulationType: "square",
                    onstop: n === 0 ? () => this.onsilence(this) : ht,
                    type: "square"
                });
                r.connect(this._highpass), this._oscillators[n] = r;
                const s = new on({
                    context: this.context,
                    value: V3[n]
                });
                this._freqMultipliers[n] = s, this.frequency.chain(s, r.frequency), this.detune.connect(r.detune)
            }
            this._filterFreqScaler = new Di({
                context: this.context,
                max: 7e3,
                min: this.toFrequency(e.resonance)
            }), this.envelope = new Yn({
                attack: e.envelope.attack,
                attackCurve: "linear",
                context: this.context,
                decay: e.envelope.decay,
                release: e.envelope.release,
                sustain: 0
            }), this.envelope.chain(this._filterFreqScaler, this._highpass.frequency), this.envelope.connect(this._amplitude.gain), this._octaves = e.octaves, this.octaves = e.octaves
        }
        static getDefaults() {
            return ss(Hn.getDefaults(), {
                envelope: Object.assign(tr(Yn.getDefaults(), Object.keys(Oe.getDefaults())), {
                    attack: .001,
                    decay: 1.4,
                    release: .2
                }),
                harmonicity: 5.1,
                modulationIndex: 32,
                octaves: 1.5,
                resonance: 4e3
            })
        }
        _triggerEnvelopeAttack(e, n = 1) {
            return this.envelope.triggerAttack(e, n), this._oscillators.forEach(r => r.start(e)), this.envelope.sustain === 0 && this._oscillators.forEach(r => {
                r.stop(e + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay))
            }), this
        }
        _triggerEnvelopeRelease(e) {
            return this.envelope.triggerRelease(e), this._oscillators.forEach(n => n.stop(e + this.toSeconds(this.envelope.release))), this
        }
        getLevelAtTime(e) {
            return e = this.toSeconds(e), this.envelope.getValueAtTime(e)
        }
        get modulationIndex() {
            return this._oscillators[0].modulationIndex.value
        }
        set modulationIndex(e) {
            this._oscillators.forEach(n => n.modulationIndex.value = e)
        }
        get harmonicity() {
            return this._oscillators[0].harmonicity.value
        }
        set harmonicity(e) {
            this._oscillators.forEach(n => n.harmonicity.value = e)
        }
        get resonance() {
            return this._filterFreqScaler.min
        }
        set resonance(e) {
            this._filterFreqScaler.min = this.toFrequency(e), this.octaves = this._octaves
        }
        get octaves() {
            return this._octaves
        }
        set octaves(e) {
            this._octaves = e, this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, e)
        }
        dispose() {
            return super.dispose(), this._oscillators.forEach(e => e.dispose()), this._freqMultipliers.forEach(e => e.dispose()), this.frequency.dispose(), this.detune.dispose(), this._filterFreqScaler.dispose(), this._amplitude.dispose(), this.envelope.dispose(), this._highpass.dispose(), this
        }
    }
    class Hc extends ti {
        constructor() {
            super(Y(Hc.getDefaults(), arguments)), this.name = "MembraneSynth", this.portamento = 0;
            const e = Y(Hc.getDefaults(), arguments);
            this.pitchDecay = e.pitchDecay, this.octaves = e.octaves, Fe(this, ["oscillator", "envelope"])
        }
        static getDefaults() {
            return ss(Hn.getDefaults(), ti.getDefaults(), {
                envelope: {
                    attack: .001,
                    attackCurve: "exponential",
                    decay: .4,
                    release: 1.4,
                    sustain: .01
                },
                octaves: 10,
                oscillator: {
                    type: "sine"
                },
                pitchDecay: .05
            })
        }
        setNote(e, n) {
            const r = this.toSeconds(n),
                s = this.toFrequency(e instanceof Wn ? e.toFrequency() : e),
                i = s * this.octaves;
            return this.oscillator.frequency.setValueAtTime(i, r), this.oscillator.frequency.exponentialRampToValueAtTime(s, r + this.toSeconds(this.pitchDecay)), this
        }
        dispose() {
            return super.dispose(), this
        }
    }
    $s([Yk(0)], Hc.prototype, "octaves", void 0);
    $s([ji(0)], Hc.prototype, "pitchDecay", void 0);
    class Qd extends ei {
        constructor() {
            super(Y(Qd.getDefaults(), arguments)), this.name = "NoiseSynth";
            const e = Y(Qd.getDefaults(), arguments);
            this.noise = new Co(Object.assign({
                context: this.context
            }, e.noise)), this.envelope = new bh(Object.assign({
                context: this.context
            }, e.envelope)), this.noise.chain(this.envelope, this.output)
        }
        static getDefaults() {
            return Object.assign(ei.getDefaults(), {
                envelope: Object.assign(tr(Yn.getDefaults(), Object.keys(Oe.getDefaults())), {
                    decay: .1,
                    sustain: 0
                }),
                noise: Object.assign(tr(Co.getDefaults(), Object.keys(An.getDefaults())), {
                    type: "white"
                })
            })
        }
        triggerAttack(e, n = 1) {
            return e = this.toSeconds(e), this.envelope.triggerAttack(e, n), this.noise.start(e), this.envelope.sustain === 0 && this.noise.stop(e + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay)), this
        }
        triggerRelease(e) {
            return e = this.toSeconds(e), this.envelope.triggerRelease(e), this.noise.stop(e + this.toSeconds(this.envelope.release)), this
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 0), this._syncMethod("triggerRelease", 0)), this
        }
        triggerAttackRelease(e, n, r = 1) {
            return n = this.toSeconds(n), e = this.toSeconds(e), this.triggerAttack(n, r), this.triggerRelease(n + e), this
        }
        dispose() {
            return super.dispose(), this.noise.dispose(), this.envelope.dispose(), this
        }
    }
    const G0 = new Set;

    function W0(t) {
        G0.add(t)
    }

    function Zk(t, e) {
        const n = `registerProcessor("${t}", ${e})`;
        G0.add(n)
    }

    function Xye() {
        return Array.from(G0).join(`
`)
    }
    class gy extends Oe {
        constructor(e) {
            super(e), this.name = "ToneAudioWorklet", this.workletOptions = {}, this.onprocessorerror = ht;
            const n = URL.createObjectURL(new Blob([Xye()], {
                    type: "text/javascript"
                })),
                r = this._audioWorkletName();
            this._dummyGain = this.context.createGain(), this._dummyParam = this._dummyGain.gain, this.context.addAudioWorkletModule(n, r).then(() => {
                this.disposed || (this._worklet = this.context.createAudioWorkletNode(r, this.workletOptions), this._worklet.onprocessorerror = this.onprocessorerror.bind(this), this.onReady(this._worklet))
            })
        }
        dispose() {
            return super.dispose(), this._dummyGain.disconnect(), this._worklet && (this._worklet.port.postMessage("dispose"), this._worklet.disconnect()), this
        }
    }
    const Jye = `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`;
    W0(Jye);
    const Qye = `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;
    W0(Qye);
    const eve = `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`;
    W0(eve);
    const Xk = "feedback-comb-filter",
        tve = `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`;
    Zk(Xk, tve);
    class Du extends gy {
        constructor() {
            super(Y(Du.getDefaults(), arguments, ["delayTime", "resonance"])), this.name = "FeedbackCombFilter";
            const e = Y(Du.getDefaults(), arguments, ["delayTime", "resonance"]);
            this.input = new Le({
                context: this.context
            }), this.output = new Le({
                context: this.context
            }), this.delayTime = new it({
                context: this.context,
                value: e.delayTime,
                units: "time",
                minValue: 0,
                maxValue: 1,
                param: this._dummyParam,
                swappable: !0
            }), this.resonance = new it({
                context: this.context,
                value: e.resonance,
                units: "normalRange",
                param: this._dummyParam,
                swappable: !0
            }), Fe(this, ["resonance", "delayTime"])
        }
        _audioWorkletName() {
            return Xk
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                delayTime: .1,
                resonance: .5
            })
        }
        onReady(e) {
            is(this.input, e, this.output);
            const n = e.parameters.get("delayTime");
            this.delayTime.setParam(n);
            const r = e.parameters.get("feedback");
            this.resonance.setParam(r)
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this.output.dispose(), this.delayTime.dispose(), this.resonance.dispose(), this
        }
    }
    class $u extends Oe {
        constructor() {
            super(Y($u.getDefaults(), arguments, ["frequency", "type"])), this.name = "OnePoleFilter";
            const e = Y($u.getDefaults(), arguments, ["frequency", "type"]);
            this._frequency = e.frequency, this._type = e.type, this.input = new Le({
                context: this.context
            }), this.output = new Le({
                context: this.context
            }), this._createFilter()
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                frequency: 880,
                type: "lowpass"
            })
        }
        _createFilter() {
            const e = this._filter,
                n = this.toFrequency(this._frequency),
                r = 1 / (2 * Math.PI * n);
            if (this._type === "lowpass") {
                const s = 1 / (r * this.context.sampleRate),
                    i = s - 1;
                this._filter = this.context.createIIRFilter([s, 0], [1, i])
            } else {
                const s = 1 / (r * this.context.sampleRate) - 1;
                this._filter = this.context.createIIRFilter([1, -1], [1, s])
            }
            this.input.chain(this._filter, this.output), e && this.context.setTimeout(() => {
                this.disposed || (this.input.disconnect(e), e.disconnect())
            }, this.blockTime)
        }
        get frequency() {
            return this._frequency
        }
        set frequency(e) {
            this._frequency = e, this._createFilter()
        }
        get type() {
            return this._type
        }
        set type(e) {
            this._type = e, this._createFilter()
        }
        getFrequencyResponse(e = 128) {
            const n = new Float32Array(e);
            for (let i = 0; i < e; i++) {
                const c = Math.pow(i / e, 2) * (2e4 - 20) + 20;
                n[i] = c
            }
            const r = new Float32Array(e),
                s = new Float32Array(e);
            return this._filter.getFrequencyResponse(n, r, s), r
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this.output.dispose(), this._filter.disconnect(), this
        }
    }
    class Lu extends Oe {
        constructor() {
            super(Y(Lu.getDefaults(), arguments, ["delayTime", "resonance", "dampening"])), this.name = "LowpassCombFilter";
            const e = Y(Lu.getDefaults(), arguments, ["delayTime", "resonance", "dampening"]);
            this._combFilter = this.output = new Du({
                context: this.context,
                delayTime: e.delayTime,
                resonance: e.resonance
            }), this.delayTime = this._combFilter.delayTime, this.resonance = this._combFilter.resonance, this._lowpass = this.input = new $u({
                context: this.context,
                frequency: e.dampening,
                type: "lowpass"
            }), this._lowpass.connect(this._combFilter)
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                dampening: 3e3,
                delayTime: .1,
                resonance: .5
            })
        }
        get dampening() {
            return this._lowpass.frequency
        }
        set dampening(e) {
            this._lowpass.frequency = e
        }
        dispose() {
            return super.dispose(), this._combFilter.dispose(), this._lowpass.dispose(), this
        }
    }
    class ep extends ei {
        constructor() {
            super(Y(ep.getDefaults(), arguments)), this.name = "PluckSynth";
            const e = Y(ep.getDefaults(), arguments);
            this._noise = new Co({
                context: this.context,
                type: "pink"
            }), this.attackNoise = e.attackNoise, this._lfcf = new Lu({
                context: this.context,
                dampening: e.dampening,
                resonance: e.resonance
            }), this.resonance = e.resonance, this.release = e.release, this._noise.connect(this._lfcf), this._lfcf.connect(this.output)
        }
        static getDefaults() {
            return ss(ei.getDefaults(), {
                attackNoise: 1,
                dampening: 4e3,
                resonance: .7,
                release: 1
            })
        }
        get dampening() {
            return this._lfcf.dampening
        }
        set dampening(e) {
            this._lfcf.dampening = e
        }
        triggerAttack(e, n) {
            const r = this.toFrequency(e);
            n = this.toSeconds(n);
            const s = 1 / r;
            return this._lfcf.delayTime.setValueAtTime(s, n), this._noise.start(n), this._noise.stop(n + s * this.attackNoise), this._lfcf.resonance.cancelScheduledValues(n), this._lfcf.resonance.setValueAtTime(this.resonance, n), this
        }
        triggerRelease(e) {
            return this._lfcf.resonance.linearRampTo(0, this.release, e), this
        }
        dispose() {
            return super.dispose(), this._noise.dispose(), this._lfcf.dispose(), this
        }
    }
    class da extends ei {
        constructor() {
            super(Y(da.getDefaults(), arguments, ["voice", "options"])), this.name = "PolySynth", this._availableVoices = [], this._activeVoices = [], this._voices = [], this._gcTimeout = -1, this._averageActiveVoices = 0;
            const e = Y(da.getDefaults(), arguments, ["voice", "options"]);
            Ve(!Mi(e.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
            const n = e.voice.getDefaults();
            this.options = Object.assign(n, e.options), this.voice = e.voice, this.maxPolyphony = e.maxPolyphony, this._dummyVoice = this._getNextAvailableVoice();
            const r = this._voices.indexOf(this._dummyVoice);
            this._voices.splice(r, 1), this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1)
        }
        static getDefaults() {
            return Object.assign(ei.getDefaults(), {
                maxPolyphony: 32,
                options: {},
                voice: ti
            })
        }
        get activeVoices() {
            return this._activeVoices.length
        }
        _makeVoiceAvailable(e) {
            this._availableVoices.push(e);
            const n = this._activeVoices.findIndex(r => r.voice === e);
            this._activeVoices.splice(n, 1)
        }
        _getNextAvailableVoice() {
            if (this._availableVoices.length) return this._availableVoices.shift();
            if (this._voices.length < this.maxPolyphony) {
                const e = new this.voice(Object.assign(this.options, {
                    context: this.context,
                    onsilence: this._makeVoiceAvailable.bind(this)
                }));
                return e.connect(this.output), this._voices.push(e), e
            } else D0("Max polyphony exceeded. Note dropped.")
        }
        _collectGarbage() {
            if (this._averageActiveVoices = Math.max(this._averageActiveVoices * .95, this.activeVoices), this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
                const e = this._availableVoices.shift(),
                    n = this._voices.indexOf(e);
                this._voices.splice(n, 1), this.context.isOffline || e.dispose()
            }
        }
        _triggerAttack(e, n, r) {
            e.forEach(s => {
                const i = new Hd(this.context, s).toMidi(),
                    a = this._getNextAvailableVoice();
                a && (a.triggerAttack(s, n, r), this._activeVoices.push({
                    midi: i,
                    voice: a,
                    released: !1
                }), this.log("triggerAttack", s, n))
            })
        }
        _triggerRelease(e, n) {
            e.forEach(r => {
                const s = new Hd(this.context, r).toMidi(),
                    i = this._activeVoices.find(({
                        midi: a,
                        released: c
                    }) => a === s && !c);
                i && (i.voice.triggerRelease(n), i.released = !0, this.log("triggerRelease", r, n))
            })
        }
        _scheduleEvent(e, n, r, s) {
            Ve(!this.disposed, "Synth was already disposed"), r <= this.now() ? e === "attack" ? this._triggerAttack(n, r, s) : this._triggerRelease(n, r) : this.context.setTimeout(() => {
                this._scheduleEvent(e, n, r, s)
            }, r - this.now())
        }
        triggerAttack(e, n, r) {
            Array.isArray(e) || (e = [e]);
            const s = this.toSeconds(n);
            return this._scheduleEvent("attack", e, s, r), this
        }
        triggerRelease(e, n) {
            Array.isArray(e) || (e = [e]);
            const r = this.toSeconds(n);
            return this._scheduleEvent("release", e, r), this
        }
        triggerAttackRelease(e, n, r, s) {
            const i = this.toSeconds(r);
            if (this.triggerAttack(e, i, s), Fr(n)) {
                Ve(Fr(e), "If the duration is an array, the notes must also be an array"), e = e;
                for (let a = 0; a < e.length; a++) {
                    const c = n[Math.min(a, n.length - 1)],
                        u = this.toSeconds(c);
                    Ve(u > 0, "The duration must be greater than 0"), this.triggerRelease(e[a], i + u)
                }
            } else {
                const a = this.toSeconds(n);
                Ve(a > 0, "The duration must be greater than 0"), this.triggerRelease(e, i + a)
            }
            return this
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
        }
        set(e) {
            const n = tr(e, ["onsilence", "context"]);
            return this.options = ss(this.options, n), this._voices.forEach(r => r.set(n)), this._dummyVoice.set(n), this
        }
        get() {
            return this._dummyVoice.get()
        }
        releaseAll(e) {
            const n = this.toSeconds(e);
            return this._activeVoices.forEach(({
                voice: r
            }) => {
                r.triggerRelease(n)
            }), this
        }
        dispose() {
            return super.dispose(), this._dummyVoice.dispose(), this._voices.forEach(e => e.dispose()), this._activeVoices = [], this._availableVoices = [], this.context.clearInterval(this._gcTimeout), this
        }
    }
    class Kc extends ei {
        constructor() {
            super(Y(Kc.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "Sampler", this._activeSources = new Map;
            const e = Y(Kc.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls"),
                n = {};
            Object.keys(e.urls).forEach(r => {
                const s = parseInt(r, 10);
                if (Ve(Bf(r) || Mi(s) && isFinite(s), `url key is neither a note or midi pitch: ${r}`), Bf(r)) {
                    const i = new Wn(this.context, r).toMidi();
                    n[i] = e.urls[r]
                } else Mi(s) && isFinite(s) && (n[s] = e.urls[s])
            }), this._buffers = new vh({
                urls: n,
                onload: e.onload,
                baseUrl: e.baseUrl,
                onerror: e.onerror
            }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this._buffers.loaded && Promise.resolve().then(e.onload)
        }
        static getDefaults() {
            return Object.assign(ei.getDefaults(), {
                attack: 0,
                baseUrl: "",
                curve: "exponential",
                onload: ht,
                onerror: ht,
                release: .1,
                urls: {}
            })
        }
        _findClosest(e) {
            let r = 0;
            for (; r < 96;) {
                if (this._buffers.has(e + r)) return -r;
                if (this._buffers.has(e - r)) return r;
                r++
            }
            throw new Error(`No available buffers for note: ${e}`)
        }
        triggerAttack(e, n, r = 1) {
            return this.log("triggerAttack", e, n, r), Array.isArray(e) || (e = [e]), e.forEach(s => {
                const i = Nm(new Wn(this.context, s).toFrequency()),
                    a = Math.round(i),
                    c = i - a,
                    u = this._findClosest(a),
                    h = a - u,
                    d = this._buffers.get(h),
                    p = Aa(u + c),
                    m = new Qs({
                        url: d,
                        context: this.context,
                        curve: this.curve,
                        fadeIn: this.attack,
                        fadeOut: this.release,
                        playbackRate: p
                    }).connect(this.output);
                m.start(n, 0, d.duration / p, r), Fr(this._activeSources.get(a)) || this._activeSources.set(a, []), this._activeSources.get(a).push(m), m.onended = () => {
                    if (this._activeSources && this._activeSources.has(a)) {
                        const _ = this._activeSources.get(a),
                            y = _.indexOf(m);
                        y !== -1 && _.splice(y, 1)
                    }
                }
            }), this
        }
        triggerRelease(e, n) {
            return this.log("triggerRelease", e, n), Array.isArray(e) || (e = [e]), e.forEach(r => {
                const s = new Wn(this.context, r).toMidi();
                if (this._activeSources.has(s) && this._activeSources.get(s).length) {
                    const i = this._activeSources.get(s);
                    n = this.toSeconds(n), i.forEach(a => {
                        a.stop(n)
                    }), this._activeSources.set(s, [])
                }
            }), this
        }
        releaseAll(e) {
            const n = this.toSeconds(e);
            return this._activeSources.forEach(r => {
                for (; r.length;) r.shift().stop(n)
            }), this
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
        }
        triggerAttackRelease(e, n, r, s = 1) {
            const i = this.toSeconds(r);
            return this.triggerAttack(e, i, s), Fr(n) ? (Ve(Fr(e), "notes must be an array when duration is array"), e.forEach((a, c) => {
                const u = n[Math.min(c, n.length - 1)];
                this.triggerRelease(a, i + this.toSeconds(u))
            })) : this.triggerRelease(e, i + this.toSeconds(n)), this
        }
        add(e, n, r) {
            if (Ve(Bf(e) || isFinite(e), `note must be a pitch or midi: ${e}`), Bf(e)) {
                const s = new Wn(this.context, e).toMidi();
                this._buffers.add(s, n, r)
            } else this._buffers.add(e, n, r);
            return this
        }
        get loaded() {
            return this._buffers.loaded
        }
        dispose() {
            return super.dispose(), this._buffers.dispose(), this._activeSources.forEach(e => {
                e.forEach(n => n.dispose())
            }), this._activeSources.clear(), this
        }
    }
    $s([ji(0)], Kc.prototype, "attack", void 0);
    $s([ji(0)], Kc.prototype, "release", void 0);
    class Yc extends Oe {
        constructor() {
            super(Object.assign(Y(Yc.getDefaults(), arguments, ["fade"]))), this.name = "CrossFade", this._panner = this.context.createStereoPanner(), this._split = this.context.createChannelSplitter(2), this._g2a = new Zye({
                context: this.context
            }), this.a = new Le({
                context: this.context,
                gain: 0
            }), this.b = new Le({
                context: this.context,
                gain: 0
            }), this.output = new Le({
                context: this.context
            }), this._internalChannels = [this.a, this.b];
            const e = Y(Yc.getDefaults(), arguments, ["fade"]);
            this.fade = new Ge({
                context: this.context,
                units: "normalRange",
                value: e.fade
            }), Fe(this, "fade"), this.context.getConstant(1).connect(this._panner), this._panner.connect(this._split), this._panner.channelCount = 1, this._panner.channelCountMode = "explicit", os(this._split, this.a.gain, 0), os(this._split, this.b.gain, 1), this.fade.chain(this._g2a, this._panner.pan), this.a.connect(this.output), this.b.connect(this.output)
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                fade: .5
            })
        }
        dispose() {
            return super.dispose(), this.a.dispose(), this.b.dispose(), this.output.dispose(), this.fade.dispose(), this._g2a.dispose(), this._panner.disconnect(), this._split.disconnect(), this
        }
    }
    class Rn extends Oe {
        constructor(e) {
            super(e), this.name = "Effect", this._dryWet = new Yc({
                context: this.context
            }), this.wet = this._dryWet.fade, this.effectSend = new Le({
                context: this.context
            }), this.effectReturn = new Le({
                context: this.context
            }), this.input = new Le({
                context: this.context
            }), this.output = this._dryWet, this.input.fan(this._dryWet.a, this.effectSend), this.effectReturn.connect(this._dryWet.b), this.wet.setValueAtTime(e.wet, 0), this._internalChannels = [this.effectReturn, this.effectSend], Fe(this, "wet")
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                wet: 1
            })
        }
        connectEffect(e) {
            return this._internalChannels.push(e), this.effectSend.chain(e, this.effectReturn), this
        }
        dispose() {
            return super.dispose(), this._dryWet.dispose(), this.effectSend.dispose(), this.effectReturn.dispose(), this.wet.dispose(), this
        }
    }
    class tp extends Rn {
        constructor(e) {
            super(e), this.name = "LFOEffect", this._lfo = new dr({
                context: this.context,
                frequency: e.frequency,
                amplitude: e.depth
            }), this.depth = this._lfo.amplitude, this.frequency = this._lfo.frequency, this.type = e.type, Fe(this, ["frequency", "depth"])
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                frequency: 1,
                type: "sine",
                depth: 1
            })
        }
        start(e) {
            return this._lfo.start(e), this
        }
        stop(e) {
            return this._lfo.stop(e), this
        }
        sync() {
            return this._lfo.sync(), this
        }
        unsync() {
            return this._lfo.unsync(), this
        }
        get type() {
            return this._lfo.type
        }
        set type(e) {
            this._lfo.type = e
        }
        dispose() {
            return super.dispose(), this._lfo.dispose(), this.frequency.dispose(), this.depth.dispose(), this
        }
    }
    class Fu extends tp {
        constructor() {
            super(Y(Fu.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"])), this.name = "AutoFilter";
            const e = Y(Fu.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"]);
            this.filter = new wr(Object.assign(e.filter, {
                context: this.context
            })), this.connectEffect(this.filter), this._lfo.connect(this.filter.frequency), this.octaves = e.octaves, this.baseFrequency = e.baseFrequency
        }
        static getDefaults() {
            return Object.assign(tp.getDefaults(), {
                baseFrequency: 200,
                octaves: 2.6,
                filter: {
                    type: "lowpass",
                    rolloff: -12,
                    Q: 1
                }
            })
        }
        get baseFrequency() {
            return this._lfo.min
        }
        set baseFrequency(e) {
            this._lfo.min = this.toFrequency(e), this.octaves = this._octaves
        }
        get octaves() {
            return this._octaves
        }
        set octaves(e) {
            this._octaves = e, this._lfo.max = this._lfo.min * Math.pow(2, e)
        }
        dispose() {
            return super.dispose(), this.filter.dispose(), this
        }
    }
    class zc extends Oe {
        constructor() {
            super(Object.assign(Y(zc.getDefaults(), arguments, ["pan"]))), this.name = "Panner", this._panner = this.context.createStereoPanner(), this.input = this._panner, this.output = this._panner;
            const e = Y(zc.getDefaults(), arguments, ["pan"]);
            this.pan = new it({
                context: this.context,
                param: this._panner.pan,
                value: e.pan,
                minValue: -1,
                maxValue: 1
            }), this._panner.channelCount = e.channelCount, this._panner.channelCountMode = "explicit", Fe(this, "pan")
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                pan: 0,
                channelCount: 1
            })
        }
        dispose() {
            return super.dispose(), this._panner.disconnect(), this.pan.dispose(), this
        }
    }
    class Uu extends tp {
        constructor() {
            super(Y(Uu.getDefaults(), arguments, ["frequency"])), this.name = "AutoPanner";
            const e = Y(Uu.getDefaults(), arguments, ["frequency"]);
            this._panner = new zc({
                context: this.context,
                channelCount: e.channelCount
            }), this.connectEffect(this._panner), this._lfo.connect(this._panner.pan), this._lfo.min = -1, this._lfo.max = 1
        }
        static getDefaults() {
            return Object.assign(tp.getDefaults(), {
                channelCount: 1
            })
        }
        dispose() {
            return super.dispose(), this._panner.dispose(), this
        }
    }
    class Bu extends Oe {
        constructor() {
            super(Y(Bu.getDefaults(), arguments, ["smoothing"])), this.name = "Follower";
            const e = Y(Bu.getDefaults(), arguments, ["smoothing"]);
            this._abs = this.input = new zye({
                context: this.context
            }), this._lowpass = this.output = new $u({
                context: this.context,
                frequency: 1 / this.toSeconds(e.smoothing),
                type: "lowpass"
            }), this._abs.connect(this._lowpass), this._smoothing = e.smoothing
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                smoothing: .05
            })
        }
        get smoothing() {
            return this._smoothing
        }
        set smoothing(e) {
            this._smoothing = e, this._lowpass.frequency = 1 / this.toSeconds(this.smoothing)
        }
        dispose() {
            return super.dispose(), this._abs.dispose(), this._lowpass.dispose(), this
        }
    }
    class np extends Rn {
        constructor() {
            super(Y(np.getDefaults(), arguments, ["baseFrequency", "octaves", "sensitivity"])), this.name = "AutoWah";
            const e = Y(np.getDefaults(), arguments, ["baseFrequency", "octaves", "sensitivity"]);
            this._follower = new Bu({
                context: this.context,
                smoothing: e.follower
            }), this._sweepRange = new Zd({
                context: this.context,
                min: 0,
                max: 1,
                exponent: .5
            }), this._baseFrequency = this.toFrequency(e.baseFrequency), this._octaves = e.octaves, this._inputBoost = new Le({
                context: this.context
            }), this._bandpass = new wr({
                context: this.context,
                rolloff: -48,
                frequency: 0,
                Q: e.Q
            }), this._peaking = new wr({
                context: this.context,
                type: "peaking"
            }), this._peaking.gain.value = e.gain, this.gain = this._peaking.gain, this.Q = this._bandpass.Q, this.effectSend.chain(this._inputBoost, this._follower, this._sweepRange), this._sweepRange.connect(this._bandpass.frequency), this._sweepRange.connect(this._peaking.frequency), this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn), this._setSweepRange(), this.sensitivity = e.sensitivity, Fe(this, ["gain", "Q"])
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                baseFrequency: 100,
                octaves: 6,
                sensitivity: 0,
                Q: 2,
                gain: 2,
                follower: .2
            })
        }
        get octaves() {
            return this._octaves
        }
        set octaves(e) {
            this._octaves = e, this._setSweepRange()
        }
        get follower() {
            return this._follower.smoothing
        }
        set follower(e) {
            this._follower.smoothing = e
        }
        get baseFrequency() {
            return this._baseFrequency
        }
        set baseFrequency(e) {
            this._baseFrequency = this.toFrequency(e), this._setSweepRange()
        }
        get sensitivity() {
            return L0(1 / this._inputBoost.gain.value)
        }
        set sensitivity(e) {
            this._inputBoost.gain.value = 1 / Bd(e)
        }
        _setSweepRange() {
            this._sweepRange.min = this._baseFrequency, this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2)
        }
        dispose() {
            return super.dispose(), this._follower.dispose(), this._sweepRange.dispose(), this._bandpass.dispose(), this._peaking.dispose(), this._inputBoost.dispose(), this
        }
    }
    const Jk = "bit-crusher",
        nve = `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;
    Zk(Jk, nve);
    class rp extends Rn {
        constructor() {
            super(Y(rp.getDefaults(), arguments, ["bits"])), this.name = "BitCrusher";
            const e = Y(rp.getDefaults(), arguments, ["bits"]);
            this._bitCrusherWorklet = new sp({
                context: this.context,
                bits: e.bits
            }), this.connectEffect(this._bitCrusherWorklet), this.bits = this._bitCrusherWorklet.bits
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                bits: 4
            })
        }
        dispose() {
            return super.dispose(), this._bitCrusherWorklet.dispose(), this
        }
    }
    class sp extends gy {
        constructor() {
            super(Y(sp.getDefaults(), arguments)), this.name = "BitCrusherWorklet";
            const e = Y(sp.getDefaults(), arguments);
            this.input = new Le({
                context: this.context
            }), this.output = new Le({
                context: this.context
            }), this.bits = new it({
                context: this.context,
                value: e.bits,
                units: "positive",
                minValue: 1,
                maxValue: 16,
                param: this._dummyParam,
                swappable: !0
            })
        }
        static getDefaults() {
            return Object.assign(gy.getDefaults(), {
                bits: 12
            })
        }
        _audioWorkletName() {
            return Jk
        }
        onReady(e) {
            is(this.input, e, this.output);
            const n = e.parameters.get("bits");
            this.bits.setParam(n)
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this.output.dispose(), this.bits.dispose(), this
        }
    }
    class ip extends Rn {
        constructor() {
            super(Y(ip.getDefaults(), arguments, ["order"])), this.name = "Chebyshev";
            const e = Y(ip.getDefaults(), arguments, ["order"]);
            this._shaper = new Cs({
                context: this.context,
                length: 4096
            }), this._order = e.order, this.connectEffect(this._shaper), this.order = e.order, this.oversample = e.oversample
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                order: 1,
                oversample: "none"
            })
        }
        _getCoefficient(e, n, r) {
            return r.has(n) || (n === 0 ? r.set(n, 0) : n === 1 ? r.set(n, e) : r.set(n, 2 * e * this._getCoefficient(e, n - 1, r) - this._getCoefficient(e, n - 2, r))), r.get(n)
        }
        get order() {
            return this._order
        }
        set order(e) {
            this._order = e, this._shaper.setMap(n => this._getCoefficient(n, e, new Map))
        }
        get oversample() {
            return this._shaper.oversample
        }
        set oversample(e) {
            this._shaper.oversample = e
        }
        dispose() {
            return super.dispose(), this._shaper.dispose(), this
        }
    }
    class Zc extends Oe {
        constructor() {
            super(Y(Zc.getDefaults(), arguments, ["channels"])), this.name = "Split";
            const e = Y(Zc.getDefaults(), arguments, ["channels"]);
            this._splitter = this.input = this.output = this.context.createChannelSplitter(e.channels), this._internalChannels = [this._splitter]
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                channels: 2
            })
        }
        dispose() {
            return super.dispose(), this._splitter.disconnect(), this
        }
    }
    class Ca extends Oe {
        constructor() {
            super(Y(Ca.getDefaults(), arguments, ["channels"])), this.name = "Merge";
            const e = Y(Ca.getDefaults(), arguments, ["channels"]);
            this._merger = this.output = this.input = this.context.createChannelMerger(e.channels)
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                channels: 2
            })
        }
        dispose() {
            return super.dispose(), this._merger.disconnect(), this
        }
    }
    class ni extends Oe {
        constructor(e) {
            super(e), this.name = "StereoEffect", this.input = new Le({
                context: this.context
            }), this.input.channelCount = 2, this.input.channelCountMode = "explicit", this._dryWet = this.output = new Yc({
                context: this.context,
                fade: e.wet
            }), this.wet = this._dryWet.fade, this._split = new Zc({
                context: this.context,
                channels: 2
            }), this._merge = new Ca({
                context: this.context,
                channels: 2
            }), this.input.connect(this._split), this.input.connect(this._dryWet.a), this._merge.connect(this._dryWet.b), Fe(this, ["wet"])
        }
        connectEffectLeft(...e) {
            this._split.connect(e[0], 0, 0), is(...e), os(e[e.length - 1], this._merge, 0, 0)
        }
        connectEffectRight(...e) {
            this._split.connect(e[0], 1, 0), is(...e), os(e[e.length - 1], this._merge, 0, 1)
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                wet: 1
            })
        }
        dispose() {
            return super.dispose(), this._dryWet.dispose(), this._split.dispose(), this._merge.dispose(), this
        }
    }
    class _y extends ni {
        constructor(e) {
            super(e), this.feedback = new Ge({
                context: this.context,
                value: e.feedback,
                units: "normalRange"
            }), this._feedbackL = new Le({
                context: this.context
            }), this._feedbackR = new Le({
                context: this.context
            }), this._feedbackSplit = new Zc({
                context: this.context,
                channels: 2
            }), this._feedbackMerge = new Ca({
                context: this.context,
                channels: 2
            }), this._merge.connect(this._feedbackSplit), this._feedbackMerge.connect(this._split), this._feedbackSplit.connect(this._feedbackL, 0, 0), this._feedbackL.connect(this._feedbackMerge, 0, 0), this._feedbackSplit.connect(this._feedbackR, 1, 0), this._feedbackR.connect(this._feedbackMerge, 0, 1), this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain), Fe(this, ["feedback"])
        }
        static getDefaults() {
            return Object.assign(ni.getDefaults(), {
                feedback: .5
            })
        }
        dispose() {
            return super.dispose(), this.feedback.dispose(), this._feedbackL.dispose(), this._feedbackR.dispose(), this._feedbackSplit.dispose(), this._feedbackMerge.dispose(), this
        }
    }
    class op extends _y {
        constructor() {
            super(Y(op.getDefaults(), arguments, ["frequency", "delayTime", "depth"])), this.name = "Chorus";
            const e = Y(op.getDefaults(), arguments, ["frequency", "delayTime", "depth"]);
            this._depth = e.depth, this._delayTime = e.delayTime / 1e3, this._lfoL = new dr({
                context: this.context,
                frequency: e.frequency,
                min: 0,
                max: 1
            }), this._lfoR = new dr({
                context: this.context,
                frequency: e.frequency,
                min: 0,
                max: 1,
                phase: 180
            }), this._delayNodeL = new Ur({
                context: this.context
            }), this._delayNodeR = new Ur({
                context: this.context
            }), this.frequency = this._lfoL.frequency, Fe(this, ["frequency"]), this._lfoL.frequency.connect(this._lfoR.frequency), this.connectEffectLeft(this._delayNodeL), this.connectEffectRight(this._delayNodeR), this._lfoL.connect(this._delayNodeL.delayTime), this._lfoR.connect(this._delayNodeR.delayTime), this.depth = this._depth, this.type = e.type, this.spread = e.spread
        }
        static getDefaults() {
            return Object.assign(_y.getDefaults(), {
                frequency: 1.5,
                delayTime: 3.5,
                depth: .7,
                type: "sine",
                spread: 180,
                feedback: 0,
                wet: .5
            })
        }
        get depth() {
            return this._depth
        }
        set depth(e) {
            this._depth = e;
            const n = this._delayTime * e;
            this._lfoL.min = Math.max(this._delayTime - n, 0), this._lfoL.max = this._delayTime + n, this._lfoR.min = Math.max(this._delayTime - n, 0), this._lfoR.max = this._delayTime + n
        }
        get delayTime() {
            return this._delayTime * 1e3
        }
        set delayTime(e) {
            this._delayTime = e / 1e3, this.depth = this._depth
        }
        get type() {
            return this._lfoL.type
        }
        set type(e) {
            this._lfoL.type = e, this._lfoR.type = e
        }
        get spread() {
            return this._lfoR.phase - this._lfoL.phase
        }
        set spread(e) {
            this._lfoL.phase = 90 - e / 2, this._lfoR.phase = e / 2 + 90
        }
        start(e) {
            return this._lfoL.start(e), this._lfoR.start(e), this
        }
        stop(e) {
            return this._lfoL.stop(e), this._lfoR.stop(e), this
        }
        sync() {
            return this._lfoL.sync(), this._lfoR.sync(), this
        }
        unsync() {
            return this._lfoL.unsync(), this._lfoR.unsync(), this
        }
        dispose() {
            return super.dispose(), this._lfoL.dispose(), this._lfoR.dispose(), this._delayNodeL.dispose(), this._delayNodeR.dispose(), this.frequency.dispose(), this
        }
    }
    class ap extends Rn {
        constructor() {
            super(Y(ap.getDefaults(), arguments, ["distortion"])), this.name = "Distortion";
            const e = Y(ap.getDefaults(), arguments, ["distortion"]);
            this._shaper = new Cs({
                context: this.context,
                length: 4096
            }), this._distortion = e.distortion, this.connectEffect(this._shaper), this.distortion = e.distortion, this.oversample = e.oversample
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                distortion: .4,
                oversample: "none"
            })
        }
        get distortion() {
            return this._distortion
        }
        set distortion(e) {
            this._distortion = e;
            const n = e * 100,
                r = Math.PI / 180;
            this._shaper.setMap(s => Math.abs(s) < .001 ? 0 : (3 + n) * s * 20 * r / (Math.PI + n * Math.abs(s)))
        }
        get oversample() {
            return this._shaper.oversample
        }
        set oversample(e) {
            this._shaper.oversample = e
        }
        dispose() {
            return super.dispose(), this._shaper.dispose(), this
        }
    }
    class cp extends Rn {
        constructor(e) {
            super(e), this.name = "FeedbackEffect", this._feedbackGain = new Le({
                context: this.context,
                gain: e.feedback,
                units: "normalRange"
            }), this.feedback = this._feedbackGain.gain, Fe(this, "feedback"), this.effectReturn.chain(this._feedbackGain, this.effectSend)
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                feedback: .125
            })
        }
        dispose() {
            return super.dispose(), this._feedbackGain.dispose(), this.feedback.dispose(), this
        }
    }
    class lp extends cp {
        constructor() {
            super(Y(lp.getDefaults(), arguments, ["delayTime", "feedback"])), this.name = "FeedbackDelay";
            const e = Y(lp.getDefaults(), arguments, ["delayTime", "feedback"]);
            this._delayNode = new Ur({
                context: this.context,
                delayTime: e.delayTime,
                maxDelay: e.maxDelay
            }), this.delayTime = this._delayNode.delayTime, this.connectEffect(this._delayNode), Fe(this, "delayTime")
        }
        static getDefaults() {
            return Object.assign(cp.getDefaults(), {
                delayTime: .25,
                maxDelay: 1
            })
        }
        dispose() {
            return super.dispose(), this._delayNode.dispose(), this.delayTime.dispose(), this
        }
    }
    class rve extends Oe {
        constructor(e) {
            super(e), this.name = "PhaseShiftAllpass", this.input = new Le({
                context: this.context
            }), this.output = new Le({
                context: this.context
            }), this.offset90 = new Le({
                context: this.context
            });
            const n = [.6923878, .9360654322959, .988229522686, .9987488452737],
                r = [.4021921162426, .856171088242, .9722909545651, .9952884791278];
            this._bank0 = this._createAllPassFilterBank(n), this._bank1 = this._createAllPassFilterBank(r), this._oneSampleDelay = this.context.createIIRFilter([0, 1], [1, 0]), is(this.input, ...this._bank0, this._oneSampleDelay, this.output), is(this.input, ...this._bank1, this.offset90)
        }
        _createAllPassFilterBank(e) {
            return e.map(r => {
                const s = [
                    [r * r, 0, -1],
                    [1, 0, -(r * r)]
                ];
                return this.context.createIIRFilter(s[0], s[1])
            })
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this.output.dispose(), this.offset90.dispose(), this._bank0.forEach(e => e.disconnect()), this._bank1.forEach(e => e.disconnect()), this._oneSampleDelay.disconnect(), this
        }
    }
    class up extends Rn {
        constructor() {
            super(Y(up.getDefaults(), arguments, ["frequency"])), this.name = "FrequencyShifter";
            const e = Y(up.getDefaults(), arguments, ["frequency"]);
            this.frequency = new Ge({
                context: this.context,
                units: "frequency",
                value: e.frequency,
                minValue: -this.context.sampleRate / 2,
                maxValue: this.context.sampleRate / 2
            }), this._sine = new Cu({
                context: this.context,
                type: "sine"
            }), this._cosine = new rn({
                context: this.context,
                phase: -90,
                type: "sine"
            }), this._sineMultiply = new on({
                context: this.context
            }), this._cosineMultiply = new on({
                context: this.context
            }), this._negate = new zk({
                context: this.context
            }), this._add = new yl({
                context: this.context
            }), this._phaseShifter = new rve({
                context: this.context
            }), this.effectSend.connect(this._phaseShifter), this.frequency.fan(this._sine.frequency, this._cosine.frequency), this._phaseShifter.offset90.connect(this._cosineMultiply), this._cosine.connect(this._cosineMultiply.factor), this._phaseShifter.connect(this._sineMultiply), this._sine.connect(this._sineMultiply.factor), this._sineMultiply.connect(this._negate), this._cosineMultiply.connect(this._add), this._negate.connect(this._add.addend), this._add.connect(this.effectReturn);
            const n = this.immediate();
            this._sine.start(n), this._cosine.start(n)
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                frequency: 0
            })
        }
        dispose() {
            return super.dispose(), this.frequency.dispose(), this._add.dispose(), this._cosine.dispose(), this._cosineMultiply.dispose(), this._negate.dispose(), this._phaseShifter.dispose(), this._sine.dispose(), this._sineMultiply.dispose(), this
        }
    }
    const G3 = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100],
        W3 = [225, 556, 441, 341];
    class hp extends ni {
        constructor() {
            super(Y(hp.getDefaults(), arguments, ["roomSize", "dampening"])), this.name = "Freeverb", this._combFilters = [], this._allpassFiltersL = [], this._allpassFiltersR = [];
            const e = Y(hp.getDefaults(), arguments, ["roomSize", "dampening"]);
            this.roomSize = new Ge({
                context: this.context,
                value: e.roomSize,
                units: "normalRange"
            }), this._allpassFiltersL = W3.map(n => {
                const r = this.context.createBiquadFilter();
                return r.type = "allpass", r.frequency.value = n, r
            }), this._allpassFiltersR = W3.map(n => {
                const r = this.context.createBiquadFilter();
                return r.type = "allpass", r.frequency.value = n, r
            }), this._combFilters = G3.map((n, r) => {
                const s = new Lu({
                    context: this.context,
                    dampening: e.dampening,
                    delayTime: n
                });
                return r < G3.length / 2 ? this.connectEffectLeft(s, ...this._allpassFiltersL) : this.connectEffectRight(s, ...this._allpassFiltersR), this.roomSize.connect(s.resonance), s
            }), Fe(this, ["roomSize"])
        }
        static getDefaults() {
            return Object.assign(ni.getDefaults(), {
                roomSize: .7,
                dampening: 3e3
            })
        }
        get dampening() {
            return this._combFilters[0].dampening
        }
        set dampening(e) {
            this._combFilters.forEach(n => n.dampening = e)
        }
        dispose() {
            return super.dispose(), this._allpassFiltersL.forEach(e => e.disconnect()), this._allpassFiltersR.forEach(e => e.disconnect()), this._combFilters.forEach(e => e.dispose()), this.roomSize.dispose(), this
        }
    }
    const H3 = [1687 / 25e3, 1601 / 25e3, 2053 / 25e3, 2251 / 25e3],
        sve = [.773, .802, .753, .733],
        ive = [347, 113, 37];
    class fp extends ni {
        constructor() {
            super(Y(fp.getDefaults(), arguments, ["roomSize"])), this.name = "JCReverb", this._allpassFilters = [], this._feedbackCombFilters = [];
            const e = Y(fp.getDefaults(), arguments, ["roomSize"]);
            this.roomSize = new Ge({
                context: this.context,
                value: e.roomSize,
                units: "normalRange"
            }), this._scaleRoomSize = new Di({
                context: this.context,
                min: -.733,
                max: .197
            }), this._allpassFilters = ive.map(n => {
                const r = this.context.createBiquadFilter();
                return r.type = "allpass", r.frequency.value = n, r
            }), this._feedbackCombFilters = H3.map((n, r) => {
                const s = new Du({
                    context: this.context,
                    delayTime: n
                });
                return this._scaleRoomSize.connect(s.resonance), s.resonance.value = sve[r], r < H3.length / 2 ? this.connectEffectLeft(...this._allpassFilters, s) : this.connectEffectRight(...this._allpassFilters, s), s
            }), this.roomSize.connect(this._scaleRoomSize), Fe(this, ["roomSize"])
        }
        static getDefaults() {
            return Object.assign(ni.getDefaults(), {
                roomSize: .5
            })
        }
        dispose() {
            return super.dispose(), this._allpassFilters.forEach(e => e.disconnect()), this._feedbackCombFilters.forEach(e => e.dispose()), this.roomSize.dispose(), this._scaleRoomSize.dispose(), this
        }
    }
    class K3 extends _y {
        constructor(e) {
            super(e), this._feedbackL.disconnect(), this._feedbackL.connect(this._feedbackMerge, 0, 1), this._feedbackR.disconnect(), this._feedbackR.connect(this._feedbackMerge, 0, 0), Fe(this, ["feedback"])
        }
    }
    class dp extends K3 {
        constructor() {
            super(Y(dp.getDefaults(), arguments, ["delayTime", "feedback"])), this.name = "PingPongDelay";
            const e = Y(dp.getDefaults(), arguments, ["delayTime", "feedback"]);
            this._leftDelay = new Ur({
                context: this.context,
                maxDelay: e.maxDelay
            }), this._rightDelay = new Ur({
                context: this.context,
                maxDelay: e.maxDelay
            }), this._rightPreDelay = new Ur({
                context: this.context,
                maxDelay: e.maxDelay
            }), this.delayTime = new Ge({
                context: this.context,
                units: "time",
                value: e.delayTime
            }), this.connectEffectLeft(this._leftDelay), this.connectEffectRight(this._rightPreDelay, this._rightDelay), this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime), this._feedbackL.disconnect(), this._feedbackL.connect(this._rightDelay), Fe(this, ["delayTime"])
        }
        static getDefaults() {
            return Object.assign(K3.getDefaults(), {
                delayTime: .25,
                maxDelay: 1
            })
        }
        dispose() {
            return super.dispose(), this._leftDelay.dispose(), this._rightDelay.dispose(), this._rightPreDelay.dispose(), this.delayTime.dispose(), this
        }
    }
    class pp extends cp {
        constructor() {
            super(Y(pp.getDefaults(), arguments, ["pitch"])), this.name = "PitchShift";
            const e = Y(pp.getDefaults(), arguments, ["pitch"]);
            this._frequency = new Ge({
                context: this.context
            }), this._delayA = new Ur({
                maxDelay: 1,
                context: this.context
            }), this._lfoA = new dr({
                context: this.context,
                min: 0,
                max: .1,
                type: "sawtooth"
            }).connect(this._delayA.delayTime), this._delayB = new Ur({
                maxDelay: 1,
                context: this.context
            }), this._lfoB = new dr({
                context: this.context,
                min: 0,
                max: .1,
                type: "sawtooth",
                phase: 180
            }).connect(this._delayB.delayTime), this._crossFade = new Yc({
                context: this.context
            }), this._crossFadeLFO = new dr({
                context: this.context,
                min: 0,
                max: 1,
                type: "triangle",
                phase: 90
            }).connect(this._crossFade.fade), this._feedbackDelay = new Ur({
                delayTime: e.delayTime,
                context: this.context
            }), this.delayTime = this._feedbackDelay.delayTime, Fe(this, "delayTime"), this._pitch = e.pitch, this._windowSize = e.windowSize, this._delayA.connect(this._crossFade.a), this._delayB.connect(this._crossFade.b), this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency), this.effectSend.fan(this._delayA, this._delayB), this._crossFade.chain(this._feedbackDelay, this.effectReturn);
            const n = this.now();
            this._lfoA.start(n), this._lfoB.start(n), this._crossFadeLFO.start(n), this.windowSize = this._windowSize
        }
        static getDefaults() {
            return Object.assign(cp.getDefaults(), {
                pitch: 0,
                windowSize: .1,
                delayTime: 0,
                feedback: 0
            })
        }
        get pitch() {
            return this._pitch
        }
        set pitch(e) {
            this._pitch = e;
            let n = 0;
            e < 0 ? (this._lfoA.min = 0, this._lfoA.max = this._windowSize, this._lfoB.min = 0, this._lfoB.max = this._windowSize, n = Aa(e - 1) + 1) : (this._lfoA.min = this._windowSize, this._lfoA.max = 0, this._lfoB.min = this._windowSize, this._lfoB.max = 0, n = Aa(e) - 1), this._frequency.value = n * (1.2 / this._windowSize)
        }
        get windowSize() {
            return this._windowSize
        }
        set windowSize(e) {
            this._windowSize = this.toSeconds(e), this.pitch = this._pitch
        }
        dispose() {
            return super.dispose(), this._frequency.dispose(), this._delayA.dispose(), this._delayB.dispose(), this._lfoA.dispose(), this._lfoB.dispose(), this._crossFade.dispose(), this._crossFadeLFO.dispose(), this._feedbackDelay.dispose(), this
        }
    }
    class mp extends ni {
        constructor() {
            super(Y(mp.getDefaults(), arguments, ["frequency", "octaves", "baseFrequency"])), this.name = "Phaser";
            const e = Y(mp.getDefaults(), arguments, ["frequency", "octaves", "baseFrequency"]);
            this._lfoL = new dr({
                context: this.context,
                frequency: e.frequency,
                min: 0,
                max: 1
            }), this._lfoR = new dr({
                context: this.context,
                frequency: e.frequency,
                min: 0,
                max: 1,
                phase: 180
            }), this._baseFrequency = this.toFrequency(e.baseFrequency), this._octaves = e.octaves, this.Q = new Ge({
                context: this.context,
                value: e.Q,
                units: "positive"
            }), this._filtersL = this._makeFilters(e.stages, this._lfoL), this._filtersR = this._makeFilters(e.stages, this._lfoR), this.frequency = this._lfoL.frequency, this.frequency.value = e.frequency, this.connectEffectLeft(...this._filtersL), this.connectEffectRight(...this._filtersR), this._lfoL.frequency.connect(this._lfoR.frequency), this.baseFrequency = e.baseFrequency, this.octaves = e.octaves, this._lfoL.start(), this._lfoR.start(), Fe(this, ["frequency", "Q"])
        }
        static getDefaults() {
            return Object.assign(ni.getDefaults(), {
                frequency: .5,
                octaves: 3,
                stages: 10,
                Q: 10,
                baseFrequency: 350
            })
        }
        _makeFilters(e, n) {
            const r = [];
            for (let s = 0; s < e; s++) {
                const i = this.context.createBiquadFilter();
                i.type = "allpass", this.Q.connect(i.Q), n.connect(i.frequency), r.push(i)
            }
            return r
        }
        get octaves() {
            return this._octaves
        }
        set octaves(e) {
            this._octaves = e;
            const n = this._baseFrequency * Math.pow(2, e);
            this._lfoL.max = n, this._lfoR.max = n
        }
        get baseFrequency() {
            return this._baseFrequency
        }
        set baseFrequency(e) {
            this._baseFrequency = this.toFrequency(e), this._lfoL.min = this._baseFrequency, this._lfoR.min = this._baseFrequency, this.octaves = this._octaves
        }
        dispose() {
            return super.dispose(), this.Q.dispose(), this._lfoL.dispose(), this._lfoR.dispose(), this._filtersL.forEach(e => e.disconnect()), this._filtersR.forEach(e => e.disconnect()), this.frequency.dispose(), this
        }
    }
    class gp extends Rn {
        constructor() {
            super(Y(gp.getDefaults(), arguments, ["decay"])), this.name = "Reverb", this._convolver = this.context.createConvolver(), this.ready = Promise.resolve();
            const e = Y(gp.getDefaults(), arguments, ["decay"]);
            this._decay = e.decay, this._preDelay = e.preDelay, this.generate(), this.connectEffect(this._convolver)
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                decay: 1.5,
                preDelay: .01
            })
        }
        get decay() {
            return this._decay
        }
        set decay(e) {
            e = this.toSeconds(e), As(e, .001), this._decay = e, this.generate()
        }
        get preDelay() {
            return this._preDelay
        }
        set preDelay(e) {
            e = this.toSeconds(e), As(e, 0), this._preDelay = e, this.generate()
        }
        generate() {
            return yn(this, void 0, void 0, function*() {
                const e = this.ready,
                    n = new km(2, this._decay + this._preDelay, this.context.sampleRate),
                    r = new Co({
                        context: n
                    }),
                    s = new Co({
                        context: n
                    }),
                    i = new Ca({
                        context: n
                    });
                r.connect(i, 0, 0), s.connect(i, 0, 1);
                const a = new Le({
                    context: n
                }).toDestination();
                i.connect(a), r.start(0), s.start(0), a.gain.setValueAtTime(0, 0), a.gain.setValueAtTime(1, this._preDelay), a.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);
                const c = n.render();
                return this.ready = c.then(ht), yield e, this._convolver.buffer = (yield c).get(), this
            })
        }
        dispose() {
            return super.dispose(), this._convolver.disconnect(), this
        }
    }
    class H0 extends Oe {
        constructor() {
            super(Y(H0.getDefaults(), arguments)), this.name = "MidSideSplit", this._split = this.input = new Zc({
                channels: 2,
                context: this.context
            }), this._midAdd = new yl({
                context: this.context
            }), this.mid = new on({
                context: this.context,
                value: Math.SQRT1_2
            }), this._sideSubtract = new vl({
                context: this.context
            }), this.side = new on({
                context: this.context,
                value: Math.SQRT1_2
            }), this._split.connect(this._midAdd, 0), this._split.connect(this._midAdd.addend, 1), this._split.connect(this._sideSubtract, 0), this._split.connect(this._sideSubtract.subtrahend, 1), this._midAdd.connect(this.mid), this._sideSubtract.connect(this.side)
        }
        dispose() {
            return super.dispose(), this.mid.dispose(), this.side.dispose(), this._midAdd.dispose(), this._sideSubtract.dispose(), this._split.dispose(), this
        }
    }
    class K0 extends Oe {
        constructor() {
            super(Y(K0.getDefaults(), arguments)), this.name = "MidSideMerge", this.mid = new Le({
                context: this.context
            }), this.side = new Le({
                context: this.context
            }), this._left = new yl({
                context: this.context
            }), this._leftMult = new on({
                context: this.context,
                value: Math.SQRT1_2
            }), this._right = new vl({
                context: this.context
            }), this._rightMult = new on({
                context: this.context,
                value: Math.SQRT1_2
            }), this._merge = this.output = new Ca({
                context: this.context
            }), this.mid.fan(this._left), this.side.connect(this._left.addend), this.mid.connect(this._right), this.side.connect(this._right.subtrahend), this._left.connect(this._leftMult), this._right.connect(this._rightMult), this._leftMult.connect(this._merge, 0, 0), this._rightMult.connect(this._merge, 0, 1)
        }
        dispose() {
            return super.dispose(), this.mid.dispose(), this.side.dispose(), this._leftMult.dispose(), this._rightMult.dispose(), this._left.dispose(), this._right.dispose(), this
        }
    }
    class Y3 extends Rn {
        constructor(e) {
            super(e), this.name = "MidSideEffect", this._midSideMerge = new K0({
                context: this.context
            }), this._midSideSplit = new H0({
                context: this.context
            }), this._midSend = this._midSideSplit.mid, this._sideSend = this._midSideSplit.side, this._midReturn = this._midSideMerge.mid, this._sideReturn = this._midSideMerge.side, this.effectSend.connect(this._midSideSplit), this._midSideMerge.connect(this.effectReturn)
        }
        connectEffectMid(...e) {
            this._midSend.chain(...e, this._midReturn)
        }
        connectEffectSide(...e) {
            this._sideSend.chain(...e, this._sideReturn)
        }
        dispose() {
            return super.dispose(), this._midSideSplit.dispose(), this._midSideMerge.dispose(), this._midSend.dispose(), this._sideSend.dispose(), this._midReturn.dispose(), this._sideReturn.dispose(), this
        }
    }
    class _p extends Y3 {
        constructor() {
            super(Y(_p.getDefaults(), arguments, ["width"])), this.name = "StereoWidener";
            const e = Y(_p.getDefaults(), arguments, ["width"]);
            this.width = new Ge({
                context: this.context,
                value: e.width,
                units: "normalRange"
            }), Fe(this, ["width"]), this._twoTimesWidthMid = new on({
                context: this.context,
                value: 2
            }), this._twoTimesWidthSide = new on({
                context: this.context,
                value: 2
            }), this._midMult = new on({
                context: this.context
            }), this._twoTimesWidthMid.connect(this._midMult.factor), this.connectEffectMid(this._midMult), this._oneMinusWidth = new vl({
                context: this.context
            }), this._oneMinusWidth.connect(this._twoTimesWidthMid), os(this.context.getConstant(1), this._oneMinusWidth), this.width.connect(this._oneMinusWidth.subtrahend), this._sideMult = new on({
                context: this.context
            }), this.width.connect(this._twoTimesWidthSide), this._twoTimesWidthSide.connect(this._sideMult.factor), this.connectEffectSide(this._sideMult)
        }
        static getDefaults() {
            return Object.assign(Y3.getDefaults(), {
                width: .5
            })
        }
        dispose() {
            return super.dispose(), this.width.dispose(), this._midMult.dispose(), this._sideMult.dispose(), this._twoTimesWidthMid.dispose(), this._twoTimesWidthSide.dispose(), this._oneMinusWidth.dispose(), this
        }
    }
    class qu extends ni {
        constructor() {
            super(Y(qu.getDefaults(), arguments, ["frequency", "depth"])), this.name = "Tremolo";
            const e = Y(qu.getDefaults(), arguments, ["frequency", "depth"]);
            this._lfoL = new dr({
                context: this.context,
                type: e.type,
                min: 1,
                max: 0
            }), this._lfoR = new dr({
                context: this.context,
                type: e.type,
                min: 1,
                max: 0
            }), this._amplitudeL = new Le({
                context: this.context
            }), this._amplitudeR = new Le({
                context: this.context
            }), this.frequency = new Ge({
                context: this.context,
                value: e.frequency,
                units: "frequency"
            }), this.depth = new Ge({
                context: this.context,
                value: e.depth,
                units: "normalRange"
            }), Fe(this, ["frequency", "depth"]), this.connectEffectLeft(this._amplitudeL), this.connectEffectRight(this._amplitudeR), this._lfoL.connect(this._amplitudeL.gain), this._lfoR.connect(this._amplitudeR.gain), this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency), this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude), this.spread = e.spread
        }
        static getDefaults() {
            return Object.assign(ni.getDefaults(), {
                frequency: 10,
                type: "sine",
                depth: .5,
                spread: 180
            })
        }
        start(e) {
            return this._lfoL.start(e), this._lfoR.start(e), this
        }
        stop(e) {
            return this._lfoL.stop(e), this._lfoR.stop(e), this
        }
        sync() {
            return this._lfoL.sync(), this._lfoR.sync(), this.context.transport.syncSignal(this.frequency), this
        }
        unsync() {
            return this._lfoL.unsync(), this._lfoR.unsync(), this.context.transport.unsyncSignal(this.frequency), this
        }
        get type() {
            return this._lfoL.type
        }
        set type(e) {
            this._lfoL.type = e, this._lfoR.type = e
        }
        get spread() {
            return this._lfoR.phase - this._lfoL.phase
        }
        set spread(e) {
            this._lfoL.phase = 90 - e / 2, this._lfoR.phase = e / 2 + 90
        }
        dispose() {
            return super.dispose(), this._lfoL.dispose(), this._lfoR.dispose(), this._amplitudeL.dispose(), this._amplitudeR.dispose(), this.frequency.dispose(), this.depth.dispose(), this
        }
    }
    class yp extends Rn {
        constructor() {
            super(Y(yp.getDefaults(), arguments, ["frequency", "depth"])), this.name = "Vibrato";
            const e = Y(yp.getDefaults(), arguments, ["frequency", "depth"]);
            this._delayNode = new Ur({
                context: this.context,
                delayTime: 0,
                maxDelay: e.maxDelay
            }), this._lfo = new dr({
                context: this.context,
                type: e.type,
                min: 0,
                max: e.maxDelay,
                frequency: e.frequency,
                phase: -90
            }).start().connect(this._delayNode.delayTime), this.frequency = this._lfo.frequency, this.depth = this._lfo.amplitude, this.depth.value = e.depth, Fe(this, ["frequency", "depth"]), this.effectSend.chain(this._delayNode, this.effectReturn)
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                maxDelay: .005,
                frequency: 5,
                depth: .1,
                type: "sine"
            })
        }
        get type() {
            return this._lfo.type
        }
        set type(e) {
            this._lfo.type = e
        }
        dispose() {
            return super.dispose(), this._delayNode.dispose(), this._lfo.dispose(), this.frequency.dispose(), this.depth.dispose(), this
        }
    }
    class pn extends Oe {
        constructor() {
            super(Y(pn.getDefaults(), arguments, ["solo"])), this.name = "Solo";
            const e = Y(pn.getDefaults(), arguments, ["solo"]);
            this.input = this.output = new Le({
                context: this.context
            }), pn._allSolos.has(this.context) || pn._allSolos.set(this.context, new Set), pn._allSolos.get(this.context).add(this), this.solo = e.solo
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                solo: !1
            })
        }
        get solo() {
            return this._isSoloed()
        }
        set solo(e) {
            e ? this._addSolo() : this._removeSolo(), pn._allSolos.get(this.context).forEach(n => n._updateSolo())
        }
        get muted() {
            return this.input.gain.value === 0
        }
        _addSolo() {
            pn._soloed.has(this.context) || pn._soloed.set(this.context, new Set), pn._soloed.get(this.context).add(this)
        }
        _removeSolo() {
            pn._soloed.has(this.context) && pn._soloed.get(this.context).delete(this)
        }
        _isSoloed() {
            return pn._soloed.has(this.context) && pn._soloed.get(this.context).has(this)
        }
        _noSolos() {
            return !pn._soloed.has(this.context) || pn._soloed.has(this.context) && pn._soloed.get(this.context).size === 0
        }
        _updateSolo() {
            this._isSoloed() ? this.input.gain.value = 1 : this._noSolos() ? this.input.gain.value = 1 : this.input.gain.value = 0
        }
        dispose() {
            return super.dispose(), pn._allSolos.get(this.context).delete(this), this._removeSolo(), this
        }
    }
    pn._allSolos = new Map;
    pn._soloed = new Map;
    class Xc extends Oe {
        constructor() {
            super(Y(Xc.getDefaults(), arguments, ["pan", "volume"])), this.name = "PanVol";
            const e = Y(Xc.getDefaults(), arguments, ["pan", "volume"]);
            this._panner = this.input = new zc({
                context: this.context,
                pan: e.pan,
                channelCount: e.channelCount
            }), this.pan = this._panner.pan, this._volume = this.output = new Js({
                context: this.context,
                volume: e.volume
            }), this.volume = this._volume.volume, this._panner.connect(this._volume), this.mute = e.mute, Fe(this, ["pan", "volume"])
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                mute: !1,
                pan: 0,
                volume: 0,
                channelCount: 1
            })
        }
        get mute() {
            return this._volume.mute
        }
        set mute(e) {
            this._volume.mute = e
        }
        dispose() {
            return super.dispose(), this._panner.dispose(), this.pan.dispose(), this._volume.dispose(), this.volume.dispose(), this
        }
    }
    class ua extends Oe {
        constructor() {
            super(Y(ua.getDefaults(), arguments, ["volume", "pan"])), this.name = "Channel";
            const e = Y(ua.getDefaults(), arguments, ["volume", "pan"]);
            this._solo = this.input = new pn({
                solo: e.solo,
                context: this.context
            }), this._panVol = this.output = new Xc({
                context: this.context,
                pan: e.pan,
                volume: e.volume,
                mute: e.mute,
                channelCount: e.channelCount
            }), this.pan = this._panVol.pan, this.volume = this._panVol.volume, this._solo.connect(this._panVol), Fe(this, ["pan", "volume"])
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                pan: 0,
                volume: 0,
                mute: !1,
                solo: !1,
                channelCount: 1
            })
        }
        get solo() {
            return this._solo.solo
        }
        set solo(e) {
            this._solo.solo = e
        }
        get muted() {
            return this._solo.muted || this.mute
        }
        get mute() {
            return this._panVol.mute
        }
        set mute(e) {
            this._panVol.mute = e
        }
        _getBus(e) {
            return ua.buses.has(e) || ua.buses.set(e, new Le({
                context: this.context
            })), ua.buses.get(e)
        }
        send(e, n = 0) {
            const r = this._getBus(e),
                s = new Le({
                    context: this.context,
                    units: "decibels",
                    gain: n
                });
            return this.connect(s), s.connect(r), s
        }
        receive(e) {
            return this._getBus(e).connect(this), this
        }
        dispose() {
            return super.dispose(), this._panVol.dispose(), this.pan.dispose(), this.volume.dispose(), this._solo.dispose(), this
        }
    }
    ua.buses = new Map;
    class ju extends Oe {
        constructor() {
            super(Y(ju.getDefaults(), arguments, ["lowFrequency", "highFrequency"])), this.name = "MultibandSplit", this.input = new Le({
                context: this.context
            }), this.output = void 0, this.low = new wr({
                context: this.context,
                frequency: 0,
                type: "lowpass"
            }), this._lowMidFilter = new wr({
                context: this.context,
                frequency: 0,
                type: "highpass"
            }), this.mid = new wr({
                context: this.context,
                frequency: 0,
                type: "lowpass"
            }), this.high = new wr({
                context: this.context,
                frequency: 0,
                type: "highpass"
            }), this._internalChannels = [this.low, this.mid, this.high];
            const e = Y(ju.getDefaults(), arguments, ["lowFrequency", "highFrequency"]);
            this.lowFrequency = new Ge({
                context: this.context,
                units: "frequency",
                value: e.lowFrequency
            }), this.highFrequency = new Ge({
                context: this.context,
                units: "frequency",
                value: e.highFrequency
            }), this.Q = new Ge({
                context: this.context,
                units: "positive",
                value: e.Q
            }), this.input.fan(this.low, this.high), this.input.chain(this._lowMidFilter, this.mid), this.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency), this.highFrequency.fan(this.mid.frequency, this.high.frequency), this.Q.connect(this.low.Q), this.Q.connect(this._lowMidFilter.Q), this.Q.connect(this.mid.Q), this.Q.connect(this.high.Q), Fe(this, ["high", "mid", "low", "highFrequency", "lowFrequency"])
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                Q: 1,
                highFrequency: 2500,
                lowFrequency: 400
            })
        }
        dispose() {
            return super.dispose(), yh(this, ["high", "mid", "low", "highFrequency", "lowFrequency"]), this.low.dispose(), this._lowMidFilter.dispose(), this.mid.dispose(), this.high.dispose(), this.lowFrequency.dispose(), this.highFrequency.dispose(), this.Q.dispose(), this
        }
    }
    class ove extends Oe {
        constructor() {
            super(...arguments), this.name = "Listener", this.positionX = new it({
                context: this.context,
                param: this.context.rawContext.listener.positionX
            }), this.positionY = new it({
                context: this.context,
                param: this.context.rawContext.listener.positionY
            }), this.positionZ = new it({
                context: this.context,
                param: this.context.rawContext.listener.positionZ
            }), this.forwardX = new it({
                context: this.context,
                param: this.context.rawContext.listener.forwardX
            }), this.forwardY = new it({
                context: this.context,
                param: this.context.rawContext.listener.forwardY
            }), this.forwardZ = new it({
                context: this.context,
                param: this.context.rawContext.listener.forwardZ
            }), this.upX = new it({
                context: this.context,
                param: this.context.rawContext.listener.upX
            }), this.upY = new it({
                context: this.context,
                param: this.context.rawContext.listener.upY
            }), this.upZ = new it({
                context: this.context,
                param: this.context.rawContext.listener.upZ
            })
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                positionX: 0,
                positionY: 0,
                positionZ: 0,
                forwardX: 0,
                forwardY: 0,
                forwardZ: -1,
                upX: 0,
                upY: 1,
                upZ: 0
            })
        }
        dispose() {
            return super.dispose(), this.positionX.dispose(), this.positionY.dispose(), this.positionZ.dispose(), this.forwardX.dispose(), this.forwardY.dispose(), this.forwardZ.dispose(), this.upX.dispose(), this.upY.dispose(), this.upZ.dispose(), this
        }
    }
    Am(t => {
        t.listener = new ove({
            context: t
        })
    });
    Cm(t => {
        t.listener.dispose()
    });
    class vo extends Oe {
        constructor() {
            super(Y(vo.getDefaults(), arguments, ["threshold", "ratio"])), this.name = "Compressor", this._compressor = this.context.createDynamicsCompressor(), this.input = this._compressor, this.output = this._compressor;
            const e = Y(vo.getDefaults(), arguments, ["threshold", "ratio"]);
            this.threshold = new it({
                minValue: this._compressor.threshold.minValue,
                maxValue: this._compressor.threshold.maxValue,
                context: this.context,
                convert: !1,
                param: this._compressor.threshold,
                units: "decibels",
                value: e.threshold
            }), this.attack = new it({
                minValue: this._compressor.attack.minValue,
                maxValue: this._compressor.attack.maxValue,
                context: this.context,
                param: this._compressor.attack,
                units: "time",
                value: e.attack
            }), this.release = new it({
                minValue: this._compressor.release.minValue,
                maxValue: this._compressor.release.maxValue,
                context: this.context,
                param: this._compressor.release,
                units: "time",
                value: e.release
            }), this.knee = new it({
                minValue: this._compressor.knee.minValue,
                maxValue: this._compressor.knee.maxValue,
                context: this.context,
                convert: !1,
                param: this._compressor.knee,
                units: "decibels",
                value: e.knee
            }), this.ratio = new it({
                minValue: this._compressor.ratio.minValue,
                maxValue: this._compressor.ratio.maxValue,
                context: this.context,
                convert: !1,
                param: this._compressor.ratio,
                units: "positive",
                value: e.ratio
            }), Fe(this, ["knee", "release", "attack", "ratio", "threshold"])
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                attack: .003,
                knee: 30,
                ratio: 12,
                release: .25,
                threshold: -24
            })
        }
        get reduction() {
            return this._compressor.reduction
        }
        dispose() {
            return super.dispose(), this._compressor.disconnect(), this.attack.dispose(), this.release.dispose(), this.threshold.dispose(), this.ratio.dispose(), this.knee.dispose(), this
        }
    }
    class vp extends Oe {
        constructor() {
            super(Object.assign(Y(vp.getDefaults(), arguments, ["threshold", "smoothing"]))), this.name = "Gate";
            const e = Y(vp.getDefaults(), arguments, ["threshold", "smoothing"]);
            this._follower = new Bu({
                context: this.context,
                smoothing: e.smoothing
            }), this._gt = new zd({
                context: this.context,
                value: Bd(e.threshold)
            }), this.input = new Le({
                context: this.context
            }), this._gate = this.output = new Le({
                context: this.context
            }), this.input.connect(this._gate), this.input.chain(this._follower, this._gt, this._gate.gain)
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                smoothing: .1,
                threshold: -40
            })
        }
        get threshold() {
            return L0(this._gt.value)
        }
        set threshold(e) {
            this._gt.value = Bd(e)
        }
        get smoothing() {
            return this._follower.smoothing
        }
        set smoothing(e) {
            this._follower.smoothing = e
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this._follower.dispose(), this._gt.dispose(), this._gate.dispose(), this
        }
    }
    class bp extends Oe {
        constructor() {
            super(Object.assign(Y(bp.getDefaults(), arguments, ["threshold"]))), this.name = "Limiter";
            const e = Y(bp.getDefaults(), arguments, ["threshold"]);
            this._compressor = this.input = this.output = new vo({
                context: this.context,
                ratio: 20,
                attack: .003,
                release: .01,
                threshold: e.threshold
            }), this.threshold = this._compressor.threshold, Fe(this, "threshold")
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                threshold: -12
            })
        }
        get reduction() {
            return this._compressor.reduction
        }
        dispose() {
            return super.dispose(), this._compressor.dispose(), this.threshold.dispose(), this
        }
    }
    class Ep extends Oe {
        constructor() {
            super(Object.assign(Y(Ep.getDefaults(), arguments))), this.name = "MultibandCompressor";
            const e = Y(Ep.getDefaults(), arguments);
            this._splitter = this.input = new ju({
                context: this.context,
                lowFrequency: e.lowFrequency,
                highFrequency: e.highFrequency
            }), this.lowFrequency = this._splitter.lowFrequency, this.highFrequency = this._splitter.highFrequency, this.output = new Le({
                context: this.context
            }), this.low = new vo(Object.assign(e.low, {
                context: this.context
            })), this.mid = new vo(Object.assign(e.mid, {
                context: this.context
            })), this.high = new vo(Object.assign(e.high, {
                context: this.context
            })), this._splitter.low.chain(this.low, this.output), this._splitter.mid.chain(this.mid, this.output), this._splitter.high.chain(this.high, this.output), Fe(this, ["high", "mid", "low", "highFrequency", "lowFrequency"])
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                lowFrequency: 250,
                highFrequency: 2e3,
                low: {
                    ratio: 6,
                    threshold: -30,
                    release: .25,
                    attack: .03,
                    knee: 10
                },
                mid: {
                    ratio: 3,
                    threshold: -24,
                    release: .03,
                    attack: .02,
                    knee: 16
                },
                high: {
                    ratio: 3,
                    threshold: -24,
                    release: .03,
                    attack: .02,
                    knee: 16
                }
            })
        }
        dispose() {
            return super.dispose(), this._splitter.dispose(), this.low.dispose(), this.mid.dispose(), this.high.dispose(), this.output.dispose(), this
        }
    }
    class Tp extends Oe {
        constructor() {
            super(Y(Tp.getDefaults(), arguments, ["low", "mid", "high"])), this.name = "EQ3", this.output = new Le({
                context: this.context
            }), this._internalChannels = [];
            const e = Y(Tp.getDefaults(), arguments, ["low", "mid", "high"]);
            this.input = this._multibandSplit = new ju({
                context: this.context,
                highFrequency: e.highFrequency,
                lowFrequency: e.lowFrequency
            }), this._lowGain = new Le({
                context: this.context,
                gain: e.low,
                units: "decibels"
            }), this._midGain = new Le({
                context: this.context,
                gain: e.mid,
                units: "decibels"
            }), this._highGain = new Le({
                context: this.context,
                gain: e.high,
                units: "decibels"
            }), this.low = this._lowGain.gain, this.mid = this._midGain.gain, this.high = this._highGain.gain, this.Q = this._multibandSplit.Q, this.lowFrequency = this._multibandSplit.lowFrequency, this.highFrequency = this._multibandSplit.highFrequency, this._multibandSplit.low.chain(this._lowGain, this.output), this._multibandSplit.mid.chain(this._midGain, this.output), this._multibandSplit.high.chain(this._highGain, this.output), Fe(this, ["low", "mid", "high", "lowFrequency", "highFrequency"]), this._internalChannels = [this._multibandSplit]
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                high: 0,
                highFrequency: 2500,
                low: 0,
                lowFrequency: 400,
                mid: 0
            })
        }
        dispose() {
            return super.dispose(), yh(this, ["low", "mid", "high", "lowFrequency", "highFrequency"]), this._multibandSplit.dispose(), this.lowFrequency.dispose(), this.highFrequency.dispose(), this._lowGain.dispose(), this._midGain.dispose(), this._highGain.dispose(), this.low.dispose(), this.mid.dispose(), this.high.dispose(), this.Q.dispose(), this
        }
    }
    es().transport;
    es().destination;
    es().destination;
    es().listener;
    es().draw;
    es();

    function Y0() {
        return Ot.loaded()
    }
    class ave {
        constructor(e) {
            this.isPlayable = !0, this.node = new Pm(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class cve {
        constructor(e) {
            this.isPlayable = !1;
            const n = new as(e.frequency || 440, e.type || "sine"),
                r = new Fu(e).start();
            n.connect(r), this.node = r
        }
    }
    class lve {
        constructor(e) {
            this.isPlayable = !1;
            const n = new as(e.frequency || 440, e.type || "sine"),
                r = new Uu(e).start();
            n.connect(r), this.node = r
        }
    }
    class ks extends Oe {
        constructor() {
            super(Y(ks.getDefaults(), arguments)), this._scheduledEvents = [], this._synced = !1, this._original_triggerAttack = this.triggerAttack, this._original_triggerRelease = this.triggerRelease;
            const e = Y(ks.getDefaults(), arguments);
            this._volume = new Js({
                context: this.context,
                volume: e.volume
            }), this.output = this._volume, this.volume = this._volume.volume, Fe(this, "volume")
        }
        static getDefaults() {
            return Object.assign(Oe.getDefaults(), {
                volume: 0
            })
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 0)), this
        }
        _syncState() {
            let e = !1;
            return this._synced || (this._synced = !0, e = !0), e
        }
        _syncMethod(e, n) {
            const r = this[e];
            this[`_original_${e}`] = this[e], this[e] = (...s) => {
                const i = s[n],
                    a = this.context.transport.schedule(c => {
                        s[n] = c, r.apply(this, s)
                    }, i);
                this._scheduledEvents.push(a)
            }
        }
        unsync() {
            return this._scheduledEvents.forEach(e => this.context.transport.clear(e)), this._scheduledEvents = [], this._synced && (this._synced = !1, this.triggerAttack = this._original_triggerAttack, this.triggerRelease = this._original_triggerRelease), this
        }
        triggerAttackRelease(e, n, r, s) {
            const i = this.toSeconds(r),
                a = this.toSeconds(n);
            return this.triggerAttack(e, i, s), this.triggerRelease(i + a), this
        }
        dispose() {
            return super.dispose(), this._volume.dispose(), this.unsync(), this._scheduledEvents = [], this
        }
    }
    var Sp = (t, e) => Array(Math.abs(e) + 1).join(t);

    function Qk(t, e, n) {
        return function(...r) {
            return console.warn(`${t} is deprecated. Use ${e}.`), n.apply(this, r)
        }
    }

    function e6(t) {
        return t !== null && typeof t == "object" && typeof t.name == "string"
    }

    function t6(t) {
        return t !== null && typeof t == "object" && typeof t.step == "number" && typeof t.alt == "number"
    }
    var n6 = [0, 2, 4, -1, 1, 3, 5],
        r6 = n6.map(t => Math.floor(t * 7 / 12));

    function s6(t) {
        const {
            step: e,
            alt: n,
            oct: r,
            dir: s = 1
        } = t, i = n6[e] + 7 * n;
        if (r === void 0) return [s * i];
        const a = r - r6[e] - 4 * n;
        return [s * i, s * a]
    }
    var uve = [3, 0, 4, 1, 5, 2, 6];

    function i6(t) {
        const [e, n, r] = t, s = uve[hve(e)], i = Math.floor((e + 1) / 7);
        if (n === void 0) return {
            step: s,
            alt: i,
            dir: r
        };
        const a = n + 4 * i + r6[s];
        return {
            step: s,
            alt: i,
            oct: a,
            dir: r
        }
    }

    function hve(t) {
        const e = (t + 1) % 7;
        return e < 0 ? 7 + e : e
    }
    var o6 = {
            empty: !0,
            name: "",
            pc: "",
            acc: ""
        },
        z3 = new Map,
        fve = t => "CDEFGAB".charAt(t),
        dve = t => t < 0 ? Sp("b", -t) : Sp("#", t),
        pve = t => t[0] === "b" ? -t.length : t.length;

    function Bt(t) {
        const e = JSON.stringify(t),
            n = z3.get(e);
        if (n) return n;
        const r = typeof t == "string" ? yve(t) : t6(t) ? Bt(vve(t)) : e6(t) ? Bt(t.name) : o6;
        return z3.set(e, r), r
    }
    var mve = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;

    function a6(t) {
        const e = mve.exec(t);
        return [e[1].toUpperCase(), e[2].replace(/x/g, "##"), e[3], e[4]]
    }

    function gve(t) {
        return Bt(i6(t))
    }
    var _ve = (t, e) => (t % e + e) % e,
        Y_ = [0, 2, 4, 5, 7, 9, 11];

    function yve(t) {
        const e = a6(t);
        if (e[0] === "" || e[3] !== "") return o6;
        const n = e[0],
            r = e[1],
            s = e[2],
            i = (n.charCodeAt(0) + 3) % 7,
            a = pve(r),
            c = s.length ? +s : void 0,
            u = s6({
                step: i,
                alt: a,
                oct: c
            }),
            h = n + r + s,
            d = n + r,
            p = (Y_[i] + a + 120) % 12,
            m = c === void 0 ? _ve(Y_[i] + a, 12) - 12 * 99 : Y_[i] + a + 12 * (c + 1),
            _ = m >= 0 && m <= 127 ? m : null,
            y = c === void 0 ? null : Math.pow(2, (m - 69) / 12) * 440;
        return {
            empty: !1,
            acc: r,
            alt: a,
            chroma: p,
            coord: u,
            freq: y,
            height: m,
            letter: n,
            midi: _,
            name: h,
            oct: c,
            pc: d,
            step: i
        }
    }

    function vve(t) {
        const {
            step: e,
            alt: n,
            oct: r
        } = t, s = fve(e);
        if (!s) return "";
        const i = s + dve(n);
        return r || r === 0 ? i + r : i
    }
    var yy = {
            empty: !0,
            name: "",
            acc: ""
        },
        bve = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})",
        Eve = "(AA|A|P|M|m|d|dd)([-+]?\\d+)",
        Tve = new RegExp("^" + bve + "|" + Eve + "$");

    function Sve(t) {
        const e = Tve.exec(`${t}`);
        return e === null ? ["", ""] : e[1] ? [e[1], e[2]] : [e[4], e[3]]
    }
    var Z3 = {};

    function Vu(t) {
        return typeof t == "string" ? Z3[t] || (Z3[t] = wve(t)) : t6(t) ? Vu(Cve(t)) : e6(t) ? Vu(t.name) : yy
    }
    var X3 = [0, 2, 4, 5, 7, 9, 11],
        c6 = "PMMPPMM";

    function wve(t) {
        const e = Sve(t);
        if (e[0] === "") return yy;
        const n = +e[0],
            r = e[1],
            s = (Math.abs(n) - 1) % 7,
            i = c6[s];
        if (i === "M" && r === "P") return yy;
        const a = i === "M" ? "majorable" : "perfectable",
            c = "" + n + r,
            u = n < 0 ? -1 : 1,
            h = n === 8 || n === -8 ? n : u * (s + 1),
            d = Ave(a, r),
            p = Math.floor((Math.abs(n) - 1) / 7),
            m = u * (X3[s] + d + 12 * p),
            _ = (u * (X3[s] + d) % 12 + 12) % 12,
            y = s6({
                step: s,
                alt: d,
                oct: p,
                dir: u
            });
        return {
            empty: !1,
            name: c,
            num: n,
            q: r,
            step: s,
            alt: d,
            dir: u,
            type: a,
            simple: h,
            semitones: m,
            chroma: _,
            coord: y,
            oct: p
        }
    }

    function Ove(t, e) {
        const [n, r = 0] = t, s = n * 7 + r * 12 < 0, i = e || s ? [-n, -r, -1] : [n, r, 1];
        return Vu(i6(i))
    }

    function Ave(t, e) {
        return e === "M" && t === "majorable" || e === "P" && t === "perfectable" ? 0 : e === "m" && t === "majorable" ? -1 : /^A+$/.test(e) ? e.length : /^d+$/.test(e) ? -1 * (t === "perfectable" ? e.length : e.length + 1) : 0
    }

    function Cve(t) {
        const {
            step: e,
            alt: n,
            oct: r = 0,
            dir: s
        } = t;
        if (!s) return "";
        const i = e + 1 + 7 * r,
            a = i === 0 ? e + 1 : i,
            c = s < 0 ? "-" : "",
            u = c6[e] === "M" ? "majorable" : "perfectable";
        return c + a + kve(u, n)
    }

    function kve(t, e) {
        return e === 0 ? t === "majorable" ? "M" : "P" : e === -1 && t === "majorable" ? "m" : e > 0 ? Sp("A", e) : Sp("d", t === "perfectable" ? e : e + 1)
    }

    function Io(t, e) {
        const n = Bt(t),
            r = Array.isArray(e) ? e : Vu(e).coord;
        if (n.empty || !r || r.length < 2) return "";
        const s = n.coord,
            i = s.length === 1 ? [s[0] + r[0]] : [s[0] + r[0], s[1] + r[1]];
        return gve(i).name
    }

    function Rm(t, e) {
        const n = t.length;
        return r => {
            if (!e) return "";
            const s = r < 0 ? (n - -r % n) % n : r % n,
                i = Math.floor(r / n),
                a = Io(e, [0, i]);
            return Io(a, t[s])
        }
    }

    function Ive(t, e) {
        const n = Bt(t),
            r = Bt(e);
        if (n.empty || r.empty) return "";
        const s = n.coord,
            i = r.coord,
            a = i[0] - s[0],
            c = s.length === 2 && i.length === 2 ? i[1] - s[1] : -Math.floor(a * 7 / 12),
            u = r.height === n.height && r.midi !== null && n.midi !== null && n.step > r.step;
        return Ove([a, c], u).name
    }

    function Nve(t, e) {
        const n = [];
        for (; e--; n[e] = e + t);
        return n
    }

    function xve(t, e) {
        const n = [];
        for (; e--; n[e] = t - e);
        return n
    }

    function Pve(t, e) {
        return t < e ? Nve(t, e - t + 1) : xve(t, t - e + 1)
    }

    function Eh(t, e) {
        const n = e.length,
            r = (t % n + n) % n;
        return e.slice(r, n).concat(e.slice(0, r))
    }

    function Rve(t) {
        return t.filter(e => e === 0 || e)
    }
    var ka = {
            empty: !0,
            name: "",
            setNum: 0,
            chroma: "000000000000",
            normalized: "000000000000",
            intervals: []
        },
        l6 = t => Number(t).toString(2),
        J3 = t => parseInt(t, 2),
        Mve = /^[01]{12}$/;

    function z0(t) {
        return Mve.test(t)
    }
    var Dve = t => typeof t == "number" && t >= 0 && t <= 4095,
        $ve = t => t && z0(t.chroma),
        Q3 = {
            [ka.chroma]: ka
        };

    function No(t) {
        const e = z0(t) ? t : Dve(t) ? l6(t) : Array.isArray(t) ? jve(t) : $ve(t) ? t.chroma : ka.chroma;
        return Q3[e] = Q3[e] || qve(e)
    }
    var Lve = t => No(t).chroma,
        Fve = ["1P", "2m", "2M", "3m", "3M", "4P", "5d", "5P", "6m", "6M", "7m", "7M"];

    function Uve(t) {
        const e = [];
        for (let n = 0; n < 12; n++) t.charAt(n) === "1" && e.push(Fve[n]);
        return e
    }

    function u6(t, e = !0) {
        const r = No(t).chroma.split("");
        return Rve(r.map((s, i) => {
            const a = Eh(i, r);
            return e && a[0] === "0" ? null : a.join("")
        }))
    }

    function Z0(t) {
        const e = No(t).setNum;
        return n => {
            const r = No(n).setNum;
            return e && e !== r && (r & e) === r
        }
    }

    function X0(t) {
        const e = No(t).setNum;
        return n => {
            const r = No(n).setNum;
            return e && e !== r && (r | e) === r
        }
    }

    function Bve(t) {
        const e = t.split("");
        return e.map((n, r) => Eh(r, e).join(""))
    }

    function qve(t) {
        const e = J3(t),
            n = Bve(t).map(J3).filter(i => i >= 2048).sort()[0],
            r = l6(n),
            s = Uve(t);
        return {
            empty: !1,
            name: "",
            setNum: e,
            chroma: t,
            normalized: r,
            intervals: s
        }
    }

    function jve(t) {
        if (t.length === 0) return ka.chroma;
        let e;
        const n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (let r = 0; r < t.length; r++) e = Bt(t[r]), e.empty && (e = Vu(t[r])), e.empty || (n[e.chroma] = 1);
        return n.join("")
    }
    var Vve = [
            ["1P 3M 5P", "major", "M ^  maj"],
            ["1P 3M 5P 7M", "major seventh", "maj7  ma7 M7 Maj7 ^7"],
            ["1P 3M 5P 7M 9M", "major ninth", "maj9 9 ^9"],
            ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
            ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
            ["1P 3M 5P 6M 9M", "sixth/ninth", "6/9 69 M69"],
            ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
            ["1P 3M 5P 7M 11A", "major seventh sharp eleventh", "maj#4 #4 #11 M7#11 ^7#11 maj7#11"],
            ["1P 3m 5P", "minor", "m min -"],
            ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
            ["1P 3m 5P 7M", "minor/major seventh", "m/ma7 m/maj7 mM7 mMaj7 m/M7 -7 m -^7"],
            ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
            ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
            ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
            ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
            ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
            ["1P 3m 5d", "diminished", "dim  o"],
            ["1P 3m 5d 7d", "diminished seventh", "dim7 7 o7"],
            ["1P 3m 5d 7m", "half-diminished", "m7b5  -7b5 h7 h"],
            ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
            ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
            ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
            ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
            ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
            ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
            ["1P 3M 7m 9m", "altered", "alt7"],
            ["1P 4P 5P", "suspended fourth", "sus4 sus"],
            ["1P 2M 5P", "suspended second", "sus2"],
            ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
            ["1P 5P 7m 9M 11P", "eleventh", "11"],
            ["1P 4P 5P 7m 9m", "suspended fourth flat ninth", "b9sus phryg 7b9sus 7b9sus4"],
            ["1P 5P", "fifth", "5"],
            ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
            ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
            ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
            ["1P 3M 5P 7M 9M 11A", "major sharp eleventh (lydian)", "maj9#11 9#11 ^9#11"],
            ["1P 2M 4P 5P", "", "sus24 sus4add9"],
            ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
            ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
            ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
            ["1P 3M 5A 7m 9M", "", "9#5 9+"],
            ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
            ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
            ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
            ["1P 3M 5A 9A", "", "+add#9"],
            ["1P 3M 5A 9M", "", "M#5add9 +add9"],
            ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
            ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
            ["1P 3M 5P 6M 9M 11A", "", "69#11"],
            ["1P 3m 5P 6M 9M", "", "m69 -69"],
            ["1P 3M 5P 6m 7m", "", "7b6"],
            ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
            ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
            ["1P 3M 5P 7M 9m", "", "M7b9"],
            ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
            ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
            ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
            ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
            ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
            ["1P 3M 5P 7m 9A 13M", "", "13#9"],
            ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
            ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
            ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
            ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
            ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
            ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
            ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
            ["1P 3M 5P 7m 9m 13M", "", "13b9"],
            ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
            ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
            ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
            ["1P 3M 5P 9m", "", "Maddb9"],
            ["1P 3M 5d", "", "Mb5"],
            ["1P 3M 5d 6M 7m 9M", "", "13b5"],
            ["1P 3M 5d 7M", "", "M7b5"],
            ["1P 3M 5d 7M 9M", "", "M9b5"],
            ["1P 3M 5d 7m", "", "7b5"],
            ["1P 3M 5d 7m 9M", "", "9b5"],
            ["1P 3M 7m", "", "7no5"],
            ["1P 3M 7m 13m", "", "7b13"],
            ["1P 3M 7m 9M", "", "9no5"],
            ["1P 3M 7m 9M 13M", "", "13no5"],
            ["1P 3M 7m 9M 13m", "", "9b13"],
            ["1P 3m 4P 5P", "", "madd4"],
            ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
            ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
            ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
            ["1P 3m 5P 9M", "", "madd9"],
            ["1P 3m 5d 6M 7M", "", "o7M7"],
            ["1P 3m 5d 7M", "", "oM7"],
            ["1P 3m 6m 7M", "", "mb6M7"],
            ["1P 3m 6m 7m", "", "m7#5"],
            ["1P 3m 6m 7m 9M", "", "m9#5"],
            ["1P 3m 5A 7m 9M 11P", "", "m11A"],
            ["1P 3m 6m 9m", "", "mb6b9"],
            ["1P 2M 3m 5d 7m", "", "m9b5"],
            ["1P 4P 5A 7M", "", "M7#5sus4"],
            ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
            ["1P 4P 5A 7m", "", "7#5sus4"],
            ["1P 4P 5P 7M", "", "M7sus4"],
            ["1P 4P 5P 7M 9M", "", "M9sus4"],
            ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
            ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
            ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
            ["1P 4P 7m 10m", "", "4 quartal"],
            ["1P 5P 7m 9m 11P", "", "11b9"]
        ],
        Gve = Vve,
        Wve = {
            ...ka,
            name: "",
            quality: "Unknown",
            intervals: [],
            aliases: []
        },
        J0 = [],
        ou = {};

    function Hve(t) {
        return ou[t] || Wve
    }

    function Mm() {
        return J0.slice()
    }

    function Kve(t, e, n) {
        const r = zve(t),
            s = {
                ...No(t),
                name: n || "",
                quality: r,
                intervals: t,
                aliases: e
            };
        J0.push(s), s.name && (ou[s.name] = s), ou[s.setNum] = s, ou[s.chroma] = s, s.aliases.forEach(i => Yve(s, i))
    }

    function Yve(t, e) {
        ou[e] = t
    }

    function zve(t) {
        const e = n => t.indexOf(n) !== -1;
        return e("5A") ? "Augmented" : e("3M") ? "Major" : e("5d") ? "Diminished" : e("3m") ? "Minor" : "Unknown"
    }
    Gve.forEach(([t, e, n]) => Kve(t.split(" "), n.split(" "), e));
    J0.sort((t, e) => t.setNum - e.setNum);
    var Zve = t => {
        const e = t.reduce((n, r) => {
            const s = Bt(r).chroma;
            return s !== void 0 && (n[s] = n[s] || Bt(r).name), n
        }, {});
        return n => e[n]
    };

    function Xve(t, e = {}) {
        const n = t.map(s => Bt(s).pc).filter(s => s);
        return Bt.length === 0 ? [] : s0e(n, 1, e).filter(s => s.weight).sort((s, i) => i.weight - s.weight).map(s => s.name)
    }
    var Dm = {
            anyThirds: 384,
            perfectFifth: 16,
            nonPerfectFifths: 40,
            anySeventh: 3
        },
        $m = t => e => !!(e & t),
        Jve = $m(Dm.anyThirds),
        Qve = $m(Dm.perfectFifth),
        e0e = $m(Dm.anySeventh),
        t0e = $m(Dm.nonPerfectFifths);

    function n0e(t) {
        const e = parseInt(t.chroma, 2);
        return Jve(e) && Qve(e) && e0e(e)
    }

    function r0e(t) {
        const e = parseInt(t, 2);
        return t0e(e) ? t : (e | 16).toString(2)
    }

    function s0e(t, e, n) {
        const r = t[0],
            s = Bt(r).chroma,
            i = Zve(t),
            a = u6(t, !1),
            c = [];
        return a.forEach((u, h) => {
            const d = n.assumePerfectFifth && r0e(u);
            Mm().filter(m => n.assumePerfectFifth && n0e(m) ? m.chroma === d : m.chroma === u).forEach(m => {
                const _ = m.aliases[0],
                    y = i(h);
                h !== s ? c.push({
                    weight: .5 * e,
                    name: `${y}${_}/${r}`
                }) : c.push({
                    weight: 1 * e,
                    name: `${y}${_}`
                })
            })
        }), c
    }
    var i0e = [
            ["1P 2M 3M 5P 6M", "major pentatonic", "pentatonic"],
            ["1P 2M 3M 4P 5P 6M 7M", "major", "ionian"],
            ["1P 2M 3m 4P 5P 6m 7m", "minor", "aeolian"],
            ["1P 2M 3m 3M 5P 6M", "major blues"],
            ["1P 3m 4P 5d 5P 7m", "minor blues", "blues"],
            ["1P 2M 3m 4P 5P 6M 7M", "melodic minor"],
            ["1P 2M 3m 4P 5P 6m 7M", "harmonic minor"],
            ["1P 2M 3M 4P 5P 6M 7m 7M", "bebop"],
            ["1P 2M 3m 4P 5d 6m 6M 7M", "diminished", "whole-half diminished"],
            ["1P 2M 3m 4P 5P 6M 7m", "dorian"],
            ["1P 2M 3M 4A 5P 6M 7M", "lydian"],
            ["1P 2M 3M 4P 5P 6M 7m", "mixolydian", "dominant"],
            ["1P 2m 3m 4P 5P 6m 7m", "phrygian"],
            ["1P 2m 3m 4P 5d 6m 7m", "locrian"],
            ["1P 3M 4P 5P 7M", "ionian pentatonic"],
            ["1P 3M 4P 5P 7m", "mixolydian pentatonic", "indian"],
            ["1P 2M 4P 5P 6M", "ritusen"],
            ["1P 2M 4P 5P 7m", "egyptian"],
            ["1P 3M 4P 5d 7m", "neopolitan major pentatonic"],
            ["1P 3m 4P 5P 6m", "vietnamese 1"],
            ["1P 2m 3m 5P 6m", "pelog"],
            ["1P 2m 4P 5P 6m", "kumoijoshi"],
            ["1P 2M 3m 5P 6m", "hirajoshi"],
            ["1P 2m 4P 5d 7m", "iwato"],
            ["1P 2m 4P 5P 7m", "in-sen"],
            ["1P 3M 4A 5P 7M", "lydian pentatonic", "chinese"],
            ["1P 3m 4P 6m 7m", "malkos raga"],
            ["1P 3m 4P 5d 7m", "locrian pentatonic", "minor seven flat five pentatonic"],
            ["1P 3m 4P 5P 7m", "minor pentatonic", "vietnamese 2"],
            ["1P 3m 4P 5P 6M", "minor six pentatonic"],
            ["1P 2M 3m 5P 6M", "flat three pentatonic", "kumoi"],
            ["1P 2M 3M 5P 6m", "flat six pentatonic"],
            ["1P 2m 3M 5P 6M", "scriabin"],
            ["1P 3M 5d 6m 7m", "whole tone pentatonic"],
            ["1P 3M 4A 5A 7M", "lydian #5P pentatonic"],
            ["1P 3M 4A 5P 7m", "lydian dominant pentatonic"],
            ["1P 3m 4P 5P 7M", "minor #7M pentatonic"],
            ["1P 3m 4d 5d 7m", "super locrian pentatonic"],
            ["1P 2M 3m 4P 5P 7M", "minor hexatonic"],
            ["1P 2A 3M 5P 5A 7M", "augmented"],
            ["1P 2M 4P 5P 6M 7m", "piongio"],
            ["1P 2m 3M 4A 6M 7m", "prometheus neopolitan"],
            ["1P 2M 3M 4A 6M 7m", "prometheus"],
            ["1P 2m 3M 5d 6m 7m", "mystery #1"],
            ["1P 2m 3M 4P 5A 6M", "six tone symmetric"],
            ["1P 2M 3M 4A 5A 6A", "whole tone", "messiaen's mode #1"],
            ["1P 2m 4P 4A 5P 7M", "messiaen's mode #5"],
            ["1P 2M 3M 4P 5d 6m 7m", "locrian major", "arabian"],
            ["1P 2m 3M 4A 5P 6m 7M", "double harmonic lydian"],
            ["1P 2m 2A 3M 4A 6m 7m", "altered", "super locrian", "diminished whole tone", "pomeroy"],
            ["1P 2M 3m 4P 5d 6m 7m", "locrian #2", "half-diminished", "aeolian b5"],
            ["1P 2M 3M 4P 5P 6m 7m", "mixolydian b6", "melodic minor fifth mode", "hindu"],
            ["1P 2M 3M 4A 5P 6M 7m", "lydian dominant", "lydian b7", "overtone"],
            ["1P 2M 3M 4A 5A 6M 7M", "lydian augmented"],
            ["1P 2m 3m 4P 5P 6M 7m", "dorian b2", "phrygian #6", "melodic minor second mode"],
            ["1P 2m 3m 4d 5d 6m 7d", "ultralocrian", "superlocrian bb7", "superlocrian diminished"],
            ["1P 2m 3m 4P 5d 6M 7m", "locrian 6", "locrian natural 6", "locrian sharp 6"],
            ["1P 2A 3M 4P 5P 5A 7M", "augmented heptatonic"],
            ["1P 2M 3m 4A 5P 6M 7m", "dorian #4", "ukrainian dorian", "romanian minor", "altered dorian"],
            ["1P 2M 3m 4A 5P 6M 7M", "lydian diminished"],
            ["1P 2M 3M 4A 5A 7m 7M", "leading whole tone"],
            ["1P 2M 3M 4A 5P 6m 7m", "lydian minor"],
            ["1P 2m 3M 4P 5P 6m 7m", "phrygian dominant", "spanish", "phrygian major"],
            ["1P 2m 3m 4P 5P 6m 7M", "balinese"],
            ["1P 2m 3m 4P 5P 6M 7M", "neopolitan major"],
            ["1P 2M 3M 4P 5P 6m 7M", "harmonic major"],
            ["1P 2m 3M 4P 5P 6m 7M", "double harmonic major", "gypsy"],
            ["1P 2M 3m 4A 5P 6m 7M", "hungarian minor"],
            ["1P 2A 3M 4A 5P 6M 7m", "hungarian major"],
            ["1P 2m 3M 4P 5d 6M 7m", "oriental"],
            ["1P 2m 3m 3M 4A 5P 7m", "flamenco"],
            ["1P 2m 3m 4A 5P 6m 7M", "todi raga"],
            ["1P 2m 3M 4P 5d 6m 7M", "persian"],
            ["1P 2m 3M 5d 6m 7m 7M", "enigmatic"],
            ["1P 2M 3M 4P 5A 6M 7M", "major augmented", "major #5", "ionian augmented", "ionian #5"],
            ["1P 2A 3M 4A 5P 6M 7M", "lydian #9"],
            ["1P 2m 2M 4P 4A 5P 6m 7M", "messiaen's mode #4"],
            ["1P 2m 3M 4P 4A 5P 6m 7M", "purvi raga"],
            ["1P 2m 3m 3M 4P 5P 6m 7m", "spanish heptatonic"],
            ["1P 2M 3m 3M 4P 5P 6M 7m", "bebop minor"],
            ["1P 2M 3M 4P 5P 5A 6M 7M", "bebop major"],
            ["1P 2m 3m 4P 5d 5P 6m 7m", "bebop locrian"],
            ["1P 2M 3m 4P 5P 6m 7m 7M", "minor bebop"],
            ["1P 2M 3M 4P 5d 5P 6M 7M", "ichikosucho"],
            ["1P 2M 3m 4P 5P 6m 6M 7M", "minor six diminished"],
            ["1P 2m 3m 3M 4A 5P 6M 7m", "half-whole diminished", "dominant diminished", "messiaen's mode #2"],
            ["1P 3m 3M 4P 5P 6M 7m 7M", "kafi raga"],
            ["1P 2M 3M 4P 4A 5A 6A 7M", "messiaen's mode #6"],
            ["1P 2M 3m 3M 4P 5d 5P 6M 7m", "composite blues"],
            ["1P 2M 3m 3M 4A 5P 6m 7m 7M", "messiaen's mode #3"],
            ["1P 2m 2M 3m 4P 4A 5P 6m 6M 7M", "messiaen's mode #7"],
            ["1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M", "chromatic"]
        ],
        o0e = i0e,
        a0e = {
            ...ka,
            intervals: [],
            aliases: []
        },
        Q0 = [],
        au = {};

    function c0e() {
        return Q0.map(t => t.name)
    }

    function h6(t) {
        return au[t] || a0e
    }

    function Lm() {
        return Q0.slice()
    }

    function l0e(t, e, n = []) {
        const r = {
            ...No(t),
            name: e,
            intervals: t,
            aliases: n
        };
        return Q0.push(r), au[r.name] = r, au[r.setNum] = r, au[r.chroma] = r, r.aliases.forEach(s => u0e(r, s)), r
    }

    function u0e(t, e) {
        au[e] = t
    }
    o0e.forEach(([t, e, ...n]) => l0e(t.split(" "), e, n));
    var vy = {
            empty: !0,
            name: "",
            symbol: "",
            root: "",
            rootDegree: 0,
            type: "",
            tonic: null,
            setNum: NaN,
            quality: "Unknown",
            chroma: "",
            normalized: "",
            aliases: [],
            notes: [],
            intervals: []
        },
        h0e = /^(6|64|7|9|11|13)$/;

    function eb(t) {
        const [e, n, r, s] = a6(t);
        return e === "" ? ["", t] : e === "A" && s === "ug" ? ["", "aug"] : !s && (r === "4" || r === "5") ? [e + n, r] : h0e.test(r) ? [e + n, r + s] : [e + n + r, s]
    }

    function $a(t) {
        if (t === "") return vy;
        if (Array.isArray(t) && t.length === 2) return ed(t[1], t[0]); {
            const [e, n] = eb(t), r = ed(n, e);
            return r.empty ? ed(t) : r
        }
    }

    function ed(t, e, n) {
        const r = Hve(t),
            s = Bt(e || ""),
            i = Bt(n || "");
        if (r.empty || e && s.empty || n && i.empty) return vy;
        const a = Ive(s.pc, i.pc),
            c = r.intervals.indexOf(a) + 1;
        if (!i.empty && !c) return vy;
        const u = Array.from(r.intervals);
        for (let m = 1; m < c; m++) {
            const _ = u[0][0],
                y = u[0][1],
                v = parseInt(_, 10) + 7;
            u.push(`${v}${y}`), u.shift()
        }
        const h = s.empty ? [] : u.map(m => Io(s, m));
        t = r.aliases.indexOf(t) !== -1 ? t : r.aliases[0];
        const d = `${s.empty?"":s.pc}${t}${i.empty||c<=1?"":"/"+i.pc}`,
            p = `${e?s.pc+" ":""}${r.name}${c>1&&n?" over "+i.pc:""}`;
        return {
            ...r,
            name: p,
            symbol: d,
            type: r.name,
            root: i.name,
            intervals: u,
            rootDegree: c,
            tonic: s.name,
            notes: h
        }
    }
    var f0e = Qk("Chord.chord", "Chord.get", $a);

    function d0e(t, e) {
        const [n, r] = eb(t);
        return n ? Io(n, e) + r : t
    }

    function p0e(t) {
        const e = $a(t),
            n = X0(e.chroma);
        return Lm().filter(r => n(r.chroma)).map(r => r.name)
    }

    function m0e(t) {
        const e = $a(t),
            n = X0(e.chroma);
        return Mm().filter(r => n(r.chroma)).map(r => e.tonic + r.aliases[0])
    }

    function g0e(t) {
        const e = $a(t),
            n = Z0(e.chroma);
        return Mm().filter(r => n(r.chroma)).map(r => e.tonic + r.aliases[0])
    }

    function _0e(t) {
        const {
            intervals: e,
            tonic: n
        } = $a(t), r = Rm(e, n);
        return s => s ? r(s > 0 ? s - 1 : s) : ""
    }

    function y0e(t) {
        const {
            intervals: e,
            tonic: n
        } = $a(t);
        return Rm(e, n)
    }
    var e5 = {
        getChord: ed,
        get: $a,
        detect: Xve,
        chordScales: p0e,
        extended: m0e,
        reduced: g0e,
        tokenize: eb,
        transpose: d0e,
        degrees: _0e,
        steps: y0e,
        chord: f0e
    };

    function f6(t) {
        return +t >= 0 && +t <= 127
    }

    function v0e(t) {
        if (f6(t)) return +t;
        const e = Bt(t);
        return e.empty ? null : e.midi
    }

    function b0e(t, e = 440) {
        return Math.pow(2, (t - 69) / 12) * e
    }
    var E0e = Math.log(2),
        T0e = Math.log(440);

    function tb(t) {
        const e = 12 * (Math.log(t) - T0e) / E0e + 69;
        return Math.round(e * 100) / 100
    }
    var S0e = "C C# D D# E F F# G G# A A# B".split(" "),
        w0e = "C Db D Eb E F Gb G Ab A Bb B".split(" ");

    function La(t, e = {}) {
        if (isNaN(t) || t === -1 / 0 || t === 1 / 0) return "";
        t = Math.round(t);
        const r = (e.sharps === !0 ? S0e : w0e)[t % 12];
        if (e.pitchClass) return r;
        const s = Math.floor(t / 12) - 1;
        return r + s
    }

    function nb(t) {
        return t % 12
    }

    function O0e(t) {
        return t.split("").reduce((e, n, r) => (r < 12 && n === "1" && e.push(r), e), [])
    }

    function A0e(t) {
        return t.map(nb).sort((e, n) => e - n).filter((e, n, r) => n === 0 || e !== r[n - 1])
    }

    function rb(t) {
        return Array.isArray(t) ? A0e(t) : O0e(t)
    }

    function C0e(t) {
        const e = rb(t);
        return n => {
            const r = nb(n);
            for (let s = 0; s < 12; s++) {
                if (e.includes(r + s)) return n + s;
                if (e.includes(r - s)) return n - s
            }
        }
    }

    function d6(t, e) {
        const n = rb(t),
            r = n.length;
        return s => {
            const i = s < 0 ? (r - -s % r) % r : s % r,
                a = Math.floor(s / r);
            return n[i] + a * 12 + e
        }
    }

    function k0e(t, e) {
        const n = d6(t, e);
        return r => {
            if (r !== 0) return n(r > 0 ? r - 1 : r)
        }
    }
    var I0e = {
            chroma: nb,
            freqToMidi: tb,
            isMidi: f6,
            midiToFreq: b0e,
            midiToNoteName: La,
            pcsetNearest: C0e,
            pcset: rb,
            pcsetDegrees: k0e,
            pcsetSteps: d6,
            toMidi: v0e
        },
        N0e = ["C", "D", "E", "F", "G", "A", "B"],
        p6 = t => t.name,
        m6 = t => t.map(Bt).filter(e => !e.empty);

    function x0e(t) {
        return t === void 0 ? N0e.slice() : Array.isArray(t) ? m6(t).map(p6) : []
    }
    var Is = Bt,
        P0e = t => Is(t).name,
        R0e = t => Is(t).pc,
        M0e = t => Is(t).acc,
        D0e = t => Is(t).oct,
        $0e = t => Is(t).midi,
        L0e = t => Is(t).freq,
        F0e = t => Is(t).chroma;

    function g6(t) {
        return La(t)
    }

    function U0e(t) {
        return La(tb(t))
    }

    function B0e(t) {
        return La(tb(t), {
            sharps: !0
        })
    }

    function q0e(t) {
        return La(t, {
            sharps: !0
        })
    }
    var Th = Io,
        j0e = Io,
        _6 = t => e => Th(e, t),
        V0e = _6,
        y6 = t => e => Th(t, e),
        G0e = y6;

    function v6(t, e) {
        return Th(t, [e, 0])
    }
    var W0e = v6;

    function H0e(t, e) {
        return Th(t, [0, e])
    }
    var sb = (t, e) => t.height - e.height,
        K0e = (t, e) => e.height - t.height;

    function b6(t, e) {
        return e = e || sb, m6(t).sort(e).map(p6)
    }

    function E6(t) {
        return b6(t, sb).filter((e, n, r) => n === 0 || e !== r[n - 1])
    }
    var Y0e = t => {
        const e = Is(t);
        return e.empty ? "" : La(e.midi || e.chroma, {
            sharps: e.alt > 0,
            pitchClass: e.midi === null
        })
    };

    function T6(t, e) {
        const n = Is(t);
        if (n.empty) return "";
        const r = Is(e || La(n.midi || n.chroma, {
            sharps: n.alt < 0,
            pitchClass: !0
        }));
        if (r.empty || r.chroma !== n.chroma) return "";
        if (n.oct === void 0) return r.pc;
        const s = n.chroma - n.alt,
            i = r.chroma - r.alt,
            a = s > 11 || i < 0 ? -1 : s < 0 || i > 11 ? 1 : 0,
            c = n.oct + a;
        return r.pc + c
    }
    var t5 = {
            names: x0e,
            get: Is,
            name: P0e,
            pitchClass: R0e,
            accidentals: M0e,
            octave: D0e,
            midi: $0e,
            ascending: sb,
            descending: K0e,
            sortedNames: b6,
            sortedUniqNames: E6,
            fromMidi: g6,
            fromMidiSharps: q0e,
            freq: L0e,
            fromFreq: U0e,
            fromFreqSharps: B0e,
            chroma: F0e,
            transpose: Th,
            tr: j0e,
            transposeBy: _6,
            trBy: V0e,
            transposeFrom: y6,
            trFrom: G0e,
            transposeFifths: v6,
            transposeOctaves: H0e,
            trFifths: W0e,
            simplify: Y0e,
            enharmonic: T6
        },
        ib = [
            [0, 2773, 0, "ionian", "", "Maj7", "major"],
            [1, 2902, 2, "dorian", "m", "m7"],
            [2, 3418, 4, "phrygian", "m", "m7"],
            [3, 2741, -1, "lydian", "", "Maj7"],
            [4, 2774, 1, "mixolydian", "", "7"],
            [5, 2906, 3, "aeolian", "m", "m7", "minor"],
            [6, 3434, 5, "locrian", "dim", "m7b5"]
        ],
        n5 = {
            ...ka,
            name: "",
            alt: 0,
            modeNum: NaN,
            triad: "",
            seventh: "",
            aliases: []
        },
        z0e = ib.map(Z0e),
        by = {};
    z0e.forEach(t => {
        by[t.name] = t, t.aliases.forEach(e => {
            by[e] = t
        })
    });

    function S6(t) {
        return typeof t == "string" ? by[t.toLowerCase()] || n5 : t && t.name ? S6(t.name) : n5
    }

    function Z0e(t) {
        const [e, n, r, s, i, a, c] = t, u = c ? [c] : [], h = Number(n).toString(2);
        return {
            empty: !1,
            intervals: h6(s).intervals,
            modeNum: e,
            chroma: h,
            normalized: h,
            name: s,
            setNum: n,
            alt: r,
            triad: i,
            seventh: a,
            aliases: u
        }
    }

    function w6(t) {
        return (e, n) => {
            const r = S6(e);
            if (r.empty) return [];
            const s = Eh(r.modeNum, t),
                i = r.intervals.map(a => Io(n, a));
            return s.map((a, c) => i[c] + a)
        }
    }
    w6(ib.map(t => t[4]));
    w6(ib.map(t => t[5]));
    var X0e = {
        empty: !0,
        name: "",
        type: "",
        tonic: null,
        setNum: NaN,
        chroma: "",
        normalized: "",
        aliases: [],
        notes: [],
        intervals: []
    };

    function O6(t) {
        if (typeof t != "string") return ["", ""];
        const e = t.indexOf(" "),
            n = Bt(t.substring(0, e));
        if (n.empty) {
            const s = Bt(t);
            return s.empty ? ["", t] : [s.name, ""]
        }
        const r = t.substring(n.name.length + 1);
        return [n.name, r.length ? r : ""]
    }
    var J0e = c0e;

    function ri(t) {
        const e = Array.isArray(t) ? t : O6(t),
            n = Bt(e[0]).name,
            r = h6(e[1]);
        if (r.empty) return X0e;
        const s = r.name,
            i = n ? r.intervals.map(c => Io(n, c)) : [],
            a = n ? n + " " + s : s;
        return {
            ...r,
            name: a,
            type: s,
            tonic: n,
            notes: i
        }
    }
    var Q0e = Qk("Scale.scale", "Scale.get", ri);

    function ebe(t, e = {}) {
        const n = Lve(t),
            r = Bt(e.tonic ?? t[0] ?? ""),
            s = r.chroma;
        if (s === void 0) return [];
        const i = n.split("");
        i[s] = "1";
        const a = Eh(s, i).join(""),
            c = Lm().find(h => h.chroma === a),
            u = [];
        return c && u.push(r.name + " " + c.name), e.match === "exact" || A6(a).forEach(h => {
            u.push(r.name + " " + h)
        }), u
    }

    function tbe(t) {
        const e = ri(t),
            n = Z0(e.chroma);
        return Mm().filter(r => n(r.chroma)).map(r => r.aliases[0])
    }

    function A6(t) {
        const e = z0(t) ? t : ri(t).chroma,
            n = X0(e);
        return Lm().filter(r => n(r.chroma)).map(r => r.name)
    }

    function nbe(t) {
        const e = Z0(ri(t).chroma);
        return Lm().filter(n => e(n.chroma)).map(n => n.name)
    }

    function C6(t) {
        const e = t.map(s => Bt(s).pc).filter(s => s),
            n = e[0],
            r = E6(e);
        return Eh(r.indexOf(n), r)
    }

    function rbe(t) {
        const e = ri(t);
        if (e.empty) return [];
        const n = e.tonic ? e.notes : e.intervals;
        return u6(e.chroma).map((r, s) => {
            const i = ri(r).name;
            return i ? [n[s], i] : ["", ""]
        }).filter(r => r[0])
    }

    function sbe(t) {
        const e = Array.isArray(t) ? C6(t) : ri(t).notes,
            n = e.map(r => Bt(r).chroma);
        return r => {
            const s = Bt(typeof r == "number" ? g6(r) : r),
                i = s.height;
            if (i === void 0) return;
            const a = i % 12,
                c = n.indexOf(a);
            if (c !== -1) return T6(s.name, e[c])
        }
    }

    function ibe(t) {
        const e = sbe(t);
        return (n, r) => {
            const s = Bt(n).height,
                i = Bt(r).height;
            return s === void 0 || i === void 0 ? [] : Pve(s, i).map(e).filter(a => a)
        }
    }

    function obe(t) {
        const {
            intervals: e,
            tonic: n
        } = ri(t), r = Rm(e, n);
        return s => s ? r(s > 0 ? s - 1 : s) : ""
    }

    function abe(t) {
        const {
            intervals: e,
            tonic: n
        } = ri(t);
        return Rm(e, n)
    }
    var r5 = {
        degrees: obe,
        detect: ebe,
        extended: A6,
        get: ri,
        modeNames: rbe,
        names: J0e,
        rangeOf: ibe,
        reduced: nbe,
        scaleChords: tbe,
        scaleNotes: C6,
        steps: abe,
        tokenize: O6,
        scale: Q0e
    };
    class wp {
        static getChordNameFromMidi(e) {
            const n = e.sort().map(r => t5.fromMidi(r));
            return this.getChordNameFromNotes(n)
        }
        static getChordNameFromFrequencies(e) {
            const n = e.sort().map(r => t5.fromFreq(r));
            return this.getChordNameFromNotes(n)
        }
        static getChordNameFromNotes(e, n = "Unknown") {
            const r = [],
                s = e5.detect(e);
            if (!s.length) return [];
            r.push(s[0]);
            let i = s[0];
            const a = s[0].split("/");
            a.length > 1 && (i = a[0], r.push(i));
            const c = e5.get(i);
            if (c.quality === "Major") r.push(`${c.tonic}`);
            else if (c.quality === "Minor") r.push(`${c.tonic}m`);
            else if (c.quality === "Diminished") {
                r.push(`${c.tonic}m`);
                const u = c.intervals.findIndex(h => h.includes("3"));
                u !== -1 && r.push(`${c.notes[u]}m`)
            }
            return n === "Major" ? r.push(`${c.tonic}`) : n === "Minor" && r.push(`${c.tonic}m`), r.map(u => {
                const h = /M/g,
                    d = /\//g;
                return u.replace(h, "").replace(d, "|").toLowerCase()
            })
        }
        static getRandomNumber(e, n) {
            return Math.floor(Math.random() * (n - e + 1) + e)
        }
        static getNotesInScale(e, n) {
            const r = r5.get(e);
            return n.map(s => {
                const i = s === 8 ? r5.degrees(r.name)(8) : r.notes[s - 1];
                return I0e.toMidi(i) ?? 60
            })
        }
    }
    class Ls {
        constructor(e, n) {
            this.notes = new Set, this.isMidiKeyed = !0, this.rotationType = n.rotationType ?? "serial", n.isHarmonic && (this.isMidiKeyed = !1);
            let r;
            Array.isArray(e) ? (this.isMidiKeyed = !1, r = {
                samples: e
            }) : r = e;
            const s = new Map,
                i = {};
            Object.keys(r).forEach(a => {
                const c = [];
                let u;
                if (this.isMidiKeyed) {
                    const h = qd(a).toMidi();
                    this.notes.add(h), u = `${h}`
                } else u = a.toLowerCase();
                r[a].forEach((h, d) => {
                    i[`${u}:${d}`] = h, i[`${u}:${d}`] = h, c.push(`${u}:${d}`)
                }), s.set(u, {
                    nextIndex: this.rotationType === "serial" ? 0 : wp.getRandomNumber(0, c.length - 1),
                    bufferKeys: c
                })
            }), this.groupMap = s, this.buffers = new vh({
                urls: i,
                onload: n.onload,
                baseUrl: n.baseUrl,
                onerror: n.onerror
            })
        }
        get loaded() {
            return this.buffers.loaded
        }
        findClosest(e) {
            if (!this.isMidiKeyed) return e;
            const n = 96;
            let r = 0;
            for (; r < n;) {
                if (this.notes.has(e + r)) return -r;
                if (this.notes.has(e - r)) return r;
                r += 1
            }
            return e
        }
        get(e) {
            e === void 0 && (e = "samples"), typeof e == "number" && (e = `${e}`);
            const n = this.groupMap.get(e);
            if (!n) return;
            const r = n.bufferKeys[n.nextIndex];
            return r ? (this.rotationType === "random" ? n.nextIndex = wp.getRandomNumber(0, n.bufferKeys.length - 1) : n.nextIndex = n.nextIndex === n.bufferKeys.length - 1 ? 0 : n.nextIndex + 1, this.buffers.get(r)) : void 0
        }
        keys() {
            return Array.from(this.groupMap.keys())
        }
        has(e) {
            return !this.isMidiKeyed || e === void 0 ? !0 : (typeof e == "number" && (e = `${e}`), this.groupMap.has(e))
        }
        dispose() {
            this.buffers.dispose()
        }
        static transformSampleMap(e) {
            const n = {};
            return Object.keys(e.urls).forEach(r => {
                var s, i;
                (s = e.notes) != null && s.length && !e.notes.includes(r) || (i = e.chords) != null && i.length && !e.chords.includes(r) || (n[r] = e.urls[r].map(a => this.transformUrl(a, e.baseUrl, e.ext)))
            }), n
        }
        static transformSampleObject(e) {
            const n = {};
            return Object.keys(e.urls).forEach(r => {
                e.notes && !e.notes.includes(r) || e.chords && !e.chords.includes(r) || (n[r] = this.transformUrl(e.urls[r], e.baseUrl, e.ext))
            }), n
        }
        static transformSampleArray(e) {
            return e.urls.map(n => this.transformUrl(n, e.baseUrl, e.ext))
        }
        static transformUrl(e, n, r) {
            return r || (r = Ot.supportsType("ogg") ? "ogg" : "mp3"), e.includes(`.${r}`) ? `${n}/${e}` : `${n}/${e}.${r}`
        }
    }
    class Gu extends ks {
        constructor() {
            super(Y(Gu.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "OneShotSampler", this.activeSources = new Map;
            const e = Y(Gu.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
            this.buffers = new Ls(e.urls, {
                rotationType: e.rotationType,
                baseUrl: e.baseUrl,
                onload: e.onload,
                onerror: e.onerror
            }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this.isPitchLocked = e.pitchLocked ?? !1, this.restrictToSingleNotes = e.restrictToSingleNotes ?? !1, this.buffers.loaded && Promise.resolve().then(e.onload)
        }
        get loaded() {
            return this.buffers.loaded
        }
        static getDefaults() {
            return Object.assign(ks.getDefaults(), {
                attack: 0,
                baseUrl: "",
                curve: "exponential",
                onload: ht,
                onerror: ht,
                release: .1,
                pitchLocked: !1,
                restrictToSingleNotes: !1,
                rotationType: "serial",
                urls: {}
            })
        }
        triggerAttack(e, n) {
            return Array.isArray(e) || (e = [e]), this.restrictToSingleNotes && e.length > 1 ? this : (e.forEach(r => {
                const s = Nm(new Wn(this.context, r).toFrequency()),
                    i = Math.round(s),
                    a = s - i,
                    c = this.buffers.findClosest(i);
                if (c === null) return;
                const u = i - c,
                    h = Aa(c + a),
                    d = this.buffers.get(u);
                if (!d) return;
                const p = new Qs({
                    url: d,
                    context: this.context,
                    curve: this.curve,
                    playbackRate: this.isPitchLocked ? 1 : h,
                    fadeIn: this.attack,
                    fadeOut: this.release,
                    onended: () => {
                        this.onSourceEnded(i)
                    },
                    loop: !1
                }).connect(this.output);
                p.start(n, 0), this.activeSources.set(i, p)
            }), this)
        }
        triggerAttackRelease(e, n, r) {
            const s = this.toSeconds(r);
            return this.triggerAttack(e, s), this.triggerRelease(s + this.toSeconds(n)), this
        }
        triggerRelease(e, n) {
            return Array.isArray(e) || (e = [e]), this.restrictToSingleNotes && e.length > 1 ? this : (e.forEach(r => {
                const s = new Wn(this.context, r).toMidi(),
                    i = this.activeSources.get(s);
                i && (n ? i.stop(this.toSeconds(n)) : i.stop(this.now()), this.activeSources.delete(s))
            }), this)
        }
        onSourceEnded(e) {
            const n = this.activeSources.get(e);
            n && (n.stop(this.now()), this.activeSources.delete(e))
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
        }
        dispose() {
            return super.dispose(), this.buffers.dispose(), this.activeSources.forEach(e => e.dispose()), this.activeSources.clear(), this
        }
    }
    const dc = class dc {
        constructor(e, n) {
            this.isPlayable = !0, e.urls = this.convertDrumRackKeys(e.urls), n.baseUrl && (e.urls = Ls.transformSampleMap({
                urls: e.urls,
                baseUrl: n.baseUrl,
                ext: n.ext
            })), this.node = new Gu(e)
        }
        attack(e) {
            this.node.triggerAttack(e)
        }
        oneShot(e, n) {
            n ? this.node.triggerAttackRelease(e, n) : this.node.triggerAttack(e)
        }
        release(e) {
            this.node.triggerRelease(e)
        }
        convertDrumRackKeys(e) {
            const n = {};
            return Object.keys(e).forEach(r => {
                dc.keyToNoteMap[r] ? n[dc.keyToNoteMap[r]] = e[r] : n[r] = e[r]
            }), n
        }
    };
    dc.keys = ["kick", "rim", "snare", "sidestick", "rimshot", "pedalhh", "closedhh", "floortom", "mediumhh", "lowtom", "openhh", "midtom", "hitom", "crash", "ride", "click"], dc.keyToNoteMap = {
        kick: "c2",
        rim: "db2",
        snare: "d2",
        sidestick: "eb2",
        rimshot: "e2",
        pedalhh: "f2",
        closedhh: "gb2",
        floortom: "g2",
        mediumhh: "ab2",
        lowtom: "a2",
        openhh: "bb2",
        midtom: "b2",
        hitom: "c3",
        crash: "d3",
        ride: "eb3",
        click: "g3"
    };
    let Ey = dc;
    class cbe {
        constructor(e) {
            this.isPlayable = !0, this.node = new Xd(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class Op extends ks {
        constructor() {
            super(Y(Op.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "FlubSampler", this.activeSources = new Set;
            const e = Y(Op.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
            this.buffers = new Ls(e.urls, {
                rotationType: e.rotationType,
                baseUrl: e.baseUrl,
                onload: e.onload,
                onerror: e.onerror
            }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this.buffers.loaded && Promise.resolve().then(e.onload)
        }
        get loaded() {
            return this.buffers.loaded
        }
        static getDefaults() {
            return Object.assign(ks.getDefaults(), {
                attack: 0,
                baseUrl: "",
                curve: "exponential",
                onload: ht,
                onerror: ht,
                release: .1,
                rotationType: "serial",
                urls: []
            })
        }
        triggerAttack(e) {
            const n = this.buffers.get();
            if (!n) return this;
            const r = new Qs({
                url: n,
                context: this.context,
                curve: this.curve,
                fadeIn: this.attack,
                fadeOut: this.release,
                onended: s => this.activeSources.delete(s)
            }).connect(this.output);
            return r.start(e, 0), this.activeSources.add(r), this
        }
        triggerAttackRelease() {
            return this
        }
        triggerRelease() {
            return this
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
        }
        dispose() {
            return super.dispose(), this.buffers.dispose(), this.activeSources.forEach(e => e.dispose()), this.activeSources.clear(), this
        }
    }
    class lbe {
        constructor(e, n) {
            this.isPlayable = !0, n.baseUrl && (e.urls = Ls.transformSampleArray({
                urls: e.urls,
                baseUrl: n.baseUrl,
                ext: n.ext
            })), this.node = new Op(e)
        }
        attack() {
            this.node.triggerAttack()
        }
        oneShot() {
            this.node.triggerAttack()
        }
        release() {
            this.node.triggerRelease()
        }
    }
    class ube {
        constructor(e) {
            this.isPlayable = !0, this.node = new Mu(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class Ap extends ks {
        constructor() {
            super(Y(Ap.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "HarmonicSampler";
            const e = Y(Ap.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
            this.buffers = new Ls(e.urls, {
                isHarmonic: !0,
                rotationType: e.rotationType,
                baseUrl: e.baseUrl,
                onload: e.onload,
                onerror: e.onerror
            }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this.buffers.loaded && Promise.resolve().then(e.onload)
        }
        get loaded() {
            return this.buffers.loaded
        }
        static getDefaults() {
            return Object.assign(ks.getDefaults(), {
                attack: 0,
                baseUrl: "",
                curve: "exponential",
                onload: ht,
                onerror: ht,
                release: .1,
                rotationType: "serial",
                urls: {}
            })
        }
        triggerAttack(e, n) {
            if (!Array.isArray(e)) return this;
            let r;
            const s = wp.getChordNameFromFrequencies(e);
            for (let i = 0; i < s.length && (r = this.buffers.get(s[i]), !r); i++);
            return r ? (this.activeSource && (this.activeSource.stop(), this.disposeActiveSource()), this.activeSource = new Qs({
                url: r,
                context: this.context,
                curve: this.curve,
                fadeIn: this.attack,
                fadeOut: this.release,
                loop: !1
            }).connect(this.output), this.activeSource.start(n, 0), this) : this
        }
        triggerAttackRelease(e, n, r) {
            const s = this.toSeconds(r);
            return this.triggerAttack(e, s), this.triggerRelease(s + this.toSeconds(n)), this
        }
        triggerRelease(e, n) {
            return Array.isArray(e) ? this.activeSource ? (n ? this.activeSource.stop(this.toSeconds(n)) : this.activeSource.stop(this.now()), delete this.activeSource, this) : this : this
        }
        disposeActiveSource() {
            this.activeSource && (this.activeSource.dispose(), delete this.activeSource)
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
        }
        dispose() {
            return super.dispose(), this.buffers.dispose(), this.disposeActiveSource(), this
        }
    }
    class hbe {
        constructor(e, n) {
            this.isPlayable = !0, n.baseUrl && (e.urls = Ls.transformSampleMap({
                urls: e.urls,
                baseUrl: n.baseUrl,
                ext: n.ext
            })), this.node = new Ap(e)
        }
        attack(e) {
            this.node.triggerAttack(e)
        }
        oneShot(e, n = .25) {
            this.node.triggerAttackRelease(e, n)
        }
        release(e) {
            this.node.triggerRelease(e)
        }
    }
    class fbe {
        constructor(e) {
            this.isPlayable = !0, this.node = new Hc(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class dbe {
        constructor(e) {
            this.isPlayable = !0, this.node = new Jd(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class pbe {
        constructor(e) {
            this.isPlayable = !0, this.node = new ki(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class mbe {
        constructor(e) {
            this.isPlayable = !0, this.node = new Qd(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class gbe {
        constructor(e, n) {
            this.isPlayable = !0;
            let r;
            n.notes && (r = n.notes.map(s => qd(s, "midi").toNote())), n.baseUrl && (e.urls = Ls.transformSampleMap({
                urls: e.urls,
                baseUrl: n.baseUrl,
                ext: n.ext,
                notes: r
            })), this.node = new Gu(e)
        }
        attack(e) {
            this.node.triggerAttack(e)
        }
        oneShot(e, n) {
            n ? this.node.triggerAttackRelease(e, n) : this.node.triggerAttack(e)
        }
        release(e) {
            this.node.triggerRelease(e)
        }
    }
    class _be {
        constructor(e, n) {
            this.isPlayable = !0, n.baseUrl && (e.url = Ls.transformUrl(e.url, n.baseUrl, n.ext)), this.node = new ko(e)
        }
        attack(e) {
            this.node.start()
        }
        oneShot(e, n = .25) {
            this.node.start(), window.setTimeout(() => {
                this.node.stop()
            }, n * 1e3)
        }
        release(e) {
            this.node.stop()
        }
    }
    class ybe {
        constructor(e) {
            this.isPlayable = !0, this.node = new ep(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class vbe {
        constructor(e) {
            this.isPlayable = !0, this.node = this.getNode(e)
        }
        getNode(e) {
            return e.voice.type === "amSynth" ? new da({
                voice: Pm,
                maxPolyphony: e.maxPolyphony ?? 12,
                options: e.voice.options
            }) : e.voice.type === "fmSynth" ? new da({
                voice: Mu,
                maxPolyphony: e.maxPolyphony ?? 12,
                options: e.voice.options
            }) : e.voice.type === "monoSynth" ? new da({
                voice: ki,
                maxPolyphony: e.maxPolyphony ?? 12,
                options: e.voice.options
            }) : new da({
                voice: ti,
                maxPolyphony: e.maxPolyphony ?? 12,
                options: e.voice.options
            })
        }
        attack(e) {
            this.node.triggerAttack(e)
        }
        oneShot(e, n = .25) {
            this.node.triggerAttackRelease(e, n)
        }
        release(e) {
            this.node.triggerRelease(e)
        }
    }
    class bbe {
        constructor(e, n) {
            this.isPlayable = !0, n.baseUrl && (e.urls = Ls.transformSampleObject({
                urls: e.urls,
                baseUrl: n.baseUrl,
                ext: n.ext
            })), this.node = new Kc(e)
        }
        attack(e) {
            this.node.triggerAttack(e)
        }
        oneShot(e, n = .25) {
            this.node.triggerAttackRelease(e, n)
        }
        release(e) {
            this.node.triggerRelease(e)
        }
    }
    class Ebe {
        constructor(e) {
            this.isPlayable = !1, this.node = this.getNode(e)
        }
        getNode(e) {
            switch (e.type) {
                case "compressor":
                    return new vo(e.options);
                case "eq3":
                    return new Tp(e.options);
                case "filter":
                    return new wr(e.options);
                case "gate":
                    return new vp(e.options);
                case "limiter":
                    return new bp(e.options);
                case "multibandCompressor":
                    return new Ep(e.options);
                case "panVol":
                    return new Xc(e.options);
                case "panner":
                    return new zc(e.options);
                case "volume":
                    return new Js(e.options);
                case "autoFilter":
                    return new Fu(e.options);
                case "autoPanner":
                    return new Uu(e.options);
                case "autoWah":
                    return new np(e.options);
                case "bitCrusher":
                    return new rp(e.options);
                case "chebyshev":
                    return new ip(e.options);
                case "chorus":
                    return new op(e.options);
                case "distortion":
                    return new ap(e.options);
                case "feedbackDelay":
                    return new lp(e.options);
                case "freeverb":
                    return new hp(e.options);
                case "frequencyShifter":
                    return new up(e.options);
                case "jcReverb":
                    return new fp(e.options);
                case "phaser":
                    return new mp(e.options);
                case "pingPongDelay":
                    return new dp(e.options);
                case "pitchShift":
                    return new pp(e.options);
                case "reverb":
                    return new gp(e.options);
                case "stereoWidener":
                    return new _p(e.options);
                case "tremolo":
                    return new qu(e.options);
                case "vibrato":
                    return new yp(e.options);
                default:
                    throw new Error(`Unknown static node type ${e.type}`)
            }
        }
    }
    class Cp extends ks {
        constructor() {
            super(Y(Cp.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "SustainSampler";
            const e = Y(Cp.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
            this.buffers = new Ls(e.urls, {
                rotationType: e.rotationType,
                baseUrl: e.baseUrl,
                onload: e.onload,
                onerror: e.onerror
            }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this.legato = e.legato, this.buffers.loaded && Promise.resolve().then(e.onload)
        }
        static getDefaults() {
            return Object.assign(ks.getDefaults(), {
                attack: 0,
                baseUrl: "",
                curve: "exponential",
                legato: !1,
                onload: ht,
                onerror: ht,
                release: .1,
                rotationType: "serial",
                urls: {}
            })
        }
        triggerAttack(e, n) {
            var p;
            const r = Nm(new Wn(this.context, e).toFrequency());
            if (this.activeSource && this.activeNote && !this.legato) {
                const m = r - this.activeNote,
                    _ = this.buffers.findClosest(this.activeNote);
                if (_ === null) return this;
                const y = Aa(_ + m);
                return this.activeSource.playbackRate.value = y, this
            }
            const s = Math.round(r),
                i = r - s,
                a = this.buffers.findClosest(s);
            if (a === null) return this;
            const c = Aa(a + i),
                u = s - a;
            if (this.legato) {
                if (u === this.activeNote) return this;
                (p = this.activeSource) == null || p.stop(this.now())
            }
            const h = this.buffers.get(u);
            if (!h) return this;
            const d = new Qs({
                url: h,
                context: this.context,
                curve: this.curve,
                fadeIn: this.attack,
                fadeOut: this.release,
                loop: !1,
                playbackRate: c
            }).connect(this.output);
            return d.start(n, 0), this.activeSource = d, this.activeNote = u, this
        }
        triggerAttackRelease(e, n, r) {
            return this
        }
        triggerUpdate(e, n) {
            return this.triggerAttack(e, n), this
        }
        triggerRelease(e) {
            return this.activeSource ? (e ? this.activeSource.stop(this.toSeconds(e)) : this.activeSource.stop(this.now()), delete this.activeSource, delete this.activeNote, this) : this
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
        }
        dispose() {
            var e;
            return super.dispose(), this.buffers.dispose(), (e = this.activeSource) == null || e.dispose(), this
        }
    }
    class Tbe {
        constructor(e, n) {
            this.isPlayable = !0, n.baseUrl && (e.urls = Ls.transformSampleMap({
                urls: e.urls,
                baseUrl: n.baseUrl,
                ext: n.ext
            })), this.node = new Cp(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class Sbe {
        constructor(e) {
            this.isPlayable = !0, this.node = new ti(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class wbe {
        constructor(e) {
            this.isPlayable = !1;
            const n = new as(e.frequency || 440, e.type || "sine"),
                r = new qu(e).start();
            n.connect(r), this.node = r
        }
    }
    class jl {
        constructor(e, n) {
            this.nodes = [], this.duration = n.duration ?? .25, e.forEach(r => {
                if (r.isDisabled) return;
                const s = this.getNode(r, n);
                this.nodes.push(s), this.isPlayableNode(s) && (this.playable = s)
            }), this.connectNodes()
        }
        get inNode() {
            return this.nodes[0]
        }
        get outNode() {
            return this.nodes[this.nodes.length - 1]
        }
        isPlayableNode(e) {
            return e.attack !== void 0
        }
        getNode(e, n) {
            switch (e.type) {
                case "amSynth":
                    return new ave(e.options);
                case "autoFilter":
                    return new cve(e.options);
                case "autoPanner":
                    return new lve(e.options);
                case "drumRackSampler":
                    return new Ey(e.options, n);
                case "duoSynth":
                    return new cbe(e.options);
                case "flubSampler":
                    return new lbe(e.options, n);
                case "fmSynth":
                    return new ube(e.options);
                case "harmonicSampler":
                    return new hbe(e.options, n);
                case "membraneSynth":
                    return new fbe(e.options);
                case "metalSynth":
                    return new dbe(e.options);
                case "monoSynth":
                    return new pbe(e.options);
                case "noiseSynth":
                    return new mbe(e.options);
                case "oneShotSampler":
                    return new gbe(e.options, n);
                case "player":
                    return new _be(e.options, n);
                case "pluckSynth":
                    return new ybe(e.options);
                case "polySynth":
                    return new vbe(e.options);
                case "sampler":
                    return new bbe(e.options, n);
                case "sustainSampler":
                    return new Tbe(e.options, n);
                case "synth":
                    return new Sbe(e.options);
                case "tremolo":
                    return new wbe(e.options);
                default:
                    return new Ebe(e)
            }
        }
        connectNodes() {
            this.nodes.forEach((e, n) => {
                n !== this.nodes.length - 1 && e.node.connect(this.nodes[n + 1].node)
            })
        }
        attack(e) {
            var n;
            (n = this.playable) != null && n.attack && this.playable.attack(e)
        }
        oneShot(e, n) {
            var r;
            (r = this.playable) != null && r.oneShot && this.playable.oneShot(e, n)
        }
        update(e) {
            var n;
            (n = this.playable) != null && n.update && this.playable.update(e)
        }
        release(e) {
            var n;
            (n = this.playable) != null && n.release && this.playable.release(e)
        }
    }
    class ob {
        constructor(e = {}) {
            this.attackChains = [], this.mainChains = [], this.releaseChains = [], this.flubChains = [], this.activeFrequency = null, this.activeInputs = new Map, this.outNode = new Xc, this.settings = {
                baseUrl: null,
                ext: null,
                chords: [],
                config: null,
                notes: [],
                isOneShot: !1,
                noFlubs: !1
            }, this.continuous = {
                attack: (n, r = 48, s = 60) => {
                    this.activeFrequency === null && (n = this.normalizeSignal(n), this.activeFrequency = this.signalToFrequency(n, r, s), this.attackChains.forEach(i => i.oneShot([this.activeFrequency], i.duration)), this.mainChains.forEach(i => i.attack([this.activeFrequency])))
                },
                update: (n, r = 48, s = 60) => {
                    this.activeFrequency !== null && (n = this.normalizeSignal(n), this.activeFrequency = this.signalToFrequency(n, r, s), this.mainChains.forEach(i => i.update([this.activeFrequency])))
                },
                release: () => {
                    this.activeFrequency !== null && (this.releaseChains.forEach(n => n.oneShot([this.activeFrequency], n.duration)), this.mainChains.forEach(n => n.release([this.activeFrequency])), this.activeFrequency = null)
                }
            }, this.discrete = {
                attack: (n, r) => {
                    if (Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]), n = this.transposeNotesIntoRange(n), r.some(a => this.activeInputs.has(a))) return;
                    const i = n.map(a => qd(a, "midi").toFrequency());
                    r.forEach(a => this.activeInputs.set(a, i)), this.attackChains.forEach(a => a.oneShot(i, a.duration)), this.mainChains.forEach(a => {
                        this.isOneShot ? a.oneShot(i) : a.attack(i)
                    })
                },
                release: n => {
                    Array.isArray(n) || (n = [n]), n.forEach(r => {
                        const s = this.activeInputs.get(r);
                        s !== void 0 && (this.releaseChains.forEach(i => i.oneShot(s, i.duration)), this.mainChains.forEach(i => {
                            this.isOneShot || i.release(s)
                        }), this.activeInputs.delete(r))
                    })
                }
            }, this.flub = {
                attack: () => {
                    this.flubChains.forEach(n => n.oneShot([60], n.duration))
                }
            }, this.outNode.toDestination(), this.update(e)
        }
        update(e = {}) {
            this.releaseAll();
            const n = JSON.parse(JSON.stringify(e));
            n.baseUrl !== void 0 && (this.settings.baseUrl = n.baseUrl), n.ext !== void 0 && (this.settings.ext = n.ext), n.chords !== void 0 && (this.settings.chords = n.chords), n.notes !== void 0 && (this.settings.notes = this.transposeNotesIntoRange(n.notes.sort())), n.noFlubs !== void 0 && (this.settings.noFlubs = n.noFlubs), n.config !== void 0 && (this.settings.config = n.config), this.settings.config && (this.settings.isOneShot = this.settings.config.capabilities.includes("OneShot"), this.resetChains())
        }
        get baseUrl() {
            return this.settings.baseUrl
        }
        get ext() {
            return this.settings.ext
        }
        get chords() {
            return this.settings.chords
        }
        get notes() {
            return this.settings.notes
        }
        get isOneShot() {
            return this.settings.isOneShot
        }
        get noFlubs() {
            return this.settings.noFlubs
        }
        get config() {
            return this.settings.config
        }
        resetChains() {
            this.clearChains(), this.config && (this.buildChains(), this.connectChains())
        }
        clearChains() {
            const e = [];
            this.attackChains.forEach(n => {
                e.push(...n.nodes)
            }), this.mainChains.forEach(n => {
                e.push(...n.nodes)
            }), this.releaseChains.forEach(n => {
                e.push(...n.nodes)
            }), this.flubChains.forEach(n => {
                e.push(...n.nodes)
            }), this.effectChain && e.push(...this.effectChain.nodes), this.attackChains = [], this.mainChains = [], this.releaseChains = [], this.flubChains = [], delete this.effectChain, e.forEach(n => {
                n.node.disconnect(), n.node.dispose()
            })
        }
        buildChains() {
            this.config && this.config.chains.forEach(e => {
                var r;
                if (this.settings.noFlubs && e.type === "flub" || !e.nodes.length || (r = e.nodes[0]) != null && r.isDisabled && e.type !== "effect") return;
                const n = {};
                this.baseUrl && (n.baseUrl = this.baseUrl), this.chords && (n.chords = this.chords), this.ext && (n.ext = this.ext), this.notes && (n.notes = this.notes), e.type === "effect" ? this.effectChain = new jl(e.nodes, n) : e.type === "main" ? this.mainChains.push(new jl(e.nodes, n)) : (n.duration = e.duration, e.type === "attack" ? this.attackChains.push(new jl(e.nodes, n)) : e.type === "release" ? this.releaseChains.push(new jl(e.nodes, n)) : this.flubChains.push(new jl(e.nodes, n)))
            })
        }
        connectChains() {
            this.effectChain && this.effectChain.outNode.node.connect(this.outNode), [...this.attackChains, ...this.mainChains, ...this.releaseChains, ...this.flubChains].forEach(n => {
                this.effectChain ? n.outNode.node.connect(this.effectChain.inNode.node) : n.outNode.node.connect(this.outNode)
            })
        }
        normalizeSignal(e) {
            return e < 0 ? 0 : e > 1 ? 1 : e
        }
        signalToFrequency(e, n, r) {
            const s = (r - n) * e + n;
            return qd(s, "midi").toFrequency()
        }
        transposeNotesIntoRange(e) {
            return e.map(this.transposeNoteIntoRange.bind(this))
        }
        transposeNoteIntoRange(e) {
            if (!this.config || !this.config.preferredRange) return e;
            if (e < this.config.preferredRange[0]) {
                for (let n = e; n <= 127; n += 12)
                    if (n >= this.config.preferredRange[0]) return n;
                return console.warn(`Unable to transpose note ${e} into range ${this.config.preferredRange}`), e
            }
            if (e > this.config.preferredRange[1]) {
                for (let n = e; n >= 0; n -= 12)
                    if (n <= this.config.preferredRange[1]) return n;
                console.warn(`Unable to transpose note ${e} into range ${this.config.preferredRange}`)
            }
            return e
        }
        releaseAll() {
            this.activeInputs.forEach((e, n) => this.discrete.release(n)), this.continuous.release()
        }
    }
    const Obe = mt({
            props: {
                beatmap: {
                    type: Object,
                    required: !0
                },
                instrument: {
                    type: Object,
                    required: !0
                }
            },
            setup() {
                return {
                    instraface: new ob({
                        noFlubs: !0
                    })
                }
            },
            data() {
                return {
                    isLoading: !0,
                    isDown: !1,
                    signal: 0
                }
            },
            watch: {
                instrument: {
                    handler(t, e) {
                        e && t.config.slug === e.config.slug || (this.instraface.update({
                            baseUrl: `https://cdn.jackboxgames.com/nopus-opus/instruments/${this.instrument.config.slug}`,
                            config: this.instrument.config
                        }), this.instraface.outNode.volume.value = 8, this.waitForLoading())
                    },
                    immediate: !0
                }
            },
            beforeUnmount() {
                this.instraface.releaseAll(), this.instraface.update({
                    config: null
                })
            },
            methods: {
                normalizeSignal(t) {
                    return t < 0 ? 0 : t > 1 ? 1 : t
                },
                onPointerBoxStart(t) {
                    if (!this.isLoading) {
                        this.isDown = !0, this.signal = this.normalizeSignal(t.detail.percentX);
                        try {
                            this.instraface.continuous.attack(this.signal, 48, 72)
                        } catch {
                            t.detail.cancel(), console.warn("not loaded")
                        }
                    }
                },
                onPointerBoxMove(t) {
                    if (!this.isLoading) {
                        this.signal = this.normalizeSignal(t.detail.percentX);
                        try {
                            this.instraface.continuous.update(this.signal, 48, 72)
                        } catch {
                            console.warn("not loaded")
                        }
                    }
                },
                onPointerBoxEnd() {
                    if (!this.isLoading) {
                        this.isDown = !1;
                        try {
                            this.instraface.continuous.release()
                        } catch {
                            console.warn("not loaded")
                        }
                    }
                },
                async waitForLoading() {
                    this.isLoading = !0, await Y0(), this.isLoading = !1
                }
            }
        }),
        Abe = {
            class: "slider-wrapper"
        },
        Cbe = ["disabled"],
        kbe = {
            key: 0,
            class: "test-it"
        },
        Ibe = {
            key: 1,
            class: "test-it"
        };

    function Nbe(t, e, n, r, s, i) {
        const a = On("pointerbox"),
            c = On("t");
        return G(), H("div", {
            class: Xe(["tester", {
                loading: t.isLoading
            }])
        }, [B("div", Abe, [Ke((G(), H("div", {
            class: "slider",
            disabled: t.isLoading,
            "onPointerbox:start": e[0] || (e[0] = (...u) => t.onPointerBoxStart && t.onPointerBoxStart(...u)),
            "onPointerbox:move": e[1] || (e[1] = (...u) => t.onPointerBoxMove && t.onPointerBoxMove(...u)),
            "onPointerbox:end": e[2] || (e[2] = (...u) => t.onPointerBoxEnd && t.onPointerBoxEnd(...u))
        }, [B("div", {
            class: Xe(["indicator", {
                visible: t.isDown
            }]),
            style: Tn({
                left: `${t.signal*100}%`
            })
        }, null, 6)], 40, Cbe)), [
            [a, void 0, void 0, {
                restrict: !0
            }]
        ])]), t.isLoading ? Ke((G(), H("p", kbe, null, 512)), [
            [c, "MENU.LOADING"]
        ]) : Ke((G(), H("p", Ibe, null, 512)), [
            [c, "MENU.TEST_IT"]
        ])], 2)
    }
    const xbe = ot(Obe, [
            ["render", Nbe],
            ["__scopeId", "data-v-d4d4738c"]
        ]),
        Pbe = [{
            hotKeys: [],
            degrees: [],
            lanes: [],
            hit: 0
        }, {
            hotKeys: ["space"],
            degrees: [1],
            lanes: [0, .5, 1],
            hit: .15
        }, {
            hotKeys: ["g", "h"],
            degrees: [1, 5],
            lanes: [0, .25, .5, .75, 1],
            hit: .15
        }, {
            hotKeys: ["f", "g", "h"],
            degrees: [1, 3, 5],
            lanes: [0, .166, .333, .5, .666, .833, 1],
            hit: .15
        }, {
            hotKeys: ["f", "g", "h", "j"],
            degrees: [1, 3, 5, 8],
            lanes: [0, .125, .25, .375, .5, .625, .75, .875, 1],
            hit: .15
        }, {
            hotKeys: ["d", "f", "g", "h", "j"],
            degrees: [1, 3, 4, 5, 8],
            lanes: [0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1],
            hit: .13
        }, {
            hotKeys: ["d", "f", "g", "h", "j", "k"],
            degrees: [1, 3, 4, 5, 6, 8],
            lanes: [0, .083, .166, .25, .333, .415, .5, .585, .666, .75, .833, .917, 1],
            hit: .12
        }];

    function ab(t) {
        const e = Pbe[t];
        if (!e) return null;
        const n = [];
        for (let r = 1; r < e.lanes.length; r += 2) n.push({
            left: e.lanes[r - 1],
            center: e.lanes[r],
            right: e.lanes[r + 1]
        });
        return {
            hotKeys: e.hotKeys,
            degrees: e.degrees,
            lanes: n,
            hit: e.hit
        }
    }
    const Rbe = mt({
            props: {
                beatmap: {
                    type: Object,
                    required: !0
                },
                instrument: {
                    type: Object,
                    required: !0
                },
                scaleKey: {
                    type: String,
                    required: !0
                },
                scaleType: {
                    type: String,
                    required: !0
                }
            },
            setup() {
                return {
                    instraface: new ob({
                        noFlubs: !0
                    })
                }
            },
            data() {
                return {
                    isLoading: !0,
                    down: []
                }
            },
            computed: {
                layout() {
                    return ab(this.beatmap.config.laneCount)
                },
                isPercussion() {
                    for (let t = 0; t < this.instrument.config.capabilities.length; t++)
                        if (this.instrument.config.capabilities[t] === "DrumRack" || this.instrument.config.capabilities[t] === "PercSingle" || this.instrument.config.capabilities[t] === "PercRep") return !0;
                    return !1
                },
                notes() {
                    if (this.isPercussion) switch (this.beatmap.config.laneCount) {
                        case 1:
                            return [36];
                        case 2:
                            return [36, 38];
                        case 3:
                            return [36, 38, 42];
                        case 4:
                            return [36, 38, 42, 50];
                        case 5:
                            return [36, 38, 42, 45, 50];
                        default:
                            return [36, 38, 42, 45, 48, 50]
                    }
                    return wp.getNotesInScale(`${this.scaleKey}4 ${this.scaleType}`, this.layout.degrees)
                }
            },
            watch: {
                instrument: {
                    handler(t, e) {
                        if (!(e && t.config.slug === e.config.slug)) {
                            this.instraface.update({
                                baseUrl: `https://cdn.jackboxgames.com/nopus-opus/instruments/${this.instrument.config.slug}`,
                                config: this.instrument.config
                            }), this.instraface.outNode.volume.value = 8, this.down = [];
                            for (let n = 0; n < this.beatmap.config.laneCount; n++) this.down.push(!1);
                            this.waitForLoading()
                        }
                    },
                    immediate: !0
                }
            },
            mounted() {
                window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp)
            },
            beforeUnmount() {
                window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp), this.instraface.releaseAll(), this.instraface.update({
                    config: null
                })
            },
            methods: {
                onPointerDown(t) {
                    this.onDown(t)
                },
                onPointerUp(t) {
                    this.onUp(t)
                },
                onKeyDown(t) {
                    const e = t.key.toLowerCase(),
                        n = this.layout.hotKeys.indexOf(e);
                    n !== -1 && this.onDown(n)
                },
                onKeyUp(t) {
                    const e = t.key.toLowerCase(),
                        n = this.layout.hotKeys.indexOf(e);
                    n !== -1 && this.onUp(n)
                },
                onDown(t) {
                    if (this.isLoading) return;
                    const e = this.notes[t];
                    this.down[t] = !0;
                    try {
                        this.instraface.discrete.attack(e, t)
                    } catch {
                        console.warn("not loaded")
                    }
                },
                onUp(t) {
                    if (!this.isLoading && this.down[t]) {
                        this.down[t] = !1;
                        try {
                            this.instraface.discrete.release(t)
                        } catch {
                            console.warn("not loaded")
                        }
                    }
                },
                async waitForLoading() {
                    this.isLoading = !0, await Y0(), this.isLoading = !1
                }
            }
        }),
        Mbe = {
            class: "notes"
        },
        Dbe = ["onPointerdown", "onPointerleave", "onPointerup"],
        $be = {
            key: 0,
            class: "test-it"
        },
        Lbe = {
            key: 1,
            class: "test-it"
        };

    function Fbe(t, e, n, r, s, i) {
        const a = On("t");
        return G(), H("div", {
            class: Xe(["tester", {
                loading: t.isLoading
            }])
        }, [B("div", Mbe, [(G(!0), H(Tt, null, $n(t.beatmap.config.laneCount, (c, u) => (G(), H("div", {
            key: c,
            class: "cell"
        }, [B("button", {
            class: Xe(["note", {
                down: t.down[u]
            }]),
            onPointerdown: h => t.onPointerDown(u),
            onPointerleave: h => t.onPointerUp(u),
            onPointerup: h => t.onPointerUp(u)
        }, null, 42, Dbe)]))), 128))]), t.isLoading ? Ke((G(), H("p", $be, null, 512)), [
            [a, "MENU.LOADING"]
        ]) : Ke((G(), H("p", Lbe, null, 512)), [
            [a, "MENU.TEST_IT"]
        ])], 2)
    }
    const Ube = ot(Rbe, [
            ["render", Fbe],
            ["__scopeId", "data-v-83570038"]
        ]),
        Bbe = mt({
            props: {
                category: {
                    type: String,
                    required: !0
                },
                classes: {
                    type: Array,
                    required: !1
                }
            }
        }),
        qbe = {
            key: 0,
            class: "aux",
            d: "m29.25,8.63l-2.29-5.43-5.14-2.5-14,.59-5.07,1.91L.25,8.77l.21,32.38,2.5,5.07,4.5,2.72c3.63.05,11.05.22,14.64.37,0,0,5.29-2.57,5.29-2.57l2.36-5.36-.5-32.75m-20.21-1.4l1.14-.73,5.86,3.23-5.57,2.86-3.57-.88-3-2.13,5.14-2.35m5.29,9.84l5.64-2.86,5.93,2.86-5.57,3.74c-1.36-1.12-4.41-2.97-6-3.74m5.64,18.94l-5.86-3.45,5.93-2.57,5.43,2.72-5.5,3.3m-3.93-10.72l-5.71,3.3-6.57-3.52,6.5-3.3,5.79,3.52m-11.79,15.57l5.57-2.94,5.29,3.01-4.71,3.6-6.14-3.67Z"
        },
        jbe = {
            key: 1,
            class: "bass",
            d: "m29.68,8.48l-2.64-5.51-4.86-2.28-2.64.07.29,37.08-.57,2.79-4.21,1.91-2.14-.44-2.21-1.69L10.39.84h-2.5L3.32,3.27l-2.21,4.77L.32,41.59l2.57,4.99,5.57,2.57,7.29.15h6.21l5.21-2.28,2.21-5.58.29-32.97Z"
        },
        Vbe = {
            key: 2,
            class: "counter",
            d: "m30,24.67c-.25-4.29-.77-17.9-2.14-21.81C24.2,2.19,12.09.65,8.21.15L2.93,3.67,0,8.66c.46,3.96-.7,36.11,2.79,38.55l5.5,2.35,13.79.29,5.21-3.3c2.33-2.9,2.39-18.28,2.71-21.88m-4.29-14.83l.43,2.94-2.57,2.79-3.5-1.54-.21-4.04,2.86-1.62,3,1.47m-7.43,7.71l-5.07-4.99.86-1.32,11.64,9.99-16.21,19.46-1.21-.88,9.14-12.78,5.86-5.58-5-3.89m-12.93,14.83v-3.89l3.64-1.03,2.5,2.28-.64,3.01-2.86,1.84-2.64-2.2m12.29-13l.43,2.79-1.79,2.28-3.57-.29-1-3.16,2.71-3.3,3.21,1.69m-1.21,16.96l1.86,2.42.36,3.16-4,1.25-1.79-1.69.14-3.08,3.43-2.06Z"
        },
        Gbe = {
            key: 3,
            class: "drums",
            d: "m29.89,9.18l-2-6.46L21.89.22l-13.43.29L2.61,3.23.11,9.1c.35,4.39-1.14,34.72,2.21,37.81l6,2.28c.89.07,6.71.44,7.43.59,0,0,11.43-2.94,11.43-2.94,2.67-3.14,2.36-33.38,2.71-37.67m-5.57-2.35l-.21,5.14h-8.21l.36-4.99c2.06.56,6,.26,8.07-.15M6.61,17.18l7.43-.07c.14.15.1,1.81-.14,4.99l-8.07.15,1-2.79-.21-2.28m-.79,15.86l-.21-4.77,8.5-.37.14,5.58-4.64-1.25-3.79.81m8.29,5.95l-.64,2.72.79,2.72-7.79-.44.14-3.96,7.5-1.03Z"
        },
        Wbe = {
            key: 4,
            class: "harmony",
            d: "m28.86,8.33l-2-5.21-1.57-.81-.43,18.58-1.21,1.98-2.43.29-.79-2.42c.09-1.68-.06-19.16.71-20.19h-4.21l.07,22.47-2.79-.37-1.36-2.13L13.21.48C7.52.2,7.54.35,2.57,2.97-.28,5.94.98,37.56.71,41.74c0,0,2.21,4.48,2.21,4.48l3.21,1.47-.71-18.87.93-1.32,2.43.66.43,20.56,3.86.37c.27-1.82-.44-21.07,1.57-21.88l1.86.59,1,3.01-.64,11.16.5,7.42,4.43.22,5.57-2.72c3.16-3.36,1.28-34.01,1.5-38.55Z"
        },
        Hbe = {
            key: 5,
            class: "melody",
            d: "m28.96,8.33l-1.79-5.36-4.64-2.2L7.68.4,2.89,3.34.39,9.07l.07,32.01,2.21,4.48,5.57,3.16,6.57.88c6.65-.26,6.68.12,12.5-3.45l2.29-5.43-.64-32.38m-7.79,14.9l-.14.44-3.36,3.74.93,1.84-.21,2.64-3.57,1.54-.93-.66-3.14,4.41.64,3.82-2.43,1.47-3.29-.59-1.79-2.86,2.29-3.08,2.5.07,3.5-4.48-.86-.66.57-3.23,3.79-.59c.23-.32,4.05-5.21,4.07-5.43l-.79-.81.79-2.35-.21-.15-3.43-3.82-1.71.15-2.5-1.54-.29-4.26,3.5-1.47c-.14.22,1.47,1.2,1.86,1.4,0,0,1.57,2.35,1.57,2.35l-.57,2.35,3.86,3.82,2.57-.37,2.07,3.45-2.29,3.16-1.93.81-1.07-1.1Z"
        },
        Kbe = {
            key: 6,
            class: "signature",
            d: "m29.89,8.74l-2.64-5.51-5.14-3.23-13.93.73L2.32,2.79.11,9.18l.07,32.38,2.57,5.51,5.43,2.94c5.73-.06,13.81-1.07,19.29-2.79,3.22-2.49,2.05-34.59,2.43-38.47m-3.21,13c-1.55.8-3.89,4.5-4.79,5.95l.21,7.49-6.64-2.5-7.64,2.5,1.07-5.58-2.21-4.7-2.86-3.16,3-1.47,4.43-.81,4.07-6.61c.1.24,1.48,2.37,4.14,6.39l7.21,2.5Z"
        };

    function Ybe(t, e, n, r, s, i) {
        return G(), H("svg", {
            viewBox: "0 0 30 50",
            class: Xe(t.classes)
        }, [t.category === "AuxPercussion" ? (G(), H("path", qbe)) : t.category === "Bass" ? (G(), H("path", jbe)) : t.category === "CounterMelody" ? (G(), H("path", Vbe)) : t.category === "Drums" ? (G(), H("path", Gbe)) : t.category === "Harmony" ? (G(), H("path", Wbe)) : t.category === "Melody" ? (G(), H("path", Hbe)) : t.category === "Signature" ? (G(), H("path", Kbe)) : Be("", !0)], 2)
    }
    const k6 = ot(Bbe, [
            ["render", Ybe],
            ["__scopeId", "data-v-d2174d82"]
        ]),
        zbe = mt({
            props: {
                category: {
                    type: String,
                    required: !0
                },
                slug: {
                    type: String,
                    required: !0
                }
            },
            computed: {
                categoryClass() {
                    return Ii.categorySlugByKey(this.category)
                },
                icon() {
                    return Ii.instrumentIconBySlug(this.slug)
                }
            }
        }),
        Zbe = {
            key: 0,
            d: "m133.26,90.5v-6.5l-3.48,3,3.48,3.5ZM31.33,45l2.48,10,21.38-3,1.83,10.32-15.25,2.68v7l16.25-4.09,1.76,9.96-15.03,6.13,2.99,5.5,13.08-5.8,2.05,11.59-13.15,5.21v6.5l14.56-3.75,1.59,8.93-14.65,5.32,3.97,4.5,11.83-3.34,2.1,11.84-19.4,2.5v11.5l35.8-5.5-16.4-101-37.79,7Zm97.95,61.5l-4.97,1,3.48,5,1.49-6Zm-5.47,15l1-4.5h-4.98l3.98,4.5Zm-17.9-78.5l-6.96-5.5-6.96,7.5-6.46-7.5-3.49,10.5-8.95-10.5,14.92,100h10.94l15.41-100-8.45,5.5Zm18.4,51l3.48,5.5.99-7-4.47,1.5Zm12.93-24v-6.5l-3.98,3,3.98,3.5Zm-19.4-33l-16.4,100,28.34,6,1.99-14.5-13.93-3-1.98-5.5,11.93-63,15.91,2.5,2.49-16-28.35-6.5Zm13.93,36l-3.98,1.5,1.99,4.5,1.99-6Z"
        },
        Xbe = {
            key: 1,
            d: "m50.02,96.74c-9.78,14.26-8.34,12.27-11.63,28.91l8.67,14.46c19.13,9.82,13.79,7.23,34.67,6.38,12.67-17.79,9.85-12.43,11.71-33.8l-8.09-11.34,37.99-54.99,20.35-10.35-2.38-7.09-21.07,4.93c1.61,2.1-39.98,58.25-41.69,61.16l-13.11-2.51-15.43,4.25Zm5.15,22.49l14.43,9.49-1.26,2.02-14.63-9.97,1.46-1.54Z"
        },
        Jbe = {
            key: 2,
            d: "m75.08,94.5l7.46,27-3.98,20,4.48,5.5c29.34-4.44,22.28-1.44,45.81-19.43l-5.36-3.05c-16.08,14.36-11,11.24-31.87,15.48l-4.11-1.5c6.34-7.33,31.58-25.87,40.03-31.25l.07.02,11.62-3.27-3.31,5.66,4.44,1.27,4.33-8.93-5.46-7c-24.07-3.71-19.08-2.07-38.79-16l-9.94,3-20.89-37-11.93-10-5.97,4,5.97,15,24.36,33-6.96,7.5Zm43.51,22.75l8.52,7.63h9.32l3.73-6-4.97-6.88-7.9-2.01-8.7,7.25Z"
        },
        Qbe = {
            key: 3,
            d: "m132.57,76.01l-25.44-2.48-16.94,6.13-.28,6.44,3.78,2.72,2.43,29.39,10.85,6.26,19.77.04,10.59-4.49,5.25-27.93,3.81-2.39.28-6.44-14.1-7.27Zm1.14,14.03l-29.64-2.07-12.34-4.55,2.47-3.31,17.28-4.14,22.23,2.48,9.46,4.97,1.24,2.9-10.7,3.72Zm-41.67-.83l-5.15.62-.62,20.18,6.9.21-1.13-21Zm-3.56-17.17l-16.66-4.23-27.99,2.48-14.82,8.64.5,5.36,3.88,1.71,11.24,34.64,25.34,1.36,13.94-5.06,2.54-35.56,3.91-2.45-1.88-6.89Zm-11.57,8.89l-23.87,1.66-19.76-1.66,1.24-3.31,11.93-5.38,21.41-2.07,16.87,2.07,1.23,3.31-9.05,5.38Z"
        },
        e2e = {
            key: 4,
            d: "m29.59,66.75l11.43-16.25,9.7,1.5,4.39,5.04,72.21,14.49,17.97,10.05,5.27,15.65,6.41-.69,1.39,9.29-4.78,7.08-5.14-3.87-12.31,14.71-.62-.04c3.83-22.49,4.86-17.09-2.31-39l-17.63-9.29-19.05,6.97-10.35,20.74-.54,5.03-36.01-16.86-6.8,2.83-10.25-3.12-2.98-24.25Zm6.06,3.21l5.02-8.27,5.74.89,1.81,10.41-5.1,10.33-6.63-1.65-.84-11.71Zm79.4,9.62l-16.94,6.2-9.21,18.44-1.93,18.18,6.42,19.46,17.11,5.35,12.56-6.99c11.21-17.73,9.44-15.71,12.82-35.87,0,0-5.15-16.52-5.15-16.52l-15.68-8.26Zm1.2,27.17l5.5,4.5-.5,5.12-6,3.75-3.38-3.12.38-7.12,4-3.12Zm-55.75,12.25l2.33-19.27,20.61,10.96.06,10.45,2.17,9.57-8.17,8.79-11.5-2.5-5.5-18Z"
        },
        t2e = {
            key: 5,
            d: "m14.42,68l29.84,16.5,40.27-18,3.98-5,8.45,1.5v5c-6.73-.76-44.79,14.24-51.71,16.5l46.24,20.5,75.08-37c-98.08-29.69-54.24-29.58-152.15,0Zm38.79,48.5v-25.5l38.28,17.5,37.79-17.5-.5,25.5-12.92,10-26.36,4-26.35-4-9.94-10Zm-8.95-6.5l.99-17.5,1.49,17.5,2.98,6.5c0,4.48,0,13.52,0,18l-2.98,2.5-4.47-2.5v-15.5l1.99-9Z"
        },
        n2e = {
            key: 6,
            d: "m30.83,94l2.98,17.5s31.33,9,31.33,9c13.04-1.38,71.3-7.16,83.04-9-3.24-11.77-13.91-43.99-17.9-56l-55.2,1-13.67,33-30.58,4.5Zm36.8-4.75l10.44-27.5,15.91.25.99,29-27.34-1.75Zm31.57-26.75l1.49,28.25,16.41-.75-4.97-28.25-12.93.75Zm-62.9,45l-1.24-7.75,7.46.25,1.49,8.75-7.71-1.25Zm19.39-3.75l-.25,8,8.46,2.25.99-9-9.2-1.25Zm23.5,27.25l-8.08-7.47,24.24-2.28-3.88,8.77-12.28.98Zm45.59-5.75l-10.59-6.47,24.21-2.28-5.29,8.75h-8.33Zm-73.53-2l-7-6.75,16.25,4.5-.75,2.25h-8.5Zm8.75-85.75l10.62,11.25,3.38-3.88-7.62-13.25-6.38,5.88Zm23-6.25l-.5,13.75,5,1.75,5-15-9.5-.5Zm-35.12,22.38l13.62,4.25-1.25,5.38h-13.5l1.13-9.62Z"
        },
        r2e = {
            key: 7,
            d: "m82.99,54.23l21.42,11.23,22.46-.56-9.98,20.99,12.22,25.6-15.17,25.32-28.93,2.12-22.78-23.59,4.42-26.34,19.74-12.76-3.39-22Zm-5.89,3.17l-6.19-5.03,4.28,21.41-21.01,9.99-5.87,29.42,15.32,19.83,8.34.35-15.61-19.83,4.57-24.97,19.74-12.76-3.57-18.41Zm35.67,16.35l-15.31-3.69-1.32,6.07,13.2,2.64,3.43-5.01Zm6.07-23.23l-7.13,12.93,6.6-.79,6.07-13.46-7.13-12.4-15.57-2.38-2.11-2.64,3.17-2.64v-7.39l-9.24,7.92,4.22,9.24,15.31,1.85,5.81,9.77Z"
        },
        s2e = {
            key: 8,
            d: "m64.14,43.5l-3.73-.07-6.59,28.61c-4.93,9.4-12.05,29.78-14.79,40.09l21.38,20.5,22.87,9.25,28.59-5c18.42-13.39,16.58-9.78,28.09-30l-16.21-31.86-7.16-30.76-4.24.92-15.4,27.08-15.66-.05-17.15-28.7Zm1.74,54l-7.23-4.51,5.85,6.11,11.67.72,6.82-5.87c-8.8,4.39-7.3,4.13-17.12,3.55Zm38.78.62l-8.74-3.93,7.49,5.05,10.58-.71,3.83-5.43c-6.01,4.93-5.87,3.92-13.17,5.01Zm24.33,23.38l-17,13.5-28,4-24-10-16-16.5,1.5-12.5,24,5,10-1.5,1.5,2.77,4-.77,7-16,7,16,4,1.5,16-3.5,14-5.5,3.5,11-7.5,12.5Zm-44.02-14.13l6.12,5.12,5.58-5.64-6.69-1.38-5.01,1.9Zm4.52-.87l-.5,1.5.5,1.5,2-2.5-2-.5Zm3.27,10.99l-11.26,5.15,1.73,6.99,12.94.5,7.7-7.36-4.07-1.93-1.67,5.08-2-6.82-3.37-1.6Zm46.01-71.99l19.35,6.14-.89,8.23-16.37-6.43-1.19,23.94-11.16-1.65-1.34-6.58,5.06-2.24,4.76,2.69,1.79-24.09Z"
        },
        i2e = {
            key: 9,
            d: "m54.42,82l17.09-8.36,4.31-28.79-6.41.37.49-5.37,6.31,2.45.82-5.49-6.91-1.07v-3.04l7.27,1.7.7-4.7-3.54-5.13,7.35-5.81,4.95,9.54-3.28,1.94-.13,2.1,7.24-1.44-.65,5.61-6.75-1.57-.35,5.58,6.71,1.08-.12,2.14-6.73-.94-2.07,32.76,11.21,5.89c-.03,5.83.22,19.51,1.68,25.06l-7.61,1-2.21,7.95,2.17,8.39,5.3,2.04,2.52,18.1-15.5,13.55-29.83-3.22-7.57-15.34,4.11-17.95,8.09-.45,4.25-7.62-.56-6.84-6.82-3.19,3.03-6.74,1.44-14.19Zm51.26-62.46l24.53,126.48,1.73,7-2.29.74-1.35-6.59-3.23.52c-5.27-32.39-18.1-98.27-25.05-130.53l5.66,2.38Z"
        },
        o2e = {
            key: 10,
            d: "m106.06,119.81l9.01,1.85V32.23h-5.41l-3.6,87.58Zm-42.78-.41h5.63l3.38-87.17h-5.07l-3.94,87.17Zm12.79,24.27l3.04,9.82,10.96,5.53,10.35-3.68,2.44-9.82-6.09-9.82-6.7-3.68-7.31,3.68-6.69,7.98Zm7.48-110.31h-5.41l-3.6,84.91,6.6-4.31,2.41-80.6Zm10.85-14.71l.26-8.73-1.9-.51-.29,8.8-.47-.11-26.79,2.46-3.04,4.3v2.46l29.96,1.23-.23,7.08h-1.36l-3.61,83.54,2.17,1.64-.33,9.98,1.31,1.23v-.53s1,.53,1,.53l.28-9.5.38.29,4.2-87.17h-2.03l.21-6.99,27.72,1.14v-4.91l-27.42-6.21Zm6.36,102.2l4.18-88.62h-5.37l-4.77,91.7,5.96-3.08Z"
        },
        a2e = {
            key: 11,
            d: "m93.05,35.53l-26.08,4.92-24.45,21.86-5.98,10.38v44.26l17.93,24.04-4.34,11.47-1.63,12.57h5.97l9.78-18.58,14.13,6.01,23.91,1.09,18.47-7.1,11.96,18.58h4.89l-3.26-17.48-3.8-6.56,16.3-22.95,2.71-8.74-1.08-31.69-21.74-30.6-33.69-11.47Zm0,9.29l-22.82,2.73-22.28,23.5-2.72,41.53,16.85,22.95,16.84,8.2h22.83l20.64-8.2,17.94-25.68v-27.87l-17.94-27.32-29.34-9.84Zm-43.06-.95l-18.1,14.83-4.39-8.79,9.32-21.42,13.17-5.49,15.91,5.49-15.91,15.38Zm75.7-19.22l-6.59,5.49,14.81,15.38,20.3,13.18,3.29-16.48-8.23-13.73-11.52-5.49-12.06,1.65Zm-26.62,71.6l.43,1.75h-4.57l-3.43-4.31,2.26-.97-7.57-31.82,2.74-8.24,3.3,8.79,2,31.07,3.56-1.52,1.06,4.36,28.48-.95,1.65,6.59-29.91-4.75Z"
        },
        c2e = {
            key: 12,
            d: "m69.49,164.56l-2.31-27.52-2.31-11.71,20.24,14.05,8.09-2.34-3.47-11.71,25.44,5.27v-11.71h7.52l-7.52,48.6-35.85,3.51-9.83-6.44Zm36.42-51.53h16.77l5.2-38.65-18.5,4.68-30.06,1.76-18.5-4.1,2.89,37.48,22.55,20.49-5.2-17.57,28.33,8.2-3.47-12.3Zm-4.05-96.03l-8.09,2.34-6.36,48.6,5.2,1.17,6.94-2.93,2.31-49.19Zm-34.69,44.5l20.24-2.93-2.31,9.96,8.09,2.93,8.67-2.93v-9.96h7.52l18.5,4.68,2.89,5.27-27.17,8.2h-30.64l-16.77-5.27v-4.68l10.98-5.27Z"
        },
        l2e = {
            key: 13,
            d: "m103.54,79.14c3.75,3.75,11.61,11.66,15.29,15.38l11.94.36,9.82,13.88,9.57,5-5.34,5.75-20.01-1.12-6.72-5.88,5.58,10.88-32.68,16.37c-1.75-8.83-25.23-46.98-29.95-55.38l.3-2.46,3.06,1.23,3.1-2.64-.35,3.56,8.26,4.61-9.79-17.22,3.67-14.45,26.91,23.37,7.34-1.23Zm29.36,51.05l-5.51-6.77-39.9,20.76,2.6,7.07,42.81-21.06Zm-35.1-37.51l-3.61-7.63,1.75,9.66,8.79,1.81-6.94-3.84ZM49.28,25.5l19.34,6.14-.89,8.23-16.37-6.43-1.19,23.94-11.16-1.65-1.34-6.58,5.06-2.24,4.76,2.69,1.79-24.09Z"
        },
        u2e = {
            key: 14,
            d: "m113.21,105.67l-4.54-.06,5.71,9.53-5.6,23.65-17.92,11.54-22.84-.93-16.36-9.49-5.6-21.68,11.21-21.12,3.47-1.71-2.96-29.46-37.82,3.08,24.42-8.18,12.03-8.52-.44-4.41,3.05-.51.51,4.37,10.79,4.97,24.92,6.14-34.09,2.78,3.25,27.93,7.19-3.54h17.81l14.36,7.33,1.94,3.23-.1-20.53,8.51-2.69,19.61-1.13,12.57,2.28v26.08l-33.07,1.02Zm-4.47,10.31l-8.87-14.8c-15.87-6.89-12.89-5.43-29.73-4.94-14.28,9.12-10.25,6.71-18.14,21.11l4.41,19.31,11.92,6.75,19.69,1.3,15.81-10.16,4.92-18.56Zm2.14,28.49l5.08-1.02,9.16-13.3,13.74,13.3,6.1-1.02-16.79-15.86-1.01-18.92h-3.56l1.01,16.37-13.73,20.46Zm4.91-65.65l20.44-.28,6.99,2.82-11.76,2.82h-14.56l-8.95-2.53,7.84-2.82Zm-25.77-47.02l.56-3.38,3.09.56c-1.83,1.31,33.13,29.7,33.88,30.69l-.56,2.53c-4.8.07-32.55-30.02-36.96-30.41Zm-11.19,91.5l-1.4,14.08,9.8-18.3-5.05-.28,5.33-11.26h-11.49l-3.36,16.05,6.16-.28Z"
        },
        h2e = {
            key: 15,
            d: "m59.98,48.46l-21.27-4.71,3.62,10.7-7.02-3.42,4.89,14.33,13.25,21.15,9.7,26c.76-3.14,2.82-11.61,3.98-14.5,3.09,1.02,24.47,12.74,27.87,14.52,0,0,25.33,8.98,25.33,8.98l1.26,15.83,2.98,11.98,5.96-23.32,22.12-5.99c-5.01-1.18-19.81-4.72-24.68-5.35l-14.25-26.53-14.25-16.26,5.53-4.07,12.76-5.56-32.33-.43-11.59-8.32-13.86-5.04Zm-3.82,5.6l-5.11.43,1.91,4.49,4.68-.21-1.48-4.71Z"
        },
        f2e = {
            key: 16,
            d: "m142.26,31l-9.2,7.2-3.58-2.6-15.31,15.45,3.08,2.55-12.78,11.3.7,8.75-7.86-.5-7.16,6.65.45,7.95-8.1-.75-6.66,7.2.15,8.05-9.35-.85-7.66,7.7.2,8.2-7.36-.5-21.48,23.15,9.2,8.2L124.41,60.8l4.57,2.05,20.93-26.2-7.66-5.65Z"
        },
        d2e = {
            key: 17,
            d: "m146.68,31.5v-4.5l-37.79,7-35.8,15.5,3.48,3.5,13.92,2,15.91,13.5,8.45,19,.99,31.5-9.45,15,2.49-18.5-10.44-1.5-1.99,24h-9.45l9.45-42-10.94-2.5-10.94,44.5-4.97-4,6.96-31h-8.95l-5.97,23.5-5.97-6,5.97-24.5,11.44-8.5h23.37l12.43,8.5v-10l-4.47-6-25.85-4.5-26.35,14.5-5.97,32,21.38,28.5,28.84,2.5,9.94-4.5,21.88-29.5v-50.5l3.98-23.5,14.42-13.5Zm-102.43,96.5l-13.92-9c-5.15,5.43-4.51,4.8-5.97,12l27.84,8.5-7.96-11.5Z"
        },
        p2e = {
            key: 18,
            d: "m28.16,121.11c1.64-.98,38.97-20.47,39.27-21.24l.78-4.99,4.57-3.14,5.66,3.02,1.33,6.05h0s-6.01,4.69-6.01,4.69l-4.97-3.16c-3.33,1.67-35.28,19.04-39.4,21.24l-1.22-2.46Zm15.95-3.22l-.76,24.99h8.08l.77-29.36-8.09,4.37Zm97.84-67.95h-8.07l5.06,93.16-7.69.39-5.84-93.93-12.24.09-1.7,23.42,8.11,4.18,5.47,23.75-7.45,23.25-24.87,11.5-24.86-6.75-10.13-18.48c1.6-.86,9.49-5.15,10.95-5.88l5.19,3.3,8.11-6.34-1.81-8.17-7.54-4.03-6.27,4.3-.78,4.97c-1.38,1.04-6.45,3.67-8.05,4.52l.88-15.45,10.19-15.25,3.34-1.03-.55-21.5-17.54.13-1.47,55.84-8.05,4.29,1.83-59.74h-7.69l-6.15-11.22,113.87.23-4.24,10.44Zm-30.79-.28l-37.75.29.54,20.9,14.07-4.35h10.69l10.84,5.58,1.63-22.41Z"
        },
        m2e = {
            key: 19,
            d: "m138.73,54.23c5.47-6.87,7.69-10.3,6.66-10.3l-12.78-10.75-33.21,37-23.02-6.7-12.29,19.55-32.66,14.9-2.59,23.1,23.02,23.15,25.01,1.55,15.86-32.9,20.44-16.45-5.12-19.55,25.06-28.75,5.62,6.15Zm-54.55,30.45c3.58-.17,5.59-.03,6.02.4l2.04,10.25-7.16,5.65-8.21-6.15,2.04-9.75c1.73-.17,3.48-.3,5.27-.4Z"
        },
        g2e = {
            key: 20,
            d: "m96.84,137.12l.5,10.62,26.23-9.42c-.41-5.47,1.42-19.51,2.24-25.07,0,0-3.98-19.97-3.98-19.97,0,0-9.94-22.52-9.94-22.52l-3.48.21c1.23,4.98,5.29,19.7,6.71,24.86-2.89-7.91-10.06-23.22-14.17-30.59l-4.48,1.27,10.19,31.87-13.67-27.83-4.47.64.5,11.47,5.47,15.72c.94,4,1.99,13.09,2.36,17.23l-4.23-8.62-5.84-6.91-5.97,1.06c2.05,5,4.12,17.79,4.85,23.22l11.19,12.75Zm-38.91-36.19l2.98,7.22c1.38-7.94,3.17-24.29,2.98-32.29l4.72-.43c1.66,5.98,1.63,21.33,1.49,27.62l2.98-29.32,4.72.85.5,22.52,1.99-16.99,3.73,1.06-.25,17.63-6.46,1.91,3.23,8.07,1.49,18.06,3.73,2.97-1.24,11.05h-22.62c4.07-15.03,2.83-8.51-8.45-21.67l-1.49-14.45-3.48-5.52,4.47-2.55,4.97,4.25Zm1.24-55.44l9.7,12.25,2.74-3.5-5.97-12-6.46,3.25Zm21.88-11.25l1.99,15,5.47-.75.25-14.25h-7.71Zm23.12,7.5l-2.98,8,3.23,1.5,3.98-7.25-4.23-2.25Zm-18.15,48.12l-.87,8.5,2.11.38,2.24,2-.25-10.12-3.23-.75Z"
        },
        _2e = {
            key: 21,
            d: "m33.69,105.38l2.49-12,25.35-9.25.13-5.38-4.1-4.25,2.98-3.75,19.02-4.62,16.53.88,4.1,4.38-2.48,2.38v2.62l42.39-8.12,7.45,3.75,2.61,7.75c-12.02,4.91-87.41,37.74-98.07,40.12l-13.93-6.5-4.47-8Zm60.43-33.09l-3.13-2.41-12.68-.51-10.94,2.43-2.74,2.08,6.82,3.21,18.07-1.8,4.6-3Zm-55.71,24.09l12.68,4.25,3.98,7-3.23,8.75-12.43-5-1.99-6.75.99-8.25Z"
        },
        y2e = {
            key: 22,
            d: "m109.89,63.5l-22.87,9-24.86-9-30.83,19.15,16.93,28.14,18.38,8.21,40.28,2.5,22.37-9.35,20.09-25.87v-6.78l-39.48-16Zm-49.67,31.06l-3.16.68-4.29-9.08,8.8,1.59-1.35,6.81Zm13.77,4.31l-4.97.91-3.84-2.27-1.35-9.76,10.38,2.95-.22,8.17Zm14.07,3.4l-10.24-2.48-1.46-9.09,13.65.28-1.95,11.3Zm17.97-4.9l-4.2,4.9-10.01-.52.46-10.32,13.98-2.32-.23,8.26Zm12.31-1.35l-3.88,2.85-6.39-1.22v-9.38l10.83-1.43-.56,9.17Zm5.98-3.16h-2.71l-.9-6.13,7.22-1.82-3.61,7.94Z"
        },
        v2e = {
            key: 23,
            d: "m12.46,108.65l9.4-14.49.8-18.31,21.32-17.01c26-8.68,80.89-27.99,108.45-26.26l-1.35,11.87-41.55,44.71c-5.94,13.24-17.78,39.97-23.55,53.25l-18.5-6.22-3.41-13.39-10.67-5.49-16.66.99-24.28-9.66Zm72.27-52.61l6.52-4.42,6.06,6.67-7.93,3.14-4.65-5.39Zm-12.94.59l-9.73,2.5,5.7,11.7,11.27-2.9.35-7.22-7.59-4.08Zm-21.32,17.01l5.6-8.03,8.51,9.88-9.57,7.4-4.54-9.26Zm-18.52,12.99l2.13-8.78,9.5.85,2.75,10.81-8.71,2.24-5.67-5.13Zm66.24-7.71l-2.65,6.72,7.17-1.84-4.52-4.87Zm17.75-13.89l-4.97,6.22,5.27,1.39-.3-7.6Zm7.54-4.68l7.79-5.84-3.03,9.56-4.76-3.71Z"
        },
        b2e = {
            key: 24,
            d: "m23.56,131.42l18.51-91.04,29.67-25.74,33.96,4.31,11.76,8.16,10.73,28.54-3.15,22.92,8.43,15.77,14.53,15.7-9.31,48.94-12.75-.76,5.82-24.58-13.6-3.26-3.08,19.12-8.64-2.07,4.45-18.79-12.23-2.93-3.94,16.62-8.43.27,4.45-18.79-12.95-3.1-4.45,18.79-7.92-1.9,4.45-18.79-15.11-3.62-4.45,18.79-5.96-3.72,3.94-16.62-7.92-1.9-5.82,24.58-9.15.1-1.85-5.03Z"
        },
        E2e = {
            key: 25,
            d: "m60.17,144l-22.87-13-1.49-16.5,10.94-13,22.38,6.5,66.63,8.5,13.92,12.5-20.39,11.5-69.11,3.5Zm-9.45-61l3.48,12.5,10.94,3,60.66,7,6.96-15-10.44-18.5-17.4-.5-38.78-5-15.41,16.5Zm26.35-35.5l3.48,13.5,28.84,5,8.95-7-11.44-15-17.9-16-11.93,19.5Z"
        },
        T2e = {
            key: 26,
            d: "m77.74,100l-34.1-3.25-17.28-13,.46-1.86,13.08-7.43,29.43-4.18,24.29,5.11,12.15,8.82,1.4,4.64-29.43,11.14Zm26.63-29.71l6.07,4.18,1.87,5.11.93-8.36,44.38-30.64v-3.71l-6.54-1.86-46.71,35.29Zm-84.51,10.29l3.28-7.07,16.87-9.42,30.93-2.83,26.71,6.12,12.18,8.48c.89,1.78,2.19,5.68,2.69,7.62l.12-.08c0,.08-.05.4,0,.47l-.04.03-4.18,50.86-6.56,11.78-34.67,8.95-43.11-11.78-4.69-8.95c0-.65,0-50.72,0-51.36h.07l.4-2.83Zm3.89,4l19.54,14.85c37.75,2.97,29.57,5.77,65.13-8.95.02-2.45-.02-7.41,0-9.9,0,0-1.4-2.83-1.4-2.83l-11.25-8.48-25.77-5.65-29.99,3.77s-14.52,8.48-14.52,8.48l-1.74,8.71Z"
        },
        S2e = {
            key: 27,
            d: "m90.8,24.7l5.32,11.1-53.85,92.05,3.83,18.7,23.52,10.35,21.13-7.5,14.02-27.6,9.35-4.95,11.73,8.2,11.24-9c-1.15-31.16,2.45-23.17-14.52-49.8l-7.96,3.4-3.13,12.75-15.86,7.25-23.77,35.6-11.34,4.25,27.74-54,10.54-5.2-1.29-9.2,9.35-4.9-3.18-7.55,8.05-9.9-10.79-22.75-33.07,4.7c.4.27,1.97,1.85,4.72,4.75l18.2-.75Zm41.82,65.7l-.35,21-5.62,5.65-12.68-21.05c.99-.63,3.88-7.57,8.65-20.8l9.99,15.2Z"
        },
        w2e = {
            key: 28,
            d: "m77.17,127.37l10.11-14.39,5.21,6.77-5.22,12.75-8.47,3.82-1.63-8.95Zm-14.83-68.54l14.88,4.82-.36-13.78-5.26-5.38-17.4-.25-13,9.1-5.4,18.9,8.54,14.31.52-13.82,14.97,3.57,2.51-17.48Zm49.89,60.82l-33.7-30.5,7.99-12.39-1.24-18.25-3.28-3.36.41,15.46-15.96-5.18-2.45,17.02-14.37-3.43-.39,10.21-.69-.03,9.88,5.06,15.33-1.18,31.53,37.05,8.2.38-1.26-10.85Zm18.54-71.4l-15.66-5.5-15.94,5.11-2.85,4.6c6.07,4.35,29.16,20.99,43.68,31.45l.22-.16,1.74-20.25-11.19-15.25Zm-40.52,14l.89,16.27,9.98,12.33-5.77,9.97,6.3,4.91,6.63-11.93,16.93.76,10.52-7.58c-14.36-10.35-35.84-25.82-42.05-30.27l-3.43,5.53Z"
        },
        O2e = {
            key: 29,
            d: "m49.2,140.64l21.41,9.36h12.43l-17.02-41.39-16.82,32.03Zm47.98-40.37l-23.49-.78-6.39,6.43-.25-.05,17.45,42.44,16.8-43.3-4.12-4.74Zm11.35-22.26c-2.55.06-25.98-.64-27.72.27l-33.53-21.44-2.66,1.53-.73,3.63,28.78,17.45-19.98,2.87-7.75,9.73,3.76,4.16-.93,42.89,17.74-33.78-4.99-6.7-8.75-2.01-4.2-4.64,6.19-7.77,21.61-3.1c3.2,2.03,17.7,10.16,19.72,13.17h5.58l-3.22-5.74c-2.72-1.2-11.42-6.9-14.06-8.58,10.06-.62,30.68.23,40.47,2.03l11.2,10.8-1.37,3.38-13.36,47.75,10.44-3.38c.85-5.61,2.7-44.42,6.65-48.25l-12.66-12.2-16.24-2.04Zm-22.53,71.99h15.45l16.03-5.19-15.26-36.63-16.22,41.82Zm45.33-55.42l-20.36,5.25-7.82,5.38,15.51,37.25,13.13-46.9-.46-.97Zm-39.55-31.98l47.58-28.86-.73-3.63-2.66-1.53-46.12,29.49-3.9,1.04-4.75,5.88h6.86l3.72-2.4Z"
        },
        A2e = {
            key: 30,
            d: "m96.91,94.69l-40.1,37.2-.35,4.43,9.54,1.24c17.83-19.69,56.26-57.76,76.9-74.14,0,0,6.12-12.02,6.12-12.02l-2.75-2.93-6.32,10.76-35.43,26.56,1.61-16.48-4.16.51-5.06,24.87Zm-12.39,57.75l-4-1.61-3.54-19.79,4.74-5.18,7.61,21.75-4.81,4.83Zm-10.82-105.44l-.79,26.1,4.8,32.62-5.6,6.04-5.21-40.27,1.6-24.97-4-14.9,2.8-2.01,6.22,16.42,1.39-1.92.8-8.05,8.81-7.25,7.21-2.82-5.61,12.89c-2.48,1.51-10.41,6.21-12.42,8.13Z"
        },
        C2e = {
            key: 31,
            d: "m89.92,93.77h-7.46v5.42l11.55,14.47h6l1.55-5.81-11.65-14.09Zm-15.79,4.34h-7.09v4.87l11.14,19.02,6.59-2.28v-4.68l-10.64-16.94Zm-28.52,28.55l-6.86-23.14-6.92,1.72c-1.41,3.01,6.49,23.58,7.33,26.75l6.46-1.74v-3.59Zm6.94-20.63h-7.34c-1.63,2.3,8.39,23.48,9.14,25.94l6.41-1.72v-5.07l-8.21-19.15Zm-22.09,16.38l-5.73-22.79-6.29,1.81c-1.07,3.36,4.56,23.76,5.29,27.39l6.73-1.79v-4.62Zm78.94-23.38v5l16.22,13.17,6.68-1.84v-5l-16.93-11.32h-5.96Zm34.44,18.21l-17.38-14.53.79-4.56,5.31.71,18.93,12.3-.6,5.44-7.04.65Zm13.74.48l-12.4-13.95,2.15-2.63c4.21.95,15.12,11.41,18.37,14.22l-1.91,4.21-6.2-1.84Zm-75.07-34.29c-.48.14-10.17,4.68-10.83,4.73-.25,0-12.45,0-12.7,0-.34-.12-10.49-4.72-10.57-4.7l.07-.72s2.83-28.51,2.83-28.51c.03-.3.09-.95.12-1.24l9.43,2.91,16.24-4.03c.05.31.14.84.2,1.15l5.08,29.64.13.77Zm-5.69-33.16l-15.68,3.79-9.55-2.73c.04-.39.15-1.47.18-1.85.18-.08,9.22-4.03,9.57-4.18l.26.03,4.78.5-2.84,3.86,1.41.42,3.16-4.11c1.34.14,6.75.7,8.12.84l.13.75.46,2.68Zm24.78-1.54v-3.06c.3-.13,10.2-4.54,10.64-4.74.32.09,15.27,4.33,15.61,4.42,0,0,.59.17.59.17.08.41.37,1.91.46,2.35l-5.92,3.51h-10.02l.56-4.24h-1.84l-.56,4.09-9.52-2.51Zm33.12,28.89c-.34.08-12.12,6.23-12.69,6.21-.27,0-12.49,0-12.75,0-.38-.2-7.44-4.13-7.68-4.25v-28.25l9.24,2.03h12.56l5.84-3.74s.11.56.11.56c.08.43.2,1.04.29,1.47l4.93,25.23.15.75Z"
        },
        k2e = {
            key: 32,
            d: "m99.3,92.93l-3.61-1.98-1.17-28.88-23.92,16.44-2.38-2.24,12.43-25.72-9.09,9.53c-5.64,10.97-13.99,55.75-16.64,68.36l14.94,10.64,18.39,5.15c3.65-5.69,34.94-47.4,35.23-53.27l-4.51-19.67-19.67,21.63Zm22.41-38.01l-18.14-9.48-13.49-2.39c-.45.28-5.25,2.72-5.32,3.2,0,0-12.1,27.46-12.1,27.46l20.66-13.18,2.82,1.61,2.35,26.05,18.26-17.25,3.72-.31,4.28,17.4c2.08-1.2,2.17-23.76,2.49-26.04l-5.53-7.08Zm-26.79-1.35l-6.24-8.3,13.37,1.49,17.02,8.82,6.21,6.62-2.43,1.04-2.8,6.41-3.56-.06.35-6.49-15.43-6.38-4.61,4.43-2.92-1.97,1.04-5.61Z"
        },
        I2e = {
            key: 33,
            d: "m87.02,41l-13.93,2-20.88,12.5-11.93,23,4.47,34,20.39,20,23.37,5,22.37-6,19.39-21,4.98-24-4.98-18.5-14.41-18-28.84-9Zm0,3l-13.43,2.5-17.9,11-10.94,22,5.97,31,15.41,16.5,22.38,5.5,20.38-6,16.41-17.5,5.47-22.5-3.98-17-12.92-17-26.85-8.5Zm-13.43,7l13.43-3,24.86,7.5,12.93,15.5,3.48,15.5-4.98,21.5-14.42,16.5-20.38,6-21.38-6-14.42-15-5.47-29.5,11.44-19.5,14.91-9.5Zm4.91-16l-2.5,5.5,11.5-2,12.5,3.5-2.5-7-10-4-9,4Zm39,9l-5,3,5,1.5,13,15,2-4.5-3-10.5-12-4.5Zm24.5,36l-6.5-2.5,2.5,8.5-3,14.5,7-2,3.5-8-3.5-10.5Zm-9.5,38l-2-3-5,5.5-1,5.5h-5.5l-5,5.5,10.5,2,6.5-6,1.5-9.5Zm-78,6l6.5,7.5-8,2-8-5-1.5-9,1.5-4,9.5,8.5Zm-14-34.5l.5,11.5-8.5-4-2.5-8.5,4-8.5,5-2.5,1.5,12Zm11-35.5l-5.5,9.5-2.5-6.5,1-5.5,6-5.5,8.5-1,4,2-11.5,7Z"
        },
        N2e = {
            key: 34,
            d: "m161.04,93.27l-12.38-4.03-14.35,4.42,5.02-3.18-5.13-28.91-27.91-35.21-8.65,2.32-8,30.66-58.69,33.9-10.32,22.53,14.12,15.36,61.71-19-2.62,16.91-16.49,5.87-6.37-4.58,2.61,13.99,4.22,1.59,1.53-4.63,77.83-25.44,7.25-12.75-3.38-9.83Zm-54.39-54.96l2.24-1.75c19.2,24.13,17.77,14.98,22.62,46.25l-16.41-10.06-9.7-24.75,1.24-9.69ZM39.76,122.81l-6.22-11.33,4.93-8.66,19.83-7.11,11.47,17.85-30.01,9.25Zm35.26-10.87l-12.18-17.86,39.04-14c4.09,1.56,24.23,12.54,28.52,14.79l-55.38,17.07Zm23.41,15.48l2.58-16.68,46.26-14.24,6.98,2.44,1.17,8.2-56.98,20.28Z"
        },
        x2e = {
            key: 35,
            d: "m47.24,133.05l-1-12.8-17.9,15.9,7.66,12.35c2.48-3.18,11.04-14.26,11.24-15.45ZM111.13,19l-5.62,3.6,6.12,19.5.5,11.85-15.81,17.95-16.86,1.55,3.58,11.3-12.78-3.05.5,16.45-12.78-1.55,2.54,11.8-7.16,7.2,3.08,20.55,15.32,14.9,21.48-5.15,42.41-53.45-16.36-22.05-6.12,9.75,8.7,14.4-31.72,40.6-22.47,2.05-1.54-24.15c10.99-10.41,51.89-49.15,54.69-50.9,0,0,17.4-1.05,17.4-1.05l11.24,6.2,5.62-5.15-16.36-31.35-27.6-11.8Z"
        },
        P2e = {
            key: 36,
            d: "m104.6,33.79l-19.23-4.32,6.34-4.1,21.95-1.14,16.97,2.96-.9,4.32-25.11,2.28Zm-6.22,47.78l-1.58,1.71,2.15,38.23v22.18l-8.82,8.65-14.82-1.82-9.05-5.23-1.47-54.49-1.02-25.48,5.43-10.92,10.3-.23,9.28,8.3,1.13,17.07,4.64-4.89-2.38-23.55-7.81-9.21-16.74-.11-11.88,11.95-1.47,27.99,2.83,55.52,7.01,17.52,14.48,8.53,19.91-1.82,13.69-16.5,3.17-33.56,3.05-30.6-9.62,1.48-10.41-.68Zm23.87-60.07l-28.74.11-15.84,6.26,2.94,5.01,8.26,4.89,4.98,10.47,2.49,24,13.35,1.14,9.16-2.73,4.07-26.62,13.12-11.83,2.49-5.23-16.29-5.46Zm6.22,46.53l-.43,1.67-.37-1.1-6.69,4.76-11.79,2.18-13.46-.61-5.4,6.9.91,53.29-6.74,9.3-8.63-1.86-3.28-5.8-.11-13.54-.9-34.58,4.19-3.3,6.34,2.42.23,19.6.4,21.34,3.23,5.77,4.07-1.47-.23-4.89-2.04-.23-.11-20.36-.11-24h.11s-.23-6.37-.23-6.37l-2.72-5.8-3.85,5.23-3.85-5.01-3.73,4.55-5.43-4.89-1.92,4.09.68,8.65,1.95-.04-2.2,1.84.93,38.29.24,16.97,6.25,7.26,14.55.98,7.47-10.24.45-18.43-1.02-37.54,2.64-3.48,11.65.53,12.87-2.38,7.45-2.64-.2-.6,1.44.94-2.6-7.4Z"
        },
        R2e = {
            key: 37,
            d: "m48.73,122.5L124.81,49l-3.48-7,1.99-8.5,8.45-6,10.94,1.5,5.97,11-1.49,9-7.96,6-12.43-3L47.74,127.5l-6.46-3-4.97-25.5-5.47-3-4.47,8,6.46,44.5,62.15-30.5v-8.5l36.8-28c10.93.14,9.2-1.4,18.89,4.5l3.98,15v8.5l-51.71,18-5.97-5-66.13,30.5c-.41-5.83-9.79-52.57-5.97-57l7.95-5,6.46,5,4.97,25,4.48,1.5Z"
        },
        M2e = {
            key: 38,
            d: "m19.41,121.34l94.13-60.35,7.87.88,12.68-6.59.53-6.74,11.34-8.03,9.04,4.57,2.51,5.12-.43,7.28-9.91,6.67-8.41-.79-11.52,6.95-.97,7.38-80.27,57.45-12.17-3.48-3.59-4.94-6.17-3.94-4.3.73-.36-2.16Zm22.7-9.4l5.19,4.66.71-5.67-5.9,1Z"
        },
        D2e = {
            key: 39,
            d: "m45.06,63.28l42.73-12.28,46.65,11.84-.12.5-43.48,15.28-45.21-13.47-.57-1.88Zm.65,3.12l18.97,62.33,27.91,8.77,26.16-9.21,15.53-63.77-43.87,20.36-44.7-18.48Z"
        },
        $2e = {
            key: 40,
            d: "m40.27,92.25l-16.16,39.25,9.08,3,11.31-3,9.45-38.51c-6.91-2.1-6.54-2.31-13.68-.74Zm6.71,38.51l9.95-37.02,5.59-1.61,6.59,1.8-6.71,36.83-8.33,3-7.09-3Zm25.36-35.72l6.34-1.54,5.84,2.28-2.48,33.97-8.7,3.24-7.71-2.69,6.71-35.27Zm12.68,34.79l2.74-33.32c5.79-1.83,5.65-1.57,11.43-.17l3.48,33.48c-9.59,2.74-8.17,2.3-17.65,0Zm18.4-32.18l5.22-1.16,5.22,1.34,7.71,30.51-7.46,2.12-7.96-2.12-2.73-30.69Zm14.92,1.86l5.71-1.38,5.72,1.19,8.45,27.53-6.21,1.65-7.46-2.21-6.21-26.79Zm23.37,25.3l-7.46-24.55,4.35-1.12,5.34,1.12,10.44,24.18-5.59,1.94-7.08-1.57Zm-35.31-49.8l42.52-30.25,2.23,3.25-42.01,31.5-1.99,8.25-8.95,1.75-5.97-5.25,1.49-7.25,7.21-4,5.47,2Zm-32.81-5.5l-18.15-34.75-3.73,1.5,17.65,35-3.23,7.5,5.47,6.75,7.95-2.5,3.48-7-2.98-5.75-6.46-.75Z"
        };

    function L2e(t, e, n, r, s, i) {
        return G(), H("svg", {
            viewBox: "0 0 180 180",
            class: Xe(["instrument", `type-${t.categoryClass}`])
        }, [t.icon === "accordion" ? (G(), H("path", Zbe)) : t.icon === "banjo" ? (G(), H("path", Xbe)) : t.icon === "bell" ? (G(), H("path", Jbe)) : t.icon === "bongos" ? (G(), H("path", Qbe)) : t.icon === "canon" ? (G(), H("path", e2e)) : t.icon === "cap" ? (G(), H("path", t2e)) : t.icon === "car" ? (G(), H("path", n2e)) : t.icon === "castanets" ? (G(), H("path", r2e)) : t.icon === "cat" ? (G(), H("path", s2e)) : t.icon === "cello" ? (G(), H("path", i2e)) : t.icon === "chimes" ? (G(), H("path", o2e)) : t.icon === "clock" ? (G(), H("path", a2e)) : t.icon === "cup" ? (G(), H("path", c2e)) : t.icon === "dog" ? (G(), H("path", l2e)) : t.icon === "drumKit" ? (G(), H("path", u2e)) : t.icon === "fish" ? (G(), H("path", h2e)) : t.icon === "flute" ? (G(), H("path", f2e)) : t.icon === "frenchHorn" ? (G(), H("path", d2e)) : t.icon === "gong" ? (G(), H("path", p2e)) : t.icon === "guitar" ? (G(), H("path", m2e)) : t.icon === "hands" ? (G(), H("path", g2e)) : t.icon === "kazoo" ? (G(), H("path", _2e)) : t.icon === "mouth" ? (G(), H("path", y2e)) : t.icon === "ocarina" ? (G(), H("path", v2e)) : t.icon === "piano" ? (G(), H("path", b2e)) : t.icon === "poop" ? (G(), H("path", E2e)) : t.icon === "pots" ? (G(), H("path", T2e)) : t.icon === "sax" ? (G(), H("path", S2e)) : t.icon === "shaker" ? (G(), H("path", w2e)) : t.icon === "snare" ? (G(), H("path", O2e)) : t.icon === "sticks" ? (G(), H("path", A2e)) : t.icon === "synth" ? (G(), H("path", C2e)) : t.icon === "tallBongo" ? (G(), H("path", k2e)) : t.icon === "tamborine" ? (G(), H("path", I2e)) : t.icon === "trombone" ? (G(), H("path", N2e)) : t.icon === "trumpet" ? (G(), H("path", x2e)) : t.icon === "tuba" ? (G(), H("path", P2e)) : t.icon === "vibraslap" ? (G(), H("path", R2e)) : t.icon === "whistle" ? (G(), H("path", M2e)) : t.icon === "woodblock" ? (G(), H("path", D2e)) : t.icon === "xylophone" ? (G(), H("path", $2e)) : Be("", !0)], 2)
    }
    const F2e = ot(zbe, [
            ["render", L2e],
            ["__scopeId", "data-v-74251a63"]
        ]),
        U2e = mt({
            props: {
                lanes: {
                    type: Number,
                    required: !1
                }
            },
            computed: {
                viewbox() {
                    return this.lanes === 1 ? "0 0 30 150" : this.lanes === 2 ? "0 0 80 150" : this.lanes === 3 ? "0 0 130 150" : this.lanes === 5 ? "0 0 230 150" : this.lanes === 6 ? "0 0 280 150" : "0 0 180 150"
                }
            }
        }),
        B2e = ["viewBox"],
        q2e = {
            key: 0,
            width: "30",
            height: "150",
            rx: "8",
            ry: "8"
        },
        j2e = {
            key: 1,
            x: "50",
            width: "30",
            height: "150",
            rx: "8",
            ry: "8"
        },
        V2e = {
            key: 2,
            x: "100",
            width: "30",
            height: "150",
            rx: "8",
            ry: "8"
        },
        G2e = {
            key: 3,
            x: "150",
            width: "30",
            height: "150",
            rx: "8",
            ry: "8"
        },
        W2e = {
            key: 4,
            x: "200",
            width: "30",
            height: "150",
            rx: "8",
            ry: "8"
        },
        H2e = {
            key: 5,
            x: "250",
            width: "30",
            height: "150",
            rx: "8",
            ry: "8"
        },
        K2e = {
            key: 6,
            y: "66",
            width: "180",
            height: "18",
            rx: "9",
            ry: "9"
        },
        Y2e = {
            key: 7,
            cx: "40",
            cy: "75",
            r: "25"
        };

    function z2e(t, e, n, r, s, i) {
        return G(), H("svg", {
            viewBox: t.viewbox
        }, [t.lanes ? (G(), H("rect", q2e)) : Be("", !0), t.lanes && t.lanes > 1 ? (G(), H("rect", j2e)) : Be("", !0), t.lanes && t.lanes > 2 ? (G(), H("rect", V2e)) : Be("", !0), t.lanes && t.lanes > 3 ? (G(), H("rect", G2e)) : Be("", !0), t.lanes && t.lanes > 4 ? (G(), H("rect", W2e)) : Be("", !0), t.lanes && t.lanes > 5 ? (G(), H("rect", H2e)) : Be("", !0), t.lanes ? Be("", !0) : (G(), H("rect", K2e)), t.lanes ? Be("", !0) : (G(), H("circle", Y2e))], 8, B2e)
    }
    const Z2e = ot(U2e, [
            ["render", z2e],
            ["__scopeId", "data-v-8ddc6f95"]
        ]),
        X2e = {},
        J2e = {
            viewBox: "0 0 65 100"
        },
        Q2e = B("path", {
            d: "m65,5.22v89.56c0,4.32-4.68,6.76-7.91,4.13L1.84,53.88c-2.45-2-2.45-5.76,0-7.76L57.09,1.09c3.23-2.63,7.91-.19,7.91,4.13Z"
        }, null, -1),
        eEe = [Q2e];

    function tEe(t, e) {
        return G(), H("svg", J2e, eEe)
    }
    const nEe = ot(X2e, [
            ["render", tEe]
        ]),
        rEe = mt({
            components: {
                ChangeVIP: vm,
                PlayerHeader: fl,
                ContinuousTester: xbe,
                DiscreteTester: Ube,
                AvatarSVG: g0,
                CategorySVG: k6,
                InstrumentSVG: F2e,
                LanesSVG: Z2e,
                LeftArrowSVG: nEe
            },
            props: {
                beatmaps: {
                    type: Object,
                    required: !0
                },
                info: {
                    type: Object,
                    required: !0
                },
                instruments: {
                    type: Object,
                    required: !0
                },
                players: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                }
            },
            data() {
                return {
                    audienceIndex: 0,
                    showChangeVIP: !1,
                    showUnlocked: !1
                }
            },
            computed: {
                selectedChoice() {
                    return this.instrumentChoices.find(t => t.isSelected)
                },
                selectedBeatmap() {
                    return this.beatmaps[this.selectedChoice.beatmapSlug]
                },
                selectedInstrument() {
                    return this.instruments[this.selectedChoice.instrumentSlug]
                },
                mappedPlayers() {
                    const t = {};
                    return Object.values(this.players).forEach(e => {
                        if (!e.beatmapSlug || !e.instrumentSlug) return;
                        const n = `${e.beatmapSlug}:${e.instrumentSlug}`;
                        t[n] || (t[n] = []), t[n].push(e)
                    }), t
                },
                instrumentChoices() {
                    const t = [];
                    return this.player.instruments.instruments.forEach((e, n) => {
                        let r = !1;
                        this.info.isAudience && n === this.audienceIndex && (r = !0), e.beatmapSlug === this.info.beatmapSlug && e.instrumentSlug === this.info.instrumentSlug && (r = !0);
                        const s = Ii.difficultyI18ByNumber(this.beatmaps[e.beatmapSlug].config.difficulty);
                        t.push({
                            isSelected: r,
                            index: n,
                            label: e.instrumentName,
                            category: e.beatmapCategory,
                            beatmapSlug: e.beatmapSlug,
                            instrumentSlug: e.instrumentSlug,
                            difficulty: this.beatmaps[e.beatmapSlug].config.difficulty,
                            difficultyName: this.$t(s),
                            players: this.mappedPlayers[`${e.beatmapSlug}:${e.instrumentSlug}`] ?? []
                        })
                    }), t.sort((e, n) => e.difficulty === n.difficulty ? e.category === n.category ? e.index - n.index : e.category < n.category ? -1 : 1 : e.difficulty - n.difficulty), t
                },
                categoryName() {
                    return this.selectedBeatmap ? this.$t(Ii.categoryI18ByKey(this.selectedBeatmap.config.category)) : ""
                },
                categoryClass() {
                    return this.selectedBeatmap ? Ii.categorySlugByKey(this.selectedBeatmap.config.category) : ""
                }
            },
            mounted() {
                this.info.isAudience && this.setAudienceChoice(0)
            },
            methods: {
                onDidRequestChangeVIP() {
                    this.showChangeVIP = !0
                },
                onDidRequestModalClose() {
                    this.showChangeVIP = !1, this.showUnlocked = !1
                },
                async onBackClick() {
                    if (this.player.responseKey) try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            backToSongSelect: !0
                        })
                    } catch (t) {
                        this.$handleEcastError(t)
                    }
                },
                async onInstrumentClick(t) {
                    if (!this.player.responseKey) {
                        this.setAudienceChoice(t);
                        return
                    }
                    const e = this.instrumentChoices[t];
                    try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            selectInstrument: {
                                beatmapSlug: e.beatmapSlug,
                                instrumentSlug: e.instrumentSlug
                            }
                        })
                    } catch (n) {
                        this.$handleEcastError(n)
                    }
                },
                setAudienceChoice(t) {
                    this.audienceIndex = t, ln.set("beatmap", this.instrumentChoices[t].beatmapSlug, "code"), ln.set("instrument", this.instrumentChoices[t].instrumentSlug, "code")
                },
                async onStartClick() {
                    if (this.player.responseKey) try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            startSong: !0
                        })
                    } catch (t) {
                        this.$handleEcastError(t)
                    }
                }
            }
        }),
        sEe = {
            class: "instrument-select"
        },
        iEe = {
            class: "constrain menu has-header"
        },
        oEe = {
            class: "title-wrapper"
        },
        aEe = {
            class: "title"
        },
        cEe = ["aria-label"],
        lEe = {
            class: "choices-wrapper"
        },
        uEe = {
            class: "choices"
        },
        hEe = ["onClick"],
        fEe = {
            class: "sub"
        },
        dEe = {
            class: "avatars"
        },
        pEe = {
            class: "details"
        },
        mEe = {
            class: "info"
        },
        gEe = {
            class: "name"
        },
        _Ee = {
            class: "label"
        },
        yEe = {
            class: "value"
        },
        vEe = {
            class: "box difficulty"
        },
        bEe = {
            class: "label"
        },
        EEe = {
            class: "value"
        },
        TEe = {
            class: "box lanes"
        },
        SEe = {
            class: "label"
        },
        wEe = {
            class: "value"
        };

    function OEe(t, e, n, r, s, i) {
        const a = st("LeftArrowSVG"),
            c = st("InstrumentSVG"),
            u = st("AvatarSVG"),
            h = st("CategorySVG"),
            d = st("LanesSVG"),
            p = st("ContinuousTester"),
            m = st("DiscreteTester"),
            _ = st("PlayerHeader"),
            y = st("ChangeVIP"),
            v = On("t");
        return G(), H("div", sEe, [B("div", iEe, [B("div", oEe, [Ke(B("h3", aEe, null, 512), [
            [v, "MENU.CHOOSE_INSTRUMENT"]
        ]), t.info.isVip ? (G(), H("button", {
            key: 0,
            "aria-label": t.$t("ACTION.BACK"),
            class: "back",
            onClick: e[0] || (e[0] = (...w) => t.onBackClick && t.onBackClick(...w))
        }, [Je(a)], 8, cEe)) : Be("", !0)]), B("div", lEe, [B("div", uEe, [(G(!0), H(Tt, null, $n(t.instrumentChoices, (w, b) => (G(), H("button", {
            key: b,
            class: Xe([{
                selected: w.isSelected
            }, "choice has-icon has-sub"]),
            onClick: Pi(I => t.onInstrumentClick(b), ["prevent"])
        }, [Je(c, {
            category: w.category,
            slug: w.instrumentSlug,
            class: "icon"
        }, null, 8, ["category", "slug"]), Nn(" " + vt(w.label) + " ", 1), B("span", fEe, vt(w.difficultyName), 1), B("div", dEe, [(G(!0), H(Tt, null, $n(w.players, I => (G(), H("div", {
            key: I.name,
            focusable: "false",
            class: "avatar-wrapper"
        }, [Je(u, {
            avatar: I.avatar
        }, null, 8, ["avatar"])]))), 128))])], 10, hEe))), 128))])]), B("div", pEe, [B("div", mEe, [B("p", gEe, vt(t.selectedChoice.label), 1), B("div", {
            class: Xe(["box part", t.categoryClass])
        }, [Je(h, {
            category: t.selectedBeatmap.config.category,
            class: "icon"
        }, null, 8, ["category"]), Ke(B("p", _Ee, null, 512), [
            [v, "MENU.SONG_PART"]
        ]), B("p", yEe, vt(t.categoryName), 1)], 2), B("div", vEe, [Ke(B("p", bEe, null, 512), [
            [v, "MENU.DIFFICULTY"]
        ]), B("p", EEe, vt(t.selectedChoice.difficultyName), 1)]), B("div", TEe, [Ke(B("p", SEe, null, 512), [
            [v, "MENU.LANES"]
        ]), B("p", wEe, [Je(d, {
            lanes: t.selectedBeatmap.config.laneCount ?? null,
            class: "icon"
        }, null, 8, ["lanes"]), Nn(" " + vt(t.selectedBeatmap.config.laneCount ?? ""), 1)])])]), t.selectedBeatmap.config.type === "Continuous" ? (G(), Ut(p, {
            key: 0,
            "scale-key": "C",
            "scale-type": "major",
            beatmap: t.selectedBeatmap,
            instrument: t.selectedInstrument
        }, null, 8, ["beatmap", "instrument"])) : (G(), Ut(m, {
            key: 1,
            "scale-key": "C",
            "scale-type": "major",
            beatmap: t.selectedBeatmap,
            instrument: t.selectedInstrument
        }, null, 8, ["beatmap", "instrument"]))]), t.info.isVip ? Ke((G(), H("button", {
            key: 0,
            class: "commit",
            onClick: e[1] || (e[1] = (...w) => t.onStartClick && t.onStartClick(...w))
        }, null, 512)), [
            [v, "MENU.START_SONG"]
        ]) : Be("", !0)]), Je(_, {
            info: t.info,
            players: t.players,
            "is-vip": t.info.isVip && !t.info.isSolo,
            "response-key": t.player.responseKey,
            onDidRequestChangeVip: t.onDidRequestChangeVIP
        }, null, 8, ["info", "players", "is-vip", "response-key", "onDidRequestChangeVip"]), Je(Li, {
            name: "modal"
        }, {
            default: si(() => [t.showChangeVIP && t.player.responseKey ? (G(), Ut(y, {
                key: 0,
                info: t.info,
                players: t.players,
                "response-key": t.player.responseKey,
                onDidRequestClose: t.onDidRequestModalClose
            }, null, 8, ["info", "players", "response-key", "onDidRequestClose"])) : Be("", !0)]),
            _: 1
        })])
    }
    const AEe = ot(rEe, [
            ["render", OEe],
            ["__scopeId", "data-v-f1397ade"]
        ]),
        CEe = mt({
            components: {
                PlayerHeader: fl
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                }
            },
            data() {
                return {
                    isOn: !1
                }
            },
            methods: {
                onClick() {
                    this.isOn = !this.isOn
                }
            }
        }),
        kEe = {
            class: "constrain"
        },
        IEe = Q5('<circle class="glow glow-2" cx="100" cy="100" r="100" data-v-6bf0f020></circle><circle class="glow glow-1" cx="100" cy="100" r="50" data-v-6bf0f020></circle><circle class="glow glow-0" cx="100" cy="100" r="30" data-v-6bf0f020></circle><path class="body" d="m111.81,34.5c2.73-.71,4.59,3.41,6.88,1.97.59-.59.59-1.54,0-2.12-5.3-5.69-15.7-2.2-16.51,5.52-1.04-.1-2.12-.14-3.17-.09-.87-7.67-11.22-11.09-16.49-5.43-.59.59-.59,1.54,0,2.12.59.59,1.54.59,2.12,0,3.62-3.88,10.72-1.6,11.39,3.66-24.46,2.26-11.41,69.01,3.97,68.2,15.07.8,28.11-63.97,5.13-67.94.34-3.28,3.37-5.96,6.67-5.89Z" data-v-6bf0f020></path><path class="bottom-wing left" d="m98.71,50.9c8.7,7.81-21.59,50.03-31.91,39.49-8.7-7.81,21.59-50.03,31.91-39.49Z" data-v-6bf0f020></path><path class="bottom-wing right" d="m101.29,50.9c10.33-10.54,40.62,31.68,31.91,39.49-10.33,10.54-40.62-31.68-31.91-39.49Z" data-v-6bf0f020></path><path class="top-wing left" d="m98.58,48.04c9.59,9.1-26.11,44.79-35.2,35.2-9.59-9.1,26.11-44.79,35.2-35.2Z" data-v-6bf0f020></path><path class="top-wing right" d="m101.42,48.04c9.1-9.59,44.79,26.11,35.2,35.2-9.1,9.59-44.79-26.11-35.2-35.2Z" data-v-6bf0f020></path>', 8),
        NEe = [IEe];

    function xEe(t, e, n, r, s, i) {
        const a = st("PlayerHeader");
        return G(), H("div", {
            class: Xe(["playback", {
                on: t.isOn
            }])
        }, [B("div", kEe, [(G(), H("svg", {
            class: "fly",
            viewBox: "0 0 200 200",
            onClick: e[0] || (e[0] = (...c) => t.onClick && t.onClick(...c))
        }, NEe))]), Je(a, {
            info: t.info
        }, null, 8, ["info"])], 2)
    }
    const PEe = ot(CEe, [
        ["render", xEe],
        ["__scopeId", "data-v-6bf0f020"]
    ]);
    class REe {
        constructor() {
            Se(this, "idCounter", 1);
            Se(this, "idMap", new Map);
            Se(this, "fnMap", new Map);
            Se(this, "times", [])
        }
        schedule(e, n) {
            const r = this.idCounter,
                s = this.idMap.get(n);
            return s ? s.push(this.idCounter) : (this.idMap.set(n, [r]), this.times.push(n), this.times.sort((i, a) => i - a)), this.fnMap.set(r, e), this.idCounter += 1, r
        }
        cancel(e) {
            this.fnMap.delete(e)
        }
        call(e) {
            const n = this.fnMap.get(e);
            this.fnMap.delete(e), n && n()
        }
        check(e) {
            let n = 0;
            for (let r = 0; r < this.times.length && !(this.times[r] > e); r++) {
                n += 1;
                const s = this.idMap.get(this.times[r]);
                s && s.forEach(i => this.call(i))
            }
            this.times.splice(0, n)
        }
    }
    class I6 {
        constructor(e) {
            Se(this, "callbackMap", new Map);
            Se(this, "isAudience");
            Se(this, "instraface");
            Se(this, "scheduler", new REe);
            Se(this, "difficulty");
            Se(this, "duration");
            Se(this, "guide");
            Se(this, "isLoaded", Jr(!1));
            Se(this, "hasStarted", !1);
            Se(this, "isRunning", !1);
            Se(this, "isComplete", !1);
            Se(this, "baseTime");
            Se(this, "lastTick", 0);
            Se(this, "playhead", 0);
            Se(this, "playheadPercent", 0);
            Se(this, "accuracy", 0);
            Se(this, "currentCombo", 0);
            Se(this, "longestCombo", 0);
            Se(this, "pastNotes", 0);
            Se(this, "noteQualityScoreFactors");
            Se(this, "scorePerHighestCombo");
            Se(this, "scorePoolPerDifficulty");
            Se(this, "successPercentage");
            Se(this, "pendingInputs", []);
            Se(this, "reportInterval");
            Se(this, "responseKey");
            Se(this, "wsClient");
            this.isAudience = e.isAudience, this.difficulty = e.beatmap.difficulty, this.duration = e.duration, this.guide = e.guide, this.noteQualityScoreFactors = e.noteQualityScoreFactors, this.playhead = e.offset ?? 0, this.scorePerHighestCombo = e.scorePerHighestCombo, this.scorePoolPerDifficulty = e.scorePoolPerDifficulty, this.successPercentage = e.successPercentage;
            const n = `https://cdn.jackboxgames.com/nopus-opus/instruments/${e.instrument.slug}`;
            this.instraface = new ob({
                baseUrl: n,
                config: e.instrument
            }), this.instraface.outNode.volume.value = 8, e.wsClient && (this.wsClient = e.wsClient, this.responseKey = e.responseKey, this.isAudience || (this.reportInterval = window.setInterval(() => {
                this.onReportInterval()
            }, 2e3))), this.awaitForLoaded()
        }
        get now() {
            return this.baseTime ? Math.round(window.performance.now() - this.baseTime) : 0
        }
        get scorePool() {
            return this.scorePoolPerDifficulty[this.difficulty - 1]
        }
        millisecondsToY(e) {
            return e / this.duration
        }
        durationToHeight(e) {
            return e / this.duration
        }
        start(e) {
            this.baseTime = Math.round(window.performance.now()), e !== void 0 && (this.playhead = e, this.baseTime -= e), this.hasStarted = !0, this.isRunning = !0, window.requestAnimationFrame(this.onRequestAnimationFrame.bind(this))
        }
        stop() {
            this.isRunning = !1
        }
        destroy() {
            var e;
            this.stop(), this.callbackMap.clear(), (e = this.instraface) == null || e.update({
                config: null
            }), delete this.instraface, this.reportInterval && (window.clearInterval(this.reportInterval), delete this.reportInterval)
        }
        async awaitForLoaded() {
            await Y0(), this.isLoaded.value = !0
        }
        on(e, n) {
            const r = this.callbackMap.get(e) ?? new Set;
            r.size || this.callbackMap.set(e, r), r.add(n)
        }
        off(e, n) {
            const r = this.callbackMap.get(e);
            r && r.delete(n)
        }
        emit(e) {
            var n;
            (n = this.callbackMap.get(e.type)) == null || n.forEach(r => r(e))
        }
        onTick() {
            const e = this.now;
            this.emit({
                type: "tick",
                now: e,
                debug: e
            }), this.updatePlayhead(e), this.scheduler.check(e), e >= this.duration && (this.isComplete = !0, this.stop(), this.isAudience && this.reportAudience())
        }
        onRequestAnimationFrame() {
            this.isRunning && (this.onTick(), window.requestAnimationFrame(this.onRequestAnimationFrame.bind(this)))
        }
        updatePlayhead(e) {
            if (e >= this.duration) {
                this.isRunning = !1, this.playhead = this.duration, this.playheadPercent = 1;
                return
            }
            this.lastTick = this.playhead, this.playhead = this.now, this.playheadPercent = this.millisecondsToY(this.playhead)
        }
        schedule(e, n) {
            return this.scheduler.schedule(e, n + this.now)
        }
        scoreNote(e) {
            if (this.pastNotes += 1, e === null) {
                this.currentCombo = 0;
                return
            }
            this.accuracy += this.noteQualityScoreFactors[e], this.currentCombo += 1, this.currentCombo > this.longestCombo && (this.longestCombo = this.currentCombo)
        }
        reportInput(e) {
            this.isAudience || this.reportInterval && this.pendingInputs.push(e)
        }
        async onReportInterval() {
            if (this.isAudience || !this.pendingInputs.length) return;
            const e = this.pendingInputs;
            this.pendingInputs = [];
            try {
                await this.wsClient.updateObject(this.responseKey, {
                    input: e
                })
            } catch (n) {
                console.error(n)
            }
        }
        async reportAudience() {
            if (!this.isAudience) return;
            const e = Math.round(this.accuracy / this.pastNotes * 100);
            if (e !== 0) try {
                await this.wsClient.incrementCountGroupCounter(this.responseKey, `${e}`)
            } catch (n) {
                console.error(n)
            }
        }
    }
    class MEe extends I6 {
        constructor(n) {
            super(n);
            Se(this, "criteria");
            Se(this, "inputMap");
            Se(this, "limitsMap");
            Se(this, "isActive", !1);
            Se(this, "isFlubbing", !1);
            Se(this, "signal", 0);
            Se(this, "inputId");
            Se(this, "downAt");
            Se(this, "tracking");
            Se(this, "currentInput");
            Se(this, "currentLimits");
            Se(this, "feedback", []);
            this.criteria = n.criteria, this.inputMap = this.parseInputs(n.beatmap), this.limitsMap = this.parseLimits(n.beatmap), this.currentLimits = this.limitsMap.get(0)
        }
        roundSignal(n) {
            return Math.round(n * 1e3) / 1e3
        }
        parseInputs(n) {
            const r = new Map;
            return n.inputs.forEach(i => {
                const a = {
                    start: i.start,
                    duration: i.duration,
                    signal: i.signal,
                    isTaken: !1,
                    isMissed: !1,
                    isVisible: !1,
                    isAudible: !1,
                    isHolding: !1,
                    y: this.millisecondsToY(i.start),
                    height: this.durationToHeight(i.duration)
                };
                r.set(i.start, a)
            }), r
        }
        parseLimits(n) {
            const r = new Map;
            return n.limits && n.limits.forEach(s => {
                r.set(s[0], [s[1], s[2]])
            }), r
        }
        onDown(n, r) {
            if (this.instraface) {
                if (this.inputId === r) {
                    this.onMove(n, r);
                    return
                }
                this.inputId === void 0 && (n = this.roundSignal(n), this.instraface.continuous.attack(n, this.currentLimits[0], this.currentLimits[1]), this.tracking = [{
                    start: 0,
                    signal: n
                }], this.currentInput && (this.currentInput.isHolding = !0), this.isActive = !0, this.signal = n, this.inputId = r, this.downAt = this.now)
            }
        }
        onMove(n, r) {
            if (!this.instraface || this.inputId !== r || !this.tracking) return;
            n = this.roundSignal(n), this.instraface.continuous.update(n, this.currentLimits[0], this.currentLimits[1]), this.currentInput && (this.currentInput.isHolding = !0);
            const s = this.now - this.downAt;
            this.tracking[this.tracking.length - 1].start + 150 > s || (this.tracking.push({
                start: s,
                signal: n
            }), this.signal = n)
        }
        onUp(n) {
            this.instraface && this.inputId === n && this.tracking && (this.instraface.continuous.release(), this.currentInput && (this.currentInput.isHolding = !1, this.currentInput.isTaken = !0), this.tracking && this.downAt && this.reportInput({
                start: this.downAt,
                duration: this.now - this.downAt,
                signal: this.tracking
            }), this.isActive = !1, delete this.tracking, delete this.inputId, delete this.downAt)
        }
        onTick() {
            super.onTick(), this.currentInput && this.currentInput.start + this.currentInput.duration < this.playhead && (this.currentInput.isHolding || this.currentInput.isTaken ? this.currentInput.isTaken = !0 : this.currentInput.isMissed = !0, this.currentInput.isHolding = !1, delete this.currentInput);
            for (let n = this.lastTick; n < this.playhead; n++) {
                const r = this.inputMap.get(n),
                    s = this.limitsMap.get(n);
                r && (this.currentInput = r), s && (this.currentLimits = s)
            }
        }
    }
    const DEe = mt({
            props: {
                manager: {
                    type: Object,
                    required: !0
                }
            },
            methods: {
                normalizeSignal(t) {
                    return t < .25 ? 0 : t > .75 ? 1 : (t - .25) * 2
                },
                onPointerBoxStart(t) {
                    this.manager.onDown(this.normalizeSignal(t.detail.percentX), t.detail.id)
                },
                onPointerBoxMove(t) {
                    this.manager.onMove(this.normalizeSignal(t.detail.percentX), t.detail.id)
                },
                onPointerBoxEnd(t) {
                    this.manager.onUp(t.detail.id)
                },
                onReleaserUp(t) {
                    this.manager.onUp(t.pointerId)
                },
                onContextMenu() {
                    this.manager.onUp()
                }
            }
        }),
        $Ee = {
            class: "constrainer controls"
        };

    function LEe(t, e, n, r, s, i) {
        const a = On("pointerbox");
        return G(), H(Tt, null, [B("div", {
            class: "releaser",
            onPointerup: e[0] || (e[0] = (...c) => t.onReleaserUp && t.onReleaserUp(...c))
        }, null, 32), B("div", $Ee, [Ke(B("div", {
            class: "hitbox",
            onContextmenu: e[1] || (e[1] = (...c) => t.onContextMenu && t.onContextMenu(...c)),
            "onPointerbox:start": e[2] || (e[2] = (...c) => t.onPointerBoxStart && t.onPointerBoxStart(...c)),
            "onPointerbox:move": e[3] || (e[3] = (...c) => t.onPointerBoxMove && t.onPointerBoxMove(...c)),
            "onPointerbox:end": e[4] || (e[4] = (...c) => t.onPointerBoxEnd && t.onPointerBoxEnd(...c))
        }, null, 544), [
            [a, void 0, void 0, {
                restrict: !0
            }]
        ])])], 64)
    }
    const FEe = ot(DEe, [
            ["render", LEe],
            ["__scopeId", "data-v-e3892bdc"]
        ]),
        UEe = mt({
            props: {
                duration: {
                    type: Number,
                    required: !0
                },
                guide: {
                    type: Array,
                    required: !0
                }
            },
            computed: {
                beatLines() {
                    const t = this.guide.flat(),
                        e = [];
                    for (let n = 0; n < t.length; n += 2) {
                        const r = t[n],
                            s = t[n + 1] ?? this.duration,
                            i = s - r;
                        e.push({
                            debug: [r, s],
                            styles: {
                                bottom: `${r/this.duration*100}%`,
                                height: `${i/this.duration*100}%`
                            }
                        })
                    }
                    return e
                }
            }
        }),
        BEe = {
            class: "beat-lines"
        },
        qEe = {
            class: "debug"
        },
        jEe = {
            class: "debug"
        };

    function VEe(t, e, n, r, s, i) {
        return G(), H("div", BEe, [(G(!0), H(Tt, null, $n(t.beatLines, (a, c) => (G(), H("div", {
            key: c,
            class: "beat-line",
            style: Tn(a.styles)
        }, [B("p", qEe, vt(Math.round(a.debug[0])), 1), B("p", jEe, vt(Math.round(a.debug[1])), 1)], 4))), 128))])
    }
    const N6 = ot(UEe, [
            ["render", VEe],
            ["__scopeId", "data-v-ea04da8a"]
        ]),
        GEe = mt({
            components: {
                Beatlines: N6
            },
            props: {
                manager: {
                    type: Object,
                    required: !0
                },
                isDesktop: {
                    type: Boolean,
                    required: !0
                }
            },
            computed: {
                scrollStyles() {
                    return {
                        transform: `translateY(${this.manager.playheadPercent*100}%)`
                    }
                },
                showCTA() {
                    return !this.manager.hasStarted
                },
                hitIndicator() {
                    const t = [];
                    return this.manager.isActive && t.push("active"), this.manager.isFlubbing && t.push("flubbing"), {
                        debug: "",
                        classes: t,
                        styles: {
                            left: `${(this.manager.signal??0)*100}%`
                        }
                    }
                },
                inputs() {
                    const t = [];
                    return this.manager.inputMap.forEach(e => {
                        let n = "";
                        e.signal.forEach((s, i) => {
                            const a = 1 - s.start / e.duration;
                            n += `${i?"L":"M"} ${s.signal} ${a} `
                        });
                        const r = {
                            debug: Math.round(e.start),
                            path: n,
                            classes: [],
                            styles: {
                                height: `${e.height*100}%`,
                                bottom: `${e.y*100}%`
                            },
                            line: {
                                classes: [],
                                styles: {}
                            },
                            indicator: {
                                classes: [],
                                styles: {
                                    left: `${e.signal[0].signal*100}%`
                                }
                            }
                        };
                        e.isTaken && r.classes.push("taken"), e.isMissed && r.classes.push("missed"), e.isHolding && r.classes.push("holding"), t.push(r)
                    }), t
                }
            }
        }),
        WEe = t => (Ns("data-v-c322639f"), t = t(), xs(), t),
        HEe = {
            class: "visuals"
        },
        KEe = {
            class: "scroll-wrapper"
        },
        YEe = WEe(() => B("div", {
            class: "touch-line"
        }, null, -1)),
        zEe = {
            class: "scroll-wrapper"
        },
        ZEe = {
            class: "constrainer"
        },
        XEe = ["d"],
        JEe = ["d"],
        QEe = {
            class: "constrainer foreground"
        },
        eTe = {
            class: "cta"
        };

    function tTe(t, e, n, r, s, i) {
        const a = st("Beatlines"),
            c = On("t");
        return G(), H("div", HEe, [B("div", KEe, [Je(a, {
            guide: t.manager.guide,
            duration: t.manager.duration,
            class: "scroll-container",
            style: Tn(t.scrollStyles)
        }, null, 8, ["guide", "duration", "style"])]), YEe, B("div", zEe, [B("div", {
            class: "inputs scroll-container",
            style: Tn(t.scrollStyles)
        }, [B("div", ZEe, [(G(!0), H(Tt, null, $n(t.inputs, (u, h) => (G(), H("div", {
            key: h,
            class: Xe(["input", u.classes]),
            style: Tn(u.styles)
        }, [(G(), H("svg", {
            viewBox: "0 0 1 1",
            preserveAspectRatio: "none",
            class: Xe(u.line.classes),
            style: Tn(u.line.styles)
        }, [B("path", {
            class: "background",
            d: u.path
        }, null, 8, XEe), B("path", {
            class: "foreground",
            d: u.path
        }, null, 8, JEe)], 6)), B("div", {
            class: Xe(["start-indicator", u.indicator.classes]),
            style: Tn(u.indicator.styles)
        }, null, 6)], 6))), 128))])], 4)]), B("div", QEe, [B("div", {
            class: Xe(["hit-house", {
                alert: t.showCTA
            }])
        }, null, 2), B("div", {
            class: Xe(["hit-indicator okay", t.hitIndicator.classes]),
            style: Tn(t.hitIndicator.styles)
        }, null, 6), B("div", {
            class: Xe(["hit-indicator good", t.hitIndicator.classes]),
            style: Tn(t.hitIndicator.styles)
        }, null, 6), B("div", {
            class: Xe(["hit-indicator perfect", t.hitIndicator.classes]),
            style: Tn(t.hitIndicator.styles)
        }, null, 6), B("div", {
            class: Xe(["cta-container", {
                show: t.showCTA
            }])
        }, [Ke(B("p", eTe, null, 512), [
            [c, "INFO.CONTINUOUS"]
        ])], 2)])])
    }
    const nTe = ot(GEe, [
        ["render", tTe],
        ["__scopeId", "data-v-c322639f"]
    ]);
    class rTe extends I6 {
        constructor(n) {
            super(n);
            Se(this, "criteria");
            Se(this, "missCriteria");
            Se(this, "inputMap");
            Se(this, "lanes");
            Se(this, "delayedInputs", []);
            Se(this, "inputTimes");
            this.criteria = n.criteria, this.missCriteria = this.criteria[this.criteria.length - 1], this.inputMap = this.parseInputs(n.beatmap), this.lanes = new Array(n.beatmap.laneCount).fill(0).map((r, s) => ({
                index: s,
                isActive: !1,
                isAudible: !1,
                isFlubbing: !1,
                isHolding: !1,
                feedback: []
            })), this.inputTimes = Array.from(this.inputMap.keys()).sort((r, s) => r - s)
        }
        laneWithPointerId(n) {
            return this.lanes.find(r => r.pointerId === n) ?? null
        }
        getDurationOfNotes(n) {
            return Math.max(...n.map(r => r.start + r.duration))
        }
        parseNoteMaps(n) {
            const r = new Map,
                s = new Map;
            return n.forEach(i => {
                const a = i.start,
                    c = r.get(a) ?? [];
                c.length || r.set(a, c), c.push(i.note);
                const u = i.start + i.duration,
                    h = s.get(u) ?? [];
                h.length || s.set(u, h), h.push(i.note)
            }), [r, s]
        }
        parseInputs(n) {
            const r = new Map;
            return n.inputs.forEach(i => {
                const a = i.start,
                    c = r.get(a) ?? [];
                c.length || r.set(a, c);
                const u = this.getDurationOfNotes(i.notes),
                    [h, d] = this.parseNoteMaps(i.notes),
                    p = {
                        start: a,
                        lanes: i.lanes,
                        notes: i.notes,
                        attackMap: h,
                        releaseMap: d,
                        attackIds: [],
                        releaseIds: [],
                        isAudible: !1,
                        isHolding: !1,
                        isMissed: !1,
                        isMultilane: i.lanes.length > 1,
                        isTaken: !1,
                        isTap: !i.duration,
                        isVisible: !1,
                        audioDuration: u,
                        audioHeight: this.durationToHeight(u),
                        range: [i.start - this.missCriteria, i.start + this.missCriteria],
                        indicators: i.lanes.map(m => ({
                            isDown: !1,
                            lane: m,
                            y: this.millisecondsToY(a)
                        }))
                    };
                i.duration && (p.duration = i.duration, p.height = this.durationToHeight(p.duration)), c.push(p)
            }), r
        }
        onDown(n, r) {
            const s = this.lanes[n];
            s.isActive || this.laneWithPointerId(r) || (s.isActive = !0, s.pointerId = r, s.downAt = this.now, this.checkDownOnLane(s))
        }
        onUp(n) {
            const r = this.laneWithPointerId(n);
            r && (r.downAt && this.reportInput({
                start: r.downAt,
                duration: this.now - r.downAt,
                lane: r.index
            }), this.checkUpOnLane(r), r.isActive = !1, delete r.pointerId, delete r.downAt)
        }
        getNextInputOnLane(n) {
            const r = this.now,
                s = [r - this.criteria[this.criteria.length - 1], r + this.criteria[this.criteria.length - 1]];
            for (let i = 0; i < this.inputTimes.length && !(this.inputTimes[i] > s[1]); i++) {
                if (this.inputTimes[i] < s[0]) continue;
                const a = this.inputMap.get(this.inputTimes[i]);
                if (a != null && a.length) {
                    for (let c = 0; c < a.length; c++)
                        if (!a[c].isTaken && a[c].lanes.includes(n.index)) return a[c]
                }
            }
            return null
        }
        checkDownOnLane(n) {
            const r = this.getNextInputOnLane(n);
            if (!r) {
                n.isAudible = !1, n.isHolding = !1, this.flubOnLane(n);
                return
            }
            if (!r.lanes.every(c => this.lanes[c].isActive)) return;
            const i = Math.abs(this.now - r.start),
                a = this.criteria.findIndex(c => i < c);
            r.isTap ? (r.isTaken = !0, a !== void 0 && this.scoreNote(a), r.lanes.forEach(c => {
                this.lanes[c].isHolding = !0, this.lanes[c].holdingInput = r, this.lanes[c].feedback.push(a)
            })) : a !== void 0 && (r.pendingFeedback = a), r.isHolding = !0, r.lanes.forEach(c => {
                this.lanes[c].isHolding = !0, this.lanes[c].holdingInput = r
            }), this.attackWithInput(r)
        }
        checkUpOnLane(n) {
            const r = n.holdingInput;
            r && (!r.isTap && r.pendingFeedback !== void 0 && this.scoreNote(r.pendingFeedback), r.isHolding = !1, r.isTaken = !0, r.lanes.forEach(s => {
                const i = this.lanes[s];
                i.isHolding = !1, !r.isTap && r.pendingFeedback !== void 0 && this.lanes[s].feedback.push(r.pendingFeedback), delete i.holdingInput
            }), this.releaseWithInput(r))
        }
        async onReportInterval() {
            this.lanes.some(r => {
                const s = r.holdingInput;
                return s && !s.isTap
            }) || await super.onReportInterval()
        }
        flubOnLane(n) {
            this.instraface && (n.flubEndId && this.scheduler.cancel(n.flubEndId), this.instraface.flub.attack(), n.isFlubbing = !0, n.flubEndId = this.schedule(() => {
                n.isFlubbing = !1, delete n.flubEndId
            }, 250))
        }
        attackWithInput(n) {
            this.instraface && (n.isAudible = !0, n.audibleEndId = this.schedule(() => {
                n.isAudible = !1
            }, n.audioDuration), n.lanes.forEach(r => {
                const s = this.lanes[r];
                s.isAudible = !0, s.audibleEndId = this.schedule(() => {
                    s.isAudible = !1, delete s.audibleEndId
                }, n.audioDuration)
            }), n.attackMap.forEach((r, s) => {
                if (s) {
                    n.attackIds.push(this.schedule(() => {
                        this.instraface.discrete.attack(r, r)
                    }, s));
                    return
                }
                this.instraface.discrete.attack(r, r)
            }), n.releaseMap.forEach((r, s) => {
                n.releaseIds.push(this.schedule(() => {
                    this.instraface.discrete.release(r)
                }, s))
            }))
        }
        releaseWithInput(n) {
            n.audibleEndId && this.scheduler.call(n.audibleEndId), n.lanes.forEach(r => {
                const s = this.lanes[r];
                s.audibleEndId && this.scheduler.call(s.audibleEndId)
            }), n.attackIds.forEach(r => this.scheduler.cancel(r)), n.releaseIds.forEach(r => this.scheduler.call(r))
        }
        onTick() {
            var n;
            super.onTick();
            for (let r = this.lastTick; r < this.playhead; r++) {
                const s = r - this.missCriteria;
                (n = this.inputMap.get(s)) == null || n.forEach(i => {
                    i.isTaken || i.isHolding || i.isMissed || (i.isMissed = !0, this.scoreNote(null))
                })
            }
        }
    }
    const sTe = mt({
            components: {
                Beatlines: N6
            },
            props: {
                manager: {
                    type: Object,
                    required: !0
                },
                isDesktop: {
                    type: Boolean,
                    required: !0
                }
            },
            computed: {
                layout() {
                    return ab(this.manager.lanes.length)
                },
                showCTA() {
                    return !this.manager.hasStarted
                },
                scrollStyles() {
                    return {
                        transform: `translateY(${this.manager.playheadPercent*100}%)`
                    }
                },
                laneLines() {
                    return this.layout.lanes.map(t => ({
                        classes: [],
                        styles: {
                            left: `${t.center*100}%`
                        }
                    }))
                },
                hitIndicators() {
                    return this.manager.lanes.map((t, e) => {
                        const n = [];
                        return this.manager.lanes[e].isActive && n.push("active"), this.manager.lanes[e].isFlubbing && n.push("flubbing"), this.showCTA && n.push("alert"), {
                            classes: n,
                            text: this.layout.hotKeys[e],
                            styles: {
                                width: `${this.layout.hit*100}%`,
                                left: `${this.layout.lanes[e].center*100}%`
                            },
                            items: t.feedback.map(r => r === 0 ? {
                                text: "PERFECT",
                                classes: ["perfect"]
                            } : r === 1 ? {
                                text: "GOOD",
                                classes: ["good"]
                            } : {
                                text: "OKAY",
                                classes: ["okay"]
                            })
                        }
                    })
                },
                inputs() {
                    const t = [];
                    return this.manager.inputMap.forEach(e => {
                        e.forEach(n => {
                            n.indicators.forEach(r => {
                                const s = this.layout.lanes[r.lane];
                                if (s === void 0) {
                                    console.warn("unrenderable lane", r.lane);
                                    return
                                }
                                const i = {
                                    isTap: n.isTap,
                                    debug: n.start,
                                    classes: [],
                                    styles: {
                                        left: `${s.center*100}%`,
                                        width: `${this.layout.hit*100}%`,
                                        bottom: `${r.y*100}%`
                                    }
                                };
                                !n.isTap && n.height && (i.styles.height = `${n.height*100}%`), n.isTaken && i.classes.push("taken"), n.isMissed && i.classes.push("missed"), n.isVisible && i.classes.push("visible"), n.isMultilane && i.classes.push("multi"), n.isHolding && i.classes.push("holding"), n.isTap ? i.classes.push("tap") : i.classes.push("hold"), t.push(i)
                            })
                        })
                    }), t
                },
                scoring() {
                    const t = this.manager.longestCombo * this.manager.scorePerHighestCombo,
                        e = Math.round(this.manager.accuracy / this.manager.pastNotes * 100),
                        n = Math.round(this.manager.scorePool * (this.manager.accuracy / this.manager.pastNotes));
                    return {
                        accuracy: this.manager.accuracy,
                        accuracyPercentage: `${e}%`,
                        accuracyScore: n,
                        scorePool: this.manager.scorePool,
                        currentCombo: this.manager.currentCombo,
                        longestCombo: this.manager.longestCombo,
                        comboBonus: t,
                        totalInputs: this.manager.inputMap.size,
                        score: n + t
                    }
                }
            }
        }),
        iTe = {
            class: "visuals"
        },
        oTe = {
            class: "scroll-wrapper"
        },
        aTe = {
            class: "constrainer"
        },
        cTe = {
            class: "lane-lines"
        },
        lTe = {
            class: "hit-indicators behind"
        },
        uTe = {
            class: "scroll-wrapper"
        },
        hTe = {
            class: "constrainer"
        },
        fTe = {
            key: 0,
            class: "hold-indicator"
        },
        dTe = {
            class: "tap-indicator"
        },
        pTe = {
            class: "debug"
        },
        mTe = {
            class: "constrainer foreground"
        },
        gTe = {
            key: 0,
            class: "hotkey"
        },
        _Te = {
            class: "cta"
        },
        yTe = {
            class: "debug scoring"
        };

    function vTe(t, e, n, r, s, i) {
        const a = st("Beatlines"),
            c = On("t");
        return G(), H("div", iTe, [B("div", oTe, [Je(a, {
            guide: t.manager.guide,
            duration: t.manager.duration,
            class: "scroll-container",
            style: Tn(t.scrollStyles)
        }, null, 8, ["guide", "duration", "style"])]), B("div", aTe, [B("div", cTe, [(G(!0), H(Tt, null, $n(t.laneLines, (u, h) => (G(), H("div", {
            key: h,
            class: Xe(["lane-line", u.classes]),
            style: Tn(u.styles)
        }, null, 6))), 128))]), B("div", lTe, [(G(!0), H(Tt, null, $n(t.hitIndicators, (u, h) => (G(), H("div", {
            key: h,
            class: Xe(["hit-indicator", u.classes]),
            style: Tn(u.styles)
        }, null, 6))), 128))])]), B("div", uTe, [B("div", {
            class: "inputs scroll-container",
            style: Tn(t.scrollStyles)
        }, [B("div", hTe, [(G(!0), H(Tt, null, $n(t.inputs, (u, h) => (G(), H("div", {
            key: h,
            class: Xe(["input", u.classes]),
            style: Tn(u.styles)
        }, [u.isTap ? Be("", !0) : (G(), H("div", fTe)), B("div", dTe, [B("p", pTe, vt(u.debug), 1)])], 6))), 128))])], 4)]), B("div", mTe, [(G(!0), H(Tt, null, $n(t.hitIndicators, (u, h) => (G(), H("div", {
            key: h,
            class: Xe(["hit-indicator", u.classes]),
            style: Tn(u.styles)
        }, [(G(!0), H(Tt, null, $n(u.items, (d, p) => (G(), H("span", {
            key: p,
            class: Xe(["feedback-item", d.classes])
        }, vt(d.text), 3))), 128)), t.isDesktop ? (G(), H("span", gTe, vt(u.text), 1)) : Be("", !0)], 6))), 128)), B("div", {
            class: Xe(["cta-container", {
                show: t.showCTA
            }])
        }, [Ke(B("p", _Te, null, 512), [
            [c, "INFO.DISCRETE"]
        ])], 2)]), B("div", yTe, [(G(!0), H(Tt, null, $n(t.scoring, (u, h) => (G(), H("p", {
            key: h
        }, vt(h) + ": " + vt(u), 1))), 128))])])
    }
    const bTe = ot(sTe, [
            ["render", vTe],
            ["__scopeId", "data-v-e779d49d"]
        ]),
        ETe = mt({
            props: {
                manager: {
                    type: Object,
                    required: !0
                }
            },
            computed: {
                layout() {
                    return ab(this.manager.lanes.length)
                }
            },
            mounted() {
                window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp)
            },
            beforeUnmount() {
                window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp)
            },
            methods: {
                onPointerBoxStart(t) {
                    const e = t.detail.percentX;
                    if (e < 0 || e > 1) return;
                    const n = this.layout.lanes.findIndex(r => e >= r.left && e <= r.right);
                    n !== -1 && this.manager.onDown(n, t.detail.id)
                },
                onPointerBoxEnd(t) {
                    this.manager.onUp(t.detail.id)
                },
                onKeyDown(t) {
                    let e = t.key.toLowerCase();
                    e === " " && (e = "space");
                    const n = this.layout.hotKeys.indexOf(t.key.toLowerCase());
                    n !== -1 && this.manager.onDown(n, e)
                },
                onKeyUp(t) {
                    const e = t.key.toLowerCase();
                    this.manager.onUp(e)
                }
            }
        });

    function TTe(t, e, n, r, s, i) {
        const a = On("pointerbox");
        return Ke((G(), H("div", {
            class: "constrainer controls",
            "onPointerbox:start": e[0] || (e[0] = (...c) => t.onPointerBoxStart && t.onPointerBoxStart(...c)),
            "onPointerbox:end": e[1] || (e[1] = (...c) => t.onPointerBoxEnd && t.onPointerBoxEnd(...c))
        }, null, 544)), [
            [a, void 0, void 0, {
                multi: !0,
                restrict: !0
            }]
        ])
    }
    const STe = ot(ETe, [
            ["render", TTe]
        ]),
        wTe = mt({
            components: {
                ContinuousControls: FEe,
                ContinuousVisuals: nTe,
                DiscreteVisuals: bTe,
                DiscreteControls: STe
            },
            props: {
                beatmap: {
                    type: Object,
                    required: !0
                },
                countInOffset: {
                    type: Number,
                    required: !0
                },
                instrument: {
                    type: Object,
                    required: !0
                },
                isAudience: {
                    type: Boolean,
                    required: !0
                },
                isDesktop: {
                    type: Boolean,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                },
                shouldRun: {
                    type: Boolean,
                    required: !0
                }
            },
            data({
                beatmap: t,
                instrument: e,
                player: n
            }) {
                let r;
                const s = {
                    isAudience: this.isAudience,
                    beatmap: t.config,
                    duration: n.recordingInfo.duration,
                    guide: n.guide.guide,
                    instrument: e.config,
                    noteQualityScoreFactors: n.recordingInfo.noteQualityScoreFactors,
                    offset: n.recordingInfo.position,
                    responseKey: n.responseEntity,
                    scorePerHighestCombo: n.recordingInfo.scorePerHighestCombo,
                    scorePoolPerDifficulty: n.recordingInfo.scorePoolPerDifficulty,
                    successPercentage: n.recordingInfo.successPercentage,
                    wsClient: this.$ecast
                };
                return t.config.type === "Continuous" ? (s.criteria = {
                    factors: n.recordingInfo.continuousCriteriaFactors,
                    percentage: n.recordingInfo.continuousPercentageCriteria,
                    signal: n.recordingInfo.continuousSignalCriteria
                }, r = new MEe(s)) : (s.criteria = n.recordingInfo.discreteCriteria, r = new rTe(s)), {
                    manager: r
                }
            },
            computed: {
                classes() {
                    return this.beatmap.config.type === "Continuous" ? ["continuous"] : ["discrete"]
                }
            },
            watch: {
                shouldRun: {
                    immediate: !0,
                    handler: "onShouldRunChange"
                }
            },
            beforeUnmount() {
                var t;
                (t = this.manager) == null || t.destroy(), this.manager = null
            },
            methods: {
                onShouldRunChange(t, e) {
                    var n;
                    if (t && !e) {
                        let r = this.countInOffset;
                        r += this.player.recordingInfo.position === 0 ? this.player.recordingInfo.timeAfterCountInBeforeSong : this.player.recordingInfo.timeAfterCountInDuringSong, window.setTimeout(() => {
                            var s;
                            (s = this.manager) == null || s.start(this.player.recordingInfo.position)
                        }, r)
                    }!t && e && ((n = this.manager) == null || n.stop())
                }
            }
        }),
        OTe = {
            key: 2,
            class: "debug loading"
        };

    function ATe(t, e, n, r, s, i) {
        const a = st("ContinuousVisuals"),
            c = st("ContinuousControls"),
            u = st("DiscreteVisuals"),
            h = st("DiscreteControls");
        return t.manager ? (G(), H("div", {
            key: 0,
            class: Xe(t.classes)
        }, [t.beatmap.config.type === "Continuous" ? (G(), H(Tt, {
            key: 0
        }, [Je(a, {
            manager: t.manager,
            "is-desktop": t.isDesktop
        }, null, 8, ["manager", "is-desktop"]), t.manager.isLoaded ? (G(), Ut(c, {
            key: 0,
            manager: t.manager
        }, null, 8, ["manager"])) : Be("", !0)], 64)) : (G(), H(Tt, {
            key: 1
        }, [Je(u, {
            manager: t.manager,
            "is-desktop": t.isDesktop
        }, null, 8, ["manager", "is-desktop"]), t.manager.isLoaded ? (G(), Ut(h, {
            key: 0,
            manager: t.manager
        }, null, 8, ["manager"])) : Be("", !0)], 64)), t.manager.isLoaded ? Be("", !0) : (G(), H("p", OTe, "LOADING"))], 2)) : Be("", !0)
    }
    const CTe = ot(wTe, [
            ["render", ATe],
            ["__scopeId", "data-v-2ce53692"]
        ]),
        kTe = "main/pp10/nopus-opus/assets/50849cf6.mp3",
        ITe = "main/pp10/nopus-opus/assets/9431923a.ogg",
        NTe = "main/pp10/nopus-opus/assets/2188b01d.mp3",
        xTe = "main/pp10/nopus-opus/assets/9f40765c.ogg",
        PTe = "main/pp10/nopus-opus/assets/20141192.mp3",
        RTe = "main/pp10/nopus-opus/assets/8e80ea3f.ogg",
        MTe = mt({
            props: {
                state: {
                    type: String,
                    required: !0
                }
            },
            emits: {
                didCountIn: (t, e) => !0
            },
            setup() {
                const t = Ot.supportsType("ogg") ? "ogg" : "mp3";
                return {
                    players: new Yd({
                        one: new URL(Object.assign({
                            "../../assets/tap1.mp3": kTe,
                            "../../assets/tap1.ogg": ITe
                        })[`../../assets/tap1.${t}`], self.location).href,
                        two: new URL(Object.assign({
                            "../../assets/tap2.mp3": NTe,
                            "../../assets/tap2.ogg": xTe
                        })[`../../assets/tap2.${t}`], self.location).href,
                        three: new URL(Object.assign({
                            "../../assets/tap3.mp3": PTe,
                            "../../assets/tap3.ogg": RTe
                        })[`../../assets/tap3.${t}`], self.location).href
                    }).toDestination()
                }
            },
            data() {
                return {
                    taps: 3,
                    count: 0,
                    timeoutDuration: 2500,
                    timeout: null,
                    desktopDetected: !1
                }
            },
            computed: {
                titleKey() {
                    return this.state === "Inactive" ? "COUNT_IN.WHEN" : this.count === 0 ? "COUNT_IN.GET_READY" : "COUNT_IN.SYNCING"
                },
                buttonKey() {
                    return this.state === "Inactive" ? "COUNT_IN.TAP_HERE" : this.count === this.taps ? "COUNT_IN.SYNCED" : "COUNT_IN.TAP"
                },
                classes() {
                    const t = [];
                    return this.state === "Inactive" ? t.push("inactive") : (t.push("tap-0"), this.count >= 1 && t.push("tap-1"), this.count >= 2 && t.push("tap-2"), this.count >= 3 && t.push("tap-3", "synced")), t
                }
            },
            mounted() {
                window.addEventListener("keydown", this.onKeyDown)
            },
            beforeUnmount() {
                window.removeEventListener("keydown", this.onKeyDown)
            },
            methods: {
                onKeyDown(t) {
                    t.key === " " && this.state !== "Inactive" && (this.desktopDetected = !0, this.onCount())
                },
                onPointerDown(t) {
                    this.state !== "Inactive" && (t.pointerType === "mouse" && (this.desktopDetected = !0), this.onCount())
                },
                onTimeout() {
                    this.count = this.taps, this.$emit("didCountIn", this.timeoutDuration, this.desktopDetected)
                },
                async onCount() {
                    this.count += 1, this.$vibrate(), this.timeout && (window.clearTimeout(this.timeout), this.timeout = null);
                    try {
                        await Wk(), this.count === 1 && this.players.player("one").start(0, .01), this.count === 2 && this.players.player("two").start(0, .01), this.count === 3 && this.players.player("three").start(0, .01)
                    } catch (t) {
                        console.warn(t)
                    }
                    if (this.count === this.taps) {
                        this.$emit("didCountIn", 0, this.desktopDetected);
                        return
                    }
                    this.timeout = window.setTimeout(() => {
                        this.onTimeout()
                    }, this.timeoutDuration)
                }
            }
        }),
        DTe = {
            class: "constrain"
        },
        $Te = {
            class: "title-box"
        },
        LTe = {
            class: "title"
        },
        FTe = {
            class: "button-box"
        },
        UTe = ["disabled"],
        BTe = {
            class: "pip-box"
        };

    function qTe(t, e, n, r, s, i) {
        const a = On("t"),
            c = On("bb");
        return G(), H("div", {
            class: Xe(["count-in", t.classes])
        }, [B("div", DTe, [B("div", $Te, [Ke(B("p", LTe, null, 512), [
            [a, t.titleKey]
        ])]), B("div", FTe, [Ke(B("button", {
            class: "tap",
            disabled: t.state === "Inactive",
            onPointerdown: e[0] || (e[0] = (...u) => t.onPointerDown && t.onPointerDown(...u))
        }, null, 40, UTe), [
            [c, t.$t(t.buttonKey)]
        ])]), B("div", BTe, [Ke(B("span", null, null, 512), [
            [a, "COUNT_IN.TAP"]
        ]), Nn(" "), Ke(B("span", null, null, 512), [
            [a, "COUNT_IN.TAP"]
        ]), Nn(" "), Ke(B("span", null, null, 512), [
            [a, "COUNT_IN.TAP"]
        ])])])], 2)
    }
    const jTe = ot(MTe, [
            ["render", qTe],
            ["__scopeId", "data-v-e918bacb"]
        ]),
        VTe = mt({}),
        GTe = t => (Ns("data-v-de4a525e"), t = t(), xs(), t),
        WTe = {
            class: "paused"
        },
        HTe = GTe(() => B("div", {
            class: "constrain"
        }, " THIS SONG IS IN PROGRESS. YOU CAN PAUSE AND UNPAUSE THE GAME TO RESYNC ", -1)),
        KTe = [HTe];

    function YTe(t, e, n, r, s, i) {
        return G(), H("div", WTe, KTe)
    }
    const zTe = ot(VTe, [
            ["render", YTe],
            ["__scopeId", "data-v-de4a525e"]
        ]),
        ZTe = mt({}),
        XTe = t => (Ns("data-v-df9b26b5"), t = t(), xs(), t),
        JTe = {
            class: "paused"
        },
        QTe = XTe(() => B("div", {
            class: "constrain"
        }, " PLEASE WAIT WE WILL RESYNC WHEN THE GAME IS READY ", -1)),
        eSe = [QTe];

    function tSe(t, e, n, r, s, i) {
        return G(), H("div", JTe, eSe)
    }
    const nSe = ot(ZTe, [
            ["render", tSe],
            ["__scopeId", "data-v-df9b26b5"]
        ]),
        rSe = mt({
            components: {
                Beatmap: CTe,
                CountIn: jTe,
                InProgress: zTe,
                Paused: nSe
            },
            props: {
                beatmap: {
                    type: Object,
                    required: !0
                },
                hostIsPaused: {
                    type: Boolean,
                    required: !0
                },
                info: {
                    type: Object,
                    required: !0
                },
                instrument: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                }
            },
            data({
                player: t
            }) {
                const e = !t.recordingInfo.isTesting && t.recordingInfo.recordingState === "Playing",
                    n = t.recordingInfo.isTesting ?? !1,
                    r = !t.recordingInfo.isTesting;
                return {
                    runBeatmap: n,
                    showCountIn: r,
                    countInOffset: 0,
                    wasJoinedInProgress: e,
                    isDesktop: !1,
                    isDebug: ln.get("nopus:debug") === "true",
                    isExploring: ln.get("nopus:exploring") === "true"
                }
            },
            computed: {
                classes() {
                    const t = [Ii.categorySlugByKey(this.beatmap.config.category)];
                    return this.isDebug && t.push("is-debug"), this.isExploring && t.push("is-exploring"), t
                },
                drawDistance() {
                    return `${this.player.recordingInfo.duration*.05}%`
                }
            },
            watch: {
                hostIsPaused: {
                    handler: "onPauseChanged",
                    immediate: !0
                }
            },
            methods: {
                onPauseChanged(t) {
                    t && (this.runBeatmap = !1, this.showCountIn = !0, this.wasJoinedInProgress = !1)
                },
                onDidCountIn(t, e) {
                    this.isDesktop = e, this.countInOffset = t, this.runBeatmap = !0, window.setTimeout(() => {
                        this.showCountIn = !1
                    }, 1e3)
                },
                onDebugToggle() {
                    this.isDebug = !this.isDebug, ln.set("nopus:debug", `${this.isDebug}`)
                },
                onExplorerToggle() {
                    this.isExploring = !this.isExploring, ln.set("nopus:exploring", `${this.isExploring}`)
                }
            }
        }),
        x6 = t => (Ns("data-v-6f992f2d"), t = t(), xs(), t),
        sSe = {
            class: "instrument"
        },
        iSe = x6(() => B("br", null, null, -1)),
        oSe = x6(() => B("br", null, null, -1));

    function aSe(t, e, n, r, s, i) {
        const a = st("Beatmap"),
            c = st("CountIn"),
            u = st("Paused"),
            h = st("InProgress");
        return G(), H("div", {
            class: Xe(["recording", t.classes]),
            style: Tn({
                "--draw-distance": t.drawDistance
            })
        }, [(G(), Ut(a, {
            key: t.instrument.name,
            beatmap: t.beatmap,
            "count-in-offset": t.countInOffset,
            instrument: t.instrument,
            "is-audience": t.info.isAudience ?? !1,
            "is-desktop": t.isDesktop,
            player: t.player,
            "should-run": t.runBeatmap
        }, null, 8, ["beatmap", "count-in-offset", "instrument", "is-audience", "is-desktop", "player", "should-run"])), B("p", sSe, vt(t.instrument.name), 1), t.showCountIn ? (G(), Ut(c, {
            key: 0,
            state: t.player.recordingInfo.recordingState,
            onDidCountIn: t.onDidCountIn
        }, null, 8, ["state", "onDidCountIn"])) : Be("", !0), t.hostIsPaused ? (G(), Ut(u, {
            key: 1
        })) : t.wasJoinedInProgress ? (G(), Ut(h, {
            key: 2
        })) : Be("", !0), B("button", {
            class: "debug-toggle toggle",
            onClick: e[0] || (e[0] = (...d) => t.onDebugToggle && t.onDebugToggle(...d))
        }, [Nn("DEBUG"), iSe, Nn(vt(t.isDebug ? "ON" : "OFF"), 1)]), B("button", {
            class: "exploring-toggle toggle",
            onClick: e[1] || (e[1] = (...d) => t.onExplorerToggle && t.onExplorerToggle(...d))
        }, [Nn("EXPLORER"), oSe, Nn(vt(t.isExploring ? "ON" : "OFF"), 1)])], 6)
    }
    const cSe = ot(rSe, [
            ["render", aSe],
            ["__scopeId", "data-v-6f992f2d"]
        ]),
        lSe = mt({
            components: {
                ChangeVIP: vm,
                PlayerHeader: fl
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                },
                players: {
                    type: Object,
                    required: !0
                },
                render: {
                    type: Object,
                    required: !1
                }
            },
            data() {
                return {
                    showChangeVIP: !1
                }
            },
            computed: {
                vipName() {
                    const t = Object.keys(this.players).find(e => this.players[e].isVip);
                    return t !== void 0 ? this.players[t].name : ""
                }
            },
            methods: {
                onDidRequestChangeVIP() {
                    this.showChangeVIP = !0
                },
                onDidRequestModalClose() {
                    this.showChangeVIP = !1
                },
                async onChoiceClick(t) {
                    if (this.player.responseKey) try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            [t]: !0
                        })
                    } catch (e) {
                        this.$handleEcastError(e)
                    }
                }
            }
        }),
        P6 = t => (Ns("data-v-4907da50"), t = t(), xs(), t),
        uSe = {
            class: "scoreboard"
        },
        hSe = {
            key: 0,
            class: "bite",
            viewBox: "0 0 200 100"
        },
        fSe = P6(() => B("polygon", {
            class: "screen",
            points: "176.48 45.33 163.58 4.46 132.15 0 102.19 13.39 102.19 48.88 75.96 33.48 39.75 39.96 28.1 75.22 48.49 95.31 9.57 87.05 0 100 200 100 200 15.85 196.05 16.29 176.48 45.33"
        }, null, -1)),
        dSe = P6(() => B("path", {
            class: "shadow",
            d: "m163.58,4.46l-31.43-4.46-29.97,13.39v25.61l14.57,3.74-3.95-18.42,18.11-12.28,26.43,3.79,4.79,26.9,11.26-7.23-9.8-31.05Zm-85.12,30.49l-2.5-1.47-36.21,6.47-11.65,35.27,10.75,10.58,18.36-.99-18.49-15.18,6.02-21.21,33.74-13.49Z"
        }, null, -1)),
        pSe = [fSe, dSe],
        mSe = {
            class: "constrain menu has-header"
        },
        gSe = {
            key: 0,
            class: "survived"
        },
        _Se = {
            key: 1,
            class: "eaten"
        },
        ySe = {
            class: "title-wrapper"
        },
        vSe = {
            key: 0,
            class: "title"
        },
        bSe = {
            key: 1,
            class: "title"
        },
        ESe = {
            key: 2,
            class: "title"
        },
        TSe = {
            key: 2,
            class: "choices-wrapper"
        },
        SSe = {
            class: "choices"
        };

    function wSe(t, e, n, r, s, i) {
        var h;
        const a = st("PlayerHeader"),
            c = st("ChangeVIP"),
            u = On("t");
        return G(), H("div", uSe, [t.render && !t.render.survived ? (G(), H("svg", hSe, pSe)) : Be("", !0), B("div", mSe, [(h = t.render) != null && h.survived ? (G(), H("h1", gSe, "SURVIVED")) : t.render && !t.render.survived ? (G(), H("h1", _Se, "EATEN")) : Be("", !0), B("div", ySe, [t.info.isVip ? Ke((G(), H("h3", vSe, null, 512)), [
            [u, "MENU.WHAT_NEXT"]
        ]) : t.vipName ? (G(), H("h3", bSe, vt(t.$t("MENU.WAITING_FOR", {
            vipName: t.vipName
        })), 1)) : Ke((G(), H("h3", ESe, null, 512)), [
            [u, "WAITING"]
        ])]), t.info.isVip ? (G(), H("div", TSe, [B("div", SSe, [Ke(B("button", {
            onClick: e[0] || (e[0] = d => t.onChoiceClick("retry"))
        }, null, 512), [
            [u, "MENU.RETRY_SONG"]
        ]), Ke(B("button", {
            onClick: e[1] || (e[1] = d => t.onChoiceClick("newSong"))
        }, null, 512), [
            [u, "MENU.NEW_SONG"]
        ]), Ke(B("button", {
            onClick: e[2] || (e[2] = d => t.onChoiceClick("endSession"))
        }, null, 512), [
            [u, "MENU.END_SESSION"]
        ])])])) : Be("", !0)]), Je(a, {
            info: t.info,
            "is-vip": t.info.isVip && !t.info.isSolo,
            players: t.players,
            "response-key": t.player.responseKey,
            onDidRequestChangeVip: t.onDidRequestChangeVIP
        }, null, 8, ["info", "is-vip", "players", "response-key", "onDidRequestChangeVip"]), Je(Li, {
            name: "modal"
        }, {
            default: si(() => [t.showChangeVIP ? (G(), Ut(c, {
                key: 0,
                info: t.info,
                players: t.players,
                "response-key": t.player.responseKey,
                onDidRequestClose: t.onDidRequestModalClose
            }, null, 8, ["info", "players", "response-key", "onDidRequestClose"])) : Be("", !0)]),
            _: 1
        })])
    }
    const OSe = ot(lSe, [
            ["render", wSe],
            ["__scopeId", "data-v-4907da50"]
        ]),
        ASe = mt({
            props: {
                rating: {
                    type: Number,
                    required: !0
                }
            },
            computed: {
                classes() {
                    const t = [];
                    return this.rating === 8 ? t.push("gold") : this.rating === 7 ? t.push("silver") : this.rating === 6 ? t.push("bronze") : this.rating === 5 && t.push("full"), this.rating === 0 ? t.push("rating-0") : this.rating === 1 ? t.push("rating-1") : this.rating === 2 ? t.push("rating-2") : this.rating === 3 ? t.push("rating-3") : this.rating === 4 ? t.push("rating-4") : t.push("rating-5"), t
                }
            }
        }),
        CSe = {
            key: 0,
            class: "bg-stroke",
            points: "64.76 11.33 49.22 0 35.24 12.09 31.16 28.2 13.35 26.73 0 38.26 5.39 56.27 19.81 64.16 13.23 80.33 18.75 96.75 27.77 99.87 41 95.61 49.34 86.31 60.59 96.27 73.35 100 81.19 96.31 86.58 79.82 79.87 64.16 93.73 55.82 100 37.81 84.95 26.16 67.65 27.94 64.76 11.33"
        },
        kSe = Q5('<polygon class="bg" points="64.76 11.33 49.22 0 35.24 12.09 31.16 28.2 13.35 26.73 0 38.26 5.39 56.27 19.81 64.16 13.23 80.33 18.75 96.75 27.77 99.87 41 95.61 49.34 86.31 60.59 96.27 73.35 100 81.19 96.31 86.58 79.82 79.87 64.16 93.73 55.82 100 37.81 84.95 26.16 67.65 27.94 64.76 11.33" data-v-bc6516f8></polygon><polygon class="petal p5" points="6.02 40.04 9.72 51.11 20.82 59.07 33.04 59.07 44.64 52.45 38.75 41.82 29.84 33.99 16.18 32.08 6.02 40.04" data-v-bc6516f8></polygon><polygon class="petal p4" points="33.35 61.62 23.51 69.7 19.37 80.97 23.7 92.74 27.65 93.7 37.81 89.69 44.26 82.75 47.77 72.44 46.02 59.96 33.35 61.62" data-v-bc6516f8></polygon><polygon class="petal p3" points="75.24 67.92 64.2 60.6 52.98 59.83 52.73 71.8 55.61 83.51 62.76 90.83 72.23 93.83 77.49 91.28 80.5 79.19 75.24 67.92" data-v-bc6516f8></polygon><polygon class="petal p2" points="69.59 33.99 60.69 42.27 55.42 52.9 64.33 57.48 76.24 59.2 89.09 51.75 93.04 39.72 82.95 32.59 69.59 33.99" data-v-bc6516f8></polygon><polygon class="petal p1" points="62.45 29.41 60 15.47 49.34 7.57 39.56 15.47 36.68 28.2 41 38.89 49.53 47.87 57.62 40.04 62.45 29.41" data-v-bc6516f8></polygon>', 6);

    function ISe(t, e, n, r, s, i) {
        return G(), H("svg", {
            viewBox: "0 0 100 100",
            class: Xe(t.classes)
        }, [t.rating > 5 ? (G(), H("polygon", CSe)) : Be("", !0), kSe], 2)
    }
    const NSe = ot(ASe, [
            ["render", ISe],
            ["__scopeId", "data-v-bc6516f8"]
        ]),
        xSe = {},
        PSe = {
            viewBox: "0 0 75 100"
        },
        RSe = B("path", {
            d: "m22,21l13-10,20,11v19l17,1-2-26L31,0,11,15,3,40h18l1-19Zm51,24L1,47l-1,46,40,7,35-5-2-50Zm-31,36h-9l-1-17,6-4,5,6-1,15Z"
        }, null, -1),
        MSe = [RSe];

    function DSe(t, e) {
        return G(), H("svg", PSe, MSe)
    }
    const $Se = ot(xSe, [
            ["render", DSe]
        ]),
        LSe = {},
        FSe = {
            viewBox: "0 0 80 100"
        },
        USe = B("path", {
            d: "m9.69,100c-22.03-2.79-1.78-29.92,14.06-21.33V13.83L79.68,0c-1.07,7.9,2.83,79.11-2.84,84.29-3.99,7.74-16.19,13.35-23.78,7.78-9.11-11.56,9.48-25.36,21.08-19.16V11.05l-44.86,11.98v56.07c.3,10.79-8.3,20.84-19.59,20.89Z"
        }, null, -1),
        BSe = [USe];

    function qSe(t, e) {
        return G(), H("svg", FSe, BSe)
    }
    const jSe = ot(LSe, [
            ["render", qSe]
        ]),
        VSe = {},
        GSe = {
            viewBox: "0 0 100 65"
        },
        WSe = B("path", {
            d: "m94.78,65H5.22c-4.32,0-6.76-4.68-4.13-7.91L46.12,1.84c2-2.45,5.76-2.45,7.76,0l45.03,55.25c2.63,3.23.19,7.91-4.13,7.91Z"
        }, null, -1),
        HSe = [WSe];

    function KSe(t, e) {
        return G(), H("svg", GSe, HSe)
    }
    const YSe = ot(VSe, [
            ["render", KSe]
        ]),
        zSe = mt({
            components: {
                ChangeVIP: vm,
                PlayerHeader: fl,
                CategorySVG: k6,
                FlowerSVG: NSe,
                LockSVG: $Se,
                NoteSVG: jSe,
                UpArrowSVG: YSe
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                players: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                }
            },
            data() {
                return {
                    showChangeVIP: !1,
                    localSelectedIndex: null
                }
            },
            computed: {
                selectedIndex() {
                    return this.choices.findIndex(t => t.isSelected) ?? null
                },
                selectedChoice() {
                    return this.selectedIndex === null ? null : this.choices[this.selectedIndex] ?? null
                },
                upChoice() {
                    return this.selectedIndex === null ? null : this.selectedIndex === 0 ? this.choices[this.choices.length - 1] : this.choices[this.selectedIndex - 1]
                },
                downChoice() {
                    return this.selectedIndex === null ? null : this.selectedIndex === this.choices.length - 1 ? this.choices[0] : this.choices[this.selectedIndex + 1]
                },
                choices() {
                    const t = [];
                    return this.player.songs.songs.forEach((e, n) => {
                        if (!this.info.isVip && e.isLocked) return;
                        const r = [];
                        e.isSelected && r.push("on-screen"), n === this.localSelectedIndex && r.push("nominated"), t.push({
                            classes: r,
                            name: e.name,
                            slug: e.slug,
                            highestRating: e.highestRating,
                            categories: e.beatmapProgress,
                            isSelected: e.isSelected,
                            isLocked: e.isLocked
                        })
                    }), t
                }
            },
            mounted() {
                document.addEventListener("keydown", this.onKeyDown.bind(this))
            },
            beforeUnmount() {
                document.removeEventListener("keydown", this.onKeyDown.bind(this))
            },
            methods: {
                onDidRequestChangeVIP() {
                    this.showChangeVIP = !0
                },
                onDidRequestModalClose() {
                    this.showChangeVIP = !1
                },
                onKeyDown(t) {
                    t.key === "ArrowDown" && this.onDirectionClick("down"), t.key === "ArrowUp" && this.onDirectionClick("up")
                },
                async onDirectionClick(t) {
                    if (this.info.isVip) try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            scrollSong: t
                        })
                    } catch (e) {
                        this.$handleEcastError(e)
                    }
                },
                async onSelectClick() {
                    if (this.selectedChoice) try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            selectSong: !0
                        })
                    } catch (t) {
                        this.$handleEcastError(t)
                    }
                },
                async onVoteClick(t) {
                    this.localSelectedIndex = null, window.setTimeout(() => {
                        this.localSelectedIndex = t
                    }, 50);
                    try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            voteSong: this.choices[t].slug
                        })
                    } catch (e) {
                        this.$handleEcastError(e)
                    }
                }
            }
        }),
        ZSe = {
            class: "song-select"
        },
        XSe = {
            class: "constrain menu has-header"
        },
        JSe = {
            class: "title-wrapper"
        },
        QSe = {
            key: 0,
            class: "title"
        },
        ewe = {
            key: 1,
            class: "title"
        },
        twe = {
            key: 0,
            class: "choices"
        },
        nwe = ["aria-label"],
        rwe = ["aria-label"],
        swe = {
            key: 1,
            class: "choices"
        },
        iwe = ["onClick"],
        owe = {
            key: 0,
            class: "details"
        },
        awe = {
            class: "info"
        },
        cwe = {
            class: "name"
        },
        lwe = {
            class: "box score"
        },
        uwe = {
            class: "box parts"
        },
        hwe = {
            class: "label"
        },
        fwe = {
            class: "value indicators"
        },
        dwe = ["aria-label", "disabled"];

    function pwe(t, e, n, r, s, i) {
        var y, v, w, b;
        const a = st("UpArrowSVG"),
            c = st("NoteSVG"),
            u = st("LockSVG"),
            h = st("FlowerSVG"),
            d = st("CategorySVG"),
            p = st("PlayerHeader"),
            m = st("ChangeVIP"),
            _ = On("t");
        return G(), H("div", ZSe, [B("div", XSe, [B("div", JSe, [t.info.isVip ? Ke((G(), H("h3", QSe, null, 512)), [
            [_, "MENU.CHOOSE_SONG"]
        ]) : Ke((G(), H("h3", ewe, null, 512)), [
            [_, "MENU.VOTE_SONG"]
        ])]), B("div", {
            class: Xe(["choices-wrapper", {
                "is-choosing": t.info.isVip
            }])
        }, [t.info.isVip ? (G(), H("div", twe, [B("button", {
            class: "direction",
            "aria-label": t.$t("ARIA.SONG_UP", {
                songName: ((y = t.upChoice) == null ? void 0 : y.name) ?? ""
            }),
            onClick: e[0] || (e[0] = I => t.onDirectionClick("up"))
        }, [Je(a)], 8, nwe), B("button", {
            class: "direction",
            "aria-label": t.$t("ARIA.SONG_DOWN", {
                songName: ((v = t.downChoice) == null ? void 0 : v.name) ?? ""
            }),
            onClick: e[1] || (e[1] = I => t.onDirectionClick("down"))
        }, [Je(a)], 8, rwe)])) : (G(), H("div", swe, [(G(!0), H(Tt, null, $n(t.choices, (I, F) => (G(), H("button", {
            key: F,
            class: Xe([I.classes, "choice has-icon"]),
            onClick: Pi(x => t.onVoteClick(F), ["prevent"])
        }, [I === t.selectedChoice ? (G(), Ut(c, {
            key: 0,
            class: "icon note"
        })) : Be("", !0), Nn(" " + vt(I.name), 1)], 10, iwe))), 128))]))], 2), t.info.isVip && t.selectedChoice ? (G(), H("div", owe, [B("div", awe, [B("p", cwe, [t.selectedChoice.isLocked ? (G(), Ut(u, {
            key: 0,
            class: "icon"
        })) : (G(), Ut(c, {
            key: 1,
            class: "icon"
        })), Nn(" " + vt(t.selectedChoice.name), 1)]), B("div", lwe, [Je(h, {
            class: "flower",
            rating: t.selectedChoice.highestRating
        }, null, 8, ["rating"])]), B("div", uwe, [Ke(B("p", hwe, null, 512), [
            [_, "MENU.COMPLETED_PARTS"]
        ]), B("div", fwe, [(G(!0), H(Tt, null, $n(t.selectedChoice.categories, (I, F) => (G(), Ut(d, {
            key: F,
            category: I.category,
            class: Xe(["indicator", {
                perfected: I.isPerfected,
                incomplete: !I.isSurvived
            }])
        }, null, 8, ["category", "class"]))), 128))])])])])) : Be("", !0), t.info.isVip ? Ke((G(), H("button", {
            key: 1,
            "aria-label": t.$t("ARIA.SELECT_SONG", {
                songName: ((w = t.selectedChoice) == null ? void 0 : w.name) ?? ""
            }),
            class: "commit",
            disabled: (b = t.selectedChoice) == null ? void 0 : b.isLocked,
            onClick: e[2] || (e[2] = (...I) => t.onSelectClick && t.onSelectClick(...I))
        }, null, 8, dwe)), [
            [_, "MENU.SELECT_SONG"]
        ]) : Be("", !0)]), Je(p, {
            info: t.info,
            players: t.players,
            "is-vip": t.info.isVip && !t.info.isSolo,
            "response-key": t.player.responseKey,
            onDidRequestChangeVip: t.onDidRequestChangeVIP
        }, null, 8, ["info", "players", "is-vip", "response-key", "onDidRequestChangeVip"]), Je(Li, {
            name: "modal"
        }, {
            default: si(() => [t.showChangeVIP ? (G(), Ut(m, {
                key: 0,
                info: t.info,
                players: t.players,
                "response-key": t.player.responseKey,
                onDidRequestClose: t.onDidRequestModalClose
            }, null, 8, ["info", "players", "response-key", "onDidRequestClose"])) : Be("", !0)]),
            _: 1
        })])
    }
    const mwe = ot(zSe, [
            ["render", pwe],
            ["__scopeId", "data-v-e84d3f28"]
        ]),
        gwe = mt({
            components: {
                PlayerHeader: fl
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !1
                }
            }
        }),
        _we = t => (Ns("data-v-33c50df1"), t = t(), xs(), t),
        ywe = {
            class: "waiting"
        },
        vwe = _we(() => B("div", {
            class: "constrain menu has-header"
        }, [B("div", {
            class: "bg"
        })], -1));

    function bwe(t, e, n, r, s, i) {
        const a = st("PlayerHeader");
        return G(), H("div", ywe, [vwe, Je(a, {
            info: t.info
        }, null, 8, ["info"])])
    }
    const Ewe = ot(gwe, [
            ["render", bwe],
            ["__scopeId", "data-v-33c50df1"]
        ]),
        Twe = "main/pp10/nopus-opus/assets/34539c96.mp3",
        Swe = "main/pp10/nopus-opus/assets/6d7d4f0c.ogg",
        wwe = "main/pp10/nopus-opus/assets/cfa29138.wav",
        Owe = mt({
            components: {
                BaseModal: GC
            },
            setup() {
                const t = Ot.supportsType("ogg") ? "ogg" : "mp3",
                    e = new ko(new URL(Object.assign({
                        "../../assets/welcome.mp3": Twe,
                        "../../assets/welcome.ogg": Swe,
                        "../../assets/welcome.wav": wwe
                    })[`../../assets/welcome.${t}`], self.location).href).toDestination();
                return e.volume.value = -3, {
                    player: e
                }
            },
            methods: {
                onCloseClick() {
                    this.$emit("didRequestClose")
                },
                async onTestClick() {
                    await Wk(), this.player.start(0, .01)
                }
            }
        });

    function Awe(t, e, n, r, s, i) {
        const a = st("BaseModal"),
            c = On("t");
        return G(), Ut(a, {
            "title-key": "WELCOME.WELCOME"
        }, {
            default: si(() => [B("ul", null, [Ke(B("li", null, null, 512), [
                [c, "WELCOME.SILENT"]
            ]), Ke(B("li", null, null, 512), [
                [c, "WELCOME.VOLUME"]
            ]), Ke(B("li", null, null, 512), [
                [c, "WELCOME.POWER_SAVER"]
            ])]), Ke(B("button", {
                class: "choice",
                onClick: e[0] || (e[0] = (...u) => t.onTestClick && t.onTestClick(...u))
            }, null, 512), [
                [c, "WELCOME.TEST"]
            ]), Ke(B("button", {
                class: "secondary close",
                onClick: e[1] || (e[1] = (...u) => t.onCloseClick && t.onCloseClick(...u))
            }, null, 512), [
                [c, "WELCOME.GO"]
            ])]),
            _: 1
        }, 8, ["title-key"])
    }
    const Cwe = ot(Owe, [
            ["render", Awe]
        ]),
        kwe = mt({
            components: {
                Credits: _pe,
                InstrumentSelect: AEe,
                Playback: PEe,
                Recording: cSe,
                Scoreboard: OSe,
                SongSelect: mwe,
                Waiting: Ewe,
                Welcome: Cwe
            },
            bb: {
                break: () => "<br />",
                info: (t, e) => `<span class="sub">${e}</span>`
            },
            ecastKeys: {
                audience: "audiencePlayer",
                player: ({
                    id: t
                }) => `player:${t}`,
                players: "connectedPlayers"
            },
            ecastProviders: {
                beatmaps: t => {
                    const e = {};
                    return Object.keys(t).forEach(n => {
                        const [r, s] = n.split(":");
                        r === "beatmap" && (e[s] = t[n])
                    }), e
                },
                hostIsPaused: t => {
                    var e;
                    return ((e = t.hostIsPaused) == null ? void 0 : e.hostIsPaused) ?? !1
                },
                info: (t, {
                    id: e
                }) => {
                    const n = t.connectedPlayers[e];
                    return t.audiencePlayer || !n ? {
                        name: "",
                        id: e,
                        avatar: 99,
                        isAudience: !0
                    } : t.connectedPlayers ? (Object.keys(t.connectedPlayers).length === 1 && (n.isSolo = !0), n) : void 0
                },
                instruments: t => {
                    const e = {};
                    return Object.keys(t).forEach(n => {
                        const [r, s] = n.split(":");
                        r === "instrument" && (e[s] = t[n])
                    }), e
                },
                renders: t => t.songData ? t.songData.songs : []
            },
            props: {
                audience: Object,
                beatmaps: Object,
                hostIsPaused: Boolean,
                info: Object,
                instruments: Object,
                player: Object,
                players: Object,
                renders: Array
            },
            themeColor: "#000",
            data() {
                return {
                    showWelcome: !1,
                    themeClass: "bg-default"
                }
            },
            computed: {
                isReady() {
                    return !(!this.player && !this.audience || this.player && !this.info)
                },
                lastRender() {
                    var t;
                    return (t = this.renders) != null && t.length ? this.renders[this.renders.length - 1] : null
                },
                screen() {
                    var n, r;
                    const t = ((n = this.player) == null ? void 0 : n.kind) ?? ((r = this.audience) == null ? void 0 : r.kind),
                        e = {
                            info: this.info,
                            player: this.player ?? this.audience
                        };
                    switch (t) {
                        case "credits":
                            return e.renders = this.renders, ["Credits", e];
                        case "playback":
                            return ["Playback", e];
                        case "audienceRecording":
                        case "recording":
                            const s = this.getBeatmapAndInstrument();
                            return s ? (e.hostIsPaused = this.hostIsPaused, e.beatmap = s[0], e.instrument = s[1], ["Recording", e]) : ["Waiting", e];
                        case "instrumentSelect":
                            return e.beatmaps = this.beatmaps, e.instruments = this.instruments, e.players = this.players, ["InstrumentSelect", e];
                        case "scoreboard":
                            return e.players = this.players, e.render = this.lastRender, ["Scoreboard", e];
                        case "songSelect":
                            return e.players = this.players, ["SongSelect", e]
                    }
                    return ["Waiting", e]
                }
            },
            watch: {
                "player.kind": "updateColors",
                "audience.kind": "updateColors"
            },
            mounted() {
                var t, e;
                this.updateColors(((t = this.player) == null ? void 0 : t.kind) ?? ((e = this.audience) == null ? void 0 : e.kind) ?? "", !0), document.body.classList.add("disabled-debug"), setTimeout(() => {
                    var r;
                    !ln.get("welcome", "code") && ((r = this.info) == null ? void 0 : r.name) !== "CARTOGRAPHER" && (this.showWelcome = !0, ln.set("welcome", "true", "code"))
                }, 500)
            },
            methods: {
                onDidRequestModalClose() {
                    this.showWelcome = !1
                },
                getBeatmapAndInstrument() {
                    if (!this.info || !this.beatmaps || !this.instruments) return null;
                    const t = this.info.isAudience ? ln.get("beatmap", "code") : this.info.beatmapSlug,
                        e = this.info.isAudience ? ln.get("instrument", "code") : this.info.instrumentSlug;
                    if (!t || !e) return null;
                    const n = this.beatmaps[t],
                        r = this.instruments[e];
                    return !n || !r ? null : [n, r]
                },
                updateColors(t, e = !1) {
                    var n;
                    if (t === "audienceRecording") {
                        this.themeClass = "theme-blue", this.$setThemeColor("#3a3d75");
                        return
                    }
                    if (t === "credits") {
                        this.themeClass = "theme-purple", this.$setThemeColor("#000000");
                        return
                    }
                    if (t === "instrumentSelect") {
                        this.themeClass = "theme-purple", this.$setThemeColor("#000000");
                        return
                    }
                    if (t === "playback") {
                        this.themeClass = "theme-purple", this.$setThemeColor("#300f4a");
                        return
                    }
                    if (t === "recording") {
                        this.themeClass = "theme-purple", this.$setThemeColor("#300f4a");
                        return
                    }
                    if (t === "scoreboard") {
                        this.themeClass = (n = this.lastRender) != null && n.survived ? "theme-yellow" : "theme-purple", this.$setThemeColor("#000000");
                        return
                    }
                    if (t === "songSelect") {
                        this.themeClass = "theme-green", this.$setThemeColor("#000000");
                        return
                    }
                    e === !0 && (this.themeClass = "theme-green", this.$setThemeColor("#000000"))
                }
            }
        });

    function Iwe(t, e, n, r, s, i) {
        const a = st("Welcome");
        return t.isReady ? (G(), H("div", {
            key: 0,
            class: Xe(["nopus", t.themeClass])
        }, [t.screen ? (G(), Ut(Fy(t.screen[0]), Bp({
            key: 0,
            role: "main"
        }, t.screen[1]), null, 16)) : Be("", !0), Je(Li, {
            name: "modal"
        }, {
            default: si(() => [t.showWelcome ? (G(), Ut(a, {
                key: 0,
                onDidRequestClose: t.onDidRequestModalClose
            }, null, 8, ["onDidRequestClose"])) : Be("", !0)]),
            _: 1
        })], 2)) : Be("", !0)
    }
    const Nwe = ot(kwe, [
        ["render", Iwe]
    ]);
    yhe({
        MainView: Nwe,
        messages: Afe,
        plugins: [Ole]
    })
});
export default xwe();
//# sourceMappingURL=96269f59.js.map