var hR = Object.defineProperty;
var fR = (t, e, n) => e in t ? hR(t, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : t[e] = n;
var dR = (t, e) => () => (e || t((e = {
    exports: {}
}).exports, e), e.exports);
var Ce = (t, e, n) => (fR(t, typeof e != "symbol" ? e + "" : e, n), n);
var Dwe = dR((Z3e, Mk) => {
    (function() {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s);
        new MutationObserver(s => {
            for (const i of s)
                if (i.type === "childList")
                    for (const a of i.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a)
        }).observe(document, {
            childList: !0,
            subtree: !0
        });

        function n(s) {
            const i = {};
            return s.integrity && (i.integrity = s.integrity), s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i
        }

        function r(s) {
            if (s.ep) return;
            s.ep = !0;
            const i = n(s);
            fetch(s.href, i)
        }
    })();

    function Oy(t, e) {
        const n = Object.create(null),
            r = t.split(",");
        for (let s = 0; s < r.length; s++) n[r[s]] = !0;
        return e ? s => !!n[s.toLowerCase()] : s => !!n[s]
    }
    const Qt = {},
        pc = [],
        Ts = () => {},
        pR = () => !1,
        mR = /^on[^a-z]/,
        Cp = t => mR.test(t),
        Ay = t => t.startsWith("onUpdate:"),
        wn = Object.assign,
        Cy = (t, e) => {
            const n = t.indexOf(e);
            n > -1 && t.splice(n, 1)
        },
        gR = Object.prototype.hasOwnProperty,
        kt = (t, e) => gR.call(t, e),
        We = Array.isArray,
        mc = t => Hl(t) === "[object Map]",
        Ip = t => Hl(t) === "[object Set]",
        BE = t => Hl(t) === "[object Date]",
        lt = t => typeof t == "function",
        bn = t => typeof t == "string",
        cl = t => typeof t == "symbol",
        Gt = t => t !== null && typeof t == "object",
        i5 = t => Gt(t) && lt(t.then) && lt(t.catch),
        o5 = Object.prototype.toString,
        Hl = t => o5.call(t),
        _R = t => Hl(t).slice(8, -1),
        a5 = t => Hl(t) === "[object Object]",
        Iy = t => bn(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t,
        jf = Oy(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
        kp = t => {
            const e = Object.create(null);
            return n => e[n] || (e[n] = t(n))
        },
        yR = /-(\w)/g,
        zs = kp(t => t.replace(yR, (e, n) => n ? n.toUpperCase() : "")),
        vR = /\B([A-Z])/g,
        ka = kp(t => t.replace(vR, "-$1").toLowerCase()),
        Np = kp(t => t.charAt(0).toUpperCase() + t.slice(1)),
        zg = kp(t => t ? `on${Np(t)}` : ""),
        ul = (t, e) => !Object.is(t, e),
        Gf = (t, e) => {
            for (let n = 0; n < t.length; n++) t[n](e)
        },
        nd = (t, e, n) => {
            Object.defineProperty(t, e, {
                configurable: !0,
                enumerable: !1,
                value: n
            })
        },
        Y_ = t => {
            const e = parseFloat(t);
            return isNaN(e) ? t : e
        },
        bR = t => {
            const e = bn(t) ? Number(t) : NaN;
            return isNaN(e) ? t : e
        };
    let qE;
    const z_ = () => qE || (qE = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

    function Jn(t) {
        if (We(t)) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const r = t[n],
                    s = bn(r) ? wR(r) : Jn(r);
                if (s)
                    for (const i in s) e[i] = s[i]
            }
            return e
        } else {
            if (bn(t)) return t;
            if (Gt(t)) return t
        }
    }
    const ER = /;(?![^(]*\))/g,
        SR = /:([^]+)/,
        TR = /\/\*[^]*?\*\//g;

    function wR(t) {
        const e = {};
        return t.replace(TR, "").split(ER).forEach(n => {
            if (n) {
                const r = n.split(SR);
                r.length > 1 && (e[r[0].trim()] = r[1].trim())
            }
        }), e
    }

    function mt(t) {
        let e = "";
        if (bn(t)) e = t;
        else if (We(t))
            for (let n = 0; n < t.length; n++) {
                const r = mt(t[n]);
                r && (e += r + " ")
            } else if (Gt(t))
                for (const n in t) t[n] && (e += n + " ");
        return e.trim()
    }
    const OR = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
        AR = Oy(OR);

    function c5(t) {
        return !!t || t === ""
    }

    function CR(t, e) {
        if (t.length !== e.length) return !1;
        let n = !0;
        for (let r = 0; n && r < t.length; r++) n = xp(t[r], e[r]);
        return n
    }

    function xp(t, e) {
        if (t === e) return !0;
        let n = BE(t),
            r = BE(e);
        if (n || r) return n && r ? t.getTime() === e.getTime() : !1;
        if (n = cl(t), r = cl(e), n || r) return t === e;
        if (n = We(t), r = We(e), n || r) return n && r ? CR(t, e) : !1;
        if (n = Gt(t), r = Gt(e), n || r) {
            if (!n || !r) return !1;
            const s = Object.keys(t).length,
                i = Object.keys(e).length;
            if (s !== i) return !1;
            for (const a in t) {
                const c = t.hasOwnProperty(a),
                    l = e.hasOwnProperty(a);
                if (c && !l || !c && l || !xp(t[a], e[a])) return !1
            }
        }
        return String(t) === String(e)
    }

    function u5(t, e) {
        return t.findIndex(n => xp(n, e))
    }
    const _t = t => bn(t) ? t : t == null ? "" : We(t) || Gt(t) && (t.toString === o5 || !lt(t.toString)) ? JSON.stringify(t, l5, 2) : String(t),
        l5 = (t, e) => e && e.__v_isRef ? l5(t, e.value) : mc(e) ? {
            [`Map(${e.size})`]: [...e.entries()].reduce((n, [r, s]) => (n[`${r} =>`] = s, n), {})
        } : Ip(e) ? {
            [`Set(${e.size})`]: [...e.values()]
        } : Gt(e) && !We(e) && !a5(e) ? String(e) : e;
    let ps;
    class h5 {
        constructor(e = !1) {
            this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = ps, !e && ps && (this.index = (ps.scopes || (ps.scopes = [])).push(this) - 1)
        }
        get active() {
            return this._active
        }
        run(e) {
            if (this._active) {
                const n = ps;
                try {
                    return ps = this, e()
                } finally {
                    ps = n
                }
            }
        }
        on() {
            ps = this
        }
        off() {
            ps = this.parent
        }
        stop(e) {
            if (this._active) {
                let n, r;
                for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop();
                for (n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]();
                if (this.scopes)
                    for (n = 0, r = this.scopes.length; n < r; n++) this.scopes[n].stop(!0);
                if (!this.detached && this.parent && !e) {
                    const s = this.parent.scopes.pop();
                    s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index)
                }
                this.parent = void 0, this._active = !1
            }
        }
    }

    function IR(t) {
        return new h5(t)
    }

    function kR(t, e = ps) {
        e && e.active && e.effects.push(t)
    }

    function NR() {
        return ps
    }
    const ky = t => {
            const e = new Set(t);
            return e.w = 0, e.n = 0, e
        },
        f5 = t => (t.w & bo) > 0,
        d5 = t => (t.n & bo) > 0,
        xR = ({
            deps: t
        }) => {
            if (t.length)
                for (let e = 0; e < t.length; e++) t[e].w |= bo
        },
        PR = t => {
            const {
                deps: e
            } = t;
            if (e.length) {
                let n = 0;
                for (let r = 0; r < e.length; r++) {
                    const s = e[r];
                    f5(s) && !d5(s) ? s.delete(t) : e[n++] = s, s.w &= ~bo, s.n &= ~bo
                }
                e.length = n
            }
        },
        Z_ = new WeakMap;
    let ju = 0,
        bo = 1;
    const X_ = 30;
    let vs;
    const da = Symbol(""),
        Q_ = Symbol("");
    class Ny {
        constructor(e, n = null, r) {
            this.fn = e, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, kR(this, r)
        }
        run() {
            if (!this.active) return this.fn();
            let e = vs,
                n = fo;
            for (; e;) {
                if (e === this) return;
                e = e.parent
            }
            try {
                return this.parent = vs, vs = this, fo = !0, bo = 1 << ++ju, ju <= X_ ? xR(this) : VE(this), this.fn()
            } finally {
                ju <= X_ && PR(this), bo = 1 << --ju, vs = this.parent, fo = n, this.parent = void 0, this.deferStop && this.stop()
            }
        }
        stop() {
            vs === this ? this.deferStop = !0 : this.active && (VE(this), this.onStop && this.onStop(), this.active = !1)
        }
    }

    function VE(t) {
        const {
            deps: e
        } = t;
        if (e.length) {
            for (let n = 0; n < e.length; n++) e[n].delete(t);
            e.length = 0
        }
    }
    let fo = !0;
    const p5 = [];

    function Qc() {
        p5.push(fo), fo = !1
    }

    function Jc() {
        const t = p5.pop();
        fo = t === void 0 ? !0 : t
    }

    function Ar(t, e, n) {
        if (fo && vs) {
            let r = Z_.get(t);
            r || Z_.set(t, r = new Map);
            let s = r.get(n);
            s || r.set(n, s = ky()), m5(s)
        }
    }

    function m5(t, e) {
        let n = !1;
        ju <= X_ ? d5(t) || (t.n |= bo, n = !f5(t)) : n = !t.has(vs), n && (t.add(vs), vs.deps.push(t))
    }

    function Ni(t, e, n, r, s, i) {
        const a = Z_.get(t);
        if (!a) return;
        let c = [];
        if (e === "clear") c = [...a.values()];
        else if (n === "length" && We(t)) {
            const l = Number(r);
            a.forEach((h, d) => {
                (d === "length" || d >= l) && c.push(h)
            })
        } else switch (n !== void 0 && c.push(a.get(n)), e) {
            case "add":
                We(t) ? Iy(n) && c.push(a.get("length")) : (c.push(a.get(da)), mc(t) && c.push(a.get(Q_)));
                break;
            case "delete":
                We(t) || (c.push(a.get(da)), mc(t) && c.push(a.get(Q_)));
                break;
            case "set":
                mc(t) && c.push(a.get(da));
                break
        }
        if (c.length === 1) c[0] && J_(c[0]);
        else {
            const l = [];
            for (const h of c) h && l.push(...h);
            J_(ky(l))
        }
    }

    function J_(t, e) {
        const n = We(t) ? t : [...t];
        for (const r of n) r.computed && jE(r);
        for (const r of n) r.computed || jE(r)
    }

    function jE(t, e) {
        (t !== vs || t.allowRecurse) && (t.scheduler ? t.scheduler() : t.run())
    }
    const RR = Oy("__proto__,__v_isRef,__isVue"),
        g5 = new Set(Object.getOwnPropertyNames(Symbol).filter(t => t !== "arguments" && t !== "caller").map(t => Symbol[t]).filter(cl)),
        MR = xy(),
        DR = xy(!1, !0),
        $R = xy(!0),
        GE = LR();

    function LR() {
        const t = {};
        return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
            t[e] = function(...n) {
                const r = xt(this);
                for (let i = 0, a = this.length; i < a; i++) Ar(r, "get", i + "");
                const s = r[e](...n);
                return s === -1 || s === !1 ? r[e](...n.map(xt)) : s
            }
        }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
            t[e] = function(...n) {
                Qc();
                const r = xt(this)[e].apply(this, n);
                return Jc(), r
            }
        }), t
    }

    function FR(t) {
        const e = xt(this);
        return Ar(e, "has", t), e.hasOwnProperty(t)
    }

    function xy(t = !1, e = !1) {
        return function(r, s, i) {
            if (s === "__v_isReactive") return !t;
            if (s === "__v_isReadonly") return t;
            if (s === "__v_isShallow") return e;
            if (s === "__v_raw" && i === (t ? e ? eM : E5 : e ? b5 : v5).get(r)) return r;
            const a = We(r);
            if (!t) {
                if (a && kt(GE, s)) return Reflect.get(GE, s, i);
                if (s === "hasOwnProperty") return FR
            }
            const c = Reflect.get(r, s, i);
            return (cl(s) ? g5.has(s) : RR(s)) || (t || Ar(r, "get", s), e) ? c : qn(c) ? a && Iy(s) ? c : c.value : Gt(c) ? t ? S5(c) : Nc(c) : c
        }
    }
    const UR = _5(),
        BR = _5(!0);

    function _5(t = !1) {
        return function(n, r, s, i) {
            let a = n[r];
            if (xc(a) && qn(a) && !qn(s)) return !1;
            if (!t && (!rd(s) && !xc(s) && (a = xt(a), s = xt(s)), !We(n) && qn(a) && !qn(s))) return a.value = s, !0;
            const c = We(n) && Iy(r) ? Number(r) < n.length : kt(n, r),
                l = Reflect.set(n, r, s, i);
            return n === xt(i) && (c ? ul(s, a) && Ni(n, "set", r, s) : Ni(n, "add", r, s)), l
        }
    }

    function qR(t, e) {
        const n = kt(t, e);
        t[e];
        const r = Reflect.deleteProperty(t, e);
        return r && n && Ni(t, "delete", e, void 0), r
    }

    function VR(t, e) {
        const n = Reflect.has(t, e);
        return (!cl(e) || !g5.has(e)) && Ar(t, "has", e), n
    }

    function jR(t) {
        return Ar(t, "iterate", We(t) ? "length" : da), Reflect.ownKeys(t)
    }
    const y5 = {
            get: MR,
            set: UR,
            deleteProperty: qR,
            has: VR,
            ownKeys: jR
        },
        GR = {
            get: $R,
            set(t, e) {
                return !0
            },
            deleteProperty(t, e) {
                return !0
            }
        },
        WR = wn({}, y5, {
            get: DR,
            set: BR
        }),
        Py = t => t,
        Pp = t => Reflect.getPrototypeOf(t);

    function df(t, e, n = !1, r = !1) {
        t = t.__v_raw;
        const s = xt(t),
            i = xt(e);
        n || (e !== i && Ar(s, "get", e), Ar(s, "get", i));
        const {
            has: a
        } = Pp(s), c = r ? Py : n ? Dy : ll;
        if (a.call(s, e)) return c(t.get(e));
        if (a.call(s, i)) return c(t.get(i));
        t !== s && t.get(e)
    }

    function pf(t, e = !1) {
        const n = this.__v_raw,
            r = xt(n),
            s = xt(t);
        return e || (t !== s && Ar(r, "has", t), Ar(r, "has", s)), t === s ? n.has(t) : n.has(t) || n.has(s)
    }

    function mf(t, e = !1) {
        return t = t.__v_raw, !e && Ar(xt(t), "iterate", da), Reflect.get(t, "size", t)
    }

    function WE(t) {
        t = xt(t);
        const e = xt(this);
        return Pp(e).has.call(e, t) || (e.add(t), Ni(e, "add", t, t)), this
    }

    function HE(t, e) {
        e = xt(e);
        const n = xt(this),
            {
                has: r,
                get: s
            } = Pp(n);
        let i = r.call(n, t);
        i || (t = xt(t), i = r.call(n, t));
        const a = s.call(n, t);
        return n.set(t, e), i ? ul(e, a) && Ni(n, "set", t, e) : Ni(n, "add", t, e), this
    }

    function KE(t) {
        const e = xt(this),
            {
                has: n,
                get: r
            } = Pp(e);
        let s = n.call(e, t);
        s || (t = xt(t), s = n.call(e, t)), r && r.call(e, t);
        const i = e.delete(t);
        return s && Ni(e, "delete", t, void 0), i
    }

    function YE() {
        const t = xt(this),
            e = t.size !== 0,
            n = t.clear();
        return e && Ni(t, "clear", void 0, void 0), n
    }

    function gf(t, e) {
        return function(r, s) {
            const i = this,
                a = i.__v_raw,
                c = xt(a),
                l = e ? Py : t ? Dy : ll;
            return !t && Ar(c, "iterate", da), a.forEach((h, d) => r.call(s, l(h), l(d), i))
        }
    }

    function _f(t, e, n) {
        return function(...r) {
            const s = this.__v_raw,
                i = xt(s),
                a = mc(i),
                c = t === "entries" || t === Symbol.iterator && a,
                l = t === "keys" && a,
                h = s[t](...r),
                d = n ? Py : e ? Dy : ll;
            return !e && Ar(i, "iterate", l ? Q_ : da), {
                next() {
                    const {
                        value: p,
                        done: g
                    } = h.next();
                    return g ? {
                        value: p,
                        done: g
                    } : {
                        value: c ? [d(p[0]), d(p[1])] : d(p),
                        done: g
                    }
                },
                [Symbol.iterator]() {
                    return this
                }
            }
        }
    }

    function Qi(t) {
        return function(...e) {
            return t === "delete" ? !1 : this
        }
    }

    function HR() {
        const t = {
                get(i) {
                    return df(this, i)
                },
                get size() {
                    return mf(this)
                },
                has: pf,
                add: WE,
                set: HE,
                delete: KE,
                clear: YE,
                forEach: gf(!1, !1)
            },
            e = {
                get(i) {
                    return df(this, i, !1, !0)
                },
                get size() {
                    return mf(this)
                },
                has: pf,
                add: WE,
                set: HE,
                delete: KE,
                clear: YE,
                forEach: gf(!1, !0)
            },
            n = {
                get(i) {
                    return df(this, i, !0)
                },
                get size() {
                    return mf(this, !0)
                },
                has(i) {
                    return pf.call(this, i, !0)
                },
                add: Qi("add"),
                set: Qi("set"),
                delete: Qi("delete"),
                clear: Qi("clear"),
                forEach: gf(!0, !1)
            },
            r = {
                get(i) {
                    return df(this, i, !0, !0)
                },
                get size() {
                    return mf(this, !0)
                },
                has(i) {
                    return pf.call(this, i, !0)
                },
                add: Qi("add"),
                set: Qi("set"),
                delete: Qi("delete"),
                clear: Qi("clear"),
                forEach: gf(!0, !0)
            };
        return ["keys", "values", "entries", Symbol.iterator].forEach(i => {
            t[i] = _f(i, !1, !1), n[i] = _f(i, !0, !1), e[i] = _f(i, !1, !0), r[i] = _f(i, !0, !0)
        }), [t, n, e, r]
    }
    const [KR, YR, zR, ZR] = HR();

    function Ry(t, e) {
        const n = e ? t ? ZR : zR : t ? YR : KR;
        return (r, s, i) => s === "__v_isReactive" ? !t : s === "__v_isReadonly" ? t : s === "__v_raw" ? r : Reflect.get(kt(n, s) && s in r ? n : r, s, i)
    }
    const XR = {
            get: Ry(!1, !1)
        },
        QR = {
            get: Ry(!1, !0)
        },
        JR = {
            get: Ry(!0, !1)
        },
        v5 = new WeakMap,
        b5 = new WeakMap,
        E5 = new WeakMap,
        eM = new WeakMap;

    function tM(t) {
        switch (t) {
            case "Object":
            case "Array":
                return 1;
            case "Map":
            case "Set":
            case "WeakMap":
            case "WeakSet":
                return 2;
            default:
                return 0
        }
    }

    function nM(t) {
        return t.__v_skip || !Object.isExtensible(t) ? 0 : tM(_R(t))
    }

    function Nc(t) {
        return xc(t) ? t : My(t, !1, y5, XR, v5)
    }

    function rM(t) {
        return My(t, !1, WR, QR, b5)
    }

    function S5(t) {
        return My(t, !0, GR, JR, E5)
    }

    function My(t, e, n, r, s) {
        if (!Gt(t) || t.__v_raw && !(e && t.__v_isReactive)) return t;
        const i = s.get(t);
        if (i) return i;
        const a = nM(t);
        if (a === 0) return t;
        const c = new Proxy(t, a === 2 ? r : n);
        return s.set(t, c), c
    }

    function gc(t) {
        return xc(t) ? gc(t.__v_raw) : !!(t && t.__v_isReactive)
    }

    function xc(t) {
        return !!(t && t.__v_isReadonly)
    }

    function rd(t) {
        return !!(t && t.__v_isShallow)
    }

    function T5(t) {
        return gc(t) || xc(t)
    }

    function xt(t) {
        const e = t && t.__v_raw;
        return e ? xt(e) : t
    }

    function w5(t) {
        return nd(t, "__v_skip", !0), t
    }
    const ll = t => Gt(t) ? Nc(t) : t,
        Dy = t => Gt(t) ? S5(t) : t;

    function O5(t) {
        fo && vs && (t = xt(t), m5(t.dep || (t.dep = ky())))
    }

    function A5(t, e) {
        t = xt(t);
        const n = t.dep;
        n && J_(n)
    }

    function qn(t) {
        return !!(t && t.__v_isRef === !0)
    }

    function Qr(t) {
        return C5(t, !1)
    }

    function sM(t) {
        return C5(t, !0)
    }

    function C5(t, e) {
        return qn(t) ? t : new iM(t, e)
    }
    class iM {
        constructor(e, n) {
            this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : xt(e), this._value = n ? e : ll(e)
        }
        get value() {
            return O5(this), this._value
        }
        set value(e) {
            const n = this.__v_isShallow || rd(e) || xc(e);
            e = n ? e : xt(e), ul(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : ll(e), A5(this))
        }
    }

    function oM(t) {
        return qn(t) ? t.value : t
    }
    const aM = {
        get: (t, e, n) => oM(Reflect.get(t, e, n)),
        set: (t, e, n, r) => {
            const s = t[e];
            return qn(s) && !qn(n) ? (s.value = n, !0) : Reflect.set(t, e, n, r)
        }
    };

    function I5(t) {
        return gc(t) ? t : new Proxy(t, aM)
    }
    class cM {
        constructor(e, n, r, s) {
            this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new Ny(e, () => {
                this._dirty || (this._dirty = !0, A5(this))
            }), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = r
        }
        get value() {
            const e = xt(this);
            return O5(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value
        }
        set value(e) {
            this._setter(e)
        }
    }

    function uM(t, e, n = !1) {
        let r, s;
        const i = lt(t);
        return i ? (r = t, s = Ts) : (r = t.get, s = t.set), new cM(r, s, i || !s, n)
    }

    function po(t, e, n, r) {
        let s;
        try {
            s = r ? t(...r) : t()
        } catch (i) {
            Rp(i, e, n)
        }
        return s
    }

    function ts(t, e, n, r) {
        if (lt(t)) {
            const i = po(t, e, n, r);
            return i && i5(i) && i.catch(a => {
                Rp(a, e, n)
            }), i
        }
        const s = [];
        for (let i = 0; i < t.length; i++) s.push(ts(t[i], e, n, r));
        return s
    }

    function Rp(t, e, n, r = !0) {
        const s = e ? e.vnode : null;
        if (e) {
            let i = e.parent;
            const a = e.proxy,
                c = n;
            for (; i;) {
                const h = i.ec;
                if (h) {
                    for (let d = 0; d < h.length; d++)
                        if (h[d](t, a, c) === !1) return
                }
                i = i.parent
            }
            const l = e.appContext.config.errorHandler;
            if (l) {
                po(l, null, 10, [t, a, c]);
                return
            }
        }
        lM(t, n, s, r)
    }

    function lM(t, e, n, r = !0) {
        console.error(t)
    }
    let hl = !1,
        e1 = !1;
    const er = [];
    let Ys = 0;
    const _c = [];
    let Ei = null,
        ra = 0;
    const k5 = Promise.resolve();
    let $y = null;

    function hM(t) {
        const e = $y || k5;
        return t ? e.then(this ? t.bind(this) : t) : e
    }

    function fM(t) {
        let e = Ys + 1,
            n = er.length;
        for (; e < n;) {
            const r = e + n >>> 1;
            fl(er[r]) < t ? e = r + 1 : n = r
        }
        return e
    }

    function Ly(t) {
        (!er.length || !er.includes(t, hl && t.allowRecurse ? Ys + 1 : Ys)) && (t.id == null ? er.push(t) : er.splice(fM(t.id), 0, t), N5())
    }

    function N5() {
        !hl && !e1 && (e1 = !0, $y = k5.then(P5))
    }

    function dM(t) {
        const e = er.indexOf(t);
        e > Ys && er.splice(e, 1)
    }

    function pM(t) {
        We(t) ? _c.push(...t) : (!Ei || !Ei.includes(t, t.allowRecurse ? ra + 1 : ra)) && _c.push(t), N5()
    }

    function zE(t, e = hl ? Ys + 1 : 0) {
        for (; e < er.length; e++) {
            const n = er[e];
            n && n.pre && (er.splice(e, 1), e--, n())
        }
    }

    function x5(t) {
        if (_c.length) {
            const e = [...new Set(_c)];
            if (_c.length = 0, Ei) {
                Ei.push(...e);
                return
            }
            for (Ei = e, Ei.sort((n, r) => fl(n) - fl(r)), ra = 0; ra < Ei.length; ra++) Ei[ra]();
            Ei = null, ra = 0
        }
    }
    const fl = t => t.id == null ? 1 / 0 : t.id,
        mM = (t, e) => {
            const n = fl(t) - fl(e);
            if (n === 0) {
                if (t.pre && !e.pre) return -1;
                if (e.pre && !t.pre) return 1
            }
            return n
        };

    function P5(t) {
        e1 = !1, hl = !0, er.sort(mM);
        const e = Ts;
        try {
            for (Ys = 0; Ys < er.length; Ys++) {
                const n = er[Ys];
                n && n.active !== !1 && po(n, null, 14)
            }
        } finally {
            Ys = 0, er.length = 0, x5(), hl = !1, $y = null, (er.length || _c.length) && P5()
        }
    }

    function gM(t, e, ...n) {
        if (t.isUnmounted) return;
        const r = t.vnode.props || Qt;
        let s = n;
        const i = e.startsWith("update:"),
            a = i && e.slice(7);
        if (a && a in r) {
            const d = `${a==="modelValue"?"model":a}Modifiers`,
                {
                    number: p,
                    trim: g
                } = r[d] || Qt;
            g && (s = n.map(v => bn(v) ? v.trim() : v)), p && (s = n.map(Y_))
        }
        let c, l = r[c = zg(e)] || r[c = zg(zs(e))];
        !l && i && (l = r[c = zg(ka(e))]), l && ts(l, t, 6, s);
        const h = r[c + "Once"];
        if (h) {
            if (!t.emitted) t.emitted = {};
            else if (t.emitted[c]) return;
            t.emitted[c] = !0, ts(h, t, 6, s)
        }
    }

    function R5(t, e, n = !1) {
        const r = e.emitsCache,
            s = r.get(t);
        if (s !== void 0) return s;
        const i = t.emits;
        let a = {},
            c = !1;
        if (!lt(t)) {
            const l = h => {
                const d = R5(h, e, !0);
                d && (c = !0, wn(a, d))
            };
            !n && e.mixins.length && e.mixins.forEach(l), t.extends && l(t.extends), t.mixins && t.mixins.forEach(l)
        }
        return !i && !c ? (Gt(t) && r.set(t, null), null) : (We(i) ? i.forEach(l => a[l] = null) : wn(a, i), Gt(t) && r.set(t, a), a)
    }

    function Mp(t, e) {
        return !t || !Cp(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), kt(t, e[0].toLowerCase() + e.slice(1)) || kt(t, ka(e)) || kt(t, e))
    }
    let Vn = null,
        Dp = null;

    function sd(t) {
        const e = Vn;
        return Vn = t, Dp = t && t.type.__scopeId || null, e
    }

    function Di(t) {
        Dp = t
    }

    function $i() {
        Dp = null
    }

    function cs(t, e = Vn, n) {
        if (!e || t._n) return t;
        const r = (...s) => {
            r._d && aS(-1);
            const i = sd(e);
            let a;
            try {
                a = t(...s)
            } finally {
                sd(i), r._d && aS(1)
            }
            return a
        };
        return r._n = !0, r._c = !0, r._d = !0, r
    }

    function Zg(t) {
        const {
            type: e,
            vnode: n,
            proxy: r,
            withProxy: s,
            props: i,
            propsOptions: [a],
            slots: c,
            attrs: l,
            emit: h,
            render: d,
            renderCache: p,
            data: g,
            setupState: v,
            ctx: b,
            inheritAttrs: T
        } = t;
        let m, w;
        const P = sd(t);
        try {
            if (n.shapeFlag & 4) {
                const M = s || r;
                m = Hs(d.call(M, M, p, i, v, g, b)), w = l
            } else {
                const M = e;
                m = Hs(M.length > 1 ? M(i, {
                    attrs: l,
                    slots: c,
                    emit: h
                }) : M(i, null)), w = e.props ? l : _M(l)
            }
        } catch (M) {
            zu.length = 0, Rp(M, t, 1), m = Qe(ns)
        }
        let V = m;
        if (w && T !== !1) {
            const M = Object.keys(w),
                {
                    shapeFlag: I
                } = V;
            M.length && I & 7 && (a && M.some(Ay) && (w = yM(w, a)), V = Eo(V, w))
        }
        return n.dirs && (V = Eo(V), V.dirs = V.dirs ? V.dirs.concat(n.dirs) : n.dirs), n.transition && (V.transition = n.transition), m = V, sd(P), m
    }
    const _M = t => {
            let e;
            for (const n in t)(n === "class" || n === "style" || Cp(n)) && ((e || (e = {}))[n] = t[n]);
            return e
        },
        yM = (t, e) => {
            const n = {};
            for (const r in t)(!Ay(r) || !(r.slice(9) in e)) && (n[r] = t[r]);
            return n
        };

    function vM(t, e, n) {
        const {
            props: r,
            children: s,
            component: i
        } = t, {
            props: a,
            children: c,
            patchFlag: l
        } = e, h = i.emitsOptions;
        if (e.dirs || e.transition) return !0;
        if (n && l >= 0) {
            if (l & 1024) return !0;
            if (l & 16) return r ? ZE(r, a, h) : !!a;
            if (l & 8) {
                const d = e.dynamicProps;
                for (let p = 0; p < d.length; p++) {
                    const g = d[p];
                    if (a[g] !== r[g] && !Mp(h, g)) return !0
                }
            }
        } else return (s || c) && (!c || !c.$stable) ? !0 : r === a ? !1 : r ? a ? ZE(r, a, h) : !0 : !!a;
        return !1
    }

    function ZE(t, e, n) {
        const r = Object.keys(e);
        if (r.length !== Object.keys(t).length) return !0;
        for (let s = 0; s < r.length; s++) {
            const i = r[s];
            if (e[i] !== t[i] && !Mp(n, i)) return !0
        }
        return !1
    }

    function bM({
        vnode: t,
        parent: e
    }, n) {
        for (; e && e.subTree === t;)(t = e.vnode).el = n, e = e.parent
    }
    const EM = t => t.__isSuspense;

    function SM(t, e) {
        e && e.pendingBranch ? We(t) ? e.effects.push(...t) : e.effects.push(t) : pM(t)
    }
    const yf = {};

    function pa(t, e, n) {
        return M5(t, e, n)
    }

    function M5(t, e, {
        immediate: n,
        deep: r,
        flush: s,
        onTrack: i,
        onTrigger: a
    } = Qt) {
        var c;
        const l = NR() === ((c = $n) == null ? void 0 : c.scope) ? $n : null;
        let h, d = !1,
            p = !1;
        if (qn(t) ? (h = () => t.value, d = rd(t)) : gc(t) ? (h = () => t, r = !0) : We(t) ? (p = !0, d = t.some(M => gc(M) || rd(M)), h = () => t.map(M => {
                if (qn(M)) return M.value;
                if (gc(M)) return la(M);
                if (lt(M)) return po(M, l, 2)
            })) : lt(t) ? e ? h = () => po(t, l, 2) : h = () => {
                if (!(l && l.isUnmounted)) return g && g(), ts(t, l, 3, [v])
            } : h = Ts, e && r) {
            const M = h;
            h = () => la(M())
        }
        let g, v = M => {
                g = P.onStop = () => {
                    po(M, l, 4)
                }
            },
            b;
        if (ml)
            if (v = Ts, e ? n && ts(e, l, 3, [h(), p ? [] : void 0, v]) : h(), s === "sync") {
                const M = mD();
                b = M.__watcherHandles || (M.__watcherHandles = [])
            } else return Ts;
        let T = p ? new Array(t.length).fill(yf) : yf;
        const m = () => {
            if (P.active)
                if (e) {
                    const M = P.run();
                    (r || d || (p ? M.some((I, L) => ul(I, T[L])) : ul(M, T))) && (g && g(), ts(e, l, 3, [M, T === yf ? void 0 : p && T[0] === yf ? [] : T, v]), T = M)
                } else P.run()
        };
        m.allowRecurse = !!e;
        let w;
        s === "sync" ? w = m : s === "post" ? w = () => Er(m, l && l.suspense) : (m.pre = !0, l && (m.id = l.uid), w = () => Ly(m));
        const P = new Ny(h, w);
        e ? n ? m() : T = P.run() : s === "post" ? Er(P.run.bind(P), l && l.suspense) : P.run();
        const V = () => {
            P.stop(), l && l.scope && Cy(l.scope.effects, P)
        };
        return b && b.push(V), V
    }

    function TM(t, e, n) {
        const r = this.proxy,
            s = bn(t) ? t.includes(".") ? D5(r, t) : () => r[t] : t.bind(r, r);
        let i;
        lt(e) ? i = e : (i = e.handler, n = e);
        const a = $n;
        Pc(this);
        const c = M5(s, i.bind(r), n);
        return a ? Pc(a) : ma(), c
    }

    function D5(t, e) {
        const n = e.split(".");
        return () => {
            let r = t;
            for (let s = 0; s < n.length && r; s++) r = r[n[s]];
            return r
        }
    }

    function la(t, e) {
        if (!Gt(t) || t.__v_skip || (e = e || new Set, e.has(t))) return t;
        if (e.add(t), qn(t)) la(t.value, e);
        else if (We(t))
            for (let n = 0; n < t.length; n++) la(t[n], e);
        else if (Ip(t) || mc(t)) t.forEach(n => {
            la(n, e)
        });
        else if (a5(t))
            for (const n in t) la(t[n], e);
        return t
    }

    function Ge(t, e) {
        const n = Vn;
        if (n === null) return t;
        const r = Bp(n) || n.proxy,
            s = t.dirs || (t.dirs = []);
        for (let i = 0; i < e.length; i++) {
            let [a, c, l, h = Qt] = e[i];
            a && (lt(a) && (a = {
                mounted: a,
                updated: a
            }), a.deep && la(c), s.push({
                dir: a,
                instance: r,
                value: c,
                oldValue: void 0,
                arg: l,
                modifiers: h
            }))
        }
        return t
    }

    function Xo(t, e, n, r) {
        const s = t.dirs,
            i = e && e.dirs;
        for (let a = 0; a < s.length; a++) {
            const c = s[a];
            i && (c.oldValue = i[a].value);
            let l = c.dir[r];
            l && (Qc(), ts(l, n, 8, [t.el, c, t, e]), Jc())
        }
    }

    function wM() {
        const t = {
            isMounted: !1,
            isLeaving: !1,
            isUnmounting: !1,
            leavingVNodes: new Map
        };
        return Fy(() => {
            t.isMounted = !0
        }), q5(() => {
            t.isUnmounting = !0
        }), t
    }
    const Zr = [Function, Array],
        $5 = {
            mode: String,
            appear: Boolean,
            persisted: Boolean,
            onBeforeEnter: Zr,
            onEnter: Zr,
            onAfterEnter: Zr,
            onEnterCancelled: Zr,
            onBeforeLeave: Zr,
            onLeave: Zr,
            onAfterLeave: Zr,
            onLeaveCancelled: Zr,
            onBeforeAppear: Zr,
            onAppear: Zr,
            onAfterAppear: Zr,
            onAppearCancelled: Zr
        },
        OM = {
            name: "BaseTransition",
            props: $5,
            setup(t, {
                slots: e
            }) {
                const n = pl(),
                    r = wM();
                let s;
                return () => {
                    const i = e.default && F5(e.default(), !0);
                    if (!i || !i.length) return;
                    let a = i[0];
                    if (i.length > 1) {
                        for (const T of i)
                            if (T.type !== ns) {
                                a = T;
                                break
                            }
                    }
                    const c = xt(t),
                        {
                            mode: l
                        } = c;
                    if (r.isLeaving) return Xg(a);
                    const h = XE(a);
                    if (!h) return Xg(a);
                    const d = t1(h, c, r, n);
                    n1(h, d);
                    const p = n.subTree,
                        g = p && XE(p);
                    let v = !1;
                    const {
                        getTransitionKey: b
                    } = h.type;
                    if (b) {
                        const T = b();
                        s === void 0 ? s = T : T !== s && (s = T, v = !0)
                    }
                    if (g && g.type !== ns && (!sa(h, g) || v)) {
                        const T = t1(g, c, r, n);
                        if (n1(g, T), l === "out-in") return r.isLeaving = !0, T.afterLeave = () => {
                            r.isLeaving = !1, n.update.active !== !1 && n.update()
                        }, Xg(a);
                        l === "in-out" && h.type !== ns && (T.delayLeave = (m, w, P) => {
                            const V = L5(r, g);
                            V[String(g.key)] = g, m._leaveCb = () => {
                                w(), m._leaveCb = void 0, delete d.delayedLeave
                            }, d.delayedLeave = P
                        })
                    }
                    return a
                }
            }
        },
        AM = OM;

    function L5(t, e) {
        const {
            leavingVNodes: n
        } = t;
        let r = n.get(e.type);
        return r || (r = Object.create(null), n.set(e.type, r)), r
    }

    function t1(t, e, n, r) {
        const {
            appear: s,
            mode: i,
            persisted: a = !1,
            onBeforeEnter: c,
            onEnter: l,
            onAfterEnter: h,
            onEnterCancelled: d,
            onBeforeLeave: p,
            onLeave: g,
            onAfterLeave: v,
            onLeaveCancelled: b,
            onBeforeAppear: T,
            onAppear: m,
            onAfterAppear: w,
            onAppearCancelled: P
        } = e, V = String(t.key), M = L5(n, t), I = (q, se) => {
            q && ts(q, r, 9, se)
        }, L = (q, se) => {
            const ce = se[1];
            I(q, se), We(q) ? q.every(ue => ue.length <= 1) && ce() : q.length <= 1 && ce()
        }, B = {
            mode: i,
            persisted: a,
            beforeEnter(q) {
                let se = c;
                if (!n.isMounted)
                    if (s) se = T || c;
                    else return;
                q._leaveCb && q._leaveCb(!0);
                const ce = M[V];
                ce && sa(t, ce) && ce.el._leaveCb && ce.el._leaveCb(), I(se, [q])
            },
            enter(q) {
                let se = l,
                    ce = h,
                    ue = d;
                if (!n.isMounted)
                    if (s) se = m || l, ce = w || h, ue = P || d;
                    else return;
                let ee = !1;
                const ge = q._enterCb = G => {
                    ee || (ee = !0, G ? I(ue, [q]) : I(ce, [q]), B.delayedLeave && B.delayedLeave(), q._enterCb = void 0)
                };
                se ? L(se, [q, ge]) : ge()
            },
            leave(q, se) {
                const ce = String(t.key);
                if (q._enterCb && q._enterCb(!0), n.isUnmounting) return se();
                I(p, [q]);
                let ue = !1;
                const ee = q._leaveCb = ge => {
                    ue || (ue = !0, se(), ge ? I(b, [q]) : I(v, [q]), q._leaveCb = void 0, M[ce] === t && delete M[ce])
                };
                M[ce] = t, g ? L(g, [q, ee]) : ee()
            },
            clone(q) {
                return t1(q, e, n, r)
            }
        };
        return B
    }

    function Xg(t) {
        if ($p(t)) return t = Eo(t), t.children = null, t
    }

    function XE(t) {
        return $p(t) ? t.children ? t.children[0] : void 0 : t
    }

    function n1(t, e) {
        t.shapeFlag & 6 && t.component ? n1(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e
    }

    function F5(t, e = !1, n) {
        let r = [],
            s = 0;
        for (let i = 0; i < t.length; i++) {
            let a = t[i];
            const c = n == null ? a.key : String(n) + String(a.key != null ? a.key : i);
            a.type === St ? (a.patchFlag & 128 && s++, r = r.concat(F5(a.children, e, c))) : (e || a.type !== ns) && r.push(c != null ? Eo(a, {
                key: c
            }) : a)
        }
        if (s > 1)
            for (let i = 0; i < r.length; i++) r[i].patchFlag = -2;
        return r
    }

    function yt(t, e) {
        return lt(t) ? (() => wn({
            name: t.name
        }, e, {
            setup: t
        }))() : t
    }
    const Ku = t => !!t.type.__asyncLoader,
        $p = t => t.type.__isKeepAlive;

    function CM(t, e) {
        U5(t, "a", e)
    }

    function IM(t, e) {
        U5(t, "da", e)
    }

    function U5(t, e, n = $n) {
        const r = t.__wdc || (t.__wdc = () => {
            let s = n;
            for (; s;) {
                if (s.isDeactivated) return;
                s = s.parent
            }
            return t()
        });
        if (Lp(e, r, n), n) {
            let s = n.parent;
            for (; s && s.parent;) $p(s.parent.vnode) && kM(r, e, n, s), s = s.parent
        }
    }

    function kM(t, e, n, r) {
        const s = Lp(e, t, r, !0);
        Uy(() => {
            Cy(r[e], s)
        }, n)
    }

    function Lp(t, e, n = $n, r = !1) {
        if (n) {
            const s = n[t] || (n[t] = []),
                i = e.__weh || (e.__weh = (...a) => {
                    if (n.isUnmounted) return;
                    Qc(), Pc(n);
                    const c = ts(e, n, t, a);
                    return ma(), Jc(), c
                });
            return r ? s.unshift(i) : s.push(i), i
        }
    }
    const Li = t => (e, n = $n) => (!ml || t === "sp") && Lp(t, (...r) => e(...r), n),
        B5 = Li("bm"),
        Fy = Li("m"),
        NM = Li("bu"),
        xM = Li("u"),
        q5 = Li("bum"),
        Uy = Li("um"),
        PM = Li("sp"),
        RM = Li("rtg"),
        MM = Li("rtc");

    function DM(t, e = $n) {
        Lp("ec", t, e)
    }
    const By = "components",
        $M = "directives";

    function ot(t, e) {
        return Vy(By, t, !0, e) || t
    }
    const V5 = Symbol.for("v-ndc");

    function qy(t) {
        return bn(t) ? Vy(By, t, !1) || t : t || V5
    }

    function fn(t) {
        return Vy($M, t)
    }

    function Vy(t, e, n = !0, r = !1) {
        const s = Vn || $n;
        if (s) {
            const i = s.type;
            if (t === By) {
                const c = fD(i, !1);
                if (c && (c === e || c === zs(e) || c === Np(zs(e)))) return i
            }
            const a = QE(s[t] || i[t], e) || QE(s.appContext[t], e);
            return !a && r ? i : a
        }
    }

    function QE(t, e) {
        return t && (t[e] || t[zs(e)] || t[Np(zs(e))])
    }

    function In(t, e, n, r) {
        let s;
        const i = n && n[r];
        if (We(t) || bn(t)) {
            s = new Array(t.length);
            for (let a = 0, c = t.length; a < c; a++) s[a] = e(t[a], a, void 0, i && i[a])
        } else if (typeof t == "number") {
            s = new Array(t);
            for (let a = 0; a < t; a++) s[a] = e(a + 1, a, void 0, i && i[a])
        } else if (Gt(t))
            if (t[Symbol.iterator]) s = Array.from(t, (a, c) => e(a, c, void 0, i && i[c]));
            else {
                const a = Object.keys(t);
                s = new Array(a.length);
                for (let c = 0, l = a.length; c < l; c++) {
                    const h = a[c];
                    s[c] = e(t[h], h, c, i && i[c])
                }
            }
        else s = [];
        return n && (n[r] = s), s
    }

    function LM(t, e, n = {}, r, s) {
        if (Vn.isCE || Vn.parent && Ku(Vn.parent) && Vn.parent.isCE) return e !== "default" && (n.name = e), Qe("slot", n, r && r());
        let i = t[e];
        i && i._c && (i._d = !1), Y();
        const a = i && j5(i(n)),
            c = Vt(St, {
                key: n.key || a && a.key || `_${e}`
            }, a || (r ? r() : []), a && t._ === 1 ? 64 : -2);
        return !s && c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), i && i._c && (i._d = !0), c
    }

    function j5(t) {
        return t.some(e => ad(e) ? !(e.type === ns || e.type === St && !j5(e.children)) : !0) ? t : null
    }
    const r1 = t => t ? t4(t) ? Bp(t) || t.proxy : r1(t.parent) : null,
        Yu = wn(Object.create(null), {
            $: t => t,
            $el: t => t.vnode.el,
            $data: t => t.data,
            $props: t => t.props,
            $attrs: t => t.attrs,
            $slots: t => t.slots,
            $refs: t => t.refs,
            $parent: t => r1(t.parent),
            $root: t => r1(t.root),
            $emit: t => t.emit,
            $options: t => jy(t),
            $forceUpdate: t => t.f || (t.f = () => Ly(t.update)),
            $nextTick: t => t.n || (t.n = hM.bind(t.proxy)),
            $watch: t => TM.bind(t)
        }),
        Qg = (t, e) => t !== Qt && !t.__isScriptSetup && kt(t, e),
        FM = {
            get({
                _: t
            }, e) {
                const {
                    ctx: n,
                    setupState: r,
                    data: s,
                    props: i,
                    accessCache: a,
                    type: c,
                    appContext: l
                } = t;
                let h;
                if (e[0] !== "$") {
                    const v = a[e];
                    if (v !== void 0) switch (v) {
                        case 1:
                            return r[e];
                        case 2:
                            return s[e];
                        case 4:
                            return n[e];
                        case 3:
                            return i[e]
                    } else {
                        if (Qg(r, e)) return a[e] = 1, r[e];
                        if (s !== Qt && kt(s, e)) return a[e] = 2, s[e];
                        if ((h = t.propsOptions[0]) && kt(h, e)) return a[e] = 3, i[e];
                        if (n !== Qt && kt(n, e)) return a[e] = 4, n[e];
                        s1 && (a[e] = 0)
                    }
                }
                const d = Yu[e];
                let p, g;
                if (d) return e === "$attrs" && Ar(t, "get", e), d(t);
                if ((p = c.__cssModules) && (p = p[e])) return p;
                if (n !== Qt && kt(n, e)) return a[e] = 4, n[e];
                if (g = l.config.globalProperties, kt(g, e)) return g[e]
            },
            set({
                _: t
            }, e, n) {
                const {
                    data: r,
                    setupState: s,
                    ctx: i
                } = t;
                return Qg(s, e) ? (s[e] = n, !0) : r !== Qt && kt(r, e) ? (r[e] = n, !0) : kt(t.props, e) || e[0] === "$" && e.slice(1) in t ? !1 : (i[e] = n, !0)
            },
            has({
                _: {
                    data: t,
                    setupState: e,
                    accessCache: n,
                    ctx: r,
                    appContext: s,
                    propsOptions: i
                }
            }, a) {
                let c;
                return !!n[a] || t !== Qt && kt(t, a) || Qg(e, a) || (c = i[0]) && kt(c, a) || kt(r, a) || kt(Yu, a) || kt(s.config.globalProperties, a)
            },
            defineProperty(t, e, n) {
                return n.get != null ? t._.accessCache[e] = 0 : kt(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n)
            }
        };

    function JE(t) {
        return We(t) ? t.reduce((e, n) => (e[n] = null, e), {}) : t
    }
    let s1 = !0;

    function UM(t) {
        const e = jy(t),
            n = t.proxy,
            r = t.ctx;
        s1 = !1, e.beforeCreate && eS(e.beforeCreate, t, "bc");
        const {
            data: s,
            computed: i,
            methods: a,
            watch: c,
            provide: l,
            inject: h,
            created: d,
            beforeMount: p,
            mounted: g,
            beforeUpdate: v,
            updated: b,
            activated: T,
            deactivated: m,
            beforeDestroy: w,
            beforeUnmount: P,
            destroyed: V,
            unmounted: M,
            render: I,
            renderTracked: L,
            renderTriggered: B,
            errorCaptured: q,
            serverPrefetch: se,
            expose: ce,
            inheritAttrs: ue,
            components: ee,
            directives: ge,
            filters: G
        } = e;
        if (h && BM(h, r, null), a)
            for (const me in a) {
                const Te = a[me];
                lt(Te) && (r[me] = Te.bind(n))
            }
        if (s) {
            const me = s.call(n, n);
            Gt(me) && (t.data = Nc(me))
        }
        if (s1 = !0, i)
            for (const me in i) {
                const Te = i[me],
                    we = lt(Te) ? Te.bind(n, n) : lt(Te.get) ? Te.get.bind(n, n) : Ts,
                    ke = !lt(Te) && lt(Te.set) ? Te.set.bind(n) : Ts,
                    Ie = Lr({
                        get: we,
                        set: ke
                    });
                Object.defineProperty(r, me, {
                    enumerable: !0,
                    configurable: !0,
                    get: () => Ie.value,
                    set: $e => Ie.value = $e
                })
            }
        if (c)
            for (const me in c) G5(c[me], r, n, me);
        if (l) {
            const me = lt(l) ? l.call(n) : l;
            Reflect.ownKeys(me).forEach(Te => {
                HM(Te, me[Te])
            })
        }
        d && eS(d, t, "c");

        function fe(me, Te) {
            We(Te) ? Te.forEach(we => me(we.bind(n))) : Te && me(Te.bind(n))
        }
        if (fe(B5, p), fe(Fy, g), fe(NM, v), fe(xM, b), fe(CM, T), fe(IM, m), fe(DM, q), fe(MM, L), fe(RM, B), fe(q5, P), fe(Uy, M), fe(PM, se), We(ce))
            if (ce.length) {
                const me = t.exposed || (t.exposed = {});
                ce.forEach(Te => {
                    Object.defineProperty(me, Te, {
                        get: () => n[Te],
                        set: we => n[Te] = we
                    })
                })
            } else t.exposed || (t.exposed = {});
        I && t.render === Ts && (t.render = I), ue != null && (t.inheritAttrs = ue), ee && (t.components = ee), ge && (t.directives = ge)
    }

    function BM(t, e, n = Ts) {
        We(t) && (t = i1(t));
        for (const r in t) {
            const s = t[r];
            let i;
            Gt(s) ? "default" in s ? i = mo(s.from || r, s.default, !0) : i = mo(s.from || r) : i = mo(s), qn(i) ? Object.defineProperty(e, r, {
                enumerable: !0,
                configurable: !0,
                get: () => i.value,
                set: a => i.value = a
            }) : e[r] = i
        }
    }

    function eS(t, e, n) {
        ts(We(t) ? t.map(r => r.bind(e.proxy)) : t.bind(e.proxy), e, n)
    }

    function G5(t, e, n, r) {
        const s = r.includes(".") ? D5(n, r) : () => n[r];
        if (bn(t)) {
            const i = e[t];
            lt(i) && pa(s, i)
        } else if (lt(t)) pa(s, t.bind(n));
        else if (Gt(t))
            if (We(t)) t.forEach(i => G5(i, e, n, r));
            else {
                const i = lt(t.handler) ? t.handler.bind(n) : e[t.handler];
                lt(i) && pa(s, i, t)
            }
    }

    function jy(t) {
        const e = t.type,
            {
                mixins: n,
                extends: r
            } = e,
            {
                mixins: s,
                optionsCache: i,
                config: {
                    optionMergeStrategies: a
                }
            } = t.appContext,
            c = i.get(e);
        let l;
        return c ? l = c : !s.length && !n && !r ? l = e : (l = {}, s.length && s.forEach(h => id(l, h, a, !0)), id(l, e, a)), Gt(e) && i.set(e, l), l
    }

    function id(t, e, n, r = !1) {
        const {
            mixins: s,
            extends: i
        } = e;
        i && id(t, i, n, !0), s && s.forEach(a => id(t, a, n, !0));
        for (const a in e)
            if (!(r && a === "expose")) {
                const c = qM[a] || n && n[a];
                t[a] = c ? c(t[a], e[a]) : e[a]
            } return t
    }
    const qM = {
        data: tS,
        props: nS,
        emits: nS,
        methods: Gu,
        computed: Gu,
        beforeCreate: ur,
        created: ur,
        beforeMount: ur,
        mounted: ur,
        beforeUpdate: ur,
        updated: ur,
        beforeDestroy: ur,
        beforeUnmount: ur,
        destroyed: ur,
        unmounted: ur,
        activated: ur,
        deactivated: ur,
        errorCaptured: ur,
        serverPrefetch: ur,
        components: Gu,
        directives: Gu,
        watch: jM,
        provide: tS,
        inject: VM
    };

    function tS(t, e) {
        return e ? t ? function() {
            return wn(lt(t) ? t.call(this, this) : t, lt(e) ? e.call(this, this) : e)
        } : e : t
    }

    function VM(t, e) {
        return Gu(i1(t), i1(e))
    }

    function i1(t) {
        if (We(t)) {
            const e = {};
            for (let n = 0; n < t.length; n++) e[t[n]] = t[n];
            return e
        }
        return t
    }

    function ur(t, e) {
        return t ? [...new Set([].concat(t, e))] : e
    }

    function Gu(t, e) {
        return t ? wn(Object.create(null), t, e) : e
    }

    function nS(t, e) {
        return t ? We(t) && We(e) ? [...new Set([...t, ...e])] : wn(Object.create(null), JE(t), JE(e ?? {})) : e
    }

    function jM(t, e) {
        if (!t) return e;
        if (!e) return t;
        const n = wn(Object.create(null), t);
        for (const r in e) n[r] = ur(t[r], e[r]);
        return n
    }

    function W5() {
        return {
            app: null,
            config: {
                isNativeTag: pR,
                performance: !1,
                globalProperties: {},
                optionMergeStrategies: {},
                errorHandler: void 0,
                warnHandler: void 0,
                compilerOptions: {}
            },
            mixins: [],
            components: {},
            directives: {},
            provides: Object.create(null),
            optionsCache: new WeakMap,
            propsCache: new WeakMap,
            emitsCache: new WeakMap
        }
    }
    let GM = 0;

    function WM(t, e) {
        return function(r, s = null) {
            lt(r) || (r = wn({}, r)), s != null && !Gt(s) && (s = null);
            const i = W5(),
                a = new Set;
            let c = !1;
            const l = i.app = {
                _uid: GM++,
                _component: r,
                _props: s,
                _container: null,
                _context: i,
                _instance: null,
                version: gD,
                get config() {
                    return i.config
                },
                set config(h) {},
                use(h, ...d) {
                    return a.has(h) || (h && lt(h.install) ? (a.add(h), h.install(l, ...d)) : lt(h) && (a.add(h), h(l, ...d))), l
                },
                mixin(h) {
                    return i.mixins.includes(h) || i.mixins.push(h), l
                },
                component(h, d) {
                    return d ? (i.components[h] = d, l) : i.components[h]
                },
                directive(h, d) {
                    return d ? (i.directives[h] = d, l) : i.directives[h]
                },
                mount(h, d, p) {
                    if (!c) {
                        const g = Qe(r, s);
                        return g.appContext = i, d && e ? e(g, h) : t(g, h, p), c = !0, l._container = h, h.__vue_app__ = l, Bp(g.component) || g.component.proxy
                    }
                },
                unmount() {
                    c && (t(null, l._container), delete l._container.__vue_app__)
                },
                provide(h, d) {
                    return i.provides[h] = d, l
                },
                runWithContext(h) {
                    od = l;
                    try {
                        return h()
                    } finally {
                        od = null
                    }
                }
            };
            return l
        }
    }
    let od = null;

    function HM(t, e) {
        if ($n) {
            let n = $n.provides;
            const r = $n.parent && $n.parent.provides;
            r === n && (n = $n.provides = Object.create(r)), n[t] = e
        }
    }

    function mo(t, e, n = !1) {
        const r = $n || Vn;
        if (r || od) {
            const s = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : od._context.provides;
            if (s && t in s) return s[t];
            if (arguments.length > 1) return n && lt(e) ? e.call(r && r.proxy) : e
        }
    }

    function KM(t, e, n, r = !1) {
        const s = {},
            i = {};
        nd(i, Fp, 1), t.propsDefaults = Object.create(null), H5(t, e, s, i);
        for (const a in t.propsOptions[0]) a in s || (s[a] = void 0);
        n ? t.props = r ? s : rM(s) : t.type.props ? t.props = s : t.props = i, t.attrs = i
    }

    function YM(t, e, n, r) {
        const {
            props: s,
            attrs: i,
            vnode: {
                patchFlag: a
            }
        } = t, c = xt(s), [l] = t.propsOptions;
        let h = !1;
        if ((r || a > 0) && !(a & 16)) {
            if (a & 8) {
                const d = t.vnode.dynamicProps;
                for (let p = 0; p < d.length; p++) {
                    let g = d[p];
                    if (Mp(t.emitsOptions, g)) continue;
                    const v = e[g];
                    if (l)
                        if (kt(i, g)) v !== i[g] && (i[g] = v, h = !0);
                        else {
                            const b = zs(g);
                            s[b] = o1(l, c, b, v, t, !1)
                        }
                    else v !== i[g] && (i[g] = v, h = !0)
                }
            }
        } else {
            H5(t, e, s, i) && (h = !0);
            let d;
            for (const p in c)(!e || !kt(e, p) && ((d = ka(p)) === p || !kt(e, d))) && (l ? n && (n[p] !== void 0 || n[d] !== void 0) && (s[p] = o1(l, c, p, void 0, t, !0)) : delete s[p]);
            if (i !== c)
                for (const p in i)(!e || !kt(e, p)) && (delete i[p], h = !0)
        }
        h && Ni(t, "set", "$attrs")
    }

    function H5(t, e, n, r) {
        const [s, i] = t.propsOptions;
        let a = !1,
            c;
        if (e)
            for (let l in e) {
                if (jf(l)) continue;
                const h = e[l];
                let d;
                s && kt(s, d = zs(l)) ? !i || !i.includes(d) ? n[d] = h : (c || (c = {}))[d] = h : Mp(t.emitsOptions, l) || (!(l in r) || h !== r[l]) && (r[l] = h, a = !0)
            }
        if (i) {
            const l = xt(n),
                h = c || Qt;
            for (let d = 0; d < i.length; d++) {
                const p = i[d];
                n[p] = o1(s, l, p, h[p], t, !kt(h, p))
            }
        }
        return a
    }

    function o1(t, e, n, r, s, i) {
        const a = t[n];
        if (a != null) {
            const c = kt(a, "default");
            if (c && r === void 0) {
                const l = a.default;
                if (a.type !== Function && !a.skipFactory && lt(l)) {
                    const {
                        propsDefaults: h
                    } = s;
                    n in h ? r = h[n] : (Pc(s), r = h[n] = l.call(null, e), ma())
                } else r = l
            }
            a[0] && (i && !c ? r = !1 : a[1] && (r === "" || r === ka(n)) && (r = !0))
        }
        return r
    }

    function K5(t, e, n = !1) {
        const r = e.propsCache,
            s = r.get(t);
        if (s) return s;
        const i = t.props,
            a = {},
            c = [];
        let l = !1;
        if (!lt(t)) {
            const d = p => {
                l = !0;
                const [g, v] = K5(p, e, !0);
                wn(a, g), v && c.push(...v)
            };
            !n && e.mixins.length && e.mixins.forEach(d), t.extends && d(t.extends), t.mixins && t.mixins.forEach(d)
        }
        if (!i && !l) return Gt(t) && r.set(t, pc), pc;
        if (We(i))
            for (let d = 0; d < i.length; d++) {
                const p = zs(i[d]);
                rS(p) && (a[p] = Qt)
            } else if (i)
                for (const d in i) {
                    const p = zs(d);
                    if (rS(p)) {
                        const g = i[d],
                            v = a[p] = We(g) || lt(g) ? {
                                type: g
                            } : wn({}, g);
                        if (v) {
                            const b = oS(Boolean, v.type),
                                T = oS(String, v.type);
                            v[0] = b > -1, v[1] = T < 0 || b < T, (b > -1 || kt(v, "default")) && c.push(p)
                        }
                    }
                }
        const h = [a, c];
        return Gt(t) && r.set(t, h), h
    }

    function rS(t) {
        return t[0] !== "$"
    }

    function sS(t) {
        const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
        return e ? e[2] : t === null ? "null" : ""
    }

    function iS(t, e) {
        return sS(t) === sS(e)
    }

    function oS(t, e) {
        return We(e) ? e.findIndex(n => iS(n, t)) : lt(e) && iS(e, t) ? 0 : -1
    }
    const Y5 = t => t[0] === "_" || t === "$stable",
        Gy = t => We(t) ? t.map(Hs) : [Hs(t)],
        zM = (t, e, n) => {
            if (e._n) return e;
            const r = cs((...s) => Gy(e(...s)), n);
            return r._c = !1, r
        },
        z5 = (t, e, n) => {
            const r = t._ctx;
            for (const s in t) {
                if (Y5(s)) continue;
                const i = t[s];
                if (lt(i)) e[s] = zM(s, i, r);
                else if (i != null) {
                    const a = Gy(i);
                    e[s] = () => a
                }
            }
        },
        Z5 = (t, e) => {
            const n = Gy(e);
            t.slots.default = () => n
        },
        ZM = (t, e) => {
            if (t.vnode.shapeFlag & 32) {
                const n = e._;
                n ? (t.slots = xt(e), nd(e, "_", n)) : z5(e, t.slots = {})
            } else t.slots = {}, e && Z5(t, e);
            nd(t.slots, Fp, 1)
        },
        XM = (t, e, n) => {
            const {
                vnode: r,
                slots: s
            } = t;
            let i = !0,
                a = Qt;
            if (r.shapeFlag & 32) {
                const c = e._;
                c ? n && c === 1 ? i = !1 : (wn(s, e), !n && c === 1 && delete s._) : (i = !e.$stable, z5(e, s)), a = e
            } else e && (Z5(t, e), a = {
                default: 1
            });
            if (i)
                for (const c in s) !Y5(c) && !(c in a) && delete s[c]
        };

    function a1(t, e, n, r, s = !1) {
        if (We(t)) {
            t.forEach((g, v) => a1(g, e && (We(e) ? e[v] : e), n, r, s));
            return
        }
        if (Ku(r) && !s) return;
        const i = r.shapeFlag & 4 ? Bp(r.component) || r.component.proxy : r.el,
            a = s ? null : i,
            {
                i: c,
                r: l
            } = t,
            h = e && e.r,
            d = c.refs === Qt ? c.refs = {} : c.refs,
            p = c.setupState;
        if (h != null && h !== l && (bn(h) ? (d[h] = null, kt(p, h) && (p[h] = null)) : qn(h) && (h.value = null)), lt(l)) po(l, c, 12, [a, d]);
        else {
            const g = bn(l),
                v = qn(l);
            if (g || v) {
                const b = () => {
                    if (t.f) {
                        const T = g ? kt(p, l) ? p[l] : d[l] : l.value;
                        s ? We(T) && Cy(T, i) : We(T) ? T.includes(i) || T.push(i) : g ? (d[l] = [i], kt(p, l) && (p[l] = d[l])) : (l.value = [i], t.k && (d[t.k] = l.value))
                    } else g ? (d[l] = a, kt(p, l) && (p[l] = a)) : v && (l.value = a, t.k && (d[t.k] = a))
                };
                a ? (b.id = -1, Er(b, n)) : b()
            }
        }
    }
    const Er = SM;

    function QM(t) {
        return JM(t)
    }

    function JM(t, e) {
        const n = z_();
        n.__VUE__ = !0;
        const {
            insert: r,
            remove: s,
            patchProp: i,
            createElement: a,
            createText: c,
            createComment: l,
            setText: h,
            setElementText: d,
            parentNode: p,
            nextSibling: g,
            setScopeId: v = Ts,
            insertStaticContent: b
        } = t, T = (A, y, E, C = null, D = null, Z = null, oe = !1, pe = null, _e = !!y.dynamicChildren) => {
            if (A === y) return;
            A && !sa(A, y) && (C = tt(A), $e(A, D, Z, !0), A = null), y.patchFlag === -2 && (_e = !1, y.dynamicChildren = null);
            const {
                type: he,
                ref: re,
                shapeFlag: ae
            } = y;
            switch (he) {
                case Kl:
                    m(A, y, E, C);
                    break;
                case ns:
                    w(A, y, E, C);
                    break;
                case Wf:
                    A == null && P(y, E, C, oe);
                    break;
                case St:
                    ee(A, y, E, C, D, Z, oe, pe, _e);
                    break;
                default:
                    ae & 1 ? I(A, y, E, C, D, Z, oe, pe, _e) : ae & 6 ? ge(A, y, E, C, D, Z, oe, pe, _e) : (ae & 64 || ae & 128) && he.process(A, y, E, C, D, Z, oe, pe, _e, k)
            }
            re != null && D && a1(re, A && A.ref, Z, y || A, !y)
        }, m = (A, y, E, C) => {
            if (A == null) r(y.el = c(y.children), E, C);
            else {
                const D = y.el = A.el;
                y.children !== A.children && h(D, y.children)
            }
        }, w = (A, y, E, C) => {
            A == null ? r(y.el = l(y.children || ""), E, C) : y.el = A.el
        }, P = (A, y, E, C) => {
            [A.el, A.anchor] = b(A.children, y, E, C, A.el, A.anchor)
        }, V = ({
            el: A,
            anchor: y
        }, E, C) => {
            let D;
            for (; A && A !== y;) D = g(A), r(A, E, C), A = D;
            r(y, E, C)
        }, M = ({
            el: A,
            anchor: y
        }) => {
            let E;
            for (; A && A !== y;) E = g(A), s(A), A = E;
            s(y)
        }, I = (A, y, E, C, D, Z, oe, pe, _e) => {
            oe = oe || y.type === "svg", A == null ? L(y, E, C, D, Z, oe, pe, _e) : se(A, y, D, Z, oe, pe, _e)
        }, L = (A, y, E, C, D, Z, oe, pe) => {
            let _e, he;
            const {
                type: re,
                props: ae,
                shapeFlag: Re,
                transition: De,
                dirs: Je
            } = A;
            if (_e = A.el = a(A.type, Z, ae && ae.is, ae), Re & 8 ? d(_e, A.children) : Re & 16 && q(A.children, _e, null, C, D, Z && re !== "foreignObject", oe, pe), Je && Xo(A, null, C, "created"), B(_e, A, A.scopeId, oe, C), ae) {
                for (const U in ae) U !== "value" && !jf(U) && i(_e, U, null, ae[U], Z, A.children, C, D, Xe);
                "value" in ae && i(_e, "value", null, ae.value), (he = ae.onVnodeBeforeMount) && qs(he, C, A)
            }
            Je && Xo(A, null, C, "beforeMount");
            const dt = (!D || D && !D.pendingBranch) && De && !De.persisted;
            dt && De.beforeEnter(_e), r(_e, y, E), ((he = ae && ae.onVnodeMounted) || dt || Je) && Er(() => {
                he && qs(he, C, A), dt && De.enter(_e), Je && Xo(A, null, C, "mounted")
            }, D)
        }, B = (A, y, E, C, D) => {
            if (E && v(A, E), C)
                for (let Z = 0; Z < C.length; Z++) v(A, C[Z]);
            if (D) {
                let Z = D.subTree;
                if (y === Z) {
                    const oe = D.vnode;
                    B(A, oe, oe.scopeId, oe.slotScopeIds, D.parent)
                }
            }
        }, q = (A, y, E, C, D, Z, oe, pe, _e = 0) => {
            for (let he = _e; he < A.length; he++) {
                const re = A[he] = pe ? so(A[he]) : Hs(A[he]);
                T(null, re, y, E, C, D, Z, oe, pe)
            }
        }, se = (A, y, E, C, D, Z, oe) => {
            const pe = y.el = A.el;
            let {
                patchFlag: _e,
                dynamicChildren: he,
                dirs: re
            } = y;
            _e |= A.patchFlag & 16;
            const ae = A.props || Qt,
                Re = y.props || Qt;
            let De;
            E && Qo(E, !1), (De = Re.onVnodeBeforeUpdate) && qs(De, E, y, A), re && Xo(y, A, E, "beforeUpdate"), E && Qo(E, !0);
            const Je = D && y.type !== "foreignObject";
            if (he ? ce(A.dynamicChildren, he, pe, E, C, Je, Z) : oe || Te(A, y, pe, null, E, C, Je, Z, !1), _e > 0) {
                if (_e & 16) ue(pe, y, ae, Re, E, C, D);
                else if (_e & 2 && ae.class !== Re.class && i(pe, "class", null, Re.class, D), _e & 4 && i(pe, "style", ae.style, Re.style, D), _e & 8) {
                    const dt = y.dynamicProps;
                    for (let U = 0; U < dt.length; U++) {
                        const $ = dt[U],
                            te = ae[$],
                            F = Re[$];
                        (F !== te || $ === "value") && i(pe, $, te, F, D, A.children, E, C, Xe)
                    }
                }
                _e & 1 && A.children !== y.children && d(pe, y.children)
            } else !oe && he == null && ue(pe, y, ae, Re, E, C, D);
            ((De = Re.onVnodeUpdated) || re) && Er(() => {
                De && qs(De, E, y, A), re && Xo(y, A, E, "updated")
            }, C)
        }, ce = (A, y, E, C, D, Z, oe) => {
            for (let pe = 0; pe < y.length; pe++) {
                const _e = A[pe],
                    he = y[pe],
                    re = _e.el && (_e.type === St || !sa(_e, he) || _e.shapeFlag & 70) ? p(_e.el) : E;
                T(_e, he, re, null, C, D, Z, oe, !0)
            }
        }, ue = (A, y, E, C, D, Z, oe) => {
            if (E !== C) {
                if (E !== Qt)
                    for (const pe in E) !jf(pe) && !(pe in C) && i(A, pe, E[pe], null, oe, y.children, D, Z, Xe);
                for (const pe in C) {
                    if (jf(pe)) continue;
                    const _e = C[pe],
                        he = E[pe];
                    _e !== he && pe !== "value" && i(A, pe, he, _e, oe, y.children, D, Z, Xe)
                }
                "value" in C && i(A, "value", E.value, C.value)
            }
        }, ee = (A, y, E, C, D, Z, oe, pe, _e) => {
            const he = y.el = A ? A.el : c(""),
                re = y.anchor = A ? A.anchor : c("");
            let {
                patchFlag: ae,
                dynamicChildren: Re,
                slotScopeIds: De
            } = y;
            De && (pe = pe ? pe.concat(De) : De), A == null ? (r(he, E, C), r(re, E, C), q(y.children, E, re, D, Z, oe, pe, _e)) : ae > 0 && ae & 64 && Re && A.dynamicChildren ? (ce(A.dynamicChildren, Re, E, D, Z, oe, pe), (y.key != null || D && y === D.subTree) && X5(A, y, !0)) : Te(A, y, E, re, D, Z, oe, pe, _e)
        }, ge = (A, y, E, C, D, Z, oe, pe, _e) => {
            y.slotScopeIds = pe, A == null ? y.shapeFlag & 512 ? D.ctx.activate(y, E, C, oe, _e) : G(y, E, C, D, Z, oe, _e) : le(A, y, _e)
        }, G = (A, y, E, C, D, Z, oe) => {
            const pe = A.component = aD(A, C, D);
            if ($p(A) && (pe.ctx.renderer = k), cD(pe), pe.asyncDep) {
                if (D && D.registerDep(pe, fe), !A.el) {
                    const _e = pe.subTree = Qe(ns);
                    w(null, _e, y, E)
                }
                return
            }
            fe(pe, A, y, E, D, Z, oe)
        }, le = (A, y, E) => {
            const C = y.component = A.component;
            if (vM(A, y, E))
                if (C.asyncDep && !C.asyncResolved) {
                    me(C, y, E);
                    return
                } else C.next = y, dM(C.update), C.update();
            else y.el = A.el, C.vnode = y
        }, fe = (A, y, E, C, D, Z, oe) => {
            const pe = () => {
                    if (A.isMounted) {
                        let {
                            next: re,
                            bu: ae,
                            u: Re,
                            parent: De,
                            vnode: Je
                        } = A, dt = re, U;
                        Qo(A, !1), re ? (re.el = Je.el, me(A, re, oe)) : re = Je, ae && Gf(ae), (U = re.props && re.props.onVnodeBeforeUpdate) && qs(U, De, re, Je), Qo(A, !0);
                        const $ = Zg(A),
                            te = A.subTree;
                        A.subTree = $, T(te, $, p(te.el), tt(te), A, D, Z), re.el = $.el, dt === null && bM(A, $.el), Re && Er(Re, D), (U = re.props && re.props.onVnodeUpdated) && Er(() => qs(U, De, re, Je), D)
                    } else {
                        let re;
                        const {
                            el: ae,
                            props: Re
                        } = y, {
                            bm: De,
                            m: Je,
                            parent: dt
                        } = A, U = Ku(y);
                        if (Qo(A, !1), De && Gf(De), !U && (re = Re && Re.onVnodeBeforeMount) && qs(re, dt, y), Qo(A, !0), ae && K) {
                            const $ = () => {
                                A.subTree = Zg(A), K(ae, A.subTree, A, D, null)
                            };
                            U ? y.type.__asyncLoader().then(() => !A.isUnmounted && $()) : $()
                        } else {
                            const $ = A.subTree = Zg(A);
                            T(null, $, E, C, A, D, Z), y.el = $.el
                        }
                        if (Je && Er(Je, D), !U && (re = Re && Re.onVnodeMounted)) {
                            const $ = y;
                            Er(() => qs(re, dt, $), D)
                        }(y.shapeFlag & 256 || dt && Ku(dt.vnode) && dt.vnode.shapeFlag & 256) && A.a && Er(A.a, D), A.isMounted = !0, y = E = C = null
                    }
                },
                _e = A.effect = new Ny(pe, () => Ly(he), A.scope),
                he = A.update = () => _e.run();
            he.id = A.uid, Qo(A, !0), he()
        }, me = (A, y, E) => {
            y.component = A;
            const C = A.vnode.props;
            A.vnode = y, A.next = null, YM(A, y.props, C, E), XM(A, y.children, E), Qc(), zE(), Jc()
        }, Te = (A, y, E, C, D, Z, oe, pe, _e = !1) => {
            const he = A && A.children,
                re = A ? A.shapeFlag : 0,
                ae = y.children,
                {
                    patchFlag: Re,
                    shapeFlag: De
                } = y;
            if (Re > 0) {
                if (Re & 128) {
                    ke(he, ae, E, C, D, Z, oe, pe, _e);
                    return
                } else if (Re & 256) {
                    we(he, ae, E, C, D, Z, oe, pe, _e);
                    return
                }
            }
            De & 8 ? (re & 16 && Xe(he, D, Z), ae !== he && d(E, ae)) : re & 16 ? De & 16 ? ke(he, ae, E, C, D, Z, oe, pe, _e) : Xe(he, D, Z, !0) : (re & 8 && d(E, ""), De & 16 && q(ae, E, C, D, Z, oe, pe, _e))
        }, we = (A, y, E, C, D, Z, oe, pe, _e) => {
            A = A || pc, y = y || pc;
            const he = A.length,
                re = y.length,
                ae = Math.min(he, re);
            let Re;
            for (Re = 0; Re < ae; Re++) {
                const De = y[Re] = _e ? so(y[Re]) : Hs(y[Re]);
                T(A[Re], De, E, null, D, Z, oe, pe, _e)
            }
            he > re ? Xe(A, D, Z, !0, !1, ae) : q(y, E, C, D, Z, oe, pe, _e, ae)
        }, ke = (A, y, E, C, D, Z, oe, pe, _e) => {
            let he = 0;
            const re = y.length;
            let ae = A.length - 1,
                Re = re - 1;
            for (; he <= ae && he <= Re;) {
                const De = A[he],
                    Je = y[he] = _e ? so(y[he]) : Hs(y[he]);
                if (sa(De, Je)) T(De, Je, E, null, D, Z, oe, pe, _e);
                else break;
                he++
            }
            for (; he <= ae && he <= Re;) {
                const De = A[ae],
                    Je = y[Re] = _e ? so(y[Re]) : Hs(y[Re]);
                if (sa(De, Je)) T(De, Je, E, null, D, Z, oe, pe, _e);
                else break;
                ae--, Re--
            }
            if (he > ae) {
                if (he <= Re) {
                    const De = Re + 1,
                        Je = De < re ? y[De].el : C;
                    for (; he <= Re;) T(null, y[he] = _e ? so(y[he]) : Hs(y[he]), E, Je, D, Z, oe, pe, _e), he++
                }
            } else if (he > Re)
                for (; he <= ae;) $e(A[he], D, Z, !0), he++;
            else {
                const De = he,
                    Je = he,
                    dt = new Map;
                for (he = Je; he <= Re; he++) {
                    const xe = y[he] = _e ? so(y[he]) : Hs(y[he]);
                    xe.key != null && dt.set(xe.key, he)
                }
                let U, $ = 0;
                const te = Re - Je + 1;
                let F = !1,
                    Q = 0;
                const ve = new Array(te);
                for (he = 0; he < te; he++) ve[he] = 0;
                for (he = De; he <= ae; he++) {
                    const xe = A[he];
                    if ($ >= te) {
                        $e(xe, D, Z, !0);
                        continue
                    }
                    let Fe;
                    if (xe.key != null) Fe = dt.get(xe.key);
                    else
                        for (U = Je; U <= Re; U++)
                            if (ve[U - Je] === 0 && sa(xe, y[U])) {
                                Fe = U;
                                break
                            } Fe === void 0 ? $e(xe, D, Z, !0) : (ve[Fe - Je] = he + 1, Fe >= Q ? Q = Fe : F = !0, T(xe, y[Fe], E, null, D, Z, oe, pe, _e), $++)
                }
                const Oe = F ? eD(ve) : pc;
                for (U = Oe.length - 1, he = te - 1; he >= 0; he--) {
                    const xe = Je + he,
                        Fe = y[xe],
                        dn = xe + 1 < re ? y[xe + 1].el : C;
                    ve[he] === 0 ? T(null, Fe, E, dn, D, Z, oe, pe, _e) : F && (U < 0 || he !== Oe[U] ? Ie(Fe, E, dn, 2) : U--)
                }
            }
        }, Ie = (A, y, E, C, D = null) => {
            const {
                el: Z,
                type: oe,
                transition: pe,
                children: _e,
                shapeFlag: he
            } = A;
            if (he & 6) {
                Ie(A.component.subTree, y, E, C);
                return
            }
            if (he & 128) {
                A.suspense.move(y, E, C);
                return
            }
            if (he & 64) {
                oe.move(A, y, E, k);
                return
            }
            if (oe === St) {
                r(Z, y, E);
                for (let ae = 0; ae < _e.length; ae++) Ie(_e[ae], y, E, C);
                r(A.anchor, y, E);
                return
            }
            if (oe === Wf) {
                V(A, y, E);
                return
            }
            if (C !== 2 && he & 1 && pe)
                if (C === 0) pe.beforeEnter(Z), r(Z, y, E), Er(() => pe.enter(Z), D);
                else {
                    const {
                        leave: ae,
                        delayLeave: Re,
                        afterLeave: De
                    } = pe, Je = () => r(Z, y, E), dt = () => {
                        ae(Z, () => {
                            Je(), De && De()
                        })
                    };
                    Re ? Re(Z, Je, dt) : dt()
                }
            else r(Z, y, E)
        }, $e = (A, y, E, C = !1, D = !1) => {
            const {
                type: Z,
                props: oe,
                ref: pe,
                children: _e,
                dynamicChildren: he,
                shapeFlag: re,
                patchFlag: ae,
                dirs: Re
            } = A;
            if (pe != null && a1(pe, null, E, A, !0), re & 256) {
                y.ctx.deactivate(A);
                return
            }
            const De = re & 1 && Re,
                Je = !Ku(A);
            let dt;
            if (Je && (dt = oe && oe.onVnodeBeforeUnmount) && qs(dt, y, A), re & 6) qe(A.component, E, C);
            else {
                if (re & 128) {
                    A.suspense.unmount(E, C);
                    return
                }
                De && Xo(A, null, y, "beforeUnmount"), re & 64 ? A.type.remove(A, y, E, D, k, C) : he && (Z !== St || ae > 0 && ae & 64) ? Xe(he, y, E, !1, !0) : (Z === St && ae & 384 || !D && re & 16) && Xe(_e, y, E), C && At(A)
            }(Je && (dt = oe && oe.onVnodeUnmounted) || De) && Er(() => {
                dt && qs(dt, y, A), De && Xo(A, null, y, "unmounted")
            }, E)
        }, At = A => {
            const {
                type: y,
                el: E,
                anchor: C,
                transition: D
            } = A;
            if (y === St) {
                $t(E, C);
                return
            }
            if (y === Wf) {
                M(A);
                return
            }
            const Z = () => {
                s(E), D && !D.persisted && D.afterLeave && D.afterLeave()
            };
            if (A.shapeFlag & 1 && D && !D.persisted) {
                const {
                    leave: oe,
                    delayLeave: pe
                } = D, _e = () => oe(E, Z);
                pe ? pe(A.el, Z, _e) : _e()
            } else Z()
        }, $t = (A, y) => {
            let E;
            for (; A !== y;) E = g(A), s(A), A = E;
            s(y)
        }, qe = (A, y, E) => {
            const {
                bum: C,
                scope: D,
                update: Z,
                subTree: oe,
                um: pe
            } = A;
            C && Gf(C), D.stop(), Z && (Z.active = !1, $e(oe, A, y, E)), pe && Er(pe, y), Er(() => {
                A.isUnmounted = !0
            }, y), y && y.pendingBranch && !y.isUnmounted && A.asyncDep && !A.asyncResolved && A.suspenseId === y.pendingId && (y.deps--, y.deps === 0 && y.resolve())
        }, Xe = (A, y, E, C = !1, D = !1, Z = 0) => {
            for (let oe = Z; oe < A.length; oe++) $e(A[oe], y, E, C, D)
        }, tt = A => A.shapeFlag & 6 ? tt(A.component.subTree) : A.shapeFlag & 128 ? A.suspense.next() : g(A.anchor || A.el), S = (A, y, E) => {
            A == null ? y._vnode && $e(y._vnode, null, null, !0) : T(y._vnode || null, A, y, null, null, null, E), zE(), x5(), y._vnode = A
        }, k = {
            p: T,
            um: $e,
            m: Ie,
            r: At,
            mt: G,
            mc: q,
            pc: Te,
            pbc: ce,
            n: tt,
            o: t
        };
        let H, K;
        return e && ([H, K] = e(k)), {
            render: S,
            hydrate: H,
            createApp: WM(S, H)
        }
    }

    function Qo({
        effect: t,
        update: e
    }, n) {
        t.allowRecurse = e.allowRecurse = n
    }

    function X5(t, e, n = !1) {
        const r = t.children,
            s = e.children;
        if (We(r) && We(s))
            for (let i = 0; i < r.length; i++) {
                const a = r[i];
                let c = s[i];
                c.shapeFlag & 1 && !c.dynamicChildren && ((c.patchFlag <= 0 || c.patchFlag === 32) && (c = s[i] = so(s[i]), c.el = a.el), n || X5(a, c)), c.type === Kl && (c.el = a.el)
            }
    }

    function eD(t) {
        const e = t.slice(),
            n = [0];
        let r, s, i, a, c;
        const l = t.length;
        for (r = 0; r < l; r++) {
            const h = t[r];
            if (h !== 0) {
                if (s = n[n.length - 1], t[s] < h) {
                    e[r] = s, n.push(r);
                    continue
                }
                for (i = 0, a = n.length - 1; i < a;) c = i + a >> 1, t[n[c]] < h ? i = c + 1 : a = c;
                h < t[n[i]] && (i > 0 && (e[r] = n[i - 1]), n[i] = r)
            }
        }
        for (i = n.length, a = n[i - 1]; i-- > 0;) n[i] = a, a = e[a];
        return n
    }
    const tD = t => t.__isTeleport,
        St = Symbol.for("v-fgt"),
        Kl = Symbol.for("v-txt"),
        ns = Symbol.for("v-cmt"),
        Wf = Symbol.for("v-stc"),
        zu = [];
    let Es = null;

    function Y(t = !1) {
        zu.push(Es = t ? null : [])
    }

    function nD() {
        zu.pop(), Es = zu[zu.length - 1] || null
    }
    let dl = 1;

    function aS(t) {
        dl += t
    }

    function Q5(t) {
        return t.dynamicChildren = dl > 0 ? Es || pc : null, nD(), dl > 0 && Es && Es.push(t), t
    }

    function X(t, e, n, r, s, i) {
        return Q5(W(t, e, n, r, s, i, !0))
    }

    function Vt(t, e, n, r, s) {
        return Q5(Qe(t, e, n, r, s, !0))
    }

    function ad(t) {
        return t ? t.__v_isVNode === !0 : !1
    }

    function sa(t, e) {
        return t.type === e.type && t.key === e.key
    }
    const Fp = "__vInternal",
        J5 = ({
            key: t
        }) => t ?? null,
        Hf = ({
            ref: t,
            ref_key: e,
            ref_for: n
        }) => (typeof t == "number" && (t = "" + t), t != null ? bn(t) || qn(t) || lt(t) ? {
            i: Vn,
            r: t,
            k: e,
            f: !!n
        } : t : null);

    function W(t, e = null, n = null, r = 0, s = null, i = t === St ? 0 : 1, a = !1, c = !1) {
        const l = {
            __v_isVNode: !0,
            __v_skip: !0,
            type: t,
            props: e,
            key: e && J5(e),
            ref: e && Hf(e),
            scopeId: Dp,
            slotScopeIds: null,
            children: n,
            component: null,
            suspense: null,
            ssContent: null,
            ssFallback: null,
            dirs: null,
            transition: null,
            el: null,
            anchor: null,
            target: null,
            targetAnchor: null,
            staticCount: 0,
            shapeFlag: i,
            patchFlag: r,
            dynamicProps: s,
            dynamicChildren: null,
            appContext: null,
            ctx: Vn
        };
        return c ? (Wy(l, n), i & 128 && t.normalize(l)) : n && (l.shapeFlag |= bn(n) ? 8 : 16), dl > 0 && !a && Es && (l.patchFlag > 0 || i & 6) && l.patchFlag !== 32 && Es.push(l), l
    }
    const Qe = rD;

    function rD(t, e = null, n = null, r = 0, s = null, i = !1) {
        if ((!t || t === V5) && (t = ns), ad(t)) {
            const c = Eo(t, e, !0);
            return n && Wy(c, n), dl > 0 && !i && Es && (c.shapeFlag & 6 ? Es[Es.indexOf(t)] = c : Es.push(c)), c.patchFlag |= -2, c
        }
        if (dD(t) && (t = t.__vccOpts), e) {
            e = sD(e);
            let {
                class: c,
                style: l
            } = e;
            c && !bn(c) && (e.class = mt(c)), Gt(l) && (T5(l) && !We(l) && (l = wn({}, l)), e.style = Jn(l))
        }
        const a = bn(t) ? 1 : EM(t) ? 128 : tD(t) ? 64 : Gt(t) ? 4 : lt(t) ? 2 : 0;
        return W(t, e, n, r, s, a, i, !0)
    }

    function sD(t) {
        return t ? T5(t) || Fp in t ? wn({}, t) : t : null
    }

    function Eo(t, e, n = !1) {
        const {
            props: r,
            ref: s,
            patchFlag: i,
            children: a
        } = t, c = e ? Up(r || {}, e) : r;
        return {
            __v_isVNode: !0,
            __v_skip: !0,
            type: t.type,
            props: c,
            key: c && J5(c),
            ref: e && e.ref ? n && s ? We(s) ? s.concat(Hf(e)) : [s, Hf(e)] : Hf(e) : s,
            scopeId: t.scopeId,
            slotScopeIds: t.slotScopeIds,
            children: a,
            target: t.target,
            targetAnchor: t.targetAnchor,
            staticCount: t.staticCount,
            shapeFlag: t.shapeFlag,
            patchFlag: e && t.type !== St ? i === -1 ? 16 : i | 16 : i,
            dynamicProps: t.dynamicProps,
            dynamicChildren: t.dynamicChildren,
            appContext: t.appContext,
            dirs: t.dirs,
            transition: t.transition,
            component: t.component,
            suspense: t.suspense,
            ssContent: t.ssContent && Eo(t.ssContent),
            ssFallback: t.ssFallback && Eo(t.ssFallback),
            el: t.el,
            anchor: t.anchor,
            ctx: t.ctx,
            ce: t.ce
        }
    }

    function Nn(t = " ", e = 0) {
        return Qe(Kl, null, t, e)
    }

    function e4(t, e) {
        const n = Qe(Wf, null, t);
        return n.staticCount = e, n
    }

    function Ve(t = "", e = !1) {
        return e ? (Y(), Vt(ns, null, t)) : Qe(ns, null, t)
    }

    function Hs(t) {
        return t == null || typeof t == "boolean" ? Qe(ns) : We(t) ? Qe(St, null, t.slice()) : typeof t == "object" ? so(t) : Qe(Kl, null, String(t))
    }

    function so(t) {
        return t.el === null && t.patchFlag !== -1 || t.memo ? t : Eo(t)
    }

    function Wy(t, e) {
        let n = 0;
        const {
            shapeFlag: r
        } = t;
        if (e == null) e = null;
        else if (We(e)) n = 16;
        else if (typeof e == "object")
            if (r & 65) {
                const s = e.default;
                s && (s._c && (s._d = !1), Wy(t, s()), s._c && (s._d = !0));
                return
            } else {
                n = 32;
                const s = e._;
                !s && !(Fp in e) ? e._ctx = Vn : s === 3 && Vn && (Vn.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024))
            }
        else lt(e) ? (e = {
            default: e,
            _ctx: Vn
        }, n = 32) : (e = String(e), r & 64 ? (n = 16, e = [Nn(e)]) : n = 8);
        t.children = e, t.shapeFlag |= n
    }

    function Up(...t) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const r = t[n];
            for (const s in r)
                if (s === "class") e.class !== r.class && (e.class = mt([e.class, r.class]));
                else if (s === "style") e.style = Jn([e.style, r.style]);
            else if (Cp(s)) {
                const i = e[s],
                    a = r[s];
                a && i !== a && !(We(i) && i.includes(a)) && (e[s] = i ? [].concat(i, a) : a)
            } else s !== "" && (e[s] = r[s])
        }
        return e
    }

    function qs(t, e, n, r = null) {
        ts(t, e, 7, [n, r])
    }
    const iD = W5();
    let oD = 0;

    function aD(t, e, n) {
        const r = t.type,
            s = (e ? e.appContext : t.appContext) || iD,
            i = {
                uid: oD++,
                vnode: t,
                type: r,
                parent: e,
                appContext: s,
                root: null,
                next: null,
                subTree: null,
                effect: null,
                update: null,
                scope: new h5(!0),
                render: null,
                proxy: null,
                exposed: null,
                exposeProxy: null,
                withProxy: null,
                provides: e ? e.provides : Object.create(s.provides),
                accessCache: null,
                renderCache: [],
                components: null,
                directives: null,
                propsOptions: K5(r, s),
                emitsOptions: R5(r, s),
                emit: null,
                emitted: null,
                propsDefaults: Qt,
                inheritAttrs: r.inheritAttrs,
                ctx: Qt,
                data: Qt,
                props: Qt,
                attrs: Qt,
                slots: Qt,
                refs: Qt,
                setupState: Qt,
                setupContext: null,
                attrsProxy: null,
                slotsProxy: null,
                suspense: n,
                suspenseId: n ? n.pendingId : 0,
                asyncDep: null,
                asyncResolved: !1,
                isMounted: !1,
                isUnmounted: !1,
                isDeactivated: !1,
                bc: null,
                c: null,
                bm: null,
                m: null,
                bu: null,
                u: null,
                um: null,
                bum: null,
                da: null,
                a: null,
                rtg: null,
                rtc: null,
                ec: null,
                sp: null
            };
        return i.ctx = {
            _: i
        }, i.root = e ? e.root : i, i.emit = gM.bind(null, i), t.ce && t.ce(i), i
    }
    let $n = null;
    const pl = () => $n || Vn;
    let Hy, Qa, cS = "__VUE_INSTANCE_SETTERS__";
    (Qa = z_()[cS]) || (Qa = z_()[cS] = []), Qa.push(t => $n = t), Hy = t => {
        Qa.length > 1 ? Qa.forEach(e => e(t)) : Qa[0](t)
    };
    const Pc = t => {
            Hy(t), t.scope.on()
        },
        ma = () => {
            $n && $n.scope.off(), Hy(null)
        };

    function t4(t) {
        return t.vnode.shapeFlag & 4
    }
    let ml = !1;

    function cD(t, e = !1) {
        ml = e;
        const {
            props: n,
            children: r
        } = t.vnode, s = t4(t);
        KM(t, n, s, e), ZM(t, r);
        const i = s ? uD(t, e) : void 0;
        return ml = !1, i
    }

    function uD(t, e) {
        const n = t.type;
        t.accessCache = Object.create(null), t.proxy = w5(new Proxy(t.ctx, FM));
        const {
            setup: r
        } = n;
        if (r) {
            const s = t.setupContext = r.length > 1 ? hD(t) : null;
            Pc(t), Qc();
            const i = po(r, t, 0, [t.props, s]);
            if (Jc(), ma(), i5(i)) {
                if (i.then(ma, ma), e) return i.then(a => {
                    uS(t, a, e)
                }).catch(a => {
                    Rp(a, t, 0)
                });
                t.asyncDep = i
            } else uS(t, i, e)
        } else n4(t, e)
    }

    function uS(t, e, n) {
        lt(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : Gt(e) && (t.setupState = I5(e)), n4(t, n)
    }
    let lS;

    function n4(t, e, n) {
        const r = t.type;
        if (!t.render) {
            if (!e && lS && !r.render) {
                const s = r.template || jy(t).template;
                if (s) {
                    const {
                        isCustomElement: i,
                        compilerOptions: a
                    } = t.appContext.config, {
                        delimiters: c,
                        compilerOptions: l
                    } = r, h = wn(wn({
                        isCustomElement: i,
                        delimiters: c
                    }, a), l);
                    r.render = lS(s, h)
                }
            }
            t.render = r.render || Ts
        }
        Pc(t), Qc(), UM(t), Jc(), ma()
    }

    function lD(t) {
        return t.attrsProxy || (t.attrsProxy = new Proxy(t.attrs, {
            get(e, n) {
                return Ar(t, "get", "$attrs"), e[n]
            }
        }))
    }

    function hD(t) {
        const e = n => {
            t.exposed = n || {}
        };
        return {
            get attrs() {
                return lD(t)
            },
            slots: t.slots,
            emit: t.emit,
            expose: e
        }
    }

    function Bp(t) {
        if (t.exposed) return t.exposeProxy || (t.exposeProxy = new Proxy(I5(w5(t.exposed)), {
            get(e, n) {
                if (n in e) return e[n];
                if (n in Yu) return Yu[n](t)
            },
            has(e, n) {
                return n in e || n in Yu
            }
        }))
    }

    function fD(t, e = !0) {
        return lt(t) ? t.displayName || t.name : t.name || e && t.__name
    }

    function dD(t) {
        return lt(t) && "__vccOpts" in t
    }
    const Lr = (t, e) => uM(t, e, ml);

    function Ky(t, e, n) {
        const r = arguments.length;
        return r === 2 ? Gt(e) && !We(e) ? ad(e) ? Qe(t, null, [e]) : Qe(t, e) : Qe(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && ad(n) && (n = [n]), Qe(t, e, n))
    }
    const pD = Symbol.for("v-scx"),
        mD = () => mo(pD),
        gD = "3.3.4",
        _D = "http://www.w3.org/2000/svg",
        ia = typeof document < "u" ? document : null,
        hS = ia && ia.createElement("template"),
        yD = {
            insert: (t, e, n) => {
                e.insertBefore(t, n || null)
            },
            remove: t => {
                const e = t.parentNode;
                e && e.removeChild(t)
            },
            createElement: (t, e, n, r) => {
                const s = e ? ia.createElementNS(_D, t) : ia.createElement(t, n ? {
                    is: n
                } : void 0);
                return t === "select" && r && r.multiple != null && s.setAttribute("multiple", r.multiple), s
            },
            createText: t => ia.createTextNode(t),
            createComment: t => ia.createComment(t),
            setText: (t, e) => {
                t.nodeValue = e
            },
            setElementText: (t, e) => {
                t.textContent = e
            },
            parentNode: t => t.parentNode,
            nextSibling: t => t.nextSibling,
            querySelector: t => ia.querySelector(t),
            setScopeId(t, e) {
                t.setAttribute(e, "")
            },
            insertStaticContent(t, e, n, r, s, i) {
                const a = n ? n.previousSibling : e.lastChild;
                if (s && (s === i || s.nextSibling))
                    for (; e.insertBefore(s.cloneNode(!0), n), !(s === i || !(s = s.nextSibling)););
                else {
                    hS.innerHTML = r ? `<svg>${t}</svg>` : t;
                    const c = hS.content;
                    if (r) {
                        const l = c.firstChild;
                        for (; l.firstChild;) c.appendChild(l.firstChild);
                        c.removeChild(l)
                    }
                    e.insertBefore(c, n)
                }
                return [a ? a.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
            }
        };

    function vD(t, e, n) {
        const r = t._vtc;
        r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e
    }

    function bD(t, e, n) {
        const r = t.style,
            s = bn(n);
        if (n && !s) {
            if (e && !bn(e))
                for (const i in e) n[i] == null && c1(r, i, "");
            for (const i in n) c1(r, i, n[i])
        } else {
            const i = r.display;
            s ? e !== n && (r.cssText = n) : e && t.removeAttribute("style"), "_vod" in t && (r.display = i)
        }
    }
    const fS = /\s*!important$/;

    function c1(t, e, n) {
        if (We(n)) n.forEach(r => c1(t, e, r));
        else if (n == null && (n = ""), e.startsWith("--")) t.setProperty(e, n);
        else {
            const r = ED(t, e);
            fS.test(n) ? t.setProperty(ka(r), n.replace(fS, ""), "important") : t[r] = n
        }
    }
    const dS = ["Webkit", "Moz", "ms"],
        Jg = {};

    function ED(t, e) {
        const n = Jg[e];
        if (n) return n;
        let r = zs(e);
        if (r !== "filter" && r in t) return Jg[e] = r;
        r = Np(r);
        for (let s = 0; s < dS.length; s++) {
            const i = dS[s] + r;
            if (i in t) return Jg[e] = i
        }
        return e
    }
    const pS = "http://www.w3.org/1999/xlink";

    function SD(t, e, n, r, s) {
        if (r && e.startsWith("xlink:")) n == null ? t.removeAttributeNS(pS, e.slice(6, e.length)) : t.setAttributeNS(pS, e, n);
        else {
            const i = AR(e);
            n == null || i && !c5(n) ? t.removeAttribute(e) : t.setAttribute(e, i ? "" : n)
        }
    }

    function TD(t, e, n, r, s, i, a) {
        if (e === "innerHTML" || e === "textContent") {
            r && a(r, s, i), t[e] = n ?? "";
            return
        }
        const c = t.tagName;
        if (e === "value" && c !== "PROGRESS" && !c.includes("-")) {
            t._value = n;
            const h = c === "OPTION" ? t.getAttribute("value") : t.value,
                d = n ?? "";
            h !== d && (t.value = d), n == null && t.removeAttribute(e);
            return
        }
        let l = !1;
        if (n === "" || n == null) {
            const h = typeof t[e];
            h === "boolean" ? n = c5(n) : n == null && h === "string" ? (n = "", l = !0) : h === "number" && (n = 0, l = !0)
        }
        try {
            t[e] = n
        } catch {}
        l && t.removeAttribute(e)
    }

    function oa(t, e, n, r) {
        t.addEventListener(e, n, r)
    }

    function wD(t, e, n, r) {
        t.removeEventListener(e, n, r)
    }

    function OD(t, e, n, r, s = null) {
        const i = t._vei || (t._vei = {}),
            a = i[e];
        if (r && a) a.value = r;
        else {
            const [c, l] = AD(e);
            if (r) {
                const h = i[e] = kD(r, s);
                oa(t, c, h, l)
            } else a && (wD(t, c, a, l), i[e] = void 0)
        }
    }
    const mS = /(?:Once|Passive|Capture)$/;

    function AD(t) {
        let e;
        if (mS.test(t)) {
            e = {};
            let r;
            for (; r = t.match(mS);) t = t.slice(0, t.length - r[0].length), e[r[0].toLowerCase()] = !0
        }
        return [t[2] === ":" ? t.slice(3) : ka(t.slice(2)), e]
    }
    let e_ = 0;
    const CD = Promise.resolve(),
        ID = () => e_ || (CD.then(() => e_ = 0), e_ = Date.now());

    function kD(t, e) {
        const n = r => {
            if (!r._vts) r._vts = Date.now();
            else if (r._vts <= n.attached) return;
            ts(ND(r, n.value), e, 5, [r])
        };
        return n.value = t, n.attached = ID(), n
    }

    function ND(t, e) {
        if (We(e)) {
            const n = t.stopImmediatePropagation;
            return t.stopImmediatePropagation = () => {
                n.call(t), t._stopped = !0
            }, e.map(r => s => !s._stopped && r && r(s))
        } else return e
    }
    const gS = /^on[a-z]/,
        xD = (t, e, n, r, s = !1, i, a, c, l) => {
            e === "class" ? vD(t, r, s) : e === "style" ? bD(t, n, r) : Cp(e) ? Ay(e) || OD(t, e, n, r, a) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : PD(t, e, r, s)) ? TD(t, e, r, i, a, c, l) : (e === "true-value" ? t._trueValue = r : e === "false-value" && (t._falseValue = r), SD(t, e, r, s))
        };

    function PD(t, e, n, r) {
        return r ? !!(e === "innerHTML" || e === "textContent" || e in t && gS.test(e) && lt(n)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || gS.test(e) && bn(n) ? !1 : e in t
    }
    const Ji = "transition",
        $u = "animation",
        xs = (t, {
            slots: e
        }) => Ky(AM, RD(t), e);
    xs.displayName = "Transition";
    const r4 = {
        name: String,
        type: String,
        css: {
            type: Boolean,
            default: !0
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
    };
    xs.props = wn({}, $5, r4);
    const Jo = (t, e = []) => {
            We(t) ? t.forEach(n => n(...e)) : t && t(...e)
        },
        _S = t => t ? We(t) ? t.some(e => e.length > 1) : t.length > 1 : !1;

    function RD(t) {
        const e = {};
        for (const ee in t) ee in r4 || (e[ee] = t[ee]);
        if (t.css === !1) return e;
        const {
            name: n = "v",
            type: r,
            duration: s,
            enterFromClass: i = `${n}-enter-from`,
            enterActiveClass: a = `${n}-enter-active`,
            enterToClass: c = `${n}-enter-to`,
            appearFromClass: l = i,
            appearActiveClass: h = a,
            appearToClass: d = c,
            leaveFromClass: p = `${n}-leave-from`,
            leaveActiveClass: g = `${n}-leave-active`,
            leaveToClass: v = `${n}-leave-to`
        } = t, b = MD(s), T = b && b[0], m = b && b[1], {
            onBeforeEnter: w,
            onEnter: P,
            onEnterCancelled: V,
            onLeave: M,
            onLeaveCancelled: I,
            onBeforeAppear: L = w,
            onAppear: B = P,
            onAppearCancelled: q = V
        } = e, se = (ee, ge, G) => {
            ea(ee, ge ? d : c), ea(ee, ge ? h : a), G && G()
        }, ce = (ee, ge) => {
            ee._isLeaving = !1, ea(ee, p), ea(ee, v), ea(ee, g), ge && ge()
        }, ue = ee => (ge, G) => {
            const le = ee ? B : P,
                fe = () => se(ge, ee, G);
            Jo(le, [ge, fe]), yS(() => {
                ea(ge, ee ? l : i), eo(ge, ee ? d : c), _S(le) || vS(ge, r, T, fe)
            })
        };
        return wn(e, {
            onBeforeEnter(ee) {
                Jo(w, [ee]), eo(ee, i), eo(ee, a)
            },
            onBeforeAppear(ee) {
                Jo(L, [ee]), eo(ee, l), eo(ee, h)
            },
            onEnter: ue(!1),
            onAppear: ue(!0),
            onLeave(ee, ge) {
                ee._isLeaving = !0;
                const G = () => ce(ee, ge);
                eo(ee, p), LD(), eo(ee, g), yS(() => {
                    ee._isLeaving && (ea(ee, p), eo(ee, v), _S(M) || vS(ee, r, m, G))
                }), Jo(M, [ee, G])
            },
            onEnterCancelled(ee) {
                se(ee, !1), Jo(V, [ee])
            },
            onAppearCancelled(ee) {
                se(ee, !0), Jo(q, [ee])
            },
            onLeaveCancelled(ee) {
                ce(ee), Jo(I, [ee])
            }
        })
    }

    function MD(t) {
        if (t == null) return null;
        if (Gt(t)) return [t_(t.enter), t_(t.leave)]; {
            const e = t_(t);
            return [e, e]
        }
    }

    function t_(t) {
        return bR(t)
    }

    function eo(t, e) {
        e.split(/\s+/).forEach(n => n && t.classList.add(n)), (t._vtc || (t._vtc = new Set)).add(e)
    }

    function ea(t, e) {
        e.split(/\s+/).forEach(r => r && t.classList.remove(r));
        const {
            _vtc: n
        } = t;
        n && (n.delete(e), n.size || (t._vtc = void 0))
    }

    function yS(t) {
        requestAnimationFrame(() => {
            requestAnimationFrame(t)
        })
    }
    let DD = 0;

    function vS(t, e, n, r) {
        const s = t._endId = ++DD,
            i = () => {
                s === t._endId && r()
            };
        if (n) return setTimeout(i, n);
        const {
            type: a,
            timeout: c,
            propCount: l
        } = $D(t, e);
        if (!a) return r();
        const h = a + "end";
        let d = 0;
        const p = () => {
                t.removeEventListener(h, g), i()
            },
            g = v => {
                v.target === t && ++d >= l && p()
            };
        setTimeout(() => {
            d < l && p()
        }, c + 1), t.addEventListener(h, g)
    }

    function $D(t, e) {
        const n = window.getComputedStyle(t),
            r = b => (n[b] || "").split(", "),
            s = r(`${Ji}Delay`),
            i = r(`${Ji}Duration`),
            a = bS(s, i),
            c = r(`${$u}Delay`),
            l = r(`${$u}Duration`),
            h = bS(c, l);
        let d = null,
            p = 0,
            g = 0;
        e === Ji ? a > 0 && (d = Ji, p = a, g = i.length) : e === $u ? h > 0 && (d = $u, p = h, g = l.length) : (p = Math.max(a, h), d = p > 0 ? a > h ? Ji : $u : null, g = d ? d === Ji ? i.length : l.length : 0);
        const v = d === Ji && /\b(transform|all)(,|$)/.test(r(`${Ji}Property`).toString());
        return {
            type: d,
            timeout: p,
            propCount: g,
            hasTransform: v
        }
    }

    function bS(t, e) {
        for (; t.length < e.length;) t = t.concat(t);
        return Math.max(...e.map((n, r) => ES(n) + ES(t[r])))
    }

    function ES(t) {
        return Number(t.slice(0, -1).replace(",", ".")) * 1e3
    }

    function LD() {
        return document.body.offsetHeight
    }
    const cd = t => {
        const e = t.props["onUpdate:modelValue"] || !1;
        return We(e) ? n => Gf(e, n) : e
    };

    function FD(t) {
        t.target.composing = !0
    }

    function SS(t) {
        const e = t.target;
        e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")))
    }
    const TS = {
            created(t, {
                modifiers: {
                    lazy: e,
                    trim: n,
                    number: r
                }
            }, s) {
                t._assign = cd(s);
                const i = r || s.props && s.props.type === "number";
                oa(t, e ? "change" : "input", a => {
                    if (a.target.composing) return;
                    let c = t.value;
                    n && (c = c.trim()), i && (c = Y_(c)), t._assign(c)
                }), n && oa(t, "change", () => {
                    t.value = t.value.trim()
                }), e || (oa(t, "compositionstart", FD), oa(t, "compositionend", SS), oa(t, "change", SS))
            },
            mounted(t, {
                value: e
            }) {
                t.value = e ?? ""
            },
            beforeUpdate(t, {
                value: e,
                modifiers: {
                    lazy: n,
                    trim: r,
                    number: s
                }
            }, i) {
                if (t._assign = cd(i), t.composing || document.activeElement === t && t.type !== "range" && (n || r && t.value.trim() === e || (s || t.type === "number") && Y_(t.value) === e)) return;
                const a = e ?? "";
                t.value !== a && (t.value = a)
            }
        },
        UD = {
            deep: !0,
            created(t, e, n) {
                t._assign = cd(n), oa(t, "change", () => {
                    const r = t._modelValue,
                        s = BD(t),
                        i = t.checked,
                        a = t._assign;
                    if (We(r)) {
                        const c = u5(r, s),
                            l = c !== -1;
                        if (i && !l) a(r.concat(s));
                        else if (!i && l) {
                            const h = [...r];
                            h.splice(c, 1), a(h)
                        }
                    } else if (Ip(r)) {
                        const c = new Set(r);
                        i ? c.add(s) : c.delete(s), a(c)
                    } else a(s4(t, i))
                })
            },
            mounted: wS,
            beforeUpdate(t, e, n) {
                t._assign = cd(n), wS(t, e, n)
            }
        };

    function wS(t, {
        value: e,
        oldValue: n
    }, r) {
        t._modelValue = e, We(e) ? t.checked = u5(e, r.props.value) > -1 : Ip(e) ? t.checked = e.has(r.props.value) : e !== n && (t.checked = xp(e, s4(t, !0)))
    }

    function BD(t) {
        return "_value" in t ? t._value : t.value
    }

    function s4(t, e) {
        const n = e ? "_trueValue" : "_falseValue";
        return n in t ? t[n] : e
    }
    const qD = ["ctrl", "shift", "alt", "meta"],
        VD = {
            stop: t => t.stopPropagation(),
            prevent: t => t.preventDefault(),
            self: t => t.target !== t.currentTarget,
            ctrl: t => !t.ctrlKey,
            shift: t => !t.shiftKey,
            alt: t => !t.altKey,
            meta: t => !t.metaKey,
            left: t => "button" in t && t.button !== 0,
            middle: t => "button" in t && t.button !== 1,
            right: t => "button" in t && t.button !== 2,
            exact: (t, e) => qD.some(n => t[`${n}Key`] && !e.includes(n))
        },
        xi = (t, e) => (n, ...r) => {
            for (let s = 0; s < e.length; s++) {
                const i = VD[e[s]];
                if (i && i(n, e)) return
            }
            return t(n, ...r)
        },
        jD = {
            esc: "escape",
            space: " ",
            up: "arrow-up",
            left: "arrow-left",
            right: "arrow-right",
            down: "arrow-down",
            delete: "backspace"
        },
        Yy = (t, e) => n => {
            if (!("key" in n)) return;
            const r = ka(n.key);
            if (e.some(s => s === r || jD[s] === r)) return t(n)
        },
        GD = wn({
            patchProp: xD
        }, yD);
    let OS;

    function WD() {
        return OS || (OS = QM(GD))
    }
    const HD = (...t) => {
        const e = WD().createApp(...t),
            {
                mount: n
            } = e;
        return e.mount = r => {
            const s = KD(r);
            if (!s) return;
            const i = e._component;
            !lt(i) && !i.render && !i.template && (i.template = s.innerHTML), s.innerHTML = "";
            const a = n(s, !1, s instanceof SVGElement);
            return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), a
        }, e
    };

    function KD(t) {
        return bn(t) ? document.querySelector(t) : t
    }
    const ct = (t, e) => {
        const n = t.__vccOpts || t;
        for (const [r, s] of e) n[r] = s;
        return n
    };
    var hn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

    function eu(t) {
        return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
    }

    function YD(t) {
        if (t.__esModule) return t;
        var e = t.default;
        if (typeof e == "function") {
            var n = function r() {
                return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
            };
            n.prototype = e.prototype
        } else n = {};
        return Object.defineProperty(n, "__esModule", {
            value: !0
        }), Object.keys(t).forEach(function(r) {
            var s = Object.getOwnPropertyDescriptor(t, r);
            Object.defineProperty(n, r, s.get ? s : {
                enumerable: !0,
                get: function() {
                    return t[r]
                }
            })
        }), n
    }
    var go = {
            DEBUG: !1,
            LIB_VERSION: "2.45.0"
        },
        nr;
    if (typeof window > "u") {
        var AS = {
            hostname: ""
        };
        nr = {
            navigator: {
                userAgent: ""
            },
            document: {
                location: AS,
                referrer: ""
            },
            screen: {
                width: 0,
                height: 0
            },
            location: AS
        }
    } else nr = window;
    var qp = Array.prototype,
        zD = Function.prototype,
        i4 = Object.prototype,
        lo = qp.slice,
        Yl = i4.toString,
        Vp = i4.hasOwnProperty,
        Sn = nr.console,
        Oi = nr.navigator,
        qt = nr.document,
        Lu = nr.opera,
        ud = nr.screen,
        ms = Oi.userAgent,
        n_ = zD.bind,
        CS = qp.forEach,
        IS = qp.indexOf,
        kS = qp.map,
        ZD = Array.isArray,
        u1 = {},
        x = {
            trim: function(t) {
                return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
            }
        },
        Lt = {
            log: function() {
                if (go.DEBUG && !x.isUndefined(Sn) && Sn) try {
                    Sn.log.apply(Sn, arguments)
                } catch {
                    x.each(arguments, function(e) {
                        Sn.log(e)
                    })
                }
            },
            warn: function() {
                if (go.DEBUG && !x.isUndefined(Sn) && Sn) {
                    var t = ["Mixpanel warning:"].concat(x.toArray(arguments));
                    try {
                        Sn.warn.apply(Sn, t)
                    } catch {
                        x.each(t, function(n) {
                            Sn.warn(n)
                        })
                    }
                }
            },
            error: function() {
                if (go.DEBUG && !x.isUndefined(Sn) && Sn) {
                    var t = ["Mixpanel error:"].concat(x.toArray(arguments));
                    try {
                        Sn.error.apply(Sn, t)
                    } catch {
                        x.each(t, function(n) {
                            Sn.error(n)
                        })
                    }
                }
            },
            critical: function() {
                if (!x.isUndefined(Sn) && Sn) {
                    var t = ["Mixpanel error:"].concat(x.toArray(arguments));
                    try {
                        Sn.error.apply(Sn, t)
                    } catch {
                        x.each(t, function(n) {
                            Sn.error(n)
                        })
                    }
                }
            }
        },
        r_ = function(t, e) {
            return function() {
                return arguments[0] = "[" + e + "] " + arguments[0], t.apply(Lt, arguments)
            }
        },
        zy = function(t) {
            return {
                log: r_(Lt.log, t),
                error: r_(Lt.error, t),
                critical: r_(Lt.critical, t)
            }
        };
    x.bind = function(t, e) {
        var n, r;
        if (n_ && t.bind === n_) return n_.apply(t, lo.call(arguments, 1));
        if (!x.isFunction(t)) throw new TypeError;
        return n = lo.call(arguments, 2), r = function() {
            if (!(this instanceof r)) return t.apply(e, n.concat(lo.call(arguments)));
            var s = {};
            s.prototype = t.prototype;
            var i = new s;
            s.prototype = null;
            var a = t.apply(i, n.concat(lo.call(arguments)));
            return Object(a) === a ? a : i
        }, r
    };
    x.each = function(t, e, n) {
        if (t != null) {
            if (CS && t.forEach === CS) t.forEach(e, n);
            else if (t.length === +t.length) {
                for (var r = 0, s = t.length; r < s; r++)
                    if (r in t && e.call(n, t[r], r, t) === u1) return
            } else
                for (var i in t)
                    if (Vp.call(t, i) && e.call(n, t[i], i, t) === u1) return
        }
    };
    x.extend = function(t) {
        return x.each(lo.call(arguments, 1), function(e) {
            for (var n in e) e[n] !== void 0 && (t[n] = e[n])
        }), t
    };
    x.isArray = ZD || function(t) {
        return Yl.call(t) === "[object Array]"
    };
    x.isFunction = function(t) {
        try {
            return /^\s*\bfunction\b/.test(t)
        } catch {
            return !1
        }
    };
    x.isArguments = function(t) {
        return !!(t && Vp.call(t, "callee"))
    };
    x.toArray = function(t) {
        return t ? t.toArray ? t.toArray() : x.isArray(t) || x.isArguments(t) ? lo.call(t) : x.values(t) : []
    };
    x.map = function(t, e, n) {
        if (kS && t.map === kS) return t.map(e, n);
        var r = [];
        return x.each(t, function(s) {
            r.push(e.call(n, s))
        }), r
    };
    x.keys = function(t) {
        var e = [];
        return t === null || x.each(t, function(n, r) {
            e[e.length] = r
        }), e
    };
    x.values = function(t) {
        var e = [];
        return t === null || x.each(t, function(n) {
            e[e.length] = n
        }), e
    };
    x.include = function(t, e) {
        var n = !1;
        return t === null ? n : IS && t.indexOf === IS ? t.indexOf(e) != -1 : (x.each(t, function(r) {
            if (n || (n = r === e)) return u1
        }), n)
    };
    x.includes = function(t, e) {
        return t.indexOf(e) !== -1
    };
    x.inherit = function(t, e) {
        return t.prototype = new e, t.prototype.constructor = t, t.superclass = e.prototype, t
    };
    x.isObject = function(t) {
        return t === Object(t) && !x.isArray(t)
    };
    x.isEmptyObject = function(t) {
        if (x.isObject(t)) {
            for (var e in t)
                if (Vp.call(t, e)) return !1;
            return !0
        }
        return !1
    };
    x.isUndefined = function(t) {
        return t === void 0
    };
    x.isString = function(t) {
        return Yl.call(t) == "[object String]"
    };
    x.isDate = function(t) {
        return Yl.call(t) == "[object Date]"
    };
    x.isNumber = function(t) {
        return Yl.call(t) == "[object Number]"
    };
    x.isElement = function(t) {
        return !!(t && t.nodeType === 1)
    };
    x.encodeDates = function(t) {
        return x.each(t, function(e, n) {
            x.isDate(e) ? t[n] = x.formatDate(e) : x.isObject(e) && (t[n] = x.encodeDates(e))
        }), t
    };
    x.timestamp = function() {
        return Date.now = Date.now || function() {
            return +new Date
        }, Date.now()
    };
    x.formatDate = function(t) {
        function e(n) {
            return n < 10 ? "0" + n : n
        }
        return t.getUTCFullYear() + "-" + e(t.getUTCMonth() + 1) + "-" + e(t.getUTCDate()) + "T" + e(t.getUTCHours()) + ":" + e(t.getUTCMinutes()) + ":" + e(t.getUTCSeconds())
    };
    x.strip_empty_properties = function(t) {
        var e = {};
        return x.each(t, function(n, r) {
            x.isString(n) && n.length > 0 && (e[r] = n)
        }), e
    };
    x.truncate = function(t, e) {
        var n;
        return typeof t == "string" ? n = t.slice(0, e) : x.isArray(t) ? (n = [], x.each(t, function(r) {
            n.push(x.truncate(r, e))
        })) : x.isObject(t) ? (n = {}, x.each(t, function(r, s) {
            n[s] = x.truncate(r, e)
        })) : n = t, n
    };
    x.JSONEncode = function() {
        return function(t) {
            var e = t,
                n = function(s) {
                    var i = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                        a = {
                            "\b": "\\b",
                            "	": "\\t",
                            "\n": "\\n",
                            "\f": "\\f",
                            "\r": "\\r",
                            '"': '\\"',
                            "\\": "\\\\"
                        };
                    return i.lastIndex = 0, i.test(s) ? '"' + s.replace(i, function(c) {
                        var l = a[c];
                        return typeof l == "string" ? l : "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4)
                    }) + '"' : '"' + s + '"'
                },
                r = function(s, i) {
                    var a = "",
                        c = "    ",
                        l = 0,
                        h = "",
                        d = "",
                        p = 0,
                        g = a,
                        v = [],
                        b = i[s];
                    switch (b && typeof b == "object" && typeof b.toJSON == "function" && (b = b.toJSON(s)), typeof b) {
                        case "string":
                            return n(b);
                        case "number":
                            return isFinite(b) ? String(b) : "null";
                        case "boolean":
                        case "null":
                            return String(b);
                        case "object":
                            if (!b) return "null";
                            if (a += c, v = [], Yl.apply(b) === "[object Array]") {
                                for (p = b.length, l = 0; l < p; l += 1) v[l] = r(l, b) || "null";
                                return d = v.length === 0 ? "[]" : a ? `[
` + a + v.join(`,
` + a) + `
` + g + "]" : "[" + v.join(",") + "]", a = g, d
                            }
                            for (h in b) Vp.call(b, h) && (d = r(h, b), d && v.push(n(h) + (a ? ": " : ":") + d));
                            return d = v.length === 0 ? "{}" : a ? "{" + v.join(",") + g + "}" : "{" + v.join(",") + "}", a = g, d
                    }
                };
            return r("", {
                "": e
            })
        }
    }();
    x.JSONDecode = function() {
        var t, e, n = {
                '"': '"',
                "\\": "\\",
                "/": "/",
                b: "\b",
                f: "\f",
                n: `
`,
                r: "\r",
                t: "	"
            },
            r, s = function(v) {
                var b = new SyntaxError(v);
                throw b.at = t, b.text = r, b
            },
            i = function(v) {
                return v && v !== e && s("Expected '" + v + "' instead of '" + e + "'"), e = r.charAt(t), t += 1, e
            },
            a = function() {
                var v, b = "";
                for (e === "-" && (b = "-", i("-")); e >= "0" && e <= "9";) b += e, i();
                if (e === ".")
                    for (b += "."; i() && e >= "0" && e <= "9";) b += e;
                if (e === "e" || e === "E")
                    for (b += e, i(), (e === "-" || e === "+") && (b += e, i()); e >= "0" && e <= "9";) b += e, i();
                if (v = +b, !isFinite(v)) s("Bad number");
                else return v
            },
            c = function() {
                var v, b, T = "",
                    m;
                if (e === '"')
                    for (; i();) {
                        if (e === '"') return i(), T;
                        if (e === "\\")
                            if (i(), e === "u") {
                                for (m = 0, b = 0; b < 4 && (v = parseInt(i(), 16), !!isFinite(v)); b += 1) m = m * 16 + v;
                                T += String.fromCharCode(m)
                            } else if (typeof n[e] == "string") T += n[e];
                        else break;
                        else T += e
                    }
                s("Bad string")
            },
            l = function() {
                for (; e && e <= " ";) i()
            },
            h = function() {
                switch (e) {
                    case "t":
                        return i("t"), i("r"), i("u"), i("e"), !0;
                    case "f":
                        return i("f"), i("a"), i("l"), i("s"), i("e"), !1;
                    case "n":
                        return i("n"), i("u"), i("l"), i("l"), null
                }
                s('Unexpected "' + e + '"')
            },
            d, p = function() {
                var v = [];
                if (e === "[") {
                    if (i("["), l(), e === "]") return i("]"), v;
                    for (; e;) {
                        if (v.push(d()), l(), e === "]") return i("]"), v;
                        i(","), l()
                    }
                }
                s("Bad array")
            },
            g = function() {
                var v, b = {};
                if (e === "{") {
                    if (i("{"), l(), e === "}") return i("}"), b;
                    for (; e;) {
                        if (v = c(), l(), i(":"), Object.hasOwnProperty.call(b, v) && s('Duplicate key "' + v + '"'), b[v] = d(), l(), e === "}") return i("}"), b;
                        i(","), l()
                    }
                }
                s("Bad object")
            };
        return d = function() {
                switch (l(), e) {
                    case "{":
                        return g();
                    case "[":
                        return p();
                    case '"':
                        return c();
                    case "-":
                        return a();
                    default:
                        return e >= "0" && e <= "9" ? a() : h()
                }
            },
            function(v) {
                var b;
                return r = v, t = 0, e = " ", b = d(), l(), e && s("Syntax error"), b
            }
    }();
    x.base64Encode = function(t) {
        var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            n, r, s, i, a, c, l, h, d = 0,
            p = 0,
            g = "",
            v = [];
        if (!t) return t;
        t = x.utf8Encode(t);
        do n = t.charCodeAt(d++), r = t.charCodeAt(d++), s = t.charCodeAt(d++), h = n << 16 | r << 8 | s, i = h >> 18 & 63, a = h >> 12 & 63, c = h >> 6 & 63, l = h & 63, v[p++] = e.charAt(i) + e.charAt(a) + e.charAt(c) + e.charAt(l); while (d < t.length);
        switch (g = v.join(""), t.length % 3) {
            case 1:
                g = g.slice(0, -2) + "==";
                break;
            case 2:
                g = g.slice(0, -1) + "=";
                break
        }
        return g
    };
    x.utf8Encode = function(t) {
        t = (t + "").replace(/\r\n/g, `
`).replace(/\r/g, `
`);
        var e = "",
            n, r, s = 0,
            i;
        for (n = r = 0, s = t.length, i = 0; i < s; i++) {
            var a = t.charCodeAt(i),
                c = null;
            a < 128 ? r++ : a > 127 && a < 2048 ? c = String.fromCharCode(a >> 6 | 192, a & 63 | 128) : c = String.fromCharCode(a >> 12 | 224, a >> 6 & 63 | 128, a & 63 | 128), c !== null && (r > n && (e += t.substring(n, r)), e += c, n = r = i + 1)
        }
        return r > n && (e += t.substring(n, t.length)), e
    };
    x.UUID = function() {
        var t = function() {
                for (var r = 1 * new Date, s = 0; r == 1 * new Date;) s++;
                return r.toString(16) + s.toString(16)
            },
            e = function() {
                return Math.random().toString(16).replace(".", "")
            },
            n = function() {
                var r = ms,
                    s, i, a = [],
                    c = 0;

                function l(h, d) {
                    var p, g = 0;
                    for (p = 0; p < d.length; p++) g |= a[p] << p * 8;
                    return h ^ g
                }
                for (s = 0; s < r.length; s++) i = r.charCodeAt(s), a.unshift(i & 255), a.length >= 4 && (c = l(c, a), a = []);
                return a.length > 0 && (c = l(c, a)), c.toString(16)
            };
        return function() {
            var r = (ud.height * ud.width).toString(16);
            return t() + "-" + e() + "-" + n() + "-" + r + "-" + t()
        }
    }();
    var NS = ["ahrefsbot", "baiduspider", "bingbot", "bingpreview", "facebookexternal", "petalbot", "pinterest", "screaming frog", "yahoo! slurp", "yandexbot", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google"];
    x.isBlockedUA = function(t) {
        var e;
        for (t = t.toLowerCase(), e = 0; e < NS.length; e++)
            if (t.indexOf(NS[e]) !== -1) return !0;
        return !1
    };
    x.HTTPBuildQuery = function(t, e) {
        var n, r, s = [];
        return x.isUndefined(e) && (e = "&"), x.each(t, function(i, a) {
            n = encodeURIComponent(i.toString()), r = encodeURIComponent(a), s[s.length] = r + "=" + n
        }), s.join(e)
    };
    x.getQueryParam = function(t, e) {
        e = e.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
        var n = "[\\?&]" + e + "=([^&#]*)",
            r = new RegExp(n),
            s = r.exec(t);
        if (s === null || s && typeof s[1] != "string" && s[1].length) return "";
        var i = s[1];
        try {
            i = decodeURIComponent(i)
        } catch {
            Lt.error("Skipping decoding for malformed query param: " + i)
        }
        return i.replace(/\+/g, " ")
    };
    x.cookie = {
        get: function(t) {
            for (var e = t + "=", n = qt.cookie.split(";"), r = 0; r < n.length; r++) {
                for (var s = n[r]; s.charAt(0) == " ";) s = s.substring(1, s.length);
                if (s.indexOf(e) === 0) return decodeURIComponent(s.substring(e.length, s.length))
            }
            return null
        },
        parse: function(t) {
            var e;
            try {
                e = x.JSONDecode(x.cookie.get(t)) || {}
            } catch {}
            return e
        },
        set_seconds: function(t, e, n, r, s, i, a) {
            var c = "",
                l = "",
                h = "";
            if (a) c = "; domain=" + a;
            else if (r) {
                var d = xS(qt.location.hostname);
                c = d ? "; domain=." + d : ""
            }
            if (n) {
                var p = new Date;
                p.setTime(p.getTime() + n * 1e3), l = "; expires=" + p.toGMTString()
            }
            i && (s = !0, h = "; SameSite=None"), s && (h += "; secure"), qt.cookie = t + "=" + encodeURIComponent(e) + l + "; path=/" + c + h
        },
        set: function(t, e, n, r, s, i, a) {
            var c = "",
                l = "",
                h = "";
            if (a) c = "; domain=" + a;
            else if (r) {
                var d = xS(qt.location.hostname);
                c = d ? "; domain=." + d : ""
            }
            if (n) {
                var p = new Date;
                p.setTime(p.getTime() + n * 24 * 60 * 60 * 1e3), l = "; expires=" + p.toGMTString()
            }
            i && (s = !0, h = "; SameSite=None"), s && (h += "; secure");
            var g = t + "=" + encodeURIComponent(e) + l + "; path=/" + c + h;
            return qt.cookie = g, g
        },
        remove: function(t, e, n) {
            x.cookie.set(t, "", -1, e, !1, !1, n)
        }
    };
    var s_ = null,
        ld = function(t, e) {
            if (s_ !== null && !e) return s_;
            var n = !0;
            try {
                t = t || window.localStorage;
                var r = "__mplss_" + Zy(8),
                    s = "xyz";
                t.setItem(r, s), t.getItem(r) !== s && (n = !1), t.removeItem(r)
            } catch {
                n = !1
            }
            return s_ = n, n
        };
    x.localStorage = {
        is_supported: function(t) {
            var e = ld(null, t);
            return e || Lt.error("localStorage unsupported; falling back to cookie store"), e
        },
        error: function(t) {
            Lt.error("localStorage error: " + t)
        },
        get: function(t) {
            try {
                return window.localStorage.getItem(t)
            } catch (e) {
                x.localStorage.error(e)
            }
            return null
        },
        parse: function(t) {
            try {
                return x.JSONDecode(x.localStorage.get(t)) || {}
            } catch {}
            return null
        },
        set: function(t, e) {
            try {
                window.localStorage.setItem(t, e)
            } catch (n) {
                x.localStorage.error(n)
            }
        },
        remove: function(t) {
            try {
                window.localStorage.removeItem(t)
            } catch (e) {
                x.localStorage.error(e)
            }
        }
    };
    x.register_event = function() {
        var t = function(r, s, i, a, c) {
            if (!r) {
                Lt.error("No valid element provided to register_event");
                return
            }
            if (r.addEventListener && !a) r.addEventListener(s, i, !!c);
            else {
                var l = "on" + s,
                    h = r[l];
                r[l] = e(r, i, h)
            }
        };

        function e(r, s, i) {
            var a = function(c) {
                if (c = c || n(window.event), !!c) {
                    var l = !0,
                        h, d;
                    return x.isFunction(i) && (h = i(c)), d = s.call(r, c), (h === !1 || d === !1) && (l = !1), l
                }
            };
            return a
        }

        function n(r) {
            return r && (r.preventDefault = n.preventDefault, r.stopPropagation = n.stopPropagation), r
        }
        return n.preventDefault = function() {
            this.returnValue = !1
        }, n.stopPropagation = function() {
            this.cancelBubble = !0
        }, t
    }();
    var XD = new RegExp('^(\\w*)\\[(\\w+)([=~\\|\\^\\$\\*]?)=?"?([^\\]"]*)"?\\]$');
    x.dom_query = function() {
        function t(s) {
            return s.all ? s.all : s.getElementsByTagName("*")
        }
        var e = /[\t\r\n]/g;

        function n(s, i) {
            var a = " " + i + " ";
            return (" " + s.className + " ").replace(e, " ").indexOf(a) >= 0
        }

        function r(s) {
            if (!qt.getElementsByTagName) return [];
            var i = s.split(" "),
                a, c, l, h, d, p, g, v, b, T, m = [qt];
            for (p = 0; p < i.length; p++) {
                if (a = i[p].replace(/^\s+/, "").replace(/\s+$/, ""), a.indexOf("#") > -1) {
                    c = a.split("#"), l = c[0];
                    var w = c[1],
                        P = qt.getElementById(w);
                    if (!P || l && P.nodeName.toLowerCase() != l) return [];
                    m = [P];
                    continue
                }
                if (a.indexOf(".") > -1) {
                    c = a.split("."), l = c[0];
                    var V = c[1];
                    for (l || (l = "*"), h = [], d = 0, g = 0; g < m.length; g++)
                        for (l == "*" ? b = t(m[g]) : b = m[g].getElementsByTagName(l), v = 0; v < b.length; v++) h[d++] = b[v];
                    for (m = [], T = 0, g = 0; g < h.length; g++) h[g].className && x.isString(h[g].className) && n(h[g], V) && (m[T++] = h[g]);
                    continue
                }
                var M = a.match(XD);
                if (M) {
                    l = M[1];
                    var I = M[2],
                        L = M[3],
                        B = M[4];
                    for (l || (l = "*"), h = [], d = 0, g = 0; g < m.length; g++)
                        for (l == "*" ? b = t(m[g]) : b = m[g].getElementsByTagName(l), v = 0; v < b.length; v++) h[d++] = b[v];
                    m = [], T = 0;
                    var q;
                    switch (L) {
                        case "=":
                            q = function(se) {
                                return se.getAttribute(I) == B
                            };
                            break;
                        case "~":
                            q = function(se) {
                                return se.getAttribute(I).match(new RegExp("\\b" + B + "\\b"))
                            };
                            break;
                        case "|":
                            q = function(se) {
                                return se.getAttribute(I).match(new RegExp("^" + B + "-?"))
                            };
                            break;
                        case "^":
                            q = function(se) {
                                return se.getAttribute(I).indexOf(B) === 0
                            };
                            break;
                        case "$":
                            q = function(se) {
                                return se.getAttribute(I).lastIndexOf(B) == se.getAttribute(I).length - B.length
                            };
                            break;
                        case "*":
                            q = function(se) {
                                return se.getAttribute(I).indexOf(B) > -1
                            };
                            break;
                        default:
                            q = function(se) {
                                return se.getAttribute(I)
                            }
                    }
                    for (m = [], T = 0, g = 0; g < h.length; g++) q(h[g]) && (m[T++] = h[g]);
                    continue
                }
                for (l = a, h = [], d = 0, g = 0; g < m.length; g++)
                    for (b = m[g].getElementsByTagName(l), v = 0; v < b.length; v++) h[d++] = b[v];
                m = h
            }
            return m
        }
        return function(s) {
            return x.isElement(s) ? [s] : x.isObject(s) && !x.isUndefined(s.length) ? s : r.call(this, s)
        }
    }();
    x.info = {
        campaignParams: function() {
            var t = "utm_source utm_medium utm_campaign utm_content utm_term".split(" "),
                e = "",
                n = {};
            return x.each(t, function(r) {
                e = x.getQueryParam(qt.URL, r), e.length && (n[r] = e)
            }), n
        },
        searchEngine: function(t) {
            return t.search("https?://(.*)google.([^/?]*)") === 0 ? "google" : t.search("https?://(.*)bing.com") === 0 ? "bing" : t.search("https?://(.*)yahoo.com") === 0 ? "yahoo" : t.search("https?://(.*)duckduckgo.com") === 0 ? "duckduckgo" : null
        },
        searchInfo: function(t) {
            var e = x.info.searchEngine(t),
                n = e != "yahoo" ? "q" : "p",
                r = {};
            if (e !== null) {
                r.$search_engine = e;
                var s = x.getQueryParam(t, n);
                s.length && (r.mp_keyword = s)
            }
            return r
        },
        browser: function(t, e, n) {
            return e = e || "", n || x.includes(t, " OPR/") ? x.includes(t, "Mini") ? "Opera Mini" : "Opera" : /(BlackBerry|PlayBook|BB10)/i.test(t) ? "BlackBerry" : x.includes(t, "IEMobile") || x.includes(t, "WPDesktop") ? "Internet Explorer Mobile" : x.includes(t, "SamsungBrowser/") ? "Samsung Internet" : x.includes(t, "Edge") || x.includes(t, "Edg/") ? "Microsoft Edge" : x.includes(t, "FBIOS") ? "Facebook Mobile" : x.includes(t, "Chrome") ? "Chrome" : x.includes(t, "CriOS") ? "Chrome iOS" : x.includes(t, "UCWEB") || x.includes(t, "UCBrowser") ? "UC Browser" : x.includes(t, "FxiOS") ? "Firefox iOS" : x.includes(e, "Apple") ? x.includes(t, "Mobile") ? "Mobile Safari" : "Safari" : x.includes(t, "Android") ? "Android Mobile" : x.includes(t, "Konqueror") ? "Konqueror" : x.includes(t, "Firefox") ? "Firefox" : x.includes(t, "MSIE") || x.includes(t, "Trident/") ? "Internet Explorer" : x.includes(t, "Gecko") ? "Mozilla" : ""
        },
        browserVersion: function(t, e, n) {
            var r = x.info.browser(t, e, n),
                s = {
                    "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
                    "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/,
                    Chrome: /Chrome\/(\d+(\.\d+)?)/,
                    "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
                    "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
                    Safari: /Version\/(\d+(\.\d+)?)/,
                    "Mobile Safari": /Version\/(\d+(\.\d+)?)/,
                    Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/,
                    Firefox: /Firefox\/(\d+(\.\d+)?)/,
                    "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
                    Konqueror: /Konqueror:(\d+(\.\d+)?)/,
                    BlackBerry: /BlackBerry (\d+(\.\d+)?)/,
                    "Android Mobile": /android\s(\d+(\.\d+)?)/,
                    "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/,
                    "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
                    Mozilla: /rv:(\d+(\.\d+)?)/
                },
                i = s[r];
            if (i === void 0) return null;
            var a = t.match(i);
            return a ? parseFloat(a[a.length - 2]) : null
        },
        os: function() {
            var t = ms;
            return /Windows/i.test(t) ? /Phone/.test(t) || /WPDesktop/.test(t) ? "Windows Phone" : "Windows" : /(iPhone|iPad|iPod)/.test(t) ? "iOS" : /Android/.test(t) ? "Android" : /(BlackBerry|PlayBook|BB10)/i.test(t) ? "BlackBerry" : /Mac/i.test(t) ? "Mac OS X" : /Linux/.test(t) ? "Linux" : /CrOS/.test(t) ? "Chrome OS" : ""
        },
        device: function(t) {
            return /Windows Phone/i.test(t) || /WPDesktop/.test(t) ? "Windows Phone" : /iPad/.test(t) ? "iPad" : /iPod/.test(t) ? "iPod Touch" : /iPhone/.test(t) ? "iPhone" : /(BlackBerry|PlayBook|BB10)/i.test(t) ? "BlackBerry" : /Android/.test(t) ? "Android" : ""
        },
        referringDomain: function(t) {
            var e = t.split("/");
            return e.length >= 3 ? e[2] : ""
        },
        properties: function() {
            return x.extend(x.strip_empty_properties({
                $os: x.info.os(),
                $browser: x.info.browser(ms, Oi.vendor, Lu),
                $referrer: qt.referrer,
                $referring_domain: x.info.referringDomain(qt.referrer),
                $device: x.info.device(ms)
            }), {
                $current_url: nr.location.href,
                $browser_version: x.info.browserVersion(ms, Oi.vendor, Lu),
                $screen_height: ud.height,
                $screen_width: ud.width,
                mp_lib: "web",
                $lib_version: go.LIB_VERSION,
                $insert_id: Zy(),
                time: x.timestamp() / 1e3
            })
        },
        people_properties: function() {
            return x.extend(x.strip_empty_properties({
                $os: x.info.os(),
                $browser: x.info.browser(ms, Oi.vendor, Lu)
            }), {
                $browser_version: x.info.browserVersion(ms, Oi.vendor, Lu)
            })
        },
        pageviewInfo: function(t) {
            return x.strip_empty_properties({
                mp_page: t,
                mp_referrer: qt.referrer,
                mp_browser: x.info.browser(ms, Oi.vendor, Lu),
                mp_platform: x.info.os()
            })
        }
    };
    var Zy = function(t) {
            var e = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);
            return t ? e.substring(0, t) : e
        },
        QD = /[a-z0-9][a-z0-9-]*\.[a-z]+$/i,
        JD = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i,
        xS = function(t) {
            var e = JD,
                n = t.split("."),
                r = n[n.length - 1];
            (r.length > 4 || r === "com" || r === "org") && (e = QD);
            var s = t.match(e);
            return s ? s[0] : ""
        },
        hd = null,
        fd = null;
    typeof JSON < "u" && (hd = JSON.stringify, fd = JSON.parse);
    hd = hd || x.JSONEncode;
    fd = fd || x.JSONDecode;
    x.toArray = x.toArray;
    x.isObject = x.isObject;
    x.JSONEncode = x.JSONEncode;
    x.JSONDecode = x.JSONDecode;
    x.isBlockedUA = x.isBlockedUA;
    x.isEmptyObject = x.isEmptyObject;
    x.info = x.info;
    x.info.device = x.info.device;
    x.info.browser = x.info.browser;
    x.info.browserVersion = x.info.browserVersion;
    x.info.properties = x.info.properties;
    var Fi = function() {};
    Fi.prototype.create_properties = function() {};
    Fi.prototype.event_handler = function() {};
    Fi.prototype.after_track_handler = function() {};
    Fi.prototype.init = function(t) {
        return this.mp = t, this
    };
    Fi.prototype.track = function(t, e, n, r) {
        var s = this,
            i = x.dom_query(t);
        if (i.length === 0) {
            Lt.error("The DOM query (" + t + ") returned 0 elements");
            return
        }
        return x.each(i, function(a) {
            x.register_event(a, this.override_event, function(c) {
                var l = {},
                    h = s.create_properties(n, this),
                    d = s.mp.get_config("track_links_timeout");
                s.event_handler(c, this, l), window.setTimeout(s.track_callback(r, h, l, !0), d), s.mp.track(e, h, s.track_callback(r, h, l))
            })
        }, this), !0
    };
    Fi.prototype.track_callback = function(t, e, n, r) {
        r = r || !1;
        var s = this;
        return function() {
            n.callback_fired || (n.callback_fired = !0, !(t && t(r, e) === !1) && s.after_track_handler(e, n, r))
        }
    };
    Fi.prototype.create_properties = function(t, e) {
        var n;
        return typeof t == "function" ? n = t(e) : n = x.extend({}, t), n
    };
    var Rc = function() {
        this.override_event = "click"
    };
    x.inherit(Rc, Fi);
    Rc.prototype.create_properties = function(t, e) {
        var n = Rc.superclass.create_properties.apply(this, arguments);
        return e.href && (n.url = e.href), n
    };
    Rc.prototype.event_handler = function(t, e, n) {
        n.new_tab = t.which === 2 || t.metaKey || t.ctrlKey || e.target === "_blank", n.href = e.href, n.new_tab || t.preventDefault()
    };
    Rc.prototype.after_track_handler = function(t, e) {
        e.new_tab || setTimeout(function() {
            window.location = e.href
        }, 0)
    };
    var jp = function() {
        this.override_event = "submit"
    };
    x.inherit(jp, Fi);
    jp.prototype.event_handler = function(t, e, n) {
        n.element = e, t.preventDefault()
    };
    jp.prototype.after_track_handler = function(t, e) {
        setTimeout(function() {
            e.element.submit()
        }, 0)
    };
    var e$ = zy("lock"),
        o4 = function(t, e) {
            e = e || {}, this.storageKey = t, this.storage = e.storage || window.localStorage, this.pollIntervalMS = e.pollIntervalMS || 100, this.timeoutMS = e.timeoutMS || 2e3
        };
    o4.prototype.withLock = function(t, e, n) {
        !n && typeof e != "function" && (n = e, e = null);
        var r = n || new Date().getTime() + "|" + Math.random(),
            s = new Date().getTime(),
            i = this.storageKey,
            a = this.pollIntervalMS,
            c = this.timeoutMS,
            l = this.storage,
            h = i + ":X",
            d = i + ":Y",
            p = i + ":Z",
            g = function(P) {
                e && e(P)
            },
            v = function(P) {
                if (new Date().getTime() - s > c) {
                    e$.error("Timeout waiting for mutex on " + i + "; clearing lock. [" + r + "]"), l.removeItem(p), l.removeItem(d), m();
                    return
                }
                setTimeout(function() {
                    try {
                        P()
                    } catch (V) {
                        g(V)
                    }
                }, a * (Math.random() + .1))
            },
            b = function(P, V) {
                P() ? V() : v(function() {
                    b(P, V)
                })
            },
            T = function() {
                var P = l.getItem(d);
                if (P && P !== r) return !1;
                if (l.setItem(d, r), l.getItem(d) === r) return !0;
                if (!ld(l, !0)) throw new Error("localStorage support dropped while acquiring lock");
                return !1
            },
            m = function() {
                l.setItem(h, r), b(T, function() {
                    if (l.getItem(h) === r) {
                        w();
                        return
                    }
                    v(function() {
                        if (l.getItem(d) !== r) {
                            m();
                            return
                        }
                        b(function() {
                            return !l.getItem(p)
                        }, w)
                    })
                })
            },
            w = function() {
                l.setItem(p, "1");
                try {
                    t()
                } finally {
                    l.removeItem(p), l.getItem(d) === r && l.removeItem(d), l.getItem(h) === r && l.removeItem(h)
                }
            };
        try {
            if (ld(l, !0)) m();
            else throw new Error("localStorage support check failed")
        } catch (P) {
            g(P)
        }
    };
    var PS = zy("batch"),
        No = function(t, e) {
            e = e || {}, this.storageKey = t, this.storage = e.storage || window.localStorage, this.reportError = e.errorReporter || x.bind(PS.error, PS), this.lock = new o4(t, {
                storage: this.storage
            }), this.pid = e.pid || null, this.memQueue = []
        };
    No.prototype.enqueue = function(t, e, n) {
        var r = {
            id: Zy(),
            flushAfter: new Date().getTime() + e * 2,
            payload: t
        };
        this.lock.withLock(x.bind(function() {
            var i;
            try {
                var a = this.readFromStorage();
                a.push(r), i = this.saveToStorage(a), i && this.memQueue.push(r)
            } catch {
                this.reportError("Error enqueueing item", t), i = !1
            }
            n && n(i)
        }, this), x.bind(function(i) {
            this.reportError("Error acquiring storage lock", i), n && n(!1)
        }, this), this.pid)
    };
    No.prototype.fillBatch = function(t) {
        var e = this.memQueue.slice(0, t);
        if (e.length < t) {
            var n = this.readFromStorage();
            if (n.length) {
                var r = {};
                x.each(e, function(a) {
                    r[a.id] = !0
                });
                for (var s = 0; s < n.length; s++) {
                    var i = n[s];
                    if (new Date().getTime() > i.flushAfter && !r[i.id] && (i.orphaned = !0, e.push(i), e.length >= t)) break
                }
            }
        }
        return e
    };
    var RS = function(t, e) {
        var n = [];
        return x.each(t, function(r) {
            r.id && !e[r.id] && n.push(r)
        }), n
    };
    No.prototype.removeItemsByID = function(t, e) {
        var n = {};
        x.each(t, function(s) {
            n[s] = !0
        }), this.memQueue = RS(this.memQueue, n);
        var r = x.bind(function() {
            var s;
            try {
                var i = this.readFromStorage();
                if (i = RS(i, n), s = this.saveToStorage(i), s) {
                    i = this.readFromStorage();
                    for (var a = 0; a < i.length; a++) {
                        var c = i[a];
                        if (c.id && n[c.id]) return this.reportError("Item not removed from storage"), !1
                    }
                }
            } catch {
                this.reportError("Error removing items", t), s = !1
            }
            return s
        }, this);
        this.lock.withLock(function() {
            var i = r();
            e && e(i)
        }, x.bind(function(i) {
            var a = !1;
            if (this.reportError("Error acquiring storage lock", i), !ld(this.storage, !0) && (a = r(), !a)) try {
                this.storage.removeItem(this.storageKey)
            } catch (c) {
                this.reportError("Error clearing queue", c)
            }
            e && e(a)
        }, this), this.pid)
    };
    var MS = function(t, e) {
        var n = [];
        return x.each(t, function(r) {
            var s = r.id;
            if (s in e) {
                var i = e[s];
                i !== null && (r.payload = i, n.push(r))
            } else n.push(r)
        }), n
    };
    No.prototype.updatePayloads = function(t, e) {
        this.memQueue = MS(this.memQueue, t), this.lock.withLock(x.bind(function() {
            var r;
            try {
                var s = this.readFromStorage();
                s = MS(s, t), r = this.saveToStorage(s)
            } catch {
                this.reportError("Error updating items", t), r = !1
            }
            e && e(r)
        }, this), x.bind(function(r) {
            this.reportError("Error acquiring storage lock", r), e && e(!1)
        }, this), this.pid)
    };
    No.prototype.readFromStorage = function() {
        var t;
        try {
            t = this.storage.getItem(this.storageKey), t && (t = fd(t), x.isArray(t) || (this.reportError("Invalid storage entry:", t), t = null))
        } catch (e) {
            this.reportError("Error retrieving queue", e), t = null
        }
        return t || []
    };
    No.prototype.saveToStorage = function(t) {
        try {
            return this.storage.setItem(this.storageKey, hd(t)), !0
        } catch (e) {
            return this.reportError("Error saving queue", e), !1
        }
    };
    No.prototype.clear = function() {
        this.memQueue = [], this.storage.removeItem(this.storageKey)
    };
    var t$ = 10 * 60 * 1e3,
        Zu = zy("batch"),
        si = function(t, e) {
            this.errorReporter = e.errorReporter, this.queue = new No(t, {
                errorReporter: x.bind(this.reportError, this),
                storage: e.storage
            }), this.libConfig = e.libConfig, this.sendRequest = e.sendRequestFunc, this.beforeSendHook = e.beforeSendHook, this.stopAllBatching = e.stopAllBatchingFunc, this.batchSize = this.libConfig.batch_size, this.flushInterval = this.libConfig.batch_flush_interval_ms, this.stopped = !this.libConfig.batch_autostart, this.consecutiveRemovalFailures = 0
        };
    si.prototype.enqueue = function(t, e) {
        this.queue.enqueue(t, this.flushInterval, e)
    };
    si.prototype.start = function() {
        this.stopped = !1, this.consecutiveRemovalFailures = 0, this.flush()
    };
    si.prototype.stop = function() {
        this.stopped = !0, this.timeoutID && (clearTimeout(this.timeoutID), this.timeoutID = null)
    };
    si.prototype.clear = function() {
        this.queue.clear()
    };
    si.prototype.resetBatchSize = function() {
        this.batchSize = this.libConfig.batch_size
    };
    si.prototype.resetFlush = function() {
        this.scheduleFlush(this.libConfig.batch_flush_interval_ms)
    };
    si.prototype.scheduleFlush = function(t) {
        this.flushInterval = t, this.stopped || (this.timeoutID = setTimeout(x.bind(this.flush, this), this.flushInterval))
    };
    si.prototype.flush = function(t) {
        try {
            if (this.requestInProgress) {
                Zu.log("Flush: Request already in progress");
                return
            }
            t = t || {};
            var e = this.libConfig.batch_request_timeout_ms,
                n = new Date().getTime(),
                r = this.batchSize,
                s = this.queue.fillBatch(r),
                i = [],
                a = {};
            if (x.each(s, function(h) {
                    var d = h.payload;
                    this.beforeSendHook && !h.orphaned && (d = this.beforeSendHook(d)), d && i.push(d), a[h.id] = d
                }, this), i.length < 1) {
                this.resetFlush();
                return
            }
            this.requestInProgress = !0;
            var c = x.bind(function(h) {
                    this.requestInProgress = !1;
                    try {
                        var d = !1;
                        if (t.unloading) this.queue.updatePayloads(a);
                        else if (x.isObject(h) && h.error === "timeout" && new Date().getTime() - n >= e) this.reportError("Network timeout; retrying"), this.flush();
                        else if (x.isObject(h) && h.xhr_req && (h.xhr_req.status >= 500 || h.xhr_req.status === 429 || h.error === "timeout")) {
                            var p = this.flushInterval * 2,
                                g = h.xhr_req.responseHeaders;
                            if (g) {
                                var v = g["Retry-After"];
                                v && (p = parseInt(v, 10) * 1e3 || p)
                            }
                            p = Math.min(t$, p), this.reportError("Error; retry in " + p + " ms"), this.scheduleFlush(p)
                        } else if (x.isObject(h) && h.xhr_req && h.xhr_req.status === 413)
                            if (s.length > 1) {
                                var b = Math.max(1, Math.floor(r / 2));
                                this.batchSize = Math.min(this.batchSize, b, s.length - 1), this.reportError("413 response; reducing batch size to " + this.batchSize), this.resetFlush()
                            } else this.reportError("Single-event request too large; dropping", s), this.resetBatchSize(), d = !0;
                        else d = !0;
                        d && this.queue.removeItemsByID(x.map(s, function(T) {
                            return T.id
                        }), x.bind(function(T) {
                            T ? (this.consecutiveRemovalFailures = 0, this.flush()) : (this.reportError("Failed to remove items from queue"), ++this.consecutiveRemovalFailures > 5 ? (this.reportError("Too many queue failures; disabling batching system."), this.stopAllBatching()) : this.resetFlush())
                        }, this))
                    } catch (T) {
                        this.reportError("Error handling API response", T), this.resetFlush()
                    }
                }, this),
                l = {
                    method: "POST",
                    verbose: !0,
                    ignore_json_errors: !0,
                    timeout_ms: e
                };
            t.unloading && (l.transport = "sendBeacon"), Zu.log("MIXPANEL REQUEST:", i), this.sendRequest(i, l, c)
        } catch (h) {
            this.reportError("Error flushing request queue", h), this.resetFlush()
        }
    };
    si.prototype.reportError = function(t, e) {
        if (Zu.error.apply(Zu.error, arguments), this.errorReporter) try {
            e instanceof Error || (e = new Error(t)), this.errorReporter(t, e)
        } catch (n) {
            Zu.error(n)
        }
    };
    var n$ = "__mp_opt_in_out_";

    function r$(t, e) {
        u4(!0, t, e)
    }

    function s$(t, e) {
        u4(!1, t, e)
    }

    function i$(t, e) {
        return c4(t, e) === "1"
    }

    function a4(t, e) {
        if (a$(e)) return Lt.warn('This browser has "Do Not Track" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the "Do Not Track" browser setting, initialize the Mixpanel instance with the config "ignore_dnt: true"'), !0;
        var n = c4(t, e) === "0";
        return n && Lt.warn("You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data."), n
    }

    function zl(t) {
        return Jy(t, function(e) {
            return this.get_config(e)
        })
    }

    function xo(t) {
        return Jy(t, function(e) {
            return this._get_config(e)
        })
    }

    function tu(t) {
        return Jy(t, function(e) {
            return this._get_config(e)
        })
    }

    function o$(t, e) {
        e = e || {}, Xy(e).remove(Qy(t, e), !!e.crossSubdomainCookie, e.cookieDomain)
    }

    function Xy(t) {
        return t = t || {}, t.persistenceType === "localStorage" ? x.localStorage : x.cookie
    }

    function Qy(t, e) {
        return e = e || {}, (e.persistencePrefix || n$) + t
    }

    function c4(t, e) {
        return Xy(e).get(Qy(t, e))
    }

    function a$(t) {
        if (t && t.ignoreDnt) return !1;
        var e = t && t.window || nr,
            n = e.navigator || {},
            r = !1;
        return x.each([n.doNotTrack, n.msDoNotTrack, e.doNotTrack], function(s) {
            x.includes([!0, 1, "1", "yes"], s) && (r = !0)
        }), r
    }

    function u4(t, e, n) {
        if (!x.isString(e) || !e.length) {
            Lt.error("gdpr." + (t ? "optIn" : "optOut") + " called with an invalid token");
            return
        }
        n = n || {}, Xy(n).set(Qy(e, n), t ? 1 : 0, x.isNumber(n.cookieExpiration) ? n.cookieExpiration : null, !!n.crossSubdomainCookie, !!n.secureCookie, !!n.crossSiteCookie, n.cookieDomain), n.track && t && n.track(n.trackEventName || "$opt_in", n.trackProperties, {
            send_immediately: !0
        })
    }

    function Jy(t, e) {
        return function() {
            var n = !1;
            try {
                var r = e.call(this, "token"),
                    s = e.call(this, "ignore_dnt"),
                    i = e.call(this, "opt_out_tracking_persistence_type"),
                    a = e.call(this, "opt_out_tracking_cookie_prefix"),
                    c = e.call(this, "window");
                r && (n = a4(r, {
                    ignoreDnt: s,
                    persistenceType: i,
                    persistencePrefix: a,
                    window: c
                }))
            } catch (h) {
                Lt.error("Unexpected error when checking tracking opt-out status: " + h)
            }
            if (!n) return t.apply(this, arguments);
            var l = arguments[arguments.length - 1];
            typeof l == "function" && l(0)
        }
    }
    var So = "$set",
        Mc = "$set_once",
        gs = "$unset",
        ba = "$add",
        Pi = "$append",
        Ea = "$union",
        To = "$remove",
        c$ = "$delete",
        l4 = {
            set_action: function(t, e) {
                var n = {},
                    r = {};
                return x.isObject(t) ? x.each(t, function(s, i) {
                    this._is_reserved_property(i) || (r[i] = s)
                }, this) : r[t] = e, n[So] = r, n
            },
            unset_action: function(t) {
                var e = {},
                    n = [];
                return x.isArray(t) || (t = [t]), x.each(t, function(r) {
                    this._is_reserved_property(r) || n.push(r)
                }, this), e[gs] = n, e
            },
            set_once_action: function(t, e) {
                var n = {},
                    r = {};
                return x.isObject(t) ? x.each(t, function(s, i) {
                    this._is_reserved_property(i) || (r[i] = s)
                }, this) : r[t] = e, n[Mc] = r, n
            },
            union_action: function(t, e) {
                var n = {},
                    r = {};
                return x.isObject(t) ? x.each(t, function(s, i) {
                    this._is_reserved_property(i) || (r[i] = x.isArray(s) ? s : [s])
                }, this) : r[t] = x.isArray(e) ? e : [e], n[Ea] = r, n
            },
            append_action: function(t, e) {
                var n = {},
                    r = {};
                return x.isObject(t) ? x.each(t, function(s, i) {
                    this._is_reserved_property(i) || (r[i] = s)
                }, this) : r[t] = e, n[Pi] = r, n
            },
            remove_action: function(t, e) {
                var n = {},
                    r = {};
                return x.isObject(t) ? x.each(t, function(s, i) {
                    this._is_reserved_property(i) || (r[i] = s)
                }, this) : r[t] = e, n[To] = r, n
            },
            delete_action: function() {
                var t = {};
                return t[c$] = "", t
            }
        },
        en = function() {};
    x.extend(en.prototype, l4);
    en.prototype._init = function(t, e, n) {
        this._mixpanel = t, this._group_key = e, this._group_id = n
    };
    en.prototype.set = tu(function(t, e, n) {
        var r = this.set_action(t, e);
        return x.isObject(t) && (n = e), this._send_request(r, n)
    });
    en.prototype.set_once = tu(function(t, e, n) {
        var r = this.set_once_action(t, e);
        return x.isObject(t) && (n = e), this._send_request(r, n)
    });
    en.prototype.unset = tu(function(t, e) {
        var n = this.unset_action(t);
        return this._send_request(n, e)
    });
    en.prototype.union = tu(function(t, e, n) {
        x.isObject(t) && (n = e);
        var r = this.union_action(t, e);
        return this._send_request(r, n)
    });
    en.prototype.delete = tu(function(t) {
        var e = this.delete_action();
        return this._send_request(e, t)
    });
    en.prototype.remove = tu(function(t, e, n) {
        var r = this.remove_action(t, e);
        return this._send_request(r, n)
    });
    en.prototype._send_request = function(t, e) {
        t.$group_key = this._group_key, t.$group_id = this._group_id, t.$token = this._get_config("token");
        var n = x.encodeDates(t);
        return this._mixpanel._track_or_batch({
            type: "groups",
            data: n,
            endpoint: this._get_config("api_host") + "/groups/",
            batcher: this._mixpanel.request_batchers.groups
        }, e)
    };
    en.prototype._is_reserved_property = function(t) {
        return t === "$group_key" || t === "$group_id"
    };
    en.prototype._get_config = function(t) {
        return this._mixpanel.get_config(t)
    };
    en.prototype.toString = function() {
        return this._mixpanel.toString() + ".group." + this._group_key + "." + this._group_id
    };
    en.prototype.remove = en.prototype.remove;
    en.prototype.set = en.prototype.set;
    en.prototype.set_once = en.prototype.set_once;
    en.prototype.union = en.prototype.union;
    en.prototype.unset = en.prototype.unset;
    en.prototype.toString = en.prototype.toString;
    var it = function() {};
    x.extend(it.prototype, l4);
    it.prototype._init = function(t) {
        this._mixpanel = t
    };
    it.prototype.set = xo(function(t, e, n) {
        var r = this.set_action(t, e);
        return x.isObject(t) && (n = e), this._get_config("save_referrer") && this._mixpanel.persistence.update_referrer_info(document.referrer), r[So] = x.extend({}, x.info.people_properties(), this._mixpanel.persistence.get_referrer_info(), r[So]), this._send_request(r, n)
    });
    it.prototype.set_once = xo(function(t, e, n) {
        var r = this.set_once_action(t, e);
        return x.isObject(t) && (n = e), this._send_request(r, n)
    });
    it.prototype.unset = xo(function(t, e) {
        var n = this.unset_action(t);
        return this._send_request(n, e)
    });
    it.prototype.increment = xo(function(t, e, n) {
        var r = {},
            s = {};
        return x.isObject(t) ? (x.each(t, function(i, a) {
            if (!this._is_reserved_property(a))
                if (isNaN(parseFloat(i))) {
                    Lt.error("Invalid increment value passed to mixpanel.people.increment - must be a number");
                    return
                } else s[a] = i
        }, this), n = e) : (x.isUndefined(e) && (e = 1), s[t] = e), r[ba] = s, this._send_request(r, n)
    });
    it.prototype.append = xo(function(t, e, n) {
        x.isObject(t) && (n = e);
        var r = this.append_action(t, e);
        return this._send_request(r, n)
    });
    it.prototype.remove = xo(function(t, e, n) {
        x.isObject(t) && (n = e);
        var r = this.remove_action(t, e);
        return this._send_request(r, n)
    });
    it.prototype.union = xo(function(t, e, n) {
        x.isObject(t) && (n = e);
        var r = this.union_action(t, e);
        return this._send_request(r, n)
    });
    it.prototype.track_charge = xo(function(t, e, n) {
        if (!x.isNumber(t) && (t = parseFloat(t), isNaN(t))) {
            Lt.error("Invalid value passed to mixpanel.people.track_charge - must be a number");
            return
        }
        return this.append("$transactions", x.extend({
            $amount: t
        }, e), n)
    });
    it.prototype.clear_charges = function(t) {
        return this.set("$transactions", [], t)
    };
    it.prototype.delete_user = function() {
        if (!this._identify_called()) {
            Lt.error("mixpanel.people.delete_user() requires you to call identify() first");
            return
        }
        var t = {
            $delete: this._mixpanel.get_distinct_id()
        };
        return this._send_request(t)
    };
    it.prototype.toString = function() {
        return this._mixpanel.toString() + ".people"
    };
    it.prototype._send_request = function(t, e) {
        t.$token = this._get_config("token"), t.$distinct_id = this._mixpanel.get_distinct_id();
        var n = this._mixpanel.get_property("$device_id"),
            r = this._mixpanel.get_property("$user_id"),
            s = this._mixpanel.get_property("$had_persisted_distinct_id");
        n && (t.$device_id = n), r && (t.$user_id = r), s && (t.$had_persisted_distinct_id = s);
        var i = x.encodeDates(t);
        return this._identify_called() ? this._mixpanel._track_or_batch({
            type: "people",
            data: i,
            endpoint: this._get_config("api_host") + "/engage/",
            batcher: this._mixpanel.request_batchers.people
        }, e) : (this._enqueue(t), x.isUndefined(e) || (this._get_config("verbose") ? e({
            status: -1,
            error: null
        }) : e(-1)), x.truncate(i, 255))
    };
    it.prototype._get_config = function(t) {
        return this._mixpanel.get_config(t)
    };
    it.prototype._identify_called = function() {
        return this._mixpanel._flags.identify_called === !0
    };
    it.prototype._enqueue = function(t) {
        So in t ? this._mixpanel.persistence._add_to_people_queue(So, t) : Mc in t ? this._mixpanel.persistence._add_to_people_queue(Mc, t) : gs in t ? this._mixpanel.persistence._add_to_people_queue(gs, t) : ba in t ? this._mixpanel.persistence._add_to_people_queue(ba, t) : Pi in t ? this._mixpanel.persistence._add_to_people_queue(Pi, t) : To in t ? this._mixpanel.persistence._add_to_people_queue(To, t) : Ea in t ? this._mixpanel.persistence._add_to_people_queue(Ea, t) : Lt.error("Invalid call to _enqueue():", t)
    };
    it.prototype._flush_one_queue = function(t, e, n, r) {
        var s = this,
            i = x.extend({}, this._mixpanel.persistence._get_queue(t)),
            a = i;
        !x.isUndefined(i) && x.isObject(i) && !x.isEmptyObject(i) && (s._mixpanel.persistence._pop_from_people_queue(t, i), r && (a = r(i)), e.call(s, a, function(c, l) {
            c === 0 && s._mixpanel.persistence._add_to_people_queue(t, i), x.isUndefined(n) || n(c, l)
        }))
    };
    it.prototype._flush = function(t, e, n, r, s, i, a) {
        var c = this,
            l = this._mixpanel.persistence._get_queue(Pi),
            h = this._mixpanel.persistence._get_queue(To);
        if (this._flush_one_queue(So, this.set, t), this._flush_one_queue(Mc, this.set_once, r), this._flush_one_queue(gs, this.unset, i, function(m) {
                return x.keys(m)
            }), this._flush_one_queue(ba, this.increment, e), this._flush_one_queue(Ea, this.union, s), !x.isUndefined(l) && x.isArray(l) && l.length) {
            for (var d, p = function(m, w) {
                    m === 0 && c._mixpanel.persistence._add_to_people_queue(Pi, d), x.isUndefined(n) || n(m, w)
                }, g = l.length - 1; g >= 0; g--) d = l.pop(), x.isEmptyObject(d) || c.append(d, p);
            c._mixpanel.persistence.save()
        }
        if (!x.isUndefined(h) && x.isArray(h) && h.length) {
            for (var v, b = function(m, w) {
                    m === 0 && c._mixpanel.persistence._add_to_people_queue(To, v), x.isUndefined(a) || a(m, w)
                }, T = h.length - 1; T >= 0; T--) v = h.pop(), x.isEmptyObject(v) || c.remove(v, b);
            c._mixpanel.persistence.save()
        }
    };
    it.prototype._is_reserved_property = function(t) {
        return t === "$distinct_id" || t === "$token" || t === "$device_id" || t === "$user_id" || t === "$had_persisted_distinct_id"
    };
    it.prototype.set = it.prototype.set;
    it.prototype.set_once = it.prototype.set_once;
    it.prototype.unset = it.prototype.unset;
    it.prototype.increment = it.prototype.increment;
    it.prototype.append = it.prototype.append;
    it.prototype.remove = it.prototype.remove;
    it.prototype.union = it.prototype.union;
    it.prototype.track_charge = it.prototype.track_charge;
    it.prototype.clear_charges = it.prototype.clear_charges;
    it.prototype.delete_user = it.prototype.delete_user;
    it.prototype.toString = it.prototype.toString;
    var ev = "__mps",
        tv = "__mpso",
        nv = "__mpus",
        rv = "__mpa",
        sv = "__mpap",
        iv = "__mpr",
        ov = "__mpu",
        h4 = "$people_distinct_id",
        dd = "__alias",
        gl = "__timers",
        u$ = [ev, tv, nv, rv, sv, iv, ov, h4, dd, gl],
        gt = function(t) {
            this.props = {}, this.campaign_params_saved = !1, t.persistence_name ? this.name = "mp_" + t.persistence_name : this.name = "mp_" + t.token + "_mixpanel";
            var e = t.persistence;
            e !== "cookie" && e !== "localStorage" && (Lt.critical("Unknown persistence type " + e + "; falling back to cookie"), e = t.persistence = "cookie"), e === "localStorage" && x.localStorage.is_supported() ? this.storage = x.localStorage : this.storage = x.cookie, this.load(), this.update_config(t), this.upgrade(t), this.save()
        };
    gt.prototype.properties = function() {
        var t = {};
        return x.each(this.props, function(e, n) {
            x.include(u$, n) || (t[n] = e)
        }), t
    };
    gt.prototype.load = function() {
        if (!this.disabled) {
            var t = this.storage.parse(this.name);
            t && (this.props = x.extend({}, t))
        }
    };
    gt.prototype.upgrade = function(t) {
        var e = t.upgrade,
            n, r;
        e && (n = "mp_super_properties", typeof e == "string" && (n = e), r = this.storage.parse(n), this.storage.remove(n), this.storage.remove(n, !0), r && (this.props = x.extend(this.props, r.all, r.events))), !t.cookie_name && t.name !== "mixpanel" && (n = "mp_" + t.token + "_" + t.name, r = this.storage.parse(n), r && (this.storage.remove(n), this.storage.remove(n, !0), this.register_once(r))), this.storage === x.localStorage && (r = x.cookie.parse(this.name), x.cookie.remove(this.name), x.cookie.remove(this.name, !0), r && this.register_once(r))
    };
    gt.prototype.save = function() {
        this.disabled || this.storage.set(this.name, x.JSONEncode(this.props), this.expire_days, this.cross_subdomain, this.secure, this.cross_site, this.cookie_domain)
    };
    gt.prototype.remove = function() {
        this.storage.remove(this.name, !1, this.cookie_domain), this.storage.remove(this.name, !0, this.cookie_domain)
    };
    gt.prototype.clear = function() {
        this.remove(), this.props = {}
    };
    gt.prototype.register_once = function(t, e, n) {
        return x.isObject(t) ? (typeof e > "u" && (e = "None"), this.expire_days = typeof n > "u" ? this.default_expiry : n, x.each(t, function(r, s) {
            (!this.props.hasOwnProperty(s) || this.props[s] === e) && (this.props[s] = r)
        }, this), this.save(), !0) : !1
    };
    gt.prototype.register = function(t, e) {
        return x.isObject(t) ? (this.expire_days = typeof e > "u" ? this.default_expiry : e, x.extend(this.props, t), this.save(), !0) : !1
    };
    gt.prototype.unregister = function(t) {
        t in this.props && (delete this.props[t], this.save())
    };
    gt.prototype.update_campaign_params = function() {
        this.campaign_params_saved || (this.register_once(x.info.campaignParams()), this.campaign_params_saved = !0)
    };
    gt.prototype.update_search_keyword = function(t) {
        this.register(x.info.searchInfo(t))
    };
    gt.prototype.update_referrer_info = function(t) {
        this.register_once({
            $initial_referrer: t || "$direct",
            $initial_referring_domain: x.info.referringDomain(t) || "$direct"
        }, "")
    };
    gt.prototype.get_referrer_info = function() {
        return x.strip_empty_properties({
            $initial_referrer: this.props.$initial_referrer,
            $initial_referring_domain: this.props.$initial_referring_domain
        })
    };
    gt.prototype.safe_merge = function(t) {
        return x.each(this.props, function(e, n) {
            n in t || (t[n] = e)
        }), t
    };
    gt.prototype.update_config = function(t) {
        this.default_expiry = this.expire_days = t.cookie_expiration, this.set_disabled(t.disable_persistence), this.set_cookie_domain(t.cookie_domain), this.set_cross_site(t.cross_site_cookie), this.set_cross_subdomain(t.cross_subdomain_cookie), this.set_secure(t.secure_cookie)
    };
    gt.prototype.set_disabled = function(t) {
        this.disabled = t, this.disabled ? this.remove() : this.save()
    };
    gt.prototype.set_cookie_domain = function(t) {
        t !== this.cookie_domain && (this.remove(), this.cookie_domain = t, this.save())
    };
    gt.prototype.set_cross_site = function(t) {
        t !== this.cross_site && (this.cross_site = t, this.remove(), this.save())
    };
    gt.prototype.set_cross_subdomain = function(t) {
        t !== this.cross_subdomain && (this.cross_subdomain = t, this.remove(), this.save())
    };
    gt.prototype.get_cross_subdomain = function() {
        return this.cross_subdomain
    };
    gt.prototype.set_secure = function(t) {
        t !== this.secure && (this.secure = !!t, this.remove(), this.save())
    };
    gt.prototype._add_to_people_queue = function(t, e) {
        var n = this._get_queue_key(t),
            r = e[t],
            s = this._get_or_create_queue(So),
            i = this._get_or_create_queue(Mc),
            a = this._get_or_create_queue(gs),
            c = this._get_or_create_queue(ba),
            l = this._get_or_create_queue(Ea),
            h = this._get_or_create_queue(To, []),
            d = this._get_or_create_queue(Pi, []);
        n === ev ? (x.extend(s, r), this._pop_from_people_queue(ba, r), this._pop_from_people_queue(Ea, r), this._pop_from_people_queue(gs, r)) : n === tv ? (x.each(r, function(p, g) {
            g in i || (i[g] = p)
        }), this._pop_from_people_queue(gs, r)) : n === nv ? x.each(r, function(p) {
            x.each([s, i, c, l], function(g) {
                p in g && delete g[p]
            }), x.each(d, function(g) {
                p in g && delete g[p]
            }), a[p] = !0
        }) : n === rv ? (x.each(r, function(p, g) {
            g in s ? s[g] += p : (g in c || (c[g] = 0), c[g] += p)
        }, this), this._pop_from_people_queue(gs, r)) : n === ov ? (x.each(r, function(p, g) {
            x.isArray(p) && (g in l || (l[g] = []), l[g] = l[g].concat(p))
        }), this._pop_from_people_queue(gs, r)) : n === iv ? (h.push(r), this._pop_from_people_queue(Pi, r)) : n === sv && (d.push(r), this._pop_from_people_queue(gs, r)), Lt.log("MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):"), Lt.log(e), this.save()
    };
    gt.prototype._pop_from_people_queue = function(t, e) {
        var n = this._get_queue(t);
        x.isUndefined(n) || (x.each(e, function(r, s) {
            t === Pi || t === To ? x.each(n, function(i) {
                i[s] === r && delete i[s]
            }) : delete n[s]
        }, this), this.save())
    };
    gt.prototype._get_queue_key = function(t) {
        if (t === So) return ev;
        if (t === Mc) return tv;
        if (t === gs) return nv;
        if (t === ba) return rv;
        if (t === Pi) return sv;
        if (t === To) return iv;
        if (t === Ea) return ov;
        Lt.error("Invalid queue:", t)
    };
    gt.prototype._get_queue = function(t) {
        return this.props[this._get_queue_key(t)]
    };
    gt.prototype._get_or_create_queue = function(t, e) {
        var n = this._get_queue_key(t);
        return e = x.isUndefined(e) ? {} : e, this.props[n] || (this.props[n] = e)
    };
    gt.prototype.set_event_timer = function(t, e) {
        var n = this.props[gl] || {};
        n[t] = e, this.props[gl] = n, this.save()
    };
    gt.prototype.remove_event_timer = function(t) {
        var e = this.props[gl] || {},
            n = e[t];
        return x.isUndefined(n) || (delete this.props[gl][t], this.save()), n
    };
    var av, Qn, f4 = 0,
        l$ = 1,
        h$ = function(t) {
            return t
        },
        _l = function() {},
        Jr = "mixpanel",
        d4 = "base64",
        f$ = "json",
        yc = nr.XMLHttpRequest && "withCredentials" in new XMLHttpRequest,
        p4 = !yc && ms.indexOf("MSIE") === -1 && ms.indexOf("Mozilla") === -1,
        pd = null;
    Oi.sendBeacon && (pd = function() {
        return Oi.sendBeacon.apply(Oi, arguments)
    });
    var DS = {
            api_host: "https://api-js.mixpanel.com",
            api_method: "POST",
            api_transport: "XHR",
            api_payload_format: d4,
            app_host: "https://mixpanel.com",
            cdn: "https://cdn.mxpnl.com",
            cross_site_cookie: !1,
            cross_subdomain_cookie: !0,
            error_reporter: _l,
            persistence: "cookie",
            persistence_name: "",
            cookie_domain: "",
            cookie_name: "",
            loaded: _l,
            store_google: !0,
            save_referrer: !0,
            test: !1,
            verbose: !1,
            img: !1,
            debug: !1,
            track_links_timeout: 300,
            cookie_expiration: 365,
            upgrade: !1,
            disable_persistence: !1,
            disable_cookie: !1,
            secure_cookie: !1,
            ip: !0,
            opt_out_tracking_by_default: !1,
            opt_out_persistence_by_default: !1,
            opt_out_tracking_persistence_type: "localStorage",
            opt_out_tracking_cookie_prefix: null,
            property_blacklist: [],
            xhr_headers: {},
            ignore_dnt: !1,
            batch_requests: !0,
            batch_size: 50,
            batch_flush_interval_ms: 5e3,
            batch_request_timeout_ms: 9e4,
            batch_autostart: !0,
            hooks: {}
        },
        m4 = !1,
        be = function() {},
        l1 = function(t, e, n) {
            var r, s = n === Jr ? Qn : Qn[n];
            if (s && av === f4) r = s;
            else {
                if (s && !x.isArray(s)) {
                    Lt.error("You have already initialized " + n);
                    return
                }
                r = new be
            }
            return r._cached_groups = {}, r._init(t, e, n), r.people = new it, r.people._init(r), go.DEBUG = go.DEBUG || r.get_config("debug"), !x.isUndefined(s) && x.isArray(s) && (r._execute_array.call(r.people, s.people), r._execute_array(s)), r
        };
    be.prototype.init = function(t, e, n) {
        if (x.isUndefined(n)) {
            this.report_error("You must name your new library: init(token, config, name)");
            return
        }
        if (n === Jr) {
            this.report_error("You must initialize the main mixpanel object right after you include the Mixpanel js snippet");
            return
        }
        var r = l1(t, e, n);
        return Qn[n] = r, r._loaded(), r
    };
    be.prototype._init = function(t, e, n) {
        e = e || {}, this.__loaded = !0, this.config = {};
        var r = {};
        if (!("api_payload_format" in e)) {
            var s = e.api_host || DS.api_host;
            s.match(/\.mixpanel\.com$/) && (r.api_payload_format = f$)
        }
        if (this.set_config(x.extend({}, DS, r, e, {
                name: n,
                token: t,
                callback_fn: (n === Jr ? n : Jr + "." + n) + "._jsc"
            })), this._jsc = _l, this.__dom_loaded_queue = [], this.__request_queue = [], this.__disabled_events = [], this._flags = {
                disable_all_events: !1,
                identify_called: !1
            }, this.request_batchers = {}, this._batch_requests = this.get_config("batch_requests"), this._batch_requests) {
            if (!x.localStorage.is_supported(!0) || !yc) this._batch_requests = !1, Lt.log("Turning off Mixpanel request-queueing; needs XHR and localStorage support");
            else if (this.init_batchers(), pd && nr.addEventListener) {
                var i = x.bind(function() {
                    this.request_batchers.events.stopped || this.request_batchers.events.flush({
                        unloading: !0
                    })
                }, this);
                nr.addEventListener("pagehide", function(c) {
                    c.persisted && i()
                }), nr.addEventListener("visibilitychange", function() {
                    qt.visibilityState === "hidden" && i()
                })
            }
        }
        this.persistence = this.cookie = new gt(this.config), this.unpersisted_superprops = {}, this._gdpr_init();
        var a = x.UUID();
        this.get_distinct_id() || this.register_once({
            distinct_id: a,
            $device_id: a
        }, "")
    };
    be.prototype._loaded = function() {
        this.get_config("loaded")(this), this._set_default_superprops()
    };
    be.prototype._set_default_superprops = function() {
        this.persistence.update_search_keyword(qt.referrer), this.get_config("store_google") && this.persistence.update_campaign_params(), this.get_config("save_referrer") && this.persistence.update_referrer_info(qt.referrer)
    };
    be.prototype._dom_loaded = function() {
        x.each(this.__dom_loaded_queue, function(t) {
            this._track_dom.apply(this, t)
        }, this), this.has_opted_out_tracking() || x.each(this.__request_queue, function(t) {
            this._send_request.apply(this, t)
        }, this), delete this.__dom_loaded_queue, delete this.__request_queue
    };
    be.prototype._track_dom = function(t, e) {
        if (this.get_config("img")) return this.report_error("You can't use DOM tracking functions with img = true."), !1;
        if (!m4) return this.__dom_loaded_queue.push([t, e]), !1;
        var n = new t().init(this);
        return n.track.apply(n, e)
    };
    be.prototype._prepare_callback = function(t, e) {
        if (x.isUndefined(t)) return null;
        if (yc) {
            var n = function(a) {
                t(a, e)
            };
            return n
        } else {
            var r = this._jsc,
                s = "" + Math.floor(Math.random() * 1e8),
                i = this.get_config("callback_fn") + "[" + s + "]";
            return r[s] = function(a) {
                delete r[s], t(a, e)
            }, i
        }
    };
    be.prototype._send_request = function(t, e, n, r) {
        var s = !0;
        if (p4) return this.__request_queue.push(arguments), s;
        var i = {
                method: this.get_config("api_method"),
                transport: this.get_config("api_transport"),
                verbose: this.get_config("verbose")
            },
            a = null;
        !r && (x.isFunction(n) || typeof n == "string") && (r = n, n = null), n = x.extend(i, n || {}), yc || (n.method = "GET");
        var c = n.method === "POST",
            l = pd && c && n.transport.toLowerCase() === "sendbeacon",
            h = n.verbose;
        e.verbose && (h = !0), this.get_config("test") && (e.test = 1), h && (e.verbose = 1), this.get_config("img") && (e.img = 1), yc || (r ? e.callback = r : (h || this.get_config("test")) && (e.callback = "(function(){})")), e.ip = this.get_config("ip") ? 1 : 0, e._ = new Date().getTime().toString(), c && (a = "data=" + encodeURIComponent(e.data), delete e.data), t += "?" + x.HTTPBuildQuery(e);
        var d = this;
        if ("img" in e) {
            var p = qt.createElement("img");
            p.src = t, qt.body.appendChild(p)
        } else if (l) {
            try {
                s = pd(t, a)
            } catch (w) {
                d.report_error(w), s = !1
            }
            try {
                r && r(s ? 1 : 0)
            } catch (w) {
                d.report_error(w)
            }
        } else if (yc) try {
            var g = new XMLHttpRequest;
            g.open(n.method, t, !0);
            var v = this.get_config("xhr_headers");
            if (c && (v["Content-Type"] = "application/x-www-form-urlencoded"), x.each(v, function(w, P) {
                    g.setRequestHeader(P, w)
                }), n.timeout_ms && typeof g.timeout < "u") {
                g.timeout = n.timeout_ms;
                var b = new Date().getTime()
            }
            g.withCredentials = !0, g.onreadystatechange = function() {
                if (g.readyState === 4)
                    if (g.status === 200) {
                        if (r)
                            if (h) {
                                var w;
                                try {
                                    w = x.JSONDecode(g.responseText)
                                } catch (V) {
                                    if (d.report_error(V), n.ignore_json_errors) w = g.responseText;
                                    else return
                                }
                                r(w)
                            } else r(Number(g.responseText))
                    } else {
                        var P;
                        g.timeout && !g.status && new Date().getTime() - b >= g.timeout ? P = "timeout" : P = "Bad HTTP status: " + g.status + " " + g.statusText, d.report_error(P), r && r(h ? {
                            status: 0,
                            error: P,
                            xhr_req: g
                        } : 0)
                    }
            }, g.send(a)
        } catch (w) {
            d.report_error(w), s = !1
        } else {
            var T = qt.createElement("script");
            T.type = "text/javascript", T.async = !0, T.defer = !0, T.src = t;
            var m = qt.getElementsByTagName("script")[0];
            m.parentNode.insertBefore(T, m)
        }
        return s
    };
    be.prototype._execute_array = function(t) {
        var e, n = [],
            r = [],
            s = [];
        x.each(t, function(a) {
            a && (e = a[0], x.isArray(e) ? s.push(a) : typeof a == "function" ? a.call(this) : x.isArray(a) && e === "alias" ? n.push(a) : x.isArray(a) && e.indexOf("track") !== -1 && typeof this[e] == "function" ? s.push(a) : r.push(a))
        }, this);
        var i = function(a, c) {
            x.each(a, function(l) {
                if (x.isArray(l[0])) {
                    var h = c;
                    x.each(l, function(d) {
                        h = h[d[0]].apply(h, d.slice(1))
                    })
                } else this[l[0]].apply(this, l.slice(1))
            }, c)
        };
        i(n, this), i(r, this), i(s, this)
    };
    be.prototype.are_batchers_initialized = function() {
        return !!this.request_batchers.events
    };
    be.prototype.init_batchers = function() {
        var t = this.get_config("token");
        if (!this.are_batchers_initialized()) {
            var e = x.bind(function(n) {
                return new si("__mpq_" + t + n.queue_suffix, {
                    libConfig: this.config,
                    sendRequestFunc: x.bind(function(r, s, i) {
                        this._send_request(this.get_config("api_host") + n.endpoint, this._encode_data_for_request(r), s, this._prepare_callback(i, r))
                    }, this),
                    beforeSendHook: x.bind(function(r) {
                        return this._run_hook("before_send_" + n.type, r)
                    }, this),
                    errorReporter: this.get_config("error_reporter"),
                    stopAllBatchingFunc: x.bind(this.stop_batch_senders, this)
                })
            }, this);
            this.request_batchers = {
                events: e({
                    type: "events",
                    endpoint: "/track/",
                    queue_suffix: "_ev"
                }),
                people: e({
                    type: "people",
                    endpoint: "/engage/",
                    queue_suffix: "_pp"
                }),
                groups: e({
                    type: "groups",
                    endpoint: "/groups/",
                    queue_suffix: "_gr"
                })
            }
        }
        this.get_config("batch_autostart") && this.start_batch_senders()
    };
    be.prototype.start_batch_senders = function() {
        this.are_batchers_initialized() && (this._batch_requests = !0, x.each(this.request_batchers, function(t) {
            t.start()
        }))
    };
    be.prototype.stop_batch_senders = function() {
        this._batch_requests = !1, x.each(this.request_batchers, function(t) {
            t.stop(), t.clear()
        })
    };
    be.prototype.push = function(t) {
        this._execute_array([t])
    };
    be.prototype.disable = function(t) {
        typeof t > "u" ? this._flags.disable_all_events = !0 : this.__disabled_events = this.__disabled_events.concat(t)
    };
    be.prototype._encode_data_for_request = function(t) {
        var e = x.JSONEncode(t);
        return this.get_config("api_payload_format") === d4 && (e = x.base64Encode(e)), {
            data: e
        }
    };
    be.prototype._track_or_batch = function(t, e) {
        var n = x.truncate(t.data, 255),
            r = t.endpoint,
            s = t.batcher,
            i = t.should_send_immediately,
            a = t.send_request_options || {};
        e = e || _l;
        var c = !0,
            l = x.bind(function() {
                return a.skip_hooks || (n = this._run_hook("before_send_" + t.type, n)), n ? (Lt.log("MIXPANEL REQUEST:"), Lt.log(n), this._send_request(r, this._encode_data_for_request(n), a, this._prepare_callback(e, n))) : null
            }, this);
        return this._batch_requests && !i ? s.enqueue(n, function(h) {
            h ? e(1, n) : l()
        }) : c = l(), c && n
    };
    be.prototype.track = zl(function(t, e, n, r) {
        !r && typeof n == "function" && (r = n, n = null), n = n || {};
        var s = n.transport;
        s && (n.transport = s);
        var i = n.send_immediately;
        if (typeof r != "function" && (r = _l), x.isUndefined(t)) {
            this.report_error("No event name provided to mixpanel.track");
            return
        }
        if (this._event_is_disabled(t)) {
            r(0);
            return
        }
        e = e || {}, e.token = this.get_config("token");
        var a = this.persistence.remove_event_timer(t);
        if (!x.isUndefined(a)) {
            var c = new Date().getTime() - a;
            e.$duration = parseFloat((c / 1e3).toFixed(3))
        }
        this._set_default_superprops(), e = x.extend({}, x.info.properties(), this.persistence.properties(), this.unpersisted_superprops, e);
        var l = this.get_config("property_blacklist");
        x.isArray(l) ? x.each(l, function(p) {
            delete e[p]
        }) : this.report_error("Invalid value for property_blacklist config: " + l);
        var h = {
                event: t,
                properties: e
            },
            d = this._track_or_batch({
                type: "events",
                data: h,
                endpoint: this.get_config("api_host") + "/track/",
                batcher: this.request_batchers.events,
                should_send_immediately: i,
                send_request_options: n
            }, r);
        return d
    });
    be.prototype.set_group = zl(function(t, e, n) {
        x.isArray(e) || (e = [e]);
        var r = {};
        return r[t] = e, this.register(r), this.people.set(t, e, n)
    });
    be.prototype.add_group = zl(function(t, e, n) {
        var r = this.get_property(t);
        if (r === void 0) {
            var s = {};
            s[t] = [e], this.register(s)
        } else r.indexOf(e) === -1 && (r.push(e), this.register(s));
        return this.people.union(t, e, n)
    });
    be.prototype.remove_group = zl(function(t, e, n) {
        var r = this.get_property(t);
        if (r !== void 0) {
            var s = r.indexOf(e);
            s > -1 && (r.splice(s, 1), this.register({
                group_key: r
            })), r.length === 0 && this.unregister(t)
        }
        return this.people.remove(t, e, n)
    });
    be.prototype.track_with_groups = zl(function(t, e, n, r) {
        var s = x.extend({}, e || {});
        return x.each(n, function(i, a) {
            i != null && (s[a] = i)
        }), this.track(t, s, r)
    });
    be.prototype._create_map_key = function(t, e) {
        return t + "_" + JSON.stringify(e)
    };
    be.prototype._remove_group_from_cache = function(t, e) {
        delete this._cached_groups[this._create_map_key(t, e)]
    };
    be.prototype.get_group = function(t, e) {
        var n = this._create_map_key(t, e),
            r = this._cached_groups[n];
        return (r === void 0 || r._group_key !== t || r._group_id !== e) && (r = new en, r._init(this, t, e), this._cached_groups[n] = r), r
    };
    be.prototype.track_pageview = function(t) {
        x.isUndefined(t) && (t = qt.location.href), this.track("mp_page_view", x.info.pageviewInfo(t))
    };
    be.prototype.track_links = function() {
        return this._track_dom.call(this, Rc, arguments)
    };
    be.prototype.track_forms = function() {
        return this._track_dom.call(this, jp, arguments)
    };
    be.prototype.time_event = function(t) {
        if (x.isUndefined(t)) {
            this.report_error("No event name provided to mixpanel.time_event");
            return
        }
        this._event_is_disabled(t) || this.persistence.set_event_timer(t, new Date().getTime())
    };
    var d$ = {
            persistent: !0
        },
        cv = function(t) {
            var e;
            return x.isObject(t) ? e = t : x.isUndefined(t) ? e = {} : e = {
                days: t
            }, x.extend({}, d$, e)
        };
    be.prototype.register = function(t, e) {
        var n = cv(e);
        n.persistent ? this.persistence.register(t, n.days) : x.extend(this.unpersisted_superprops, t)
    };
    be.prototype.register_once = function(t, e, n) {
        var r = cv(n);
        r.persistent ? this.persistence.register_once(t, e, r.days) : (typeof e > "u" && (e = "None"), x.each(t, function(s, i) {
            (!this.unpersisted_superprops.hasOwnProperty(i) || this.unpersisted_superprops[i] === e) && (this.unpersisted_superprops[i] = s)
        }, this))
    };
    be.prototype.unregister = function(t, e) {
        e = cv(e), e.persistent ? this.persistence.unregister(t) : delete this.unpersisted_superprops[t]
    };
    be.prototype._register_single = function(t, e) {
        var n = {};
        n[t] = e, this.register(n)
    };
    be.prototype.identify = function(t, e, n, r, s, i, a, c) {
        var l = this.get_distinct_id();
        if (this.register({
                $user_id: t
            }), !this.get_property("$device_id")) {
            var h = l;
            this.register_once({
                $had_persisted_distinct_id: !0,
                $device_id: h
            }, "")
        }
        t !== l && t !== this.get_property(dd) && (this.unregister(dd), this.register({
            distinct_id: t
        })), this._flags.identify_called = !0, this.people._flush(e, n, r, s, i, a, c), t !== l && this.track("$identify", {
            distinct_id: t,
            $anon_distinct_id: l
        }, {
            skip_hooks: !0
        })
    };
    be.prototype.reset = function() {
        this.persistence.clear(), this._flags.identify_called = !1;
        var t = x.UUID();
        this.register_once({
            distinct_id: t,
            $device_id: t
        }, "")
    };
    be.prototype.get_distinct_id = function() {
        return this.get_property("distinct_id")
    };
    be.prototype.alias = function(t, e) {
        if (t === this.get_property(h4)) return this.report_error("Attempting to create alias for existing People user - aborting."), -2;
        var n = this;
        return x.isUndefined(e) && (e = this.get_distinct_id()), t !== e ? (this._register_single(dd, t), this.track("$create_alias", {
            alias: t,
            distinct_id: e
        }, {
            skip_hooks: !0
        }, function() {
            n.identify(t)
        })) : (this.report_error("alias matches current distinct_id - skipping api call."), this.identify(t), -1)
    };
    be.prototype.name_tag = function(t) {
        this._register_single("mp_name_tag", t)
    };
    be.prototype.set_config = function(t) {
        if (x.isObject(t)) {
            x.extend(this.config, t);
            var e = t.batch_size;
            e && x.each(this.request_batchers, function(n) {
                n.resetBatchSize()
            }), this.get_config("persistence_name") || (this.config.persistence_name = this.config.cookie_name), this.get_config("disable_persistence") || (this.config.disable_persistence = this.config.disable_cookie), this.persistence && this.persistence.update_config(this.config), go.DEBUG = go.DEBUG || this.get_config("debug")
        }
    };
    be.prototype.get_config = function(t) {
        return this.config[t]
    };
    be.prototype._run_hook = function(t) {
        var e = (this.config.hooks[t] || h$).apply(this, lo.call(arguments, 1));
        return typeof e > "u" && (this.report_error(t + " hook did not return a value"), e = null), e
    };
    be.prototype.get_property = function(t) {
        return this.persistence.props[t]
    };
    be.prototype.toString = function() {
        var t = this.get_config("name");
        return t !== Jr && (t = Jr + "." + t), t
    };
    be.prototype._event_is_disabled = function(t) {
        return x.isBlockedUA(ms) || this._flags.disable_all_events || x.include(this.__disabled_events, t)
    };
    be.prototype._gdpr_init = function() {
        var t = this.get_config("opt_out_tracking_persistence_type") === "localStorage";
        t && x.localStorage.is_supported() && (!this.has_opted_in_tracking() && this.has_opted_in_tracking({
            persistence_type: "cookie"
        }) && this.opt_in_tracking({
            enable_persistence: !1
        }), !this.has_opted_out_tracking() && this.has_opted_out_tracking({
            persistence_type: "cookie"
        }) && this.opt_out_tracking({
            clear_persistence: !1
        }), this.clear_opt_in_out_tracking({
            persistence_type: "cookie",
            enable_persistence: !1
        })), this.has_opted_out_tracking() ? this._gdpr_update_persistence({
            clear_persistence: !0
        }) : !this.has_opted_in_tracking() && (this.get_config("opt_out_tracking_by_default") || x.cookie.get("mp_optout")) && (x.cookie.remove("mp_optout"), this.opt_out_tracking({
            clear_persistence: this.get_config("opt_out_persistence_by_default")
        }))
    };
    be.prototype._gdpr_update_persistence = function(t) {
        var e;
        if (t && t.clear_persistence) e = !0;
        else if (t && t.enable_persistence) e = !1;
        else return;
        !this.get_config("disable_persistence") && this.persistence.disabled !== e && this.persistence.set_disabled(e), e && x.each(this.request_batchers, function(n) {
            n.clear()
        })
    };
    be.prototype._gdpr_call_func = function(t, e) {
        return e = x.extend({
            track: x.bind(this.track, this),
            persistence_type: this.get_config("opt_out_tracking_persistence_type"),
            cookie_prefix: this.get_config("opt_out_tracking_cookie_prefix"),
            cookie_expiration: this.get_config("cookie_expiration"),
            cross_site_cookie: this.get_config("cross_site_cookie"),
            cross_subdomain_cookie: this.get_config("cross_subdomain_cookie"),
            cookie_domain: this.get_config("cookie_domain"),
            secure_cookie: this.get_config("secure_cookie"),
            ignore_dnt: this.get_config("ignore_dnt")
        }, e), x.localStorage.is_supported() || (e.persistence_type = "cookie"), t(this.get_config("token"), {
            track: e.track,
            trackEventName: e.track_event_name,
            trackProperties: e.track_properties,
            persistenceType: e.persistence_type,
            persistencePrefix: e.cookie_prefix,
            cookieDomain: e.cookie_domain,
            cookieExpiration: e.cookie_expiration,
            crossSiteCookie: e.cross_site_cookie,
            crossSubdomainCookie: e.cross_subdomain_cookie,
            secureCookie: e.secure_cookie,
            ignoreDnt: e.ignore_dnt
        })
    };
    be.prototype.opt_in_tracking = function(t) {
        t = x.extend({
            enable_persistence: !0
        }, t), this._gdpr_call_func(r$, t), this._gdpr_update_persistence(t)
    };
    be.prototype.opt_out_tracking = function(t) {
        t = x.extend({
            clear_persistence: !0,
            delete_user: !0
        }, t), t.delete_user && this.people && this.people._identify_called() && (this.people.delete_user(), this.people.clear_charges()), this._gdpr_call_func(s$, t), this._gdpr_update_persistence(t)
    };
    be.prototype.has_opted_in_tracking = function(t) {
        return this._gdpr_call_func(i$, t)
    };
    be.prototype.has_opted_out_tracking = function(t) {
        return this._gdpr_call_func(a4, t)
    };
    be.prototype.clear_opt_in_out_tracking = function(t) {
        t = x.extend({
            enable_persistence: !0
        }, t), this._gdpr_call_func(o$, t), this._gdpr_update_persistence(t)
    };
    be.prototype.report_error = function(t, e) {
        Lt.error.apply(Lt.error, arguments);
        try {
            !e && !(t instanceof Error) && (t = new Error(t)), this.get_config("error_reporter")(t, e)
        } catch (n) {
            Lt.error(n)
        }
    };
    be.prototype.init = be.prototype.init;
    be.prototype.reset = be.prototype.reset;
    be.prototype.disable = be.prototype.disable;
    be.prototype.time_event = be.prototype.time_event;
    be.prototype.track = be.prototype.track;
    be.prototype.track_links = be.prototype.track_links;
    be.prototype.track_forms = be.prototype.track_forms;
    be.prototype.track_pageview = be.prototype.track_pageview;
    be.prototype.register = be.prototype.register;
    be.prototype.register_once = be.prototype.register_once;
    be.prototype.unregister = be.prototype.unregister;
    be.prototype.identify = be.prototype.identify;
    be.prototype.alias = be.prototype.alias;
    be.prototype.name_tag = be.prototype.name_tag;
    be.prototype.set_config = be.prototype.set_config;
    be.prototype.get_config = be.prototype.get_config;
    be.prototype.get_property = be.prototype.get_property;
    be.prototype.get_distinct_id = be.prototype.get_distinct_id;
    be.prototype.toString = be.prototype.toString;
    be.prototype.opt_out_tracking = be.prototype.opt_out_tracking;
    be.prototype.opt_in_tracking = be.prototype.opt_in_tracking;
    be.prototype.has_opted_out_tracking = be.prototype.has_opted_out_tracking;
    be.prototype.has_opted_in_tracking = be.prototype.has_opted_in_tracking;
    be.prototype.clear_opt_in_out_tracking = be.prototype.clear_opt_in_out_tracking;
    be.prototype.get_group = be.prototype.get_group;
    be.prototype.set_group = be.prototype.set_group;
    be.prototype.add_group = be.prototype.add_group;
    be.prototype.remove_group = be.prototype.remove_group;
    be.prototype.track_with_groups = be.prototype.track_with_groups;
    be.prototype.start_batch_senders = be.prototype.start_batch_senders;
    be.prototype.stop_batch_senders = be.prototype.stop_batch_senders;
    gt.prototype.properties = gt.prototype.properties;
    gt.prototype.update_search_keyword = gt.prototype.update_search_keyword;
    gt.prototype.update_referrer_info = gt.prototype.update_referrer_info;
    gt.prototype.get_cross_subdomain = gt.prototype.get_cross_subdomain;
    gt.prototype.clear = gt.prototype.clear;
    var oc = {},
        p$ = function() {
            x.each(oc, function(t, e) {
                e !== Jr && (Qn[e] = t)
            }), Qn._ = x
        },
        m$ = function() {
            Qn.init = function(t, e, n) {
                if (n) return Qn[n] || (Qn[n] = oc[n] = l1(t, e, n), Qn[n]._loaded()), Qn[n];
                var r = Qn;
                oc[Jr] ? r = oc[Jr] : t && (r = l1(t, e, Jr), r._loaded(), oc[Jr] = r), Qn = r, av === l$ && (nr[Jr] = Qn), p$()
            }
        },
        g$ = function() {
            function t() {
                t.done || (t.done = !0, m4 = !0, p4 = !1, x.each(oc, function(r) {
                    r._dom_loaded()
                }))
            }

            function e() {
                try {
                    qt.documentElement.doScroll("left")
                } catch {
                    setTimeout(e, 1);
                    return
                }
                t()
            }
            if (qt.addEventListener) qt.readyState === "complete" ? t() : qt.addEventListener("DOMContentLoaded", t, !1);
            else if (qt.attachEvent) {
                qt.attachEvent("onreadystatechange", t);
                var n = !1;
                try {
                    n = nr.frameElement === null
                } catch {}
                qt.documentElement.doScroll && n && e()
            }
            x.register_event(nr, "load", t, !0)
        };

    function _$() {
        return av = f4, Qn = new be, m$(), Qn.init(), g$(), Qn
    }
    _$();

    function y$() {
        this.__data__ = [], this.size = 0
    }
    var v$ = y$;

    function b$(t, e) {
        return t === e || t !== t && e !== e
    }
    var Gp = b$,
        E$ = Gp;

    function S$(t, e) {
        for (var n = t.length; n--;)
            if (E$(t[n][0], e)) return n;
        return -1
    }
    var Wp = S$,
        T$ = Wp,
        w$ = Array.prototype,
        O$ = w$.splice;

    function A$(t) {
        var e = this.__data__,
            n = T$(e, t);
        if (n < 0) return !1;
        var r = e.length - 1;
        return n == r ? e.pop() : O$.call(e, n, 1), --this.size, !0
    }
    var C$ = A$,
        I$ = Wp;

    function k$(t) {
        var e = this.__data__,
            n = I$(e, t);
        return n < 0 ? void 0 : e[n][1]
    }
    var N$ = k$,
        x$ = Wp;

    function P$(t) {
        return x$(this.__data__, t) > -1
    }
    var R$ = P$,
        M$ = Wp;

    function D$(t, e) {
        var n = this.__data__,
            r = M$(n, t);
        return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
    }
    var $$ = D$,
        L$ = v$,
        F$ = C$,
        U$ = N$,
        B$ = R$,
        q$ = $$;

    function nu(t) {
        var e = -1,
            n = t == null ? 0 : t.length;
        for (this.clear(); ++e < n;) {
            var r = t[e];
            this.set(r[0], r[1])
        }
    }
    nu.prototype.clear = L$;
    nu.prototype.delete = F$;
    nu.prototype.get = U$;
    nu.prototype.has = B$;
    nu.prototype.set = q$;
    var Hp = nu,
        V$ = Hp;

    function j$() {
        this.__data__ = new V$, this.size = 0
    }
    var G$ = j$;

    function W$(t) {
        var e = this.__data__,
            n = e.delete(t);
        return this.size = e.size, n
    }
    var H$ = W$;

    function K$(t) {
        return this.__data__.get(t)
    }
    var Y$ = K$;

    function z$(t) {
        return this.__data__.has(t)
    }
    var Z$ = z$,
        X$ = typeof hn == "object" && hn && hn.Object === Object && hn,
        g4 = X$,
        Q$ = g4,
        J$ = typeof self == "object" && self && self.Object === Object && self,
        eL = Q$ || J$ || Function("return this")(),
        Ps = eL,
        tL = Ps,
        nL = tL.Symbol,
        Kp = nL,
        $S = Kp,
        _4 = Object.prototype,
        rL = _4.hasOwnProperty,
        sL = _4.toString,
        Fu = $S ? $S.toStringTag : void 0;

    function iL(t) {
        var e = rL.call(t, Fu),
            n = t[Fu];
        try {
            t[Fu] = void 0;
            var r = !0
        } catch {}
        var s = sL.call(t);
        return r && (e ? t[Fu] = n : delete t[Fu]), s
    }
    var oL = iL,
        aL = Object.prototype,
        cL = aL.toString;

    function uL(t) {
        return cL.call(t)
    }
    var lL = uL,
        LS = Kp,
        hL = oL,
        fL = lL,
        dL = "[object Null]",
        pL = "[object Undefined]",
        FS = LS ? LS.toStringTag : void 0;

    function mL(t) {
        return t == null ? t === void 0 ? pL : dL : FS && FS in Object(t) ? hL(t) : fL(t)
    }
    var ru = mL;

    function gL(t) {
        var e = typeof t;
        return t != null && (e == "object" || e == "function")
    }
    var Rs = gL,
        _L = ru,
        yL = Rs,
        vL = "[object AsyncFunction]",
        bL = "[object Function]",
        EL = "[object GeneratorFunction]",
        SL = "[object Proxy]";

    function TL(t) {
        if (!yL(t)) return !1;
        var e = _L(t);
        return e == bL || e == EL || e == vL || e == SL
    }
    var uv = TL,
        wL = Ps,
        OL = wL["__core-js_shared__"],
        AL = OL,
        i_ = AL,
        US = function() {
            var t = /[^.]+$/.exec(i_ && i_.keys && i_.keys.IE_PROTO || "");
            return t ? "Symbol(src)_1." + t : ""
        }();

    function CL(t) {
        return !!US && US in t
    }
    var IL = CL,
        kL = Function.prototype,
        NL = kL.toString;

    function xL(t) {
        if (t != null) {
            try {
                return NL.call(t)
            } catch {}
            try {
                return t + ""
            } catch {}
        }
        return ""
    }
    var y4 = xL,
        PL = uv,
        RL = IL,
        ML = Rs,
        DL = y4,
        $L = /[\\^$.*+?()[\]{}|]/g,
        LL = /^\[object .+?Constructor\]$/,
        FL = Function.prototype,
        UL = Object.prototype,
        BL = FL.toString,
        qL = UL.hasOwnProperty,
        VL = RegExp("^" + BL.call(qL).replace($L, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

    function jL(t) {
        if (!ML(t) || RL(t)) return !1;
        var e = PL(t) ? VL : LL;
        return e.test(DL(t))
    }
    var GL = jL;

    function WL(t, e) {
        return t == null ? void 0 : t[e]
    }
    var HL = WL,
        KL = GL,
        YL = HL;

    function zL(t, e) {
        var n = YL(t, e);
        return KL(n) ? n : void 0
    }
    var Na = zL,
        ZL = Na,
        XL = Ps,
        QL = ZL(XL, "Map"),
        lv = QL,
        JL = Na,
        eF = JL(Object, "create"),
        Yp = eF,
        BS = Yp;

    function tF() {
        this.__data__ = BS ? BS(null) : {}, this.size = 0
    }
    var nF = tF;

    function rF(t) {
        var e = this.has(t) && delete this.__data__[t];
        return this.size -= e ? 1 : 0, e
    }
    var sF = rF,
        iF = Yp,
        oF = "__lodash_hash_undefined__",
        aF = Object.prototype,
        cF = aF.hasOwnProperty;

    function uF(t) {
        var e = this.__data__;
        if (iF) {
            var n = e[t];
            return n === oF ? void 0 : n
        }
        return cF.call(e, t) ? e[t] : void 0
    }
    var lF = uF,
        hF = Yp,
        fF = Object.prototype,
        dF = fF.hasOwnProperty;

    function pF(t) {
        var e = this.__data__;
        return hF ? e[t] !== void 0 : dF.call(e, t)
    }
    var mF = pF,
        gF = Yp,
        _F = "__lodash_hash_undefined__";

    function yF(t, e) {
        var n = this.__data__;
        return this.size += this.has(t) ? 0 : 1, n[t] = gF && e === void 0 ? _F : e, this
    }
    var vF = yF,
        bF = nF,
        EF = sF,
        SF = lF,
        TF = mF,
        wF = vF;

    function su(t) {
        var e = -1,
            n = t == null ? 0 : t.length;
        for (this.clear(); ++e < n;) {
            var r = t[e];
            this.set(r[0], r[1])
        }
    }
    su.prototype.clear = bF;
    su.prototype.delete = EF;
    su.prototype.get = SF;
    su.prototype.has = TF;
    su.prototype.set = wF;
    var OF = su,
        qS = OF,
        AF = Hp,
        CF = lv;

    function IF() {
        this.size = 0, this.__data__ = {
            hash: new qS,
            map: new(CF || AF),
            string: new qS
        }
    }
    var kF = IF;

    function NF(t) {
        var e = typeof t;
        return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
    }
    var xF = NF,
        PF = xF;

    function RF(t, e) {
        var n = t.__data__;
        return PF(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
    }
    var zp = RF,
        MF = zp;

    function DF(t) {
        var e = MF(this, t).delete(t);
        return this.size -= e ? 1 : 0, e
    }
    var $F = DF,
        LF = zp;

    function FF(t) {
        return LF(this, t).get(t)
    }
    var UF = FF,
        BF = zp;

    function qF(t) {
        return BF(this, t).has(t)
    }
    var VF = qF,
        jF = zp;

    function GF(t, e) {
        var n = jF(this, t),
            r = n.size;
        return n.set(t, e), this.size += n.size == r ? 0 : 1, this
    }
    var WF = GF,
        HF = kF,
        KF = $F,
        YF = UF,
        zF = VF,
        ZF = WF;

    function iu(t) {
        var e = -1,
            n = t == null ? 0 : t.length;
        for (this.clear(); ++e < n;) {
            var r = t[e];
            this.set(r[0], r[1])
        }
    }
    iu.prototype.clear = HF;
    iu.prototype.delete = KF;
    iu.prototype.get = YF;
    iu.prototype.has = zF;
    iu.prototype.set = ZF;
    var v4 = iu,
        XF = Hp,
        QF = lv,
        JF = v4,
        eU = 200;

    function tU(t, e) {
        var n = this.__data__;
        if (n instanceof XF) {
            var r = n.__data__;
            if (!QF || r.length < eU - 1) return r.push([t, e]), this.size = ++n.size, this;
            n = this.__data__ = new JF(r)
        }
        return n.set(t, e), this.size = n.size, this
    }
    var nU = tU,
        rU = Hp,
        sU = G$,
        iU = H$,
        oU = Y$,
        aU = Z$,
        cU = nU;

    function ou(t) {
        var e = this.__data__ = new rU(t);
        this.size = e.size
    }
    ou.prototype.clear = sU;
    ou.prototype.delete = iU;
    ou.prototype.get = oU;
    ou.prototype.has = aU;
    ou.prototype.set = cU;
    var b4 = ou,
        uU = Na,
        lU = function() {
            try {
                var t = uU(Object, "defineProperty");
                return t({}, "", {}), t
            } catch {}
        }(),
        E4 = lU,
        VS = E4;

    function hU(t, e, n) {
        e == "__proto__" && VS ? VS(t, e, {
            configurable: !0,
            enumerable: !0,
            value: n,
            writable: !0
        }) : t[e] = n
    }
    var hv = hU,
        fU = hv,
        dU = Gp;

    function pU(t, e, n) {
        (n !== void 0 && !dU(t[e], n) || n === void 0 && !(e in t)) && fU(t, e, n)
    }
    var S4 = pU;

    function mU(t) {
        return function(e, n, r) {
            for (var s = -1, i = Object(e), a = r(e), c = a.length; c--;) {
                var l = a[t ? c : ++s];
                if (n(i[l], l, i) === !1) break
            }
            return e
        }
    }
    var gU = mU,
        _U = gU,
        yU = _U(),
        vU = yU,
        md = {
            exports: {}
        };
    md.exports;
    (function(t, e) {
        var n = Ps,
            r = e && !e.nodeType && e,
            s = r && !0 && t && !t.nodeType && t,
            i = s && s.exports === r,
            a = i ? n.Buffer : void 0,
            c = a ? a.allocUnsafe : void 0;

        function l(h, d) {
            if (d) return h.slice();
            var p = h.length,
                g = c ? c(p) : new h.constructor(p);
            return h.copy(g), g
        }
        t.exports = l
    })(md, md.exports);
    var T4 = md.exports,
        bU = Ps,
        EU = bU.Uint8Array,
        SU = EU,
        jS = SU;

    function TU(t) {
        var e = new t.constructor(t.byteLength);
        return new jS(e).set(new jS(t)), e
    }
    var fv = TU,
        wU = fv;

    function OU(t, e) {
        var n = e ? wU(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.length)
    }
    var w4 = OU;

    function AU(t, e) {
        var n = -1,
            r = t.length;
        for (e || (e = Array(r)); ++n < r;) e[n] = t[n];
        return e
    }
    var O4 = AU,
        CU = Rs,
        GS = Object.create,
        IU = function() {
            function t() {}
            return function(e) {
                if (!CU(e)) return {};
                if (GS) return GS(e);
                t.prototype = e;
                var n = new t;
                return t.prototype = void 0, n
            }
        }(),
        kU = IU;

    function NU(t, e) {
        return function(n) {
            return t(e(n))
        }
    }
    var A4 = NU,
        xU = A4,
        PU = xU(Object.getPrototypeOf, Object),
        dv = PU,
        RU = Object.prototype;

    function MU(t) {
        var e = t && t.constructor,
            n = typeof e == "function" && e.prototype || RU;
        return t === n
    }
    var pv = MU,
        DU = kU,
        $U = dv,
        LU = pv;

    function FU(t) {
        return typeof t.constructor == "function" && !LU(t) ? DU($U(t)) : {}
    }
    var C4 = FU;

    function UU(t) {
        return t != null && typeof t == "object"
    }
    var Po = UU,
        BU = ru,
        qU = Po,
        VU = "[object Arguments]";

    function jU(t) {
        return qU(t) && BU(t) == VU
    }
    var GU = jU,
        WS = GU,
        WU = Po,
        I4 = Object.prototype,
        HU = I4.hasOwnProperty,
        KU = I4.propertyIsEnumerable,
        YU = WS(function() {
            return arguments
        }()) ? WS : function(t) {
            return WU(t) && HU.call(t, "callee") && !KU.call(t, "callee")
        },
        k4 = YU,
        zU = Array.isArray,
        Ro = zU,
        ZU = 9007199254740991;

    function XU(t) {
        return typeof t == "number" && t > -1 && t % 1 == 0 && t <= ZU
    }
    var N4 = XU,
        QU = uv,
        JU = N4;

    function eB(t) {
        return t != null && JU(t.length) && !QU(t)
    }
    var Zp = eB,
        tB = Zp,
        nB = Po;

    function rB(t) {
        return nB(t) && tB(t)
    }
    var sB = rB,
        gd = {
            exports: {}
        };

    function iB() {
        return !1
    }
    var oB = iB;
    gd.exports;
    (function(t, e) {
        var n = Ps,
            r = oB,
            s = e && !e.nodeType && e,
            i = s && !0 && t && !t.nodeType && t,
            a = i && i.exports === s,
            c = a ? n.Buffer : void 0,
            l = c ? c.isBuffer : void 0,
            h = l || r;
        t.exports = h
    })(gd, gd.exports);
    var mv = gd.exports,
        aB = ru,
        cB = dv,
        uB = Po,
        lB = "[object Object]",
        hB = Function.prototype,
        fB = Object.prototype,
        x4 = hB.toString,
        dB = fB.hasOwnProperty,
        pB = x4.call(Object);

    function mB(t) {
        if (!uB(t) || aB(t) != lB) return !1;
        var e = cB(t);
        if (e === null) return !0;
        var n = dB.call(e, "constructor") && e.constructor;
        return typeof n == "function" && n instanceof n && x4.call(n) == pB
    }
    var gB = mB,
        _B = ru,
        yB = N4,
        vB = Po,
        bB = "[object Arguments]",
        EB = "[object Array]",
        SB = "[object Boolean]",
        TB = "[object Date]",
        wB = "[object Error]",
        OB = "[object Function]",
        AB = "[object Map]",
        CB = "[object Number]",
        IB = "[object Object]",
        kB = "[object RegExp]",
        NB = "[object Set]",
        xB = "[object String]",
        PB = "[object WeakMap]",
        RB = "[object ArrayBuffer]",
        MB = "[object DataView]",
        DB = "[object Float32Array]",
        $B = "[object Float64Array]",
        LB = "[object Int8Array]",
        FB = "[object Int16Array]",
        UB = "[object Int32Array]",
        BB = "[object Uint8Array]",
        qB = "[object Uint8ClampedArray]",
        VB = "[object Uint16Array]",
        jB = "[object Uint32Array]",
        Xt = {};
    Xt[DB] = Xt[$B] = Xt[LB] = Xt[FB] = Xt[UB] = Xt[BB] = Xt[qB] = Xt[VB] = Xt[jB] = !0;
    Xt[bB] = Xt[EB] = Xt[RB] = Xt[SB] = Xt[MB] = Xt[TB] = Xt[wB] = Xt[OB] = Xt[AB] = Xt[CB] = Xt[IB] = Xt[kB] = Xt[NB] = Xt[xB] = Xt[PB] = !1;

    function GB(t) {
        return vB(t) && yB(t.length) && !!Xt[_B(t)]
    }
    var WB = GB;

    function HB(t) {
        return function(e) {
            return t(e)
        }
    }
    var gv = HB,
        _d = {
            exports: {}
        };
    _d.exports;
    (function(t, e) {
        var n = g4,
            r = e && !e.nodeType && e,
            s = r && !0 && t && !t.nodeType && t,
            i = s && s.exports === r,
            a = i && n.process,
            c = function() {
                try {
                    var l = s && s.require && s.require("util").types;
                    return l || a && a.binding && a.binding("util")
                } catch {}
            }();
        t.exports = c
    })(_d, _d.exports);
    var _v = _d.exports,
        KB = WB,
        YB = gv,
        HS = _v,
        KS = HS && HS.isTypedArray,
        zB = KS ? YB(KS) : KB,
        P4 = zB;

    function ZB(t, e) {
        if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__") return t[e]
    }
    var R4 = ZB,
        XB = hv,
        QB = Gp,
        JB = Object.prototype,
        eq = JB.hasOwnProperty;

    function tq(t, e, n) {
        var r = t[e];
        (!(eq.call(t, e) && QB(r, n)) || n === void 0 && !(e in t)) && XB(t, e, n)
    }
    var yv = tq,
        nq = yv,
        rq = hv;

    function sq(t, e, n, r) {
        var s = !n;
        n || (n = {});
        for (var i = -1, a = e.length; ++i < a;) {
            var c = e[i],
                l = r ? r(n[c], t[c], c, n, t) : void 0;
            l === void 0 && (l = t[c]), s ? rq(n, c, l) : nq(n, c, l)
        }
        return n
    }
    var Zl = sq;

    function iq(t, e) {
        for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
        return r
    }
    var oq = iq,
        aq = 9007199254740991,
        cq = /^(?:0|[1-9]\d*)$/;

    function uq(t, e) {
        var n = typeof t;
        return e = e ?? aq, !!e && (n == "number" || n != "symbol" && cq.test(t)) && t > -1 && t % 1 == 0 && t < e
    }
    var vv = uq,
        lq = oq,
        hq = k4,
        fq = Ro,
        dq = mv,
        pq = vv,
        mq = P4,
        gq = Object.prototype,
        _q = gq.hasOwnProperty;

    function yq(t, e) {
        var n = fq(t),
            r = !n && hq(t),
            s = !n && !r && dq(t),
            i = !n && !r && !s && mq(t),
            a = n || r || s || i,
            c = a ? lq(t.length, String) : [],
            l = c.length;
        for (var h in t)(e || _q.call(t, h)) && !(a && (h == "length" || s && (h == "offset" || h == "parent") || i && (h == "buffer" || h == "byteLength" || h == "byteOffset") || pq(h, l))) && c.push(h);
        return c
    }
    var M4 = yq;

    function vq(t) {
        var e = [];
        if (t != null)
            for (var n in Object(t)) e.push(n);
        return e
    }
    var bq = vq,
        Eq = Rs,
        Sq = pv,
        Tq = bq,
        wq = Object.prototype,
        Oq = wq.hasOwnProperty;

    function Aq(t) {
        if (!Eq(t)) return Tq(t);
        var e = Sq(t),
            n = [];
        for (var r in t) r == "constructor" && (e || !Oq.call(t, r)) || n.push(r);
        return n
    }
    var Cq = Aq,
        Iq = M4,
        kq = Cq,
        Nq = Zp;

    function xq(t) {
        return Nq(t) ? Iq(t, !0) : kq(t)
    }
    var Xl = xq,
        Pq = Zl,
        Rq = Xl;

    function Mq(t) {
        return Pq(t, Rq(t))
    }
    var Dq = Mq,
        YS = S4,
        $q = T4,
        Lq = w4,
        Fq = O4,
        Uq = C4,
        zS = k4,
        ZS = Ro,
        Bq = sB,
        qq = mv,
        Vq = uv,
        jq = Rs,
        Gq = gB,
        Wq = P4,
        XS = R4,
        Hq = Dq;

    function Kq(t, e, n, r, s, i, a) {
        var c = XS(t, n),
            l = XS(e, n),
            h = a.get(l);
        if (h) {
            YS(t, n, h);
            return
        }
        var d = i ? i(c, l, n + "", t, e, a) : void 0,
            p = d === void 0;
        if (p) {
            var g = ZS(l),
                v = !g && qq(l),
                b = !g && !v && Wq(l);
            d = l, g || v || b ? ZS(c) ? d = c : Bq(c) ? d = Fq(c) : v ? (p = !1, d = $q(l, !0)) : b ? (p = !1, d = Lq(l, !0)) : d = [] : Gq(l) || zS(l) ? (d = c, zS(c) ? d = Hq(c) : (!jq(c) || Vq(c)) && (d = Uq(l))) : p = !1
        }
        p && (a.set(l, d), s(d, l, r, i, a), a.delete(l)), YS(t, n, d)
    }
    var Yq = Kq,
        zq = b4,
        Zq = S4,
        Xq = vU,
        Qq = Yq,
        Jq = Rs,
        eV = Xl,
        tV = R4;

    function D4(t, e, n, r, s) {
        t !== e && Xq(e, function(i, a) {
            if (s || (s = new zq), Jq(i)) Qq(t, e, a, n, D4, r, s);
            else {
                var c = r ? r(tV(t, a), i, a + "", t, e, s) : void 0;
                c === void 0 && (c = i), Zq(t, a, c)
            }
        }, eV)
    }
    var nV = D4;

    function rV(t) {
        return t
    }
    var $4 = rV;

    function sV(t, e, n) {
        switch (n.length) {
            case 0:
                return t.call(e);
            case 1:
                return t.call(e, n[0]);
            case 2:
                return t.call(e, n[0], n[1]);
            case 3:
                return t.call(e, n[0], n[1], n[2])
        }
        return t.apply(e, n)
    }
    var iV = sV,
        oV = iV,
        QS = Math.max;

    function aV(t, e, n) {
        return e = QS(e === void 0 ? t.length - 1 : e, 0),
            function() {
                for (var r = arguments, s = -1, i = QS(r.length - e, 0), a = Array(i); ++s < i;) a[s] = r[e + s];
                s = -1;
                for (var c = Array(e + 1); ++s < e;) c[s] = r[s];
                return c[e] = n(a), oV(t, this, c)
            }
    }
    var cV = aV;

    function uV(t) {
        return function() {
            return t
        }
    }
    var lV = uV,
        hV = lV,
        JS = E4,
        fV = $4,
        dV = JS ? function(t, e) {
            return JS(t, "toString", {
                configurable: !0,
                enumerable: !1,
                value: hV(e),
                writable: !0
            })
        } : fV,
        pV = dV,
        mV = 800,
        gV = 16,
        _V = Date.now;

    function yV(t) {
        var e = 0,
            n = 0;
        return function() {
            var r = _V(),
                s = gV - (r - n);
            if (n = r, s > 0) {
                if (++e >= mV) return arguments[0]
            } else e = 0;
            return t.apply(void 0, arguments)
        }
    }
    var vV = yV,
        bV = pV,
        EV = vV,
        SV = EV(bV),
        TV = SV,
        wV = $4,
        OV = cV,
        AV = TV;

    function CV(t, e) {
        return AV(OV(t, e, wV), t + "")
    }
    var IV = CV,
        kV = Gp,
        NV = Zp,
        xV = vv,
        PV = Rs;

    function RV(t, e, n) {
        if (!PV(n)) return !1;
        var r = typeof e;
        return (r == "number" ? NV(n) && xV(e, n.length) : r == "string" && e in n) ? kV(n[e], t) : !1
    }
    var MV = RV,
        DV = IV,
        $V = MV;

    function LV(t) {
        return DV(function(e, n) {
            var r = -1,
                s = n.length,
                i = s > 1 ? n[s - 1] : void 0,
                a = s > 2 ? n[2] : void 0;
            for (i = t.length > 3 && typeof i == "function" ? (s--, i) : void 0, a && $V(n[0], n[1], a) && (i = s < 3 ? void 0 : i, s = 1), e = Object(e); ++r < s;) {
                var c = n[r];
                c && t(e, c, r, i)
            }
            return e
        })
    }
    var FV = LV,
        UV = nV,
        BV = FV,
        qV = BV(function(t, e, n) {
            UV(t, e, n)
        }),
        VV = qV;
    const jV = eu(VV);
    class vc {
        static set(e) {
            if (e && this.isSupported(e)) {
                this.locale = e;
                return
            }
            this.locale = this.getPreferredDeviceLocale()
        }
        static getPreferredDeviceLocale() {
            const e = navigator.languages;
            for (let n = 0; n < e.length; n++)
                if (this.isSupported(e[n])) return e[n];
            return this.supported[0]
        }
        static isSupported(e) {
            return Object.values(this.supported).includes(e)
        }
        static mergeMessages(...e) {
            return jV(e[0], ...e)
        }
    }
    Ce(vc, "locale"), Ce(vc, "supported", ["en", "fr", "it", "de", "es", "es-XL"]);
    var uo;
    let bs = (uo = class {
        static get serverUrl() {
            const e = this.getQueryParam("server") ?? this.getQueryParam("s");
            return !e || e === "live" ? "ecast.jackboxgames.com" : e === "local" ? "https://localhost" : e.includes("localhost") ? e : `${e}.jackboxgames.com`
        }
        static get isCanvasSupported() {
            const e = document.createElement("canvas");
            return !!(e.getContext && e.getContext("2d"))
        }
        static toPrecision(e, n) {
            const r = 10 ** n;
            return Math.round((e + Number.EPSILON) * r) / r
        }
        static isProduction() {
            return window.location.hostname === "jackbox.tv"
        }
        static htmlUnescape(e) {
            return String(e).replace(/&quot;/gi, '"').replace(/&#39;/gi, "'").replace(/&lt;/gi, "<").replace(/&gt;/gi, ">").replace(/&amp;/gi, "&")
        }
        static htmlEscape(e) {
            return String(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
        }
        static sanitize(e) {
            const n = this.sanitizeInput(e).replace(/'/g, "");
            return this.htmlEscape(n).trim()
        }
        static sanitizeName(e) {
            return e.replace(/[^A-Z0-9\u00A1\u0020-\u002F\u00BF-\u00FF\u2026!?*$+\-'_ .,]/gi, "").replace(/'/g, "")
        }
        static sanitizeInput(e) {
            return e = e.replace("", "..."), e.replace(/[^\u00A1\u0020-\u007E\u00BF-\u00FF]/gi, "")
        }
        static sanitizeEmoji(e) {
            return e.replace(/(\u00a9|\u00ae|[\u2000-\u2017]|[\u2020-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/, "")
        }
        static safeText(e) {
            const n = document.createElement("div");
            return n.textContent = e, n.innerHTML
        }
        static htmlTagsToBBCode(e, n) {
            if (!n.length) throw new Error("[Utils.htmlTagsToBBCode] No tag pairs were passed in");
            return n.reduce((r, s) => (r.replaceAll(`<${s[0]}>`, `[${s[1]}]`), r.replaceAll(`</${s[0]}>`, `</${s[1]}>`), r), e)
        }
        static hexToRgb(e) {
            const n = new ArrayBuffer(4);
            new DataView(n).setUint32(0, parseInt(e.replace("#", ""), 16), !1);
            const s = new Uint8Array(n);
            return `${s[1]},${s[2]},${s[3]}`
        }
        static adjustColor(e, n) {
            let r = !1,
                s = e;
            s[0] === "#" && (s = s.slice(1), r = !0);
            const i = parseInt(s, 16),
                a = Math.min(Math.max(0, (i >> 16) * n), 255),
                c = Math.min(Math.max(0, (i >> 8 & 255) * n), 255);
            let h = (Math.min(Math.max(0, (i & 255) * n), 255) | c << 8 | a << 16).toString(16);
            for (; h.length < s.length;) h = `0${h}`;
            return (r ? "#" : "") + h
        }
        static isInTolerance(e, n, r) {
            return !(Math.abs(e.x - n.x) < r || Math.abs(e.y - n.y) > r)
        }
        static getDistanceBetweenPoints(e, n) {
            const r = [e.x - n.x, e.y - n.y],
                s = Math.hypot(...r);
            return Math.round(s * 100) / 100
        }
        static getMidpoint(e, n) {
            return {
                x: (e.x + n.x) / 2,
                y: (e.y + n.y) / 2
            }
        }
        static getAngleBetweenPoints(e, n) {
            let s = Math.atan2(n.y - e.y, n.x - e.x) * (180 / Math.PI);
            return s < 0 && (s += 360), 360 - s
        }
        static getAngularDistance(e, n) {
            let r = (n - e) % 360;
            const s = r < 0 ? 1 : -1;
            return r = Math.abs(r), r > 180 ? s * (360 - r) : s * r
        }
        static getVelocity(e, n, r, s) {
            return this.getDistanceBetweenPoints(e, r) / (s - n)
        }
        static isInsideElement(e, n) {
            const r = n.getBoundingClientRect();
            return !(e.x < r.left || e.x > r.left + r.width || e.y < r.top || e.y > r.top + r.height)
        }
        static cyrb128(e) {
            let n = 1779033703,
                r = 3144134277,
                s = 1013904242,
                i = 2773480762;
            for (let a = 0, c; a < e.length; a++) c = e.charCodeAt(a), n = r ^ Math.imul(n ^ c, 597399067), r = s ^ Math.imul(r ^ c, 2869860233), s = i ^ Math.imul(s ^ c, 951274213), i = n ^ Math.imul(i ^ c, 2716044179);
            return n = Math.imul(s ^ n >>> 18, 597399067), r = Math.imul(i ^ r >>> 22, 2869860233), s = Math.imul(n ^ s >>> 17, 951274213), i = Math.imul(r ^ i >>> 19, 2716044179), [(n ^ r ^ s ^ i) >>> 0, (r ^ n) >>> 0, (s ^ n) >>> 0, (i ^ n) >>> 0]
        }
        static sfc32(e, n, r, s) {
            return function() {
                e >>>= 0, n >>>= 0, r >>>= 0, s >>>= 0;
                let a = e + n | 0;
                return e = n ^ n >>> 9, n = r + (r << 3) | 0, r = r << 21 | r >>> 11, s = s + 1 | 0, a = a + s | 0, r = r + a | 0, (a >>> 0) / 4294967296
            }
        }
    }, Ce(uo, "queryParams", new URLSearchParams(window.location.search)), Ce(uo, "getQueryParam", e => uo.queryParams.get(e)), Ce(uo, "sleep", e => new Promise(n => {
        window.setTimeout(n, e)
    })), uo);
    class un {
        static get namespace() {
            var e;
            return ((e = window.tv.storage) == null ? void 0 : e.namespace) ?? this.defaultNamespace
        }
        static get isDisabled() {
            var e;
            return ((e = window.tv.storage) == null ? void 0 : e.isDisabled) ?? !1
        }
        static get tag() {
            var e;
            return (e = window.tv.storage) == null ? void 0 : e.tag
        }
        static get code() {
            var e;
            return (e = window.tv.storage) == null ? void 0 : e.code
        }
        static get isSupported() {
            if (this.isDisabled) return !1;
            try {
                return window.localStorage ? (window.localStorage.setItem("support-check", "1"), window.localStorage.removeItem("support-check"), !0) : !1
            } catch {
                return !1
            }
        }
        static setup(e, n) {
            delete window.tv.storage, window.tv.storage = {
                namespace: bs.getQueryParam("namespace") ?? bs.getQueryParam("ns") ?? this.defaultNamespace,
                isDisabled: bs.queryParams.has("incognito") || bs.queryParams.has("nc")
            }, e && (window.tv.storage.tag = e), n && (window.tv.storage.code = n.toLowerCase(), this.clearCodeScopedKeys(window.tv.storage.code))
        }
        static get(e, n) {
            return this.isSupported ? window.localStorage.getItem(this.getScopedKey(e, n)) : null
        }
        static set(e, n, r = "none") {
            if (this.isSupported) return window.localStorage.setItem(this.getScopedSetKey(e, r), n)
        }
        static remove(e, n) {
            if (this.isSupported) return window.localStorage.removeItem(this.getScopedKey(e, n))
        }
        static setTag(e) {
            const n = e.toLowerCase(),
                r = this.get("tags") ?? "[]",
                s = n.split("-")[0];
            let i = JSON.parse(r);
            i = i.filter(a => {
                const c = a.split("-")[0];
                return s !== c
            }), i.push(n), this.set("tags", JSON.stringify(i))
        }
        static getScopedKey(e, n) {
            const r = `${this.namespace}:${e}`,
                s = this.tag ? `${this.namespace}:${e}:tag:${this.tag}` : null,
                i = this.code ? `${this.namespace}:${e}:code:${this.code}` : null;
            if (n === "none") return r;
            if (n === "tag") {
                if (!s) throw new Error('[Storage] requested "tag" scope but tv.storage.tag is undefined');
                return s
            }
            if (n === "code") {
                if (!i) throw new Error('[Storage] requested "code" scope but tv.storage.code is undefined');
                return i
            }
            return i && window.localStorage.getItem(i) !== null ? i : s && window.localStorage.getItem(s) !== null ? s : r
        }
        static getScopedSetKey(e, n = "none") {
            if (n === "tag") {
                if (!this.tag) throw new Error('[Storage] requested "room" scope but tv.storage.tag is undefined');
                return `${this.namespace}:${e}:tag:${this.tag}`
            }
            if (n === "code") {
                if (!this.code) throw new Error('[Storage] requested "code" scope but tv.storage.code is undefined');
                return `${this.namespace}:${e}:code:${this.code}`
            }
            return `${this.namespace}:${e}`
        }
        static clearCodeScopedKeys(e) {
            this.isSupported && Object.keys(window.localStorage).forEach(n => {
                const r = n.split(":code:");
                r.length <= 1 || r[1] !== e && window.localStorage.removeItem(n)
            })
        }
    }
    Ce(un, "defaultNamespace", "tv");
    class yd {
        constructor() {
            Ce(this, "artifacts");
            this.artifacts = this.list()
        }
        get hasUnviewed() {
            return this.artifacts.some(e => !e.viewed)
        }
        add(e, n) {
            yd.add(e, n), this.artifacts = this.list()
        }
        static add(e, n) {
            if (!un.isSupported) return;
            const r = this.isTestArtifact(e) ? "http" : "https",
                s = this.isTestArtifact(e) ? "games-test.jackbox.tv" : "games.jackbox.tv",
                i = `${r}://${s}/artifact/${e.categoryId}/${e.artifactId}/`,
                a = un.get("galleries") || "[]";
            try {
                const c = JSON.parse(a) || [];
                if (c.some(l => l.url === i)) return;
                c.unshift({
                    url: i,
                    time: new Date().getTime(),
                    categoryId: e.categoryId,
                    viewed: !1
                }), un.set("galleries", JSON.stringify(c.slice(0, 40)))
            } catch {
                console.warn("[Artifacts] Unable to add artifact to local storage")
            }
        }
        remove(e) {
            if (!un.isSupported) return;
            const n = un.get("galleries") || "[]";
            try {
                const r = JSON.parse(n) || [];
                r.splice(e, 1), un.set("galleries", JSON.stringify(r)), this.artifacts = this.list()
            } catch {
                console.warn("[Artifacts] Unable to remove artifact")
            }
        }
        setAsViewed(e) {
            yd.setAsViewed(e), this.artifacts = this.list()
        }
        static setAsViewed(e) {
            if (!un.isSupported) return;
            const n = un.get("galleries") || "[]";
            try {
                const r = JSON.parse(n) || [];
                r.length && (r[e].viewed = !0), un.set("galleries", JSON.stringify(r))
            } catch {
                console.warn(`[Artifacts] Unable to mark artifact ${e} as viewed`)
            }
        }
        static isTestArtifact(e) {
            var n;
            return ((n = e == null ? void 0 : e.rootId) == null ? void 0 : n.indexOf("test")) !== -1
        }
        list() {
            if (!un.isSupported) return [];
            const e = new Intl.DateTimeFormat(vc.locale, {
                    year: "numeric",
                    month: "short",
                    day: "numeric"
                }),
                n = un.get("galleries") || "[]",
                r = Date.now();
            try {
                return (JSON.parse(n) || []).filter(i => r - i.time < 525600 * 60 * 1e3).map(i => {
                    const a = new Date(i.time),
                        c = e.format(a),
                        l = i.url.split("/"),
                        h = l[l.length - 1] === "" ? l[l.length - 2] : l[l.length - 1];
                    let d = i.categoryId;
                    return d || (i.url.indexOf("Quiplash2") !== -1 ? d = "Quiplash2Game" : i.url.indexOf("Drawful") !== -1 ? d = "DrawfulGame" : i.url.indexOf("TeeKO") !== -1 ? d = "TeeKOGame" : i.url.indexOf("TriviaDeath") !== -1 && (d = "TriviaDeathResults")), {
                        id: h,
                        gameName: d,
                        date: c,
                        ...i
                    }
                })
            } catch {
                return console.warn("[Artifacts] Unable to parse artifacts array"), []
            }
        }
    }
    var h1 = {
        exports: {}
    };
    (function(t, e) {
        var n = typeof self < "u" ? self : hn,
            r = function() {
                function i() {
                    this.fetch = !1, this.DOMException = n.DOMException
                }
                return i.prototype = n, new i
            }();
        (function(i) {
            (function(a) {
                var c = {
                    searchParams: "URLSearchParams" in i,
                    iterable: "Symbol" in i && "iterator" in Symbol,
                    blob: "FileReader" in i && "Blob" in i && function() {
                        try {
                            return new Blob, !0
                        } catch {
                            return !1
                        }
                    }(),
                    formData: "FormData" in i,
                    arrayBuffer: "ArrayBuffer" in i
                };

                function l(G) {
                    return G && DataView.prototype.isPrototypeOf(G)
                }
                if (c.arrayBuffer) var h = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                    d = ArrayBuffer.isView || function(G) {
                        return G && h.indexOf(Object.prototype.toString.call(G)) > -1
                    };

                function p(G) {
                    if (typeof G != "string" && (G = String(G)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(G)) throw new TypeError("Invalid character in header field name");
                    return G.toLowerCase()
                }

                function g(G) {
                    return typeof G != "string" && (G = String(G)), G
                }

                function v(G) {
                    var le = {
                        next: function() {
                            var fe = G.shift();
                            return {
                                done: fe === void 0,
                                value: fe
                            }
                        }
                    };
                    return c.iterable && (le[Symbol.iterator] = function() {
                        return le
                    }), le
                }

                function b(G) {
                    this.map = {}, G instanceof b ? G.forEach(function(le, fe) {
                        this.append(fe, le)
                    }, this) : Array.isArray(G) ? G.forEach(function(le) {
                        this.append(le[0], le[1])
                    }, this) : G && Object.getOwnPropertyNames(G).forEach(function(le) {
                        this.append(le, G[le])
                    }, this)
                }
                b.prototype.append = function(G, le) {
                    G = p(G), le = g(le);
                    var fe = this.map[G];
                    this.map[G] = fe ? fe + ", " + le : le
                }, b.prototype.delete = function(G) {
                    delete this.map[p(G)]
                }, b.prototype.get = function(G) {
                    return G = p(G), this.has(G) ? this.map[G] : null
                }, b.prototype.has = function(G) {
                    return this.map.hasOwnProperty(p(G))
                }, b.prototype.set = function(G, le) {
                    this.map[p(G)] = g(le)
                }, b.prototype.forEach = function(G, le) {
                    for (var fe in this.map) this.map.hasOwnProperty(fe) && G.call(le, this.map[fe], fe, this)
                }, b.prototype.keys = function() {
                    var G = [];
                    return this.forEach(function(le, fe) {
                        G.push(fe)
                    }), v(G)
                }, b.prototype.values = function() {
                    var G = [];
                    return this.forEach(function(le) {
                        G.push(le)
                    }), v(G)
                }, b.prototype.entries = function() {
                    var G = [];
                    return this.forEach(function(le, fe) {
                        G.push([fe, le])
                    }), v(G)
                }, c.iterable && (b.prototype[Symbol.iterator] = b.prototype.entries);

                function T(G) {
                    if (G.bodyUsed) return Promise.reject(new TypeError("Already read"));
                    G.bodyUsed = !0
                }

                function m(G) {
                    return new Promise(function(le, fe) {
                        G.onload = function() {
                            le(G.result)
                        }, G.onerror = function() {
                            fe(G.error)
                        }
                    })
                }

                function w(G) {
                    var le = new FileReader,
                        fe = m(le);
                    return le.readAsArrayBuffer(G), fe
                }

                function P(G) {
                    var le = new FileReader,
                        fe = m(le);
                    return le.readAsText(G), fe
                }

                function V(G) {
                    for (var le = new Uint8Array(G), fe = new Array(le.length), me = 0; me < le.length; me++) fe[me] = String.fromCharCode(le[me]);
                    return fe.join("")
                }

                function M(G) {
                    if (G.slice) return G.slice(0);
                    var le = new Uint8Array(G.byteLength);
                    return le.set(new Uint8Array(G)), le.buffer
                }

                function I() {
                    return this.bodyUsed = !1, this._initBody = function(G) {
                        this._bodyInit = G, G ? typeof G == "string" ? this._bodyText = G : c.blob && Blob.prototype.isPrototypeOf(G) ? this._bodyBlob = G : c.formData && FormData.prototype.isPrototypeOf(G) ? this._bodyFormData = G : c.searchParams && URLSearchParams.prototype.isPrototypeOf(G) ? this._bodyText = G.toString() : c.arrayBuffer && c.blob && l(G) ? (this._bodyArrayBuffer = M(G.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : c.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(G) || d(G)) ? this._bodyArrayBuffer = M(G) : this._bodyText = G = Object.prototype.toString.call(G) : this._bodyText = "", this.headers.get("content-type") || (typeof G == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : c.searchParams && URLSearchParams.prototype.isPrototypeOf(G) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                    }, c.blob && (this.blob = function() {
                        var G = T(this);
                        if (G) return G;
                        if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                        if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                        if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                        return Promise.resolve(new Blob([this._bodyText]))
                    }, this.arrayBuffer = function() {
                        return this._bodyArrayBuffer ? T(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(w)
                    }), this.text = function() {
                        var G = T(this);
                        if (G) return G;
                        if (this._bodyBlob) return P(this._bodyBlob);
                        if (this._bodyArrayBuffer) return Promise.resolve(V(this._bodyArrayBuffer));
                        if (this._bodyFormData) throw new Error("could not read FormData body as text");
                        return Promise.resolve(this._bodyText)
                    }, c.formData && (this.formData = function() {
                        return this.text().then(se)
                    }), this.json = function() {
                        return this.text().then(JSON.parse)
                    }, this
                }
                var L = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

                function B(G) {
                    var le = G.toUpperCase();
                    return L.indexOf(le) > -1 ? le : G
                }

                function q(G, le) {
                    le = le || {};
                    var fe = le.body;
                    if (G instanceof q) {
                        if (G.bodyUsed) throw new TypeError("Already read");
                        this.url = G.url, this.credentials = G.credentials, le.headers || (this.headers = new b(G.headers)), this.method = G.method, this.mode = G.mode, this.signal = G.signal, !fe && G._bodyInit != null && (fe = G._bodyInit, G.bodyUsed = !0)
                    } else this.url = String(G);
                    if (this.credentials = le.credentials || this.credentials || "same-origin", (le.headers || !this.headers) && (this.headers = new b(le.headers)), this.method = B(le.method || this.method || "GET"), this.mode = le.mode || this.mode || null, this.signal = le.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && fe) throw new TypeError("Body not allowed for GET or HEAD requests");
                    this._initBody(fe)
                }
                q.prototype.clone = function() {
                    return new q(this, {
                        body: this._bodyInit
                    })
                };

                function se(G) {
                    var le = new FormData;
                    return G.trim().split("&").forEach(function(fe) {
                        if (fe) {
                            var me = fe.split("="),
                                Te = me.shift().replace(/\+/g, " "),
                                we = me.join("=").replace(/\+/g, " ");
                            le.append(decodeURIComponent(Te), decodeURIComponent(we))
                        }
                    }), le
                }

                function ce(G) {
                    var le = new b,
                        fe = G.replace(/\r?\n[\t ]+/g, " ");
                    return fe.split(/\r?\n/).forEach(function(me) {
                        var Te = me.split(":"),
                            we = Te.shift().trim();
                        if (we) {
                            var ke = Te.join(":").trim();
                            le.append(we, ke)
                        }
                    }), le
                }
                I.call(q.prototype);

                function ue(G, le) {
                    le || (le = {}), this.type = "default", this.status = le.status === void 0 ? 200 : le.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in le ? le.statusText : "OK", this.headers = new b(le.headers), this.url = le.url || "", this._initBody(G)
                }
                I.call(ue.prototype), ue.prototype.clone = function() {
                    return new ue(this._bodyInit, {
                        status: this.status,
                        statusText: this.statusText,
                        headers: new b(this.headers),
                        url: this.url
                    })
                }, ue.error = function() {
                    var G = new ue(null, {
                        status: 0,
                        statusText: ""
                    });
                    return G.type = "error", G
                };
                var ee = [301, 302, 303, 307, 308];
                ue.redirect = function(G, le) {
                    if (ee.indexOf(le) === -1) throw new RangeError("Invalid status code");
                    return new ue(null, {
                        status: le,
                        headers: {
                            location: G
                        }
                    })
                }, a.DOMException = i.DOMException;
                try {
                    new a.DOMException
                } catch {
                    a.DOMException = function(le, fe) {
                        this.message = le, this.name = fe;
                        var me = Error(le);
                        this.stack = me.stack
                    }, a.DOMException.prototype = Object.create(Error.prototype), a.DOMException.prototype.constructor = a.DOMException
                }

                function ge(G, le) {
                    return new Promise(function(fe, me) {
                        var Te = new q(G, le);
                        if (Te.signal && Te.signal.aborted) return me(new a.DOMException("Aborted", "AbortError"));
                        var we = new XMLHttpRequest;

                        function ke() {
                            we.abort()
                        }
                        we.onload = function() {
                            var Ie = {
                                status: we.status,
                                statusText: we.statusText,
                                headers: ce(we.getAllResponseHeaders() || "")
                            };
                            Ie.url = "responseURL" in we ? we.responseURL : Ie.headers.get("X-Request-URL");
                            var $e = "response" in we ? we.response : we.responseText;
                            fe(new ue($e, Ie))
                        }, we.onerror = function() {
                            me(new TypeError("Network request failed"))
                        }, we.ontimeout = function() {
                            me(new TypeError("Network request failed"))
                        }, we.onabort = function() {
                            me(new a.DOMException("Aborted", "AbortError"))
                        }, we.open(Te.method, Te.url, !0), Te.credentials === "include" ? we.withCredentials = !0 : Te.credentials === "omit" && (we.withCredentials = !1), "responseType" in we && c.blob && (we.responseType = "blob"), Te.headers.forEach(function(Ie, $e) {
                            we.setRequestHeader($e, Ie)
                        }), Te.signal && (Te.signal.addEventListener("abort", ke), we.onreadystatechange = function() {
                            we.readyState === 4 && Te.signal.removeEventListener("abort", ke)
                        }), we.send(typeof Te._bodyInit > "u" ? null : Te._bodyInit)
                    })
                }
                return ge.polyfill = !0, i.fetch || (i.fetch = ge, i.Headers = b, i.Request = q, i.Response = ue), a.Headers = b, a.Request = q, a.Response = ue, a.fetch = ge, Object.defineProperty(a, "__esModule", {
                    value: !0
                }), a
            })({})
        })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
        var s = r;
        e = s.fetch, e.default = s.fetch, e.fetch = s.fetch, e.Headers = s.Headers, e.Request = s.Request, e.Response = s.Response, t.exports = e
    })(h1, h1.exports);
    var GV = h1.exports,
        WV = function() {
            if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
            if (typeof Symbol.iterator == "symbol") return !0;
            var e = {},
                n = Symbol("test"),
                r = Object(n);
            if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]") return !1;
            var s = 42;
            e[n] = s;
            for (n in e) return !1;
            if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
            var i = Object.getOwnPropertySymbols(e);
            if (i.length !== 1 || i[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n)) return !1;
            if (typeof Object.getOwnPropertyDescriptor == "function") {
                var a = Object.getOwnPropertyDescriptor(e, n);
                if (a.value !== s || a.enumerable !== !0) return !1
            }
            return !0
        },
        eT = typeof Symbol < "u" && Symbol,
        HV = WV,
        KV = function() {
            return typeof eT != "function" || typeof Symbol != "function" || typeof eT("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : HV()
        },
        YV = "Function.prototype.bind called on incompatible ",
        o_ = Array.prototype.slice,
        zV = Object.prototype.toString,
        ZV = "[object Function]",
        XV = function(e) {
            var n = this;
            if (typeof n != "function" || zV.call(n) !== ZV) throw new TypeError(YV + n);
            for (var r = o_.call(arguments, 1), s, i = function() {
                    if (this instanceof s) {
                        var d = n.apply(this, r.concat(o_.call(arguments)));
                        return Object(d) === d ? d : this
                    } else return n.apply(e, r.concat(o_.call(arguments)))
                }, a = Math.max(0, n.length - r.length), c = [], l = 0; l < a; l++) c.push("$" + l);
            if (s = Function("binder", "return function (" + c.join(",") + "){ return binder.apply(this,arguments); }")(i), n.prototype) {
                var h = function() {};
                h.prototype = n.prototype, s.prototype = new h, h.prototype = null
            }
            return s
        },
        QV = XV,
        bv = Function.prototype.bind || QV,
        JV = bv,
        ej = JV.call(Function.call, Object.prototype.hasOwnProperty),
        Ct, Dc = SyntaxError,
        L4 = Function,
        bc = TypeError,
        a_ = function(t) {
            try {
                return L4('"use strict"; return (' + t + ").constructor;")()
            } catch {}
        },
        ga = Object.getOwnPropertyDescriptor;
    if (ga) try {
        ga({}, "")
    } catch {
        ga = null
    }
    var c_ = function() {
            throw new bc
        },
        tj = ga ? function() {
            try {
                return arguments.callee, c_
            } catch {
                try {
                    return ga(arguments, "callee").get
                } catch {
                    return c_
                }
            }
        }() : c_,
        Ja = KV(),
        io = Object.getPrototypeOf || function(t) {
            return t.__proto__
        },
        rc = {},
        nj = typeof Uint8Array > "u" ? Ct : io(Uint8Array),
        Ec = {
            "%AggregateError%": typeof AggregateError > "u" ? Ct : AggregateError,
            "%Array%": Array,
            "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Ct : ArrayBuffer,
            "%ArrayIteratorPrototype%": Ja ? io([][Symbol.iterator]()) : Ct,
            "%AsyncFromSyncIteratorPrototype%": Ct,
            "%AsyncFunction%": rc,
            "%AsyncGenerator%": rc,
            "%AsyncGeneratorFunction%": rc,
            "%AsyncIteratorPrototype%": rc,
            "%Atomics%": typeof Atomics > "u" ? Ct : Atomics,
            "%BigInt%": typeof BigInt > "u" ? Ct : BigInt,
            "%Boolean%": Boolean,
            "%DataView%": typeof DataView > "u" ? Ct : DataView,
            "%Date%": Date,
            "%decodeURI%": decodeURI,
            "%decodeURIComponent%": decodeURIComponent,
            "%encodeURI%": encodeURI,
            "%encodeURIComponent%": encodeURIComponent,
            "%Error%": Error,
            "%eval%": eval,
            "%EvalError%": EvalError,
            "%Float32Array%": typeof Float32Array > "u" ? Ct : Float32Array,
            "%Float64Array%": typeof Float64Array > "u" ? Ct : Float64Array,
            "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Ct : FinalizationRegistry,
            "%Function%": L4,
            "%GeneratorFunction%": rc,
            "%Int8Array%": typeof Int8Array > "u" ? Ct : Int8Array,
            "%Int16Array%": typeof Int16Array > "u" ? Ct : Int16Array,
            "%Int32Array%": typeof Int32Array > "u" ? Ct : Int32Array,
            "%isFinite%": isFinite,
            "%isNaN%": isNaN,
            "%IteratorPrototype%": Ja ? io(io([][Symbol.iterator]())) : Ct,
            "%JSON%": typeof JSON == "object" ? JSON : Ct,
            "%Map%": typeof Map > "u" ? Ct : Map,
            "%MapIteratorPrototype%": typeof Map > "u" || !Ja ? Ct : io(new Map()[Symbol.iterator]()),
            "%Math%": Math,
            "%Number%": Number,
            "%Object%": Object,
            "%parseFloat%": parseFloat,
            "%parseInt%": parseInt,
            "%Promise%": typeof Promise > "u" ? Ct : Promise,
            "%Proxy%": typeof Proxy > "u" ? Ct : Proxy,
            "%RangeError%": RangeError,
            "%ReferenceError%": ReferenceError,
            "%Reflect%": typeof Reflect > "u" ? Ct : Reflect,
            "%RegExp%": RegExp,
            "%Set%": typeof Set > "u" ? Ct : Set,
            "%SetIteratorPrototype%": typeof Set > "u" || !Ja ? Ct : io(new Set()[Symbol.iterator]()),
            "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Ct : SharedArrayBuffer,
            "%String%": String,
            "%StringIteratorPrototype%": Ja ? io("" [Symbol.iterator]()) : Ct,
            "%Symbol%": Ja ? Symbol : Ct,
            "%SyntaxError%": Dc,
            "%ThrowTypeError%": tj,
            "%TypedArray%": nj,
            "%TypeError%": bc,
            "%Uint8Array%": typeof Uint8Array > "u" ? Ct : Uint8Array,
            "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Ct : Uint8ClampedArray,
            "%Uint16Array%": typeof Uint16Array > "u" ? Ct : Uint16Array,
            "%Uint32Array%": typeof Uint32Array > "u" ? Ct : Uint32Array,
            "%URIError%": URIError,
            "%WeakMap%": typeof WeakMap > "u" ? Ct : WeakMap,
            "%WeakRef%": typeof WeakRef > "u" ? Ct : WeakRef,
            "%WeakSet%": typeof WeakSet > "u" ? Ct : WeakSet
        },
        rj = function t(e) {
            var n;
            if (e === "%AsyncFunction%") n = a_("async function () {}");
            else if (e === "%GeneratorFunction%") n = a_("function* () {}");
            else if (e === "%AsyncGeneratorFunction%") n = a_("async function* () {}");
            else if (e === "%AsyncGenerator%") {
                var r = t("%AsyncGeneratorFunction%");
                r && (n = r.prototype)
            } else if (e === "%AsyncIteratorPrototype%") {
                var s = t("%AsyncGenerator%");
                s && (n = io(s.prototype))
            }
            return Ec[e] = n, n
        },
        tT = {
            "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
            "%ArrayPrototype%": ["Array", "prototype"],
            "%ArrayProto_entries%": ["Array", "prototype", "entries"],
            "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
            "%ArrayProto_keys%": ["Array", "prototype", "keys"],
            "%ArrayProto_values%": ["Array", "prototype", "values"],
            "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
            "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
            "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
            "%BooleanPrototype%": ["Boolean", "prototype"],
            "%DataViewPrototype%": ["DataView", "prototype"],
            "%DatePrototype%": ["Date", "prototype"],
            "%ErrorPrototype%": ["Error", "prototype"],
            "%EvalErrorPrototype%": ["EvalError", "prototype"],
            "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
            "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
            "%FunctionPrototype%": ["Function", "prototype"],
            "%Generator%": ["GeneratorFunction", "prototype"],
            "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
            "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
            "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
            "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
            "%JSONParse%": ["JSON", "parse"],
            "%JSONStringify%": ["JSON", "stringify"],
            "%MapPrototype%": ["Map", "prototype"],
            "%NumberPrototype%": ["Number", "prototype"],
            "%ObjectPrototype%": ["Object", "prototype"],
            "%ObjProto_toString%": ["Object", "prototype", "toString"],
            "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
            "%PromisePrototype%": ["Promise", "prototype"],
            "%PromiseProto_then%": ["Promise", "prototype", "then"],
            "%Promise_all%": ["Promise", "all"],
            "%Promise_reject%": ["Promise", "reject"],
            "%Promise_resolve%": ["Promise", "resolve"],
            "%RangeErrorPrototype%": ["RangeError", "prototype"],
            "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
            "%RegExpPrototype%": ["RegExp", "prototype"],
            "%SetPrototype%": ["Set", "prototype"],
            "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
            "%StringPrototype%": ["String", "prototype"],
            "%SymbolPrototype%": ["Symbol", "prototype"],
            "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
            "%TypedArrayPrototype%": ["TypedArray", "prototype"],
            "%TypeErrorPrototype%": ["TypeError", "prototype"],
            "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
            "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
            "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
            "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
            "%URIErrorPrototype%": ["URIError", "prototype"],
            "%WeakMapPrototype%": ["WeakMap", "prototype"],
            "%WeakSetPrototype%": ["WeakSet", "prototype"]
        },
        Ql = bv,
        vd = ej,
        sj = Ql.call(Function.call, Array.prototype.concat),
        ij = Ql.call(Function.apply, Array.prototype.splice),
        nT = Ql.call(Function.call, String.prototype.replace),
        bd = Ql.call(Function.call, String.prototype.slice),
        oj = Ql.call(Function.call, RegExp.prototype.exec),
        aj = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
        cj = /\\(\\)?/g,
        uj = function(e) {
            var n = bd(e, 0, 1),
                r = bd(e, -1);
            if (n === "%" && r !== "%") throw new Dc("invalid intrinsic syntax, expected closing `%`");
            if (r === "%" && n !== "%") throw new Dc("invalid intrinsic syntax, expected opening `%`");
            var s = [];
            return nT(e, aj, function(i, a, c, l) {
                s[s.length] = c ? nT(l, cj, "$1") : a || i
            }), s
        },
        lj = function(e, n) {
            var r = e,
                s;
            if (vd(tT, r) && (s = tT[r], r = "%" + s[0] + "%"), vd(Ec, r)) {
                var i = Ec[r];
                if (i === rc && (i = rj(r)), typeof i > "u" && !n) throw new bc("intrinsic " + e + " exists, but is not available. Please file an issue!");
                return {
                    alias: s,
                    name: r,
                    value: i
                }
            }
            throw new Dc("intrinsic " + e + " does not exist!")
        },
        Ev = function(e, n) {
            if (typeof e != "string" || e.length === 0) throw new bc("intrinsic name must be a non-empty string");
            if (arguments.length > 1 && typeof n != "boolean") throw new bc('"allowMissing" argument must be a boolean');
            if (oj(/^%?[^%]*%?$/g, e) === null) throw new Dc("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
            var r = uj(e),
                s = r.length > 0 ? r[0] : "",
                i = lj("%" + s + "%", n),
                a = i.name,
                c = i.value,
                l = !1,
                h = i.alias;
            h && (s = h[0], ij(r, sj([0, 1], h)));
            for (var d = 1, p = !0; d < r.length; d += 1) {
                var g = r[d],
                    v = bd(g, 0, 1),
                    b = bd(g, -1);
                if ((v === '"' || v === "'" || v === "`" || b === '"' || b === "'" || b === "`") && v !== b) throw new Dc("property names with quotes must have matching quotes");
                if ((g === "constructor" || !p) && (l = !0), s += "." + g, a = "%" + s + "%", vd(Ec, a)) c = Ec[a];
                else if (c != null) {
                    if (!(g in c)) {
                        if (!n) throw new bc("base intrinsic for " + e + " exists, but the property is not available.");
                        return
                    }
                    if (ga && d + 1 >= r.length) {
                        var T = ga(c, g);
                        p = !!T, p && "get" in T && !("originalValue" in T.get) ? c = T.get : c = c[g]
                    } else p = vd(c, g), c = c[g];
                    p && !l && (Ec[a] = c)
                }
            }
            return c
        },
        F4 = {
            exports: {}
        };
    (function(t) {
        var e = bv,
            n = Ev,
            r = n("%Function.prototype.apply%"),
            s = n("%Function.prototype.call%"),
            i = n("%Reflect.apply%", !0) || e.call(s, r),
            a = n("%Object.getOwnPropertyDescriptor%", !0),
            c = n("%Object.defineProperty%", !0),
            l = n("%Math.max%");
        if (c) try {
            c({}, "a", {
                value: 1
            })
        } catch {
            c = null
        }
        t.exports = function(p) {
            var g = i(e, s, arguments);
            if (a && c) {
                var v = a(g, "length");
                v.configurable && c(g, "length", {
                    value: 1 + l(0, p.length - (arguments.length - 1))
                })
            }
            return g
        };
        var h = function() {
            return i(e, r, arguments)
        };
        c ? c(t.exports, "apply", {
            value: h
        }) : t.exports.apply = h
    })(F4);
    var hj = F4.exports,
        U4 = Ev,
        B4 = hj,
        fj = B4(U4("String.prototype.indexOf")),
        dj = function(e, n) {
            var r = U4(e, !!n);
            return typeof r == "function" && fj(e, ".prototype.") > -1 ? B4(r) : r
        };
    const pj = {},
        mj = Object.freeze(Object.defineProperty({
            __proto__: null,
            default: pj
        }, Symbol.toStringTag, {
            value: "Module"
        })),
        gj = YD(mj);
    var Sv = typeof Map == "function" && Map.prototype,
        u_ = Object.getOwnPropertyDescriptor && Sv ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
        Ed = Sv && u_ && typeof u_.get == "function" ? u_.get : null,
        _j = Sv && Map.prototype.forEach,
        Tv = typeof Set == "function" && Set.prototype,
        l_ = Object.getOwnPropertyDescriptor && Tv ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
        Sd = Tv && l_ && typeof l_.get == "function" ? l_.get : null,
        yj = Tv && Set.prototype.forEach,
        vj = typeof WeakMap == "function" && WeakMap.prototype,
        Xu = vj ? WeakMap.prototype.has : null,
        bj = typeof WeakSet == "function" && WeakSet.prototype,
        Qu = bj ? WeakSet.prototype.has : null,
        Ej = typeof WeakRef == "function" && WeakRef.prototype,
        rT = Ej ? WeakRef.prototype.deref : null,
        Sj = Boolean.prototype.valueOf,
        Tj = Object.prototype.toString,
        wj = Function.prototype.toString,
        Oj = String.prototype.match,
        wv = String.prototype.slice,
        ho = String.prototype.replace,
        Aj = String.prototype.toUpperCase,
        sT = String.prototype.toLowerCase,
        q4 = RegExp.prototype.test,
        iT = Array.prototype.concat,
        Ks = Array.prototype.join,
        Cj = Array.prototype.slice,
        oT = Math.floor,
        f1 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
        h_ = Object.getOwnPropertySymbols,
        d1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null,
        $c = typeof Symbol == "function" && typeof Symbol.iterator == "object",
        rr = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === $c || "symbol") ? Symbol.toStringTag : null,
        V4 = Object.prototype.propertyIsEnumerable,
        aT = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
            return t.__proto__
        } : null);

    function cT(t, e) {
        if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || q4.call(/e/, e)) return e;
        var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof t == "number") {
            var r = t < 0 ? -oT(-t) : oT(t);
            if (r !== t) {
                var s = String(r),
                    i = wv.call(e, s.length + 1);
                return ho.call(s, n, "$&_") + "." + ho.call(ho.call(i, /([0-9]{3})/g, "$&_"), /_$/, "")
            }
        }
        return ho.call(e, n, "$&_")
    }
    var p1 = gj,
        uT = p1.custom,
        lT = G4(uT) ? uT : null,
        Ij = function t(e, n, r, s) {
            var i = n || {};
            if (oo(i, "quoteStyle") && i.quoteStyle !== "single" && i.quoteStyle !== "double") throw new TypeError('option "quoteStyle" must be "single" or "double"');
            if (oo(i, "maxStringLength") && (typeof i.maxStringLength == "number" ? i.maxStringLength < 0 && i.maxStringLength !== 1 / 0 : i.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
            var a = oo(i, "customInspect") ? i.customInspect : !0;
            if (typeof a != "boolean" && a !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
            if (oo(i, "indent") && i.indent !== null && i.indent !== "	" && !(parseInt(i.indent, 10) === i.indent && i.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
            if (oo(i, "numericSeparator") && typeof i.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
            var c = i.numericSeparator;
            if (typeof e > "u") return "undefined";
            if (e === null) return "null";
            if (typeof e == "boolean") return e ? "true" : "false";
            if (typeof e == "string") return H4(e, i);
            if (typeof e == "number") {
                if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
                var l = String(e);
                return c ? cT(e, l) : l
            }
            if (typeof e == "bigint") {
                var h = String(e) + "n";
                return c ? cT(e, h) : h
            }
            var d = typeof i.depth > "u" ? 5 : i.depth;
            if (typeof r > "u" && (r = 0), r >= d && d > 0 && typeof e == "object") return m1(e) ? "[Array]" : "[Object]";
            var p = Hj(i, r);
            if (typeof s > "u") s = [];
            else if (W4(s, e) >= 0) return "[Circular]";

            function g(ge, G, le) {
                if (G && (s = Cj.call(s), s.push(G)), le) {
                    var fe = {
                        depth: i.depth
                    };
                    return oo(i, "quoteStyle") && (fe.quoteStyle = i.quoteStyle), t(ge, fe, r + 1, s)
                }
                return t(ge, i, r + 1, s)
            }
            if (typeof e == "function" && !hT(e)) {
                var v = Lj(e),
                    b = vf(e, g);
                return "[Function" + (v ? ": " + v : " (anonymous)") + "]" + (b.length > 0 ? " { " + Ks.call(b, ", ") + " }" : "")
            }
            if (G4(e)) {
                var T = $c ? ho.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : d1.call(e);
                return typeof e == "object" && !$c ? Uu(T) : T
            }
            if (jj(e)) {
                for (var m = "<" + sT.call(String(e.nodeName)), w = e.attributes || [], P = 0; P < w.length; P++) m += " " + w[P].name + "=" + j4(kj(w[P].value), "double", i);
                return m += ">", e.childNodes && e.childNodes.length && (m += "..."), m += "</" + sT.call(String(e.nodeName)) + ">", m
            }
            if (m1(e)) {
                if (e.length === 0) return "[]";
                var V = vf(e, g);
                return p && !Wj(V) ? "[" + g1(V, p) + "]" : "[ " + Ks.call(V, ", ") + " ]"
            }
            if (xj(e)) {
                var M = vf(e, g);
                return !("cause" in Error.prototype) && "cause" in e && !V4.call(e, "cause") ? "{ [" + String(e) + "] " + Ks.call(iT.call("[cause]: " + g(e.cause), M), ", ") + " }" : M.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + Ks.call(M, ", ") + " }"
            }
            if (typeof e == "object" && a) {
                if (lT && typeof e[lT] == "function" && p1) return p1(e, {
                    depth: d - r
                });
                if (a !== "symbol" && typeof e.inspect == "function") return e.inspect()
            }
            if (Fj(e)) {
                var I = [];
                return _j.call(e, function(ge, G) {
                    I.push(g(G, e, !0) + " => " + g(ge, e))
                }), fT("Map", Ed.call(e), I, p)
            }
            if (qj(e)) {
                var L = [];
                return yj.call(e, function(ge) {
                    L.push(g(ge, e))
                }), fT("Set", Sd.call(e), L, p)
            }
            if (Uj(e)) return f_("WeakMap");
            if (Vj(e)) return f_("WeakSet");
            if (Bj(e)) return f_("WeakRef");
            if (Rj(e)) return Uu(g(Number(e)));
            if (Dj(e)) return Uu(g(f1.call(e)));
            if (Mj(e)) return Uu(Sj.call(e));
            if (Pj(e)) return Uu(g(String(e)));
            if (!Nj(e) && !hT(e)) {
                var B = vf(e, g),
                    q = aT ? aT(e) === Object.prototype : e instanceof Object || e.constructor === Object,
                    se = e instanceof Object ? "" : "null prototype",
                    ce = !q && rr && Object(e) === e && rr in e ? wv.call(Mo(e), 8, -1) : se ? "Object" : "",
                    ue = q || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "",
                    ee = ue + (ce || se ? "[" + Ks.call(iT.call([], ce || [], se || []), ": ") + "] " : "");
                return B.length === 0 ? ee + "{}" : p ? ee + "{" + g1(B, p) + "}" : ee + "{ " + Ks.call(B, ", ") + " }"
            }
            return String(e)
        };

    function j4(t, e, n) {
        var r = (n.quoteStyle || e) === "double" ? '"' : "'";
        return r + t + r
    }

    function kj(t) {
        return ho.call(String(t), /"/g, "&quot;")
    }

    function m1(t) {
        return Mo(t) === "[object Array]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function Nj(t) {
        return Mo(t) === "[object Date]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function hT(t) {
        return Mo(t) === "[object RegExp]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function xj(t) {
        return Mo(t) === "[object Error]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function Pj(t) {
        return Mo(t) === "[object String]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function Rj(t) {
        return Mo(t) === "[object Number]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function Mj(t) {
        return Mo(t) === "[object Boolean]" && (!rr || !(typeof t == "object" && rr in t))
    }

    function G4(t) {
        if ($c) return t && typeof t == "object" && t instanceof Symbol;
        if (typeof t == "symbol") return !0;
        if (!t || typeof t != "object" || !d1) return !1;
        try {
            return d1.call(t), !0
        } catch {}
        return !1
    }

    function Dj(t) {
        if (!t || typeof t != "object" || !f1) return !1;
        try {
            return f1.call(t), !0
        } catch {}
        return !1
    }
    var $j = Object.prototype.hasOwnProperty || function(t) {
        return t in this
    };

    function oo(t, e) {
        return $j.call(t, e)
    }

    function Mo(t) {
        return Tj.call(t)
    }

    function Lj(t) {
        if (t.name) return t.name;
        var e = Oj.call(wj.call(t), /^function\s*([\w$]+)/);
        return e ? e[1] : null
    }

    function W4(t, e) {
        if (t.indexOf) return t.indexOf(e);
        for (var n = 0, r = t.length; n < r; n++)
            if (t[n] === e) return n;
        return -1
    }

    function Fj(t) {
        if (!Ed || !t || typeof t != "object") return !1;
        try {
            Ed.call(t);
            try {
                Sd.call(t)
            } catch {
                return !0
            }
            return t instanceof Map
        } catch {}
        return !1
    }

    function Uj(t) {
        if (!Xu || !t || typeof t != "object") return !1;
        try {
            Xu.call(t, Xu);
            try {
                Qu.call(t, Qu)
            } catch {
                return !0
            }
            return t instanceof WeakMap
        } catch {}
        return !1
    }

    function Bj(t) {
        if (!rT || !t || typeof t != "object") return !1;
        try {
            return rT.call(t), !0
        } catch {}
        return !1
    }

    function qj(t) {
        if (!Sd || !t || typeof t != "object") return !1;
        try {
            Sd.call(t);
            try {
                Ed.call(t)
            } catch {
                return !0
            }
            return t instanceof Set
        } catch {}
        return !1
    }

    function Vj(t) {
        if (!Qu || !t || typeof t != "object") return !1;
        try {
            Qu.call(t, Qu);
            try {
                Xu.call(t, Xu)
            } catch {
                return !0
            }
            return t instanceof WeakSet
        } catch {}
        return !1
    }

    function jj(t) {
        return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function"
    }

    function H4(t, e) {
        if (t.length > e.maxStringLength) {
            var n = t.length - e.maxStringLength,
                r = "... " + n + " more character" + (n > 1 ? "s" : "");
            return H4(wv.call(t, 0, e.maxStringLength), e) + r
        }
        var s = ho.call(ho.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Gj);
        return j4(s, "single", e)
    }

    function Gj(t) {
        var e = t.charCodeAt(0),
            n = {
                8: "b",
                9: "t",
                10: "n",
                12: "f",
                13: "r"
            } [e];
        return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + Aj.call(e.toString(16))
    }

    function Uu(t) {
        return "Object(" + t + ")"
    }

    function f_(t) {
        return t + " { ? }"
    }

    function fT(t, e, n, r) {
        var s = r ? g1(n, r) : Ks.call(n, ", ");
        return t + " (" + e + ") {" + s + "}"
    }

    function Wj(t) {
        for (var e = 0; e < t.length; e++)
            if (W4(t[e], `
`) >= 0) return !1;
        return !0
    }

    function Hj(t, e) {
        var n;
        if (t.indent === "	") n = "	";
        else if (typeof t.indent == "number" && t.indent > 0) n = Ks.call(Array(t.indent + 1), " ");
        else return null;
        return {
            base: n,
            prev: Ks.call(Array(e + 1), n)
        }
    }

    function g1(t, e) {
        if (t.length === 0) return "";
        var n = `
` + e.prev + e.base;
        return n + Ks.call(t, "," + n) + `
` + e.prev
    }

    function vf(t, e) {
        var n = m1(t),
            r = [];
        if (n) {
            r.length = t.length;
            for (var s = 0; s < t.length; s++) r[s] = oo(t, s) ? e(t[s], t) : ""
        }
        var i = typeof h_ == "function" ? h_(t) : [],
            a;
        if ($c) {
            a = {};
            for (var c = 0; c < i.length; c++) a["$" + i[c]] = i[c]
        }
        for (var l in t) oo(t, l) && (n && String(Number(l)) === l && l < t.length || $c && a["$" + l] instanceof Symbol || (q4.call(/[^\w$]/, l) ? r.push(e(l, t) + ": " + e(t[l], t)) : r.push(l + ": " + e(t[l], t))));
        if (typeof h_ == "function")
            for (var h = 0; h < i.length; h++) V4.call(t, i[h]) && r.push("[" + e(i[h]) + "]: " + e(t[i[h]], t));
        return r
    }
    var Ov = Ev,
        au = dj,
        Kj = Ij,
        Yj = Ov("%TypeError%"),
        bf = Ov("%WeakMap%", !0),
        Ef = Ov("%Map%", !0),
        zj = au("WeakMap.prototype.get", !0),
        Zj = au("WeakMap.prototype.set", !0),
        Xj = au("WeakMap.prototype.has", !0),
        Qj = au("Map.prototype.get", !0),
        Jj = au("Map.prototype.set", !0),
        eG = au("Map.prototype.has", !0),
        Av = function(t, e) {
            for (var n = t, r;
                (r = n.next) !== null; n = r)
                if (r.key === e) return n.next = r.next, r.next = t.next, t.next = r, r
        },
        tG = function(t, e) {
            var n = Av(t, e);
            return n && n.value
        },
        nG = function(t, e, n) {
            var r = Av(t, e);
            r ? r.value = n : t.next = {
                key: e,
                next: t.next,
                value: n
            }
        },
        rG = function(t, e) {
            return !!Av(t, e)
        },
        sG = function() {
            var e, n, r, s = {
                assert: function(i) {
                    if (!s.has(i)) throw new Yj("Side channel does not contain " + Kj(i))
                },
                get: function(i) {
                    if (bf && i && (typeof i == "object" || typeof i == "function")) {
                        if (e) return zj(e, i)
                    } else if (Ef) {
                        if (n) return Qj(n, i)
                    } else if (r) return tG(r, i)
                },
                has: function(i) {
                    if (bf && i && (typeof i == "object" || typeof i == "function")) {
                        if (e) return Xj(e, i)
                    } else if (Ef) {
                        if (n) return eG(n, i)
                    } else if (r) return rG(r, i);
                    return !1
                },
                set: function(i, a) {
                    bf && i && (typeof i == "object" || typeof i == "function") ? (e || (e = new bf), Zj(e, i, a)) : Ef ? (n || (n = new Ef), Jj(n, i, a)) : (r || (r = {
                        key: {},
                        next: null
                    }), nG(r, i, a))
                }
            };
            return s
        },
        iG = String.prototype.replace,
        oG = /%20/g,
        d_ = {
            RFC1738: "RFC1738",
            RFC3986: "RFC3986"
        },
        Cv = {
            default: d_.RFC3986,
            formatters: {
                RFC1738: function(t) {
                    return iG.call(t, oG, "+")
                },
                RFC3986: function(t) {
                    return String(t)
                }
            },
            RFC1738: d_.RFC1738,
            RFC3986: d_.RFC3986
        },
        aG = Cv,
        p_ = Object.prototype.hasOwnProperty,
        aa = Array.isArray,
        Vs = function() {
            for (var t = [], e = 0; e < 256; ++e) t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
            return t
        }(),
        cG = function(e) {
            for (; e.length > 1;) {
                var n = e.pop(),
                    r = n.obj[n.prop];
                if (aa(r)) {
                    for (var s = [], i = 0; i < r.length; ++i) typeof r[i] < "u" && s.push(r[i]);
                    n.obj[n.prop] = s
                }
            }
        },
        K4 = function(e, n) {
            for (var r = n && n.plainObjects ? Object.create(null) : {}, s = 0; s < e.length; ++s) typeof e[s] < "u" && (r[s] = e[s]);
            return r
        },
        uG = function t(e, n, r) {
            if (!n) return e;
            if (typeof n != "object") {
                if (aa(e)) e.push(n);
                else if (e && typeof e == "object")(r && (r.plainObjects || r.allowPrototypes) || !p_.call(Object.prototype, n)) && (e[n] = !0);
                else return [e, n];
                return e
            }
            if (!e || typeof e != "object") return [e].concat(n);
            var s = e;
            return aa(e) && !aa(n) && (s = K4(e, r)), aa(e) && aa(n) ? (n.forEach(function(i, a) {
                if (p_.call(e, a)) {
                    var c = e[a];
                    c && typeof c == "object" && i && typeof i == "object" ? e[a] = t(c, i, r) : e.push(i)
                } else e[a] = i
            }), e) : Object.keys(n).reduce(function(i, a) {
                var c = n[a];
                return p_.call(i, a) ? i[a] = t(i[a], c, r) : i[a] = c, i
            }, s)
        },
        lG = function(e, n) {
            return Object.keys(n).reduce(function(r, s) {
                return r[s] = n[s], r
            }, e)
        },
        hG = function(t, e, n) {
            var r = t.replace(/\+/g, " ");
            if (n === "iso-8859-1") return r.replace(/%[0-9a-f]{2}/gi, unescape);
            try {
                return decodeURIComponent(r)
            } catch {
                return r
            }
        },
        fG = function(e, n, r, s, i) {
            if (e.length === 0) return e;
            var a = e;
            if (typeof e == "symbol" ? a = Symbol.prototype.toString.call(e) : typeof e != "string" && (a = String(e)), r === "iso-8859-1") return escape(a).replace(/%u[0-9a-f]{4}/gi, function(d) {
                return "%26%23" + parseInt(d.slice(2), 16) + "%3B"
            });
            for (var c = "", l = 0; l < a.length; ++l) {
                var h = a.charCodeAt(l);
                if (h === 45 || h === 46 || h === 95 || h === 126 || h >= 48 && h <= 57 || h >= 65 && h <= 90 || h >= 97 && h <= 122 || i === aG.RFC1738 && (h === 40 || h === 41)) {
                    c += a.charAt(l);
                    continue
                }
                if (h < 128) {
                    c = c + Vs[h];
                    continue
                }
                if (h < 2048) {
                    c = c + (Vs[192 | h >> 6] + Vs[128 | h & 63]);
                    continue
                }
                if (h < 55296 || h >= 57344) {
                    c = c + (Vs[224 | h >> 12] + Vs[128 | h >> 6 & 63] + Vs[128 | h & 63]);
                    continue
                }
                l += 1, h = 65536 + ((h & 1023) << 10 | a.charCodeAt(l) & 1023), c += Vs[240 | h >> 18] + Vs[128 | h >> 12 & 63] + Vs[128 | h >> 6 & 63] + Vs[128 | h & 63]
            }
            return c
        },
        dG = function(e) {
            for (var n = [{
                    obj: {
                        o: e
                    },
                    prop: "o"
                }], r = [], s = 0; s < n.length; ++s)
                for (var i = n[s], a = i.obj[i.prop], c = Object.keys(a), l = 0; l < c.length; ++l) {
                    var h = c[l],
                        d = a[h];
                    typeof d == "object" && d !== null && r.indexOf(d) === -1 && (n.push({
                        obj: a,
                        prop: h
                    }), r.push(d))
                }
            return cG(n), e
        },
        pG = function(e) {
            return Object.prototype.toString.call(e) === "[object RegExp]"
        },
        mG = function(e) {
            return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
        },
        gG = function(e, n) {
            return [].concat(e, n)
        },
        _G = function(e, n) {
            if (aa(e)) {
                for (var r = [], s = 0; s < e.length; s += 1) r.push(n(e[s]));
                return r
            }
            return n(e)
        },
        Y4 = {
            arrayToObject: K4,
            assign: lG,
            combine: gG,
            compact: dG,
            decode: hG,
            encode: fG,
            isBuffer: mG,
            isRegExp: pG,
            maybeMap: _G,
            merge: uG
        },
        z4 = sG,
        Kf = Y4,
        Ju = Cv,
        yG = Object.prototype.hasOwnProperty,
        dT = {
            brackets: function(e) {
                return e + "[]"
            },
            comma: "comma",
            indices: function(e, n) {
                return e + "[" + n + "]"
            },
            repeat: function(e) {
                return e
            }
        },
        wi = Array.isArray,
        vG = Array.prototype.push,
        Z4 = function(t, e) {
            vG.apply(t, wi(e) ? e : [e])
        },
        bG = Date.prototype.toISOString,
        pT = Ju.default,
        Xn = {
            addQueryPrefix: !1,
            allowDots: !1,
            charset: "utf-8",
            charsetSentinel: !1,
            delimiter: "&",
            encode: !0,
            encoder: Kf.encode,
            encodeValuesOnly: !1,
            format: pT,
            formatter: Ju.formatters[pT],
            indices: !1,
            serializeDate: function(e) {
                return bG.call(e)
            },
            skipNulls: !1,
            strictNullHandling: !1
        },
        EG = function(e) {
            return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint"
        },
        m_ = {},
        SG = function t(e, n, r, s, i, a, c, l, h, d, p, g, v, b, T, m) {
            for (var w = e, P = m, V = 0, M = !1;
                (P = P.get(m_)) !== void 0 && !M;) {
                var I = P.get(e);
                if (V += 1, typeof I < "u") {
                    if (I === V) throw new RangeError("Cyclic object value");
                    M = !0
                }
                typeof P.get(m_) > "u" && (V = 0)
            }
            if (typeof l == "function" ? w = l(n, w) : w instanceof Date ? w = p(w) : r === "comma" && wi(w) && (w = Kf.maybeMap(w, function(fe) {
                    return fe instanceof Date ? p(fe) : fe
                })), w === null) {
                if (i) return c && !b ? c(n, Xn.encoder, T, "key", g) : n;
                w = ""
            }
            if (EG(w) || Kf.isBuffer(w)) {
                if (c) {
                    var L = b ? n : c(n, Xn.encoder, T, "key", g);
                    return [v(L) + "=" + v(c(w, Xn.encoder, T, "value", g))]
                }
                return [v(n) + "=" + v(String(w))]
            }
            var B = [];
            if (typeof w > "u") return B;
            var q;
            if (r === "comma" && wi(w)) b && c && (w = Kf.maybeMap(w, c)), q = [{
                value: w.length > 0 ? w.join(",") || null : void 0
            }];
            else if (wi(l)) q = l;
            else {
                var se = Object.keys(w);
                q = h ? se.sort(h) : se
            }
            for (var ce = s && wi(w) && w.length === 1 ? n + "[]" : n, ue = 0; ue < q.length; ++ue) {
                var ee = q[ue],
                    ge = typeof ee == "object" && typeof ee.value < "u" ? ee.value : w[ee];
                if (!(a && ge === null)) {
                    var G = wi(w) ? typeof r == "function" ? r(ce, ee) : ce : ce + (d ? "." + ee : "[" + ee + "]");
                    m.set(e, V);
                    var le = z4();
                    le.set(m_, m), Z4(B, t(ge, G, r, s, i, a, r === "comma" && b && wi(w) ? null : c, l, h, d, p, g, v, b, T, le))
                }
            }
            return B
        },
        TG = function(e) {
            if (!e) return Xn;
            if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function") throw new TypeError("Encoder has to be a function.");
            var n = e.charset || Xn.charset;
            if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
            var r = Ju.default;
            if (typeof e.format < "u") {
                if (!yG.call(Ju.formatters, e.format)) throw new TypeError("Unknown format option provided.");
                r = e.format
            }
            var s = Ju.formatters[r],
                i = Xn.filter;
            return (typeof e.filter == "function" || wi(e.filter)) && (i = e.filter), {
                addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : Xn.addQueryPrefix,
                allowDots: typeof e.allowDots > "u" ? Xn.allowDots : !!e.allowDots,
                charset: n,
                charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Xn.charsetSentinel,
                delimiter: typeof e.delimiter > "u" ? Xn.delimiter : e.delimiter,
                encode: typeof e.encode == "boolean" ? e.encode : Xn.encode,
                encoder: typeof e.encoder == "function" ? e.encoder : Xn.encoder,
                encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : Xn.encodeValuesOnly,
                filter: i,
                format: r,
                formatter: s,
                serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : Xn.serializeDate,
                skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : Xn.skipNulls,
                sort: typeof e.sort == "function" ? e.sort : null,
                strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Xn.strictNullHandling
            }
        },
        wG = function(t, e) {
            var n = t,
                r = TG(e),
                s, i;
            typeof r.filter == "function" ? (i = r.filter, n = i("", n)) : wi(r.filter) && (i = r.filter, s = i);
            var a = [];
            if (typeof n != "object" || n === null) return "";
            var c;
            e && e.arrayFormat in dT ? c = e.arrayFormat : e && "indices" in e ? c = e.indices ? "indices" : "repeat" : c = "indices";
            var l = dT[c];
            if (e && "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
            var h = l === "comma" && e && e.commaRoundTrip;
            s || (s = Object.keys(n)), r.sort && s.sort(r.sort);
            for (var d = z4(), p = 0; p < s.length; ++p) {
                var g = s[p];
                r.skipNulls && n[g] === null || Z4(a, SG(n[g], g, l, h, r.strictNullHandling, r.skipNulls, r.encode ? r.encoder : null, r.filter, r.sort, r.allowDots, r.serializeDate, r.format, r.formatter, r.encodeValuesOnly, r.charset, d))
            }
            var v = a.join(r.delimiter),
                b = r.addQueryPrefix === !0 ? "?" : "";
            return r.charsetSentinel && (r.charset === "iso-8859-1" ? b += "utf8=%26%2310003%3B&" : b += "utf8=%E2%9C%93&"), v.length > 0 ? b + v : ""
        },
        Lc = Y4,
        _1 = Object.prototype.hasOwnProperty,
        OG = Array.isArray,
        Dn = {
            allowDots: !1,
            allowPrototypes: !1,
            allowSparse: !1,
            arrayLimit: 20,
            charset: "utf-8",
            charsetSentinel: !1,
            comma: !1,
            decoder: Lc.decode,
            delimiter: "&",
            depth: 5,
            ignoreQueryPrefix: !1,
            interpretNumericEntities: !1,
            parameterLimit: 1e3,
            parseArrays: !0,
            plainObjects: !1,
            strictNullHandling: !1
        },
        AG = function(t) {
            return t.replace(/&#(\d+);/g, function(e, n) {
                return String.fromCharCode(parseInt(n, 10))
            })
        },
        X4 = function(t, e) {
            return t && typeof t == "string" && e.comma && t.indexOf(",") > -1 ? t.split(",") : t
        },
        CG = "utf8=%26%2310003%3B",
        IG = "utf8=%E2%9C%93",
        kG = function(e, n) {
            var r = {
                    __proto__: null
                },
                s = n.ignoreQueryPrefix ? e.replace(/^\?/, "") : e,
                i = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit,
                a = s.split(n.delimiter, i),
                c = -1,
                l, h = n.charset;
            if (n.charsetSentinel)
                for (l = 0; l < a.length; ++l) a[l].indexOf("utf8=") === 0 && (a[l] === IG ? h = "utf-8" : a[l] === CG && (h = "iso-8859-1"), c = l, l = a.length);
            for (l = 0; l < a.length; ++l)
                if (l !== c) {
                    var d = a[l],
                        p = d.indexOf("]="),
                        g = p === -1 ? d.indexOf("=") : p + 1,
                        v, b;
                    g === -1 ? (v = n.decoder(d, Dn.decoder, h, "key"), b = n.strictNullHandling ? null : "") : (v = n.decoder(d.slice(0, g), Dn.decoder, h, "key"), b = Lc.maybeMap(X4(d.slice(g + 1), n), function(T) {
                        return n.decoder(T, Dn.decoder, h, "value")
                    })), b && n.interpretNumericEntities && h === "iso-8859-1" && (b = AG(b)), d.indexOf("[]=") > -1 && (b = OG(b) ? [b] : b), _1.call(r, v) ? r[v] = Lc.combine(r[v], b) : r[v] = b
                } return r
        },
        NG = function(t, e, n, r) {
            for (var s = r ? e : X4(e, n), i = t.length - 1; i >= 0; --i) {
                var a, c = t[i];
                if (c === "[]" && n.parseArrays) a = [].concat(s);
                else {
                    a = n.plainObjects ? Object.create(null) : {};
                    var l = c.charAt(0) === "[" && c.charAt(c.length - 1) === "]" ? c.slice(1, -1) : c,
                        h = parseInt(l, 10);
                    !n.parseArrays && l === "" ? a = {
                        0: s
                    } : !isNaN(h) && c !== l && String(h) === l && h >= 0 && n.parseArrays && h <= n.arrayLimit ? (a = [], a[h] = s) : l !== "__proto__" && (a[l] = s)
                }
                s = a
            }
            return s
        },
        xG = function(e, n, r, s) {
            if (e) {
                var i = r.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
                    a = /(\[[^[\]]*])/,
                    c = /(\[[^[\]]*])/g,
                    l = r.depth > 0 && a.exec(i),
                    h = l ? i.slice(0, l.index) : i,
                    d = [];
                if (h) {
                    if (!r.plainObjects && _1.call(Object.prototype, h) && !r.allowPrototypes) return;
                    d.push(h)
                }
                for (var p = 0; r.depth > 0 && (l = c.exec(i)) !== null && p < r.depth;) {
                    if (p += 1, !r.plainObjects && _1.call(Object.prototype, l[1].slice(1, -1)) && !r.allowPrototypes) return;
                    d.push(l[1])
                }
                return l && d.push("[" + i.slice(l.index) + "]"), NG(d, n, r, s)
            }
        },
        PG = function(e) {
            if (!e) return Dn;
            if (e.decoder !== null && e.decoder !== void 0 && typeof e.decoder != "function") throw new TypeError("Decoder has to be a function.");
            if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
            var n = typeof e.charset > "u" ? Dn.charset : e.charset;
            return {
                allowDots: typeof e.allowDots > "u" ? Dn.allowDots : !!e.allowDots,
                allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : Dn.allowPrototypes,
                allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : Dn.allowSparse,
                arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : Dn.arrayLimit,
                charset: n,
                charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Dn.charsetSentinel,
                comma: typeof e.comma == "boolean" ? e.comma : Dn.comma,
                decoder: typeof e.decoder == "function" ? e.decoder : Dn.decoder,
                delimiter: typeof e.delimiter == "string" || Lc.isRegExp(e.delimiter) ? e.delimiter : Dn.delimiter,
                depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : Dn.depth,
                ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
                interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : Dn.interpretNumericEntities,
                parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : Dn.parameterLimit,
                parseArrays: e.parseArrays !== !1,
                plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : Dn.plainObjects,
                strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Dn.strictNullHandling
            }
        },
        RG = function(t, e) {
            var n = PG(e);
            if (t === "" || t === null || typeof t > "u") return n.plainObjects ? Object.create(null) : {};
            for (var r = typeof t == "string" ? kG(t, n) : t, s = n.plainObjects ? Object.create(null) : {}, i = Object.keys(r), a = 0; a < i.length; ++a) {
                var c = i[a],
                    l = xG(c, r[c], n, typeof t == "string");
                s = Lc.merge(s, l, n)
            }
            return n.allowSparse === !0 ? s : Lc.compact(s)
        },
        MG = wG,
        DG = RG,
        $G = Cv,
        Q4 = {
            formats: $G,
            parse: DG,
            stringify: MG
        };
    let LG = class {
            constructor(e) {
                this.code = e.code, this.token = e.token, this.host = e.host
            }
        },
        FG = class {
            constructor(e) {
                this.appId = e.appId, this.appTag = e.appTag, this.audienceEnabled = e.audienceEnabled, this.code = e.code, this.host = e.host, this.audienceHost = e.audienceHost, this.locked = e.locked, this.full = e.full, this.maxPlayers = e.maxPlayers, this.minPlayers = e.minPlayers, this.moderationEnabled = e.moderationEnabled, this.passwordRequired = e.passwordRequired, this.twitchLocked = e.twitchLocked, this.locale = e.locale, this.keepalive = e.keepalive, this.controllerBranch = e.controllerBranch
            }
        },
        UG = class {
            constructor(e) {
                this.connections = e.connections
            }
        },
        BG = class {
            constructor(e) {
                this.cause = e.cause
            }
            whenReceived(e) {
                e.disconnect()
            }
        },
        qG = class {};
    var Xp = {
        CreateRoomReply: LG,
        GetRoomReply: FG,
        GetAudienceReply: UG,
        RoomExit: BG,
        RoomLock: qG
    };
    const mT = GV,
        VG = Q4,
        {
            CreateRoomReply: jG,
            GetRoomReply: GG
        } = Xp;
    let WG = class {
        constructor(e) {
            if (!e.host) throw new Error("unable to create ecast APIClient: no host provided");
            if (this.host = e.host, !e.scheme) throw new Error("unable to create ecast APIClient: no scheme provided");
            this.scheme = e.scheme
        }
        url(e, n) {
            if (n) {
                let r = VG.stringify(n);
                return `${this.scheme}://${this.host}/api/v2${e}?${r}`
            }
            return `${this.scheme}://${this.host}/api/v2${e}`
        }
        async createRoom(e) {
            let n = {
                    appTag: "test",
                    userId: "fart",
                    ...e
                },
                r = this.url("/rooms", n),
                i = await mT(r, {
                    method: "POST"
                });
            const {
                body: a,
                error: c,
                ok: l
            } = await i.json();
            if (!l) throw new Error(`failed to create room: ${c}`);
            return new jG({
                code: a.code,
                token: a.token,
                host: a.host
            })
        }
        async getRoom(e) {
            let n = this.url(`/rooms/${e.code}`),
                s = await (await mT(n)).json();
            if (!s.ok) throw new Error(`unable to get room with options ${JSON.stringify(e)}: ${s.error}`);
            let i = s.body;
            return new GG({
                appId: i.appId,
                appTag: i.appTag,
                audienceEnabled: i.audienceEnabled,
                code: i.code,
                host: i.host,
                audienceHost: i.audienceHost,
                locked: i.locked,
                full: i.full,
                maxPlayers: i.maxPlayers,
                minPlayers: i.minPlayers,
                moderationEnabled: i.moderationEnabled,
                passwordRequired: i.passwordRequired,
                twitchLocked: i.twitchLocked,
                locale: i.locale,
                keepalive: i.keepalive,
                controllerBranch: i.controllerBranch
            })
        }
    };
    var HG = {
            APIClient: WG
        },
        sc = null;
    typeof WebSocket < "u" ? sc = WebSocket : typeof MozWebSocket < "u" ? sc = MozWebSocket : typeof hn < "u" ? sc = hn.WebSocket || hn.MozWebSocket : typeof window < "u" ? sc = window.WebSocket || window.MozWebSocket : typeof self < "u" && (sc = self.WebSocket || self.MozWebSocket);
    var KG = sc,
        Iv = {
            exports: {}
        },
        Sc = typeof Reflect == "object" ? Reflect : null,
        gT = Sc && typeof Sc.apply == "function" ? Sc.apply : function(e, n, r) {
            return Function.prototype.apply.call(e, n, r)
        },
        Yf;
    Sc && typeof Sc.ownKeys == "function" ? Yf = Sc.ownKeys : Object.getOwnPropertySymbols ? Yf = function(e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
    } : Yf = function(e) {
        return Object.getOwnPropertyNames(e)
    };

    function YG(t) {
        console && console.warn && console.warn(t)
    }
    var J4 = Number.isNaN || function(e) {
        return e !== e
    };

    function Ft() {
        Ft.init.call(this)
    }
    Iv.exports = Ft;
    Iv.exports.once = QG;
    Ft.EventEmitter = Ft;
    Ft.prototype._events = void 0;
    Ft.prototype._eventsCount = 0;
    Ft.prototype._maxListeners = void 0;
    var _T = 10;

    function Qp(t) {
        if (typeof t != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
    }
    Object.defineProperty(Ft, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return _T
        },
        set: function(t) {
            if (typeof t != "number" || t < 0 || J4(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
            _T = t
        }
    });
    Ft.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
    };
    Ft.prototype.setMaxListeners = function(e) {
        if (typeof e != "number" || e < 0 || J4(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
        return this._maxListeners = e, this
    };

    function eO(t) {
        return t._maxListeners === void 0 ? Ft.defaultMaxListeners : t._maxListeners
    }
    Ft.prototype.getMaxListeners = function() {
        return eO(this)
    };
    Ft.prototype.emit = function(e) {
        for (var n = [], r = 1; r < arguments.length; r++) n.push(arguments[r]);
        var s = e === "error",
            i = this._events;
        if (i !== void 0) s = s && i.error === void 0;
        else if (!s) return !1;
        if (s) {
            var a;
            if (n.length > 0 && (a = n[0]), a instanceof Error) throw a;
            var c = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
            throw c.context = a, c
        }
        var l = i[e];
        if (l === void 0) return !1;
        if (typeof l == "function") gT(l, this, n);
        else
            for (var h = l.length, d = iO(l, h), r = 0; r < h; ++r) gT(d[r], this, n);
        return !0
    };

    function tO(t, e, n, r) {
        var s, i, a;
        if (Qp(n), i = t._events, i === void 0 ? (i = t._events = Object.create(null), t._eventsCount = 0) : (i.newListener !== void 0 && (t.emit("newListener", e, n.listener ? n.listener : n), i = t._events), a = i[e]), a === void 0) a = i[e] = n, ++t._eventsCount;
        else if (typeof a == "function" ? a = i[e] = r ? [n, a] : [a, n] : r ? a.unshift(n) : a.push(n), s = eO(t), s > 0 && a.length > s && !a.warned) {
            a.warned = !0;
            var c = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            c.name = "MaxListenersExceededWarning", c.emitter = t, c.type = e, c.count = a.length, YG(c)
        }
        return t
    }
    Ft.prototype.addListener = function(e, n) {
        return tO(this, e, n, !1)
    };
    Ft.prototype.on = Ft.prototype.addListener;
    Ft.prototype.prependListener = function(e, n) {
        return tO(this, e, n, !0)
    };

    function zG() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }

    function nO(t, e, n) {
        var r = {
                fired: !1,
                wrapFn: void 0,
                target: t,
                type: e,
                listener: n
            },
            s = zG.bind(r);
        return s.listener = n, r.wrapFn = s, s
    }
    Ft.prototype.once = function(e, n) {
        return Qp(n), this.on(e, nO(this, e, n)), this
    };
    Ft.prototype.prependOnceListener = function(e, n) {
        return Qp(n), this.prependListener(e, nO(this, e, n)), this
    };
    Ft.prototype.removeListener = function(e, n) {
        var r, s, i, a, c;
        if (Qp(n), s = this._events, s === void 0) return this;
        if (r = s[e], r === void 0) return this;
        if (r === n || r.listener === n) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete s[e], s.removeListener && this.emit("removeListener", e, r.listener || n));
        else if (typeof r != "function") {
            for (i = -1, a = r.length - 1; a >= 0; a--)
                if (r[a] === n || r[a].listener === n) {
                    c = r[a].listener, i = a;
                    break
                } if (i < 0) return this;
            i === 0 ? r.shift() : ZG(r, i), r.length === 1 && (s[e] = r[0]), s.removeListener !== void 0 && this.emit("removeListener", e, c || n)
        }
        return this
    };
    Ft.prototype.off = Ft.prototype.removeListener;
    Ft.prototype.removeAllListeners = function(e) {
        var n, r, s;
        if (r = this._events, r === void 0) return this;
        if (r.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r[e]), this;
        if (arguments.length === 0) {
            var i = Object.keys(r),
                a;
            for (s = 0; s < i.length; ++s) a = i[s], a !== "removeListener" && this.removeAllListeners(a);
            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
        }
        if (n = r[e], typeof n == "function") this.removeListener(e, n);
        else if (n !== void 0)
            for (s = n.length - 1; s >= 0; s--) this.removeListener(e, n[s]);
        return this
    };

    function rO(t, e, n) {
        var r = t._events;
        if (r === void 0) return [];
        var s = r[e];
        return s === void 0 ? [] : typeof s == "function" ? n ? [s.listener || s] : [s] : n ? XG(s) : iO(s, s.length)
    }
    Ft.prototype.listeners = function(e) {
        return rO(this, e, !0)
    };
    Ft.prototype.rawListeners = function(e) {
        return rO(this, e, !1)
    };
    Ft.listenerCount = function(t, e) {
        return typeof t.listenerCount == "function" ? t.listenerCount(e) : sO.call(t, e)
    };
    Ft.prototype.listenerCount = sO;

    function sO(t) {
        var e = this._events;
        if (e !== void 0) {
            var n = e[t];
            if (typeof n == "function") return 1;
            if (n !== void 0) return n.length
        }
        return 0
    }
    Ft.prototype.eventNames = function() {
        return this._eventsCount > 0 ? Yf(this._events) : []
    };

    function iO(t, e) {
        for (var n = new Array(e), r = 0; r < e; ++r) n[r] = t[r];
        return n
    }

    function ZG(t, e) {
        for (; e + 1 < t.length; e++) t[e] = t[e + 1];
        t.pop()
    }

    function XG(t) {
        for (var e = new Array(t.length), n = 0; n < e.length; ++n) e[n] = t[n].listener || t[n];
        return e
    }

    function QG(t, e) {
        return new Promise(function(n, r) {
            function s(a) {
                t.removeListener(e, i), r(a)
            }

            function i() {
                typeof t.removeListener == "function" && t.removeListener("error", s), n([].slice.call(arguments))
            }
            oO(t, e, i, {
                once: !0
            }), e !== "error" && JG(t, s, {
                once: !0
            })
        })
    }

    function JG(t, e, n) {
        typeof t.on == "function" && oO(t, "error", e, n)
    }

    function oO(t, e, n, r) {
        if (typeof t.on == "function") r.once ? t.once(e, n) : t.on(e, n);
        else if (typeof t.addEventListener == "function") t.addEventListener(e, function s(i) {
            r.once && t.removeEventListener(e, s), n(i)
        });
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t)
    }
    var eW = Iv.exports;
    let tW = class {
            constructor(e) {
                e && (this.error = e.error, this.to = e.to, this.opcode = e.opcode)
            }
            toString() {
                return `ObservedError{
	to:${this.to}
	error:${this.error}
	opcode:${this.opcode}
}`
            }
        },
        Jp = class extends Error {
            constructor(e) {
                super(e), e && (this.code = e.code, this.message = e.message)
            }
        };
    class Jl extends Jp {
        constructor(e) {
            super(e), this.code = 1e3, this.message = e && e.message ? e.message : "ecast server error"
        }
    }
    class aO extends Jl {
        constructor(e) {
            super(e), this.code = 1001, this.message = e && e.message ? e.message : "create room failed"
        }
    }
    class cO extends Jl {
        constructor(e) {
            super(e), this.code = 1002, this.message = e && e.message ? e.message : "unable to connect to room"
        }
    }
    class uO extends Jl {
        constructor(e) {
            super(e), this.code = 1003, this.message = e && e.message ? e.message : "server is shutting down"
        }
    }
    class Mt extends Jp {
        constructor(e) {
            super(e), this.code = 2e3, this.message = e && e.message ? e.message : "ecast client error"
        }
    }
    class lO extends Mt {
        constructor(e) {
            super(e), this.code = 2001, this.message = e && e.message ? e.message : "parse error in ecast protocol"
        }
    }
    class hO extends Mt {
        constructor(e) {
            super(e), this.code = 2002, this.message = e && e.message ? e.message : "missing opcode"
        }
    }
    class fO extends Mt {
        constructor(e) {
            super(e), this.code = 2003, this.message = e && e.message ? e.message : "invalid opcode"
        }
    }
    class dO extends Mt {
        constructor(e) {
            super(e), this.code = 2004, this.message = e && e.message ? e.message : "invalid arguments"
        }
    }
    class pO extends Mt {
        constructor(e) {
            super(e), this.code = 2005, this.message = e && e.message ? e.message : "entity not found"
        }
    }
    class mO extends Mt {
        constructor(e) {
            super(e), this.code = 2006, this.message = e && e.message ? e.message : "an entity already exists with that key"
        }
    }
    class gO extends Mt {
        constructor(e) {
            super(e), this.code = 2007, this.message = e && e.message ? e.message : "the entity is not of the expected type"
        }
    }
    class _O extends Mt {
        constructor(e) {
            super(e), this.code = 2008, this.message = e && e.message ? e.message : "no such client"
        }
    }
    class yO extends Mt {
        constructor(e) {
            super(e), this.code = 2009, this.message = e && e.message ? e.message : "room is locked"
        }
    }
    class vO extends Mt {
        constructor(e) {
            super(e), this.code = 2010, this.message = e && e.message ? e.message : "room is full"
        }
    }
    class bO extends Mt {
        constructor(e) {
            super(e), this.code = 2011, this.message = e && e.message ? e.message : "no such license"
        }
    }
    class EO extends Mt {
        constructor(e) {
            super(e), this.code = 2012, this.message = e && e.message ? e.message : "invalid license"
        }
    }
    class SO extends Mt {
        constructor(e) {
            super(e), this.code = 2013, this.message = e && e.message ? e.message : "room not found"
        }
    }
    class TO extends Mt {
        constructor(e) {
            super(e), this.code = 2014, this.message = e && e.message ? e.message : "requested role does not exist"
        }
    }
    class wO extends Mt {
        constructor(e) {
            super(e), this.code = 2015, this.message = e && e.message ? e.message : "twitch login required"
        }
    }
    class OO extends Mt {
        constructor(e) {
            super(e), this.code = 2016, this.message = e && e.message ? e.message : "no such option"
        }
    }
    class AO extends Mt {
        constructor(e) {
            super(e), this.code = 2017, this.message = e && e.message ? e.message : "password required"
        }
    }
    class CO extends Mt {
        constructor(e) {
            super(e), this.code = 2018, this.message = e && e.message ? e.message : "invalid room password"
        }
    }
    class IO extends Mt {
        constructor(e) {
            super(e), this.code = 2019, this.message = e && e.message ? e.message : "missing name"
        }
    }
    class kO extends Mt {
        constructor(e) {
            super(e), this.code = 2021, this.message = e && e.message ? e.message : "text did not pass text filters"
        }
    }
    class NO extends Mt {
        constructor(e) {
            super(e), this.code = 2022, this.message = e && e.message ? e.message : "no such filter"
        }
    }
    class xO extends Mt {
        constructor(e) {
            super(e), this.code = 2023, this.message = e && e.message ? e.message : "permission denied"
        }
    }
    class PO extends Mt {
        constructor(e) {
            super(e), this.code = 2024, this.message = e && e.message ? e.message : "not connected to a room"
        }
    }
    class RO extends Mt {
        constructor(e) {
            super(e), this.code = 2025, this.message = e && e.message ? e.message : "illegal operation"
        }
    }
    class MO extends Mt {
        constructor(e) {
            super(e), this.code = 2026, this.message = e && e.message ? e.message : "invalid ACL change"
        }
    }
    class DO extends Mt {
        constructor(e) {
            super(e), this.code = 2027, this.message = e && e.message ? e.message : "room has already ended"
        }
    }
    class $O extends Mt {
        constructor(e) {
            super(e), this.code = 2028, this.message = e && e.message ? e.message : "the entity is locked"
        }
    }
    class LO extends Mt {
        constructor(e) {
            super(e), this.code = 2420, this.message = e && e.message ? e.message : "rate limit exceeded"
        }
    }

    function nW({
        code: t,
        message: e
    }) {
        const n = rW[t];
        return n ? new n({
            message: e
        }) : new Jp({
            message: e
        })
    }
    var el = {
        createError: nW,
        CallError: Jp,
        EcastServerError: Jl,
        EcastCreateRoomFailed: aO,
        EcastDialRoomFailed: cO,
        EcastServerIsShuttingDown: uO,
        EcastClientError: Mt,
        EcastParseError: lO,
        EcastRequestIsMissingOpcode: hO,
        EcastRequestHasInvalidOpcode: fO,
        EcastRequestHasInvalidArguments: dO,
        EcastEntityNotFound: pO,
        EcastEntityAlreadyExists: mO,
        EcastEntityTypeError: gO,
        EcastNoSuchClient: _O,
        EcastRoomIsLocked: yO,
        EcastRoomIsFull: vO,
        EcastLicenseNotFound: bO,
        EcastLicenseCheckFailed: EO,
        EcastRoomNotFound: SO,
        EcastInvalidRole: TO,
        EcastTwitchLoginRequired: wO,
        EcastInvalidOption: OO,
        EcastPasswordRequired: AO,
        EcastInvalidPassword: CO,
        EcastNameRequired: IO,
        EcastFilterError: kO,
        EcastNoSuchFilter: NO,
        EcastPermissionDenied: xO,
        EcastNotConnected: PO,
        EcastIllegalOperation: RO,
        EcastACLChangeDenied: MO,
        EcastRoomHasEnded: DO,
        EcastEntityLocked: $O,
        EcastRateLimitExceeded: LO,
        ObservedError: tW
    };
    const rW = {
        1e3: Jl,
        1001: aO,
        1002: cO,
        1003: uO,
        2e3: Mt,
        2001: lO,
        2002: hO,
        2003: fO,
        2004: dO,
        2005: pO,
        2006: mO,
        2007: gO,
        2008: _O,
        2009: yO,
        2010: vO,
        2011: bO,
        2012: EO,
        2013: SO,
        2014: TO,
        2015: wO,
        2016: OO,
        2017: AO,
        2018: CO,
        2019: IO,
        2021: kO,
        2022: NO,
        2023: xO,
        2024: PO,
        2025: RO,
        2026: MO,
        2027: DO,
        2028: $O,
        2420: LO
    };
    let sW = class {
            constructor(e) {
                this.id = e.id, this.deviceId = e.deviceId, this.name = e.name, this.secret = e.secret, this.reconnect = e.reconnect, this.entities = e.entities, this.here = e.here, this.profile = e.profile, this.replayEnd = e.replayEnd
            }
        },
        iW = class {
            constructor(e) {
                this.id = e.id, this.userId = e.userId, this.name = e.name, this.role = e.role, this.reconnect = e.reconnect
            }
        },
        oW = class {
            constructor(e) {
                this.id = e.id, this.role = e.role
            }
        },
        aW = class {
            constructor(e) {
                this.to = e.to, this.from = e.from, this.body = e.body, this.userId = e.userId
            }
        },
        cW = class {
            constructor(e) {
                this.id = e.id, this.banned = e.banned, this.reason = e.reason
            }
        };
    var kv = {
        ClientConnected: iW,
        ClientDisconnected: oW,
        ClientKicked: cW,
        ClientSend: aW,
        ClientWelcome: sW
    };
    let uW = class {
        constructor(e) {
            this.choices = e.choices, this.key = e.key, this.meta = e.meta || {}
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `CountGroup{
	choices: ${this.choices}
	meta:${JSON.stringify(this.meta)}
}`
        }
    };
    var Nv = {
        CountGroup: uW
    };
    let lW = class {
            constructor(e) {
                this.key = e.key, this.colors = e.colors, this.lines = e.lines, this.live = e.live, this.maxLayer = e.maxLayer, this.maxPoints = e.maxPoints, this.size = e.size, this.weights = e.weights, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
            }
            whenReceived(e) {
                e.entities[this.key] = this
            }
            toString() {
                return `Doodle{
	key:${this.key}
	colors:${this.colors}
	lines:${this.lines}
	live:${this.live}
	maxLayer:${this.maxLayer}
	maxPoints:${this.maxPoints}
	size:${this.size}
	weights:${this.weights}
	meta:${JSON.stringify(this.meta)}
}`
            }
        },
        hW = class {
            constructor(e) {
                this.key = e.key, this.line = e.line
            }
            whenReceived(e) {
                e.entities[this.key].lines.push(this.line)
            }
            toString() {
                return `DoodleLine{
	val:${this.line}
}`
            }
        },
        fW = class {
            constructor(e) {
                this.key = e.key, this.index = e.index
            }
            whenReceived(e) {
                e.entities[this.key].lines.splice(this.index, 1)
            }
            toString() {
                return `DoodleLineRemoved{
	index:${this.index}
}`
            }
        };
    var xv = {
        DoodleEntity: lW,
        DoodleLine: hW,
        DoodleLineRemoved: fW
    };
    let dW = class {
        constructor(e) {
            this.key = e.key, this.count = e.count, this.meta = e.meta || {}
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `GCounter{
	count:${this.count}
	meta:${this.meta}
}`
        }
    };
    var Pv = {
        GCounter: dW
    };
    let pW = class {
        constructor(e) {
            this.pc = e.pc, this.opcode = e.opcode, this.result = e.result
        }
    };
    var FO = {
        Notification: pW
    };
    let mW = class UO {
        constructor(e) {
            this.from = e.from, this.key = e.key, this.val = e.val, this.restrictions = e.restrictions, this.version = e.version, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
        }
        whenReceived(e) {
            if (e.entities[this.key] && e.entities[this.key] instanceof UO && !this.restrictions) {
                e.entities[this.key].val = this.val, e.entities[this.key].meta = this.meta, e.entities[this.key].version = this.version, e.entities[this.key].from = this.from;
                return
            }
            e.entities[this.key] = this
        }
        toString() {
            return `NumberEntity{
	key:${this.key}
	val: ${this.val}
	restrictions: ${JSON.stringify(this.restrictions)}
	meta: ${JSON.stringify(this.meta)}
}`
        }
    };
    var Rv = {
        NumberEntity: mW
    };
    let gW = class {
            constructor(e) {
                this.from = e.from, this.key = e.key, this.val = e.val, this.version = e.version, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
            }
            whenReceived(e) {
                e.entities[this.key] = this
            }
            toString() {
                return `ObjectEntity{
	key:${this.key}
	value: ${JSON.stringify(this.val)}
	meta:${JSON.stringify(this.meta)}
}`
            }
            toBlob() {
                return this.val
            }
        },
        _W = class {
            constructor(e) {
                this.message = e.message
            }
            toString() {
                return `ObjectEcho{message: ${this.message}}`
            }
        };
    var Mv = {
        ObjectEntity: gW,
        ObjectEcho: _W
    };
    let yW = class {
        constructor(e) {
            this.key = e.key, this.count = e.count, this.meta = e.meta || {}
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `PNCounter{
	count:${this.count}
	meta:${JSON.stringify(this.meta)}
}`
        }
    };
    var Dv = {
        PNCounter: yW
    };
    let vW = class {
        constructor(e) {
            this.pc = e.pc, this.re = e.re, this.opcode = e.opcode, this.result = e.result
        }
    };
    var BO = {
        Reply: vW
    };
    let bW = class {
        constructor(e) {
            this.seq = e.seq, this.opcode = e.opcode, this.params = e.params
        }
    };
    var EW = {
        Request: bW
    };
    let SW = class {
            constructor(e) {
                this.key = e.key, this.size = e.size, this.version = e.version, this.from = e.from, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
            }
            whenRecived(e) {
                e.entities[this.key] = this
            }
            toString() {
                return `Stack{
	key:${this.key}
	size:${this.size}
	version:${this.version}
	from:${this.from}
	meta:${this.meta}
}`
            }
        },
        TW = class {
            constructor(e) {
                this.key = e.key, this.val = e.val
            }
            toString() {
                return `StackElement{
	key:${this.key}
	value: ${JSON.stringify(this.val)}
}`
            }
        },
        wW = class {
            constructor(e) {
                this.key = e.key, this.vals = e.vals
            }
            toString() {
                return `StackElements{
	key:${this.key}
	values: ${JSON.stringify(this.vals)}
}`
            }
        };
    var qO = {
        StackEntity: SW,
        StackElement: TW,
        StackElements: wW
    };
    let OW = class {
            constructor(e) {
                this.from = e.from, this.key = e.key, this.text = e.text, this.version = e.version, this.meta = e.meta || {}, e.acl && (this.acl = e.acl)
            }
            whenReceived(e) {
                e.entities[this.key] = this, e.emit("text " + this.key, this)
            }
            toString() {
                return `TextEntity{
	key: ${this.key}
	text: ${this.text}
	meta:${JSON.stringify(this.meta)}
}`
            }
            toBlob() {
                return JSON.parse(this.text)
            }
        },
        AW = class {
            constructor(e) {
                this.message = e.message
            }
            toString() {
                return `TextEcho{
	key: ${this.key}
	message: ${this.message}
}`
            }
        };
    var $v = {
        TextEntity: OW,
        TextEcho: AW
    };
    let CW = class {
            constructor(e) {
                this.from = e.from, this.key = e.key, this.meta = e.meta || {}, this.root = e.root, e.acl && (this.acl = e.acl)
            }
            whenReceived(e) {
                e.entities[this.key] = this
            }
            toString() {
                return `TextMap{
	key:${this.key}
	meta:${JSON.stringify(this.meta)}
}`
            }
        },
        IW = class {
            constructor(e) {
                this.from = e.from, this.key = e.key, this.msg = e.msg
            }
            toString() {
                const e = this.msg ? this.msg.join(", ") : this.msg;
                return `TextMapSynced{
	key:${this.key}
	from:${this.from}
	msg:${e}
}`
            }
        },
        kW = class {
            constructor(e) {
                this.from = e.from, this.key = e.key, this.text = e.text, this.attributions = e.attributions
            }
            toString() {
                return `TextMapState{
	key: ${this.key}
	from:${this.from}
	text:${this.text}
	attributions:${this.attributions}
}`
            }
        };
    var Lv = {
        TextMapEntity: CW,
        TextMapSynced: IW,
        TextMapState: kW
    };
    let NW = class {
        constructor(e) {
            this.key = e.key, this.elements = e.elements, this.limit = e.limit, this.meta = e.meta || {}
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `TextRing{
	elements: ${this.elements}
	meta:${JSON.stringify(this.meta)}
}`
        }
    };
    var Fv = {
        TextRing: NW
    };
    let xW = class {
        constructor(e) {
            this.key = e.key, this.artifactId = e.artifactId, this.categoryId = e.categoryId, this.rootId = e.rootId, this.meta = e.meta || {}
        }
        whenReceived(e) {
            e.entities[this.key] = this
        }
        toString() {
            return `ArtifactEntity${JSON.stringify(this)}
`
        }
    };
    var VO = {
        ArtifactEntity: xW
    };
    let PW = class {
        constructor(e) {
            this.key = e.key
        }
        whenReceived(e) {
            delete e.entities[this.key]
        }
        toString() {
            return `DropEntity{
	key:${this.key}
}`
        }
    };
    var jO = {
        DropEntity: PW
    };
    let RW = class {
        constructor(e) {
            this.message = e.message
        }
        toString() {
            return `Echo{message: ${this.message}
}`
        }
    };
    var MW = {
        Echo: RW
    };
    let DW = class {
        constructor(e) {
            this.key = e.key, this.from = e.from
        }
        whenReceived(e) {
            e.entities[this.key] && (e.entities[this.key].meta.locked = !0)
        }
        toString() {
            return `LockEntity{
	key:${this.key}
}`
        }
    };
    var $W = {
        LockEntity: DW
    };
    let LW = class {
        constructor() {}
        toString() {
            return "OK"
        }
    };
    var GO = {
        OK: LW
    };
    const {
        ArtifactEntity: FW
    } = VO, {
        ClientWelcome: UW,
        ClientConnected: BW,
        ClientDisconnected: qW,
        ClientKicked: VW,
        ClientSend: jW
    } = kv, {
        CountGroup: GW
    } = Nv, {
        DoodleEntity: WW,
        DoodleLine: HW,
        DoodleLineRemoved: KW
    } = xv, {
        StackEntity: YW,
        StackElement: zW,
        StackElements: ZW
    } = qO, {
        DropEntity: XW
    } = jO, {
        Echo: QW
    } = MW, {
        LockEntity: JW
    } = $W, {
        GCounter: eH
    } = Pv, {
        GetAudienceReply: tH,
        RoomExit: nH,
        RoomLock: rH
    } = Xp, {
        Notification: sH
    } = FO, {
        OK: iH
    } = GO, {
        NumberEntity: oH
    } = Rv, {
        ObjectEcho: aH,
        ObjectEntity: cH
    } = Mv, {
        PNCounter: yT
    } = Dv, {
        Reply: uH
    } = BO, {
        TextEcho: lH,
        TextEntity: hH
    } = $v, {
        TextRing: fH
    } = Fv, {
        createError: vT,
        ObservedError: dH
    } = el, {
        TextMapEntity: pH,
        TextMapSynced: mH,
        TextMapState: gH
    } = Lv;

    function y1(t, e, n) {
        switch (t) {
            case "ok":
                return new iH;
            case "echo":
                return new QW({
                    message: e.message
                });
            case "lock":
                return new JW({
                    key: e.key,
                    from: e.from
                });
            case "error":
                return vT({
                    code: e.code,
                    message: e.msg
                });
            case "error/observed":
                return new dH({
                    to: e.to,
                    opcode: e.opcode,
                    error: vT({
                        code: e.error.code,
                        message: e.error.msg
                    })
                });
            case "string":
                return e;
            case "text":
                return new hH({
                    from: e.from,
                    key: e.key,
                    text: e.val,
                    version: e.version,
                    meta: n,
                    acl: e.acl
                });
            case "text/echo":
                return new lH({
                    message: e.message
                });
            case "object":
                return new cH({
                    from: e.from,
                    key: e.key,
                    val: e.val,
                    meta: n,
                    acl: e.acl
                });
            case "object/echo":
                return new aH({
                    message: e.message
                });
            case "drop":
                return new XW({
                    key: e.key
                });
            case "artifact":
                return new FW({
                    key: e.key,
                    artifactId: e.artifactId,
                    categoryId: e.categoryId,
                    rootId: e.rootId,
                    meta: n
                });
            case "client/connected":
                return new BW({
                    id: e.id,
                    userId: e.userId,
                    name: e.name,
                    role: e.role,
                    reconnect: e.reconnect
                });
            case "client/disconnected":
                return new qW({
                    id: e.id,
                    role: e.role
                });
            case "client/kicked":
                return new VW({
                    id: e.id,
                    banned: e.banned,
                    reason: e.reason
                });
            case "client/send":
                return new jW({
                    to: e.to,
                    from: e.from,
                    body: e.body,
                    userId: e.userID
                });
            case "client/welcome": {
                let r = new UW({
                    id: e.id,
                    name: e.name,
                    secret: e.secret,
                    reconnect: e.reconnect,
                    here: e.here,
                    profile: e.profile,
                    replayEnd: e.replayEnd
                });
                if (e.entities) {
                    let s = {};
                    Object.entries(e.entities).forEach(([i, a]) => {
                        s[i] = y1(a[0], a[1], a[2])
                    }), r.entities = s
                }
                return r
            }
            case "doodle":
                return new WW({
                    key: e.key,
                    colors: e.val.colors,
                    lines: e.val.lines,
                    live: e.val.live,
                    maxLayer: e.val.maxLayer,
                    maxPoints: e.val.maxPoints,
                    size: e.val.size,
                    weights: e.val.weights,
                    meta: n,
                    acl: e.acl
                });
            case "doodle/line":
                return new HW({
                    key: e.key,
                    line: e.val
                });
            case "doodle/line/removed":
                return new KW({
                    key: e.key,
                    index: e.index
                });
            case "stack":
                return new YW({
                    key: e.key,
                    size: e.size,
                    from: e.from,
                    version: e.version,
                    meta: e.meta,
                    acl: e.acl
                });
            case "stack/element":
                return new zW({
                    key: e.key,
                    val: e.val
                });
            case "stack/elements":
                return new ZW({
                    key: e.key,
                    vals: e.vals
                });
            case "number":
                return new oH({
                    key: e.key,
                    val: e.val,
                    restrictions: e.restrictions,
                    from: e.from,
                    version: e.version,
                    meta: n,
                    acl: e.acl
                });
            case "text-map":
                return new pH({
                    key: e.key,
                    from: e.from,
                    root: e.root,
                    meta: n,
                    acl: e.acl
                });
            case "text-map/state":
                return new gH({
                    key: e.key,
                    from: e.from,
                    attributions: e.attributions,
                    text: e.text
                });
            case "text-map/synced":
                return new mH({
                    key: e.key,
                    from: e.from,
                    msg: e.msg
                });
            case "room/exit":
                return new nH({
                    cause: e.cause
                });
            case "room/lock":
                return new rH;
            case "room/get-audience":
                return new tH({
                    connections: e.connections
                });
            case "audience":
                return new yT({
                    key: t,
                    count: e[1]
                });
            case "audience/count-group":
                return new GW({
                    key: e.key,
                    choices: e.choices,
                    meta: n
                });
            case "audience/text-ring":
                return new fH({
                    key: e.key,
                    elements: e.elements,
                    meta: n
                });
            case "audience/g-counter":
                return new eH({
                    key: e.key,
                    count: e.count,
                    meta: n
                });
            case "audience/pn-counter":
                return new yT({
                    key: e.key,
                    count: e.count,
                    meta: n
                });
            default:
                return console.error(`failed to parse result of type ${t}: ${JSON.stringify(e,null,2)}`), e
        }
    }

    function _H(t) {
        let e = JSON.parse(t.data),
            n = e.opcode || e.type;
        return e.re ? new uH({
            pc: e.pc,
            re: e.re,
            opcode: n,
            result: y1(n, e.result)
        }) : new sH({
            pc: e.pc,
            opcode: n,
            result: y1(n, e.result)
        })
    }
    var yH = {
        parseResponseMessage: _H
    };
    const bT = KG,
        vH = Q4,
        bH = eW,
        {
            CallError: EH
        } = el,
        {
            ClientWelcome: SH
        } = kv,
        {
            CountGroup: TH
        } = Nv,
        {
            DoodleEntity: wH
        } = xv,
        {
            GCounter: OH
        } = Pv,
        {
            Notification: ET
        } = FO,
        {
            NumberEntity: AH
        } = Rv,
        {
            ObjectEntity: g_
        } = Mv,
        {
            PNCounter: CH
        } = Dv,
        {
            Reply: IH
        } = BO,
        {
            Request: kH
        } = EW,
        {
            StackEntity: NH
        } = qO,
        {
            TextEntity: __
        } = $v,
        {
            TextMapEntity: xH
        } = Lv,
        {
            TextRing: PH
        } = Fv,
        {
            parseResponseMessage: RH
        } = yH,
        MH = 1e3 + Math.floor(Math.random() * 500),
        ST = 13e3;
    let DH = class extends bH {
        constructor(e) {
            if (super(), this.debug = e.debug || !1, !e.host) throw new Error("unable to create ecast WSClient: no host provided");
            if (this.host = e.host, !e.code) throw new Error("unable to create ecast WSClient: no room code provided");
            if (this.code = e.code, e.scheme ? this.scheme = e.scheme : this.scheme = "wss", e.secret && e.id) this.id = e.id, this.secret = e.secret;
            else {
                switch (e.role) {
                    case "player":
                        if (!e.name) throw new Error("unable to create ecast WSClient: no name provided");
                        break;
                    case "host":
                        if (!e.token) throw new Error("unable to create ecast WSClient: tried to connect with host role but without host token");
                        this.token = e.token;
                        break;
                    case "moderator":
                        if (!e.password) throw new Error("unable to create ecast WSClient: tried to connect with moderator role but without password");
                        break
                }
                e.password && (this.password = e.password), e.twitchToken && (this.twitchToken = e.twitchToken)
            }
            this.name = e.name, this.role = e.role, this.deviceId = e.deviceId, this.userId = e.userId, this.conn = null, this.seq = 0, this.pending = {}, this.entities = {}, e.role == "host" && (this.replaySince = e.replaySince || 0, this.syncEntities = e.syncEntities || !1)
        }
        connect() {
            const e = {
                id: this.id,
                role: this.role,
                name: this.name,
                format: "json",
                "user-id": this.userId,
                password: this.password
            };
            this.deviceId && (e["device-id"] = this.deviceId), this.twitchToken && (e["twitch-token"] = this.twitchToken), this.secret && (e.secret = this.secret), this.role === "host" && (e["host-token"] = this.token, this.replaySince > 0 && (e["replay-since"] = this.replaySince), this.syncEntities && (e["sync-entities"] = this.syncEntities));
            const n = vH.stringify(e),
                r = this.role === "audience" || this.id > 1e7 ? `${this.scheme}://${this.host}/api/v2/audience/${this.code}/play?${n}` : `${this.scheme}://${this.host}/api/v2/rooms/${this.code}/play?${n}`;
            return new Promise((s, i) => {
                let a = !1,
                    c = !1,
                    l = d => {
                        s(d), a = !0
                    },
                    h = d => {
                        i(d), a = !0
                    };
                this.conn = new bT(r, "ecast-v0"), this.conn.onmessage = d => {
                    this.debugLog(`recv <- ${JSON.stringify(JSON.parse(d.data),null,2)}`);
                    const p = RH(d);
                    if (p instanceof IH) this.onReply(p);
                    else if (p instanceof ET) {
                        if (p.result instanceof SH) c = !0, this.id = p.result.id, this.deviceId = p.result.deviceId, this.entities = p.result.entities, this.secret = p.result.secret, p.result.name && (this.name = p.result.name), l(p.result);
                        else if (!a) {
                            h(p.result);
                            return
                        }
                        this.onNotification(p)
                    } else console.error(`failed to parse response messsage: ${p}`)
                }, this.conn.onerror = d => {
                    a ? this.emit("socketError", d) : h(d)
                }, this.conn.onclose = d => {
                    this.debugLog("onclose", d.code), c && d.code === 1006 ? this.reconnect() : this.emit("socketClose", d)
                }, this.conn.onopen = d => {
                    this.emit("socketOpen", d)
                }
            })
        }
        sleep(e) {
            return new Promise(n => setTimeout(n, e))
        }
        debugLog(...e) {
            this.debug && console.log(`%c[WSClient:${this.name}]`, "background-color:blue;color:white;", ...e)
        }
        async reconnect() {
            this.disconnect(), this.debugLog("Attempting to reconnect");
            let e = 1,
                n = MH;
            for (;;) try {
                this.emit("connection", {
                    status: "connecting",
                    attempt: e
                }), await this.connect(), this.debugLog("reconnected"), this.emit("connection", {
                    status: "connected"
                });
                return
            } catch (r) {
                if (this.debugLog("reconnect error", r), r.code === 1005 || r.code === 1e3) {
                    this.debugLog("unable to reconnect!", r), this.emit("socketClose", r);
                    return
                }
                if (n >= ST) {
                    this.debugLog("reconnect failed!", r), this.emit("socketClose", r);
                    return
                }
                e += 1, this.debugLog("waiting", n), this.emit("connection", {
                    status: "waiting",
                    attempt: e
                }), await this.sleep(n), n = Math.min(ST, n * 2)
            }
        }
        disconnect() {
            this.conn && (this.conn.close(), this.conn.onmessage = null, this.conn.onerror = null, this.conn.onopen = null, this.conn.onclose = null, this.conn = null)
        }
        onReply(e) {
            const n = e.re,
                r = this.pending[n];
            if (!r) {
                const s = new ET(e);
                s.re = n, this.emit("notification", s);
                return
            }
            delete this.pending[n], e.result instanceof EH ? r.reject(e.result) : r.resolve(e.result)
        }
        onNotification(e) {
            typeof e.result.whenReceived == "function" && e.result.whenReceived(this), this.emit("notification", e), this.emit(e.opcode, e.result)
        }
        send(e, n = {}) {
            if (!this.conn) throw new Error("No connection available");
            if (this.conn.readyState !== bT.OPEN) throw new Error(`Socket not ready to send, readyState is ${this.conn.readyState}`);
            const r = ++this.seq,
                s = new kH({
                    seq: r,
                    opcode: e,
                    params: n
                }),
                i = new Promise((c, l) => {
                    this.pending[r] = {
                        resolve: c,
                        reject: l,
                        request: s
                    }
                }),
                a = JSON.stringify(s);
            return this.debugLog(`send -> ${a}`), this.conn.send(a), i
        }
        lockRoom() {
            return this.send("room/lock")
        }
        startAudience() {
            return this.send("room/start-audience")
        }
        getAudience() {
            return this.send("room/get-audience")
        }
        mail(e, n) {
            return this.send("client/send", {
                from: this.id,
                to: e,
                body: n
            })
        }
        kick(e, n = !1, r) {
            return this.send("client/kick", {
                id: e,
                ban: n,
                reason: r
            })
        }
        async drop(e) {
            const n = await this.send("drop", {
                key: e
            });
            return delete this.entities[e], n
        }
        echo(e) {
            return this.send("echo", {
                message: e
            })
        }
        async lock(e) {
            const n = await this.send("lock", {
                key: e
            });
            return this.entities[e].meta.locked = !0, n
        }
        async createNumber(e, n = {}) {
            let r = {
                key: e
            };
            const {
                val: s = 0,
                acl: i,
                min: a,
                max: c,
                increment: l,
                type: h
            } = n;
            r.val = s, i && (r.acl = i), a != null && (r.min = a), c != null && (r.max = c), l && (r.increment = l), h && (r.type = h);
            const d = await this.send("number/create", r);
            return this.entities[e] = new AH({
                key: e,
                val: s,
                restrictions: {
                    min: a,
                    max: c,
                    increment: l,
                    type: h
                },
                meta: {
                    locked: !1
                }
            }), d
        }
        async decrementNumber(e) {
            const n = await this.send("number/decrement", {
                key: e
            });
            return this.entities[e].val = n.val, n
        }
        async getNumber(e) {
            const n = await this.send("number/get", {
                key: e
            });
            return this.entities[e].val = n.val, this.entities[e].restrictions = n.restrictions, n
        }
        async incrementNumber(e) {
            const n = await this.send("number/increment", {
                key: e
            });
            return this.entities[e].val = n.val, n
        }
        async updateNumber(e, n) {
            const r = await this.send("number/update", {
                key: e,
                val: n
            });
            return this.entities[e].val = n, r
        }
        async createObject(e, n, r) {
            const s = {
                key: e,
                val: n
            };
            r && (s.acl = r);
            const i = await this.send("object/create", s);
            return this.entities[e] = new g_({
                key: e,
                val: n,
                meta: {
                    locked: !1
                }
            }), i
        }
        echoObject(e) {
            return this.send("object/echo", {
                message: e
            })
        }
        async getObject(e) {
            const n = await this.send("object/get", {
                key: e
            });
            return this.entities[e].val = n.val, this.entities[e].version = n.version, this.entities[e].from = n.from, n
        }
        async setObject(e, n, r) {
            const s = {
                key: e,
                val: n
            };
            r && (s.acl = r);
            const i = await this.send("object/set", s);
            return this.entities[e] = new g_({
                key: e,
                val: n,
                meta: {
                    locked: !1
                }
            }), i
        }
        async updateObject(e, n) {
            const r = await this.send("object/update", {
                key: e,
                val: n
            });
            return this.entities[e] = new g_({
                key: e,
                val: n,
                meta: {
                    locked: !1
                }
            }), r
        }
        echoText(e) {
            return this.send("text/echo", {
                message: e
            })
        }
        getText(e) {
            return this.send("text/get", {
                key: e
            })
        }
        async createText(e, n, r) {
            const s = {
                    key: e,
                    val: n
                },
                {
                    acl: i,
                    accept: a,
                    reject: c
                } = r;
            i && (s.acl = i), a && (s.accept = a), c && (s.reject = c);
            const l = await this.send("text/create", s);
            return this.entities[e] = new __({
                key: e,
                text: n,
                meta: {
                    locked: !1
                }
            }), l
        }
        async setText(e, n, r) {
            const s = {
                key: e,
                val: n
            };
            r && (s.acl = r);
            const i = await this.send("text/set", s);
            return this.entities[e] = new __({
                key: e,
                text: n,
                meta: {
                    locked: !1
                }
            }), i
        }
        async updateText(e, n) {
            const r = await this.send("text/update", {
                key: e,
                val: n
            });
            return this.entities[e] = new __({
                key: e,
                text: n,
                meta: {
                    locked: !1
                }
            }), r
        }
        async createTextMap(e, n = {}) {
            const {
                val: r,
                notifyHost: s,
                acl: i,
                accept: a,
                reject: c
            } = n;
            let l = {
                key: e
            };
            r && (l.val = n.val), s && (l.notifyHost = n.notifyHost), i && (l.acl = i), a && (l.accept = a), c && (l.reject = c);
            const h = await this.send("text-map/create", l);
            return this.entities[e] = new xH({
                key: e,
                acl: i,
                meta: {
                    locked: !1
                }
            }), h
        }
        async syncTextMap(e, n) {
            return await this.send("text-map/sync", {
                key: e,
                msg: n
            })
        }
        async getTextMap(e, n) {
            const {
                includeNodes: r
            } = n;
            return await this.send("text-map/get", {
                key: e,
                includeNodes: r
            })
        }
        async createDoodle(e, n) {
            let r = {
                key: e
            };
            const {
                acl: s,
                colors: i,
                live: a,
                maxLayer: c,
                maxPoints: l,
                size: h,
                weights: d
            } = n;
            s && (r.acl = s), i && (r.colors = i), r.live = a, c != null && (r.maxLayer = c), l != null && (r.maxPoints = l), h && (r.size = h), d && (r.weights = d);
            const p = await this.send("doodle/create", r);
            return this.entities[e] = new wH({
                key: e,
                colors: i,
                lines: [],
                live: a,
                maxLayer: r.maxLayer || 0,
                maxPoints: r.maxPoints || 0,
                size: h,
                weights: d,
                meta: {
                    locked: !1
                }
            }), p
        }
        async getDoodle(e) {
            const n = await this.send("doodle/get", {
                key: e
            });
            return this.entities[e].lines = n.lines, n
        }
        async strokeDoodle(e, n) {
            const {
                color: r,
                weight: s,
                layer: i,
                points: a,
                brush: c
            } = n, l = {
                color: r,
                weight: s,
                layer: i,
                points: a
            };
            c && (l.brush = c);
            const h = await this.send("doodle/stroke", {
                key: e,
                ...l
            });
            return this.entities[e].lines.push(l), h
        }
        async undoDoodle(e) {
            const n = await this.send("doodle/undo", {
                key: e
            });
            return this.entities[e].lines.pop(), n
        }
        async createStack(e, n) {
            const r = {
                key: e
            };
            n && (r.acl = n);
            const s = await this.send("stack/create", r);
            return this.entities[e] = new NH({
                key: e,
                size: 0,
                meta: {
                    locked: !1
                }
            }), s
        }
        pushStack(e, n) {
            return this.send("stack/push", {
                key: e,
                val: n
            })
        }
        bulkPushStack(e, n) {
            return this.send("stack/bulkpush", {
                key: e,
                vals: n
            })
        }
        peekStack(e, n) {
            return this.send("stack/peek", {
                key: e,
                size: n
            })
        }
        popStack(e) {
            return this.send("stack/pop", {
                key: e
            })
        }
        async createCountGroup(e, n) {
            const r = await this.send("audience/count-group/create", {
                name: e,
                options: n
            });
            return this.entities[e] = new TH({
                key: e,
                choices: n,
                meta: {
                    locked: !1
                }
            }), r
        }
        incrementCountGroupCounter(e, n, r = 1) {
            return this.send("audience/count-group/increment", {
                name: e,
                vote: n,
                times: r
            })
        }
        getCountGroup(e) {
            return this.send("audience/count-group/get", {
                name: e
            })
        }
        async createGCounter(e, n) {
            const r = await this.send("audience/g-counter/create", {
                key: e,
                count: n
            });
            return this.entities[e] = new OH({
                key: e,
                count: n,
                meta: {
                    locked: !1
                }
            }), r
        }
        incrementGCounter(e, n) {
            return this.send("audience/g-counter/increment", {
                key: e,
                times: n
            })
        }
        getGCounter(e) {
            return this.send("audience/g-counter/get", {
                key: e
            })
        }
        async createPNCounter(e, n) {
            const r = await this.send("audience/pn-counter/create", {
                key: e,
                count: n
            });
            return this.entities[e] = new CH({
                key: e,
                count: n,
                meta: {
                    locked: !1
                }
            }), r
        }
        incrementPNCounter(e, n) {
            return this.send("audience/pn-counter/increment", {
                key: e,
                times: n
            })
        }
        decrementPNCounter(e, n) {
            return this.send("audience/pn-counter/decrement", {
                key: e,
                times: n
            })
        }
        getPNCounter(e) {
            return this.send("audience/pn-counter/get", {
                key: e
            })
        }
        async createTextRing(e, n) {
            const r = {
                    key: e
                },
                {
                    limit: s,
                    accept: i,
                    reject: a
                } = n;
            s && (r.limit = s), i && (r.accept = i), a && (r.reject = a);
            const c = await this.send("audience/text-ring/create", r);
            return this.entities[e] = new PH({
                key: e,
                elements: [],
                limit: s,
                meta: {
                    locked: !1
                }
            }), c
        }
        getTextRing(e) {
            return this.send("audience/text-ring/get", {
                name: e
            })
        }
        pushTextRing(e, n) {
            return this.send("audience/text-ring/push", {
                name: e,
                text: n
            })
        }
    };
    var $H = {
        WSClient: DH
    };
    const {
        APIClient: LH
    } = HG, {
        WSClient: FH
    } = $H, {
        CreateRoomReply: UH,
        GetRoomReply: BH
    } = Xp, {
        ClientWelcome: qH,
        ClientDisconnected: VH
    } = kv, {
        ArtifactEntity: jH
    } = VO, {
        GCounter: GH
    } = Pv, {
        NumberEntity: WH
    } = Rv, {
        TextEntity: HH
    } = $v, {
        DoodleEntity: KH
    } = xv, {
        ObjectEntity: YH
    } = Mv, {
        CountGroup: zH
    } = Nv, {
        DropEntity: ZH
    } = jO, {
        OK: XH
    } = GO, {
        RoomExit: QH
    } = Xp, {
        TextRing: JH
    } = Fv, {
        TextMapEntity: eK
    } = Lv, {
        PNCounter: tK
    } = Dv;
    var Sr = {
        APIClient: LH,
        WSClient: FH,
        ClientWelcome: qH,
        CreateRoomReply: UH,
        DropEntity: ZH,
        GetRoomReply: BH,
        ClientDisconnected: VH,
        RoomExit: QH,
        OK: XH,
        ArtifactEntity: jH,
        DoodleEntity: KH,
        NumberEntity: WH,
        CountGroup: zH,
        GCounter: GH,
        ObjectEntity: YH,
        PNCounter: tK,
        TextEntity: HH,
        TextRing: JH,
        TextMapEntity: eK
    };
    const nK = [{
            name: "Prototype",
            tag: "prototype",
            wrapper: "vue",
            isPublic: !0,
            directory: "internal/prototype"
        }, {
            name: "EcastTestClient",
            tag: "ecast-test-client",
            wrapper: "marionette",
            isPublic: !0,
            directory: "internal/ecast-test-client"
        }, {
            name: "Quiplash 2 InterLASHional",
            tag: "quiplash2-international",
            wrapper: "marionette",
            isPublic: !0,
            directory: "standalone/quiplash2-international",
            categoryId: "quiplash2-internationalGame"
        }, {
            name: "Guesspionage Crowdplay",
            tag: "guesspionage-crowdplay",
            wrapper: "marionette",
            isPublic: !0,
            directory: "standalone/guesspionage-crowdplay"
        }, {
            name: "Drawful 2",
            tag: "drawful2",
            wrapper: "marionette",
            isPublic: !0,
            directory: "standalone/drawful2",
            categoryId: "DrawfulGame",
            shopItems: ["shirts"]
        }, {
            name: "Drawful 2",
            tag: "drawful2international",
            wrapper: "marionette",
            isPublic: !0,
            directory: "standalone/drawful2-international",
            features: ["moderation"]
        }, {
            name: "Acquisitions, Inc.",
            tag: "acquisitions-inc",
            wrapper: "marionette",
            isPublic: !0,
            directory: "standalone/acquisitions-inc"
        }, {
            name: "You Don't Know Jack 2015",
            tag: "ydkj2015",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp1/ydkj2015"
        }, {
            name: "Drawful",
            tag: "drawful",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp1/drawful"
        }, {
            name: "Word Spud",
            tag: "wordspud",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp1/wordspud"
        }, {
            name: "Lie Swatter",
            tag: "lieswatter",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp1/lieswatter"
        }, {
            name: "Fibbage",
            tag: "fibbage",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp1/fibbage"
        }, {
            name: "Fibbage 2",
            tag: "fibbage2",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp2/fibbage2"
        }, {
            name: "Earwax",
            tag: "earwax",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp2/earwax"
        }, {
            name: "Bidiots",
            tag: "auction",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp2/auction"
        }, {
            name: "Bomb Corp",
            tag: "bombintern",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp2/bombintern"
        }, {
            name: "Quiplash",
            tag: "quiplash",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp2/quiplash"
        }, {
            name: "Fakin' It",
            tag: "fakinit",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp3/fakinit"
        }, {
            name: "Tee K.O.",
            tag: "awshirt",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp3/awshirt",
            categoryId: "TeeKOGame",
            shopItems: ["shirts"]
        }, {
            name: "Quiplash 2",
            tag: "quiplash2",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp3/quiplash2",
            categoryId: "Quiplash2Game"
        }, {
            name: "Trivia Murder Party",
            tag: "triviadeath",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp3/triviadeath",
            categoryId: "TriviaDeathResults"
        }, {
            name: "Guesspionage",
            tag: "pollposition",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp3/pollposition"
        }, {
            name: "Fibbage 3",
            tag: "fibbage3",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp4/fibbage3"
        }, {
            name: "Survive the Internet",
            tag: "survivetheinternet",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp4/survivetheinternet",
            categoryId: "STIGame"
        }, {
            name: "Monster Seeking Monster",
            tag: "monstermingle",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp4/monstermingle",
            categoryId: "MonsterMingleGame"
        }, {
            name: "Bracketeering",
            tag: "bracketeering",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp4/bracketeering",
            categoryId: "BRKGame"
        }, {
            name: "Civic Doodle",
            tag: "overdrawn",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp4/overdrawn",
            categoryId: "OverdrawnGame",
            shopItems: ["shirts"]
        }, {
            name: "You Don't Know Jack: Full Stream",
            tag: "ydkj2018",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp5/ydkj2018",
            categoryId: "YDKJ2018Game"
        }, {
            name: "Split the Room",
            tag: "splittheroom",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp5/splittheroom",
            categoryId: "SplitTheRoomGame"
        }, {
            name: "Mad Verse City",
            tag: "rapbattle",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp5/rapbattle",
            categoryId: "RapBattleGame"
        }, {
            name: "Zeeple Dome",
            tag: "slingshoot",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp5/slingshoot",
            categoryId: "SlingShootGame"
        }, {
            name: "Patently Stupid",
            tag: "patentlystupid",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp5/patentlystupid",
            categoryId: "PatentlyStupidGame",
            shopItems: ["mugs"]
        }, {
            name: "Trivia Murder Party 2",
            tag: "triviadeath2",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp6/triviadeath2",
            categoryId: "TriviaDeath2Game"
        }, {
            name: "Role Models",
            tag: "rolemodels",
            wrapper: "marionette",
            isPublic: !0,
            features: ["camera"],
            directory: "pp6/rolemodels",
            categoryId: "RoleModelsGame",
            shopItems: ["shirts"]
        }, {
            name: "Joke Boat",
            tag: "jokeboat",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp6/jokeboat",
            categoryId: "JokeboatGame"
        }, {
            name: "Dictionarium",
            tag: "ridictionary",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp6/ridictionary",
            categoryId: "RidictionaryGame"
        }, {
            name: "Push the Button",
            tag: "pushthebutton",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp6/pushthebutton",
            categoryId: "PushTheButtonGame"
        }, {
            name: "Talking Points",
            tag: "jackbox-talks",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp7/jackboxtalks",
            features: ["camera", "moderation"],
            categoryId: "JackboxTalksGame"
        }, {
            name: "Quiplash 3",
            tag: "quiplash3",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp7/quiplash3",
            features: ["moderation"],
            categoryId: "quiplash3Game"
        }, {
            name: "The Devils and the Details",
            tag: "everyday",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp7/everyday",
            categoryId: "EverydayGame",
            shopItems: ["mugs"]
        }, {
            name: "Champ'd Up",
            tag: "worldchamps",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp7/worldchamps",
            features: ["moderation"],
            categoryId: "WorldChampionsGame",
            shopItems: ["cards"]
        }, {
            name: "Blather 'Round",
            tag: "blanky-blank",
            wrapper: "marionette",
            isPublic: !0,
            directory: "pp7/blanky-blank",
            categoryId: "BlankyBlankGame"
        }, {
            name: "Job Job",
            tag: "apply-yourself",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp8/apply-yourself",
            categoryId: "JobGameGame",
            features: ["moderation", "previews"]
        }, {
            name: "Drawful Animate",
            tag: "drawful-animate",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp8/drawful-animate",
            categoryId: "DrawfulAnimateGame",
            features: ["moderation"]
        }, {
            name: "The Wheel of Enormous Proportions",
            tag: "the-wheel",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp8/the-wheel",
            categoryId: "TheWheelGame"
        }, {
            name: "The Poll Mine",
            tag: "survey-bomb",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp8/survey-bomb",
            categoryId: "SurveyBombGame"
        }, {
            name: "Weapons Drawn",
            tag: "murder-detectives",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp8/murder-detectives",
            categoryId: "MurderDetectivesGame",
            features: ["moderation"]
        }, {
            name: "Quiplash 3",
            tag: "quiplash3-tjsp",
            wrapper: "vue",
            isPublic: !0,
            directory: "tjsp/quiplash3",
            features: ["moderation"],
            categoryId: "quiplash3Game"
        }, {
            name: "Tee K.O.",
            tag: "awshirt-tjsp",
            wrapper: "vue",
            isPublic: !0,
            directory: "tjsp/awshirt",
            features: ["moderation"],
            shopItems: ["shirts"],
            categoryId: "TeeKOGame"
        }, {
            name: "Trivia Murder Party 2",
            tag: "triviadeath2-tjsp",
            wrapper: "vue",
            isPublic: !0,
            directory: "tjsp/triviadeath2",
            categoryId: "TriviaMurderParty2Game"
        }, {
            name: "Fibbage 4",
            tag: "fourbage",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp9/fourbage",
            features: ["moderation", "kicking"],
            categoryId: "Fibbage4Game"
        }, {
            name: "Roomerang",
            tag: "htmf",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp9/htmf",
            features: ["moderation", "kicking"],
            categoryId: "MakeFriendsGame"
        }, {
            name: "Junktopia",
            tag: "antique-freak",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp9/antique-freak",
            features: ["moderation", "kicking"],
            categoryId: "AntiqueGameGame"
        }, {
            name: "Nonsensory",
            tag: "range-game",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp9/range-game",
            features: ["moderation", "kicking"],
            categoryId: "RangeGameGame"
        }, {
            name: "Quixort",
            tag: "lineup",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp9/lineup",
            features: ["kicking", "previews"],
            categoryId: "LineupGame"
        }, {
            name: "Tee K.O. 2",
            tag: "awshirt2",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp10/awshirt2",
            features: ["moderation", "kicking"],
            shopItems: ["shirts"],
            categoryId: "TeeKO2Game"
        }, {
            name: "Dodo Re Mi",
            tag: "nopus-opus",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp10/nopus-opus",
            features: ["dropInDropOut", "kicking"],
            shopItems: [],
            categoryId: "NopusOpusGame"
        }, {
            name: "FixyText",
            tag: "risky-text",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp10/risky-text",
            features: ["moderation", "kicking"],
            shopItems: [],
            categoryId: "RiskyTextGame"
        }, {
            name: "Timejinx",
            tag: "time-trivia",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp10/time-trivia",
            features: ["kicking"],
            shopItems: [],
            categoryId: "TimeTriviaGame"
        }, {
            name: "Hypnotorious",
            tag: "us-them",
            wrapper: "vue",
            isPublic: !0,
            directory: "pp10/us-them",
            features: ["moderation", "kicking"],
            shopItems: [],
            categoryId: "UsThemGame"
        }],
        v1 = t => nK.find(e => e.tag === t || e.categoryId === t);

    function b1(...t) {
        console.log(...t)
    }
    class rK {
        constructor(e, n) {
            Ce(this, "client");
            Ce(this, "room");
            Ce(this, "items", []);
            Ce(this, "autoMarkWindow", 150);
            Ce(this, "autoMarkTimeout");
            Ce(this, "autoMarkerCount", 0);
            Ce(this, "automarkIgnoredKeys", []);
            Ce(this, "automarkPendingLabel");
            window.tv.debug = this.expose(), this.client = e, this.room = n, Object.keys(this.client.entities).forEach(r => {
                this.pushEntity(this.client.entities[r])
            }), this.items.length && this.setMarker("welcome"), e.on("artifact", r => this.pushEntity(r)), e.on("doodle", r => this.pushEntity(r)), e.on("drop", r => this.pushEntity(r)), e.on("number", r => this.pushEntity(r)), e.on("object", r => this.pushEntity(r)), e.on("text", r => this.pushEntity(r)), this.hijackConsole(), this.hijackSend()
        }
        get markerCount() {
            return this.items.reduce((e, n) => "marker" in n ? e + 1 : e, 0)
        }
        reset() {
            this.items = []
        }
        setAutomarkIgnoredKeys(e) {
            this.automarkIgnoredKeys = e
        }
        hijackConsole() {
            const e = console.error.bind(console);
            console.error = (...n) => {
                this.pushError(n), e.apply(console, n)
            }
        }
        hijackSend() {
            window.Proxy && (this.client.send = new Proxy(this.client.send, {
                apply: (e, n, r) => (this.pushSend(r), e.apply(n, r))
            }))
        }
        pushEntity(e) {
            b1("[Debug] pushEntity", e), e instanceof Sr.ArtifactEntity ? this.items.push({
                type: "artifact",
                ...e
            }) : e instanceof Sr.DoodleEntity ? this.items.push({
                type: "doodle",
                ...e
            }) : e instanceof Sr.DropEntity ? this.items.push({
                key: e.key,
                type: "drop"
            }) : e instanceof Sr.NumberEntity ? this.items.push({
                key: e.key,
                type: "number",
                value: e.val,
                meta: e.meta,
                restrictions: e.restrictions
            }) : e instanceof Sr.ObjectEntity ? (e.val.kind && (this.automarkPendingLabel = e.val.kind), this.items.push({
                key: e.key,
                type: "object",
                value: e.val,
                meta: e.meta
            })) : e instanceof Sr.TextEntity && this.items.push({
                key: e.key,
                type: "text",
                value: e.text,
                meta: e.meta
            }), !this.automarkIgnoredKeys.includes(e.key) && this.startAutoMarkTimeout()
        }
        pushError(...e) {
            this.items.push({
                error: e
            })
        }
        pushSend(e) {
            this.items.push({
                opcode: e[0],
                arguments: e[1]
            })
        }
        setMarker(e) {
            const n = this.items.filter(s => s.marker === e).length,
                r = n ? `label-${n}` : e;
            this.items.push({
                marker: r
            }), this.clearAutoMarkTimeout()
        }
        setAutoMarker() {
            const e = this.automarkPendingLabel ?? "marker";
            this.items.push({
                marker: `${this.autoMarkerCount}-${e}`
            }), this.autoMarkerCount += 1, delete this.automarkPendingLabel, this.clearAutoMarkTimeout()
        }
        startAutoMarkTimeout() {
            this.clearAutoMarkTimeout(), this.autoMarkTimeout = window.setTimeout(() => {
                this.setAutoMarker()
            }, this.autoMarkWindow)
        }
        clearAutoMarkTimeout() {
            this.autoMarkTimeout && (window.clearTimeout(this.autoMarkTimeout), delete this.autoMarkTimeout)
        }
        async send(e) {
            if (!this.client) return;
            const n = await this.sendToEcast();
            n && await this.sendToSlack(n, e)
        }
        getSendData() {
            return {
                appTag: this.room.appTag,
                state: {
                    version: 3,
                    room: {
                        code: this.room.code,
                        appTag: this.room.appTag
                    },
                    client: {
                        id: this.client.id,
                        name: this.client.name,
                        role: this.client.role
                    },
                    items: this.items
                }
            }
        }
        async sendToEcast() {
            const e = this.getSendData();
            try {
                const r = await (await fetch("https://ecast.jackboxgames.com/api/v2/controller/state", {
                    method: "POST",
                    body: JSON.stringify(e)
                })).json();
                if (!r.body || !r.body.url) return console.warn(r), null;
                const s = r.body.url.split("/"),
                    i = s[s.length - 1].replace(".json", ""),
                    a = s[s.length - 2];
                return {
                    json: r.body.url,
                    dev: `https://dev.jackbox.tv/debug/cloud/${a}/${i}/`,
                    local: `http://localhost:9090/debug/cloud/${a}/${i}/`
                }
            } catch (n) {
                return console.error("[Debug] sendToEcast", n), null
            }
        }
        async sendToSlack(e, n) {
            if (!this.room || !this.client) return;
            const r = v1(this.room.appTag),
                s = this.items.length - this.markerCount,
                i = `${this.markerCount} ${this.markerCount===1?"marker":"markers"}`,
                a = `${s} ${s===1?"entity":"entities"}`,
                c = [{
                    type: "mrkdwn",
                    text: `${this.client.role}:${this.client.id}`
                }, {
                    type: "mrkdwn",
                    text: `*Version:* ${window.tv.manifest.loader.version}`
                }, {
                    type: "mrkdwn",
                    text: `*Domain:* ${window.location.hostname}`
                }];
            try {
                const l = "https://hooks.slack.com/services/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",
                    g = {
                        unfurl_links: !1,
                        blocks: [{
                            type: "section",
                            text: {
                                type: "mrkdwn",
                                text: `*${(r==null?void 0:r.name)??this.room.appTag} :${this.room.appTag}:* (${i}, ${a}) 

 From: ${this.client.name},
${n}`
                            }
                        }, {
                            type: "context",
                            elements: c
                        }, {
                            type: "actions",
                            elements: [{
                                type: "button",
                                action_id: "actionId-0",
                                url: e.json,
                                text: {
                                    type: "plain_text",
                                    text: "JSON",
                                    emoji: !0
                                }
                            }, {
                                type: "button",
                                action_id: "actionId-3",
                                url: e.local,
                                text: {
                                    type: "plain_text",
                                    text: "localhost:9090",
                                    emoji: !0
                                }
                            }, {
                                type: "button",
                                action_id: "actionId-1",
                                url: e.dev,
                                text: {
                                    type: "plain_text",
                                    text: "dev.jackbox.tv",
                                    emoji: !0
                                }
                            }]
                        }]
                    };
                if (this.room) {
                    g.icon_emoji = this.room.appTag;
                    const T = v1(this.room.appTag);
                    g.username = `DebugRecorder ${T?T.name:this.room.appTag}`
                }
                const b = await (await fetch(l, {
                    method: "POST",
                    body: JSON.stringify(g)
                })).text();
                b1("[Debug] sendToSlack", b)
            } catch (l) {
                console.error("[Debug] sendToSlack", l)
            }
        }
        download(e) {
            var a;
            const n = e ?? `${((a=this.room)==null?void 0:a.appTag)??"unknown"}-debug`,
                r = this.getSendData().state,
                s = JSON.stringify(r, null, 4),
                i = document.createElement("a");
            i.setAttribute("href", `data:text/json;charset=utf-8,${encodeURIComponent(s)}`), i.setAttribute("download", `${n}.json`), i.style.display = "none", document.body.appendChild(i), i.click(), document.body.removeChild(i)
        }
        open() {
            var s;
            const e = this.getSendData().state,
                n = JSON.stringify(e, null, 4),
                r = window.open();
            r.document.write(`
            <iframe src="data:text/json;charset=utf-8,${encodeURIComponent(n)}" frameborder="0" style="border:0;
                top:0px; left:0px; bottom:0px; right:0px; width:100%; height:100%;" allowfullscreen>
            </iframe>
        `), r.document.title = `${(s=this.room)==null?void 0:s.appTag} debug JSON`, r.document.close(), r.focus()
        }
        expose() {
            return {
                print: () => this.items,
                reset: () => this.reset(),
                setMarker: e => this.setMarker(e),
                download: e => this.download(e),
                open: () => this.open(),
                send: e => void this.send(e)
            }
        }
    }

    function sK(t) {
        throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
    }
    var TT = {
        exports: {}
    };
    (function(t, e) {
        (function(n, r) {
            r(e)
        })(hn, function(n) {
            var r = typeof window < "u" ? window : typeof hn < "u" ? hn : typeof self < "u" ? self : {},
                s = function($, te) {
                    if (te = te.split(":")[0], $ = +$, !$) return !1;
                    switch (te) {
                        case "http":
                        case "ws":
                            return $ !== 80;
                        case "https":
                        case "wss":
                            return $ !== 443;
                        case "ftp":
                            return $ !== 21;
                        case "gopher":
                            return $ !== 70;
                        case "file":
                            return !1
                    }
                    return $ !== 0
                },
                i = Object.prototype.hasOwnProperty,
                a;

            function c(U) {
                try {
                    return decodeURIComponent(U.replace(/\+/g, " "))
                } catch {
                    return null
                }
            }

            function l(U) {
                try {
                    return encodeURIComponent(U)
                } catch {
                    return null
                }
            }

            function h(U) {
                for (var $ = /([^=?#&]+)=?([^&]*)/g, te = {}, F; F = $.exec(U);) {
                    var Q = c(F[1]),
                        ve = c(F[2]);
                    Q === null || ve === null || Q in te || (te[Q] = ve)
                }
                return te
            }

            function d(U, $) {
                $ = $ || "";
                var te = [],
                    F, Q;
                typeof $ != "string" && ($ = "?");
                for (Q in U)
                    if (i.call(U, Q)) {
                        if (F = U[Q], !F && (F === null || F === a || isNaN(F)) && (F = ""), Q = l(Q), F = l(F), Q === null || F === null) continue;
                        te.push(Q + "=" + F)
                    } return te.length ? $ + te.join("&") : ""
            }
            var p = d,
                g = h,
                v = {
                    stringify: p,
                    parse: g
                },
                b = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//,
                T = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i,
                m = "[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]",
                w = new RegExp("^" + m + "+");

            function P(U) {
                return (U || "").toString().replace(w, "")
            }
            var V = [
                    ["#", "hash"],
                    ["?", "query"],
                    function($, te) {
                        return L(te.protocol) ? $.replace(/\\/g, "/") : $
                    },
                    ["/", "pathname"],
                    ["@", "auth", 1],
                    [NaN, "host", void 0, 1, 1],
                    [/:(\d+)$/, "port", void 0, 1],
                    [NaN, "hostname", void 0, 1, 1]
                ],
                M = {
                    hash: 1,
                    query: 1
                };

            function I(U) {
                var $;
                typeof window < "u" ? $ = window : typeof r < "u" ? $ = r : typeof self < "u" ? $ = self : $ = {};
                var te = $.location || {};
                U = U || te;
                var F = {},
                    Q = typeof U,
                    ve;
                if (U.protocol === "blob:") F = new se(unescape(U.pathname), {});
                else if (Q === "string") {
                    F = new se(U, {});
                    for (ve in M) delete F[ve]
                } else if (Q === "object") {
                    for (ve in U) ve in M || (F[ve] = U[ve]);
                    F.slashes === void 0 && (F.slashes = b.test(U.href))
                }
                return F
            }

            function L(U) {
                return U === "file:" || U === "ftp:" || U === "http:" || U === "https:" || U === "ws:" || U === "wss:"
            }

            function B(U, $) {
                U = P(U), $ = $ || {};
                var te = T.exec(U),
                    F = te[1] ? te[1].toLowerCase() : "",
                    Q = !!te[2],
                    ve = !!te[3],
                    Oe = 0,
                    xe;
                return Q ? ve ? (xe = te[2] + te[3] + te[4], Oe = te[2].length + te[3].length) : (xe = te[2] + te[4], Oe = te[2].length) : ve ? (xe = te[3] + te[4], Oe = te[3].length) : xe = te[4], F === "file:" ? Oe >= 2 && (xe = xe.slice(2)) : L(F) ? xe = te[4] : F ? Q && (xe = xe.slice(2)) : Oe >= 2 && L($.protocol) && (xe = te[4]), {
                    protocol: F,
                    slashes: Q || L(F),
                    slashesCount: Oe,
                    rest: xe
                }
            }

            function q(U, $) {
                if (U === "") return $;
                for (var te = ($ || "/").split("/").slice(0, -1).concat(U.split("/")), F = te.length, Q = te[F - 1], ve = !1, Oe = 0; F--;) te[F] === "." ? te.splice(F, 1) : te[F] === ".." ? (te.splice(F, 1), Oe++) : Oe && (F === 0 && (ve = !0), te.splice(F, 1), Oe--);
                return ve && te.unshift(""), (Q === "." || Q === "..") && te.push(""), te.join("/")
            }

            function se(U, $, te) {
                if (U = P(U), !(this instanceof se)) return new se(U, $, te);
                var F, Q, ve, Oe, xe, Fe, dn = V.slice(),
                    Nr = typeof $,
                    et = this,
                    bu = 0;
                for (Nr !== "object" && Nr !== "string" && (te = $, $ = null), te && typeof te != "function" && (te = v.parse), $ = I($), Q = B(U || "", $), F = !Q.protocol && !Q.slashes, et.slashes = Q.slashes || F && $.slashes, et.protocol = Q.protocol || $.protocol || "", U = Q.rest, (et.protocol === "file:" || !Q.slashes && (Q.protocol || Q.slashesCount < 2 || !L(et.protocol))) && (dn[3] = [/(.*)/, "pathname"]); bu < dn.length; bu++) {
                    if (Oe = dn[bu], typeof Oe == "function") {
                        U = Oe(U, et);
                        continue
                    }
                    ve = Oe[0], Fe = Oe[1], ve !== ve ? et[Fe] = U : typeof ve == "string" ? ~(xe = U.indexOf(ve)) && (typeof Oe[2] == "number" ? (et[Fe] = U.slice(0, xe), U = U.slice(xe + Oe[2])) : (et[Fe] = U.slice(xe), U = U.slice(0, xe))) : (xe = ve.exec(U)) && (et[Fe] = xe[1], U = U.slice(0, xe.index)), et[Fe] = et[Fe] || F && Oe[3] && $[Fe] || "", Oe[4] && (et[Fe] = et[Fe].toLowerCase())
                }
                te && (et.query = te(et.query)), F && $.slashes && et.pathname.charAt(0) !== "/" && (et.pathname !== "" || $.pathname !== "") && (et.pathname = q(et.pathname, $.pathname)), et.pathname.charAt(0) !== "/" && L(et.protocol) && (et.pathname = "/" + et.pathname), s(et.port, et.protocol) || (et.host = et.hostname, et.port = ""), et.username = et.password = "", et.auth && (Oe = et.auth.split(":"), et.username = Oe[0] || "", et.password = Oe[1] || ""), et.origin = et.protocol !== "file:" && L(et.protocol) && et.host ? et.protocol + "//" + et.host : "null", et.href = et.toString()
            }

            function ce(U, $, te) {
                var F = this;
                switch (U) {
                    case "query":
                        typeof $ == "string" && $.length && ($ = (te || v.parse)($)), F[U] = $;
                        break;
                    case "port":
                        F[U] = $, s($, F.protocol) ? $ && (F.host = F.hostname + ":" + $) : (F.host = F.hostname, F[U] = "");
                        break;
                    case "hostname":
                        F[U] = $, F.port && ($ += ":" + F.port), F.host = $;
                        break;
                    case "host":
                        F[U] = $, /:\d+$/.test($) ? ($ = $.split(":"), F.port = $.pop(), F.hostname = $.join(":")) : (F.hostname = $, F.port = "");
                        break;
                    case "protocol":
                        F.protocol = $.toLowerCase(), F.slashes = !te;
                        break;
                    case "pathname":
                    case "hash":
                        if ($) {
                            var Q = U === "pathname" ? "/" : "#";
                            F[U] = $.charAt(0) !== Q ? Q + $ : $
                        } else F[U] = $;
                        break;
                    default:
                        F[U] = $
                }
                for (var ve = 0; ve < V.length; ve++) {
                    var Oe = V[ve];
                    Oe[4] && (F[Oe[1]] = F[Oe[1]].toLowerCase())
                }
                return F.origin = F.protocol !== "file:" && L(F.protocol) && F.host ? F.protocol + "//" + F.host : "null", F.href = F.toString(), F
            }

            function ue(U) {
                (!U || typeof U != "function") && (U = v.stringify);
                var $, te = this,
                    F = te.protocol;
                F && F.charAt(F.length - 1) !== ":" && (F += ":");
                var Q = F + (te.slashes || L(te.protocol) ? "//" : "");
                return te.username && (Q += te.username, te.password && (Q += ":" + te.password), Q += "@"), Q += te.host + te.pathname, $ = typeof te.query == "object" ? U(te.query) : te.query, $ && (Q += $.charAt(0) !== "?" ? "?" + $ : $), te.hash && (Q += te.hash), Q
            }
            se.prototype = {
                set: ce,
                toString: ue
            }, se.extractProtocol = B, se.location = I, se.trimLeft = P, se.qs = v;
            var ee = se;

            function ge(U, $) {
                setTimeout(function(te) {
                    return U.call(te)
                }, 4, $)
            }

            function G(U, $) {
                typeof process < "u" && console[U].call(null, $)
            }

            function le(U, $) {
                U === void 0 && (U = []);
                var te = [];
                return U.forEach(function(F) {
                    $(F) || te.push(F)
                }), te
            }

            function fe(U, $) {
                U === void 0 && (U = []);
                var te = [];
                return U.forEach(function(F) {
                    $(F) && te.push(F)
                }), te
            }
            var me = function() {
                this.listeners = {}
            };
            me.prototype.addEventListener = function($, te) {
                typeof te == "function" && (Array.isArray(this.listeners[$]) || (this.listeners[$] = []), fe(this.listeners[$], function(F) {
                    return F === te
                }).length === 0 && this.listeners[$].push(te))
            }, me.prototype.removeEventListener = function($, te) {
                var F = this.listeners[$];
                this.listeners[$] = le(F, function(Q) {
                    return Q === te
                })
            }, me.prototype.dispatchEvent = function($) {
                for (var te = this, F = [], Q = arguments.length - 1; Q-- > 0;) F[Q] = arguments[Q + 1];
                var ve = $.type,
                    Oe = this.listeners[ve];
                return Array.isArray(Oe) ? (Oe.forEach(function(xe) {
                    F.length > 0 ? xe.apply(te, F) : xe.call(te, $)
                }), !0) : !1
            };

            function Te(U) {
                var $ = U.indexOf("?");
                return $ >= 0 ? U.slice(0, $) : U
            }
            var we = function() {
                this.urlMap = {}
            };
            we.prototype.attachWebSocket = function($, te) {
                var F = Te(te),
                    Q = this.urlMap[F];
                if (Q && Q.server && Q.websockets.indexOf($) === -1) return Q.websockets.push($), Q.server
            }, we.prototype.addMembershipToRoom = function($, te) {
                var F = this.urlMap[Te($.url)];
                F && F.server && F.websockets.indexOf($) !== -1 && (F.roomMemberships[te] || (F.roomMemberships[te] = []), F.roomMemberships[te].push($))
            }, we.prototype.attachServer = function($, te) {
                var F = Te(te),
                    Q = this.urlMap[F];
                if (!Q) return this.urlMap[F] = {
                    server: $,
                    websockets: [],
                    roomMemberships: {}
                }, $
            }, we.prototype.serverLookup = function($) {
                var te = Te($),
                    F = this.urlMap[te];
                if (F) return F.server
            }, we.prototype.websocketsLookup = function($, te, F) {
                var Q = Te($),
                    ve, Oe = this.urlMap[Q];
                if (ve = Oe ? Oe.websockets : [], te) {
                    var xe = Oe.roomMemberships[te];
                    ve = xe || []
                }
                return F ? ve.filter(function(Fe) {
                    return Fe !== F
                }) : ve
            }, we.prototype.removeServer = function($) {
                delete this.urlMap[Te($)]
            }, we.prototype.removeWebSocket = function($, te) {
                var F = Te(te),
                    Q = this.urlMap[F];
                Q && (Q.websockets = le(Q.websockets, function(ve) {
                    return ve === $
                }))
            }, we.prototype.removeMembershipFromRoom = function($, te) {
                var F = this.urlMap[Te($.url)],
                    Q = F.roomMemberships[te];
                F && Q !== null && (F.roomMemberships[te] = le(Q, function(ve) {
                    return ve === $
                }))
            };
            var ke = new we,
                Ie = {
                    CLOSE_NORMAL: 1e3,
                    CLOSE_GOING_AWAY: 1001,
                    CLOSE_PROTOCOL_ERROR: 1002,
                    CLOSE_UNSUPPORTED: 1003,
                    CLOSE_NO_STATUS: 1005,
                    CLOSE_ABNORMAL: 1006,
                    UNSUPPORTED_DATA: 1007,
                    POLICY_VIOLATION: 1008,
                    CLOSE_TOO_LARGE: 1009,
                    MISSING_EXTENSION: 1010,
                    INTERNAL_ERROR: 1011,
                    SERVICE_RESTART: 1012,
                    TRY_AGAIN_LATER: 1013,
                    TLS_HANDSHAKE: 1015
                },
                $e = {
                    CONSTRUCTOR_ERROR: "Failed to construct 'WebSocket':",
                    CLOSE_ERROR: "Failed to execute 'close' on 'WebSocket':",
                    EVENT: {
                        CONSTRUCT: "Failed to construct 'Event':",
                        MESSAGE: "Failed to construct 'MessageEvent':",
                        CLOSE: "Failed to construct 'CloseEvent':"
                    }
                },
                At = function() {};
            At.prototype.stopPropagation = function() {}, At.prototype.stopImmediatePropagation = function() {}, At.prototype.initEvent = function($, te, F) {
                $ === void 0 && ($ = "undefined"), te === void 0 && (te = !1), F === void 0 && (F = !1), this.type = "" + $, this.bubbles = !!te, this.cancelable = !!F
            };
            var $t = function(U) {
                    function $(te, F) {
                        if (F === void 0 && (F = {}), U.call(this), !te) throw new TypeError($e.EVENT_ERROR + " 1 argument required, but only 0 present.");
                        if (typeof F != "object") throw new TypeError($e.EVENT_ERROR + " parameter 2 ('eventInitDict') is not an object.");
                        var Q = F.bubbles,
                            ve = F.cancelable;
                        this.type = "" + te, this.timeStamp = Date.now(), this.target = null, this.srcElement = null, this.returnValue = !0, this.isTrusted = !1, this.eventPhase = 0, this.defaultPrevented = !1, this.currentTarget = null, this.cancelable = ve ? !!ve : !1, this.cancelBubble = !1, this.bubbles = Q ? !!Q : !1
                    }
                    return U && ($.__proto__ = U), $.prototype = Object.create(U && U.prototype), $.prototype.constructor = $, $
                }(At),
                qe = function(U) {
                    function $(te, F) {
                        if (F === void 0 && (F = {}), U.call(this), !te) throw new TypeError($e.EVENT.MESSAGE + " 1 argument required, but only 0 present.");
                        if (typeof F != "object") throw new TypeError($e.EVENT.MESSAGE + " parameter 2 ('eventInitDict') is not an object");
                        var Q = F.bubbles,
                            ve = F.cancelable,
                            Oe = F.data,
                            xe = F.origin,
                            Fe = F.lastEventId,
                            dn = F.ports;
                        this.type = "" + te, this.timeStamp = Date.now(), this.target = null, this.srcElement = null, this.returnValue = !0, this.isTrusted = !1, this.eventPhase = 0, this.defaultPrevented = !1, this.currentTarget = null, this.cancelable = ve ? !!ve : !1, this.canncelBubble = !1, this.bubbles = Q ? !!Q : !1, this.origin = "" + xe, this.ports = typeof dn > "u" ? null : dn, this.data = typeof Oe > "u" ? null : Oe, this.lastEventId = "" + (Fe || "")
                    }
                    return U && ($.__proto__ = U), $.prototype = Object.create(U && U.prototype), $.prototype.constructor = $, $
                }(At),
                Xe = function(U) {
                    function $(te, F) {
                        if (F === void 0 && (F = {}), U.call(this), !te) throw new TypeError($e.EVENT.CLOSE + " 1 argument required, but only 0 present.");
                        if (typeof F != "object") throw new TypeError($e.EVENT.CLOSE + " parameter 2 ('eventInitDict') is not an object");
                        var Q = F.bubbles,
                            ve = F.cancelable,
                            Oe = F.code,
                            xe = F.reason,
                            Fe = F.wasClean;
                        this.type = "" + te, this.timeStamp = Date.now(), this.target = null, this.srcElement = null, this.returnValue = !0, this.isTrusted = !1, this.eventPhase = 0, this.defaultPrevented = !1, this.currentTarget = null, this.cancelable = ve ? !!ve : !1, this.cancelBubble = !1, this.bubbles = Q ? !!Q : !1, this.code = typeof Oe == "number" ? parseInt(Oe, 10) : 0, this.reason = "" + (xe || ""), this.wasClean = Fe ? !!Fe : !1
                    }
                    return U && ($.__proto__ = U), $.prototype = Object.create(U && U.prototype), $.prototype.constructor = $, $
                }(At);

            function tt(U) {
                var $ = U.type,
                    te = U.target,
                    F = new $t($);
                return te && (F.target = te, F.srcElement = te, F.currentTarget = te), F
            }

            function S(U) {
                var $ = U.type,
                    te = U.origin,
                    F = U.data,
                    Q = U.target,
                    ve = new qe($, {
                        data: F,
                        origin: te
                    });
                return Q && (ve.target = Q, ve.srcElement = Q, ve.currentTarget = Q), ve
            }

            function k(U) {
                var $ = U.code,
                    te = U.reason,
                    F = U.type,
                    Q = U.target,
                    ve = U.wasClean;
                ve || (ve = $ === Ie.CLOSE_NORMAL || $ === Ie.CLOSE_NO_STATUS);
                var Oe = new Xe(F, {
                    code: $,
                    reason: te,
                    wasClean: ve
                });
                return Q && (Oe.target = Q, Oe.srcElement = Q, Oe.currentTarget = Q), Oe
            }

            function H(U, $, te) {
                U.readyState = oe.CLOSING;
                var F = ke.serverLookup(U.url),
                    Q = k({
                        type: "close",
                        target: U.target,
                        code: $,
                        reason: te
                    }),
                    ve = k({
                        type: "server::close",
                        target: U,
                        code: $,
                        reason: te
                    });
                ge(function() {
                    ke.removeWebSocket(U, U.url), U.readyState = oe.CLOSED, U.dispatchEvent(Q), U.dispatchEvent(ve), F && F.dispatchEvent(Q, F)
                }, U)
            }

            function K(U, $, te) {
                U.readyState = oe.CLOSING;
                var F = ke.serverLookup(U.url),
                    Q = k({
                        type: "close",
                        target: U.target,
                        code: $,
                        reason: te,
                        wasClean: !1
                    }),
                    ve = k({
                        type: "server::close",
                        target: U,
                        code: $,
                        reason: te,
                        wasClean: !1
                    }),
                    Oe = tt({
                        type: "error",
                        target: U.target
                    });
                ge(function() {
                    ke.removeWebSocket(U, U.url), U.readyState = oe.CLOSED, U.dispatchEvent(Oe), U.dispatchEvent(Q), U.dispatchEvent(ve), F && F.dispatchEvent(Q, F)
                }, U)
            }

            function A(U) {
                return Object.prototype.toString.call(U) !== "[object Blob]" && !(U instanceof ArrayBuffer) && (U = String(U)), U
            }
            var y = new WeakMap;

            function E(U) {
                if (y.has(U)) return y.get(U);
                var $ = new Proxy(U, {
                    get: function(F, Q) {
                        return Q === "close" ? function(Oe) {
                            Oe === void 0 && (Oe = {});
                            var xe = Oe.code || Ie.CLOSE_NORMAL,
                                Fe = Oe.reason || "";
                            H($, xe, Fe)
                        } : Q === "send" ? function(Oe) {
                            Oe = A(Oe), U.dispatchEvent(S({
                                type: "message",
                                data: Oe,
                                origin: this.url,
                                target: U
                            }))
                        } : Q === "on" ? function(Oe, xe) {
                            U.addEventListener("server::" + Oe, xe)
                        } : Q === "target" ? U : F[Q]
                    }
                });
                return y.set(U, $), $
            }

            function C(U) {
                var $ = encodeURIComponent(U).match(/%[89ABab]/g);
                return U.length + ($ ? $.length : 0)
            }

            function D(U) {
                var $ = new ee(U),
                    te = $.pathname,
                    F = $.protocol,
                    Q = $.hash;
                if (!U) throw new TypeError($e.CONSTRUCTOR_ERROR + " 1 argument required, but only 0 present.");
                if (te || ($.pathname = "/"), F === "") throw new SyntaxError($e.CONSTRUCTOR_ERROR + " The URL '" + $.toString() + "' is invalid.");
                if (F !== "ws:" && F !== "wss:") throw new SyntaxError($e.CONSTRUCTOR_ERROR + " The URL's scheme must be either 'ws' or 'wss'. '" + F + "' is not allowed.");
                if (Q !== "") throw new SyntaxError($e.CONSTRUCTOR_ERROR + " The URL contains a fragment identifier ('" + Q + "'). Fragment identifiers are not allowed in WebSocket URLs.");
                return $.toString()
            }

            function Z(U) {
                if (U === void 0 && (U = []), !Array.isArray(U) && typeof U != "string") throw new SyntaxError($e.CONSTRUCTOR_ERROR + " The subprotocol '" + U.toString() + "' is invalid.");
                typeof U == "string" && (U = [U]);
                var $ = U.map(function(F) {
                        return {
                            count: 1,
                            protocol: F
                        }
                    }).reduce(function(F, Q) {
                        return F[Q.protocol] = (F[Q.protocol] || 0) + Q.count, F
                    }, {}),
                    te = Object.keys($).filter(function(F) {
                        return $[F] > 1
                    });
                if (te.length > 0) throw new SyntaxError($e.CONSTRUCTOR_ERROR + " The subprotocol '" + te[0] + "' is duplicated.");
                return U
            }
            var oe = function(U) {
                function $(F, Q) {
                    U.call(this), this._onopen = null, this._onmessage = null, this._onerror = null, this._onclose = null, this.url = D(F), Q = Z(Q), this.protocol = Q[0] || "", this.binaryType = "blob", this.readyState = $.CONNECTING;
                    var ve = E(this),
                        Oe = ke.attachWebSocket(ve, this.url);
                    ge(function() {
                        if (Oe)
                            if (Oe.options.verifyClient && typeof Oe.options.verifyClient == "function" && !Oe.options.verifyClient()) this.readyState = $.CLOSED, G("error", "WebSocket connection to '" + this.url + "' failed: HTTP Authentication failed; no valid credentials available"), ke.removeWebSocket(ve, this.url), this.dispatchEvent(tt({
                                type: "error",
                                target: this
                            })), this.dispatchEvent(k({
                                type: "close",
                                target: this,
                                code: Ie.CLOSE_NORMAL
                            }));
                            else {
                                if (Oe.options.selectProtocol && typeof Oe.options.selectProtocol == "function") {
                                    var Fe = Oe.options.selectProtocol(Q),
                                        dn = Fe !== "",
                                        Nr = Q.indexOf(Fe) !== -1;
                                    if (dn && !Nr) {
                                        this.readyState = $.CLOSED, G("error", "WebSocket connection to '" + this.url + "' failed: Invalid Sub-Protocol"), ke.removeWebSocket(ve, this.url), this.dispatchEvent(tt({
                                            type: "error",
                                            target: this
                                        })), this.dispatchEvent(k({
                                            type: "close",
                                            target: this,
                                            code: Ie.CLOSE_NORMAL
                                        }));
                                        return
                                    }
                                    this.protocol = Fe
                                }
                                this.readyState = $.OPEN, this.dispatchEvent(tt({
                                    type: "open",
                                    target: this
                                })), Oe.dispatchEvent(tt({
                                    type: "connection"
                                }), ve)
                            }
                        else this.readyState = $.CLOSED, this.dispatchEvent(tt({
                            type: "error",
                            target: this
                        })), this.dispatchEvent(k({
                            type: "close",
                            target: this,
                            code: Ie.CLOSE_NORMAL
                        })), G("error", "WebSocket connection to '" + this.url + "' failed")
                    }, this)
                }
                U && ($.__proto__ = U), $.prototype = Object.create(U && U.prototype), $.prototype.constructor = $;
                var te = {
                    onopen: {},
                    onmessage: {},
                    onclose: {},
                    onerror: {}
                };
                return te.onopen.get = function() {
                    return this._onopen
                }, te.onmessage.get = function() {
                    return this._onmessage
                }, te.onclose.get = function() {
                    return this._onclose
                }, te.onerror.get = function() {
                    return this._onerror
                }, te.onopen.set = function(F) {
                    this.removeEventListener("open", this._onopen), this._onopen = F, this.addEventListener("open", F)
                }, te.onmessage.set = function(F) {
                    this.removeEventListener("message", this._onmessage), this._onmessage = F, this.addEventListener("message", F)
                }, te.onclose.set = function(F) {
                    this.removeEventListener("close", this._onclose), this._onclose = F, this.addEventListener("close", F)
                }, te.onerror.set = function(F) {
                    this.removeEventListener("error", this._onerror), this._onerror = F, this.addEventListener("error", F)
                }, $.prototype.send = function(Q) {
                    var ve = this;
                    if (this.readyState === $.CLOSING || this.readyState === $.CLOSED) throw new Error("WebSocket is already in CLOSING or CLOSED state");
                    var Oe = S({
                            type: "server::message",
                            origin: this.url,
                            data: A(Q)
                        }),
                        xe = ke.serverLookup(this.url);
                    xe && ge(function() {
                        ve.dispatchEvent(Oe, Q)
                    }, xe)
                }, $.prototype.close = function(Q, ve) {
                    if (Q !== void 0 && (typeof Q != "number" || Q !== 1e3 && (Q < 3e3 || Q > 4999))) throw new TypeError($e.CLOSE_ERROR + " The code must be either 1000, or between 3000 and 4999. " + Q + " is neither.");
                    if (ve !== void 0) {
                        var Oe = C(ve);
                        if (Oe > 123) throw new SyntaxError($e.CLOSE_ERROR + " The message must not be greater than 123 bytes.")
                    }
                    if (!(this.readyState === $.CLOSING || this.readyState === $.CLOSED)) {
                        var xe = E(this);
                        this.readyState === $.CONNECTING ? K(xe, Q || Ie.CLOSE_ABNORMAL, ve) : H(xe, Q || Ie.CLOSE_NO_STATUS, ve)
                    }
                }, Object.defineProperties($.prototype, te), $
            }(me);
            oe.CONNECTING = 0, oe.prototype.CONNECTING = oe.CONNECTING, oe.OPEN = 1, oe.prototype.OPEN = oe.OPEN, oe.CLOSING = 2, oe.prototype.CLOSING = oe.CLOSING, oe.CLOSED = 3, oe.prototype.CLOSED = oe.CLOSED;
            var pe = function(U) {
                return U.reduce(function($, te) {
                    return $.indexOf(te) > -1 ? $ : $.concat(te)
                }, [])
            };

            function _e() {
                return typeof window < "u" ? window : typeof process == "object" && typeof sK == "function" && typeof hn == "object" ? hn : this
            }
            var he = {
                    mock: !0,
                    verifyClient: null,
                    selectProtocol: null
                },
                re = function(U) {
                    function $(te, F) {
                        F === void 0 && (F = he), U.call(this);
                        var Q = new ee(te);
                        Q.pathname || (Q.pathname = "/"), this.url = Q.toString(), this.originalWebSocket = null;
                        var ve = ke.attachServer(this, this.url);
                        if (!ve) throw this.dispatchEvent(tt({
                            type: "error"
                        })), new Error("A mock server is already listening on this url");
                        this.options = Object.assign({}, he, F), this.options.mock && this.mockWebsocket()
                    }
                    return U && ($.__proto__ = U), $.prototype = Object.create(U && U.prototype), $.prototype.constructor = $, $.prototype.mockWebsocket = function() {
                        var F = _e();
                        this.originalWebSocket = F.WebSocket, F.WebSocket = oe
                    }, $.prototype.restoreWebsocket = function() {
                        var F = _e();
                        this.originalWebSocket !== null && (F.WebSocket = this.originalWebSocket), this.originalWebSocket = null
                    }, $.prototype.stop = function(F) {
                        F === void 0 && (F = function() {}), this.options.mock && this.restoreWebsocket(), ke.removeServer(this.url), typeof F == "function" && F()
                    }, $.prototype.on = function(F, Q) {
                        this.addEventListener(F, Q)
                    }, $.prototype.close = function(F) {
                        F === void 0 && (F = {});
                        var Q = F.code,
                            ve = F.reason,
                            Oe = F.wasClean,
                            xe = ke.websocketsLookup(this.url);
                        ke.removeServer(this.url), xe.forEach(function(Fe) {
                            Fe.readyState = oe.CLOSED, Fe.dispatchEvent(k({
                                type: "close",
                                target: Fe.target,
                                code: Q || Ie.CLOSE_NORMAL,
                                reason: ve || "",
                                wasClean: Oe
                            }))
                        }), this.dispatchEvent(k({
                            type: "close"
                        }), this)
                    }, $.prototype.emit = function(F, Q, ve) {
                        var Oe = this;
                        ve === void 0 && (ve = {});
                        var xe = ve.websockets;
                        xe || (xe = ke.websocketsLookup(this.url)), typeof ve != "object" || arguments.length > 3 ? (Q = Array.prototype.slice.call(arguments, 1, arguments.length), Q = Q.map(function(Fe) {
                            return A(Fe)
                        })) : Q = A(Q), xe.forEach(function(Fe) {
                            Array.isArray(Q) ? Fe.dispatchEvent.apply(Fe, [S({
                                type: F,
                                data: Q,
                                origin: Oe.url,
                                target: Fe.target
                            })].concat(Q)) : Fe.dispatchEvent(S({
                                type: F,
                                data: Q,
                                origin: Oe.url,
                                target: Fe.target
                            }))
                        })
                    }, $.prototype.clients = function() {
                        return ke.websocketsLookup(this.url)
                    }, $.prototype.to = function(F, Q, ve) {
                        var Oe = this;
                        ve === void 0 && (ve = []);
                        var xe = this,
                            Fe = pe(ve.concat(ke.websocketsLookup(this.url, F, Q)));
                        return {
                            to: function(dn, Nr) {
                                return Oe.to.call(Oe, dn, Nr, Fe)
                            },
                            emit: function(Nr, et) {
                                xe.emit(Nr, et, {
                                    websockets: Fe
                                })
                            }
                        }
                    }, $.prototype.in = function() {
                        for (var F = [], Q = arguments.length; Q--;) F[Q] = arguments[Q];
                        return this.to.apply(null, F)
                    }, $.prototype.simulate = function(F) {
                        var Q = ke.websocketsLookup(this.url);
                        F === "error" && Q.forEach(function(ve) {
                            ve.readyState = oe.CLOSED, ve.dispatchEvent(tt({
                                type: "error"
                            }))
                        })
                    }, $
                }(me);
            re.of = function($) {
                return new re($)
            };
            var ae = function(U) {
                function $(F, Q) {
                    var ve = this;
                    F === void 0 && (F = "socket.io"), Q === void 0 && (Q = ""), U.call(this), this.binaryType = "blob";
                    var Oe = new ee(F);
                    Oe.pathname || (Oe.pathname = "/"), this.url = Oe.toString(), this.readyState = $.CONNECTING, this.protocol = "", this.target = this, typeof Q == "string" || typeof Q == "object" && Q !== null ? this.protocol = Q : Array.isArray(Q) && Q.length > 0 && (this.protocol = Q[0]);
                    var xe = ke.attachWebSocket(this, this.url);
                    ge(function() {
                        xe ? (this.readyState = $.OPEN, xe.dispatchEvent(tt({
                            type: "connection"
                        }), xe, this), xe.dispatchEvent(tt({
                            type: "connect"
                        }), xe, this), this.dispatchEvent(tt({
                            type: "connect",
                            target: this
                        }))) : (this.readyState = $.CLOSED, this.dispatchEvent(tt({
                            type: "error",
                            target: this
                        })), this.dispatchEvent(k({
                            type: "close",
                            target: this,
                            code: Ie.CLOSE_NORMAL
                        })), G("error", "Socket.io connection to '" + this.url + "' failed"))
                    }, this), this.addEventListener("close", function(Fe) {
                        ve.dispatchEvent(k({
                            type: "disconnect",
                            target: Fe.target,
                            code: Fe.code
                        }))
                    })
                }
                U && ($.__proto__ = U), $.prototype = Object.create(U && U.prototype), $.prototype.constructor = $;
                var te = {
                    broadcast: {}
                };
                return $.prototype.close = function() {
                    if (this.readyState === $.OPEN) {
                        var Q = ke.serverLookup(this.url);
                        return ke.removeWebSocket(this, this.url), this.readyState = $.CLOSED, this.dispatchEvent(k({
                            type: "close",
                            target: this,
                            code: Ie.CLOSE_NORMAL
                        })), Q && Q.dispatchEvent(k({
                            type: "disconnect",
                            target: this,
                            code: Ie.CLOSE_NORMAL
                        }), Q), this
                    }
                }, $.prototype.disconnect = function() {
                    return this.close()
                }, $.prototype.emit = function(Q) {
                    for (var ve = [], Oe = arguments.length - 1; Oe-- > 0;) ve[Oe] = arguments[Oe + 1];
                    if (this.readyState !== $.OPEN) throw new Error("SocketIO is already in CLOSING or CLOSED state");
                    var xe = S({
                            type: Q,
                            origin: this.url,
                            data: ve
                        }),
                        Fe = ke.serverLookup(this.url);
                    return Fe && Fe.dispatchEvent.apply(Fe, [xe].concat(ve)), this
                }, $.prototype.send = function(Q) {
                    return this.emit("message", Q), this
                }, te.broadcast.get = function() {
                    if (this.readyState !== $.OPEN) throw new Error("SocketIO is already in CLOSING or CLOSED state");
                    var F = this,
                        Q = ke.serverLookup(this.url);
                    if (!Q) throw new Error("SocketIO can not find a server at the specified URL (" + this.url + ")");
                    return {
                        emit: function(Oe, xe) {
                            return Q.emit(Oe, xe, {
                                websockets: ke.websocketsLookup(F.url, null, F)
                            }), F
                        },
                        to: function(Oe) {
                            return Q.to(Oe, F)
                        },
                        in: function(Oe) {
                            return Q.in(Oe, F)
                        }
                    }
                }, $.prototype.on = function(Q, ve) {
                    return this.addEventListener(Q, ve), this
                }, $.prototype.off = function(Q, ve) {
                    this.removeEventListener(Q, ve)
                }, $.prototype.hasListeners = function(Q) {
                    var ve = this.listeners[Q];
                    return Array.isArray(ve) ? !!ve.length : !1
                }, $.prototype.join = function(Q) {
                    ke.addMembershipToRoom(this, Q)
                }, $.prototype.leave = function(Q) {
                    ke.removeMembershipFromRoom(this, Q)
                }, $.prototype.to = function(Q) {
                    return this.broadcast.to(Q)
                }, $.prototype.in = function() {
                    return this.to.apply(null, arguments)
                }, $.prototype.dispatchEvent = function(Q) {
                    for (var ve = this, Oe = [], xe = arguments.length - 1; xe-- > 0;) Oe[xe] = arguments[xe + 1];
                    var Fe = Q.type,
                        dn = this.listeners[Fe];
                    if (!Array.isArray(dn)) return !1;
                    dn.forEach(function(Nr) {
                        Oe.length > 0 ? Nr.apply(ve, Oe) : Nr.call(ve, Q.data ? Q.data : Q)
                    })
                }, Object.defineProperties($.prototype, te), $
            }(me);
            ae.CONNECTING = 0, ae.OPEN = 1, ae.CLOSING = 2, ae.CLOSED = 3;
            var Re = function($, te) {
                return new ae($, te)
            };
            Re.connect = function($, te) {
                return Re($, te)
            };
            var De = re,
                Je = oe,
                dt = Re;
            n.Server = De, n.WebSocket = Je, n.SocketIO = dt, Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    })(TT, TT.exports);
    var iK = {
        exports: {}
    };
    (function(t) {
        (function() {
            function e(c, l) {
                var h = c.x - l.x,
                    d = c.y - l.y;
                return h * h + d * d
            }

            function n(c, l, h) {
                var d = l.x,
                    p = l.y,
                    g = h.x - d,
                    v = h.y - p;
                if (g !== 0 || v !== 0) {
                    var b = ((c.x - d) * g + (c.y - p) * v) / (g * g + v * v);
                    b > 1 ? (d = h.x, p = h.y) : b > 0 && (d += g * b, p += v * b)
                }
                return g = c.x - d, v = c.y - p, g * g + v * v
            }

            function r(c, l) {
                for (var h = c[0], d = [h], p, g = 1, v = c.length; g < v; g++) p = c[g], e(p, h) > l && (d.push(p), h = p);
                return h !== p && d.push(p), d
            }

            function s(c, l, h, d, p) {
                for (var g = d, v, b = l + 1; b < h; b++) {
                    var T = n(c[b], c[l], c[h]);
                    T > g && (v = b, g = T)
                }
                g > d && (v - l > 1 && s(c, l, v, d, p), p.push(c[v]), h - v > 1 && s(c, v, h, d, p))
            }

            function i(c, l) {
                var h = c.length - 1,
                    d = [c[0]];
                return s(c, 0, h, l, d), d.push(c[h]), d
            }

            function a(c, l, h) {
                if (c.length <= 2) return c;
                var d = l !== void 0 ? l * l : 1;
                return c = h ? c : r(c, d), c = i(c, d), c
            }
            t.exports = a, t.exports.default = a
        })()
    })(iK);
    class wT {
        static getPromptGuess(e, n) {
            var r, s, i;
            if ((r = e.player) != null && r.prompt) return e.player.prompt;
            if ((s = e.audience) != null && s.prompt) return e.audience.prompt;
            if ((i = e.audiencePlayer) != null && i.prompt) return e.audiencePlayer.prompt;
            if (e.prompt) return e.prompt;
            if (n === "range-game") return this.getRangeGameGuess(e)
        }
        static getRangeGameGuess(e) {
            var n, r, s, i, a, c, l, h;
            if ((r = (n = e.player) == null ? void 0 : n.content) != null && r.text) return (i = (s = e.player) == null ? void 0 : s.content) == null ? void 0 : i.text;
            if ((c = (a = e.content) == null ? void 0 : a.content) != null && c.text) return (h = (l = e.content) == null ? void 0 : l.content) == null ? void 0 : h.text
        }
        static async send(e) {
            const n = {
                appTag: e.room.appTag,
                state: {
                    appTag: e.room.appTag,
                    name: e.name,
                    role: e.role,
                    code: e.room.code,
                    message: e.message,
                    vibe: e.vibe,
                    state: e.values
                }
            };
            try {
                const r = await this.sendToEcast(n);
                await this.sendToSlack(r, e)
            } catch (r) {
                console.error(r)
            }
        }
        static async sendToEcast(e) {
            return (await (await fetch("https://ecast.jackboxgames.com/api/v2/controller/state", {
                method: "POST",
                body: JSON.stringify(e)
            })).json()).body.url
        }
        static async sendToSlack(e, n) {
            const r = v1(n.room.appTag),
                s = "https://hooks.slack.com/services/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",
                i = {
                    good: ":large_green_circle:",
                    meh: ":large_yellow_circle:",
                    bad: ":red_circle:"
                },
                c = `${(r==null?void 0:r.name)??n.room.appTag} :${n.room.appTag}: 

 From: ${n.name},
${n.message}`,
                l = [];
            n.vibe && n.vibe !== "none" && l.push({
                type: "plain_text",
                text: `${i[n.vibe]} ${n.vibe.toUpperCase()} Vibes`,
                emoji: !0
            }), n.content && l.push({
                type: "plain_text",
                text: `Content: ${n.content}`,
                emoji: !0
            });
            const d = {
                blocks: [{
                    type: "section",
                    text: {
                        type: "mrkdwn",
                        text: c
                    }
                }, {
                    type: "context",
                    elements: l
                }, {
                    type: "actions",
                    elements: [{
                        type: "button",
                        action_id: "actionId-0",
                        url: e,
                        text: {
                            type: "plain_text",
                            text: "View Game State JSON",
                            emoji: !0
                        }
                    }]
                }]
            };
            try {
                const g = await (await fetch(s, {
                    method: "POST",
                    body: JSON.stringify(d)
                })).text();
                b1("[Feedback] sendToSlack", g)
            } catch (p) {
                console.error("[Feedback] sendToSlack", p)
            }
        }
    }
    const fc = class fc {
        constructor(e, n) {
            Ce(this, "activePointers", new Map);
            Ce(this, "element");
            Ce(this, "documentElement");
            Ce(this, "usePointerEvents");
            Ce(this, "isCanceled", !1);
            Ce(this, "cachedElementRect");
            Ce(this, "cachedDocumentRect");
            Ce(this, "cachedTranslations");
            Ce(this, "isMultitouch");
            Ce(this, "isRestrictedToBox");
            Ce(this, "swipeVelocity");
            Ce(this, "swipeDistance");
            Ce(this, "boundOnClick", this.onClick.bind(this));
            Ce(this, "boundOnStart", this.onStart.bind(this));
            Ce(this, "boundOnMove", this.onMove.bind(this));
            Ce(this, "boundOnEnd", this.onEnd.bind(this));
            this.applyPolyfill(), this.element = e, this.documentElement = document.documentElement, this.usePointerEvents = window.PointerEvent !== void 0, this.isRestrictedToBox = n.restrictToBox, this.isMultitouch = n.isMultitouch ?? !1, this.swipeDistance = n.swipeDistance ?? 30, this.swipeVelocity = n.swipeVelocity ?? .5, this.bindStaticEvents()
        }
        destroy() {
            this.unbindStaticEvents(), this.unbindStartedEvents()
        }
        cancel() {
            this.isCanceled = !0, this.unbindStartedEvents()
        }
        isPointerEvent(e) {
            return window.PointerEvent === void 0 ? !1 : e instanceof PointerEvent
        }
        isTouchEvent(e) {
            return "ontouchstart" in window ? e instanceof TouchEvent : !1
        }
        isMouseEvent(e) {
            return e instanceof MouseEvent
        }
        getTouchById(e, n) {
            return Array.from(e).find(r => r.identifier === n)
        }
        bindStaticEvents() {
            if (this.element.addEventListener("click", this.boundOnClick), this.usePointerEvents) {
                this.element.addEventListener("pointerdown", this.boundOnStart);
                return
            }
            this.element.addEventListener("touchstart", this.boundOnStart), this.element.addEventListener("mousedown", this.boundOnStart)
        }
        unbindStaticEvents() {
            if (this.element.removeEventListener("click", this.boundOnClick), this.usePointerEvents) {
                this.element.removeEventListener("pointerdown", this.boundOnStart);
                return
            }
            this.element.removeEventListener("touchstart", this.boundOnStart), this.element.removeEventListener("mousedown", this.boundOnStart)
        }
        bindStartedEvents() {
            if (this.usePointerEvents) {
                this.element.addEventListener("pointermove", this.boundOnMove), this.element.addEventListener("pointerup", this.boundOnEnd), this.isRestrictedToBox && this.element.addEventListener("pointerleave", this.boundOnEnd), this.element.addEventListener("lostpointercapture", this.boundOnEnd), this.disableChildPointerEvents();
                return
            }
            this.element.addEventListener("touchmove", this.boundOnMove), this.element.addEventListener("mousemove", this.boundOnMove), this.element.addEventListener("touchend", this.boundOnEnd), this.element.addEventListener("mouseleave", this.boundOnEnd), this.element.addEventListener("mouseup", this.boundOnEnd)
        }
        unbindStartedEvents() {
            if (this.usePointerEvents) {
                this.element.removeEventListener("pointermove", this.boundOnMove), this.element.removeEventListener("pointerup", this.boundOnEnd), this.isRestrictedToBox && this.element.removeEventListener("pointerleave", this.boundOnEnd), this.element.removeEventListener("lostpointercapture", this.boundOnEnd), this.enableChildPointerEvents();
                return
            }
            this.element.removeEventListener("touchmove", this.boundOnMove), this.element.removeEventListener("mousemove", this.boundOnMove), this.element.removeEventListener("touchend", this.boundOnEnd), this.element.removeEventListener("mouseleave", this.boundOnEnd), this.element.removeEventListener("mouseup", this.boundOnEnd)
        }
        onClick(e) {
            const n = this.getStartDetail(e, {
                    id: 0,
                    type: "click"
                }),
                r = new CustomEvent("pointerbox:click", {
                    detail: n
                });
            this.element.dispatchEvent(r)
        }
        onStart(e) {
            if (e.preventDefault(), this.isCanceled = !1, !this.isMultitouch && this.activePointers.size) return !1;
            if (this.isPointerEvent(e)) return this.processStartEvent(e, {
                id: e.pointerId,
                type: e.pointerType
            }), !1;
            if (this.isTouchEvent(e)) {
                for (let n = 0; n < e.targetTouches.length; n++) {
                    const r = e.targetTouches.item(n);
                    this.processStartEvent(e, {
                        id: r.identifier,
                        type: "touch"
                    }, r)
                }
                return !1
            }
            return this.processStartEvent(e, {
                id: 0,
                type: "mouse"
            }), !1
        }
        processStartEvent(e, n, r) {
            if (this.activePointers.get(n.id)) return;
            const s = this.getStartDetail(e, n, r),
                i = {
                    id: n.id,
                    type: n.type,
                    distanceAccumulator: 0,
                    velocityValues: [0],
                    children: document.elementsFromPoint(s.clientX, s.clientY),
                    previousEventTimestamp: Date.now(),
                    initial: s,
                    previous: s
                };
            this.activePointers.set(n.id, i);
            const a = new CustomEvent("pointerbox:start", {
                detail: s
            });
            this.element.dispatchEvent(a);
            const c = new CustomEvent("pointerbox:childdown", {
                detail: s
            });
            i.children.forEach(l => l.dispatchEvent(c)), this.bindStartedEvents()
        }
        onMove(e) {
            if (e.preventDefault(), !this.isCanceled) {
                if (this.isPointerEvent(e)) return this.processMoveEvent(e, {
                    id: e.pointerId,
                    type: e.pointerType
                }), !1;
                if (this.isTouchEvent(e)) {
                    for (let n = 0; n < e.changedTouches.length; n++) {
                        const r = e.targetTouches.item(n);
                        this.processMoveEvent(e, {
                            id: r.identifier,
                            type: "touch"
                        }, r)
                    }
                    return !1
                }
                return this.processMoveEvent(e, {
                    id: 0,
                    type: "mouse"
                }), !1
            }
        }
        processMoveEvent(e, n, r) {
            const s = this.activePointers.get(n.id);
            if (!s) return !1;
            const i = this.getMoveDetail(e, s, r);
            s.previous = i, s.previousEventTimestamp = Date.now();
            const a = new CustomEvent("pointerbox:move", {
                detail: i
            });
            return this.element.dispatchEvent(a), !1
        }
        onEnd(e) {
            if (e.preventDefault(), !this.isCanceled) return this.isPointerEvent(e) ? (this.processEndEvent(e, {
                id: e.pointerId,
                type: e.pointerType
            }), !1) : this.isTouchEvent(e) ? (this.activePointers.forEach((n, r) => {
                if (this.getTouchById(e.touches, r)) return;
                const s = this.getTouchById(n.previous.originalEvent.touches, r);
                if (!s) throw new Error("[PointerBox] No previous details stored");
                this.processEndEvent(e, {
                    id: r,
                    type: n.type
                }, s)
            }), !1) : (this.processEndEvent(e, {
                id: 0,
                type: "mouse"
            }), !1)
        }
        processEndEvent(e, n, r) {
            const s = this.activePointers.get(n.id);
            if (!s) return !1;
            const i = this.getMoveDetail(e, s, r),
                a = new CustomEvent("pointerbox:end", {
                    detail: i
                });
            this.element.dispatchEvent(a), this.checkForSwipe(a), this.activePointers.delete(s.id), this.activePointers.size || (delete this.cachedElementRect, delete this.cachedDocumentRect, delete this.cachedTranslations, this.unbindStartedEvents());
            const c = new CustomEvent("pointerbox:childup", {
                detail: i
            });
            return document.elementsFromPoint(i.clientX, i.clientY).forEach(h => {
                if (h.dispatchEvent(c), !s.children.includes(h)) return;
                const d = new CustomEvent("pointerbox:childclick", {
                    detail: i
                });
                h.dispatchEvent(d)
            }), !1
        }
        checkForSwipe(e) {
            const n = e.detail;
            if (n.distanceFromInitial < this.swipeDistance || n.previous.normalizedVelocity < this.swipeVelocity) return;
            const r = n.degreesFromInitial;
            r > 45 && r < 135 ? n.direction = "up" : r > 135 && r < 225 ? n.direction = "left" : r > 225 && r < 315 ? n.direction = "down" : n.direction = "right";
            const s = new CustomEvent("pointerbox:swipe", {
                    detail: n
                }),
                i = new CustomEvent(`pointerbox:swipe${n.direction}`, {
                    detail: n
                });
            this.element.dispatchEvent(s), this.element.dispatchEvent(i)
        }
        getStartDetail(e, n, r) {
            let s, i, a, c;
            this.cachedElementRect || (this.cachedElementRect = this.element.getBoundingClientRect()), this.cachedDocumentRect || (this.cachedDocumentRect = this.documentElement.getBoundingClientRect());
            const l = this.cachedDocumentRect.top;
            this.cachedTranslations || (this.cachedTranslations = this.getTranslations()), r ? (s = r.pageX, i = r.pageY + l, a = r.clientX, c = r.clientY) : (s = e.pageX, i = e.pageY + l, a = e.clientX, c = e.clientY);
            const h = s - this.cachedElementRect.left,
                d = i - this.cachedElementRect.top,
                p = h / this.cachedElementRect.width,
                g = d / this.cachedElementRect.height,
                v = p < 0 || p > 1 || g < 0 || g > 1,
                b = {};
            return this.cachedTranslations.forEach(T => {
                b[T.id] && console.warn(`[PointerBox] duplicate translation key ${T.id}`), b[T.id] = {
                    x: h * T.x - T.left,
                    y: d * T.y - T.top
                }
            }), {
                id: n.id,
                type: n.type,
                boxX: h,
                boxY: d,
                pageX: s,
                pageY: i,
                clientX: a,
                clientY: c,
                percentX: p,
                percentY: g,
                translations: b,
                isOutsideBox: v,
                originalEvent: e,
                cancel: () => this.cancel()
            }
        }
        getMoveDetail(e, n, r) {
            if (!n.initial) throw new Error("[PointerBox] No initial details stored");
            if (!n.previous) throw new Error("[PointerBox] No previous details stored");
            const s = this.getStartDetail(e, {
                    id: n.id,
                    type: n.type
                }, r),
                i = bs.getAngleBetweenPoints({
                    x: n.initial.boxX,
                    y: n.initial.boxY
                }, {
                    x: s.boxX,
                    y: s.boxY
                }),
                a = bs.getDistanceBetweenPoints({
                    x: n.initial.boxX,
                    y: n.initial.boxY
                }, {
                    x: s.boxX,
                    y: s.boxY
                }),
                c = bs.getAngleBetweenPoints({
                    x: n.previous.boxX,
                    y: n.previous.boxY
                }, {
                    x: s.boxX,
                    y: s.boxY
                }),
                l = bs.getDistanceBetweenPoints({
                    x: n.previous.boxX,
                    y: n.previous.boxY
                }, {
                    x: s.boxX,
                    y: s.boxY
                });
            n.distanceAccumulator += l;
            let h = 0;
            return n.previousEventTimestamp && (h = bs.getVelocity({
                x: n.previous.boxX,
                y: n.previous.boxY
            }, n.previousEventTimestamp, {
                x: s.boxX,
                y: s.boxY
            }, Date.now())), h && (n.velocityValues.unshift(h), n.velocityValues.length = Math.min(n.velocityValues.length, 5)), {
                id: s.id,
                type: s.type,
                boxX: s.boxX,
                boxY: s.boxY,
                pageX: s.pageX,
                pageY: s.pageY,
                clientX: s.clientX,
                clientY: s.clientY,
                percentX: s.percentX,
                percentY: s.percentY,
                translations: s.translations,
                isOutsideBox: s.isOutsideBox,
                degreesFromInitial: i,
                distanceFromInitial: a,
                changeXFromInitial: s.boxX - n.initial.boxX,
                changeYFromInitial: s.boxY - n.initial.boxY,
                degreesFromPrevious: c,
                distancefromPrevious: l,
                changeXFromPrevious: s.boxX - n.previous.boxX,
                changeYFromPrevious: s.boxY - n.previous.boxY,
                totalDistance: n.distanceAccumulator,
                velocity: h,
                normalizedVelocity: n.velocityValues.reduce((d, p) => d + p) / n.velocityValues.length,
                originalEvent: s.originalEvent,
                initial: n.initial,
                previous: n.previous,
                cancel: s.cancel
            }
        }
        getTranslations() {
            if (!this.cachedElementRect) throw Error("[PointerBox] Element rect is undefined");
            const e = [],
                n = this.element.children;
            for (let r = 0; r < n.length; r++) {
                const s = n[r].attributes.getNamedItem("data-pointerboxtranslateid");
                if (!s) continue;
                const i = s.value;
                if (!i) continue;
                const a = n[r].attributes.getNamedItem("data-pointerboxtranslatewidth"),
                    c = n[r].attributes.getNamedItem("data-pointerboxtranslateheight"),
                    l = a != null && a.value ? parseInt(a.value, 10) : this.cachedElementRect.width,
                    h = c != null && c.value ? parseInt(c.value, 10) : this.cachedElementRect.height,
                    d = n[r].getBoundingClientRect();
                e.push({
                    id: i,
                    left: d.left - this.cachedElementRect.left,
                    top: d.top - this.cachedElementRect.top,
                    x: l / d.width,
                    y: h / d.height
                })
            }
            return e
        }
        disableChildPointerEvents() {
            this.element.style.touchAction = "none";
            for (let e = 0; e < this.element.children.length; e++) {
                const n = this.element.children[e];
                n.style.pointerEvents = "none", n.style.touchAction = "none"
            }
        }
        enableChildPointerEvents() {
            this.element.style.touchAction = "";
            for (let e = 0; e < this.element.children.length; e++) {
                const n = this.element.children[e];
                n.style.pointerEvents = "", n.style.touchAction = ""
            }
        }
        applyPolyfill() {
            fc.isPolyfilled || (fc.isPolyfilled = !0, window && window.document && (window.document.elementsFromPoint || (window.document.elementsFromPoint = fc.elementsFromPoint)))
        }
        static elementsFromPoint(e, n) {
            const r = [],
                s = [];
            let i = null;
            do {
                const a = window.document.elementFromPoint(e, n);
                i !== a ? (i = a, r.push(i), s.push(i.style.pointerEvents), i.style.pointerEvents = "none") : i = null
            } while (i);
            return r.forEach((a, c) => {
                a.style.pointerEvents = s[c]
            }), r
        }
    };
    Ce(fc, "isPolyfilled", !1);
    let E1 = fc;
    const oK = {
            BACK: "Back",
            CANCEL: "Cancel",
            CLOSE: "Close",
            CONFIRM: "Confirm",
            CREATE: "Create",
            DELETE: "Delete",
            DONE: "Done",
            EDIT: "Edit",
            OK: "OK",
            NEXT: "Next",
            NO: "No",
            PLAY: "Play",
            PUBLISH: "Publish",
            REMOVE: "Remove",
            RESET: "Reset",
            SUBMIT: "Submit",
            TRY_AGAIN: "Try Again",
            UNDO: "Undo",
            YES: "Yes"
        },
        aK = {
            UGC: {
                VISIBILITY_CONTROLLER_OFF: "prompts hidden on players devices",
                VISIBILITY_CONTROLLER_ON: "prompts shown on players devices",
                VISIBILITY_SCREEN_OFF: "prompts hidden on game screen",
                VISIBILITY_SCREEN_ON: "prompts shown on game screen"
            }
        },
        cK = {
            DISCONNECTED: "You have been disconnected.",
            DRAWING_NOTHING: "You have to draw something!",
            PLAYER_KICKED: "You have been kicked from the game by a moderator.",
            ROOM_DESTROYED: "Thanks for playing!",
            ROOM_DISCONNECTED: "Disconnected",
            TEXT_NAUGHTY: "Im afraid you cant write that. Please be respectful of other players.",
            TEXT_NOTHING: "You cant enter nothing!",
            TITLE: "Error"
        },
        uK = "LOADING",
        lK = {
            JOINED_COUNT: "{count} of {maxPlayers} players joined",
            PLAYERS_NEEDED: "1 player needed to start | {count} players needed to start",
            WAITING_FOR_VIP: "Waiting for {name} to start the game",
            WAITING_FOR_GAMEPAD: "Waiting for the game to start",
            GAME_STARTING: "Game is starting",
            BUTTON_START: "Press to Start",
            BUTTON_CANCEL: "Press to Cancel"
        },
        hK = {
            GALLERY_LINK: "Visit the Gallery",
            PLAY_AGAIN: "Play again?",
            BUTTON_SAME_PLAYERS: "Same Players",
            BUTTON_NEW_PLAYERS: "New Players"
        },
        fK = {
            AND: "AND",
            OR: "OR"
        },
        dK = {
            BUTTON_SKIP: "Skip",
            BUTTON_NEXT: "Next",
            BUTTON_DONE: "Lets Go!"
        },
        pK = {
            NAME: "AUDIENCE"
        },
        mK = {
            EPISODE_REPORT: "Report Episode",
            EPISODE_UNLOAD: "Unload Episode",
            EPISODE_VIEW_AUTHOR: "View Author",
            EPISODES_LOAD: "Load an episode by id:",
            EPISODES_MENU: "Episodes Menu",
            EPISODES_SELECT: "Or select an epsiode:",
            EPISODES_WARNING: "Warning: user generated content is not rated",
            INSTRUCTION: {
                CREATE_TITLE: "first things first, enter a name for the episode that will contain all your prompts and hit create.",
                LOAD: "create or load?",
                PUBLISH: "publish your episode",
                TITLE: "name your episode",
                TOGGLE_VISIBILITY: "tap to show/hide prompts",
                WRITE: "write your prompts"
            },
            WARNING: {
                DELETE: "Are you sure you want to delete this episode?",
                TOS: "By sharing content, you agree to our [tos]Terms of Service[/tos]",
                TOS_AGREE: "agree and share"
            },
            BACK_TO_EPISODES: "back to episodes",
            BACK_TO_MENU: "back to menu",
            CREATE_NEW_EPISODE: "create a new episode",
            PREVIOUS_EPISODES: "previous episodes",
            PROMPT_ADD: "add prompt",
            PROMPT_PLACEHOLDER: "enter a prompt",
            PROMPTS_COUNT_HIDDEN: "({count} hidden)",
            TITLE_PLACEHOLDER: "enter a title"
        },
        gK = {
            BROADCASTER: {
                SUBTEXT: "You have successfully connected your account to the Jackbox Audience Kit Twitch Extension.",
                WARNING: "THIS ROOM DOESN'T HAVE THE AUDIENCE SETTING ENABLED"
            },
            RECONNECTED: {
                TEXT: "RECONNECTED",
                SUBTEXT: "Have fun!"
            },
            RECONNECTING: {
                CONTROLLER: {
                    TEXT: "CONNECTION INTERRUPTED",
                    SUBTEXT: "Attempting to reconnect ({attempt} of 5)"
                },
                GAME: {
                    TEXT: "GAME CONNECTION INTERRUPTED",
                    SUBTEXT: "Please wait while we attempt to reconnect"
                }
            },
            PAUSED: {
                TEXT: "THE GAME IS PAUSED",
                SUBTEXT: "Anything you submit will still be sent to the game."
            }
        },
        _K = {
            ACTION: oK,
            ALT: aK,
            ERROR: cK,
            LOADING: uK,
            LOBBY: lK,
            POST_GAME: hK,
            SEPARATOR: fK,
            TUTORIAL: dK,
            AUDIENCE: pK,
            UGC: mK,
            TOAST: gK
        },
        yK = {
            BACK: "Retour",
            CANCEL: "Annuler",
            CLOSE: "Fermer",
            CONFIRM: "Confirmer",
            CREATE: "Crer",
            DELETE: "Supprimer",
            DONE: "Termin",
            EDIT: "Modifier",
            OK: "OK",
            NEXT: "Suivant",
            NO: "Non",
            PLAY: "Jouer",
            PUBLISH: "Publier",
            REMOVE: "Supprimer",
            RESET: "Rinitialiser",
            SUBMIT: "Envoyer",
            TRY_AGAIN: "Ressayer",
            UNDO: "Annuler",
            YES: "Oui"
        },
        vK = {
            UGC: {
                VISIBILITY_CONTROLLER_OFF: "sujets non affichs sur les appareils des joueurs",
                VISIBILITY_CONTROLLER_ON: "sujets affichs sur les appareils des joueurs",
                VISIBILITY_SCREEN_OFF: "sujets non affichs sur l'cran de jeu",
                VISIBILITY_SCREEN_ON: "sujets affichs sur l'cran de jeu"
            }
        },
        bK = {
            DISCONNECTED: "Vous avez t dconnect(e).",
            DRAWING_NOTHING: "Vous devez dessiner quelque chose!",
            PLAYER_KICKED: "Vous avez t ject(e) de la partie par un modrateur.",
            ROOM_DESTROYED: "Merci d'avoir jou!",
            ROOM_DISCONNECTED: "Dconnexion",
            TEXT_NAUGHTY: "Je crains que vous ne puissiez pas crire a. Respectez les autres joueurs.",
            TEXT_NOTHING: "Vous ne pouvez pas ne rien entrer",
            TITLE: "Erreur"
        },
        EK = "CHARGEMENT",
        SK = {
            JOINED_COUNT: "{count} joueurs sur {maxPlayers} ont rejoint la partie",
            PLAYERS_NEEDED: "1joueur ncessaire pour commencer | {count}joueurs ncessaires pour commencer",
            WAITING_FOR_VIP: "En attente de {name} pour commencer la partie",
            WAITING_FOR_GAMEPAD: "En attente du dbut de la partie",
            GAME_STARTING: "La partie commence",
            BUTTON_START: "Appuyer pour commencer",
            BUTTON_CANCEL: "Appuyer pour annuler"
        },
        TK = {
            GALLERY_LINK: "Visiter la galerie",
            PLAY_AGAIN: "Rejouer?",
            BUTTON_SAME_PLAYERS: "Les mmes joueurs",
            BUTTON_NEW_PLAYERS: "De nouveaux joueurs"
        },
        wK = {
            AND: "ET",
            OR: "OU"
        },
        OK = {
            BUTTON_SKIP: "Passer",
            BUTTON_NEXT: "Suivant",
            BUTTON_DONE: "Allons-y!"
        },
        AK = {
            NAME: "SPECTATEURS"
        },
        CK = {
            EPISODE_REPORT: "Signaler l'pisode",
            EPISODE_UNLOAD: "Retirer l'pisode",
            EPISODE_VIEW_AUTHOR: "Voir l'auteur",
            EPISODES_LOAD: "Charger un pisode par id:",
            EPISODES_MENU: "Menu des pisodes",
            EPISODES_SELECT: "Ou slectionner un pisode:",
            EPISODES_WARNING: "Attention: le contenu gnr par les utilisateurs ne fait pas l'objet d'un classement",
            INSTRUCTION: {
                CREATE_TITLE: "commencez par donner un nom  l'pisode qui contiendra vos sujets, puis touchez crer.",
                LOAD: "crer ou charger?",
                PUBLISH: "publiez votre pisode",
                TITLE: "donnez un nom  votre pisode",
                TOGGLE_VISIBILITY: "touchez pour afficher/masquer les sujets",
                WRITE: "crivez vos sujets"
            },
            WARNING: {
                DELETE: "Voulez-vous vraiment supprimer cet pisode?",
                TOS: "En partageant votre contenu, vous acceptez nos [tos]Conditions de service[/tos]",
                TOS_AGREE: "accepter et partager"
            },
            BACK_TO_EPISODES: "retour aux pisodes",
            BACK_TO_MENU: "retour au menu",
            CREATE_NEW_EPISODE: "crer un nouvel pisode",
            PREVIOUS_EPISODES: "pisodes prcdents",
            PROMPT_ADD: "ajouter un sujet",
            PROMPT_PLACEHOLDER: "taper un sujet",
            PROMPTS_COUNT_HIDDEN: "({count} non affich)",
            TITLE_PLACEHOLDER: "taper un titre"
        },
        IK = {
            BROADCASTER: {
                SUBTEXT: "La connexion de votre compte  l'extension Twitch Jackbox Audience Kit a russi.",
                WARNING: "LE PARAMTRE 'PUBLIC' N'EST PAS ACTIV DANS CETTE SALLE."
            },
            RECONNECTED: {
                TEXT: "RECONNECT(E)",
                SUBTEXT: "Amusez-vous bien!"
            },
            RECONNECTING: {
                CONTROLLER: {
                    TEXT: "CONNEXION INTERROMPUE",
                    SUBTEXT: "Tentative de reconnexion ({attempt} sur 5)"
                },
                GAME: {
                    TEXT: "CONNEXION AU JEU INTERROMPUE",
                    SUBTEXT: "Veuillez patienter pendant que nous tentons de vous reconnecter."
                }
            }
        },
        kK = {
            ACTION: yK,
            ALT: vK,
            ERROR: bK,
            LOADING: EK,
            LOBBY: SK,
            POST_GAME: TK,
            SEPARATOR: wK,
            TUTORIAL: OK,
            AUDIENCE: AK,
            UGC: CK,
            TOAST: IK
        },
        NK = {
            BACK: "Indietro",
            CANCEL: "Annulla",
            CLOSE: "Chiuda",
            CONFIRM: "Conferma",
            CREATE: "Crea",
            DELETE: "Elimina",
            DONE: "Fine",
            EDIT: "Modifica",
            OK: "OK",
            NEXT: "Prossimo",
            NO: "No",
            PLAY: "Gioca",
            PUBLISH: "Pubblica",
            REMOVE: "Rimuovi",
            RESET: "Reset",
            SUBMIT: "Invia",
            TRY_AGAIN: "Riprova",
            UNDO: "Annulla",
            YES: "S"
        },
        xK = {
            UGC: {
                VISIBILITY_CONTROLLER_OFF: "definizioni nascoste sui dispositivi dei giocatori",
                VISIBILITY_CONTROLLER_ON: "definizioni visualizzate sui dispositivi dei giocatori",
                VISIBILITY_SCREEN_OFF: "definizioni nascoste sullo schermo di gioco",
                VISIBILITY_SCREEN_ON: "definizioni visualizzate sullo schermo di gioco"
            }
        },
        PK = {
            DISCONNECTED: " stata effettuata la disconnessione.",
            DRAWING_NOTHING: "Devi disegnare qualcosa!",
            PLAYER_KICKED: "Un moderatore ti ha cacciato dalla partita.",
            ROOM_DESTROYED: "Grazie per aver scelto di giocare con noi!",
            ROOM_DISCONNECTED: "Disconnessione effettuata",
            TEXT_NAUGHTY: "Purtroppo non puoi scrivere questa cosa. Abbi rispetto per gli altri giocatori.",
            TEXT_NOTHING: "Devi per forza inserire qualcosa!",
            TITLE: "Errore"
        },
        RK = "CARICAMENTO",
        MK = {
            JOINED_COUNT: "{count} su {maxPlayers} giocatori in partita",
            PLAYERS_NEEDED: "Manca 1 giocatore per iniziare | Mancano {count} giocatori per iniziare",
            WAITING_FOR_VIP: "In attesa di {name} per iniziare la partita",
            WAITING_FOR_GAMEPAD: "In attesa d'iniziare la partita",
            GAME_STARTING: "La partita sta per iniziare",
            BUTTON_START: "Premi per avviare",
            BUTTON_CANCEL: "Premi per annullare"
        },
        DK = {
            GALLERY_LINK: "Visita la galleria",
            PLAY_AGAIN: "Vuoi giocare di nuovo?",
            BUTTON_SAME_PLAYERS: "Stessi giocatori",
            BUTTON_NEW_PLAYERS: "Nuovi giocatori"
        },
        $K = {
            AND: "E",
            OR: "O"
        },
        LK = {
            BUTTON_SKIP: "Salta",
            BUTTON_NEXT: "Avanti",
            BUTTON_DONE: "Iniziamo!"
        },
        FK = {
            NAME: "PUBBLICO"
        },
        UK = {
            EPISODE_REPORT: "Segnala episodio",
            EPISODE_UNLOAD: "Rimuovi episodio",
            EPISODE_VIEW_AUTHOR: "Mostra autore",
            EPISODES_LOAD: "Carica un episodio in base al suo id:",
            EPISODES_MENU: "Menu Episodi",
            EPISODES_SELECT: "Oppure seleziona un episodio:",
            EPISODES_WARNING: "Attenzione: il contenuto generato dagli utenti non  classificato",
            INSTRUCTION: {
                CREATE_TITLE: "per prima cosa, inserisci un nome per lepisodio che contenga tutti i tuoi suggerimenti e premi crea.",
                LOAD: "creare o caricare?",
                PUBLISH: "pubblica il tuo episodio",
                TITLE: "dai un nome al tuo episodio",
                TOGGLE_VISIBILITY: "tocca per mostrare/nascondere suggerimenti",
                WRITE: "scrivi le tue definizioni"
            },
            WARNING: {
                DELETE: "Vuoi davvero eliminare questo episodio?",
                TOS: "Condividendo i contenuti, accetti le nostre [tos]Condizioni del servizio[/tos]",
                TOS_AGREE: "accetta e condividi"
            },
            BACK_TO_EPISODES: "torna agli episodi",
            BACK_TO_MENU: "torna al menu",
            CREATE_NEW_EPISODE: "crea un nuovo episodio",
            PREVIOUS_EPISODES: "episodi precedenti",
            PROMPT_ADD: "aggiungi suggerimento",
            PROMPT_PLACEHOLDER: "inserisci suggerimento",
            PROMPTS_COUNT_HIDDEN: "({count} nascosti)",
            TITLE_PLACEHOLDER: "inserisci un titolo"
        },
        BK = {
            BROADCASTER: {
                SUBTEXT: "Il collegamento del tuo account con l'estensione per Twitch Jackbox Audience Kit  andato a buon fine.",
                WARNING: "L'IMPOSTAZIONE DEL PUBBLICO NON  ATTIVA PER QUESTA STANZA"
            },
            RECONNECTED: {
                TEXT: "RICONNESSO",
                SUBTEXT: "Buon divertimento!"
            },
            RECONNECTING: {
                CONTROLLER: {
                    TEXT: "CONNESSIONE INTERROTTA",
                    SUBTEXT: "Tentativo di riconnessione in corso ({attempt} di 5)"
                },
                GAME: {
                    TEXT: "CONNESSIONE AL GIOCO INTERROTTA",
                    SUBTEXT: "Resta in attesa mentre proviamo a riconnetterci"
                }
            }
        },
        qK = {
            ACTION: NK,
            ALT: xK,
            ERROR: PK,
            LOADING: RK,
            LOBBY: MK,
            POST_GAME: DK,
            SEPARATOR: $K,
            TUTORIAL: LK,
            AUDIENCE: FK,
            UGC: UK,
            TOAST: BK
        },
        VK = {
            BACK: "Zurck",
            CANCEL: "Abbrechen",
            CLOSE: "Schlieen",
            CONFIRM: "Besttigen",
            CREATE: "Erstellen",
            DELETE: "Lschen",
            DONE: "Fertig",
            EDIT: "Bearbeiten",
            OK: "OK",
            NEXT: "Weiter",
            NO: "Nein",
            PLAY: "Spielen",
            PUBLISH: "Verffentlichen",
            REMOVE: "Entfernen",
            RESET: "Neu starten",
            SUBMIT: "Abschicken",
            TRY_AGAIN: "Erneut versuchen",
            UNDO: "Rckgngig",
            YES: "Ja"
        },
        jK = {
            UGC: {
                VISIBILITY_CONTROLLER_OFF: "Prompts auf Spielergerten verborgen",
                VISIBILITY_CONTROLLER_ON: "Prompts auf Spielergerten angezeigt",
                VISIBILITY_SCREEN_OFF: "Prompts auf Spielbildschirm verborgen",
                VISIBILITY_SCREEN_ON: "Prompts auf Spielbildschirm angezeigt"
            }
        },
        GK = {
            DISCONNECTED: "Deine Verbindung wurde getrennt.",
            DRAWING_NOTHING: "Du musst irgendwas zeichnen!",
            PLAYER_KICKED: "Du wurdest von einem Moderator gekickt.",
            ROOM_DESTROYED: "Danke frs Spielen!",
            ROOM_DISCONNECTED: "Verbindung getrennt",
            TEXT_NAUGHTY: "Das kannst du leider nicht schreiben. Bitte nimm Rcksicht auf deine Mitspieler.",
            TEXT_NOTHING: "Du musst etwas eingeben!",
            TITLE: "Fehler"
        },
        WK = "LADE",
        HK = {
            JOINED_COUNT: "{count} von {maxPlayers} Spielern sind beigetreten",
            PLAYERS_NEEDED: "1 Spieler zum Starten bentigt | {count} Spieler zum Starten bentigt",
            WAITING_FOR_VIP: "Warten, bis {name} das Spiel startet",
            WAITING_FOR_GAMEPAD: "Warten, bis das Spiel startet",
            GAME_STARTING: "Das Spiel beginnt",
            BUTTON_START: "Zum Starten drcken",
            BUTTON_CANCEL: "Zum Abbrechen drcken"
        },
        KK = {
            GALLERY_LINK: "Galerie besuchen",
            PLAY_AGAIN: "Erneut spielen?",
            BUTTON_SAME_PLAYERS: "Selbe Spieler",
            BUTTON_NEW_PLAYERS: "Neue Spieler"
        },
        YK = {
            AND: "UND",
            OR: "ODER"
        },
        zK = {
            BUTTON_SKIP: "berspringen",
            BUTTON_NEXT: "Weiter",
            BUTTON_DONE: "Los geht's!"
        },
        ZK = {
            NAME: "PUBLIKUM"
        },
        XK = {
            EPISODE_REPORT: "Episode melden",
            EPISODE_UNLOAD: "Episode deaktivieren",
            EPISODE_VIEW_AUTHOR: "Autor ansehen",
            EPISODES_LOAD: "Lade eine Episode ber dessen ID:",
            EPISODES_MENU: "Episoden-Men",
            EPISODES_SELECT: "Oder whle eine Episode aus:",
            EPISODES_WARNING: "Achtung: Von Nutzern erstellte Inhalte werden nicht auf Familientauglichkeit geprft",
            INSTRUCTION: {
                CREATE_TITLE: 'Benenne als allererstes deine Episode, die alle deine Prompts enthalten wird und drcke dann "Erstellen".',
                LOAD: "Erstellen oder laden?",
                PUBLISH: "Verffentliche deine Episode",
                TITLE: "Benenne deine Episode",
                TOGGLE_VISIBILITY: "Drcken, um Prompts zu zeigen / zu verstecken",
                WRITE: "Schreibe deine Prompts"
            },
            WARNING: {
                DELETE: "Bist du sicher, dass du diese Episode lschen mchtest?",
                TOS: "Durch das Teilen von Inhalten stimmst du unseren [tos]Nutzungsbedingungen[/tos] zu",
                TOS_AGREE: "Zustimmen und teilen"
            },
            BACK_TO_EPISODES: "Zurck zu den Episoden",
            BACK_TO_MENU: "Zurck zum Men",
            CREATE_NEW_EPISODE: "Eigene Episode erstellen",
            PREVIOUS_EPISODES: "Vorige Episoden",
            PROMPT_ADD: "Prompt hinzufgen",
            PROMPT_PLACEHOLDER: "Prompt eingeben",
            PROMPTS_COUNT_HIDDEN: "({count} versteckt)",
            TITLE_PLACEHOLDER: "Titel eingeben"
        },
        QK = {
            BROADCASTER: {
                SUBTEXT: "Du hast dein Konto erfolgreich mit der Jackbox Audience Kit Twitch-Erweiterung verknpft.",
                WARNING: "FR DIESEN RAUM IST DIE PUBLIKUMS-EINSTELLUNG NICHT AKTIV"
            },
            RECONNECTED: {
                TEXT: "NEU VERBUNDEN",
                SUBTEXT: "Viel Spa!"
            },
            RECONNECTING: {
                CONTROLLER: {
                    TEXT: "VERBINDUNG UNTERBROCHEN",
                    SUBTEXT: "Versuche neu zu verbinden ({attempt} von 5)"
                },
                GAME: {
                    TEXT: "VERBINDUNG ZUM SPIEL UNTERBROCHEN",
                    SUBTEXT: "Bitte warte whrend wir versuchen, die Verbindung wiederherzustellen."
                }
            }
        },
        JK = {
            ACTION: VK,
            ALT: jK,
            ERROR: GK,
            LOADING: WK,
            LOBBY: HK,
            POST_GAME: KK,
            SEPARATOR: YK,
            TUTORIAL: zK,
            AUDIENCE: ZK,
            UGC: XK,
            TOAST: QK
        },
        eY = {
            BACK: "Atrs",
            CANCEL: "Cancelar",
            CLOSE: "Cerrar",
            CONFIRM: "Confirmar",
            CREATE: "Crear",
            DELETE: "Borrar",
            DONE: "Hecho",
            EDIT: "Editar",
            OK: "Aceptar",
            NEXT: "Siguiente",
            NO: "No",
            PLAY: "Jugar",
            PUBLISH: "Publicar",
            REMOVE: "Eliminar",
            RESET: "Reiniciar",
            SUBMIT: "Enviar",
            TRY_AGAIN: "Volver a intentarlo",
            UNDO: "Deshacer",
            YES: "S"
        },
        tY = {
            UGC: {
                VISIBILITY_CONTROLLER_OFF: "los enunciados no se muestran en el dispositivo del jugador",
                VISIBILITY_CONTROLLER_ON: "los enunciados se muestran en el dispositivo del jugador",
                VISIBILITY_SCREEN_OFF: "los enunciados no se muestran en la pantalla",
                VISIBILITY_SCREEN_ON: "los enunciados se muestran en la pantalla"
            }
        },
        nY = {
            DISCONNECTED: "Te has desconectado.",
            DRAWING_NOTHING: "Tienes que dibujar algo!",
            PLAYER_KICKED: "Un moderador te ha expulsado de la partida.",
            ROOM_DESTROYED: "Gracias por jugar!",
            ROOM_DISCONNECTED: "Desconectado",
            TEXT_NAUGHTY: "Lo siento, no puedes escribir eso. Hay que ser respetuoso con los dems jugadores.",
            TEXT_NOTHING: "Tienes que escribir algo",
            TITLE: "Error"
        },
        rY = "CARGANDO",
        sY = {
            JOINED_COUNT: "Se han unido {count} de {maxPlayers} jugadores",
            PLAYERS_NEEDED: "Se necesita 1 jugador para empezar | Se necesitan {count} jugadores para empezar",
            WAITING_FOR_VIP: "Esperando a que {name} inicie la partida",
            WAITING_FOR_GAMEPAD: "Esperando a que empiece la partida",
            GAME_STARTING: "La partida va a empezar",
            BUTTON_START: "Pulsa para empezar",
            BUTTON_CANCEL: "Pulsa para cancelar"
        },
        iY = {
            GALLERY_LINK: "Visita la galera",
            PLAY_AGAIN: "Jugar otra vez?",
            BUTTON_SAME_PLAYERS: "Los mismos jugadores",
            BUTTON_NEW_PLAYERS: "Nuevos jugadores"
        },
        oY = {
            AND: "Y",
            OR: "O"
        },
        aY = {
            BUTTON_SKIP: "Omitir",
            BUTTON_NEXT: "Siguiente",
            BUTTON_DONE: "Vamos!"
        },
        cY = {
            NAME: "PBLICO"
        },
        uY = {
            EPISODE_REPORT: "Denunciar episodio",
            EPISODE_UNLOAD: "Retirar episodio",
            EPISODE_VIEW_AUTHOR: "Ver autor",
            EPISODES_LOAD: "Cargar un episodio por ID:",
            EPISODES_MENU: "Men de episodios",
            EPISODES_SELECT: "O selecciona un episodio:",
            EPISODES_WARNING: "Aviso: El contenido de los usuarios no tiene clasificacin de edad",
            INSTRUCTION: {
                CREATE_TITLE: "en primer lugar, ponle un nombre al episodio que contendr tus enunciados y dale a crear.",
                LOAD: "crear o cargar?",
                PUBLISH: "publica tu episodio",
                TITLE: "ponle nombre al episodio",
                TOGGLE_VISIBILITY: "toca para mostrar u ocultar los enunciados",
                WRITE: "escribe los enunciados"
            },
            WARNING: {
                DELETE: "Seguro que quieres borrar este episodio?",
                TOS: "Al compartir contenidos, aceptas las [tos]Condiciones del servicio[/tos]",
                TOS_AGREE: "aceptar y compartir"
            },
            BACK_TO_EPISODES: "volver a los episodios",
            BACK_TO_MENU: "volver al men",
            CREATE_NEW_EPISODE: "crear nuevo episodio",
            PREVIOUS_EPISODES: "episodios anteriores",
            PROMPT_ADD: "aadir enunciado",
            PROMPT_PLACEHOLDER: "escribe un enunciado",
            PROMPTS_COUNT_HIDDEN: "({count} ocultos)",
            TITLE_PLACEHOLDER: "escribe un ttulo"
        },
        lY = {
            BROADCASTER: {
                SUBTEXT: "Has conectado tu cuenta con xito a la extensin de Twitch del kit para pblico de Jackbox.",
                WARNING: "ESTA SALA NO TIENE LA FUNCIN DE PBLICO HABILITADA"
            },
            RECONNECTED: {
                TEXT: "CONEXIN RESTABLECIDA",
                SUBTEXT: "Divirtete!"
            },
            RECONNECTING: {
                CONTROLLER: {
                    TEXT: "SE HA INTERRUMPIDO LA CONEXIN",
                    SUBTEXT: "Recuperando conexin (intento {attempt} de 5)"
                },
                GAME: {
                    TEXT: "SE HA INTERRUMPIDO LA CONEXIN CON EL JUEGO",
                    SUBTEXT: "Espera mientras intentamos recuperar la conexin"
                }
            }
        },
        hY = {
            ACTION: eY,
            ALT: tY,
            ERROR: nY,
            LOADING: rY,
            LOBBY: sY,
            POST_GAME: iY,
            SEPARATOR: oY,
            TUTORIAL: aY,
            AUDIENCE: cY,
            UGC: uY,
            TOAST: lY
        },
        fY = {
            BACK: "Volver",
            CANCEL: "Cancelar",
            CLOSE: "Cerrar",
            CONFIRM: "Confirmar",
            CREATE: "Crear",
            DELETE: "Borrar",
            DONE: "Listo",
            EDIT: "Editar",
            OK: "Aceptar",
            NEXT: "Siguiente",
            NO: "No",
            PLAY: "Jugar",
            PUBLISH: "Publicar",
            REMOVE: "Quitar",
            RESET: "Reiniciar",
            SUBMIT: "Enviar",
            TRY_AGAIN: "Volver a intentarlo",
            UNDO: "Deshacer",
            YES: "S"
        },
        dY = {
            UGC: {
                VISIBILITY_CONTROLLER_OFF: "indicaciones ocultas en los dispositivos de los jugadores",
                VISIBILITY_CONTROLLER_ON: "indicaciones presentes en los dispositivos de los jugadores",
                VISIBILITY_SCREEN_OFF: "indicaciones ocultas en la pantalla del juego",
                VISIBILITY_SCREEN_ON: "indicaciones presentes en la pantalla del juego"
            }
        },
        pY = {
            DISCONNECTED: "Te desconectaste.",
            DRAWING_NOTHING: "Tienes que dibujar algo!",
            PLAYER_KICKED: "Un moderador te expuls del juego.",
            ROOM_DESTROYED: "Gracias por jugar!",
            ROOM_DISCONNECTED: "Desconectado",
            TEXT_NAUGHTY: "Lo siento, no puedes escribir eso. Seamos respetuosos con los dems jugadores.",
            TEXT_NOTHING: "Tienes que escribir algo!",
            TITLE: "Error"
        },
        mY = "CARGANDO",
        gY = {
            JOINED_COUNT: "{count} de {maxPlayers} jugadores se unieron",
            PLAYERS_NEEDED: "Se necesita 1 jugador para empezar | Se necesitan {count} jugadores para empezar",
            WAITING_FOR_VIP: "Esperando a que {name} inicie la partida",
            WAITING_FOR_GAMEPAD: "Esperando a que empiece la partida",
            GAME_STARTING: "La partida va a empezar",
            BUTTON_START: "Pulsa para empezar",
            BUTTON_CANCEL: "Pulsa para cancelar"
        },
        _Y = {
            GALLERY_LINK: "Visita la galera",
            PLAY_AGAIN: "Jugar otra vez?",
            BUTTON_SAME_PLAYERS: "Los mismos jugadores",
            BUTTON_NEW_PLAYERS: "Nuevos jugadores"
        },
        yY = {
            AND: "Y",
            OR: "O"
        },
        vY = {
            BUTTON_SKIP: "Omitir",
            BUTTON_NEXT: "Siguiente",
            BUTTON_DONE: "Vamos!"
        },
        bY = {
            NAME: "PBLICO"
        },
        EY = {
            EPISODE_REPORT: "Denunciar episodio",
            EPISODE_UNLOAD: "Descargar episodio",
            EPISODE_VIEW_AUTHOR: "Ver autor",
            EPISODES_LOAD: "Cargar un episodio por ID:",
            EPISODES_MENU: "Men de episodios",
            EPISODES_SELECT: "O selecciona un episodio:",
            EPISODES_WARNING: "Aviso: El contenido de los usuarios no tiene clasificacin por edades",
            INSTRUCTION: {
                CREATE_TITLE: "Lo primero que debes hacer es escribir un nombre para el episodio que contendr todas sus indicaciones y pulsar crear.",
                LOAD: "Crear o cargar?",
                PUBLISH: "Publica tu episodio",
                TITLE: "Nombra tu episodio",
                TOGGLE_VISIBILITY: "Pulsa para mostrar/ocultar las indicaciones",
                WRITE: "Escribe tus indicaciones"
            },
            WARNING: {
                DELETE: "De verdad quieres borrar este episodio?",
                TOS: "Al compartir contenido, aceptas nuestros [tos]Trminos de servicio[/tos]",
                TOS_AGREE: "Aceptar y compartir"
            },
            BACK_TO_EPISODES: "Volver a los episodios",
            BACK_TO_MENU: "Volver al men",
            CREATE_NEW_EPISODE: "Crear un nuevo episodio",
            PREVIOUS_EPISODES: "Episodios anteriores",
            PROMPT_ADD: "Aadir indicacin",
            PROMPT_PLACEHOLDER: "Escribe una indicacin",
            PROMPTS_COUNT_HIDDEN: "({count} oculto(s))",
            TITLE_PLACEHOLDER: "Escribir un ttulo"
        },
        SY = {
            BROADCASTER: {
                SUBTEXT: "Conectaste correctamente tu cuenta a la extensin para Twitch del kit para pblico de Jackbox.",
                WARNING: "ESTA SALA NO TIENE ACTIVADA LA OPCIN DE PBLICO"
            },
            RECONNECTED: {
                TEXT: "CONEXIN RESTABLECIDA",
                SUBTEXT: "Divirtete!"
            },
            RECONNECTING: {
                CONTROLLER: {
                    TEXT: "CONEXIN INTERRUMPIDA",
                    SUBTEXT: "Intento de reconexin ({attempt} de 5)"
                },
                GAME: {
                    TEXT: "SE INTERRUMPI LA CONEXIN AL JUEGO",
                    SUBTEXT: "Espera mientras intentamos restablecer la conexin"
                }
            }
        },
        TY = {
            ACTION: fY,
            ALT: dY,
            ERROR: pY,
            LOADING: mY,
            LOBBY: gY,
            POST_GAME: _Y,
            SEPARATOR: yY,
            TUTORIAL: vY,
            AUDIENCE: bY,
            UGC: EY,
            TOAST: SY
        },
        wY = {
            en: _K,
            fr: kK,
            it: qK,
            de: JK,
            es: hY,
            "es-XL": TY
        };
    var Td = {
        exports: {}
    };
    /**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    Td.exports;
    (function(t, e) {
        (function() {
            var n, r = "4.17.21",
                s = 200,
                i = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
                a = "Expected a function",
                c = "Invalid `variable` option passed into `_.template`",
                l = "__lodash_hash_undefined__",
                h = 500,
                d = "__lodash_placeholder__",
                p = 1,
                g = 2,
                v = 4,
                b = 1,
                T = 2,
                m = 1,
                w = 2,
                P = 4,
                V = 8,
                M = 16,
                I = 32,
                L = 64,
                B = 128,
                q = 256,
                se = 512,
                ce = 30,
                ue = "...",
                ee = 800,
                ge = 16,
                G = 1,
                le = 2,
                fe = 3,
                me = 1 / 0,
                Te = 9007199254740991,
                we = 17976931348623157e292,
                ke = 0 / 0,
                Ie = 4294967295,
                $e = Ie - 1,
                At = Ie >>> 1,
                $t = [
                    ["ary", B],
                    ["bind", m],
                    ["bindKey", w],
                    ["curry", V],
                    ["curryRight", M],
                    ["flip", se],
                    ["partial", I],
                    ["partialRight", L],
                    ["rearg", q]
                ],
                qe = "[object Arguments]",
                Xe = "[object Array]",
                tt = "[object AsyncFunction]",
                S = "[object Boolean]",
                k = "[object Date]",
                H = "[object DOMException]",
                K = "[object Error]",
                A = "[object Function]",
                y = "[object GeneratorFunction]",
                E = "[object Map]",
                C = "[object Number]",
                D = "[object Null]",
                Z = "[object Object]",
                oe = "[object Promise]",
                pe = "[object Proxy]",
                _e = "[object RegExp]",
                he = "[object Set]",
                re = "[object String]",
                ae = "[object Symbol]",
                Re = "[object Undefined]",
                De = "[object WeakMap]",
                Je = "[object WeakSet]",
                dt = "[object ArrayBuffer]",
                U = "[object DataView]",
                $ = "[object Float32Array]",
                te = "[object Float64Array]",
                F = "[object Int8Array]",
                Q = "[object Int16Array]",
                ve = "[object Int32Array]",
                Oe = "[object Uint8Array]",
                xe = "[object Uint8ClampedArray]",
                Fe = "[object Uint16Array]",
                dn = "[object Uint32Array]",
                Nr = /\b__p \+= '';/g,
                et = /\b(__p \+=) '' \+/g,
                bu = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
                h2 = /&(?:amp|lt|gt|quot|#39);/g,
                f2 = /[&<>"']/g,
                Dk = RegExp(h2.source),
                $k = RegExp(f2.source),
                Lk = /<%-([\s\S]+?)%>/g,
                Fk = /<%([\s\S]+?)%>/g,
                d2 = /<%=([\s\S]+?)%>/g,
                Uk = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                Bk = /^\w*$/,
                qk = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                Lm = /[\\^$.*+?()[\]{}|]/g,
                Vk = RegExp(Lm.source),
                Fm = /^\s+/,
                jk = /\s/,
                Gk = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                Wk = /\{\n\/\* \[wrapped with (.+)\] \*/,
                Hk = /,? & /,
                Kk = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
                Yk = /[()=,{}\[\]\/\s]/,
                zk = /\\(\\)?/g,
                Zk = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
                p2 = /\w*$/,
                Xk = /^[-+]0x[0-9a-f]+$/i,
                Qk = /^0b[01]+$/i,
                Jk = /^\[object .+?Constructor\]$/,
                e6 = /^0o[0-7]+$/i,
                t6 = /^(?:0|[1-9]\d*)$/,
                n6 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
                wh = /($^)/,
                r6 = /['\n\r\u2028\u2029\\]/g,
                Oh = "\\ud800-\\udfff",
                s6 = "\\u0300-\\u036f",
                i6 = "\\ufe20-\\ufe2f",
                o6 = "\\u20d0-\\u20ff",
                m2 = s6 + i6 + o6,
                g2 = "\\u2700-\\u27bf",
                _2 = "a-z\\xdf-\\xf6\\xf8-\\xff",
                a6 = "\\xac\\xb1\\xd7\\xf7",
                c6 = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
                u6 = "\\u2000-\\u206f",
                l6 = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
                y2 = "A-Z\\xc0-\\xd6\\xd8-\\xde",
                v2 = "\\ufe0e\\ufe0f",
                b2 = a6 + c6 + u6 + l6,
                Um = "[']",
                h6 = "[" + Oh + "]",
                E2 = "[" + b2 + "]",
                Ah = "[" + m2 + "]",
                S2 = "\\d+",
                f6 = "[" + g2 + "]",
                T2 = "[" + _2 + "]",
                w2 = "[^" + Oh + b2 + S2 + g2 + _2 + y2 + "]",
                Bm = "\\ud83c[\\udffb-\\udfff]",
                d6 = "(?:" + Ah + "|" + Bm + ")",
                O2 = "[^" + Oh + "]",
                qm = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                Vm = "[\\ud800-\\udbff][\\udc00-\\udfff]",
                Fa = "[" + y2 + "]",
                A2 = "\\u200d",
                C2 = "(?:" + T2 + "|" + w2 + ")",
                p6 = "(?:" + Fa + "|" + w2 + ")",
                I2 = "(?:" + Um + "(?:d|ll|m|re|s|t|ve))?",
                k2 = "(?:" + Um + "(?:D|LL|M|RE|S|T|VE))?",
                N2 = d6 + "?",
                x2 = "[" + v2 + "]?",
                m6 = "(?:" + A2 + "(?:" + [O2, qm, Vm].join("|") + ")" + x2 + N2 + ")*",
                g6 = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
                _6 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
                P2 = x2 + N2 + m6,
                y6 = "(?:" + [f6, qm, Vm].join("|") + ")" + P2,
                v6 = "(?:" + [O2 + Ah + "?", Ah, qm, Vm, h6].join("|") + ")",
                b6 = RegExp(Um, "g"),
                E6 = RegExp(Ah, "g"),
                jm = RegExp(Bm + "(?=" + Bm + ")|" + v6 + P2, "g"),
                S6 = RegExp([Fa + "?" + T2 + "+" + I2 + "(?=" + [E2, Fa, "$"].join("|") + ")", p6 + "+" + k2 + "(?=" + [E2, Fa + C2, "$"].join("|") + ")", Fa + "?" + C2 + "+" + I2, Fa + "+" + k2, _6, g6, S2, y6].join("|"), "g"),
                T6 = RegExp("[" + A2 + Oh + m2 + v2 + "]"),
                w6 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
                O6 = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
                A6 = -1,
                Zt = {};
            Zt[$] = Zt[te] = Zt[F] = Zt[Q] = Zt[ve] = Zt[Oe] = Zt[xe] = Zt[Fe] = Zt[dn] = !0, Zt[qe] = Zt[Xe] = Zt[dt] = Zt[S] = Zt[U] = Zt[k] = Zt[K] = Zt[A] = Zt[E] = Zt[C] = Zt[Z] = Zt[_e] = Zt[he] = Zt[re] = Zt[De] = !1;
            var Wt = {};
            Wt[qe] = Wt[Xe] = Wt[dt] = Wt[U] = Wt[S] = Wt[k] = Wt[$] = Wt[te] = Wt[F] = Wt[Q] = Wt[ve] = Wt[E] = Wt[C] = Wt[Z] = Wt[_e] = Wt[he] = Wt[re] = Wt[ae] = Wt[Oe] = Wt[xe] = Wt[Fe] = Wt[dn] = !0, Wt[K] = Wt[A] = Wt[De] = !1;
            var C6 = {
                    : "A",
                    : "A",
                    : "A",
                    : "A",
                    : "A",
                    : "A",
                    : "a",
                    : "a",
                    : "a",
                    : "a",
                    : "a",
                    : "a",
                    : "C",
                    : "c",
                    : "D",
                    : "d",
                    : "E",
                    : "E",
                    : "E",
                    : "E",
                    : "e",
                    : "e",
                    : "e",
                    : "e",
                    : "I",
                    : "I",
                    : "I",
                    : "I",
                    : "i",
                    : "i",
                    : "i",
                    : "i",
                    : "N",
                    : "n",
                    : "O",
                    : "O",
                    : "O",
                    : "O",
                    : "O",
                    : "O",
                    : "o",
                    : "o",
                    : "o",
                    : "o",
                    : "o",
                    : "o",
                    : "U",
                    : "U",
                    : "U",
                    : "U",
                    : "u",
                    : "u",
                    : "u",
                    : "u",
                    : "Y",
                    : "y",
                    : "y",
                    : "Ae",
                    : "ae",
                    : "Th",
                    : "th",
                    : "ss",
                    : "A",
                    : "A",
                    : "A",
                    : "a",
                    : "a",
                    : "a",
                    : "C",
                    : "C",
                    : "C",
                    : "C",
                    : "c",
                    : "c",
                    : "c",
                    : "c",
                    : "D",
                    : "D",
                    : "d",
                    : "d",
                    : "E",
                    : "E",
                    : "E",
                    : "E",
                    : "E",
                    : "e",
                    : "e",
                    : "e",
                    : "e",
                    : "e",
                    : "G",
                    : "G",
                    : "G",
                    : "G",
                    : "g",
                    : "g",
                    : "g",
                    : "g",
                    : "H",
                    : "H",
                    : "h",
                    : "h",
                    : "I",
                    : "I",
                    : "I",
                    : "I",
                    : "I",
                    : "i",
                    : "i",
                    : "i",
                    : "i",
                    : "i",
                    : "J",
                    : "j",
                    : "K",
                    : "k",
                    : "k",
                    : "L",
                    : "L",
                    : "L",
                    : "L",
                    : "L",
                    : "l",
                    : "l",
                    : "l",
                    : "l",
                    : "l",
                    : "N",
                    : "N",
                    : "N",
                    : "N",
                    : "n",
                    : "n",
                    : "n",
                    : "n",
                    : "O",
                    : "O",
                    : "O",
                    : "o",
                    : "o",
                    : "o",
                    : "R",
                    : "R",
                    : "R",
                    : "r",
                    : "r",
                    : "r",
                    : "S",
                    : "S",
                    : "S",
                    : "S",
                    : "s",
                    : "s",
                    : "s",
                    : "s",
                    : "T",
                    : "T",
                    : "T",
                    : "t",
                    : "t",
                    : "t",
                    : "U",
                    : "U",
                    : "U",
                    : "U",
                    : "U",
                    : "U",
                    : "u",
                    : "u",
                    : "u",
                    : "u",
                    : "u",
                    : "u",
                    : "W",
                    : "w",
                    : "Y",
                    : "y",
                    : "Y",
                    : "Z",
                    : "Z",
                    : "Z",
                    : "z",
                    : "z",
                    : "z",
                    : "IJ",
                    : "ij",
                    : "Oe",
                    : "oe",
                    : "'n",
                    : "s"
                },
                I6 = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;"
                },
                k6 = {
                    "&amp;": "&",
                    "&lt;": "<",
                    "&gt;": ">",
                    "&quot;": '"',
                    "&#39;": "'"
                },
                N6 = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                },
                x6 = parseFloat,
                P6 = parseInt,
                R2 = typeof hn == "object" && hn && hn.Object === Object && hn,
                R6 = typeof self == "object" && self && self.Object === Object && self,
                Fn = R2 || R6 || Function("return this")(),
                Gm = e && !e.nodeType && e,
                Vo = Gm && !0 && t && !t.nodeType && t,
                M2 = Vo && Vo.exports === Gm,
                Wm = M2 && R2.process,
                Vr = function() {
                    try {
                        var ne = Vo && Vo.require && Vo.require("util").types;
                        return ne || Wm && Wm.binding && Wm.binding("util")
                    } catch {}
                }(),
                D2 = Vr && Vr.isArrayBuffer,
                $2 = Vr && Vr.isDate,
                L2 = Vr && Vr.isMap,
                F2 = Vr && Vr.isRegExp,
                U2 = Vr && Vr.isSet,
                B2 = Vr && Vr.isTypedArray;

            function xr(ne, ye, de) {
                switch (de.length) {
                    case 0:
                        return ne.call(ye);
                    case 1:
                        return ne.call(ye, de[0]);
                    case 2:
                        return ne.call(ye, de[0], de[1]);
                    case 3:
                        return ne.call(ye, de[0], de[1], de[2])
                }
                return ne.apply(ye, de)
            }

            function M6(ne, ye, de, Le) {
                for (var nt = -1, Pt = ne == null ? 0 : ne.length; ++nt < Pt;) {
                    var An = ne[nt];
                    ye(Le, An, de(An), ne)
                }
                return Le
            }

            function jr(ne, ye) {
                for (var de = -1, Le = ne == null ? 0 : ne.length; ++de < Le && ye(ne[de], de, ne) !== !1;);
                return ne
            }

            function D6(ne, ye) {
                for (var de = ne == null ? 0 : ne.length; de-- && ye(ne[de], de, ne) !== !1;);
                return ne
            }

            function q2(ne, ye) {
                for (var de = -1, Le = ne == null ? 0 : ne.length; ++de < Le;)
                    if (!ye(ne[de], de, ne)) return !1;
                return !0
            }

            function ji(ne, ye) {
                for (var de = -1, Le = ne == null ? 0 : ne.length, nt = 0, Pt = []; ++de < Le;) {
                    var An = ne[de];
                    ye(An, de, ne) && (Pt[nt++] = An)
                }
                return Pt
            }

            function Ch(ne, ye) {
                var de = ne == null ? 0 : ne.length;
                return !!de && Ua(ne, ye, 0) > -1
            }

            function Hm(ne, ye, de) {
                for (var Le = -1, nt = ne == null ? 0 : ne.length; ++Le < nt;)
                    if (de(ye, ne[Le])) return !0;
                return !1
            }

            function tn(ne, ye) {
                for (var de = -1, Le = ne == null ? 0 : ne.length, nt = Array(Le); ++de < Le;) nt[de] = ye(ne[de], de, ne);
                return nt
            }

            function Gi(ne, ye) {
                for (var de = -1, Le = ye.length, nt = ne.length; ++de < Le;) ne[nt + de] = ye[de];
                return ne
            }

            function Km(ne, ye, de, Le) {
                var nt = -1,
                    Pt = ne == null ? 0 : ne.length;
                for (Le && Pt && (de = ne[++nt]); ++nt < Pt;) de = ye(de, ne[nt], nt, ne);
                return de
            }

            function $6(ne, ye, de, Le) {
                var nt = ne == null ? 0 : ne.length;
                for (Le && nt && (de = ne[--nt]); nt--;) de = ye(de, ne[nt], nt, ne);
                return de
            }

            function Ym(ne, ye) {
                for (var de = -1, Le = ne == null ? 0 : ne.length; ++de < Le;)
                    if (ye(ne[de], de, ne)) return !0;
                return !1
            }
            var L6 = zm("length");

            function F6(ne) {
                return ne.split("")
            }

            function U6(ne) {
                return ne.match(Kk) || []
            }

            function V2(ne, ye, de) {
                var Le;
                return de(ne, function(nt, Pt, An) {
                    if (ye(nt, Pt, An)) return Le = Pt, !1
                }), Le
            }

            function Ih(ne, ye, de, Le) {
                for (var nt = ne.length, Pt = de + (Le ? 1 : -1); Le ? Pt-- : ++Pt < nt;)
                    if (ye(ne[Pt], Pt, ne)) return Pt;
                return -1
            }

            function Ua(ne, ye, de) {
                return ye === ye ? X6(ne, ye, de) : Ih(ne, j2, de)
            }

            function B6(ne, ye, de, Le) {
                for (var nt = de - 1, Pt = ne.length; ++nt < Pt;)
                    if (Le(ne[nt], ye)) return nt;
                return -1
            }

            function j2(ne) {
                return ne !== ne
            }

            function G2(ne, ye) {
                var de = ne == null ? 0 : ne.length;
                return de ? Xm(ne, ye) / de : ke
            }

            function zm(ne) {
                return function(ye) {
                    return ye == null ? n : ye[ne]
                }
            }

            function Zm(ne) {
                return function(ye) {
                    return ne == null ? n : ne[ye]
                }
            }

            function W2(ne, ye, de, Le, nt) {
                return nt(ne, function(Pt, An, Bt) {
                    de = Le ? (Le = !1, Pt) : ye(de, Pt, An, Bt)
                }), de
            }

            function q6(ne, ye) {
                var de = ne.length;
                for (ne.sort(ye); de--;) ne[de] = ne[de].value;
                return ne
            }

            function Xm(ne, ye) {
                for (var de, Le = -1, nt = ne.length; ++Le < nt;) {
                    var Pt = ye(ne[Le]);
                    Pt !== n && (de = de === n ? Pt : de + Pt)
                }
                return de
            }

            function Qm(ne, ye) {
                for (var de = -1, Le = Array(ne); ++de < ne;) Le[de] = ye(de);
                return Le
            }

            function V6(ne, ye) {
                return tn(ye, function(de) {
                    return [de, ne[de]]
                })
            }

            function H2(ne) {
                return ne && ne.slice(0, Z2(ne) + 1).replace(Fm, "")
            }

            function Pr(ne) {
                return function(ye) {
                    return ne(ye)
                }
            }

            function Jm(ne, ye) {
                return tn(ye, function(de) {
                    return ne[de]
                })
            }

            function Eu(ne, ye) {
                return ne.has(ye)
            }

            function K2(ne, ye) {
                for (var de = -1, Le = ne.length; ++de < Le && Ua(ye, ne[de], 0) > -1;);
                return de
            }

            function Y2(ne, ye) {
                for (var de = ne.length; de-- && Ua(ye, ne[de], 0) > -1;);
                return de
            }

            function j6(ne, ye) {
                for (var de = ne.length, Le = 0; de--;) ne[de] === ye && ++Le;
                return Le
            }
            var G6 = Zm(C6),
                W6 = Zm(I6);

            function H6(ne) {
                return "\\" + N6[ne]
            }

            function K6(ne, ye) {
                return ne == null ? n : ne[ye]
            }

            function Ba(ne) {
                return T6.test(ne)
            }

            function Y6(ne) {
                return w6.test(ne)
            }

            function z6(ne) {
                for (var ye, de = []; !(ye = ne.next()).done;) de.push(ye.value);
                return de
            }

            function eg(ne) {
                var ye = -1,
                    de = Array(ne.size);
                return ne.forEach(function(Le, nt) {
                    de[++ye] = [nt, Le]
                }), de
            }

            function z2(ne, ye) {
                return function(de) {
                    return ne(ye(de))
                }
            }

            function Wi(ne, ye) {
                for (var de = -1, Le = ne.length, nt = 0, Pt = []; ++de < Le;) {
                    var An = ne[de];
                    (An === ye || An === d) && (ne[de] = d, Pt[nt++] = de)
                }
                return Pt
            }

            function kh(ne) {
                var ye = -1,
                    de = Array(ne.size);
                return ne.forEach(function(Le) {
                    de[++ye] = Le
                }), de
            }

            function Z6(ne) {
                var ye = -1,
                    de = Array(ne.size);
                return ne.forEach(function(Le) {
                    de[++ye] = [Le, Le]
                }), de
            }

            function X6(ne, ye, de) {
                for (var Le = de - 1, nt = ne.length; ++Le < nt;)
                    if (ne[Le] === ye) return Le;
                return -1
            }

            function Q6(ne, ye, de) {
                for (var Le = de + 1; Le--;)
                    if (ne[Le] === ye) return Le;
                return Le
            }

            function qa(ne) {
                return Ba(ne) ? eN(ne) : L6(ne)
            }

            function ls(ne) {
                return Ba(ne) ? tN(ne) : F6(ne)
            }

            function Z2(ne) {
                for (var ye = ne.length; ye-- && jk.test(ne.charAt(ye)););
                return ye
            }
            var J6 = Zm(k6);

            function eN(ne) {
                for (var ye = jm.lastIndex = 0; jm.test(ne);) ++ye;
                return ye
            }

            function tN(ne) {
                return ne.match(jm) || []
            }

            function nN(ne) {
                return ne.match(S6) || []
            }
            var rN = function ne(ye) {
                    ye = ye == null ? Fn : Va.defaults(Fn.Object(), ye, Va.pick(Fn, O6));
                    var de = ye.Array,
                        Le = ye.Date,
                        nt = ye.Error,
                        Pt = ye.Function,
                        An = ye.Math,
                        Bt = ye.Object,
                        tg = ye.RegExp,
                        sN = ye.String,
                        Gr = ye.TypeError,
                        Nh = de.prototype,
                        iN = Pt.prototype,
                        ja = Bt.prototype,
                        xh = ye["__core-js_shared__"],
                        Ph = iN.toString,
                        Dt = ja.hasOwnProperty,
                        oN = 0,
                        X2 = function() {
                            var o = /[^.]+$/.exec(xh && xh.keys && xh.keys.IE_PROTO || "");
                            return o ? "Symbol(src)_1." + o : ""
                        }(),
                        Rh = ja.toString,
                        aN = Ph.call(Bt),
                        cN = Fn._,
                        uN = tg("^" + Ph.call(Dt).replace(Lm, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                        Mh = M2 ? ye.Buffer : n,
                        Hi = ye.Symbol,
                        Dh = ye.Uint8Array,
                        Q2 = Mh ? Mh.allocUnsafe : n,
                        $h = z2(Bt.getPrototypeOf, Bt),
                        J2 = Bt.create,
                        eb = ja.propertyIsEnumerable,
                        Lh = Nh.splice,
                        tb = Hi ? Hi.isConcatSpreadable : n,
                        Su = Hi ? Hi.iterator : n,
                        jo = Hi ? Hi.toStringTag : n,
                        Fh = function() {
                            try {
                                var o = Yo(Bt, "defineProperty");
                                return o({}, "", {}), o
                            } catch {}
                        }(),
                        lN = ye.clearTimeout !== Fn.clearTimeout && ye.clearTimeout,
                        hN = Le && Le.now !== Fn.Date.now && Le.now,
                        fN = ye.setTimeout !== Fn.setTimeout && ye.setTimeout,
                        Uh = An.ceil,
                        Bh = An.floor,
                        ng = Bt.getOwnPropertySymbols,
                        dN = Mh ? Mh.isBuffer : n,
                        nb = ye.isFinite,
                        pN = Nh.join,
                        mN = z2(Bt.keys, Bt),
                        Cn = An.max,
                        zn = An.min,
                        gN = Le.now,
                        _N = ye.parseInt,
                        rb = An.random,
                        yN = Nh.reverse,
                        rg = Yo(ye, "DataView"),
                        Tu = Yo(ye, "Map"),
                        sg = Yo(ye, "Promise"),
                        Ga = Yo(ye, "Set"),
                        wu = Yo(ye, "WeakMap"),
                        Ou = Yo(Bt, "create"),
                        qh = wu && new wu,
                        Wa = {},
                        vN = zo(rg),
                        bN = zo(Tu),
                        EN = zo(sg),
                        SN = zo(Ga),
                        TN = zo(wu),
                        Vh = Hi ? Hi.prototype : n,
                        Au = Vh ? Vh.valueOf : n,
                        sb = Vh ? Vh.toString : n;

                    function N(o) {
                        if (cn(o) && !st(o) && !(o instanceof bt)) {
                            if (o instanceof Wr) return o;
                            if (Dt.call(o, "__wrapped__")) return iE(o)
                        }
                        return new Wr(o)
                    }
                    var Ha = function() {
                        function o() {}
                        return function(u) {
                            if (!an(u)) return {};
                            if (J2) return J2(u);
                            o.prototype = u;
                            var f = new o;
                            return o.prototype = n, f
                        }
                    }();

                    function jh() {}

                    function Wr(o, u) {
                        this.__wrapped__ = o, this.__actions__ = [], this.__chain__ = !!u, this.__index__ = 0, this.__values__ = n
                    }
                    N.templateSettings = {
                        escape: Lk,
                        evaluate: Fk,
                        interpolate: d2,
                        variable: "",
                        imports: {
                            _: N
                        }
                    }, N.prototype = jh.prototype, N.prototype.constructor = N, Wr.prototype = Ha(jh.prototype), Wr.prototype.constructor = Wr;

                    function bt(o) {
                        this.__wrapped__ = o, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = Ie, this.__views__ = []
                    }

                    function wN() {
                        var o = new bt(this.__wrapped__);
                        return o.__actions__ = gr(this.__actions__), o.__dir__ = this.__dir__, o.__filtered__ = this.__filtered__, o.__iteratees__ = gr(this.__iteratees__), o.__takeCount__ = this.__takeCount__, o.__views__ = gr(this.__views__), o
                    }

                    function ON() {
                        if (this.__filtered__) {
                            var o = new bt(this);
                            o.__dir__ = -1, o.__filtered__ = !0
                        } else o = this.clone(), o.__dir__ *= -1;
                        return o
                    }

                    function AN() {
                        var o = this.__wrapped__.value(),
                            u = this.__dir__,
                            f = st(o),
                            _ = u < 0,
                            O = f ? o.length : 0,
                            R = F7(0, O, this.__views__),
                            j = R.start,
                            z = R.end,
                            ie = z - j,
                            Ee = _ ? z : j - 1,
                            Se = this.__iteratees__,
                            Ae = Se.length,
                            Pe = 0,
                            Ue = zn(ie, this.__takeCount__);
                        if (!f || !_ && O == ie && Ue == ie) return Ib(o, this.__actions__);
                        var ze = [];
                        e: for (; ie-- && Pe < Ue;) {
                            Ee += u;
                            for (var ht = -1, Ze = o[Ee]; ++ht < Ae;) {
                                var vt = Se[ht],
                                    wt = vt.iteratee,
                                    Dr = vt.type,
                                    cr = wt(Ze);
                                if (Dr == le) Ze = cr;
                                else if (!cr) {
                                    if (Dr == G) continue e;
                                    break e
                                }
                            }
                            ze[Pe++] = Ze
                        }
                        return ze
                    }
                    bt.prototype = Ha(jh.prototype), bt.prototype.constructor = bt;

                    function Go(o) {
                        var u = -1,
                            f = o == null ? 0 : o.length;
                        for (this.clear(); ++u < f;) {
                            var _ = o[u];
                            this.set(_[0], _[1])
                        }
                    }

                    function CN() {
                        this.__data__ = Ou ? Ou(null) : {}, this.size = 0
                    }

                    function IN(o) {
                        var u = this.has(o) && delete this.__data__[o];
                        return this.size -= u ? 1 : 0, u
                    }

                    function kN(o) {
                        var u = this.__data__;
                        if (Ou) {
                            var f = u[o];
                            return f === l ? n : f
                        }
                        return Dt.call(u, o) ? u[o] : n
                    }

                    function NN(o) {
                        var u = this.__data__;
                        return Ou ? u[o] !== n : Dt.call(u, o)
                    }

                    function xN(o, u) {
                        var f = this.__data__;
                        return this.size += this.has(o) ? 0 : 1, f[o] = Ou && u === n ? l : u, this
                    }
                    Go.prototype.clear = CN, Go.prototype.delete = IN, Go.prototype.get = kN, Go.prototype.has = NN, Go.prototype.set = xN;

                    function ui(o) {
                        var u = -1,
                            f = o == null ? 0 : o.length;
                        for (this.clear(); ++u < f;) {
                            var _ = o[u];
                            this.set(_[0], _[1])
                        }
                    }

                    function PN() {
                        this.__data__ = [], this.size = 0
                    }

                    function RN(o) {
                        var u = this.__data__,
                            f = Gh(u, o);
                        if (f < 0) return !1;
                        var _ = u.length - 1;
                        return f == _ ? u.pop() : Lh.call(u, f, 1), --this.size, !0
                    }

                    function MN(o) {
                        var u = this.__data__,
                            f = Gh(u, o);
                        return f < 0 ? n : u[f][1]
                    }

                    function DN(o) {
                        return Gh(this.__data__, o) > -1
                    }

                    function $N(o, u) {
                        var f = this.__data__,
                            _ = Gh(f, o);
                        return _ < 0 ? (++this.size, f.push([o, u])) : f[_][1] = u, this
                    }
                    ui.prototype.clear = PN, ui.prototype.delete = RN, ui.prototype.get = MN, ui.prototype.has = DN, ui.prototype.set = $N;

                    function li(o) {
                        var u = -1,
                            f = o == null ? 0 : o.length;
                        for (this.clear(); ++u < f;) {
                            var _ = o[u];
                            this.set(_[0], _[1])
                        }
                    }

                    function LN() {
                        this.size = 0, this.__data__ = {
                            hash: new Go,
                            map: new(Tu || ui),
                            string: new Go
                        }
                    }

                    function FN(o) {
                        var u = nf(this, o).delete(o);
                        return this.size -= u ? 1 : 0, u
                    }

                    function UN(o) {
                        return nf(this, o).get(o)
                    }

                    function BN(o) {
                        return nf(this, o).has(o)
                    }

                    function qN(o, u) {
                        var f = nf(this, o),
                            _ = f.size;
                        return f.set(o, u), this.size += f.size == _ ? 0 : 1, this
                    }
                    li.prototype.clear = LN, li.prototype.delete = FN, li.prototype.get = UN, li.prototype.has = BN, li.prototype.set = qN;

                    function Wo(o) {
                        var u = -1,
                            f = o == null ? 0 : o.length;
                        for (this.__data__ = new li; ++u < f;) this.add(o[u])
                    }

                    function VN(o) {
                        return this.__data__.set(o, l), this
                    }

                    function jN(o) {
                        return this.__data__.has(o)
                    }
                    Wo.prototype.add = Wo.prototype.push = VN, Wo.prototype.has = jN;

                    function hs(o) {
                        var u = this.__data__ = new ui(o);
                        this.size = u.size
                    }

                    function GN() {
                        this.__data__ = new ui, this.size = 0
                    }

                    function WN(o) {
                        var u = this.__data__,
                            f = u.delete(o);
                        return this.size = u.size, f
                    }

                    function HN(o) {
                        return this.__data__.get(o)
                    }

                    function KN(o) {
                        return this.__data__.has(o)
                    }

                    function YN(o, u) {
                        var f = this.__data__;
                        if (f instanceof ui) {
                            var _ = f.__data__;
                            if (!Tu || _.length < s - 1) return _.push([o, u]), this.size = ++f.size, this;
                            f = this.__data__ = new li(_)
                        }
                        return f.set(o, u), this.size = f.size, this
                    }
                    hs.prototype.clear = GN, hs.prototype.delete = WN, hs.prototype.get = HN, hs.prototype.has = KN, hs.prototype.set = YN;

                    function ib(o, u) {
                        var f = st(o),
                            _ = !f && Zo(o),
                            O = !f && !_ && Xi(o),
                            R = !f && !_ && !O && Za(o),
                            j = f || _ || O || R,
                            z = j ? Qm(o.length, sN) : [],
                            ie = z.length;
                        for (var Ee in o)(u || Dt.call(o, Ee)) && !(j && (Ee == "length" || O && (Ee == "offset" || Ee == "parent") || R && (Ee == "buffer" || Ee == "byteLength" || Ee == "byteOffset") || pi(Ee, ie))) && z.push(Ee);
                        return z
                    }

                    function ob(o) {
                        var u = o.length;
                        return u ? o[mg(0, u - 1)] : n
                    }

                    function zN(o, u) {
                        return rf(gr(o), Ho(u, 0, o.length))
                    }

                    function ZN(o) {
                        return rf(gr(o))
                    }

                    function ig(o, u, f) {
                        (f !== n && !fs(o[u], f) || f === n && !(u in o)) && hi(o, u, f)
                    }

                    function Cu(o, u, f) {
                        var _ = o[u];
                        (!(Dt.call(o, u) && fs(_, f)) || f === n && !(u in o)) && hi(o, u, f)
                    }

                    function Gh(o, u) {
                        for (var f = o.length; f--;)
                            if (fs(o[f][0], u)) return f;
                        return -1
                    }

                    function XN(o, u, f, _) {
                        return Ki(o, function(O, R, j) {
                            u(_, O, f(O), j)
                        }), _
                    }

                    function ab(o, u) {
                        return o && Us(u, Mn(u), o)
                    }

                    function QN(o, u) {
                        return o && Us(u, yr(u), o)
                    }

                    function hi(o, u, f) {
                        u == "__proto__" && Fh ? Fh(o, u, {
                            configurable: !0,
                            enumerable: !0,
                            value: f,
                            writable: !0
                        }) : o[u] = f
                    }

                    function og(o, u) {
                        for (var f = -1, _ = u.length, O = de(_), R = o == null; ++f < _;) O[f] = R ? n : Bg(o, u[f]);
                        return O
                    }

                    function Ho(o, u, f) {
                        return o === o && (f !== n && (o = o <= f ? o : f), u !== n && (o = o >= u ? o : u)), o
                    }

                    function Hr(o, u, f, _, O, R) {
                        var j, z = u & p,
                            ie = u & g,
                            Ee = u & v;
                        if (f && (j = O ? f(o, _, O, R) : f(o)), j !== n) return j;
                        if (!an(o)) return o;
                        var Se = st(o);
                        if (Se) {
                            if (j = B7(o), !z) return gr(o, j)
                        } else {
                            var Ae = Zn(o),
                                Pe = Ae == A || Ae == y;
                            if (Xi(o)) return xb(o, z);
                            if (Ae == Z || Ae == qe || Pe && !O) {
                                if (j = ie || Pe ? {} : Zb(o), !z) return ie ? k7(o, QN(j, o)) : I7(o, ab(j, o))
                            } else {
                                if (!Wt[Ae]) return O ? o : {};
                                j = q7(o, Ae, z)
                            }
                        }
                        R || (R = new hs);
                        var Ue = R.get(o);
                        if (Ue) return Ue;
                        R.set(o, j), OE(o) ? o.forEach(function(Ze) {
                            j.add(Hr(Ze, u, f, Ze, o, R))
                        }) : TE(o) && o.forEach(function(Ze, vt) {
                            j.set(vt, Hr(Ze, u, f, vt, o, R))
                        });
                        var ze = Ee ? ie ? Ag : Og : ie ? yr : Mn,
                            ht = Se ? n : ze(o);
                        return jr(ht || o, function(Ze, vt) {
                            ht && (vt = Ze, Ze = o[vt]), Cu(j, vt, Hr(Ze, u, f, vt, o, R))
                        }), j
                    }

                    function JN(o) {
                        var u = Mn(o);
                        return function(f) {
                            return cb(f, o, u)
                        }
                    }

                    function cb(o, u, f) {
                        var _ = f.length;
                        if (o == null) return !_;
                        for (o = Bt(o); _--;) {
                            var O = f[_],
                                R = u[O],
                                j = o[O];
                            if (j === n && !(O in o) || !R(j)) return !1
                        }
                        return !0
                    }

                    function ub(o, u, f) {
                        if (typeof o != "function") throw new Gr(a);
                        return Mu(function() {
                            o.apply(n, f)
                        }, u)
                    }

                    function Iu(o, u, f, _) {
                        var O = -1,
                            R = Ch,
                            j = !0,
                            z = o.length,
                            ie = [],
                            Ee = u.length;
                        if (!z) return ie;
                        f && (u = tn(u, Pr(f))), _ ? (R = Hm, j = !1) : u.length >= s && (R = Eu, j = !1, u = new Wo(u));
                        e: for (; ++O < z;) {
                            var Se = o[O],
                                Ae = f == null ? Se : f(Se);
                            if (Se = _ || Se !== 0 ? Se : 0, j && Ae === Ae) {
                                for (var Pe = Ee; Pe--;)
                                    if (u[Pe] === Ae) continue e;
                                ie.push(Se)
                            } else R(u, Ae, _) || ie.push(Se)
                        }
                        return ie
                    }
                    var Ki = $b(Fs),
                        lb = $b(cg, !0);

                    function e7(o, u) {
                        var f = !0;
                        return Ki(o, function(_, O, R) {
                            return f = !!u(_, O, R), f
                        }), f
                    }

                    function Wh(o, u, f) {
                        for (var _ = -1, O = o.length; ++_ < O;) {
                            var R = o[_],
                                j = u(R);
                            if (j != null && (z === n ? j === j && !Mr(j) : f(j, z))) var z = j,
                                ie = R
                        }
                        return ie
                    }

                    function t7(o, u, f, _) {
                        var O = o.length;
                        for (f = ut(f), f < 0 && (f = -f > O ? 0 : O + f), _ = _ === n || _ > O ? O : ut(_), _ < 0 && (_ += O), _ = f > _ ? 0 : CE(_); f < _;) o[f++] = u;
                        return o
                    }

                    function hb(o, u) {
                        var f = [];
                        return Ki(o, function(_, O, R) {
                            u(_, O, R) && f.push(_)
                        }), f
                    }

                    function Un(o, u, f, _, O) {
                        var R = -1,
                            j = o.length;
                        for (f || (f = j7), O || (O = []); ++R < j;) {
                            var z = o[R];
                            u > 0 && f(z) ? u > 1 ? Un(z, u - 1, f, _, O) : Gi(O, z) : _ || (O[O.length] = z)
                        }
                        return O
                    }
                    var ag = Lb(),
                        fb = Lb(!0);

                    function Fs(o, u) {
                        return o && ag(o, u, Mn)
                    }

                    function cg(o, u) {
                        return o && fb(o, u, Mn)
                    }

                    function Hh(o, u) {
                        return ji(u, function(f) {
                            return mi(o[f])
                        })
                    }

                    function Ko(o, u) {
                        u = zi(u, o);
                        for (var f = 0, _ = u.length; o != null && f < _;) o = o[Bs(u[f++])];
                        return f && f == _ ? o : n
                    }

                    function db(o, u, f) {
                        var _ = u(o);
                        return st(o) ? _ : Gi(_, f(o))
                    }

                    function or(o) {
                        return o == null ? o === n ? Re : D : jo && jo in Bt(o) ? L7(o) : Z7(o)
                    }

                    function ug(o, u) {
                        return o > u
                    }

                    function n7(o, u) {
                        return o != null && Dt.call(o, u)
                    }

                    function r7(o, u) {
                        return o != null && u in Bt(o)
                    }

                    function s7(o, u, f) {
                        return o >= zn(u, f) && o < Cn(u, f)
                    }

                    function lg(o, u, f) {
                        for (var _ = f ? Hm : Ch, O = o[0].length, R = o.length, j = R, z = de(R), ie = 1 / 0, Ee = []; j--;) {
                            var Se = o[j];
                            j && u && (Se = tn(Se, Pr(u))), ie = zn(Se.length, ie), z[j] = !f && (u || O >= 120 && Se.length >= 120) ? new Wo(j && Se) : n
                        }
                        Se = o[0];
                        var Ae = -1,
                            Pe = z[0];
                        e: for (; ++Ae < O && Ee.length < ie;) {
                            var Ue = Se[Ae],
                                ze = u ? u(Ue) : Ue;
                            if (Ue = f || Ue !== 0 ? Ue : 0, !(Pe ? Eu(Pe, ze) : _(Ee, ze, f))) {
                                for (j = R; --j;) {
                                    var ht = z[j];
                                    if (!(ht ? Eu(ht, ze) : _(o[j], ze, f))) continue e
                                }
                                Pe && Pe.push(ze), Ee.push(Ue)
                            }
                        }
                        return Ee
                    }

                    function i7(o, u, f, _) {
                        return Fs(o, function(O, R, j) {
                            u(_, f(O), R, j)
                        }), _
                    }

                    function ku(o, u, f) {
                        u = zi(u, o), o = eE(o, u);
                        var _ = o == null ? o : o[Bs(Yr(u))];
                        return _ == null ? n : xr(_, o, f)
                    }

                    function pb(o) {
                        return cn(o) && or(o) == qe
                    }

                    function o7(o) {
                        return cn(o) && or(o) == dt
                    }

                    function a7(o) {
                        return cn(o) && or(o) == k
                    }

                    function Nu(o, u, f, _, O) {
                        return o === u ? !0 : o == null || u == null || !cn(o) && !cn(u) ? o !== o && u !== u : c7(o, u, f, _, Nu, O)
                    }

                    function c7(o, u, f, _, O, R) {
                        var j = st(o),
                            z = st(u),
                            ie = j ? Xe : Zn(o),
                            Ee = z ? Xe : Zn(u);
                        ie = ie == qe ? Z : ie, Ee = Ee == qe ? Z : Ee;
                        var Se = ie == Z,
                            Ae = Ee == Z,
                            Pe = ie == Ee;
                        if (Pe && Xi(o)) {
                            if (!Xi(u)) return !1;
                            j = !0, Se = !1
                        }
                        if (Pe && !Se) return R || (R = new hs), j || Za(o) ? Kb(o, u, f, _, O, R) : D7(o, u, ie, f, _, O, R);
                        if (!(f & b)) {
                            var Ue = Se && Dt.call(o, "__wrapped__"),
                                ze = Ae && Dt.call(u, "__wrapped__");
                            if (Ue || ze) {
                                var ht = Ue ? o.value() : o,
                                    Ze = ze ? u.value() : u;
                                return R || (R = new hs), O(ht, Ze, f, _, R)
                            }
                        }
                        return Pe ? (R || (R = new hs), $7(o, u, f, _, O, R)) : !1
                    }

                    function u7(o) {
                        return cn(o) && Zn(o) == E
                    }

                    function hg(o, u, f, _) {
                        var O = f.length,
                            R = O,
                            j = !_;
                        if (o == null) return !R;
                        for (o = Bt(o); O--;) {
                            var z = f[O];
                            if (j && z[2] ? z[1] !== o[z[0]] : !(z[0] in o)) return !1
                        }
                        for (; ++O < R;) {
                            z = f[O];
                            var ie = z[0],
                                Ee = o[ie],
                                Se = z[1];
                            if (j && z[2]) {
                                if (Ee === n && !(ie in o)) return !1
                            } else {
                                var Ae = new hs;
                                if (_) var Pe = _(Ee, Se, ie, o, u, Ae);
                                if (!(Pe === n ? Nu(Se, Ee, b | T, _, Ae) : Pe)) return !1
                            }
                        }
                        return !0
                    }

                    function mb(o) {
                        if (!an(o) || W7(o)) return !1;
                        var u = mi(o) ? uN : Jk;
                        return u.test(zo(o))
                    }

                    function l7(o) {
                        return cn(o) && or(o) == _e
                    }

                    function h7(o) {
                        return cn(o) && Zn(o) == he
                    }

                    function f7(o) {
                        return cn(o) && lf(o.length) && !!Zt[or(o)]
                    }

                    function gb(o) {
                        return typeof o == "function" ? o : o == null ? vr : typeof o == "object" ? st(o) ? vb(o[0], o[1]) : yb(o) : FE(o)
                    }

                    function fg(o) {
                        if (!Ru(o)) return mN(o);
                        var u = [];
                        for (var f in Bt(o)) Dt.call(o, f) && f != "constructor" && u.push(f);
                        return u
                    }

                    function d7(o) {
                        if (!an(o)) return z7(o);
                        var u = Ru(o),
                            f = [];
                        for (var _ in o) _ == "constructor" && (u || !Dt.call(o, _)) || f.push(_);
                        return f
                    }

                    function dg(o, u) {
                        return o < u
                    }

                    function _b(o, u) {
                        var f = -1,
                            _ = _r(o) ? de(o.length) : [];
                        return Ki(o, function(O, R, j) {
                            _[++f] = u(O, R, j)
                        }), _
                    }

                    function yb(o) {
                        var u = Ig(o);
                        return u.length == 1 && u[0][2] ? Qb(u[0][0], u[0][1]) : function(f) {
                            return f === o || hg(f, o, u)
                        }
                    }

                    function vb(o, u) {
                        return Ng(o) && Xb(u) ? Qb(Bs(o), u) : function(f) {
                            var _ = Bg(f, o);
                            return _ === n && _ === u ? qg(f, o) : Nu(u, _, b | T)
                        }
                    }

                    function Kh(o, u, f, _, O) {
                        o !== u && ag(u, function(R, j) {
                            if (O || (O = new hs), an(R)) p7(o, u, j, f, Kh, _, O);
                            else {
                                var z = _ ? _(Pg(o, j), R, j + "", o, u, O) : n;
                                z === n && (z = R), ig(o, j, z)
                            }
                        }, yr)
                    }

                    function p7(o, u, f, _, O, R, j) {
                        var z = Pg(o, f),
                            ie = Pg(u, f),
                            Ee = j.get(ie);
                        if (Ee) {
                            ig(o, f, Ee);
                            return
                        }
                        var Se = R ? R(z, ie, f + "", o, u, j) : n,
                            Ae = Se === n;
                        if (Ae) {
                            var Pe = st(ie),
                                Ue = !Pe && Xi(ie),
                                ze = !Pe && !Ue && Za(ie);
                            Se = ie, Pe || Ue || ze ? st(z) ? Se = z : pn(z) ? Se = gr(z) : Ue ? (Ae = !1, Se = xb(ie, !0)) : ze ? (Ae = !1, Se = Pb(ie, !0)) : Se = [] : Du(ie) || Zo(ie) ? (Se = z, Zo(z) ? Se = IE(z) : (!an(z) || mi(z)) && (Se = Zb(ie))) : Ae = !1
                        }
                        Ae && (j.set(ie, Se), O(Se, ie, _, R, j), j.delete(ie)), ig(o, f, Se)
                    }

                    function bb(o, u) {
                        var f = o.length;
                        if (f) return u += u < 0 ? f : 0, pi(u, f) ? o[u] : n
                    }

                    function Eb(o, u, f) {
                        u.length ? u = tn(u, function(R) {
                            return st(R) ? function(j) {
                                return Ko(j, R.length === 1 ? R[0] : R)
                            } : R
                        }) : u = [vr];
                        var _ = -1;
                        u = tn(u, Pr(He()));
                        var O = _b(o, function(R, j, z) {
                            var ie = tn(u, function(Ee) {
                                return Ee(R)
                            });
                            return {
                                criteria: ie,
                                index: ++_,
                                value: R
                            }
                        });
                        return q6(O, function(R, j) {
                            return C7(R, j, f)
                        })
                    }

                    function m7(o, u) {
                        return Sb(o, u, function(f, _) {
                            return qg(o, _)
                        })
                    }

                    function Sb(o, u, f) {
                        for (var _ = -1, O = u.length, R = {}; ++_ < O;) {
                            var j = u[_],
                                z = Ko(o, j);
                            f(z, j) && xu(R, zi(j, o), z)
                        }
                        return R
                    }

                    function g7(o) {
                        return function(u) {
                            return Ko(u, o)
                        }
                    }

                    function pg(o, u, f, _) {
                        var O = _ ? B6 : Ua,
                            R = -1,
                            j = u.length,
                            z = o;
                        for (o === u && (u = gr(u)), f && (z = tn(o, Pr(f))); ++R < j;)
                            for (var ie = 0, Ee = u[R], Se = f ? f(Ee) : Ee;
                                (ie = O(z, Se, ie, _)) > -1;) z !== o && Lh.call(z, ie, 1), Lh.call(o, ie, 1);
                        return o
                    }

                    function Tb(o, u) {
                        for (var f = o ? u.length : 0, _ = f - 1; f--;) {
                            var O = u[f];
                            if (f == _ || O !== R) {
                                var R = O;
                                pi(O) ? Lh.call(o, O, 1) : yg(o, O)
                            }
                        }
                        return o
                    }

                    function mg(o, u) {
                        return o + Bh(rb() * (u - o + 1))
                    }

                    function _7(o, u, f, _) {
                        for (var O = -1, R = Cn(Uh((u - o) / (f || 1)), 0), j = de(R); R--;) j[_ ? R : ++O] = o, o += f;
                        return j
                    }

                    function gg(o, u) {
                        var f = "";
                        if (!o || u < 1 || u > Te) return f;
                        do u % 2 && (f += o), u = Bh(u / 2), u && (o += o); while (u);
                        return f
                    }

                    function pt(o, u) {
                        return Rg(Jb(o, u, vr), o + "")
                    }

                    function y7(o) {
                        return ob(Xa(o))
                    }

                    function v7(o, u) {
                        var f = Xa(o);
                        return rf(f, Ho(u, 0, f.length))
                    }

                    function xu(o, u, f, _) {
                        if (!an(o)) return o;
                        u = zi(u, o);
                        for (var O = -1, R = u.length, j = R - 1, z = o; z != null && ++O < R;) {
                            var ie = Bs(u[O]),
                                Ee = f;
                            if (ie === "__proto__" || ie === "constructor" || ie === "prototype") return o;
                            if (O != j) {
                                var Se = z[ie];
                                Ee = _ ? _(Se, ie, z) : n, Ee === n && (Ee = an(Se) ? Se : pi(u[O + 1]) ? [] : {})
                            }
                            Cu(z, ie, Ee), z = z[ie]
                        }
                        return o
                    }
                    var wb = qh ? function(o, u) {
                            return qh.set(o, u), o
                        } : vr,
                        b7 = Fh ? function(o, u) {
                            return Fh(o, "toString", {
                                configurable: !0,
                                enumerable: !1,
                                value: jg(u),
                                writable: !0
                            })
                        } : vr;

                    function E7(o) {
                        return rf(Xa(o))
                    }

                    function Kr(o, u, f) {
                        var _ = -1,
                            O = o.length;
                        u < 0 && (u = -u > O ? 0 : O + u), f = f > O ? O : f, f < 0 && (f += O), O = u > f ? 0 : f - u >>> 0, u >>>= 0;
                        for (var R = de(O); ++_ < O;) R[_] = o[_ + u];
                        return R
                    }

                    function S7(o, u) {
                        var f;
                        return Ki(o, function(_, O, R) {
                            return f = u(_, O, R), !f
                        }), !!f
                    }

                    function Yh(o, u, f) {
                        var _ = 0,
                            O = o == null ? _ : o.length;
                        if (typeof u == "number" && u === u && O <= At) {
                            for (; _ < O;) {
                                var R = _ + O >>> 1,
                                    j = o[R];
                                j !== null && !Mr(j) && (f ? j <= u : j < u) ? _ = R + 1 : O = R
                            }
                            return O
                        }
                        return _g(o, u, vr, f)
                    }

                    function _g(o, u, f, _) {
                        var O = 0,
                            R = o == null ? 0 : o.length;
                        if (R === 0) return 0;
                        u = f(u);
                        for (var j = u !== u, z = u === null, ie = Mr(u), Ee = u === n; O < R;) {
                            var Se = Bh((O + R) / 2),
                                Ae = f(o[Se]),
                                Pe = Ae !== n,
                                Ue = Ae === null,
                                ze = Ae === Ae,
                                ht = Mr(Ae);
                            if (j) var Ze = _ || ze;
                            else Ee ? Ze = ze && (_ || Pe) : z ? Ze = ze && Pe && (_ || !Ue) : ie ? Ze = ze && Pe && !Ue && (_ || !ht) : Ue || ht ? Ze = !1 : Ze = _ ? Ae <= u : Ae < u;
                            Ze ? O = Se + 1 : R = Se
                        }
                        return zn(R, $e)
                    }

                    function Ob(o, u) {
                        for (var f = -1, _ = o.length, O = 0, R = []; ++f < _;) {
                            var j = o[f],
                                z = u ? u(j) : j;
                            if (!f || !fs(z, ie)) {
                                var ie = z;
                                R[O++] = j === 0 ? 0 : j
                            }
                        }
                        return R
                    }

                    function Ab(o) {
                        return typeof o == "number" ? o : Mr(o) ? ke : +o
                    }

                    function Rr(o) {
                        if (typeof o == "string") return o;
                        if (st(o)) return tn(o, Rr) + "";
                        if (Mr(o)) return sb ? sb.call(o) : "";
                        var u = o + "";
                        return u == "0" && 1 / o == -me ? "-0" : u
                    }

                    function Yi(o, u, f) {
                        var _ = -1,
                            O = Ch,
                            R = o.length,
                            j = !0,
                            z = [],
                            ie = z;
                        if (f) j = !1, O = Hm;
                        else if (R >= s) {
                            var Ee = u ? null : R7(o);
                            if (Ee) return kh(Ee);
                            j = !1, O = Eu, ie = new Wo
                        } else ie = u ? [] : z;
                        e: for (; ++_ < R;) {
                            var Se = o[_],
                                Ae = u ? u(Se) : Se;
                            if (Se = f || Se !== 0 ? Se : 0, j && Ae === Ae) {
                                for (var Pe = ie.length; Pe--;)
                                    if (ie[Pe] === Ae) continue e;
                                u && ie.push(Ae), z.push(Se)
                            } else O(ie, Ae, f) || (ie !== z && ie.push(Ae), z.push(Se))
                        }
                        return z
                    }

                    function yg(o, u) {
                        return u = zi(u, o), o = eE(o, u), o == null || delete o[Bs(Yr(u))]
                    }

                    function Cb(o, u, f, _) {
                        return xu(o, u, f(Ko(o, u)), _)
                    }

                    function zh(o, u, f, _) {
                        for (var O = o.length, R = _ ? O : -1;
                            (_ ? R-- : ++R < O) && u(o[R], R, o););
                        return f ? Kr(o, _ ? 0 : R, _ ? R + 1 : O) : Kr(o, _ ? R + 1 : 0, _ ? O : R)
                    }

                    function Ib(o, u) {
                        var f = o;
                        return f instanceof bt && (f = f.value()), Km(u, function(_, O) {
                            return O.func.apply(O.thisArg, Gi([_], O.args))
                        }, f)
                    }

                    function vg(o, u, f) {
                        var _ = o.length;
                        if (_ < 2) return _ ? Yi(o[0]) : [];
                        for (var O = -1, R = de(_); ++O < _;)
                            for (var j = o[O], z = -1; ++z < _;) z != O && (R[O] = Iu(R[O] || j, o[z], u, f));
                        return Yi(Un(R, 1), u, f)
                    }

                    function kb(o, u, f) {
                        for (var _ = -1, O = o.length, R = u.length, j = {}; ++_ < O;) {
                            var z = _ < R ? u[_] : n;
                            f(j, o[_], z)
                        }
                        return j
                    }

                    function bg(o) {
                        return pn(o) ? o : []
                    }

                    function Eg(o) {
                        return typeof o == "function" ? o : vr
                    }

                    function zi(o, u) {
                        return st(o) ? o : Ng(o, u) ? [o] : sE(Rt(o))
                    }
                    var T7 = pt;

                    function Zi(o, u, f) {
                        var _ = o.length;
                        return f = f === n ? _ : f, !u && f >= _ ? o : Kr(o, u, f)
                    }
                    var Nb = lN || function(o) {
                        return Fn.clearTimeout(o)
                    };

                    function xb(o, u) {
                        if (u) return o.slice();
                        var f = o.length,
                            _ = Q2 ? Q2(f) : new o.constructor(f);
                        return o.copy(_), _
                    }

                    function Sg(o) {
                        var u = new o.constructor(o.byteLength);
                        return new Dh(u).set(new Dh(o)), u
                    }

                    function w7(o, u) {
                        var f = u ? Sg(o.buffer) : o.buffer;
                        return new o.constructor(f, o.byteOffset, o.byteLength)
                    }

                    function O7(o) {
                        var u = new o.constructor(o.source, p2.exec(o));
                        return u.lastIndex = o.lastIndex, u
                    }

                    function A7(o) {
                        return Au ? Bt(Au.call(o)) : {}
                    }

                    function Pb(o, u) {
                        var f = u ? Sg(o.buffer) : o.buffer;
                        return new o.constructor(f, o.byteOffset, o.length)
                    }

                    function Rb(o, u) {
                        if (o !== u) {
                            var f = o !== n,
                                _ = o === null,
                                O = o === o,
                                R = Mr(o),
                                j = u !== n,
                                z = u === null,
                                ie = u === u,
                                Ee = Mr(u);
                            if (!z && !Ee && !R && o > u || R && j && ie && !z && !Ee || _ && j && ie || !f && ie || !O) return 1;
                            if (!_ && !R && !Ee && o < u || Ee && f && O && !_ && !R || z && f && O || !j && O || !ie) return -1
                        }
                        return 0
                    }

                    function C7(o, u, f) {
                        for (var _ = -1, O = o.criteria, R = u.criteria, j = O.length, z = f.length; ++_ < j;) {
                            var ie = Rb(O[_], R[_]);
                            if (ie) {
                                if (_ >= z) return ie;
                                var Ee = f[_];
                                return ie * (Ee == "desc" ? -1 : 1)
                            }
                        }
                        return o.index - u.index
                    }

                    function Mb(o, u, f, _) {
                        for (var O = -1, R = o.length, j = f.length, z = -1, ie = u.length, Ee = Cn(R - j, 0), Se = de(ie + Ee), Ae = !_; ++z < ie;) Se[z] = u[z];
                        for (; ++O < j;)(Ae || O < R) && (Se[f[O]] = o[O]);
                        for (; Ee--;) Se[z++] = o[O++];
                        return Se
                    }

                    function Db(o, u, f, _) {
                        for (var O = -1, R = o.length, j = -1, z = f.length, ie = -1, Ee = u.length, Se = Cn(R - z, 0), Ae = de(Se + Ee), Pe = !_; ++O < Se;) Ae[O] = o[O];
                        for (var Ue = O; ++ie < Ee;) Ae[Ue + ie] = u[ie];
                        for (; ++j < z;)(Pe || O < R) && (Ae[Ue + f[j]] = o[O++]);
                        return Ae
                    }

                    function gr(o, u) {
                        var f = -1,
                            _ = o.length;
                        for (u || (u = de(_)); ++f < _;) u[f] = o[f];
                        return u
                    }

                    function Us(o, u, f, _) {
                        var O = !f;
                        f || (f = {});
                        for (var R = -1, j = u.length; ++R < j;) {
                            var z = u[R],
                                ie = _ ? _(f[z], o[z], z, f, o) : n;
                            ie === n && (ie = o[z]), O ? hi(f, z, ie) : Cu(f, z, ie)
                        }
                        return f
                    }

                    function I7(o, u) {
                        return Us(o, kg(o), u)
                    }

                    function k7(o, u) {
                        return Us(o, Yb(o), u)
                    }

                    function Zh(o, u) {
                        return function(f, _) {
                            var O = st(f) ? M6 : XN,
                                R = u ? u() : {};
                            return O(f, o, He(_, 2), R)
                        }
                    }

                    function Ka(o) {
                        return pt(function(u, f) {
                            var _ = -1,
                                O = f.length,
                                R = O > 1 ? f[O - 1] : n,
                                j = O > 2 ? f[2] : n;
                            for (R = o.length > 3 && typeof R == "function" ? (O--, R) : n, j && ar(f[0], f[1], j) && (R = O < 3 ? n : R, O = 1), u = Bt(u); ++_ < O;) {
                                var z = f[_];
                                z && o(u, z, _, R)
                            }
                            return u
                        })
                    }

                    function $b(o, u) {
                        return function(f, _) {
                            if (f == null) return f;
                            if (!_r(f)) return o(f, _);
                            for (var O = f.length, R = u ? O : -1, j = Bt(f);
                                (u ? R-- : ++R < O) && _(j[R], R, j) !== !1;);
                            return f
                        }
                    }

                    function Lb(o) {
                        return function(u, f, _) {
                            for (var O = -1, R = Bt(u), j = _(u), z = j.length; z--;) {
                                var ie = j[o ? z : ++O];
                                if (f(R[ie], ie, R) === !1) break
                            }
                            return u
                        }
                    }

                    function N7(o, u, f) {
                        var _ = u & m,
                            O = Pu(o);

                        function R() {
                            var j = this && this !== Fn && this instanceof R ? O : o;
                            return j.apply(_ ? f : this, arguments)
                        }
                        return R
                    }

                    function Fb(o) {
                        return function(u) {
                            u = Rt(u);
                            var f = Ba(u) ? ls(u) : n,
                                _ = f ? f[0] : u.charAt(0),
                                O = f ? Zi(f, 1).join("") : u.slice(1);
                            return _[o]() + O
                        }
                    }

                    function Ya(o) {
                        return function(u) {
                            return Km($E(DE(u).replace(b6, "")), o, "")
                        }
                    }

                    function Pu(o) {
                        return function() {
                            var u = arguments;
                            switch (u.length) {
                                case 0:
                                    return new o;
                                case 1:
                                    return new o(u[0]);
                                case 2:
                                    return new o(u[0], u[1]);
                                case 3:
                                    return new o(u[0], u[1], u[2]);
                                case 4:
                                    return new o(u[0], u[1], u[2], u[3]);
                                case 5:
                                    return new o(u[0], u[1], u[2], u[3], u[4]);
                                case 6:
                                    return new o(u[0], u[1], u[2], u[3], u[4], u[5]);
                                case 7:
                                    return new o(u[0], u[1], u[2], u[3], u[4], u[5], u[6])
                            }
                            var f = Ha(o.prototype),
                                _ = o.apply(f, u);
                            return an(_) ? _ : f
                        }
                    }

                    function x7(o, u, f) {
                        var _ = Pu(o);

                        function O() {
                            for (var R = arguments.length, j = de(R), z = R, ie = za(O); z--;) j[z] = arguments[z];
                            var Ee = R < 3 && j[0] !== ie && j[R - 1] !== ie ? [] : Wi(j, ie);
                            if (R -= Ee.length, R < f) return jb(o, u, Xh, O.placeholder, n, j, Ee, n, n, f - R);
                            var Se = this && this !== Fn && this instanceof O ? _ : o;
                            return xr(Se, this, j)
                        }
                        return O
                    }

                    function Ub(o) {
                        return function(u, f, _) {
                            var O = Bt(u);
                            if (!_r(u)) {
                                var R = He(f, 3);
                                u = Mn(u), f = function(z) {
                                    return R(O[z], z, O)
                                }
                            }
                            var j = o(u, f, _);
                            return j > -1 ? O[R ? u[j] : j] : n
                        }
                    }

                    function Bb(o) {
                        return di(function(u) {
                            var f = u.length,
                                _ = f,
                                O = Wr.prototype.thru;
                            for (o && u.reverse(); _--;) {
                                var R = u[_];
                                if (typeof R != "function") throw new Gr(a);
                                if (O && !j && tf(R) == "wrapper") var j = new Wr([], !0)
                            }
                            for (_ = j ? _ : f; ++_ < f;) {
                                R = u[_];
                                var z = tf(R),
                                    ie = z == "wrapper" ? Cg(R) : n;
                                ie && xg(ie[0]) && ie[1] == (B | V | I | q) && !ie[4].length && ie[9] == 1 ? j = j[tf(ie[0])].apply(j, ie[3]) : j = R.length == 1 && xg(R) ? j[z]() : j.thru(R)
                            }
                            return function() {
                                var Ee = arguments,
                                    Se = Ee[0];
                                if (j && Ee.length == 1 && st(Se)) return j.plant(Se).value();
                                for (var Ae = 0, Pe = f ? u[Ae].apply(this, Ee) : Se; ++Ae < f;) Pe = u[Ae].call(this, Pe);
                                return Pe
                            }
                        })
                    }

                    function Xh(o, u, f, _, O, R, j, z, ie, Ee) {
                        var Se = u & B,
                            Ae = u & m,
                            Pe = u & w,
                            Ue = u & (V | M),
                            ze = u & se,
                            ht = Pe ? n : Pu(o);

                        function Ze() {
                            for (var vt = arguments.length, wt = de(vt), Dr = vt; Dr--;) wt[Dr] = arguments[Dr];
                            if (Ue) var cr = za(Ze),
                                $r = j6(wt, cr);
                            if (_ && (wt = Mb(wt, _, O, Ue)), R && (wt = Db(wt, R, j, Ue)), vt -= $r, Ue && vt < Ee) {
                                var mn = Wi(wt, cr);
                                return jb(o, u, Xh, Ze.placeholder, f, wt, mn, z, ie, Ee - vt)
                            }
                            var ds = Ae ? f : this,
                                _i = Pe ? ds[o] : o;
                            return vt = wt.length, z ? wt = X7(wt, z) : ze && vt > 1 && wt.reverse(), Se && ie < vt && (wt.length = ie), this && this !== Fn && this instanceof Ze && (_i = ht || Pu(_i)), _i.apply(ds, wt)
                        }
                        return Ze
                    }

                    function qb(o, u) {
                        return function(f, _) {
                            return i7(f, o, u(_), {})
                        }
                    }

                    function Qh(o, u) {
                        return function(f, _) {
                            var O;
                            if (f === n && _ === n) return u;
                            if (f !== n && (O = f), _ !== n) {
                                if (O === n) return _;
                                typeof f == "string" || typeof _ == "string" ? (f = Rr(f), _ = Rr(_)) : (f = Ab(f), _ = Ab(_)), O = o(f, _)
                            }
                            return O
                        }
                    }

                    function Tg(o) {
                        return di(function(u) {
                            return u = tn(u, Pr(He())), pt(function(f) {
                                var _ = this;
                                return o(u, function(O) {
                                    return xr(O, _, f)
                                })
                            })
                        })
                    }

                    function Jh(o, u) {
                        u = u === n ? " " : Rr(u);
                        var f = u.length;
                        if (f < 2) return f ? gg(u, o) : u;
                        var _ = gg(u, Uh(o / qa(u)));
                        return Ba(u) ? Zi(ls(_), 0, o).join("") : _.slice(0, o)
                    }

                    function P7(o, u, f, _) {
                        var O = u & m,
                            R = Pu(o);

                        function j() {
                            for (var z = -1, ie = arguments.length, Ee = -1, Se = _.length, Ae = de(Se + ie), Pe = this && this !== Fn && this instanceof j ? R : o; ++Ee < Se;) Ae[Ee] = _[Ee];
                            for (; ie--;) Ae[Ee++] = arguments[++z];
                            return xr(Pe, O ? f : this, Ae)
                        }
                        return j
                    }

                    function Vb(o) {
                        return function(u, f, _) {
                            return _ && typeof _ != "number" && ar(u, f, _) && (f = _ = n), u = gi(u), f === n ? (f = u, u = 0) : f = gi(f), _ = _ === n ? u < f ? 1 : -1 : gi(_), _7(u, f, _, o)
                        }
                    }

                    function ef(o) {
                        return function(u, f) {
                            return typeof u == "string" && typeof f == "string" || (u = zr(u), f = zr(f)), o(u, f)
                        }
                    }

                    function jb(o, u, f, _, O, R, j, z, ie, Ee) {
                        var Se = u & V,
                            Ae = Se ? j : n,
                            Pe = Se ? n : j,
                            Ue = Se ? R : n,
                            ze = Se ? n : R;
                        u |= Se ? I : L, u &= ~(Se ? L : I), u & P || (u &= ~(m | w));
                        var ht = [o, u, O, Ue, Ae, ze, Pe, z, ie, Ee],
                            Ze = f.apply(n, ht);
                        return xg(o) && tE(Ze, ht), Ze.placeholder = _, nE(Ze, o, u)
                    }

                    function wg(o) {
                        var u = An[o];
                        return function(f, _) {
                            if (f = zr(f), _ = _ == null ? 0 : zn(ut(_), 292), _ && nb(f)) {
                                var O = (Rt(f) + "e").split("e"),
                                    R = u(O[0] + "e" + (+O[1] + _));
                                return O = (Rt(R) + "e").split("e"), +(O[0] + "e" + (+O[1] - _))
                            }
                            return u(f)
                        }
                    }
                    var R7 = Ga && 1 / kh(new Ga([, -0]))[1] == me ? function(o) {
                        return new Ga(o)
                    } : Hg;

                    function Gb(o) {
                        return function(u) {
                            var f = Zn(u);
                            return f == E ? eg(u) : f == he ? Z6(u) : V6(u, o(u))
                        }
                    }

                    function fi(o, u, f, _, O, R, j, z) {
                        var ie = u & w;
                        if (!ie && typeof o != "function") throw new Gr(a);
                        var Ee = _ ? _.length : 0;
                        if (Ee || (u &= ~(I | L), _ = O = n), j = j === n ? j : Cn(ut(j), 0), z = z === n ? z : ut(z), Ee -= O ? O.length : 0, u & L) {
                            var Se = _,
                                Ae = O;
                            _ = O = n
                        }
                        var Pe = ie ? n : Cg(o),
                            Ue = [o, u, f, _, O, Se, Ae, R, j, z];
                        if (Pe && Y7(Ue, Pe), o = Ue[0], u = Ue[1], f = Ue[2], _ = Ue[3], O = Ue[4], z = Ue[9] = Ue[9] === n ? ie ? 0 : o.length : Cn(Ue[9] - Ee, 0), !z && u & (V | M) && (u &= ~(V | M)), !u || u == m) var ze = N7(o, u, f);
                        else u == V || u == M ? ze = x7(o, u, z) : (u == I || u == (m | I)) && !O.length ? ze = P7(o, u, f, _) : ze = Xh.apply(n, Ue);
                        var ht = Pe ? wb : tE;
                        return nE(ht(ze, Ue), o, u)
                    }

                    function Wb(o, u, f, _) {
                        return o === n || fs(o, ja[f]) && !Dt.call(_, f) ? u : o
                    }

                    function Hb(o, u, f, _, O, R) {
                        return an(o) && an(u) && (R.set(u, o), Kh(o, u, n, Hb, R), R.delete(u)), o
                    }

                    function M7(o) {
                        return Du(o) ? n : o
                    }

                    function Kb(o, u, f, _, O, R) {
                        var j = f & b,
                            z = o.length,
                            ie = u.length;
                        if (z != ie && !(j && ie > z)) return !1;
                        var Ee = R.get(o),
                            Se = R.get(u);
                        if (Ee && Se) return Ee == u && Se == o;
                        var Ae = -1,
                            Pe = !0,
                            Ue = f & T ? new Wo : n;
                        for (R.set(o, u), R.set(u, o); ++Ae < z;) {
                            var ze = o[Ae],
                                ht = u[Ae];
                            if (_) var Ze = j ? _(ht, ze, Ae, u, o, R) : _(ze, ht, Ae, o, u, R);
                            if (Ze !== n) {
                                if (Ze) continue;
                                Pe = !1;
                                break
                            }
                            if (Ue) {
                                if (!Ym(u, function(vt, wt) {
                                        if (!Eu(Ue, wt) && (ze === vt || O(ze, vt, f, _, R))) return Ue.push(wt)
                                    })) {
                                    Pe = !1;
                                    break
                                }
                            } else if (!(ze === ht || O(ze, ht, f, _, R))) {
                                Pe = !1;
                                break
                            }
                        }
                        return R.delete(o), R.delete(u), Pe
                    }

                    function D7(o, u, f, _, O, R, j) {
                        switch (f) {
                            case U:
                                if (o.byteLength != u.byteLength || o.byteOffset != u.byteOffset) return !1;
                                o = o.buffer, u = u.buffer;
                            case dt:
                                return !(o.byteLength != u.byteLength || !R(new Dh(o), new Dh(u)));
                            case S:
                            case k:
                            case C:
                                return fs(+o, +u);
                            case K:
                                return o.name == u.name && o.message == u.message;
                            case _e:
                            case re:
                                return o == u + "";
                            case E:
                                var z = eg;
                            case he:
                                var ie = _ & b;
                                if (z || (z = kh), o.size != u.size && !ie) return !1;
                                var Ee = j.get(o);
                                if (Ee) return Ee == u;
                                _ |= T, j.set(o, u);
                                var Se = Kb(z(o), z(u), _, O, R, j);
                                return j.delete(o), Se;
                            case ae:
                                if (Au) return Au.call(o) == Au.call(u)
                        }
                        return !1
                    }

                    function $7(o, u, f, _, O, R) {
                        var j = f & b,
                            z = Og(o),
                            ie = z.length,
                            Ee = Og(u),
                            Se = Ee.length;
                        if (ie != Se && !j) return !1;
                        for (var Ae = ie; Ae--;) {
                            var Pe = z[Ae];
                            if (!(j ? Pe in u : Dt.call(u, Pe))) return !1
                        }
                        var Ue = R.get(o),
                            ze = R.get(u);
                        if (Ue && ze) return Ue == u && ze == o;
                        var ht = !0;
                        R.set(o, u), R.set(u, o);
                        for (var Ze = j; ++Ae < ie;) {
                            Pe = z[Ae];
                            var vt = o[Pe],
                                wt = u[Pe];
                            if (_) var Dr = j ? _(wt, vt, Pe, u, o, R) : _(vt, wt, Pe, o, u, R);
                            if (!(Dr === n ? vt === wt || O(vt, wt, f, _, R) : Dr)) {
                                ht = !1;
                                break
                            }
                            Ze || (Ze = Pe == "constructor")
                        }
                        if (ht && !Ze) {
                            var cr = o.constructor,
                                $r = u.constructor;
                            cr != $r && "constructor" in o && "constructor" in u && !(typeof cr == "function" && cr instanceof cr && typeof $r == "function" && $r instanceof $r) && (ht = !1)
                        }
                        return R.delete(o), R.delete(u), ht
                    }

                    function di(o) {
                        return Rg(Jb(o, n, cE), o + "")
                    }

                    function Og(o) {
                        return db(o, Mn, kg)
                    }

                    function Ag(o) {
                        return db(o, yr, Yb)
                    }
                    var Cg = qh ? function(o) {
                        return qh.get(o)
                    } : Hg;

                    function tf(o) {
                        for (var u = o.name + "", f = Wa[u], _ = Dt.call(Wa, u) ? f.length : 0; _--;) {
                            var O = f[_],
                                R = O.func;
                            if (R == null || R == o) return O.name
                        }
                        return u
                    }

                    function za(o) {
                        var u = Dt.call(N, "placeholder") ? N : o;
                        return u.placeholder
                    }

                    function He() {
                        var o = N.iteratee || Gg;
                        return o = o === Gg ? gb : o, arguments.length ? o(arguments[0], arguments[1]) : o
                    }

                    function nf(o, u) {
                        var f = o.__data__;
                        return G7(u) ? f[typeof u == "string" ? "string" : "hash"] : f.map
                    }

                    function Ig(o) {
                        for (var u = Mn(o), f = u.length; f--;) {
                            var _ = u[f],
                                O = o[_];
                            u[f] = [_, O, Xb(O)]
                        }
                        return u
                    }

                    function Yo(o, u) {
                        var f = K6(o, u);
                        return mb(f) ? f : n
                    }

                    function L7(o) {
                        var u = Dt.call(o, jo),
                            f = o[jo];
                        try {
                            o[jo] = n;
                            var _ = !0
                        } catch {}
                        var O = Rh.call(o);
                        return _ && (u ? o[jo] = f : delete o[jo]), O
                    }
                    var kg = ng ? function(o) {
                            return o == null ? [] : (o = Bt(o), ji(ng(o), function(u) {
                                return eb.call(o, u)
                            }))
                        } : Kg,
                        Yb = ng ? function(o) {
                            for (var u = []; o;) Gi(u, kg(o)), o = $h(o);
                            return u
                        } : Kg,
                        Zn = or;
                    (rg && Zn(new rg(new ArrayBuffer(1))) != U || Tu && Zn(new Tu) != E || sg && Zn(sg.resolve()) != oe || Ga && Zn(new Ga) != he || wu && Zn(new wu) != De) && (Zn = function(o) {
                        var u = or(o),
                            f = u == Z ? o.constructor : n,
                            _ = f ? zo(f) : "";
                        if (_) switch (_) {
                            case vN:
                                return U;
                            case bN:
                                return E;
                            case EN:
                                return oe;
                            case SN:
                                return he;
                            case TN:
                                return De
                        }
                        return u
                    });

                    function F7(o, u, f) {
                        for (var _ = -1, O = f.length; ++_ < O;) {
                            var R = f[_],
                                j = R.size;
                            switch (R.type) {
                                case "drop":
                                    o += j;
                                    break;
                                case "dropRight":
                                    u -= j;
                                    break;
                                case "take":
                                    u = zn(u, o + j);
                                    break;
                                case "takeRight":
                                    o = Cn(o, u - j);
                                    break
                            }
                        }
                        return {
                            start: o,
                            end: u
                        }
                    }

                    function U7(o) {
                        var u = o.match(Wk);
                        return u ? u[1].split(Hk) : []
                    }

                    function zb(o, u, f) {
                        u = zi(u, o);
                        for (var _ = -1, O = u.length, R = !1; ++_ < O;) {
                            var j = Bs(u[_]);
                            if (!(R = o != null && f(o, j))) break;
                            o = o[j]
                        }
                        return R || ++_ != O ? R : (O = o == null ? 0 : o.length, !!O && lf(O) && pi(j, O) && (st(o) || Zo(o)))
                    }

                    function B7(o) {
                        var u = o.length,
                            f = new o.constructor(u);
                        return u && typeof o[0] == "string" && Dt.call(o, "index") && (f.index = o.index, f.input = o.input), f
                    }

                    function Zb(o) {
                        return typeof o.constructor == "function" && !Ru(o) ? Ha($h(o)) : {}
                    }

                    function q7(o, u, f) {
                        var _ = o.constructor;
                        switch (u) {
                            case dt:
                                return Sg(o);
                            case S:
                            case k:
                                return new _(+o);
                            case U:
                                return w7(o, f);
                            case $:
                            case te:
                            case F:
                            case Q:
                            case ve:
                            case Oe:
                            case xe:
                            case Fe:
                            case dn:
                                return Pb(o, f);
                            case E:
                                return new _;
                            case C:
                            case re:
                                return new _(o);
                            case _e:
                                return O7(o);
                            case he:
                                return new _;
                            case ae:
                                return A7(o)
                        }
                    }

                    function V7(o, u) {
                        var f = u.length;
                        if (!f) return o;
                        var _ = f - 1;
                        return u[_] = (f > 1 ? "& " : "") + u[_], u = u.join(f > 2 ? ", " : " "), o.replace(Gk, `{
/* [wrapped with ` + u + `] */
`)
                    }

                    function j7(o) {
                        return st(o) || Zo(o) || !!(tb && o && o[tb])
                    }

                    function pi(o, u) {
                        var f = typeof o;
                        return u = u ?? Te, !!u && (f == "number" || f != "symbol" && t6.test(o)) && o > -1 && o % 1 == 0 && o < u
                    }

                    function ar(o, u, f) {
                        if (!an(f)) return !1;
                        var _ = typeof u;
                        return (_ == "number" ? _r(f) && pi(u, f.length) : _ == "string" && u in f) ? fs(f[u], o) : !1
                    }

                    function Ng(o, u) {
                        if (st(o)) return !1;
                        var f = typeof o;
                        return f == "number" || f == "symbol" || f == "boolean" || o == null || Mr(o) ? !0 : Bk.test(o) || !Uk.test(o) || u != null && o in Bt(u)
                    }

                    function G7(o) {
                        var u = typeof o;
                        return u == "string" || u == "number" || u == "symbol" || u == "boolean" ? o !== "__proto__" : o === null
                    }

                    function xg(o) {
                        var u = tf(o),
                            f = N[u];
                        if (typeof f != "function" || !(u in bt.prototype)) return !1;
                        if (o === f) return !0;
                        var _ = Cg(f);
                        return !!_ && o === _[0]
                    }

                    function W7(o) {
                        return !!X2 && X2 in o
                    }
                    var H7 = xh ? mi : Yg;

                    function Ru(o) {
                        var u = o && o.constructor,
                            f = typeof u == "function" && u.prototype || ja;
                        return o === f
                    }

                    function Xb(o) {
                        return o === o && !an(o)
                    }

                    function Qb(o, u) {
                        return function(f) {
                            return f == null ? !1 : f[o] === u && (u !== n || o in Bt(f))
                        }
                    }

                    function K7(o) {
                        var u = cf(o, function(_) {
                                return f.size === h && f.clear(), _
                            }),
                            f = u.cache;
                        return u
                    }

                    function Y7(o, u) {
                        var f = o[1],
                            _ = u[1],
                            O = f | _,
                            R = O < (m | w | B),
                            j = _ == B && f == V || _ == B && f == q && o[7].length <= u[8] || _ == (B | q) && u[7].length <= u[8] && f == V;
                        if (!(R || j)) return o;
                        _ & m && (o[2] = u[2], O |= f & m ? 0 : P);
                        var z = u[3];
                        if (z) {
                            var ie = o[3];
                            o[3] = ie ? Mb(ie, z, u[4]) : z, o[4] = ie ? Wi(o[3], d) : u[4]
                        }
                        return z = u[5], z && (ie = o[5], o[5] = ie ? Db(ie, z, u[6]) : z, o[6] = ie ? Wi(o[5], d) : u[6]), z = u[7], z && (o[7] = z), _ & B && (o[8] = o[8] == null ? u[8] : zn(o[8], u[8])), o[9] == null && (o[9] = u[9]), o[0] = u[0], o[1] = O, o
                    }

                    function z7(o) {
                        var u = [];
                        if (o != null)
                            for (var f in Bt(o)) u.push(f);
                        return u
                    }

                    function Z7(o) {
                        return Rh.call(o)
                    }

                    function Jb(o, u, f) {
                        return u = Cn(u === n ? o.length - 1 : u, 0),
                            function() {
                                for (var _ = arguments, O = -1, R = Cn(_.length - u, 0), j = de(R); ++O < R;) j[O] = _[u + O];
                                O = -1;
                                for (var z = de(u + 1); ++O < u;) z[O] = _[O];
                                return z[u] = f(j), xr(o, this, z)
                            }
                    }

                    function eE(o, u) {
                        return u.length < 2 ? o : Ko(o, Kr(u, 0, -1))
                    }

                    function X7(o, u) {
                        for (var f = o.length, _ = zn(u.length, f), O = gr(o); _--;) {
                            var R = u[_];
                            o[_] = pi(R, f) ? O[R] : n
                        }
                        return o
                    }

                    function Pg(o, u) {
                        if (!(u === "constructor" && typeof o[u] == "function") && u != "__proto__") return o[u]
                    }
                    var tE = rE(wb),
                        Mu = fN || function(o, u) {
                            return Fn.setTimeout(o, u)
                        },
                        Rg = rE(b7);

                    function nE(o, u, f) {
                        var _ = u + "";
                        return Rg(o, V7(_, Q7(U7(_), f)))
                    }

                    function rE(o) {
                        var u = 0,
                            f = 0;
                        return function() {
                            var _ = gN(),
                                O = ge - (_ - f);
                            if (f = _, O > 0) {
                                if (++u >= ee) return arguments[0]
                            } else u = 0;
                            return o.apply(n, arguments)
                        }
                    }

                    function rf(o, u) {
                        var f = -1,
                            _ = o.length,
                            O = _ - 1;
                        for (u = u === n ? _ : u; ++f < u;) {
                            var R = mg(f, O),
                                j = o[R];
                            o[R] = o[f], o[f] = j
                        }
                        return o.length = u, o
                    }
                    var sE = K7(function(o) {
                        var u = [];
                        return o.charCodeAt(0) === 46 && u.push(""), o.replace(qk, function(f, _, O, R) {
                            u.push(O ? R.replace(zk, "$1") : _ || f)
                        }), u
                    });

                    function Bs(o) {
                        if (typeof o == "string" || Mr(o)) return o;
                        var u = o + "";
                        return u == "0" && 1 / o == -me ? "-0" : u
                    }

                    function zo(o) {
                        if (o != null) {
                            try {
                                return Ph.call(o)
                            } catch {}
                            try {
                                return o + ""
                            } catch {}
                        }
                        return ""
                    }

                    function Q7(o, u) {
                        return jr($t, function(f) {
                            var _ = "_." + f[0];
                            u & f[1] && !Ch(o, _) && o.push(_)
                        }), o.sort()
                    }

                    function iE(o) {
                        if (o instanceof bt) return o.clone();
                        var u = new Wr(o.__wrapped__, o.__chain__);
                        return u.__actions__ = gr(o.__actions__), u.__index__ = o.__index__, u.__values__ = o.__values__, u
                    }

                    function J7(o, u, f) {
                        (f ? ar(o, u, f) : u === n) ? u = 1: u = Cn(ut(u), 0);
                        var _ = o == null ? 0 : o.length;
                        if (!_ || u < 1) return [];
                        for (var O = 0, R = 0, j = de(Uh(_ / u)); O < _;) j[R++] = Kr(o, O, O += u);
                        return j
                    }

                    function ex(o) {
                        for (var u = -1, f = o == null ? 0 : o.length, _ = 0, O = []; ++u < f;) {
                            var R = o[u];
                            R && (O[_++] = R)
                        }
                        return O
                    }

                    function tx() {
                        var o = arguments.length;
                        if (!o) return [];
                        for (var u = de(o - 1), f = arguments[0], _ = o; _--;) u[_ - 1] = arguments[_];
                        return Gi(st(f) ? gr(f) : [f], Un(u, 1))
                    }
                    var nx = pt(function(o, u) {
                            return pn(o) ? Iu(o, Un(u, 1, pn, !0)) : []
                        }),
                        rx = pt(function(o, u) {
                            var f = Yr(u);
                            return pn(f) && (f = n), pn(o) ? Iu(o, Un(u, 1, pn, !0), He(f, 2)) : []
                        }),
                        sx = pt(function(o, u) {
                            var f = Yr(u);
                            return pn(f) && (f = n), pn(o) ? Iu(o, Un(u, 1, pn, !0), n, f) : []
                        });

                    function ix(o, u, f) {
                        var _ = o == null ? 0 : o.length;
                        return _ ? (u = f || u === n ? 1 : ut(u), Kr(o, u < 0 ? 0 : u, _)) : []
                    }

                    function ox(o, u, f) {
                        var _ = o == null ? 0 : o.length;
                        return _ ? (u = f || u === n ? 1 : ut(u), u = _ - u, Kr(o, 0, u < 0 ? 0 : u)) : []
                    }

                    function ax(o, u) {
                        return o && o.length ? zh(o, He(u, 3), !0, !0) : []
                    }

                    function cx(o, u) {
                        return o && o.length ? zh(o, He(u, 3), !0) : []
                    }

                    function ux(o, u, f, _) {
                        var O = o == null ? 0 : o.length;
                        return O ? (f && typeof f != "number" && ar(o, u, f) && (f = 0, _ = O), t7(o, u, f, _)) : []
                    }

                    function oE(o, u, f) {
                        var _ = o == null ? 0 : o.length;
                        if (!_) return -1;
                        var O = f == null ? 0 : ut(f);
                        return O < 0 && (O = Cn(_ + O, 0)), Ih(o, He(u, 3), O)
                    }

                    function aE(o, u, f) {
                        var _ = o == null ? 0 : o.length;
                        if (!_) return -1;
                        var O = _ - 1;
                        return f !== n && (O = ut(f), O = f < 0 ? Cn(_ + O, 0) : zn(O, _ - 1)), Ih(o, He(u, 3), O, !0)
                    }

                    function cE(o) {
                        var u = o == null ? 0 : o.length;
                        return u ? Un(o, 1) : []
                    }

                    function lx(o) {
                        var u = o == null ? 0 : o.length;
                        return u ? Un(o, me) : []
                    }

                    function hx(o, u) {
                        var f = o == null ? 0 : o.length;
                        return f ? (u = u === n ? 1 : ut(u), Un(o, u)) : []
                    }

                    function fx(o) {
                        for (var u = -1, f = o == null ? 0 : o.length, _ = {}; ++u < f;) {
                            var O = o[u];
                            _[O[0]] = O[1]
                        }
                        return _
                    }

                    function uE(o) {
                        return o && o.length ? o[0] : n
                    }

                    function dx(o, u, f) {
                        var _ = o == null ? 0 : o.length;
                        if (!_) return -1;
                        var O = f == null ? 0 : ut(f);
                        return O < 0 && (O = Cn(_ + O, 0)), Ua(o, u, O)
                    }

                    function px(o) {
                        var u = o == null ? 0 : o.length;
                        return u ? Kr(o, 0, -1) : []
                    }
                    var mx = pt(function(o) {
                            var u = tn(o, bg);
                            return u.length && u[0] === o[0] ? lg(u) : []
                        }),
                        gx = pt(function(o) {
                            var u = Yr(o),
                                f = tn(o, bg);
                            return u === Yr(f) ? u = n : f.pop(), f.length && f[0] === o[0] ? lg(f, He(u, 2)) : []
                        }),
                        _x = pt(function(o) {
                            var u = Yr(o),
                                f = tn(o, bg);
                            return u = typeof u == "function" ? u : n, u && f.pop(), f.length && f[0] === o[0] ? lg(f, n, u) : []
                        });

                    function yx(o, u) {
                        return o == null ? "" : pN.call(o, u)
                    }

                    function Yr(o) {
                        var u = o == null ? 0 : o.length;
                        return u ? o[u - 1] : n
                    }

                    function vx(o, u, f) {
                        var _ = o == null ? 0 : o.length;
                        if (!_) return -1;
                        var O = _;
                        return f !== n && (O = ut(f), O = O < 0 ? Cn(_ + O, 0) : zn(O, _ - 1)), u === u ? Q6(o, u, O) : Ih(o, j2, O, !0)
                    }

                    function bx(o, u) {
                        return o && o.length ? bb(o, ut(u)) : n
                    }
                    var Ex = pt(lE);

                    function lE(o, u) {
                        return o && o.length && u && u.length ? pg(o, u) : o
                    }

                    function Sx(o, u, f) {
                        return o && o.length && u && u.length ? pg(o, u, He(f, 2)) : o
                    }

                    function Tx(o, u, f) {
                        return o && o.length && u && u.length ? pg(o, u, n, f) : o
                    }
                    var wx = di(function(o, u) {
                        var f = o == null ? 0 : o.length,
                            _ = og(o, u);
                        return Tb(o, tn(u, function(O) {
                            return pi(O, f) ? +O : O
                        }).sort(Rb)), _
                    });

                    function Ox(o, u) {
                        var f = [];
                        if (!(o && o.length)) return f;
                        var _ = -1,
                            O = [],
                            R = o.length;
                        for (u = He(u, 3); ++_ < R;) {
                            var j = o[_];
                            u(j, _, o) && (f.push(j), O.push(_))
                        }
                        return Tb(o, O), f
                    }

                    function Mg(o) {
                        return o == null ? o : yN.call(o)
                    }

                    function Ax(o, u, f) {
                        var _ = o == null ? 0 : o.length;
                        return _ ? (f && typeof f != "number" && ar(o, u, f) ? (u = 0, f = _) : (u = u == null ? 0 : ut(u), f = f === n ? _ : ut(f)), Kr(o, u, f)) : []
                    }

                    function Cx(o, u) {
                        return Yh(o, u)
                    }

                    function Ix(o, u, f) {
                        return _g(o, u, He(f, 2))
                    }

                    function kx(o, u) {
                        var f = o == null ? 0 : o.length;
                        if (f) {
                            var _ = Yh(o, u);
                            if (_ < f && fs(o[_], u)) return _
                        }
                        return -1
                    }

                    function Nx(o, u) {
                        return Yh(o, u, !0)
                    }

                    function xx(o, u, f) {
                        return _g(o, u, He(f, 2), !0)
                    }

                    function Px(o, u) {
                        var f = o == null ? 0 : o.length;
                        if (f) {
                            var _ = Yh(o, u, !0) - 1;
                            if (fs(o[_], u)) return _
                        }
                        return -1
                    }

                    function Rx(o) {
                        return o && o.length ? Ob(o) : []
                    }

                    function Mx(o, u) {
                        return o && o.length ? Ob(o, He(u, 2)) : []
                    }

                    function Dx(o) {
                        var u = o == null ? 0 : o.length;
                        return u ? Kr(o, 1, u) : []
                    }

                    function $x(o, u, f) {
                        return o && o.length ? (u = f || u === n ? 1 : ut(u), Kr(o, 0, u < 0 ? 0 : u)) : []
                    }

                    function Lx(o, u, f) {
                        var _ = o == null ? 0 : o.length;
                        return _ ? (u = f || u === n ? 1 : ut(u), u = _ - u, Kr(o, u < 0 ? 0 : u, _)) : []
                    }

                    function Fx(o, u) {
                        return o && o.length ? zh(o, He(u, 3), !1, !0) : []
                    }

                    function Ux(o, u) {
                        return o && o.length ? zh(o, He(u, 3)) : []
                    }
                    var Bx = pt(function(o) {
                            return Yi(Un(o, 1, pn, !0))
                        }),
                        qx = pt(function(o) {
                            var u = Yr(o);
                            return pn(u) && (u = n), Yi(Un(o, 1, pn, !0), He(u, 2))
                        }),
                        Vx = pt(function(o) {
                            var u = Yr(o);
                            return u = typeof u == "function" ? u : n, Yi(Un(o, 1, pn, !0), n, u)
                        });

                    function jx(o) {
                        return o && o.length ? Yi(o) : []
                    }

                    function Gx(o, u) {
                        return o && o.length ? Yi(o, He(u, 2)) : []
                    }

                    function Wx(o, u) {
                        return u = typeof u == "function" ? u : n, o && o.length ? Yi(o, n, u) : []
                    }

                    function Dg(o) {
                        if (!(o && o.length)) return [];
                        var u = 0;
                        return o = ji(o, function(f) {
                            if (pn(f)) return u = Cn(f.length, u), !0
                        }), Qm(u, function(f) {
                            return tn(o, zm(f))
                        })
                    }

                    function hE(o, u) {
                        if (!(o && o.length)) return [];
                        var f = Dg(o);
                        return u == null ? f : tn(f, function(_) {
                            return xr(u, n, _)
                        })
                    }
                    var Hx = pt(function(o, u) {
                            return pn(o) ? Iu(o, u) : []
                        }),
                        Kx = pt(function(o) {
                            return vg(ji(o, pn))
                        }),
                        Yx = pt(function(o) {
                            var u = Yr(o);
                            return pn(u) && (u = n), vg(ji(o, pn), He(u, 2))
                        }),
                        zx = pt(function(o) {
                            var u = Yr(o);
                            return u = typeof u == "function" ? u : n, vg(ji(o, pn), n, u)
                        }),
                        Zx = pt(Dg);

                    function Xx(o, u) {
                        return kb(o || [], u || [], Cu)
                    }

                    function Qx(o, u) {
                        return kb(o || [], u || [], xu)
                    }
                    var Jx = pt(function(o) {
                        var u = o.length,
                            f = u > 1 ? o[u - 1] : n;
                        return f = typeof f == "function" ? (o.pop(), f) : n, hE(o, f)
                    });

                    function fE(o) {
                        var u = N(o);
                        return u.__chain__ = !0, u
                    }

                    function e8(o, u) {
                        return u(o), o
                    }

                    function sf(o, u) {
                        return u(o)
                    }
                    var t8 = di(function(o) {
                        var u = o.length,
                            f = u ? o[0] : 0,
                            _ = this.__wrapped__,
                            O = function(R) {
                                return og(R, o)
                            };
                        return u > 1 || this.__actions__.length || !(_ instanceof bt) || !pi(f) ? this.thru(O) : (_ = _.slice(f, +f + (u ? 1 : 0)), _.__actions__.push({
                            func: sf,
                            args: [O],
                            thisArg: n
                        }), new Wr(_, this.__chain__).thru(function(R) {
                            return u && !R.length && R.push(n), R
                        }))
                    });

                    function n8() {
                        return fE(this)
                    }

                    function r8() {
                        return new Wr(this.value(), this.__chain__)
                    }

                    function s8() {
                        this.__values__ === n && (this.__values__ = AE(this.value()));
                        var o = this.__index__ >= this.__values__.length,
                            u = o ? n : this.__values__[this.__index__++];
                        return {
                            done: o,
                            value: u
                        }
                    }

                    function i8() {
                        return this
                    }

                    function o8(o) {
                        for (var u, f = this; f instanceof jh;) {
                            var _ = iE(f);
                            _.__index__ = 0, _.__values__ = n, u ? O.__wrapped__ = _ : u = _;
                            var O = _;
                            f = f.__wrapped__
                        }
                        return O.__wrapped__ = o, u
                    }

                    function a8() {
                        var o = this.__wrapped__;
                        if (o instanceof bt) {
                            var u = o;
                            return this.__actions__.length && (u = new bt(this)), u = u.reverse(), u.__actions__.push({
                                func: sf,
                                args: [Mg],
                                thisArg: n
                            }), new Wr(u, this.__chain__)
                        }
                        return this.thru(Mg)
                    }

                    function c8() {
                        return Ib(this.__wrapped__, this.__actions__)
                    }
                    var u8 = Zh(function(o, u, f) {
                        Dt.call(o, f) ? ++o[f] : hi(o, f, 1)
                    });

                    function l8(o, u, f) {
                        var _ = st(o) ? q2 : e7;
                        return f && ar(o, u, f) && (u = n), _(o, He(u, 3))
                    }

                    function h8(o, u) {
                        var f = st(o) ? ji : hb;
                        return f(o, He(u, 3))
                    }
                    var f8 = Ub(oE),
                        d8 = Ub(aE);

                    function p8(o, u) {
                        return Un(of(o, u), 1)
                    }

                    function m8(o, u) {
                        return Un(of(o, u), me)
                    }

                    function g8(o, u, f) {
                        return f = f === n ? 1 : ut(f), Un(of(o, u), f)
                    }

                    function dE(o, u) {
                        var f = st(o) ? jr : Ki;
                        return f(o, He(u, 3))
                    }

                    function pE(o, u) {
                        var f = st(o) ? D6 : lb;
                        return f(o, He(u, 3))
                    }
                    var _8 = Zh(function(o, u, f) {
                        Dt.call(o, f) ? o[f].push(u) : hi(o, f, [u])
                    });

                    function y8(o, u, f, _) {
                        o = _r(o) ? o : Xa(o), f = f && !_ ? ut(f) : 0;
                        var O = o.length;
                        return f < 0 && (f = Cn(O + f, 0)), hf(o) ? f <= O && o.indexOf(u, f) > -1 : !!O && Ua(o, u, f) > -1
                    }
                    var v8 = pt(function(o, u, f) {
                            var _ = -1,
                                O = typeof u == "function",
                                R = _r(o) ? de(o.length) : [];
                            return Ki(o, function(j) {
                                R[++_] = O ? xr(u, j, f) : ku(j, u, f)
                            }), R
                        }),
                        b8 = Zh(function(o, u, f) {
                            hi(o, f, u)
                        });

                    function of(o, u) {
                        var f = st(o) ? tn : _b;
                        return f(o, He(u, 3))
                    }

                    function E8(o, u, f, _) {
                        return o == null ? [] : (st(u) || (u = u == null ? [] : [u]), f = _ ? n : f, st(f) || (f = f == null ? [] : [f]), Eb(o, u, f))
                    }
                    var S8 = Zh(function(o, u, f) {
                        o[f ? 0 : 1].push(u)
                    }, function() {
                        return [
                            [],
                            []
                        ]
                    });

                    function T8(o, u, f) {
                        var _ = st(o) ? Km : W2,
                            O = arguments.length < 3;
                        return _(o, He(u, 4), f, O, Ki)
                    }

                    function w8(o, u, f) {
                        var _ = st(o) ? $6 : W2,
                            O = arguments.length < 3;
                        return _(o, He(u, 4), f, O, lb)
                    }

                    function O8(o, u) {
                        var f = st(o) ? ji : hb;
                        return f(o, uf(He(u, 3)))
                    }

                    function A8(o) {
                        var u = st(o) ? ob : y7;
                        return u(o)
                    }

                    function C8(o, u, f) {
                        (f ? ar(o, u, f) : u === n) ? u = 1: u = ut(u);
                        var _ = st(o) ? zN : v7;
                        return _(o, u)
                    }

                    function I8(o) {
                        var u = st(o) ? ZN : E7;
                        return u(o)
                    }

                    function k8(o) {
                        if (o == null) return 0;
                        if (_r(o)) return hf(o) ? qa(o) : o.length;
                        var u = Zn(o);
                        return u == E || u == he ? o.size : fg(o).length
                    }

                    function N8(o, u, f) {
                        var _ = st(o) ? Ym : S7;
                        return f && ar(o, u, f) && (u = n), _(o, He(u, 3))
                    }
                    var x8 = pt(function(o, u) {
                            if (o == null) return [];
                            var f = u.length;
                            return f > 1 && ar(o, u[0], u[1]) ? u = [] : f > 2 && ar(u[0], u[1], u[2]) && (u = [u[0]]), Eb(o, Un(u, 1), [])
                        }),
                        af = hN || function() {
                            return Fn.Date.now()
                        };

                    function P8(o, u) {
                        if (typeof u != "function") throw new Gr(a);
                        return o = ut(o),
                            function() {
                                if (--o < 1) return u.apply(this, arguments)
                            }
                    }

                    function mE(o, u, f) {
                        return u = f ? n : u, u = o && u == null ? o.length : u, fi(o, B, n, n, n, n, u)
                    }

                    function gE(o, u) {
                        var f;
                        if (typeof u != "function") throw new Gr(a);
                        return o = ut(o),
                            function() {
                                return --o > 0 && (f = u.apply(this, arguments)), o <= 1 && (u = n), f
                            }
                    }
                    var $g = pt(function(o, u, f) {
                            var _ = m;
                            if (f.length) {
                                var O = Wi(f, za($g));
                                _ |= I
                            }
                            return fi(o, _, u, f, O)
                        }),
                        _E = pt(function(o, u, f) {
                            var _ = m | w;
                            if (f.length) {
                                var O = Wi(f, za(_E));
                                _ |= I
                            }
                            return fi(u, _, o, f, O)
                        });

                    function yE(o, u, f) {
                        u = f ? n : u;
                        var _ = fi(o, V, n, n, n, n, n, u);
                        return _.placeholder = yE.placeholder, _
                    }

                    function vE(o, u, f) {
                        u = f ? n : u;
                        var _ = fi(o, M, n, n, n, n, n, u);
                        return _.placeholder = vE.placeholder, _
                    }

                    function bE(o, u, f) {
                        var _, O, R, j, z, ie, Ee = 0,
                            Se = !1,
                            Ae = !1,
                            Pe = !0;
                        if (typeof o != "function") throw new Gr(a);
                        u = zr(u) || 0, an(f) && (Se = !!f.leading, Ae = "maxWait" in f, R = Ae ? Cn(zr(f.maxWait) || 0, u) : R, Pe = "trailing" in f ? !!f.trailing : Pe);

                        function Ue(mn) {
                            var ds = _,
                                _i = O;
                            return _ = O = n, Ee = mn, j = o.apply(_i, ds), j
                        }

                        function ze(mn) {
                            return Ee = mn, z = Mu(vt, u), Se ? Ue(mn) : j
                        }

                        function ht(mn) {
                            var ds = mn - ie,
                                _i = mn - Ee,
                                UE = u - ds;
                            return Ae ? zn(UE, R - _i) : UE
                        }

                        function Ze(mn) {
                            var ds = mn - ie,
                                _i = mn - Ee;
                            return ie === n || ds >= u || ds < 0 || Ae && _i >= R
                        }

                        function vt() {
                            var mn = af();
                            if (Ze(mn)) return wt(mn);
                            z = Mu(vt, ht(mn))
                        }

                        function wt(mn) {
                            return z = n, Pe && _ ? Ue(mn) : (_ = O = n, j)
                        }

                        function Dr() {
                            z !== n && Nb(z), Ee = 0, _ = ie = O = z = n
                        }

                        function cr() {
                            return z === n ? j : wt(af())
                        }

                        function $r() {
                            var mn = af(),
                                ds = Ze(mn);
                            if (_ = arguments, O = this, ie = mn, ds) {
                                if (z === n) return ze(ie);
                                if (Ae) return Nb(z), z = Mu(vt, u), Ue(ie)
                            }
                            return z === n && (z = Mu(vt, u)), j
                        }
                        return $r.cancel = Dr, $r.flush = cr, $r
                    }
                    var R8 = pt(function(o, u) {
                            return ub(o, 1, u)
                        }),
                        M8 = pt(function(o, u, f) {
                            return ub(o, zr(u) || 0, f)
                        });

                    function D8(o) {
                        return fi(o, se)
                    }

                    function cf(o, u) {
                        if (typeof o != "function" || u != null && typeof u != "function") throw new Gr(a);
                        var f = function() {
                            var _ = arguments,
                                O = u ? u.apply(this, _) : _[0],
                                R = f.cache;
                            if (R.has(O)) return R.get(O);
                            var j = o.apply(this, _);
                            return f.cache = R.set(O, j) || R, j
                        };
                        return f.cache = new(cf.Cache || li), f
                    }
                    cf.Cache = li;

                    function uf(o) {
                        if (typeof o != "function") throw new Gr(a);
                        return function() {
                            var u = arguments;
                            switch (u.length) {
                                case 0:
                                    return !o.call(this);
                                case 1:
                                    return !o.call(this, u[0]);
                                case 2:
                                    return !o.call(this, u[0], u[1]);
                                case 3:
                                    return !o.call(this, u[0], u[1], u[2])
                            }
                            return !o.apply(this, u)
                        }
                    }

                    function $8(o) {
                        return gE(2, o)
                    }
                    var L8 = T7(function(o, u) {
                            u = u.length == 1 && st(u[0]) ? tn(u[0], Pr(He())) : tn(Un(u, 1), Pr(He()));
                            var f = u.length;
                            return pt(function(_) {
                                for (var O = -1, R = zn(_.length, f); ++O < R;) _[O] = u[O].call(this, _[O]);
                                return xr(o, this, _)
                            })
                        }),
                        Lg = pt(function(o, u) {
                            var f = Wi(u, za(Lg));
                            return fi(o, I, n, u, f)
                        }),
                        EE = pt(function(o, u) {
                            var f = Wi(u, za(EE));
                            return fi(o, L, n, u, f)
                        }),
                        F8 = di(function(o, u) {
                            return fi(o, q, n, n, n, u)
                        });

                    function U8(o, u) {
                        if (typeof o != "function") throw new Gr(a);
                        return u = u === n ? u : ut(u), pt(o, u)
                    }

                    function B8(o, u) {
                        if (typeof o != "function") throw new Gr(a);
                        return u = u == null ? 0 : Cn(ut(u), 0), pt(function(f) {
                            var _ = f[u],
                                O = Zi(f, 0, u);
                            return _ && Gi(O, _), xr(o, this, O)
                        })
                    }

                    function q8(o, u, f) {
                        var _ = !0,
                            O = !0;
                        if (typeof o != "function") throw new Gr(a);
                        return an(f) && (_ = "leading" in f ? !!f.leading : _, O = "trailing" in f ? !!f.trailing : O), bE(o, u, {
                            leading: _,
                            maxWait: u,
                            trailing: O
                        })
                    }

                    function V8(o) {
                        return mE(o, 1)
                    }

                    function j8(o, u) {
                        return Lg(Eg(u), o)
                    }

                    function G8() {
                        if (!arguments.length) return [];
                        var o = arguments[0];
                        return st(o) ? o : [o]
                    }

                    function W8(o) {
                        return Hr(o, v)
                    }

                    function H8(o, u) {
                        return u = typeof u == "function" ? u : n, Hr(o, v, u)
                    }

                    function K8(o) {
                        return Hr(o, p | v)
                    }

                    function Y8(o, u) {
                        return u = typeof u == "function" ? u : n, Hr(o, p | v, u)
                    }

                    function z8(o, u) {
                        return u == null || cb(o, u, Mn(u))
                    }

                    function fs(o, u) {
                        return o === u || o !== o && u !== u
                    }
                    var Z8 = ef(ug),
                        X8 = ef(function(o, u) {
                            return o >= u
                        }),
                        Zo = pb(function() {
                            return arguments
                        }()) ? pb : function(o) {
                            return cn(o) && Dt.call(o, "callee") && !eb.call(o, "callee")
                        },
                        st = de.isArray,
                        Q8 = D2 ? Pr(D2) : o7;

                    function _r(o) {
                        return o != null && lf(o.length) && !mi(o)
                    }

                    function pn(o) {
                        return cn(o) && _r(o)
                    }

                    function J8(o) {
                        return o === !0 || o === !1 || cn(o) && or(o) == S
                    }
                    var Xi = dN || Yg,
                        e9 = $2 ? Pr($2) : a7;

                    function t9(o) {
                        return cn(o) && o.nodeType === 1 && !Du(o)
                    }

                    function n9(o) {
                        if (o == null) return !0;
                        if (_r(o) && (st(o) || typeof o == "string" || typeof o.splice == "function" || Xi(o) || Za(o) || Zo(o))) return !o.length;
                        var u = Zn(o);
                        if (u == E || u == he) return !o.size;
                        if (Ru(o)) return !fg(o).length;
                        for (var f in o)
                            if (Dt.call(o, f)) return !1;
                        return !0
                    }

                    function r9(o, u) {
                        return Nu(o, u)
                    }

                    function s9(o, u, f) {
                        f = typeof f == "function" ? f : n;
                        var _ = f ? f(o, u) : n;
                        return _ === n ? Nu(o, u, n, f) : !!_
                    }

                    function Fg(o) {
                        if (!cn(o)) return !1;
                        var u = or(o);
                        return u == K || u == H || typeof o.message == "string" && typeof o.name == "string" && !Du(o)
                    }

                    function i9(o) {
                        return typeof o == "number" && nb(o)
                    }

                    function mi(o) {
                        if (!an(o)) return !1;
                        var u = or(o);
                        return u == A || u == y || u == tt || u == pe
                    }

                    function SE(o) {
                        return typeof o == "number" && o == ut(o)
                    }

                    function lf(o) {
                        return typeof o == "number" && o > -1 && o % 1 == 0 && o <= Te
                    }

                    function an(o) {
                        var u = typeof o;
                        return o != null && (u == "object" || u == "function")
                    }

                    function cn(o) {
                        return o != null && typeof o == "object"
                    }
                    var TE = L2 ? Pr(L2) : u7;

                    function o9(o, u) {
                        return o === u || hg(o, u, Ig(u))
                    }

                    function a9(o, u, f) {
                        return f = typeof f == "function" ? f : n, hg(o, u, Ig(u), f)
                    }

                    function c9(o) {
                        return wE(o) && o != +o
                    }

                    function u9(o) {
                        if (H7(o)) throw new nt(i);
                        return mb(o)
                    }

                    function l9(o) {
                        return o === null
                    }

                    function h9(o) {
                        return o == null
                    }

                    function wE(o) {
                        return typeof o == "number" || cn(o) && or(o) == C
                    }

                    function Du(o) {
                        if (!cn(o) || or(o) != Z) return !1;
                        var u = $h(o);
                        if (u === null) return !0;
                        var f = Dt.call(u, "constructor") && u.constructor;
                        return typeof f == "function" && f instanceof f && Ph.call(f) == aN
                    }
                    var Ug = F2 ? Pr(F2) : l7;

                    function f9(o) {
                        return SE(o) && o >= -Te && o <= Te
                    }
                    var OE = U2 ? Pr(U2) : h7;

                    function hf(o) {
                        return typeof o == "string" || !st(o) && cn(o) && or(o) == re
                    }

                    function Mr(o) {
                        return typeof o == "symbol" || cn(o) && or(o) == ae
                    }
                    var Za = B2 ? Pr(B2) : f7;

                    function d9(o) {
                        return o === n
                    }

                    function p9(o) {
                        return cn(o) && Zn(o) == De
                    }

                    function m9(o) {
                        return cn(o) && or(o) == Je
                    }
                    var g9 = ef(dg),
                        _9 = ef(function(o, u) {
                            return o <= u
                        });

                    function AE(o) {
                        if (!o) return [];
                        if (_r(o)) return hf(o) ? ls(o) : gr(o);
                        if (Su && o[Su]) return z6(o[Su]());
                        var u = Zn(o),
                            f = u == E ? eg : u == he ? kh : Xa;
                        return f(o)
                    }

                    function gi(o) {
                        if (!o) return o === 0 ? o : 0;
                        if (o = zr(o), o === me || o === -me) {
                            var u = o < 0 ? -1 : 1;
                            return u * we
                        }
                        return o === o ? o : 0
                    }

                    function ut(o) {
                        var u = gi(o),
                            f = u % 1;
                        return u === u ? f ? u - f : u : 0
                    }

                    function CE(o) {
                        return o ? Ho(ut(o), 0, Ie) : 0
                    }

                    function zr(o) {
                        if (typeof o == "number") return o;
                        if (Mr(o)) return ke;
                        if (an(o)) {
                            var u = typeof o.valueOf == "function" ? o.valueOf() : o;
                            o = an(u) ? u + "" : u
                        }
                        if (typeof o != "string") return o === 0 ? o : +o;
                        o = H2(o);
                        var f = Qk.test(o);
                        return f || e6.test(o) ? P6(o.slice(2), f ? 2 : 8) : Xk.test(o) ? ke : +o
                    }

                    function IE(o) {
                        return Us(o, yr(o))
                    }

                    function y9(o) {
                        return o ? Ho(ut(o), -Te, Te) : o === 0 ? o : 0
                    }

                    function Rt(o) {
                        return o == null ? "" : Rr(o)
                    }
                    var v9 = Ka(function(o, u) {
                            if (Ru(u) || _r(u)) {
                                Us(u, Mn(u), o);
                                return
                            }
                            for (var f in u) Dt.call(u, f) && Cu(o, f, u[f])
                        }),
                        kE = Ka(function(o, u) {
                            Us(u, yr(u), o)
                        }),
                        ff = Ka(function(o, u, f, _) {
                            Us(u, yr(u), o, _)
                        }),
                        b9 = Ka(function(o, u, f, _) {
                            Us(u, Mn(u), o, _)
                        }),
                        E9 = di(og);

                    function S9(o, u) {
                        var f = Ha(o);
                        return u == null ? f : ab(f, u)
                    }
                    var T9 = pt(function(o, u) {
                            o = Bt(o);
                            var f = -1,
                                _ = u.length,
                                O = _ > 2 ? u[2] : n;
                            for (O && ar(u[0], u[1], O) && (_ = 1); ++f < _;)
                                for (var R = u[f], j = yr(R), z = -1, ie = j.length; ++z < ie;) {
                                    var Ee = j[z],
                                        Se = o[Ee];
                                    (Se === n || fs(Se, ja[Ee]) && !Dt.call(o, Ee)) && (o[Ee] = R[Ee])
                                }
                            return o
                        }),
                        w9 = pt(function(o) {
                            return o.push(n, Hb), xr(NE, n, o)
                        });

                    function O9(o, u) {
                        return V2(o, He(u, 3), Fs)
                    }

                    function A9(o, u) {
                        return V2(o, He(u, 3), cg)
                    }

                    function C9(o, u) {
                        return o == null ? o : ag(o, He(u, 3), yr)
                    }

                    function I9(o, u) {
                        return o == null ? o : fb(o, He(u, 3), yr)
                    }

                    function k9(o, u) {
                        return o && Fs(o, He(u, 3))
                    }

                    function N9(o, u) {
                        return o && cg(o, He(u, 3))
                    }

                    function x9(o) {
                        return o == null ? [] : Hh(o, Mn(o))
                    }

                    function P9(o) {
                        return o == null ? [] : Hh(o, yr(o))
                    }

                    function Bg(o, u, f) {
                        var _ = o == null ? n : Ko(o, u);
                        return _ === n ? f : _
                    }

                    function R9(o, u) {
                        return o != null && zb(o, u, n7)
                    }

                    function qg(o, u) {
                        return o != null && zb(o, u, r7)
                    }
                    var M9 = qb(function(o, u, f) {
                            u != null && typeof u.toString != "function" && (u = Rh.call(u)), o[u] = f
                        }, jg(vr)),
                        D9 = qb(function(o, u, f) {
                            u != null && typeof u.toString != "function" && (u = Rh.call(u)), Dt.call(o, u) ? o[u].push(f) : o[u] = [f]
                        }, He),
                        $9 = pt(ku);

                    function Mn(o) {
                        return _r(o) ? ib(o) : fg(o)
                    }

                    function yr(o) {
                        return _r(o) ? ib(o, !0) : d7(o)
                    }

                    function L9(o, u) {
                        var f = {};
                        return u = He(u, 3), Fs(o, function(_, O, R) {
                            hi(f, u(_, O, R), _)
                        }), f
                    }

                    function F9(o, u) {
                        var f = {};
                        return u = He(u, 3), Fs(o, function(_, O, R) {
                            hi(f, O, u(_, O, R))
                        }), f
                    }
                    var U9 = Ka(function(o, u, f) {
                            Kh(o, u, f)
                        }),
                        NE = Ka(function(o, u, f, _) {
                            Kh(o, u, f, _)
                        }),
                        B9 = di(function(o, u) {
                            var f = {};
                            if (o == null) return f;
                            var _ = !1;
                            u = tn(u, function(R) {
                                return R = zi(R, o), _ || (_ = R.length > 1), R
                            }), Us(o, Ag(o), f), _ && (f = Hr(f, p | g | v, M7));
                            for (var O = u.length; O--;) yg(f, u[O]);
                            return f
                        });

                    function q9(o, u) {
                        return xE(o, uf(He(u)))
                    }
                    var V9 = di(function(o, u) {
                        return o == null ? {} : m7(o, u)
                    });

                    function xE(o, u) {
                        if (o == null) return {};
                        var f = tn(Ag(o), function(_) {
                            return [_]
                        });
                        return u = He(u), Sb(o, f, function(_, O) {
                            return u(_, O[0])
                        })
                    }

                    function j9(o, u, f) {
                        u = zi(u, o);
                        var _ = -1,
                            O = u.length;
                        for (O || (O = 1, o = n); ++_ < O;) {
                            var R = o == null ? n : o[Bs(u[_])];
                            R === n && (_ = O, R = f), o = mi(R) ? R.call(o) : R
                        }
                        return o
                    }

                    function G9(o, u, f) {
                        return o == null ? o : xu(o, u, f)
                    }

                    function W9(o, u, f, _) {
                        return _ = typeof _ == "function" ? _ : n, o == null ? o : xu(o, u, f, _)
                    }
                    var PE = Gb(Mn),
                        RE = Gb(yr);

                    function H9(o, u, f) {
                        var _ = st(o),
                            O = _ || Xi(o) || Za(o);
                        if (u = He(u, 4), f == null) {
                            var R = o && o.constructor;
                            O ? f = _ ? new R : [] : an(o) ? f = mi(R) ? Ha($h(o)) : {} : f = {}
                        }
                        return (O ? jr : Fs)(o, function(j, z, ie) {
                            return u(f, j, z, ie)
                        }), f
                    }

                    function K9(o, u) {
                        return o == null ? !0 : yg(o, u)
                    }

                    function Y9(o, u, f) {
                        return o == null ? o : Cb(o, u, Eg(f))
                    }

                    function z9(o, u, f, _) {
                        return _ = typeof _ == "function" ? _ : n, o == null ? o : Cb(o, u, Eg(f), _)
                    }

                    function Xa(o) {
                        return o == null ? [] : Jm(o, Mn(o))
                    }

                    function Z9(o) {
                        return o == null ? [] : Jm(o, yr(o))
                    }

                    function X9(o, u, f) {
                        return f === n && (f = u, u = n), f !== n && (f = zr(f), f = f === f ? f : 0), u !== n && (u = zr(u), u = u === u ? u : 0), Ho(zr(o), u, f)
                    }

                    function Q9(o, u, f) {
                        return u = gi(u), f === n ? (f = u, u = 0) : f = gi(f), o = zr(o), s7(o, u, f)
                    }

                    function J9(o, u, f) {
                        if (f && typeof f != "boolean" && ar(o, u, f) && (u = f = n), f === n && (typeof u == "boolean" ? (f = u, u = n) : typeof o == "boolean" && (f = o, o = n)), o === n && u === n ? (o = 0, u = 1) : (o = gi(o), u === n ? (u = o, o = 0) : u = gi(u)), o > u) {
                            var _ = o;
                            o = u, u = _
                        }
                        if (f || o % 1 || u % 1) {
                            var O = rb();
                            return zn(o + O * (u - o + x6("1e-" + ((O + "").length - 1))), u)
                        }
                        return mg(o, u)
                    }
                    var eP = Ya(function(o, u, f) {
                        return u = u.toLowerCase(), o + (f ? ME(u) : u)
                    });

                    function ME(o) {
                        return Vg(Rt(o).toLowerCase())
                    }

                    function DE(o) {
                        return o = Rt(o), o && o.replace(n6, G6).replace(E6, "")
                    }

                    function tP(o, u, f) {
                        o = Rt(o), u = Rr(u);
                        var _ = o.length;
                        f = f === n ? _ : Ho(ut(f), 0, _);
                        var O = f;
                        return f -= u.length, f >= 0 && o.slice(f, O) == u
                    }

                    function nP(o) {
                        return o = Rt(o), o && $k.test(o) ? o.replace(f2, W6) : o
                    }

                    function rP(o) {
                        return o = Rt(o), o && Vk.test(o) ? o.replace(Lm, "\\$&") : o
                    }
                    var sP = Ya(function(o, u, f) {
                            return o + (f ? "-" : "") + u.toLowerCase()
                        }),
                        iP = Ya(function(o, u, f) {
                            return o + (f ? " " : "") + u.toLowerCase()
                        }),
                        oP = Fb("toLowerCase");

                    function aP(o, u, f) {
                        o = Rt(o), u = ut(u);
                        var _ = u ? qa(o) : 0;
                        if (!u || _ >= u) return o;
                        var O = (u - _) / 2;
                        return Jh(Bh(O), f) + o + Jh(Uh(O), f)
                    }

                    function cP(o, u, f) {
                        o = Rt(o), u = ut(u);
                        var _ = u ? qa(o) : 0;
                        return u && _ < u ? o + Jh(u - _, f) : o
                    }

                    function uP(o, u, f) {
                        o = Rt(o), u = ut(u);
                        var _ = u ? qa(o) : 0;
                        return u && _ < u ? Jh(u - _, f) + o : o
                    }

                    function lP(o, u, f) {
                        return f || u == null ? u = 0 : u && (u = +u), _N(Rt(o).replace(Fm, ""), u || 0)
                    }

                    function hP(o, u, f) {
                        return (f ? ar(o, u, f) : u === n) ? u = 1 : u = ut(u), gg(Rt(o), u)
                    }

                    function fP() {
                        var o = arguments,
                            u = Rt(o[0]);
                        return o.length < 3 ? u : u.replace(o[1], o[2])
                    }
                    var dP = Ya(function(o, u, f) {
                        return o + (f ? "_" : "") + u.toLowerCase()
                    });

                    function pP(o, u, f) {
                        return f && typeof f != "number" && ar(o, u, f) && (u = f = n), f = f === n ? Ie : f >>> 0, f ? (o = Rt(o), o && (typeof u == "string" || u != null && !Ug(u)) && (u = Rr(u), !u && Ba(o)) ? Zi(ls(o), 0, f) : o.split(u, f)) : []
                    }
                    var mP = Ya(function(o, u, f) {
                        return o + (f ? " " : "") + Vg(u)
                    });

                    function gP(o, u, f) {
                        return o = Rt(o), f = f == null ? 0 : Ho(ut(f), 0, o.length), u = Rr(u), o.slice(f, f + u.length) == u
                    }

                    function _P(o, u, f) {
                        var _ = N.templateSettings;
                        f && ar(o, u, f) && (u = n), o = Rt(o), u = ff({}, u, _, Wb);
                        var O = ff({}, u.imports, _.imports, Wb),
                            R = Mn(O),
                            j = Jm(O, R),
                            z, ie, Ee = 0,
                            Se = u.interpolate || wh,
                            Ae = "__p += '",
                            Pe = tg((u.escape || wh).source + "|" + Se.source + "|" + (Se === d2 ? Zk : wh).source + "|" + (u.evaluate || wh).source + "|$", "g"),
                            Ue = "//# sourceURL=" + (Dt.call(u, "sourceURL") ? (u.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++A6 + "]") + `
`;
                        o.replace(Pe, function(Ze, vt, wt, Dr, cr, $r) {
                            return wt || (wt = Dr), Ae += o.slice(Ee, $r).replace(r6, H6), vt && (z = !0, Ae += `' +
__e(` + vt + `) +
'`), cr && (ie = !0, Ae += `';
` + cr + `;
__p += '`), wt && (Ae += `' +
((__t = (` + wt + `)) == null ? '' : __t) +
'`), Ee = $r + Ze.length, Ze
                        }), Ae += `';
`;
                        var ze = Dt.call(u, "variable") && u.variable;
                        if (!ze) Ae = `with (obj) {
` + Ae + `
}
`;
                        else if (Yk.test(ze)) throw new nt(c);
                        Ae = (ie ? Ae.replace(Nr, "") : Ae).replace(et, "$1").replace(bu, "$1;"), Ae = "function(" + (ze || "obj") + `) {
` + (ze ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (z ? ", __e = _.escape" : "") + (ie ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Ae + `return __p
}`;
                        var ht = LE(function() {
                            return Pt(R, Ue + "return " + Ae).apply(n, j)
                        });
                        if (ht.source = Ae, Fg(ht)) throw ht;
                        return ht
                    }

                    function yP(o) {
                        return Rt(o).toLowerCase()
                    }

                    function vP(o) {
                        return Rt(o).toUpperCase()
                    }

                    function bP(o, u, f) {
                        if (o = Rt(o), o && (f || u === n)) return H2(o);
                        if (!o || !(u = Rr(u))) return o;
                        var _ = ls(o),
                            O = ls(u),
                            R = K2(_, O),
                            j = Y2(_, O) + 1;
                        return Zi(_, R, j).join("")
                    }

                    function EP(o, u, f) {
                        if (o = Rt(o), o && (f || u === n)) return o.slice(0, Z2(o) + 1);
                        if (!o || !(u = Rr(u))) return o;
                        var _ = ls(o),
                            O = Y2(_, ls(u)) + 1;
                        return Zi(_, 0, O).join("")
                    }

                    function SP(o, u, f) {
                        if (o = Rt(o), o && (f || u === n)) return o.replace(Fm, "");
                        if (!o || !(u = Rr(u))) return o;
                        var _ = ls(o),
                            O = K2(_, ls(u));
                        return Zi(_, O).join("")
                    }

                    function TP(o, u) {
                        var f = ce,
                            _ = ue;
                        if (an(u)) {
                            var O = "separator" in u ? u.separator : O;
                            f = "length" in u ? ut(u.length) : f, _ = "omission" in u ? Rr(u.omission) : _
                        }
                        o = Rt(o);
                        var R = o.length;
                        if (Ba(o)) {
                            var j = ls(o);
                            R = j.length
                        }
                        if (f >= R) return o;
                        var z = f - qa(_);
                        if (z < 1) return _;
                        var ie = j ? Zi(j, 0, z).join("") : o.slice(0, z);
                        if (O === n) return ie + _;
                        if (j && (z += ie.length - z), Ug(O)) {
                            if (o.slice(z).search(O)) {
                                var Ee, Se = ie;
                                for (O.global || (O = tg(O.source, Rt(p2.exec(O)) + "g")), O.lastIndex = 0; Ee = O.exec(Se);) var Ae = Ee.index;
                                ie = ie.slice(0, Ae === n ? z : Ae)
                            }
                        } else if (o.indexOf(Rr(O), z) != z) {
                            var Pe = ie.lastIndexOf(O);
                            Pe > -1 && (ie = ie.slice(0, Pe))
                        }
                        return ie + _
                    }

                    function wP(o) {
                        return o = Rt(o), o && Dk.test(o) ? o.replace(h2, J6) : o
                    }
                    var OP = Ya(function(o, u, f) {
                            return o + (f ? " " : "") + u.toUpperCase()
                        }),
                        Vg = Fb("toUpperCase");

                    function $E(o, u, f) {
                        return o = Rt(o), u = f ? n : u, u === n ? Y6(o) ? nN(o) : U6(o) : o.match(u) || []
                    }
                    var LE = pt(function(o, u) {
                            try {
                                return xr(o, n, u)
                            } catch (f) {
                                return Fg(f) ? f : new nt(f)
                            }
                        }),
                        AP = di(function(o, u) {
                            return jr(u, function(f) {
                                f = Bs(f), hi(o, f, $g(o[f], o))
                            }), o
                        });

                    function CP(o) {
                        var u = o == null ? 0 : o.length,
                            f = He();
                        return o = u ? tn(o, function(_) {
                            if (typeof _[1] != "function") throw new Gr(a);
                            return [f(_[0]), _[1]]
                        }) : [], pt(function(_) {
                            for (var O = -1; ++O < u;) {
                                var R = o[O];
                                if (xr(R[0], this, _)) return xr(R[1], this, _)
                            }
                        })
                    }

                    function IP(o) {
                        return JN(Hr(o, p))
                    }

                    function jg(o) {
                        return function() {
                            return o
                        }
                    }

                    function kP(o, u) {
                        return o == null || o !== o ? u : o
                    }
                    var NP = Bb(),
                        xP = Bb(!0);

                    function vr(o) {
                        return o
                    }

                    function Gg(o) {
                        return gb(typeof o == "function" ? o : Hr(o, p))
                    }

                    function PP(o) {
                        return yb(Hr(o, p))
                    }

                    function RP(o, u) {
                        return vb(o, Hr(u, p))
                    }
                    var MP = pt(function(o, u) {
                            return function(f) {
                                return ku(f, o, u)
                            }
                        }),
                        DP = pt(function(o, u) {
                            return function(f) {
                                return ku(o, f, u)
                            }
                        });

                    function Wg(o, u, f) {
                        var _ = Mn(u),
                            O = Hh(u, _);
                        f == null && !(an(u) && (O.length || !_.length)) && (f = u, u = o, o = this, O = Hh(u, Mn(u)));
                        var R = !(an(f) && "chain" in f) || !!f.chain,
                            j = mi(o);
                        return jr(O, function(z) {
                            var ie = u[z];
                            o[z] = ie, j && (o.prototype[z] = function() {
                                var Ee = this.__chain__;
                                if (R || Ee) {
                                    var Se = o(this.__wrapped__),
                                        Ae = Se.__actions__ = gr(this.__actions__);
                                    return Ae.push({
                                        func: ie,
                                        args: arguments,
                                        thisArg: o
                                    }), Se.__chain__ = Ee, Se
                                }
                                return ie.apply(o, Gi([this.value()], arguments))
                            })
                        }), o
                    }

                    function $P() {
                        return Fn._ === this && (Fn._ = cN), this
                    }

                    function Hg() {}

                    function LP(o) {
                        return o = ut(o), pt(function(u) {
                            return bb(u, o)
                        })
                    }
                    var FP = Tg(tn),
                        UP = Tg(q2),
                        BP = Tg(Ym);

                    function FE(o) {
                        return Ng(o) ? zm(Bs(o)) : g7(o)
                    }

                    function qP(o) {
                        return function(u) {
                            return o == null ? n : Ko(o, u)
                        }
                    }
                    var VP = Vb(),
                        jP = Vb(!0);

                    function Kg() {
                        return []
                    }

                    function Yg() {
                        return !1
                    }

                    function GP() {
                        return {}
                    }

                    function WP() {
                        return ""
                    }

                    function HP() {
                        return !0
                    }

                    function KP(o, u) {
                        if (o = ut(o), o < 1 || o > Te) return [];
                        var f = Ie,
                            _ = zn(o, Ie);
                        u = He(u), o -= Ie;
                        for (var O = Qm(_, u); ++f < o;) u(f);
                        return O
                    }

                    function YP(o) {
                        return st(o) ? tn(o, Bs) : Mr(o) ? [o] : gr(sE(Rt(o)))
                    }

                    function zP(o) {
                        var u = ++oN;
                        return Rt(o) + u
                    }
                    var ZP = Qh(function(o, u) {
                            return o + u
                        }, 0),
                        XP = wg("ceil"),
                        QP = Qh(function(o, u) {
                            return o / u
                        }, 1),
                        JP = wg("floor");

                    function eR(o) {
                        return o && o.length ? Wh(o, vr, ug) : n
                    }

                    function tR(o, u) {
                        return o && o.length ? Wh(o, He(u, 2), ug) : n
                    }

                    function nR(o) {
                        return G2(o, vr)
                    }

                    function rR(o, u) {
                        return G2(o, He(u, 2))
                    }

                    function sR(o) {
                        return o && o.length ? Wh(o, vr, dg) : n
                    }

                    function iR(o, u) {
                        return o && o.length ? Wh(o, He(u, 2), dg) : n
                    }
                    var oR = Qh(function(o, u) {
                            return o * u
                        }, 1),
                        aR = wg("round"),
                        cR = Qh(function(o, u) {
                            return o - u
                        }, 0);

                    function uR(o) {
                        return o && o.length ? Xm(o, vr) : 0
                    }

                    function lR(o, u) {
                        return o && o.length ? Xm(o, He(u, 2)) : 0
                    }
                    return N.after = P8, N.ary = mE, N.assign = v9, N.assignIn = kE, N.assignInWith = ff, N.assignWith = b9, N.at = E9, N.before = gE, N.bind = $g, N.bindAll = AP, N.bindKey = _E, N.castArray = G8, N.chain = fE, N.chunk = J7, N.compact = ex, N.concat = tx, N.cond = CP, N.conforms = IP, N.constant = jg, N.countBy = u8, N.create = S9, N.curry = yE, N.curryRight = vE, N.debounce = bE, N.defaults = T9, N.defaultsDeep = w9, N.defer = R8, N.delay = M8, N.difference = nx, N.differenceBy = rx, N.differenceWith = sx, N.drop = ix, N.dropRight = ox, N.dropRightWhile = ax, N.dropWhile = cx, N.fill = ux, N.filter = h8, N.flatMap = p8, N.flatMapDeep = m8, N.flatMapDepth = g8, N.flatten = cE, N.flattenDeep = lx, N.flattenDepth = hx, N.flip = D8, N.flow = NP, N.flowRight = xP, N.fromPairs = fx, N.functions = x9, N.functionsIn = P9, N.groupBy = _8, N.initial = px, N.intersection = mx, N.intersectionBy = gx, N.intersectionWith = _x, N.invert = M9, N.invertBy = D9, N.invokeMap = v8, N.iteratee = Gg, N.keyBy = b8, N.keys = Mn, N.keysIn = yr, N.map = of, N.mapKeys = L9, N.mapValues = F9, N.matches = PP, N.matchesProperty = RP, N.memoize = cf, N.merge = U9, N.mergeWith = NE, N.method = MP, N.methodOf = DP, N.mixin = Wg, N.negate = uf, N.nthArg = LP, N.omit = B9, N.omitBy = q9, N.once = $8, N.orderBy = E8, N.over = FP, N.overArgs = L8, N.overEvery = UP, N.overSome = BP, N.partial = Lg, N.partialRight = EE, N.partition = S8, N.pick = V9, N.pickBy = xE, N.property = FE, N.propertyOf = qP, N.pull = Ex, N.pullAll = lE, N.pullAllBy = Sx, N.pullAllWith = Tx, N.pullAt = wx, N.range = VP, N.rangeRight = jP, N.rearg = F8, N.reject = O8, N.remove = Ox, N.rest = U8, N.reverse = Mg, N.sampleSize = C8, N.set = G9, N.setWith = W9, N.shuffle = I8, N.slice = Ax, N.sortBy = x8, N.sortedUniq = Rx, N.sortedUniqBy = Mx, N.split = pP, N.spread = B8, N.tail = Dx, N.take = $x, N.takeRight = Lx, N.takeRightWhile = Fx, N.takeWhile = Ux, N.tap = e8, N.throttle = q8, N.thru = sf, N.toArray = AE, N.toPairs = PE, N.toPairsIn = RE, N.toPath = YP, N.toPlainObject = IE, N.transform = H9, N.unary = V8, N.union = Bx, N.unionBy = qx, N.unionWith = Vx, N.uniq = jx, N.uniqBy = Gx, N.uniqWith = Wx, N.unset = K9, N.unzip = Dg, N.unzipWith = hE, N.update = Y9, N.updateWith = z9, N.values = Xa, N.valuesIn = Z9, N.without = Hx, N.words = $E, N.wrap = j8, N.xor = Kx, N.xorBy = Yx, N.xorWith = zx, N.zip = Zx, N.zipObject = Xx, N.zipObjectDeep = Qx, N.zipWith = Jx, N.entries = PE, N.entriesIn = RE, N.extend = kE, N.extendWith = ff, Wg(N, N), N.add = ZP, N.attempt = LE, N.camelCase = eP, N.capitalize = ME, N.ceil = XP, N.clamp = X9, N.clone = W8, N.cloneDeep = K8, N.cloneDeepWith = Y8, N.cloneWith = H8, N.conformsTo = z8, N.deburr = DE, N.defaultTo = kP, N.divide = QP, N.endsWith = tP, N.eq = fs, N.escape = nP, N.escapeRegExp = rP, N.every = l8, N.find = f8, N.findIndex = oE, N.findKey = O9, N.findLast = d8, N.findLastIndex = aE, N.findLastKey = A9, N.floor = JP, N.forEach = dE, N.forEachRight = pE, N.forIn = C9, N.forInRight = I9, N.forOwn = k9, N.forOwnRight = N9, N.get = Bg, N.gt = Z8, N.gte = X8, N.has = R9, N.hasIn = qg, N.head = uE, N.identity = vr, N.includes = y8, N.indexOf = dx, N.inRange = Q9, N.invoke = $9, N.isArguments = Zo, N.isArray = st, N.isArrayBuffer = Q8, N.isArrayLike = _r, N.isArrayLikeObject = pn, N.isBoolean = J8, N.isBuffer = Xi, N.isDate = e9, N.isElement = t9, N.isEmpty = n9, N.isEqual = r9, N.isEqualWith = s9, N.isError = Fg, N.isFinite = i9, N.isFunction = mi, N.isInteger = SE, N.isLength = lf, N.isMap = TE, N.isMatch = o9, N.isMatchWith = a9, N.isNaN = c9, N.isNative = u9, N.isNil = h9, N.isNull = l9, N.isNumber = wE, N.isObject = an, N.isObjectLike = cn, N.isPlainObject = Du, N.isRegExp = Ug, N.isSafeInteger = f9, N.isSet = OE, N.isString = hf, N.isSymbol = Mr, N.isTypedArray = Za, N.isUndefined = d9, N.isWeakMap = p9, N.isWeakSet = m9, N.join = yx, N.kebabCase = sP, N.last = Yr, N.lastIndexOf = vx, N.lowerCase = iP, N.lowerFirst = oP, N.lt = g9, N.lte = _9, N.max = eR, N.maxBy = tR, N.mean = nR, N.meanBy = rR, N.min = sR, N.minBy = iR, N.stubArray = Kg, N.stubFalse = Yg, N.stubObject = GP, N.stubString = WP, N.stubTrue = HP, N.multiply = oR, N.nth = bx, N.noConflict = $P, N.noop = Hg, N.now = af, N.pad = aP, N.padEnd = cP, N.padStart = uP, N.parseInt = lP, N.random = J9, N.reduce = T8, N.reduceRight = w8, N.repeat = hP, N.replace = fP, N.result = j9, N.round = aR, N.runInContext = ne, N.sample = A8, N.size = k8, N.snakeCase = dP, N.some = N8, N.sortedIndex = Cx, N.sortedIndexBy = Ix, N.sortedIndexOf = kx, N.sortedLastIndex = Nx, N.sortedLastIndexBy = xx, N.sortedLastIndexOf = Px, N.startCase = mP, N.startsWith = gP, N.subtract = cR, N.sum = uR, N.sumBy = lR, N.template = _P, N.times = KP, N.toFinite = gi, N.toInteger = ut, N.toLength = CE, N.toLower = yP, N.toNumber = zr, N.toSafeInteger = y9, N.toString = Rt, N.toUpper = vP, N.trim = bP, N.trimEnd = EP, N.trimStart = SP, N.truncate = TP, N.unescape = wP, N.uniqueId = zP, N.upperCase = OP, N.upperFirst = Vg, N.each = dE, N.eachRight = pE, N.first = uE, Wg(N, function() {
                        var o = {};
                        return Fs(N, function(u, f) {
                            Dt.call(N.prototype, f) || (o[f] = u)
                        }), o
                    }(), {
                        chain: !1
                    }), N.VERSION = r, jr(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(o) {
                        N[o].placeholder = N
                    }), jr(["drop", "take"], function(o, u) {
                        bt.prototype[o] = function(f) {
                            f = f === n ? 1 : Cn(ut(f), 0);
                            var _ = this.__filtered__ && !u ? new bt(this) : this.clone();
                            return _.__filtered__ ? _.__takeCount__ = zn(f, _.__takeCount__) : _.__views__.push({
                                size: zn(f, Ie),
                                type: o + (_.__dir__ < 0 ? "Right" : "")
                            }), _
                        }, bt.prototype[o + "Right"] = function(f) {
                            return this.reverse()[o](f).reverse()
                        }
                    }), jr(["filter", "map", "takeWhile"], function(o, u) {
                        var f = u + 1,
                            _ = f == G || f == fe;
                        bt.prototype[o] = function(O) {
                            var R = this.clone();
                            return R.__iteratees__.push({
                                iteratee: He(O, 3),
                                type: f
                            }), R.__filtered__ = R.__filtered__ || _, R
                        }
                    }), jr(["head", "last"], function(o, u) {
                        var f = "take" + (u ? "Right" : "");
                        bt.prototype[o] = function() {
                            return this[f](1).value()[0]
                        }
                    }), jr(["initial", "tail"], function(o, u) {
                        var f = "drop" + (u ? "" : "Right");
                        bt.prototype[o] = function() {
                            return this.__filtered__ ? new bt(this) : this[f](1)
                        }
                    }), bt.prototype.compact = function() {
                        return this.filter(vr)
                    }, bt.prototype.find = function(o) {
                        return this.filter(o).head()
                    }, bt.prototype.findLast = function(o) {
                        return this.reverse().find(o)
                    }, bt.prototype.invokeMap = pt(function(o, u) {
                        return typeof o == "function" ? new bt(this) : this.map(function(f) {
                            return ku(f, o, u)
                        })
                    }), bt.prototype.reject = function(o) {
                        return this.filter(uf(He(o)))
                    }, bt.prototype.slice = function(o, u) {
                        o = ut(o);
                        var f = this;
                        return f.__filtered__ && (o > 0 || u < 0) ? new bt(f) : (o < 0 ? f = f.takeRight(-o) : o && (f = f.drop(o)), u !== n && (u = ut(u), f = u < 0 ? f.dropRight(-u) : f.take(u - o)), f)
                    }, bt.prototype.takeRightWhile = function(o) {
                        return this.reverse().takeWhile(o).reverse()
                    }, bt.prototype.toArray = function() {
                        return this.take(Ie)
                    }, Fs(bt.prototype, function(o, u) {
                        var f = /^(?:filter|find|map|reject)|While$/.test(u),
                            _ = /^(?:head|last)$/.test(u),
                            O = N[_ ? "take" + (u == "last" ? "Right" : "") : u],
                            R = _ || /^find/.test(u);
                        O && (N.prototype[u] = function() {
                            var j = this.__wrapped__,
                                z = _ ? [1] : arguments,
                                ie = j instanceof bt,
                                Ee = z[0],
                                Se = ie || st(j),
                                Ae = function(vt) {
                                    var wt = O.apply(N, Gi([vt], z));
                                    return _ && Pe ? wt[0] : wt
                                };
                            Se && f && typeof Ee == "function" && Ee.length != 1 && (ie = Se = !1);
                            var Pe = this.__chain__,
                                Ue = !!this.__actions__.length,
                                ze = R && !Pe,
                                ht = ie && !Ue;
                            if (!R && Se) {
                                j = ht ? j : new bt(this);
                                var Ze = o.apply(j, z);
                                return Ze.__actions__.push({
                                    func: sf,
                                    args: [Ae],
                                    thisArg: n
                                }), new Wr(Ze, Pe)
                            }
                            return ze && ht ? o.apply(this, z) : (Ze = this.thru(Ae), ze ? _ ? Ze.value()[0] : Ze.value() : Ze)
                        })
                    }), jr(["pop", "push", "shift", "sort", "splice", "unshift"], function(o) {
                        var u = Nh[o],
                            f = /^(?:push|sort|unshift)$/.test(o) ? "tap" : "thru",
                            _ = /^(?:pop|shift)$/.test(o);
                        N.prototype[o] = function() {
                            var O = arguments;
                            if (_ && !this.__chain__) {
                                var R = this.value();
                                return u.apply(st(R) ? R : [], O)
                            }
                            return this[f](function(j) {
                                return u.apply(st(j) ? j : [], O)
                            })
                        }
                    }), Fs(bt.prototype, function(o, u) {
                        var f = N[u];
                        if (f) {
                            var _ = f.name + "";
                            Dt.call(Wa, _) || (Wa[_] = []), Wa[_].push({
                                name: u,
                                func: f
                            })
                        }
                    }), Wa[Xh(n, w).name] = [{
                        name: "wrapper",
                        func: n
                    }], bt.prototype.clone = wN, bt.prototype.reverse = ON, bt.prototype.value = AN, N.prototype.at = t8, N.prototype.chain = n8, N.prototype.commit = r8, N.prototype.next = s8, N.prototype.plant = o8, N.prototype.reverse = a8, N.prototype.toJSON = N.prototype.valueOf = N.prototype.value = c8, N.prototype.first = N.prototype.head, Su && (N.prototype[Su] = i8), N
                },
                Va = rN();
            Vo ? ((Vo.exports = Va)._ = Va, Gm._ = Va) : Fn._ = Va
        }).call(hn)
    })(Td, Td.exports);
    Td.exports;
    var ta, Sf, tl = typeof Map == "function" ? new Map : (ta = [], Sf = [], {
            has: function(t) {
                return ta.indexOf(t) > -1
            },
            get: function(t) {
                return Sf[ta.indexOf(t)]
            },
            set: function(t, e) {
                ta.indexOf(t) === -1 && (ta.push(t), Sf.push(e))
            },
            delete: function(t) {
                var e = ta.indexOf(t);
                e > -1 && (ta.splice(e, 1), Sf.splice(e, 1))
            }
        }),
        WO = function(t) {
            return new Event(t, {
                bubbles: !0
            })
        };
    try {
        new Event("test")
    } catch {
        WO = function(e) {
            var n = document.createEvent("Event");
            return n.initEvent(e, !0, !1), n
        }
    }

    function OY(t) {
        var e = tl.get(t);
        e && e.destroy()
    }

    function AY(t) {
        var e = tl.get(t);
        e && e.update()
    }
    var Tf = null;
    typeof window > "u" || typeof window.getComputedStyle != "function" ? ((Tf = function(t) {
        return t
    }).destroy = function(t) {
        return t
    }, Tf.update = function(t) {
        return t
    }) : ((Tf = function(t, e) {
        return t && Array.prototype.forEach.call(t.length ? t : [t], function(n) {
            return function(r) {
                if (r && r.nodeName && r.nodeName === "TEXTAREA" && !tl.has(r)) {
                    var s, i = null,
                        a = null,
                        c = null,
                        l = function() {
                            r.clientWidth !== a && g()
                        },
                        h = (function(v) {
                            window.removeEventListener("resize", l, !1), r.removeEventListener("input", g, !1), r.removeEventListener("keyup", g, !1), r.removeEventListener("autosize:destroy", h, !1), r.removeEventListener("autosize:update", g, !1), Object.keys(v).forEach(function(b) {
                                r.style[b] = v[b]
                            }), tl.delete(r)
                        }).bind(r, {
                            height: r.style.height,
                            resize: r.style.resize,
                            overflowY: r.style.overflowY,
                            overflowX: r.style.overflowX,
                            wordWrap: r.style.wordWrap
                        });
                    r.addEventListener("autosize:destroy", h, !1), "onpropertychange" in r && "oninput" in r && r.addEventListener("keyup", g, !1), window.addEventListener("resize", l, !1), r.addEventListener("input", g, !1), r.addEventListener("autosize:update", g, !1), r.style.overflowX = "hidden", r.style.wordWrap = "break-word", tl.set(r, {
                        destroy: h,
                        update: g
                    }), (s = window.getComputedStyle(r, null)).resize === "vertical" ? r.style.resize = "none" : s.resize === "both" && (r.style.resize = "horizontal"), i = s.boxSizing === "content-box" ? -(parseFloat(s.paddingTop) + parseFloat(s.paddingBottom)) : parseFloat(s.borderTopWidth) + parseFloat(s.borderBottomWidth), isNaN(i) && (i = 0), g()
                }

                function d(v) {
                    var b = r.style.width;
                    r.style.width = "0px", r.style.width = b, r.style.overflowY = v
                }

                function p() {
                    if (r.scrollHeight !== 0) {
                        var v = function(T) {
                                for (var m = []; T && T.parentNode && T.parentNode instanceof Element;) T.parentNode.scrollTop && m.push({
                                    node: T.parentNode,
                                    scrollTop: T.parentNode.scrollTop
                                }), T = T.parentNode;
                                return m
                            }(r),
                            b = document.documentElement && document.documentElement.scrollTop;
                        r.style.height = "", r.style.height = r.scrollHeight + i + "px", a = r.clientWidth, v.forEach(function(T) {
                            T.node.scrollTop = T.scrollTop
                        }), b && (document.documentElement.scrollTop = b)
                    }
                }

                function g() {
                    p();
                    var v = Math.round(parseFloat(r.style.height)),
                        b = window.getComputedStyle(r, null),
                        T = b.boxSizing === "content-box" ? Math.round(parseFloat(b.height)) : r.offsetHeight;
                    if (T < v ? b.overflowY === "hidden" && (d("scroll"), p(), T = b.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(r, null).height)) : r.offsetHeight) : b.overflowY !== "hidden" && (d("hidden"), p(), T = b.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(r, null).height)) : r.offsetHeight), c !== T) {
                        c = T;
                        var m = WO("autosize:resized");
                        try {
                            r.dispatchEvent(m)
                        } catch {}
                    }
                }
            }(n)
        }), t
    }).destroy = function(t) {
        return t && Array.prototype.forEach.call(t.length ? t : [t], OY), t
    }, Tf.update = function(t) {
        return t && Array.prototype.forEach.call(t.length ? t : [t], AY), t
    });
    var wf = function(t) {
            return t && t.Math == Math && t
        },
        Ir = wf(typeof globalThis == "object" && globalThis) || wf(typeof window == "object" && window) || wf(typeof self == "object" && self) || wf(typeof hn == "object" && hn) || function() {
            return this
        }() || hn || Function("return this")(),
        Uv = {},
        qr = function(t) {
            try {
                return !!t()
            } catch {
                return !0
            }
        },
        CY = qr,
        Do = !CY(function() {
            return Object.defineProperty({}, 1, {
                get: function() {
                    return 7
                }
            })[1] != 7
        }),
        IY = qr,
        Bv = !IY(function() {
            var t = (function() {}).bind();
            return typeof t != "function" || t.hasOwnProperty("prototype")
        }),
        kY = Bv,
        Of = Function.prototype.call,
        $o = kY ? Of.bind(Of) : function() {
            return Of.apply(Of, arguments)
        },
        HO = {},
        KO = {}.propertyIsEnumerable,
        YO = Object.getOwnPropertyDescriptor,
        NY = YO && !KO.call({
            1: 2
        }, 1);
    HO.f = NY ? function(e) {
        var n = YO(this, e);
        return !!n && n.enumerable
    } : KO;
    var zO = function(t, e) {
            return {
                enumerable: !(t & 1),
                configurable: !(t & 2),
                writable: !(t & 4),
                value: e
            }
        },
        ZO = Bv,
        XO = Function.prototype,
        S1 = XO.call,
        xY = ZO && XO.bind.bind(S1, S1),
        sr = ZO ? xY : function(t) {
            return function() {
                return S1.apply(t, arguments)
            }
        },
        QO = sr,
        PY = QO({}.toString),
        RY = QO("".slice),
        eh = function(t) {
            return RY(PY(t), 8, -1)
        },
        MY = sr,
        DY = qr,
        $Y = eh,
        y_ = Object,
        LY = MY("".split),
        FY = DY(function() {
            return !y_("z").propertyIsEnumerable(0)
        }) ? function(t) {
            return $Y(t) == "String" ? LY(t, "") : y_(t)
        } : y_,
        em = function(t) {
            return t == null
        },
        UY = em,
        BY = TypeError,
        th = function(t) {
            if (UY(t)) throw BY("Can't call method on " + t);
            return t
        },
        qY = FY,
        VY = th,
        tm = function(t) {
            return qY(VY(t))
        },
        T1 = typeof document == "object" && document.all,
        jY = typeof T1 > "u" && T1 !== void 0,
        JO = {
            all: T1,
            IS_HTMLDDA: jY
        },
        eA = JO,
        GY = eA.all,
        kr = eA.IS_HTMLDDA ? function(t) {
            return typeof t == "function" || t === GY
        } : function(t) {
            return typeof t == "function"
        },
        OT = kr,
        tA = JO,
        WY = tA.all,
        cu = tA.IS_HTMLDDA ? function(t) {
            return typeof t == "object" ? t !== null : OT(t) || t === WY
        } : function(t) {
            return typeof t == "object" ? t !== null : OT(t)
        },
        v_ = Ir,
        HY = kr,
        KY = function(t) {
            return HY(t) ? t : void 0
        },
        qv = function(t, e) {
            return arguments.length < 2 ? KY(v_[t]) : v_[t] && v_[t][e]
        },
        YY = sr,
        nA = YY({}.isPrototypeOf),
        zY = typeof navigator < "u" && String(navigator.userAgent) || "",
        rA = Ir,
        b_ = zY,
        AT = rA.process,
        CT = rA.Deno,
        IT = AT && AT.versions || CT && CT.version,
        kT = IT && IT.v8,
        _s, wd;
    kT && (_s = kT.split("."), wd = _s[0] > 0 && _s[0] < 4 ? 1 : +(_s[0] + _s[1]));
    !wd && b_ && (_s = b_.match(/Edge\/(\d+)/), (!_s || _s[1] >= 74) && (_s = b_.match(/Chrome\/(\d+)/), _s && (wd = +_s[1])));
    var ZY = wd,
        NT = ZY,
        XY = qr,
        QY = Ir,
        JY = QY.String,
        sA = !!Object.getOwnPropertySymbols && !XY(function() {
            var t = Symbol();
            return !JY(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && NT && NT < 41
        }),
        ez = sA,
        iA = ez && !Symbol.sham && typeof Symbol.iterator == "symbol",
        tz = qv,
        nz = kr,
        rz = nA,
        sz = iA,
        iz = Object,
        oA = sz ? function(t) {
            return typeof t == "symbol"
        } : function(t) {
            var e = tz("Symbol");
            return nz(e) && rz(e.prototype, iz(t))
        },
        oz = String,
        az = function(t) {
            try {
                return oz(t)
            } catch {
                return "Object"
            }
        },
        cz = kr,
        uz = az,
        lz = TypeError,
        hz = function(t) {
            if (cz(t)) return t;
            throw lz(uz(t) + " is not a function")
        },
        fz = hz,
        dz = em,
        Vv = function(t, e) {
            var n = t[e];
            return dz(n) ? void 0 : fz(n)
        },
        E_ = $o,
        S_ = kr,
        T_ = cu,
        pz = TypeError,
        mz = function(t, e) {
            var n, r;
            if (e === "string" && S_(n = t.toString) && !T_(r = E_(n, t)) || S_(n = t.valueOf) && !T_(r = E_(n, t)) || e !== "string" && S_(n = t.toString) && !T_(r = E_(n, t))) return r;
            throw pz("Can't convert object to primitive value")
        },
        aA = {
            exports: {}
        },
        xT = Ir,
        gz = Object.defineProperty,
        jv = function(t, e) {
            try {
                gz(xT, t, {
                    value: e,
                    configurable: !0,
                    writable: !0
                })
            } catch {
                xT[t] = e
            }
            return e
        },
        _z = Ir,
        yz = jv,
        PT = "__core-js_shared__",
        vz = _z[PT] || yz(PT, {}),
        Gv = vz,
        RT = Gv;
    (aA.exports = function(t, e) {
        return RT[t] || (RT[t] = e !== void 0 ? e : {})
    })("versions", []).push({
        version: "3.30.2",
        mode: "global",
        copyright: " 2014-2023 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.30.2/LICENSE",
        source: "https://github.com/zloirock/core-js"
    });
    var Wv = aA.exports,
        bz = th,
        Ez = Object,
        cA = function(t) {
            return Ez(bz(t))
        },
        Sz = sr,
        Tz = cA,
        wz = Sz({}.hasOwnProperty),
        Lo = Object.hasOwn || function(e, n) {
            return wz(Tz(e), n)
        },
        Oz = sr,
        Az = 0,
        Cz = Math.random(),
        Iz = Oz(1 .toString),
        uA = function(t) {
            return "Symbol(" + (t === void 0 ? "" : t) + ")_" + Iz(++Az + Cz, 36)
        },
        kz = Ir,
        Nz = Wv,
        MT = Lo,
        xz = uA,
        Pz = sA,
        Rz = iA,
        ac = kz.Symbol,
        w_ = Nz("wks"),
        Mz = Rz ? ac.for || ac : ac && ac.withoutSetter || xz,
        xa = function(t) {
            return MT(w_, t) || (w_[t] = Pz && MT(ac, t) ? ac[t] : Mz("Symbol." + t)), w_[t]
        },
        Dz = $o,
        DT = cu,
        $T = oA,
        $z = Vv,
        Lz = mz,
        Fz = xa,
        Uz = TypeError,
        Bz = Fz("toPrimitive"),
        qz = function(t, e) {
            if (!DT(t) || $T(t)) return t;
            var n = $z(t, Bz),
                r;
            if (n) {
                if (e === void 0 && (e = "default"), r = Dz(n, t, e), !DT(r) || $T(r)) return r;
                throw Uz("Can't convert object to primitive value")
            }
            return e === void 0 && (e = "number"), Lz(t, e)
        },
        Vz = qz,
        jz = oA,
        lA = function(t) {
            var e = Vz(t, "string");
            return jz(e) ? e : e + ""
        },
        Gz = Ir,
        LT = cu,
        w1 = Gz.document,
        Wz = LT(w1) && LT(w1.createElement),
        hA = function(t) {
            return Wz ? w1.createElement(t) : {}
        },
        Hz = Do,
        Kz = qr,
        Yz = hA,
        fA = !Hz && !Kz(function() {
            return Object.defineProperty(Yz("div"), "a", {
                get: function() {
                    return 7
                }
            }).a != 7
        }),
        zz = Do,
        Zz = $o,
        Xz = HO,
        Qz = zO,
        Jz = tm,
        eZ = lA,
        tZ = Lo,
        nZ = fA,
        FT = Object.getOwnPropertyDescriptor;
    Uv.f = zz ? FT : function(e, n) {
        if (e = Jz(e), n = eZ(n), nZ) try {
            return FT(e, n)
        } catch {}
        if (tZ(e, n)) return Qz(!Zz(Xz.f, e, n), e[n])
    };
    var nh = {},
        rZ = Do,
        sZ = qr,
        dA = rZ && sZ(function() {
            return Object.defineProperty(function() {}, "prototype", {
                value: 42,
                writable: !1
            }).prototype != 42
        }),
        iZ = cu,
        oZ = String,
        aZ = TypeError,
        Pa = function(t) {
            if (iZ(t)) return t;
            throw aZ(oZ(t) + " is not an object")
        },
        cZ = Do,
        uZ = fA,
        lZ = dA,
        Af = Pa,
        UT = lA,
        hZ = TypeError,
        O_ = Object.defineProperty,
        fZ = Object.getOwnPropertyDescriptor,
        A_ = "enumerable",
        C_ = "configurable",
        I_ = "writable";
    nh.f = cZ ? lZ ? function(e, n, r) {
        if (Af(e), n = UT(n), Af(r), typeof e == "function" && n === "prototype" && "value" in r && I_ in r && !r[I_]) {
            var s = fZ(e, n);
            s && s[I_] && (e[n] = r.value, r = {
                configurable: C_ in r ? r[C_] : s[C_],
                enumerable: A_ in r ? r[A_] : s[A_],
                writable: !1
            })
        }
        return O_(e, n, r)
    } : O_ : function(e, n, r) {
        if (Af(e), n = UT(n), Af(r), uZ) try {
            return O_(e, n, r)
        } catch {}
        if ("get" in r || "set" in r) throw hZ("Accessors not supported");
        return "value" in r && (e[n] = r.value), e
    };
    var dZ = Do,
        pZ = nh,
        mZ = zO,
        Hv = dZ ? function(t, e, n) {
            return pZ.f(t, e, mZ(1, n))
        } : function(t, e, n) {
            return t[e] = n, t
        },
        pA = {
            exports: {}
        },
        O1 = Do,
        gZ = Lo,
        mA = Function.prototype,
        _Z = O1 && Object.getOwnPropertyDescriptor,
        Kv = gZ(mA, "name"),
        yZ = Kv && (function() {}).name === "something",
        vZ = Kv && (!O1 || O1 && _Z(mA, "name").configurable),
        bZ = {
            EXISTS: Kv,
            PROPER: yZ,
            CONFIGURABLE: vZ
        },
        EZ = sr,
        SZ = kr,
        A1 = Gv,
        TZ = EZ(Function.toString);
    SZ(A1.inspectSource) || (A1.inspectSource = function(t) {
        return TZ(t)
    });
    var wZ = A1.inspectSource,
        OZ = Ir,
        AZ = kr,
        BT = OZ.WeakMap,
        CZ = AZ(BT) && /native code/.test(String(BT)),
        IZ = Wv,
        kZ = uA,
        qT = IZ("keys"),
        gA = function(t) {
            return qT[t] || (qT[t] = kZ(t))
        },
        Yv = {},
        NZ = CZ,
        _A = Ir,
        xZ = cu,
        PZ = Hv,
        k_ = Lo,
        N_ = Gv,
        RZ = gA,
        MZ = Yv,
        VT = "Object already initialized",
        C1 = _A.TypeError,
        DZ = _A.WeakMap,
        Od, yl, Ad, $Z = function(t) {
            return Ad(t) ? yl(t) : Od(t, {})
        },
        LZ = function(t) {
            return function(e) {
                var n;
                if (!xZ(e) || (n = yl(e)).type !== t) throw C1("Incompatible receiver, " + t + " required");
                return n
            }
        };
    if (NZ || N_.state) {
        var js = N_.state || (N_.state = new DZ);
        js.get = js.get, js.has = js.has, js.set = js.set, Od = function(t, e) {
            if (js.has(t)) throw C1(VT);
            return e.facade = t, js.set(t, e), e
        }, yl = function(t) {
            return js.get(t) || {}
        }, Ad = function(t) {
            return js.has(t)
        }
    } else {
        var ec = RZ("state");
        MZ[ec] = !0, Od = function(t, e) {
            if (k_(t, ec)) throw C1(VT);
            return e.facade = t, PZ(t, ec, e), e
        }, yl = function(t) {
            return k_(t, ec) ? t[ec] : {}
        }, Ad = function(t) {
            return k_(t, ec)
        }
    }
    var yA = {
            set: Od,
            get: yl,
            has: Ad,
            enforce: $Z,
            getterFor: LZ
        },
        zv = sr,
        FZ = qr,
        UZ = kr,
        Cf = Lo,
        I1 = Do,
        BZ = bZ.CONFIGURABLE,
        qZ = wZ,
        vA = yA,
        VZ = vA.enforce,
        jZ = vA.get,
        jT = String,
        zf = Object.defineProperty,
        GZ = zv("".slice),
        WZ = zv("".replace),
        HZ = zv([].join),
        KZ = I1 && !FZ(function() {
            return zf(function() {}, "length", {
                value: 8
            }).length !== 8
        }),
        YZ = String(String).split("String"),
        zZ = pA.exports = function(t, e, n) {
            GZ(jT(e), 0, 7) === "Symbol(" && (e = "[" + WZ(jT(e), /^Symbol\(([^)]*)\)/, "$1") + "]"), n && n.getter && (e = "get " + e), n && n.setter && (e = "set " + e), (!Cf(t, "name") || BZ && t.name !== e) && (I1 ? zf(t, "name", {
                value: e,
                configurable: !0
            }) : t.name = e), KZ && n && Cf(n, "arity") && t.length !== n.arity && zf(t, "length", {
                value: n.arity
            });
            try {
                n && Cf(n, "constructor") && n.constructor ? I1 && zf(t, "prototype", {
                    writable: !1
                }) : t.prototype && (t.prototype = void 0)
            } catch {}
            var r = VZ(t);
            return Cf(r, "source") || (r.source = HZ(YZ, typeof e == "string" ? e : "")), t
        };
    Function.prototype.toString = zZ(function() {
        return UZ(this) && jZ(this).source || qZ(this)
    }, "toString");
    var ZZ = pA.exports,
        XZ = kr,
        QZ = nh,
        JZ = ZZ,
        eX = jv,
        bA = function(t, e, n, r) {
            r || (r = {});
            var s = r.enumerable,
                i = r.name !== void 0 ? r.name : e;
            if (XZ(n) && JZ(n, i, r), r.global) s ? t[e] = n : eX(e, n);
            else {
                try {
                    r.unsafe ? t[e] && (s = !0) : delete t[e]
                } catch {}
                s ? t[e] = n : QZ.f(t, e, {
                    value: n,
                    enumerable: !1,
                    configurable: !r.nonConfigurable,
                    writable: !r.nonWritable
                })
            }
            return t
        },
        EA = {},
        tX = Math.ceil,
        nX = Math.floor,
        rX = Math.trunc || function(e) {
            var n = +e;
            return (n > 0 ? nX : tX)(n)
        },
        sX = rX,
        nm = function(t) {
            var e = +t;
            return e !== e || e === 0 ? 0 : sX(e)
        },
        iX = nm,
        oX = Math.max,
        aX = Math.min,
        cX = function(t, e) {
            var n = iX(t);
            return n < 0 ? oX(n + e, 0) : aX(n, e)
        },
        uX = nm,
        lX = Math.min,
        SA = function(t) {
            return t > 0 ? lX(uX(t), 9007199254740991) : 0
        },
        hX = SA,
        fX = function(t) {
            return hX(t.length)
        },
        dX = tm,
        pX = cX,
        mX = fX,
        GT = function(t) {
            return function(e, n, r) {
                var s = dX(e),
                    i = mX(s),
                    a = pX(r, i),
                    c;
                if (t && n != n) {
                    for (; i > a;)
                        if (c = s[a++], c != c) return !0
                } else
                    for (; i > a; a++)
                        if ((t || a in s) && s[a] === n) return t || a || 0;
                return !t && -1
            }
        },
        gX = {
            includes: GT(!0),
            indexOf: GT(!1)
        },
        _X = sr,
        x_ = Lo,
        yX = tm,
        vX = gX.indexOf,
        bX = Yv,
        WT = _X([].push),
        TA = function(t, e) {
            var n = yX(t),
                r = 0,
                s = [],
                i;
            for (i in n) !x_(bX, i) && x_(n, i) && WT(s, i);
            for (; e.length > r;) x_(n, i = e[r++]) && (~vX(s, i) || WT(s, i));
            return s
        },
        Zv = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
        EX = TA,
        SX = Zv,
        TX = SX.concat("length", "prototype");
    EA.f = Object.getOwnPropertyNames || function(e) {
        return EX(e, TX)
    };
    var wA = {};
    wA.f = Object.getOwnPropertySymbols;
    var wX = qv,
        OX = sr,
        AX = EA,
        CX = wA,
        IX = Pa,
        kX = OX([].concat),
        NX = wX("Reflect", "ownKeys") || function(e) {
            var n = AX.f(IX(e)),
                r = CX.f;
            return r ? kX(n, r(e)) : n
        },
        HT = Lo,
        xX = NX,
        PX = Uv,
        RX = nh,
        MX = function(t, e, n) {
            for (var r = xX(e), s = RX.f, i = PX.f, a = 0; a < r.length; a++) {
                var c = r[a];
                !HT(t, c) && !(n && HT(n, c)) && s(t, c, i(e, c))
            }
        },
        DX = qr,
        $X = kr,
        LX = /#|\.prototype\./,
        rh = function(t, e) {
            var n = UX[FX(t)];
            return n == qX ? !0 : n == BX ? !1 : $X(e) ? DX(e) : !!e
        },
        FX = rh.normalize = function(t) {
            return String(t).replace(LX, ".").toLowerCase()
        },
        UX = rh.data = {},
        BX = rh.NATIVE = "N",
        qX = rh.POLYFILL = "P",
        VX = rh,
        P_ = Ir,
        jX = Uv.f,
        GX = Hv,
        WX = bA,
        HX = jv,
        KX = MX,
        YX = VX,
        OA = function(t, e) {
            var n = t.target,
                r = t.global,
                s = t.stat,
                i, a, c, l, h, d;
            if (r ? a = P_ : s ? a = P_[n] || HX(n, {}) : a = (P_[n] || {}).prototype, a)
                for (c in e) {
                    if (h = e[c], t.dontCallGetSet ? (d = jX(a, c), l = d && d.value) : l = a[c], i = YX(r ? c : n + (s ? "." : "#") + c, t.forced), !i && l !== void 0) {
                        if (typeof h == typeof l) continue;
                        KX(h, l)
                    }(t.sham || l && l.sham) && GX(h, "sham", !0), WX(a, c, h, t)
                }
        },
        zX = cu,
        ZX = eh,
        XX = xa,
        QX = XX("match"),
        JX = function(t) {
            var e;
            return zX(t) && ((e = t[QX]) !== void 0 ? !!e : ZX(t) == "RegExp")
        },
        eQ = xa,
        tQ = eQ("toStringTag"),
        AA = {};
    AA[tQ] = "z";
    var nQ = String(AA) === "[object z]",
        rQ = nQ,
        sQ = kr,
        Zf = eh,
        iQ = xa,
        oQ = iQ("toStringTag"),
        aQ = Object,
        cQ = Zf(function() {
            return arguments
        }()) == "Arguments",
        uQ = function(t, e) {
            try {
                return t[e]
            } catch {}
        },
        lQ = rQ ? Zf : function(t) {
            var e, n, r;
            return t === void 0 ? "Undefined" : t === null ? "Null" : typeof(n = uQ(e = aQ(t), oQ)) == "string" ? n : cQ ? Zf(e) : (r = Zf(e)) == "Object" && sQ(e.callee) ? "Arguments" : r
        },
        hQ = lQ,
        fQ = String,
        rm = function(t) {
            if (hQ(t) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
            return fQ(t)
        },
        dQ = Pa,
        CA = function() {
            var t = dQ(this),
                e = "";
            return t.hasIndices && (e += "d"), t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.unicodeSets && (e += "v"), t.sticky && (e += "y"), e
        },
        pQ = $o,
        mQ = Lo,
        gQ = nA,
        _Q = CA,
        KT = RegExp.prototype,
        yQ = function(t) {
            var e = t.flags;
            return e === void 0 && !("flags" in KT) && !mQ(t, "flags") && gQ(KT, t) ? pQ(_Q, t) : e
        },
        Xv = sr,
        vQ = cA,
        bQ = Math.floor,
        R_ = Xv("".charAt),
        EQ = Xv("".replace),
        M_ = Xv("".slice),
        SQ = /\$([$&'`]|\d{1,2}|<[^>]*>)/g,
        TQ = /\$([$&'`]|\d{1,2})/g,
        IA = function(t, e, n, r, s, i) {
            var a = n + t.length,
                c = r.length,
                l = TQ;
            return s !== void 0 && (s = vQ(s), l = SQ), EQ(i, l, function(h, d) {
                var p;
                switch (R_(d, 0)) {
                    case "$":
                        return "$";
                    case "&":
                        return t;
                    case "`":
                        return M_(e, 0, n);
                    case "'":
                        return M_(e, a);
                    case "<":
                        p = s[M_(d, 1, -1)];
                        break;
                    default:
                        var g = +d;
                        if (g === 0) return h;
                        if (g > c) {
                            var v = bQ(g / 10);
                            return v === 0 ? h : v <= c ? r[v - 1] === void 0 ? R_(d, 1) : r[v - 1] + R_(d, 1) : h
                        }
                        p = r[g - 1]
                }
                return p === void 0 ? "" : p
            })
        },
        wQ = OA,
        OQ = $o,
        Qv = sr,
        YT = th,
        AQ = kr,
        CQ = em,
        IQ = JX,
        Bu = rm,
        kQ = Vv,
        NQ = yQ,
        xQ = IA,
        PQ = xa,
        RQ = PQ("replace"),
        MQ = TypeError,
        kA = Qv("".indexOf);
    Qv("".replace);
    var zT = Qv("".slice),
        DQ = Math.max,
        ZT = function(t, e, n) {
            return n > t.length ? -1 : e === "" ? n : kA(t, e, n)
        };
    wQ({
        target: "String",
        proto: !0
    }, {
        replaceAll: function(e, n) {
            var r = YT(this),
                s, i, a, c, l, h, d, p, g, v = 0,
                b = 0,
                T = "";
            if (!CQ(e)) {
                if (s = IQ(e), s && (i = Bu(YT(NQ(e))), !~kA(i, "g"))) throw MQ("`.replaceAll` does not allow non-global regexes");
                if (a = kQ(e, RQ), a) return OQ(a, e, r, n)
            }
            for (c = Bu(r), l = Bu(e), h = AQ(n), h || (n = Bu(n)), d = l.length, p = DQ(1, d), v = ZT(c, l, 0); v !== -1;) g = h ? Bu(n(l, v, c)) : xQ(l, c, v, [], void 0, n), T += zT(c, b, v) + g, b = v + d, v = ZT(c, l, v + p);
            return b < c.length && (T += zT(c, b)), T
        }
    });
    var Jv = qr,
        $Q = Ir,
        e0 = $Q.RegExp,
        t0 = Jv(function() {
            var t = e0("a", "y");
            return t.lastIndex = 2, t.exec("abcd") != null
        }),
        LQ = t0 || Jv(function() {
            return !e0("a", "y").sticky
        }),
        FQ = t0 || Jv(function() {
            var t = e0("^r", "gy");
            return t.lastIndex = 2, t.exec("str") != null
        }),
        UQ = {
            BROKEN_CARET: FQ,
            MISSED_STICKY: LQ,
            UNSUPPORTED_Y: t0
        },
        NA = {},
        BQ = TA,
        qQ = Zv,
        VQ = Object.keys || function(e) {
            return BQ(e, qQ)
        },
        jQ = Do,
        GQ = dA,
        WQ = nh,
        HQ = Pa,
        KQ = tm,
        YQ = VQ;
    NA.f = jQ && !GQ ? Object.defineProperties : function(e, n) {
        HQ(e);
        for (var r = KQ(n), s = YQ(n), i = s.length, a = 0, c; i > a;) WQ.f(e, c = s[a++], r[c]);
        return e
    };
    var zQ = qv,
        ZQ = zQ("document", "documentElement"),
        XQ = Pa,
        QQ = NA,
        XT = Zv,
        JQ = Yv,
        eJ = ZQ,
        tJ = hA,
        nJ = gA,
        QT = ">",
        JT = "<",
        k1 = "prototype",
        N1 = "script",
        xA = nJ("IE_PROTO"),
        D_ = function() {},
        PA = function(t) {
            return JT + N1 + QT + t + JT + "/" + N1 + QT
        },
        ew = function(t) {
            t.write(PA("")), t.close();
            var e = t.parentWindow.Object;
            return t = null, e
        },
        rJ = function() {
            var t = tJ("iframe"),
                e = "java" + N1 + ":",
                n;
            return t.style.display = "none", eJ.appendChild(t), t.src = String(e), n = t.contentWindow.document, n.open(), n.write(PA("document.F=Object")), n.close(), n.F
        },
        If, Xf = function() {
            try {
                If = new ActiveXObject("htmlfile")
            } catch {}
            Xf = typeof document < "u" ? document.domain && If ? ew(If) : rJ() : ew(If);
            for (var t = XT.length; t--;) delete Xf[k1][XT[t]];
            return Xf()
        };
    JQ[xA] = !0;
    var sJ = Object.create || function(e, n) {
            var r;
            return e !== null ? (D_[k1] = XQ(e), r = new D_, D_[k1] = null, r[xA] = e) : r = Xf(), n === void 0 ? r : QQ.f(r, n)
        },
        iJ = qr,
        oJ = Ir,
        aJ = oJ.RegExp,
        cJ = iJ(function() {
            var t = aJ(".", "s");
            return !(t.dotAll && t.exec(`
`) && t.flags === "s")
        }),
        uJ = qr,
        lJ = Ir,
        hJ = lJ.RegExp,
        fJ = uJ(function() {
            var t = hJ("(?<a>b)", "g");
            return t.exec("b").groups.a !== "b" || "b".replace(t, "$<a>c") !== "bc"
        }),
        cc = $o,
        sm = sr,
        dJ = rm,
        pJ = CA,
        mJ = UQ,
        gJ = Wv,
        _J = sJ,
        yJ = yA.get,
        vJ = cJ,
        bJ = fJ,
        EJ = gJ("native-string-replace", String.prototype.replace),
        Cd = RegExp.prototype.exec,
        x1 = Cd,
        SJ = sm("".charAt),
        TJ = sm("".indexOf),
        wJ = sm("".replace),
        $_ = sm("".slice),
        P1 = function() {
            var t = /a/,
                e = /b*/g;
            return cc(Cd, t, "a"), cc(Cd, e, "a"), t.lastIndex !== 0 || e.lastIndex !== 0
        }(),
        RA = mJ.BROKEN_CARET,
        R1 = /()??/.exec("")[1] !== void 0,
        OJ = P1 || R1 || RA || vJ || bJ;
    OJ && (x1 = function(e) {
        var n = this,
            r = yJ(n),
            s = dJ(e),
            i = r.raw,
            a, c, l, h, d, p, g;
        if (i) return i.lastIndex = n.lastIndex, a = cc(x1, i, s), n.lastIndex = i.lastIndex, a;
        var v = r.groups,
            b = RA && n.sticky,
            T = cc(pJ, n),
            m = n.source,
            w = 0,
            P = s;
        if (b && (T = wJ(T, "y", ""), TJ(T, "g") === -1 && (T += "g"), P = $_(s, n.lastIndex), n.lastIndex > 0 && (!n.multiline || n.multiline && SJ(s, n.lastIndex - 1) !== `
`) && (m = "(?: " + m + ")", P = " " + P, w++), c = new RegExp("^(?:" + m + ")", T)), R1 && (c = new RegExp("^" + m + "$(?!\\s)", T)), P1 && (l = n.lastIndex), h = cc(Cd, b ? c : n, P), b ? h ? (h.input = $_(h.input, w), h[0] = $_(h[0], w), h.index = n.lastIndex, n.lastIndex += h[0].length) : n.lastIndex = 0 : P1 && h && (n.lastIndex = n.global ? h.index + h[0].length : l), R1 && h && h.length > 1 && cc(EJ, h[0], c, function() {
                for (d = 1; d < arguments.length - 2; d++) arguments[d] === void 0 && (h[d] = void 0)
            }), h && v)
            for (h.groups = p = _J(null), d = 0; d < v.length; d++) g = v[d], p[g[0]] = h[g[1]];
        return h
    });
    var n0 = x1,
        AJ = OA,
        tw = n0;
    AJ({
        target: "RegExp",
        proto: !0,
        forced: /./.exec !== tw
    }, {
        exec: tw
    });
    var CJ = Bv,
        MA = Function.prototype,
        nw = MA.apply,
        rw = MA.call,
        IJ = typeof Reflect == "object" && Reflect.apply || (CJ ? rw.bind(nw) : function() {
            return rw.apply(nw, arguments)
        }),
        kJ = eh,
        NJ = sr,
        xJ = function(t) {
            if (kJ(t) === "Function") return NJ(t)
        },
        sw = xJ,
        iw = bA,
        PJ = n0,
        ow = qr,
        DA = xa,
        RJ = Hv,
        MJ = DA("species"),
        L_ = RegExp.prototype,
        DJ = function(t, e, n, r) {
            var s = DA(t),
                i = !ow(function() {
                    var h = {};
                    return h[s] = function() {
                        return 7
                    }, "" [t](h) != 7
                }),
                a = i && !ow(function() {
                    var h = !1,
                        d = /a/;
                    return t === "split" && (d = {}, d.constructor = {}, d.constructor[MJ] = function() {
                        return d
                    }, d.flags = "", d[s] = /./ [s]), d.exec = function() {
                        return h = !0, null
                    }, d[s](""), !h
                });
            if (!i || !a || n) {
                var c = sw(/./ [s]),
                    l = e(s, "" [t], function(h, d, p, g, v) {
                        var b = sw(h),
                            T = d.exec;
                        return T === PJ || T === L_.exec ? i && !v ? {
                            done: !0,
                            value: c(d, p, g)
                        } : {
                            done: !0,
                            value: b(p, d, g)
                        } : {
                            done: !1
                        }
                    });
                iw(String.prototype, t, l[0]), iw(L_, s, l[1])
            }
            r && RJ(L_[s], "sham", !0)
        },
        r0 = sr,
        $J = nm,
        LJ = rm,
        FJ = th,
        UJ = r0("".charAt),
        aw = r0("".charCodeAt),
        BJ = r0("".slice),
        cw = function(t) {
            return function(e, n) {
                var r = LJ(FJ(e)),
                    s = $J(n),
                    i = r.length,
                    a, c;
                return s < 0 || s >= i ? t ? "" : void 0 : (a = aw(r, s), a < 55296 || a > 56319 || s + 1 === i || (c = aw(r, s + 1)) < 56320 || c > 57343 ? t ? UJ(r, s) : a : t ? BJ(r, s, s + 2) : (a - 55296 << 10) + (c - 56320) + 65536)
            }
        },
        qJ = {
            codeAt: cw(!1),
            charAt: cw(!0)
        },
        VJ = qJ.charAt,
        jJ = function(t, e, n) {
            return e + (n ? VJ(t, e).length : 1)
        },
        uw = $o,
        GJ = Pa,
        WJ = kr,
        HJ = eh,
        KJ = n0,
        YJ = TypeError,
        zJ = function(t, e) {
            var n = t.exec;
            if (WJ(n)) {
                var r = uw(n, t, e);
                return r !== null && GJ(r), r
            }
            if (HJ(t) === "RegExp") return uw(KJ, t, e);
            throw YJ("RegExp#exec called on incompatible receiver")
        },
        ZJ = IJ,
        lw = $o,
        im = sr,
        XJ = DJ,
        QJ = qr,
        JJ = Pa,
        eee = kr,
        tee = em,
        nee = nm,
        ree = SA,
        tc = rm,
        see = th,
        iee = jJ,
        oee = Vv,
        aee = IA,
        cee = zJ,
        uee = xa,
        M1 = uee("replace"),
        lee = Math.max,
        hee = Math.min,
        fee = im([].concat),
        F_ = im([].push),
        hw = im("".indexOf),
        fw = im("".slice),
        dee = function(t) {
            return t === void 0 ? t : String(t)
        },
        pee = function() {
            return "a".replace(/./, "$0") === "$0"
        }(),
        dw = function() {
            return /./ [M1] ? /./ [M1]("a", "$0") === "" : !1
        }(),
        mee = !QJ(function() {
            var t = /./;
            return t.exec = function() {
                var e = [];
                return e.groups = {
                    a: "7"
                }, e
            }, "".replace(t, "$<a>") !== "7"
        });
    XJ("replace", function(t, e, n) {
        var r = dw ? "$" : "$0";
        return [function(i, a) {
            var c = see(this),
                l = tee(i) ? void 0 : oee(i, M1);
            return l ? lw(l, i, c, a) : lw(e, tc(c), i, a)
        }, function(s, i) {
            var a = JJ(this),
                c = tc(s);
            if (typeof i == "string" && hw(i, r) === -1 && hw(i, "$<") === -1) {
                var l = n(e, a, c, i);
                if (l.done) return l.value
            }
            var h = eee(i);
            h || (i = tc(i));
            var d = a.global;
            if (d) {
                var p = a.unicode;
                a.lastIndex = 0
            }
            for (var g = [];;) {
                var v = cee(a, c);
                if (v === null || (F_(g, v), !d)) break;
                var b = tc(v[0]);
                b === "" && (a.lastIndex = iee(c, ree(a.lastIndex), p))
            }
            for (var T = "", m = 0, w = 0; w < g.length; w++) {
                v = g[w];
                for (var P = tc(v[0]), V = lee(hee(nee(v.index), c.length), 0), M = [], I = 1; I < v.length; I++) F_(M, dee(v[I]));
                var L = v.groups;
                if (h) {
                    var B = fee([P], M, V, c);
                    L !== void 0 && F_(B, L);
                    var q = tc(ZJ(i, void 0, B))
                } else q = aee(P, c, V, M, L, i);
                V >= m && (T += fw(c, m, V) + q, m = V + P.length)
            }
            return T + fw(c, m)
        }]
    }, !mee || !pee || dw);
    var gee = Ir,
        _ee = sr,
        yee = function(t, e) {
            return _ee(gee[t].prototype[e])
        },
        vee = yee;
    vee("String", "replaceAll");
    var bi = {},
        om = {},
        $A = {},
        am = {},
        s0 = {};
    (function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.Token = void 0;
        var e = function() {
            function n(r, s, i, a) {
                this.type = r, this.content = s, this.attributes = i, this.text = a
            }
            return n.prototype.toString = function() {
                return this.content + " (" + this.type + ")"
            }, n.prototype.equals = function(r) {
                return this.type === r.type && this.content === r.content
            }, n.prototype.convertToTextToken = function() {
                var r;
                this.type === n.Type.startTag ? (this.content = (r = this.text) !== null && r !== void 0 ? r : "", this.type = n.Type.text) : this.type === n.Type.endTag && (this.content = "[/" + this.content + "]", this.type = n.Type.text)
            }, n
        }();
        t.Token = e,
            function(n) {
                (function(r) {
                    r[r.text = 0] = "text", r[r.startTag = 1] = "startTag", r[r.endTag = 2] = "endTag"
                })(n.Type || (n.Type = {}))
            }(e = t.Token || (t.Token = {})), t.Token = e
    })(s0);
    Object.defineProperty(am, "__esModule", {
        value: !0
    });
    am.Tokenizer = void 0;
    var to = s0,
        bee = function() {
            function t(e) {
                this.tags = e
            }
            return t.prototype.tokenizeString = function(e) {
                var n = this,
                    r = this.getTokens(e),
                    s = [],
                    i = !1,
                    a = "",
                    c = "";
                return r.forEach(function(l) {
                    var h = n.tags[l.content],
                        d = !0;
                    !h && !i ? l.convertToTextToken() : i ? l.type === to.Token.Type.endTag && l.content === a ? (i = !1, s.push(t.createTextToken(c))) : (l.convertToTextToken(), c += l.content, d = !1) : h.noNesting && l.type === to.Token.Type.startTag && (i = !0, a = l.content, c = ""), d && s.push(l)
                }), s
            }, t.prototype.getTokens = function(e) {
                for (var n = '\\[(/\\w*)\\]|\\[(\\w*)+(=(["])' + t.valueChars + "*\\4)?( (" + t.nameChars + '+)?=(["])(' + t.valueChars + "+)\\7)*\\]", r = new RegExp(n, "g"), s = [], i = r.exec(e), a = 0; i;) {
                    var c = i.index - a;
                    c > 0 && s.push(t.createTextToken(e.substr(a, c))), s.push(t.createTagToken(i)), a = r.lastIndex, i = r.exec(e)
                }
                var l = e.length - a;
                return l > 0 && s.push(t.createTextToken(e.substr(a, l))), s
            }, t.createTextToken = function(e) {
                return new to.Token(to.Token.Type.text, e)
            }, t.createTagToken = function(e) {
                if (!e[1]) {
                    for (var n = e[2], r = {}, s = new RegExp("(" + t.nameChars + '+)?=(["])(' + t.valueChars + "+)\\2", "g"), i = e[0].substr(1 + n.length, e[0].length - 2 - n.length), a = s.exec(i); a;) a[1] ? r[a[1]] = a[3] : r[n] = a[3], a = s.exec(i);
                    return new to.Token(to.Token.Type.startTag, n, r, e[0])
                }
                return new to.Token(to.Token.Type.endTag, e[1].substr(1, e[1].length - 1))
            }, t.nameChars = "[a-zA-Z0-9\\.\\-_:;/]", t.valueChars = "[a-zA-Z0-9\\.\\-_:;#/\\s]", t
        }();
    am.Tokenizer = bee;
    (function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.ParseTree = void 0;
        var e = am,
            n = s0,
            r = function() {
                function s(i) {
                    this.subTrees = [], this.type = i.type, this.content = i.content, i.attributes && (this.attributes = i.attributes), i.subTrees && (this.subTrees = i.subTrees)
                }
                return Object.defineProperty(s.prototype, "isValid", {
                    get: function() {
                        return this.subTrees.length ? this.subTrees.every(function(i) {
                            return i.isValid
                        }) : !0
                    },
                    enumerable: !1,
                    configurable: !0
                }), s.prototype.toString = function() {
                    return this.type + " - " + this.content
                }, s.buildTree = function(i, a) {
                    var c = new e.Tokenizer(a),
                        l = c.tokenizeString(i),
                        h = new s({
                            type: s.Type.root,
                            content: i
                        });
                    return this.buildTreeFromTokens(h, l.reverse())
                }, s.buildTreeFromTokens = function(i, a, c) {
                    if (c === void 0 && (c = ""), !i) return null;
                    if (!a.length) return i;
                    var l = a.pop();
                    if (!l) return null;
                    if (l.type === n.Token.Type.text) {
                        var h = new s({
                            type: s.Type.text,
                            content: l.content
                        });
                        i.subTrees.push(h)
                    }
                    if (l.type === n.Token.Type.startTag) {
                        var d = l.content,
                            h = new s({
                                type: s.Type.tag,
                                content: d,
                                attributes: l.attributes
                            }),
                            p = s.buildTreeFromTokens(h, a, d);
                        if (!p) return null;
                        i.subTrees.push(p)
                    }
                    if (l.type === n.Token.Type.endTag) {
                        var d = l.content;
                        return d === c ? i : null
                    }
                    return !a.length && c !== "" ? null : this.buildTreeFromTokens(i, a, c)
                }, s
            }();
        t.ParseTree = r,
            function(s) {
                (function(i) {
                    i[i.root = 0] = "root", i[i.text = 1] = "text", i[i.tag = 2] = "tag"
                })(s.Type || (s.Type = {}))
            }(r = t.ParseTree || (t.ParseTree = {})), t.ParseTree = r
    })($A);
    var sh = {};
    Object.defineProperty(sh, "__esModule", {
        value: !0
    });
    sh.Tag = void 0;
    var Eee = function() {
        function t(e) {
            var n;
            this.tagName = e.tagName, this.insertLineBreaks = e.insertLineBreaks, this.suppressLineBreaks = e.suppressLineBreaks, this.noNesting = e.noNesting, this.markupGenerator = (n = e.markupGenerator) !== null && n !== void 0 ? n : function(r, s) {
                return "<" + r.tagName + ">" + s + "</" + r.tagName + ">"
            }
        }
        return t.create = function(e, n, r) {
            var s, i, a;
            return r === void 0 && (r = {}), new t({
                tagName: e,
                insertLineBreaks: (s = r.insertLineBreaks) !== null && s !== void 0 ? s : !0,
                suppressLineBreaks: (i = r.suppressLineBreaks) !== null && i !== void 0 ? i : !1,
                noNesting: (a = r.noNesting) !== null && a !== void 0 ? a : !1,
                markupGenerator: n
            })
        }, t
    }();
    sh.Tag = Eee;
    Object.defineProperty(om, "__esModule", {
        value: !0
    });
    om.BBCodeParser = void 0;
    var pw = $A,
        mw = sh,
        See = function() {
            function t(e, n) {
                this.options = n, this.escapeHTML = !1, this.tags = e, n && (this.escapeHTML = n.escapeHTML)
            }
            return Object.defineProperty(t, "defaultTags", {
                get: function() {
                    return {
                        b: mw.Tag.create("b"),
                        i: mw.Tag.create("i")
                    }
                },
                enumerable: !1,
                configurable: !0
            }), t.prototype.parse = function(e, n, r, s) {
                n === void 0 && (n = !1), r === void 0 && (r = !0), s === void 0 && (s = !0);
                var i = pw.ParseTree.buildTree(e, this.tags);
                return !i || !i.isValid ? e : this.treeToHtml(i.subTrees, r, s, n)
            }, t.prototype.addTag = function(e, n) {
                this.tags[e] = n
            }, t.prototype.treeToHtml = function(e, n, r, s) {
                var i = this;
                s === void 0 && (s = !1);
                var a = "",
                    c = !1;
                return e.forEach(function(l) {
                    var h;
                    if (l.type === pw.ParseTree.Type.text) {
                        var d = l.content;
                        r && (d = i.escapeHTML ? t.escapeHTML(d) : d), n && !c && (d = d.replace(/(\r\n|\n|\r)/gm, "<br>"), c = !1), a += d
                    } else {
                        var p = i.tags[l.content],
                            g = i.treeToHtml(l.subTrees, p.insertLineBreaks, r, s);
                        s ? a += g : a += p.markupGenerator(p, g, (h = l.attributes) !== null && h !== void 0 ? h : {}), c = p.suppressLineBreaks
                    }
                }), a
            }, t.escapeHTML = function(e) {
                return e.replace(/[&<>]/g, function(n) {
                    return t.tagsToReplace[n] || n
                })
            }, t.tagsToReplace = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;"
            }, t
        }();
    om.BBCodeParser = See;
    (function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.Tag = t.BBCodeParser = void 0;
        var e = om;
        Object.defineProperty(t, "BBCodeParser", {
            enumerable: !0,
            get: function() {
                return e.BBCodeParser
            }
        });
        var n = sh;
        Object.defineProperty(t, "Tag", {
            enumerable: !0,
            get: function() {
                return n.Tag
            }
        })
    })(bi);
    const Tee = {
            install: t => {
                const e = {
                    section: bi.Tag.create("section", (i, a, {
                        section: c
                    }) => `<div ${c?`class="section ${c}"`:'class="section"'}>${a}</div>`)
                };
                ["b", "bold", "B"].forEach(i => {
                    e[i] = bi.Tag.create(i, (a, c) => `<strong>${c}</strong>`)
                }), ["i", "italic", "I"].forEach(i => {
                    e[i] = bi.Tag.create(i, (a, c) => `<em>${c}</em>`)
                }), e.tos = bi.Tag.create("tos", (i, a) => `<a class="tosLink" href="https://jackboxgames.com/terms-of-service/" target="_blank">${a}</a>`), e.pp = bi.Tag.create("pp", (i, a) => `<a class="ppLink" href="https://jackboxgames.com/privacy-policy/" target="_blank">${a}</a>`);
                const s = new bi.BBCodeParser(e);
                t.directive("bb", {
                    mounted(i, a) {
                        const c = document.createElement("div");
                        c.textContent = a.value, i.innerHTML = s.parse(c.innerHTML)
                    },
                    updated(i, a) {
                        const c = document.createElement("div");
                        c.textContent = a.value, i.innerHTML = s.parse(c.innerHTML)
                    }
                }), t.mixin({
                    beforeCreate() {
                        this.$options.bb && Object.keys(this.$options.bb).forEach(i => {
                            const a = this.$options.bb[i];
                            if (a instanceof Function) {
                                s.addTag(i, bi.Tag.create(i, a));
                                return
                            }
                            s.addTag(i, bi.Tag.create(i, a.generator, a.options))
                        })
                    }
                }), t.config.globalProperties.$bb = i => (typeof i != "string" && console.warn(`[BBCodePlugin] Received unexpected ${typeof i} with value ${i};converting to string before parsing.`), s.parse(String(i)))
            }
        },
        wee = yt({
            data() {
                return {
                    showPowerNav: !1
                }
            },
            computed: {
                debugNav() {
                    return this.$refs.debugNav
                },
                replayer() {
                    return this.$debugReplayer
                }
            },
            mounted() {
                window.addEventListener("keydown", t => {
                    var e, n, r, s;
                    return t.key === "," ? (e = this.replayer) == null ? void 0 : e.toPreviousEntity() : t.key === "." ? (n = this.replayer) == null ? void 0 : n.toNextEntity() : t.key === "q" ? (r = this.replayer) == null ? void 0 : r.toPreviousMarker() : t.key === "w" ? (s = this.replayer) == null ? void 0 : s.toNextMarker() : null
                })
            },
            methods: {
                onPreviousClick() {
                    var t;
                    (t = this.replayer) == null || t.toPreviousMarker()
                },
                onNextClick() {
                    var t;
                    (t = this.replayer) == null || t.toNextMarker()
                },
                onOpenPowerNavClick() {
                    this.showPowerNav = !0, this.debugNav.focus()
                },
                onClosePowerNavClick() {
                    this.showPowerNav = !1, this.debugNav.focus()
                },
                onMarkerClick(t) {
                    var e;
                    (e = this.replayer) == null || e.toMarkerIndex(t)
                },
                onKillClick() {
                    var t;
                    (t = this.replayer) == null || t.kill()
                },
                onDisconnectClick() {
                    var t;
                    (t = this.replayer) == null || t.disconnect()
                }
            }
        }),
        Ui = t => (Di("data-v-220ec4c0"), t = t(), $i(), t),
        Oee = {
            key: 0,
            ref: "debugNav",
            class: "debug-nav",
            tabindex: "0"
        },
        Aee = {
            key: 0,
            class: "power-nav"
        },
        Cee = Ui(() => W("p", null, "MARKERS", -1)),
        Iee = ["onClick"],
        kee = Ui(() => W("br", null, null, -1)),
        Nee = Ui(() => W("p", {
            class: "title blurred"
        }, "DEBUG", -1)),
        xee = {
            key: 1,
            class: "title focused"
        },
        Pee = {
            key: 2,
            class: "title focused"
        },
        Ree = Ui(() => W("svg", {
            viewBox: "0 0 20 10"
        }, [W("polygon", {
            points: "0,10 10,0 20,10"
        })], -1)),
        Mee = Ui(() => W("div", {
            class: "visually-hidden"
        }, "Open debug menu", -1)),
        Dee = [Ree, Mee],
        $ee = Ui(() => W("svg", {
            viewBox: "0 0 60 50"
        }, [W("polygon", {
            class: "outline",
            points: "40,35.6 20,25 40,14.4"
        }), W("polygon", {
            points: "40,35.6 20,25 40,14.4"
        })], -1)),
        Lee = Ui(() => W("div", {
            class: "visually-hidden"
        }, "Previous", -1)),
        Fee = [$ee, Lee],
        Uee = Ui(() => W("svg", {
            viewBox: "0 0 60 50"
        }, [W("polygon", {
            class: "outline",
            points: "40,35.6 20,25 40,14.4"
        }), W("polygon", {
            points: "40,35.6 20,25 40,14.4"
        })], -1)),
        Bee = Ui(() => W("div", {
            class: "visually-hidden"
        }, "Next", -1)),
        qee = [Uee, Bee];

    function Vee(t, e, n, r, s, i) {
        return t.replayer ? (Y(), X("div", Oee, [t.showPowerNav ? (Y(), X("div", Aee, [W("button", {
            class: "close",
            onClick: e[0] || (e[0] = (...a) => t.onClosePowerNavClick && t.onClosePowerNavClick(...a))
        }, "X"), Cee, W("ul", null, [(Y(!0), X(St, null, In(t.replayer.markerMap, (a, c) => (Y(), X("li", {
            key: c,
            class: mt({
                active: c === t.replayer.currentMarkerItemIndex
            }),
            onClick: l => t.onMarkerClick(c)
        }, _t(a[1].marker), 11, Iee))), 128))]), W("button", {
            class: "option",
            onClick: e[1] || (e[1] = (...a) => t.onKillClick && t.onKillClick(...a))
        }, [Nn("KILL"), kee, Nn("ROOM")]), W("button", {
            class: "option",
            onClick: e[2] || (e[2] = (...a) => t.onDisconnectClick && t.onDisconnectClick(...a))
        }, "DISCONNECT")])) : Ve("", !0), Nee, t.replayer.markerMap.length ? (Y(), X("p", Pee, _t(t.replayer.currentMarkerItemIndex) + " : " + _t(t.replayer.currentMarkerItem[1].marker) + " (" + _t(t.replayer.currentEntityItemIndex) + ") ", 1)) : (Y(), X("p", xee, "Item #" + _t(t.replayer.currentEntityItemIndex), 1)), t.showPowerNav ? Ve("", !0) : (Y(), X("button", {
            key: 3,
            class: "open-power-nav",
            onClick: e[3] || (e[3] = (...a) => t.onOpenPowerNavClick && t.onOpenPowerNavClick(...a))
        }, Dee)), W("button", {
            class: "direction previous",
            onClick: e[4] || (e[4] = (...a) => t.onPreviousClick && t.onPreviousClick(...a))
        }, Fee), W("button", {
            class: "direction next",
            onClick: e[5] || (e[5] = (...a) => t.onNextClick && t.onNextClick(...a))
        }, qee)], 512)) : Ve("", !0)
    }
    const jee = ct(wee, [
        ["render", Vee],
        ["__scopeId", "data-v-220ec4c0"]
    ]);

    function Gee(t, e) {
        for (var n = -1, r = t == null ? 0 : t.length; ++n < r && e(t[n], n, t) !== !1;);
        return t
    }
    var Wee = Gee,
        Hee = A4,
        Kee = Hee(Object.keys, Object),
        Yee = Kee,
        zee = pv,
        Zee = Yee,
        Xee = Object.prototype,
        Qee = Xee.hasOwnProperty;

    function Jee(t) {
        if (!zee(t)) return Zee(t);
        var e = [];
        for (var n in Object(t)) Qee.call(t, n) && n != "constructor" && e.push(n);
        return e
    }
    var ete = Jee,
        tte = M4,
        nte = ete,
        rte = Zp;

    function ste(t) {
        return rte(t) ? tte(t) : nte(t)
    }
    var cm = ste,
        ite = Zl,
        ote = cm;

    function ate(t, e) {
        return t && ite(e, ote(e), t)
    }
    var cte = ate,
        ute = Zl,
        lte = Xl;

    function hte(t, e) {
        return t && ute(e, lte(e), t)
    }
    var fte = hte;

    function dte(t, e) {
        for (var n = -1, r = t == null ? 0 : t.length, s = 0, i = []; ++n < r;) {
            var a = t[n];
            e(a, n, t) && (i[s++] = a)
        }
        return i
    }
    var pte = dte;

    function mte() {
        return []
    }
    var LA = mte,
        gte = pte,
        _te = LA,
        yte = Object.prototype,
        vte = yte.propertyIsEnumerable,
        gw = Object.getOwnPropertySymbols,
        bte = gw ? function(t) {
            return t == null ? [] : (t = Object(t), gte(gw(t), function(e) {
                return vte.call(t, e)
            }))
        } : _te,
        i0 = bte,
        Ete = Zl,
        Ste = i0;

    function Tte(t, e) {
        return Ete(t, Ste(t), e)
    }
    var wte = Tte;

    function Ote(t, e) {
        for (var n = -1, r = e.length, s = t.length; ++n < r;) t[s + n] = e[n];
        return t
    }
    var FA = Ote,
        Ate = FA,
        Cte = dv,
        Ite = i0,
        kte = LA,
        Nte = Object.getOwnPropertySymbols,
        xte = Nte ? function(t) {
            for (var e = []; t;) Ate(e, Ite(t)), t = Cte(t);
            return e
        } : kte,
        UA = xte,
        Pte = Zl,
        Rte = UA;

    function Mte(t, e) {
        return Pte(t, Rte(t), e)
    }
    var Dte = Mte,
        $te = FA,
        Lte = Ro;

    function Fte(t, e, n) {
        var r = e(t);
        return Lte(t) ? r : $te(r, n(t))
    }
    var BA = Fte,
        Ute = BA,
        Bte = i0,
        qte = cm;

    function Vte(t) {
        return Ute(t, qte, Bte)
    }
    var jte = Vte,
        Gte = BA,
        Wte = UA,
        Hte = Xl;

    function Kte(t) {
        return Gte(t, Hte, Wte)
    }
    var Yte = Kte,
        zte = Na,
        Zte = Ps,
        Xte = zte(Zte, "DataView"),
        Qte = Xte,
        Jte = Na,
        ene = Ps,
        tne = Jte(ene, "Promise"),
        nne = tne,
        rne = Na,
        sne = Ps,
        ine = rne(sne, "Set"),
        one = ine,
        ane = Na,
        cne = Ps,
        une = ane(cne, "WeakMap"),
        lne = une,
        D1 = Qte,
        $1 = lv,
        L1 = nne,
        F1 = one,
        U1 = lne,
        qA = ru,
        uu = y4,
        _w = "[object Map]",
        hne = "[object Object]",
        yw = "[object Promise]",
        vw = "[object Set]",
        bw = "[object WeakMap]",
        Ew = "[object DataView]",
        fne = uu(D1),
        dne = uu($1),
        pne = uu(L1),
        mne = uu(F1),
        gne = uu(U1),
        na = qA;
    (D1 && na(new D1(new ArrayBuffer(1))) != Ew || $1 && na(new $1) != _w || L1 && na(L1.resolve()) != yw || F1 && na(new F1) != vw || U1 && na(new U1) != bw) && (na = function(t) {
        var e = qA(t),
            n = e == hne ? t.constructor : void 0,
            r = n ? uu(n) : "";
        if (r) switch (r) {
            case fne:
                return Ew;
            case dne:
                return _w;
            case pne:
                return yw;
            case mne:
                return vw;
            case gne:
                return bw
        }
        return e
    });
    var o0 = na,
        _ne = Object.prototype,
        yne = _ne.hasOwnProperty;

    function vne(t) {
        var e = t.length,
            n = new t.constructor(e);
        return e && typeof t[0] == "string" && yne.call(t, "index") && (n.index = t.index, n.input = t.input), n
    }
    var bne = vne,
        Ene = fv;

    function Sne(t, e) {
        var n = e ? Ene(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.byteLength)
    }
    var Tne = Sne,
        wne = /\w*$/;

    function One(t) {
        var e = new t.constructor(t.source, wne.exec(t));
        return e.lastIndex = t.lastIndex, e
    }
    var Ane = One,
        Sw = Kp,
        Tw = Sw ? Sw.prototype : void 0,
        ww = Tw ? Tw.valueOf : void 0;

    function Cne(t) {
        return ww ? Object(ww.call(t)) : {}
    }
    var Ine = Cne,
        kne = fv,
        Nne = Tne,
        xne = Ane,
        Pne = Ine,
        Rne = w4,
        Mne = "[object Boolean]",
        Dne = "[object Date]",
        $ne = "[object Map]",
        Lne = "[object Number]",
        Fne = "[object RegExp]",
        Une = "[object Set]",
        Bne = "[object String]",
        qne = "[object Symbol]",
        Vne = "[object ArrayBuffer]",
        jne = "[object DataView]",
        Gne = "[object Float32Array]",
        Wne = "[object Float64Array]",
        Hne = "[object Int8Array]",
        Kne = "[object Int16Array]",
        Yne = "[object Int32Array]",
        zne = "[object Uint8Array]",
        Zne = "[object Uint8ClampedArray]",
        Xne = "[object Uint16Array]",
        Qne = "[object Uint32Array]";

    function Jne(t, e, n) {
        var r = t.constructor;
        switch (e) {
            case Vne:
                return kne(t);
            case Mne:
            case Dne:
                return new r(+t);
            case jne:
                return Nne(t, n);
            case Gne:
            case Wne:
            case Hne:
            case Kne:
            case Yne:
            case zne:
            case Zne:
            case Xne:
            case Qne:
                return Rne(t, n);
            case $ne:
                return new r;
            case Lne:
            case Bne:
                return new r(t);
            case Fne:
                return xne(t);
            case Une:
                return new r;
            case qne:
                return Pne(t)
        }
    }
    var ere = Jne,
        tre = o0,
        nre = Po,
        rre = "[object Map]";

    function sre(t) {
        return nre(t) && tre(t) == rre
    }
    var ire = sre,
        ore = ire,
        are = gv,
        Ow = _v,
        Aw = Ow && Ow.isMap,
        cre = Aw ? are(Aw) : ore,
        ure = cre,
        lre = o0,
        hre = Po,
        fre = "[object Set]";

    function dre(t) {
        return hre(t) && lre(t) == fre
    }
    var pre = dre,
        mre = pre,
        gre = gv,
        Cw = _v,
        Iw = Cw && Cw.isSet,
        _re = Iw ? gre(Iw) : mre,
        yre = _re,
        vre = b4,
        bre = Wee,
        Ere = yv,
        Sre = cte,
        Tre = fte,
        wre = T4,
        Ore = O4,
        Are = wte,
        Cre = Dte,
        Ire = jte,
        kre = Yte,
        Nre = o0,
        xre = bne,
        Pre = ere,
        Rre = C4,
        Mre = Ro,
        Dre = mv,
        $re = ure,
        Lre = Rs,
        Fre = yre,
        Ure = cm,
        Bre = Xl,
        qre = 1,
        Vre = 2,
        jre = 4,
        VA = "[object Arguments]",
        Gre = "[object Array]",
        Wre = "[object Boolean]",
        Hre = "[object Date]",
        Kre = "[object Error]",
        jA = "[object Function]",
        Yre = "[object GeneratorFunction]",
        zre = "[object Map]",
        Zre = "[object Number]",
        GA = "[object Object]",
        Xre = "[object RegExp]",
        Qre = "[object Set]",
        Jre = "[object String]",
        ese = "[object Symbol]",
        tse = "[object WeakMap]",
        nse = "[object ArrayBuffer]",
        rse = "[object DataView]",
        sse = "[object Float32Array]",
        ise = "[object Float64Array]",
        ose = "[object Int8Array]",
        ase = "[object Int16Array]",
        cse = "[object Int32Array]",
        use = "[object Uint8Array]",
        lse = "[object Uint8ClampedArray]",
        hse = "[object Uint16Array]",
        fse = "[object Uint32Array]",
        Ht = {};
    Ht[VA] = Ht[Gre] = Ht[nse] = Ht[rse] = Ht[Wre] = Ht[Hre] = Ht[sse] = Ht[ise] = Ht[ose] = Ht[ase] = Ht[cse] = Ht[zre] = Ht[Zre] = Ht[GA] = Ht[Xre] = Ht[Qre] = Ht[Jre] = Ht[ese] = Ht[use] = Ht[lse] = Ht[hse] = Ht[fse] = !0;
    Ht[Kre] = Ht[jA] = Ht[tse] = !1;

    function Qf(t, e, n, r, s, i) {
        var a, c = e & qre,
            l = e & Vre,
            h = e & jre;
        if (n && (a = s ? n(t, r, s, i) : n(t)), a !== void 0) return a;
        if (!Lre(t)) return t;
        var d = Mre(t);
        if (d) {
            if (a = xre(t), !c) return Ore(t, a)
        } else {
            var p = Nre(t),
                g = p == jA || p == Yre;
            if (Dre(t)) return wre(t, c);
            if (p == GA || p == VA || g && !s) {
                if (a = l || g ? {} : Rre(t), !c) return l ? Cre(t, Tre(a, t)) : Are(t, Sre(a, t))
            } else {
                if (!Ht[p]) return s ? t : {};
                a = Pre(t, p, c)
            }
        }
        i || (i = new vre);
        var v = i.get(t);
        if (v) return v;
        i.set(t, a), Fre(t) ? t.forEach(function(m) {
            a.add(Qf(m, e, n, m, t, i))
        }) : $re(t) && t.forEach(function(m, w) {
            a.set(w, Qf(m, e, n, w, t, i))
        });
        var b = h ? l ? kre : Ire : l ? Bre : Ure,
            T = d ? void 0 : b(t);
        return bre(T || t, function(m, w) {
            T && (w = m, m = t[w]), Ere(a, w, Qf(m, e, n, w, t, i))
        }), a
    }
    var dse = Qf,
        pse = dse,
        mse = 1,
        gse = 4;

    function _se(t) {
        return pse(t, mse | gse)
    }
    var yse = _se;
    const WA = eu(yse),
        vse = yt({
            emits: {
                resolve: () => !0
            },
            data() {
                return {
                    screen: "options",
                    vibe: null,
                    message: "",
                    content: null,
                    isContent: !0,
                    values: {}
                }
            },
            mounted() {
                var e, n;
                const t = (n = (e = this.$debugRecorder) == null ? void 0 : e.room) == null ? void 0 : n.appTag;
                t && (this.values = WA(this.$ecastValues), this.content = wT.getPromptGuess(this.values, t) ?? null)
            },
            methods: {
                onFeedbackClick() {
                    this.screen = "feedback"
                },
                onDebugClick() {
                    this.screen = "debug"
                },
                onVibeClick(t) {
                    this.vibe = t
                },
                async onSubmitClick() {
                    this.$debugRecorder && (this.screen === "debug" && (await this.$debugRecorder.send(this.message), this.$emit("resolve")), this.screen === "feedback" && (await wT.send({
                        room: this.$debugRecorder.room,
                        name: this.$ecast.name,
                        role: this.$ecast.role,
                        content: this.isContent ? this.content : null,
                        message: this.message ?? "",
                        vibe: this.vibe ?? "none",
                        values: this.values
                    }), this.$emit("resolve")))
                }
            }
        }),
        HA = "main/pp10/nopus-opus/assets/ad9172fc.png",
        KA = "main/pp10/nopus-opus/assets/dc131b16.png",
        bse = "main/pp10/nopus-opus/assets/38715b18.png",
        Ese = "main/pp10/nopus-opus/assets/b0d7c822.png",
        Sse = "main/pp10/nopus-opus/assets/06150f24.png",
        us = t => (Di("data-v-2c53389f"), t = t(), $i(), t),
        Tse = {
            class: "jbg"
        },
        wse = {
            key: 0,
            class: "options"
        },
        Ose = us(() => W("img", {
            src: HA,
            alt: "Leave Feedback"
        }, null, -1)),
        Ase = us(() => W("span", null, [Nn("LEAVE"), W("br"), Nn("FEEDBACK")], -1)),
        Cse = [Ose, Ase],
        Ise = us(() => W("img", {
            src: KA,
            alt: "Send Debug"
        }, null, -1)),
        kse = us(() => W("span", null, [Nn("SEND A"), W("br"), Nn("DEBUG")], -1)),
        Nse = [Ise, kse],
        xse = {
            key: 1,
            class: "feedback"
        },
        Pse = us(() => W("img", {
            class: "image",
            src: HA,
            alt: "Feedback"
        }, null, -1)),
        Rse = us(() => W("h3", {
            class: "text"
        }, "Send Feedback", -1)),
        Mse = us(() => W("p", {
            class: "cta"
        }, "CHOOSE A VIBE", -1)),
        Dse = {
            class: "buttons"
        },
        $se = us(() => W("img", {
            src: bse,
            alt: "good"
        }, null, -1)),
        Lse = [$se],
        Fse = us(() => W("img", {
            src: Ese,
            alt: "good"
        }, null, -1)),
        Use = [Fse],
        Bse = us(() => W("img", {
            src: Sse,
            alt: "bad"
        }, null, -1)),
        qse = [Bse],
        Vse = {
            class: "actions"
        },
        jse = {
            key: 0,
            class: "content-guess"
        },
        Gse = {
            key: 2,
            class: "debug"
        },
        Wse = us(() => W("img", {
            class: "image",
            src: KA,
            alt: "Debug"
        }, null, -1)),
        Hse = us(() => W("h3", {
            class: "text"
        }, "What is Happening?", -1)),
        Kse = {
            class: "actions"
        };

    function Yse(t, e, n, r, s, i) {
        return Y(), X("div", Tse, [t.screen === "options" ? (Y(), X("div", wse, [W("button", {
            class: "feedback-button",
            onClick: e[0] || (e[0] = (...a) => t.onFeedbackClick && t.onFeedbackClick(...a))
        }, Cse), W("button", {
            onClick: e[1] || (e[1] = (...a) => t.onDebugClick && t.onDebugClick(...a))
        }, Nse)])) : t.screen === "feedback" ? (Y(), X("div", xse, [Pse, Rse, W("div", {
            class: mt(["vibes", {
                "has-selected": t.vibe
            }])
        }, [Mse, W("div", Dse, [W("button", {
            class: mt({
                selected: t.vibe === "good"
            }),
            onClick: e[2] || (e[2] = a => t.onVibeClick("good"))
        }, Lse, 2), W("button", {
            class: mt({
                selected: t.vibe === "meh"
            }),
            onClick: e[3] || (e[3] = a => t.onVibeClick("meh"))
        }, Use, 2), W("button", {
            class: mt({
                selected: t.vibe === "bad"
            }),
            onClick: e[4] || (e[4] = a => t.onVibeClick("bad"))
        }, qse, 2)])], 2), W("div", Vse, [t.content ? (Y(), X("div", jse, [Ge(W("input", {
            "onUpdate:modelValue": e[5] || (e[5] = a => t.isContent = a),
            type: "checkbox"
        }, null, 512), [
            [UD, t.isContent]
        ]), W("span", null, [Nn("Feedback is about: "), W("em", null, _t(t.content), 1)])])) : Ve("", !0), Ge(W("textarea", {
            "onUpdate:modelValue": e[6] || (e[6] = a => t.message = a),
            rows: "3",
            placeholder: "(optional) more details",
            "aria-label": "Details"
        }, null, 512), [
            [TS, t.message]
        ]), W("button", {
            onClick: e[7] || (e[7] = xi((...a) => t.onSubmitClick && t.onSubmitClick(...a), ["prevent"]))
        }, _t(t.$t("ACTION.SUBMIT")), 1)])])) : t.screen === "debug" ? (Y(), X("div", Gse, [Wse, Hse, W("div", Kse, [Ge(W("textarea", {
            "onUpdate:modelValue": e[8] || (e[8] = a => t.message = a),
            rows: "3",
            placeholder: "Enter details",
            "aria-label": "Details"
        }, null, 512), [
            [TS, t.message]
        ]), W("button", {
            onClick: e[9] || (e[9] = xi((...a) => t.onSubmitClick && t.onSubmitClick(...a), ["prevent"]))
        }, _t(t.$t("ACTION.OK")), 1)])])) : Ve("", !0)])
    }
    const zse = ct(vse, [
            ["render", Yse],
            ["__scopeId", "data-v-2c53389f"]
        ]),
        Zse = yt({
            methods: {
                onFeedbackClick() {
                    this.$showModal(zse)
                }
            }
        });

    function Xse(t, e, n, r, s, i) {
        return Y(), X("div", {
            class: "feedback-button",
            onClick: e[0] || (e[0] = (...a) => t.onFeedbackClick && t.onFeedbackClick(...a))
        }, "SEND FEEDBACK")
    }
    const Qse = ct(Zse, [
            ["render", Xse],
            ["__scopeId", "data-v-6f2f1788"]
        ]),
        Jse = {
            install: (t, e) => {
                if (!t.config.globalProperties.$debugRecorder && !t.config.globalProperties.$debugReplayer) {
                    if (e.replayer) {
                        t.config.globalProperties.$debugReplayer = e.replayer, t.component("Debug", jee);
                        return
                    }
                    if (t.config.globalProperties.$debugRecorder = new rK(e.client, e.room), !t.config.globalProperties.$showModal) {
                        console.warn("[debugPlugin] Sending debug and feedback messages is disabled because the modalPlugin is missing.");
                        return
                    }(!bs.isProduction() || bs.getQueryParam("feedback")) && t.component("Debug", Qse)
                }
            }
        };
    var eie = Ps,
        tie = function() {
            return eie.Date.now()
        },
        nie = tie,
        rie = /\s/;

    function sie(t) {
        for (var e = t.length; e-- && rie.test(t.charAt(e)););
        return e
    }
    var iie = sie,
        oie = iie,
        aie = /^\s+/;

    function cie(t) {
        return t && t.slice(0, oie(t) + 1).replace(aie, "")
    }
    var uie = cie,
        lie = ru,
        hie = Po,
        fie = "[object Symbol]";

    function die(t) {
        return typeof t == "symbol" || hie(t) && lie(t) == fie
    }
    var um = die,
        pie = uie,
        kw = Rs,
        mie = um,
        Nw = 0 / 0,
        gie = /^[-+]0x[0-9a-f]+$/i,
        _ie = /^0b[01]+$/i,
        yie = /^0o[0-7]+$/i,
        vie = parseInt;

    function bie(t) {
        if (typeof t == "number") return t;
        if (mie(t)) return Nw;
        if (kw(t)) {
            var e = typeof t.valueOf == "function" ? t.valueOf() : t;
            t = kw(e) ? e + "" : e
        }
        if (typeof t != "string") return t === 0 ? t : +t;
        t = pie(t);
        var n = _ie.test(t);
        return n || yie.test(t) ? vie(t.slice(2), n ? 2 : 8) : gie.test(t) ? Nw : +t
    }
    var Eie = bie,
        Sie = Rs,
        U_ = nie,
        xw = Eie,
        Tie = "Expected a function",
        wie = Math.max,
        Oie = Math.min;

    function Aie(t, e, n) {
        var r, s, i, a, c, l, h = 0,
            d = !1,
            p = !1,
            g = !0;
        if (typeof t != "function") throw new TypeError(Tie);
        e = xw(e) || 0, Sie(n) && (d = !!n.leading, p = "maxWait" in n, i = p ? wie(xw(n.maxWait) || 0, e) : i, g = "trailing" in n ? !!n.trailing : g);

        function v(L) {
            var B = r,
                q = s;
            return r = s = void 0, h = L, a = t.apply(q, B), a
        }

        function b(L) {
            return h = L, c = setTimeout(w, e), d ? v(L) : a
        }

        function T(L) {
            var B = L - l,
                q = L - h,
                se = e - B;
            return p ? Oie(se, i - q) : se
        }

        function m(L) {
            var B = L - l,
                q = L - h;
            return l === void 0 || B >= e || B < 0 || p && q >= i
        }

        function w() {
            var L = U_();
            if (m(L)) return P(L);
            c = setTimeout(w, T(L))
        }

        function P(L) {
            return c = void 0, g && r ? v(L) : (r = s = void 0, a)
        }

        function V() {
            c !== void 0 && clearTimeout(c), h = 0, r = l = s = c = void 0
        }

        function M() {
            return c === void 0 ? a : P(U_())
        }

        function I() {
            var L = U_(),
                B = m(L);
            if (r = arguments, s = this, l = L, B) {
                if (c === void 0) return b(l);
                if (p) return clearTimeout(c), c = setTimeout(w, e), v(l)
            }
            return c === void 0 && (c = setTimeout(w, e)), a
        }
        return I.cancel = V, I.flush = M, I
    }
    var Cie = Aie;
    const Iie = eu(Cie);
    var kie = Ro,
        Nie = um,
        xie = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        Pie = /^\w*$/;

    function Rie(t, e) {
        if (kie(t)) return !1;
        var n = typeof t;
        return n == "number" || n == "symbol" || n == "boolean" || t == null || Nie(t) ? !0 : Pie.test(t) || !xie.test(t) || e != null && t in Object(e)
    }
    var Mie = Rie,
        YA = v4,
        Die = "Expected a function";

    function a0(t, e) {
        if (typeof t != "function" || e != null && typeof e != "function") throw new TypeError(Die);
        var n = function() {
            var r = arguments,
                s = e ? e.apply(this, r) : r[0],
                i = n.cache;
            if (i.has(s)) return i.get(s);
            var a = t.apply(this, r);
            return n.cache = i.set(s, a) || i, a
        };
        return n.cache = new(a0.Cache || YA), n
    }
    a0.Cache = YA;
    var $ie = a0,
        Lie = $ie,
        Fie = 500;

    function Uie(t) {
        var e = Lie(t, function(r) {
                return n.size === Fie && n.clear(), r
            }),
            n = e.cache;
        return e
    }
    var Bie = Uie,
        qie = Bie,
        Vie = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        jie = /\\(\\)?/g,
        Gie = qie(function(t) {
            var e = [];
            return t.charCodeAt(0) === 46 && e.push(""), t.replace(Vie, function(n, r, s, i) {
                e.push(s ? i.replace(jie, "$1") : r || n)
            }), e
        }),
        Wie = Gie;

    function Hie(t, e) {
        for (var n = -1, r = t == null ? 0 : t.length, s = Array(r); ++n < r;) s[n] = e(t[n], n, t);
        return s
    }
    var zA = Hie,
        Pw = Kp,
        Kie = zA,
        Yie = Ro,
        zie = um,
        Zie = 1 / 0,
        Rw = Pw ? Pw.prototype : void 0,
        Mw = Rw ? Rw.toString : void 0;

    function ZA(t) {
        if (typeof t == "string") return t;
        if (Yie(t)) return Kie(t, ZA) + "";
        if (zie(t)) return Mw ? Mw.call(t) : "";
        var e = t + "";
        return e == "0" && 1 / t == -Zie ? "-0" : e
    }
    var Xie = ZA,
        Qie = Xie;

    function Jie(t) {
        return t == null ? "" : Qie(t)
    }
    var eoe = Jie,
        toe = Ro,
        noe = Mie,
        roe = Wie,
        soe = eoe;

    function ioe(t, e) {
        return toe(t) ? t : noe(t, e) ? [t] : roe(soe(t))
    }
    var XA = ioe,
        ooe = um,
        aoe = 1 / 0;

    function coe(t) {
        if (typeof t == "string" || ooe(t)) return t;
        var e = t + "";
        return e == "0" && 1 / t == -aoe ? "-0" : e
    }
    var QA = coe,
        uoe = yv,
        loe = XA,
        hoe = vv,
        Dw = Rs,
        foe = QA;

    function doe(t, e, n, r) {
        if (!Dw(t)) return t;
        e = loe(e, t);
        for (var s = -1, i = e.length, a = i - 1, c = t; c != null && ++s < i;) {
            var l = foe(e[s]),
                h = n;
            if (l === "__proto__" || l === "constructor" || l === "prototype") return t;
            if (s != a) {
                var d = c[l];
                h = r ? r(d, l, c) : void 0, h === void 0 && (h = Dw(d) ? d : hoe(e[s + 1]) ? [] : {})
            }
            uoe(c, l, h), c = c[l]
        }
        return t
    }
    var poe = doe,
        moe = poe;

    function goe(t, e, n) {
        return t == null ? t : moe(t, e, n)
    }
    var _oe = goe;
    const yoe = eu(_oe);
    class voe {
        constructor() {
            Ce(this, "wsClient");
            Ce(this, "keyMap");
            Ce(this, "providerMap");
            Ce(this, "mappedValues", Nc({}));
            Ce(this, "shouldParseBlobcast", !1);
            Ce(this, "pausedKeys", null);
            Ce(this, "keyMapKeys");
            Ce(this, "providerMapKeys");
            Ce(this, "hotValues");
            Ce(this, "newValues");
            Ce(this, "pause", (e = []) => {
                this.pausedKeys = e
            });
            Ce(this, "resume", () => {
                this.pausedKeys = null, this.sync()
            });
            Ce(this, "sync", Iie(() => {
                this.wsClient && (!this.keyMap && !this.providerMap || this.pausedKeys && !this.pausedKeys.length || (this.hotValues = {}, this.newValues = {}, this.normalize().mapKeysToValues().mapProvidersToValues().deleteDropped().hydrateRefs().syncExisting(), delete this.hotValues, delete this.newValues))
            }, 50))
        }
        setWSClient(e) {
            this.wsClient = e, this.setupWatcher()
        }
        setupWatcher() {
            this.wsClient.entities = Nc(this.wsClient.entities), pa(this.wsClient.entities, (e, n) => {
                this.sync()
            })
        }
        valueForEntity(e) {
            return e instanceof Sr.ArtifactEntity || e instanceof Sr.DoodleEntity || e instanceof Sr.TextMapEntity || e instanceof Sr.NumberEntity ? e : e instanceof Sr.ObjectEntity ? WA(e.val) : e instanceof Sr.TextEntity ? e.text : null
        }
        normalize() {
            var n;
            const e = Object.keys(this.wsClient.entities);
            for (let r = 0; r < e.length; r++) {
                let s = e[r];
                if ((n = this.pausedKeys) != null && n.includes(s)) continue;
                const i = this.valueForEntity(this.wsClient.entities[s]);
                if (i != null) {
                    if (this.shouldParseBlobcast) {
                        const a = s.split(":");
                        if (a[0] === "bc")
                            if (a[1] === "customer") {
                                if (a[2] !== `${this.wsClient.id}`) continue;
                                s = "player"
                            } else a[1] === "room" && (s = "room")
                    }
                    this.hotValues[s] = i
                }
            }
            return this
        }
        hydrateRefs() {
            const e = (n, r, s = !1) => {
                const i = n.$ref ?? n.ref;
                if (i) {
                    const a = this.hotValues[i];
                    if (a === void 0) throw new Error(`[ecastPlugin] entity "${r}" referenced entity "${i}" but it does not exist`);
                    yoe(this.newValues, r, a)
                } else s && Object.entries(n).forEach(([a, c]) => {
                    c !== null && typeof c == "object" && e(c, `${r}.${a}`, s)
                })
            };
            return Object.entries(this.newValues).forEach(([n, r]) => {
                r && Object.entries(r).forEach(([s, i]) => {
                    i !== null && typeof i == "object" && e(i, `${n}.${s}`, this.keyHasDeepRefs(n))
                })
            }), this
        }
        keyHasDeepRefs(e) {
            var n, r, s, i;
            return !!((r = (n = this.keyMap) == null ? void 0 : n[e]) != null && r.hasDeepRefs || (i = (s = this.providerMap) == null ? void 0 : s[e]) != null && i.hasDeepRefs)
        }
        mapKeysToValues() {
            if (!this.keyMap) return this;
            for (let e = 0; e < this.keyMapKeys.length; e++) this.newValues[this.keyMapKeys[e]] = this.hotValues[this.keyMap[this.keyMapKeys[e]].key];
            return this
        }
        mapProvidersToValues() {
            if (!this.providerMap) return this;
            for (let e = 0; e < this.providerMapKeys.length; e++) this.newValues[this.providerMapKeys[e]] = this.providerMap[this.providerMapKeys[e]].fn(this.hotValues, this.wsClient);
            return this
        }
        deleteDropped() {
            const e = Object.keys(this.mappedValues);
            for (let n = 0; n < e.length; n++) this.newValues[e[n]] || delete this.mappedValues[e[n]];
            return this
        }
        syncExisting() {
            const e = Object.keys(this.newValues);
            for (let n = 0; n < e.length; n++) this.mappedValues[e[n]] = this.newValues[e[n]];
            return this.mappedValues
        }
        addKeys(e) {
            this.keyMap || (this.keyMap = {}), Object.keys(e).forEach(n => {
                if (typeof e[n] == "function") {
                    const r = e[n];
                    this.keyMap[n] = {
                        key: r(this.wsClient),
                        hasDeepRefs: !1
                    };
                    return
                }
                if (typeof e[n] == "object") {
                    const r = e[n];
                    this.keyMap[n] = {
                        key: r.fn ? r.fn(this.wsClient) : r.key,
                        hasDeepRefs: r.hasDeepRefs ?? !1
                    };
                    return
                }
                this.keyMap[n] = {
                    key: e[n]
                }
            }), this.keyMapKeys = Object.keys(this.keyMap), this.sync()
        }
        purgeKeys(e) {
            this.keyMap && (Object.keys(e).forEach(n => {
                this.keyMap[n] && delete this.keyMap[n]
            }), this.keyMapKeys = Object.keys(this.keyMap), this.sync())
        }
        addProviders(e) {
            this.providerMap || (this.providerMap = {}), Object.keys(e).forEach(n => {
                if (typeof e[n] == "object") {
                    const r = e[n];
                    this.providerMap[n] = {
                        fn: r.fn,
                        hasDeepRefs: r.hasDeepRefs ?? !1
                    };
                    return
                }
                this.providerMap[n] = {
                    fn: e[n]
                }
            }), this.providerMapKeys = Object.keys(this.providerMap), this.sync()
        }
        purgeProviders(e) {
            this.providerMap && (Object.keys(e).forEach(n => {
                this.providerMap[n] && delete this.providerMap[n]
            }), this.providerMapKeys = Object.keys(this.providerMap), this.sync())
        }
    }
    const Xr = new voe,
        boe = {
            install: (t, e) => {
                t.config.globalProperties.$setupEcast = n => {
                    Xr.setWSClient(n.wsClient), n.wsClient.on("artifact", r => yd.add(r)), n.wsClient.on("connection", r => {
                        r.status === "connected" && Xr.setupWatcher()
                    }), Xr.sync(), t.config.globalProperties.$ecast = Xr.wsClient, t.config.globalProperties.$ecastValues = Xr.mappedValues, t.config.globalProperties.$ecastRoom = n.room, t.config.globalProperties.$ecastWelcome = n.welcome, t.config.globalProperties.$syncEcast = Xr.sync, t.config.globalProperties.$pauseEcastUpdates = Xr.pause, t.config.globalProperties.$resumeEcastUpdates = Xr.resume, t.mixin({
                        beforeCreate() {
                            this.$options.ecastKeys && Xr.addKeys(this.$options.ecastKeys), this.$options.ecastProviders && Xr.addProviders(this.$options.ecastProviders)
                        },
                        beforeDestroy() {
                            this.$options.ecastKeys && Xr.purgeKeys(this.$options.ecastKeys), this.$options.ecastProviders && Xr.purgeProviders(this.$options.ecastProviders)
                        }
                    })
                }, e != null && e.wsClient && t.config.globalProperties.$setupEcast(e)
            }
        },
        ih = {
            fatal: {
                error: Symbol("fatal.error")
            },
            modal: {
                active: Symbol("modal.active")
            },
            textDescriptions: {
                announcement: Symbol("textDescriptions.announcement")
            }
        },
        JA = Object.prototype.toString;

    function eC(t) {
        switch (JA.call(t)) {
            case "[object Error]":
            case "[object Exception]":
            case "[object DOMException]":
                return !0;
            default:
                return hu(t, Error)
        }
    }

    function lu(t, e) {
        return JA.call(t) === `[object ${e}]`
    }

    function tC(t) {
        return lu(t, "ErrorEvent")
    }

    function $w(t) {
        return lu(t, "DOMError")
    }

    function Eoe(t) {
        return lu(t, "DOMException")
    }

    function Sa(t) {
        return lu(t, "String")
    }

    function Soe(t) {
        return t === null || typeof t != "object" && typeof t != "function"
    }

    function lm(t) {
        return lu(t, "Object")
    }

    function c0(t) {
        return typeof Event < "u" && hu(t, Event)
    }

    function Toe(t) {
        return typeof Element < "u" && hu(t, Element)
    }

    function woe(t) {
        return lu(t, "RegExp")
    }

    function nC(t) {
        return !!(t && t.then && typeof t.then == "function")
    }

    function Ooe(t) {
        return lm(t) && "nativeEvent" in t && "preventDefault" in t && "stopPropagation" in t
    }

    function Aoe(t) {
        return typeof t == "number" && t !== t
    }

    function hu(t, e) {
        try {
            return t instanceof e
        } catch {
            return !1
        }
    }

    function kf(t) {
        return t && t.Math == Math ? t : void 0
    }
    const ws = typeof globalThis == "object" && kf(globalThis) || typeof window == "object" && kf(window) || typeof self == "object" && kf(self) || typeof global == "object" && kf(global) || function() {
        return this
    }() || {};

    function oh() {
        return ws
    }

    function u0(t, e, n) {
        const r = n || ws,
            s = r.__SENTRY__ = r.__SENTRY__ || {};
        return s[t] || (s[t] = e())
    }
    const Coe = oh(),
        Ioe = 80;

    function B1(t, e = {}) {
        try {
            let n = t;
            const r = 5,
                s = [];
            let i = 0,
                a = 0;
            const c = " > ",
                l = c.length;
            let h;
            const d = Array.isArray(e) ? e : e.keyAttrs,
                p = !Array.isArray(e) && e.maxStringLength || Ioe;
            for (; n && i++ < r && (h = koe(n, d), !(h === "html" || i > 1 && a + s.length * l + h.length >= p));) s.push(h), a += h.length, n = n.parentNode;
            return s.reverse().join(c)
        } catch {
            return "<unknown>"
        }
    }

    function koe(t, e) {
        const n = t,
            r = [];
        let s, i, a, c, l;
        if (!n || !n.tagName) return "";
        r.push(n.tagName.toLowerCase());
        const h = e && e.length ? e.filter(p => n.getAttribute(p)).map(p => [p, n.getAttribute(p)]) : null;
        if (h && h.length) h.forEach(p => {
            r.push(`[${p[0]}="${p[1]}"]`)
        });
        else if (n.id && r.push(`#${n.id}`), s = n.className, s && Sa(s))
            for (i = s.split(/\s+/), l = 0; l < i.length; l++) r.push(`.${i[l]}`);
        const d = ["aria-label", "type", "name", "title", "alt"];
        for (l = 0; l < d.length; l++) a = d[l], c = n.getAttribute(a), c && r.push(`[${a}="${c}"]`);
        return r.join("")
    }

    function Noe() {
        try {
            return Coe.document.location.href
        } catch {
            return ""
        }
    }
    class Wu extends Error {
        constructor(e, n = "warn") {
            super(e), this.message = e, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = n
        }
    }
    const xoe = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

    function Poe(t) {
        return t === "http" || t === "https"
    }

    function Roe(t, e = !1) {
        const {
            host: n,
            path: r,
            pass: s,
            port: i,
            projectId: a,
            protocol: c,
            publicKey: l
        } = t;
        return `${c}://${l}${e&&s?`:${s}`:""}@${n}${i?`:${i}`:""}/${r&&`${r}/`}${a}`
    }

    function Moe(t) {
        const e = xoe.exec(t);
        if (!e) throw new Wu(`Invalid Sentry Dsn: ${t}`);
        const [n, r, s = "", i, a = "", c] = e.slice(1);
        let l = "",
            h = c;
        const d = h.split("/");
        if (d.length > 1 && (l = d.slice(0, -1).join("/"), h = d.pop()), h) {
            const p = h.match(/^\d+/);
            p && (h = p[0])
        }
        return rC({
            host: i,
            pass: s,
            path: l,
            projectId: h,
            port: a,
            protocol: n,
            publicKey: r
        })
    }

    function rC(t) {
        return {
            protocol: t.protocol,
            publicKey: t.publicKey || "",
            pass: t.pass || "",
            host: t.host,
            port: t.port || "",
            path: t.path || "",
            projectId: t.projectId
        }
    }

    function Doe(t) {
        if (!(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__)) return;
        const {
            port: e,
            projectId: n,
            protocol: r
        } = t;
        if (["protocol", "publicKey", "host", "projectId"].forEach(i => {
                if (!t[i]) throw new Wu(`Invalid Sentry Dsn: ${i} missing`)
            }), !n.match(/^\d+$/)) throw new Wu(`Invalid Sentry Dsn: Invalid projectId ${n}`);
        if (!Poe(r)) throw new Wu(`Invalid Sentry Dsn: Invalid protocol ${r}`);
        if (e && isNaN(parseInt(e, 10))) throw new Wu(`Invalid Sentry Dsn: Invalid port ${e}`);
        return !0
    }

    function $oe(t) {
        const e = typeof t == "string" ? Moe(t) : rC(t);
        return Doe(e), e
    }
    const Loe = "Sentry Logger ",
        Id = ["debug", "info", "warn", "error", "log", "assert", "trace"];

    function sC(t) {
        if (!("console" in ws)) return t();
        const e = ws.console,
            n = {};
        Id.forEach(r => {
            const s = e[r] && e[r].__sentry_original__;
            r in e && s && (n[r] = e[r], e[r] = s)
        });
        try {
            return t()
        } finally {
            Object.keys(n).forEach(r => {
                e[r] = n[r]
            })
        }
    }

    function Lw() {
        let t = !1;
        const e = {
            enable: () => {
                t = !0
            },
            disable: () => {
                t = !1
            }
        };
        return typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? Id.forEach(n => {
            e[n] = (...r) => {
                t && sC(() => {
                    ws.console[n](`${Loe}[${n}]:`, ...r)
                })
            }
        }) : Id.forEach(n => {
            e[n] = () => {}
        }), e
    }
    let yn;
    typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? yn = u0("logger", Lw) : yn = Lw();

    function Fw(t, e = 0) {
        return typeof t != "string" || e === 0 || t.length <= e ? t : `${t.slice(0,e)}...`
    }

    function Uw(t, e) {
        if (!Array.isArray(t)) return "";
        const n = [];
        for (let r = 0; r < t.length; r++) {
            const s = t[r];
            try {
                n.push(String(s))
            } catch {
                n.push("[value cannot be serialized]")
            }
        }
        return n.join(e)
    }

    function Foe(t, e, n = !1) {
        return Sa(t) ? woe(e) ? e.test(t) : Sa(e) ? n ? t === e : t.includes(e) : !1 : !1
    }

    function hm(t, e = [], n = !1) {
        return e.some(r => Foe(t, r, n))
    }

    function jn(t, e, n) {
        if (!(e in t)) return;
        const r = t[e],
            s = n(r);
        if (typeof s == "function") try {
            oC(s, r)
        } catch {}
        t[e] = s
    }

    function iC(t, e, n) {
        Object.defineProperty(t, e, {
            value: n,
            writable: !0,
            configurable: !0
        })
    }

    function oC(t, e) {
        const n = e.prototype || {};
        t.prototype = e.prototype = n, iC(t, "__sentry_original__", e)
    }

    function l0(t) {
        return t.__sentry_original__
    }

    function aC(t) {
        if (eC(t)) return {
            message: t.message,
            name: t.name,
            stack: t.stack,
            ...qw(t)
        };
        if (c0(t)) {
            const e = {
                type: t.type,
                target: Bw(t.target),
                currentTarget: Bw(t.currentTarget),
                ...qw(t)
            };
            return typeof CustomEvent < "u" && hu(t, CustomEvent) && (e.detail = t.detail), e
        } else return t
    }

    function Bw(t) {
        try {
            return Toe(t) ? B1(t) : Object.prototype.toString.call(t)
        } catch {
            return "<unknown>"
        }
    }

    function qw(t) {
        if (typeof t == "object" && t !== null) {
            const e = {};
            for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            return e
        } else return {}
    }

    function Uoe(t, e = 40) {
        const n = Object.keys(aC(t));
        if (n.sort(), !n.length) return "[object has no keys]";
        if (n[0].length >= e) return Fw(n[0], e);
        for (let r = n.length; r > 0; r--) {
            const s = n.slice(0, r).join(", ");
            if (!(s.length > e)) return r === n.length ? s : Fw(s, e)
        }
        return ""
    }

    function Boe(t) {
        return q1(t, new Map)
    }

    function q1(t, e) {
        if (lm(t)) {
            const n = e.get(t);
            if (n !== void 0) return n;
            const r = {};
            e.set(t, r);
            for (const s of Object.keys(t)) typeof t[s] < "u" && (r[s] = q1(t[s], e));
            return r
        }
        if (Array.isArray(t)) {
            const n = e.get(t);
            if (n !== void 0) return n;
            const r = [];
            return e.set(t, r), t.forEach(s => {
                r.push(q1(s, e))
            }), r
        }
        return t
    }
    const B_ = "<anonymous>";

    function wo(t) {
        try {
            return !t || typeof t != "function" ? B_ : t.name || B_
        } catch {
            return B_
        }
    }
    const V1 = oh();

    function qoe() {
        if (!("fetch" in V1)) return !1;
        try {
            return new Headers, new Request("http://www.example.com"), new Response, !0
        } catch {
            return !1
        }
    }

    function Vw(t) {
        return t && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
    }

    function Voe() {
        if (!qoe()) return !1;
        if (Vw(V1.fetch)) return !0;
        let t = !1;
        const e = V1.document;
        if (e && typeof e.createElement == "function") try {
            const n = e.createElement("iframe");
            n.hidden = !0, e.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (t = Vw(n.contentWindow.fetch)), e.head.removeChild(n)
        } catch (n) {
            (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n)
        }
        return t
    }
    const Nf = oh();

    function joe() {
        const t = Nf.chrome,
            e = t && t.app && t.app.runtime,
            n = "history" in Nf && !!Nf.history.pushState && !!Nf.history.replaceState;
        return !e && n
    }
    const sn = oh(),
        Hu = "__sentry_xhr_v2__",
        nl = {},
        jw = {};

    function Goe(t) {
        if (!jw[t]) switch (jw[t] = !0, t) {
            case "console":
                Woe();
                break;
            case "dom":
                Joe();
                break;
            case "xhr":
                Yoe();
                break;
            case "fetch":
                Hoe();
                break;
            case "history":
                zoe();
                break;
            case "error":
                eae();
                break;
            case "unhandledrejection":
                tae();
                break;
            default:
                (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.warn("unknown instrumentation type:", t);
                return
        }
    }

    function ca(t, e) {
        nl[t] = nl[t] || [], nl[t].push(e), Goe(t)
    }

    function Os(t, e) {
        if (!(!t || !nl[t]))
            for (const n of nl[t] || []) try {
                n(e)
            } catch (r) {
                (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${wo(n)}
Error:`, r)
            }
    }

    function Woe() {
        "console" in sn && Id.forEach(function(t) {
            t in sn.console && jn(sn.console, t, function(e) {
                return function(...n) {
                    Os("console", {
                        args: n,
                        level: t
                    }), e && e.apply(sn.console, n)
                }
            })
        })
    }

    function Hoe() {
        Voe() && jn(sn, "fetch", function(t) {
            return function(...e) {
                const {
                    method: n,
                    url: r
                } = Koe(e), s = {
                    args: e,
                    fetchData: {
                        method: n,
                        url: r
                    },
                    startTimestamp: Date.now()
                };
                return Os("fetch", {
                    ...s
                }), t.apply(sn, e).then(i => (Os("fetch", {
                    ...s,
                    endTimestamp: Date.now(),
                    response: i
                }), i), i => {
                    throw Os("fetch", {
                        ...s,
                        endTimestamp: Date.now(),
                        error: i
                    }), i
                })
            }
        })
    }

    function j1(t, e) {
        return !!t && typeof t == "object" && !!t[e]
    }

    function Gw(t) {
        return typeof t == "string" ? t : t ? j1(t, "url") ? t.url : t.toString ? t.toString() : "" : ""
    }

    function Koe(t) {
        if (t.length === 0) return {
            method: "GET",
            url: ""
        };
        if (t.length === 2) {
            const [n, r] = t;
            return {
                url: Gw(n),
                method: j1(r, "method") ? String(r.method).toUpperCase() : "GET"
            }
        }
        const e = t[0];
        return {
            url: Gw(e),
            method: j1(e, "method") ? String(e.method).toUpperCase() : "GET"
        }
    }

    function Yoe() {
        if (!("XMLHttpRequest" in sn)) return;
        const t = XMLHttpRequest.prototype;
        jn(t, "open", function(e) {
            return function(...n) {
                const r = n[1],
                    s = this[Hu] = {
                        method: Sa(n[0]) ? n[0].toUpperCase() : n[0],
                        url: n[1],
                        request_headers: {}
                    };
                Sa(r) && s.method === "POST" && r.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
                const i = () => {
                    const a = this[Hu];
                    if (a && this.readyState === 4) {
                        try {
                            a.status_code = this.status
                        } catch {}
                        Os("xhr", {
                            args: n,
                            endTimestamp: Date.now(),
                            startTimestamp: Date.now(),
                            xhr: this
                        })
                    }
                };
                return "onreadystatechange" in this && typeof this.onreadystatechange == "function" ? jn(this, "onreadystatechange", function(a) {
                    return function(...c) {
                        return i(), a.apply(this, c)
                    }
                }) : this.addEventListener("readystatechange", i), jn(this, "setRequestHeader", function(a) {
                    return function(...c) {
                        const [l, h] = c, d = this[Hu];
                        return d && (d.request_headers[l.toLowerCase()] = h), a.apply(this, c)
                    }
                }), e.apply(this, n)
            }
        }), jn(t, "send", function(e) {
            return function(...n) {
                const r = this[Hu];
                return r && n[0] !== void 0 && (r.body = n[0]), Os("xhr", {
                    args: n,
                    startTimestamp: Date.now(),
                    xhr: this
                }), e.apply(this, n)
            }
        })
    }
    let xf;

    function zoe() {
        if (!joe()) return;
        const t = sn.onpopstate;
        sn.onpopstate = function(...n) {
            const r = sn.location.href,
                s = xf;
            if (xf = r, Os("history", {
                    from: s,
                    to: r
                }), t) try {
                return t.apply(this, n)
            } catch {}
        };

        function e(n) {
            return function(...r) {
                const s = r.length > 2 ? r[2] : void 0;
                if (s) {
                    const i = xf,
                        a = String(s);
                    xf = a, Os("history", {
                        from: i,
                        to: a
                    })
                }
                return n.apply(this, r)
            }
        }
        jn(sn.history, "pushState", e), jn(sn.history, "replaceState", e)
    }
    const Zoe = 1e3;
    let Pf, Rf;

    function Xoe(t, e) {
        if (!t || t.type !== e.type) return !0;
        try {
            if (t.target !== e.target) return !0
        } catch {}
        return !1
    }

    function Qoe(t) {
        if (t.type !== "keypress") return !1;
        try {
            const e = t.target;
            if (!e || !e.tagName) return !0;
            if (e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable) return !1
        } catch {}
        return !0
    }

    function Ww(t, e = !1) {
        return n => {
            if (!n || Rf === n || Qoe(n)) return;
            const r = n.type === "keypress" ? "input" : n.type;
            Pf === void 0 ? (t({
                event: n,
                name: r,
                global: e
            }), Rf = n) : Xoe(Rf, n) && (t({
                event: n,
                name: r,
                global: e
            }), Rf = n), clearTimeout(Pf), Pf = sn.setTimeout(() => {
                Pf = void 0
            }, Zoe)
        }
    }

    function Joe() {
        if (!("document" in sn)) return;
        const t = Os.bind(null, "dom"),
            e = Ww(t, !0);
        sn.document.addEventListener("click", e, !1), sn.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach(n => {
            const r = sn[n] && sn[n].prototype;
            !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (jn(r, "addEventListener", function(s) {
                return function(i, a, c) {
                    if (i === "click" || i == "keypress") try {
                        const l = this,
                            h = l.__sentry_instrumentation_handlers__ = l.__sentry_instrumentation_handlers__ || {},
                            d = h[i] = h[i] || {
                                refCount: 0
                            };
                        if (!d.handler) {
                            const p = Ww(t);
                            d.handler = p, s.call(this, i, p, c)
                        }
                        d.refCount++
                    } catch {}
                    return s.call(this, i, a, c)
                }
            }), jn(r, "removeEventListener", function(s) {
                return function(i, a, c) {
                    if (i === "click" || i == "keypress") try {
                        const l = this,
                            h = l.__sentry_instrumentation_handlers__ || {},
                            d = h[i];
                        d && (d.refCount--, d.refCount <= 0 && (s.call(this, i, d.handler, c), d.handler = void 0, delete h[i]), Object.keys(h).length === 0 && delete l.__sentry_instrumentation_handlers__)
                    } catch {}
                    return s.call(this, i, a, c)
                }
            }))
        })
    }
    let Mf = null;

    function eae() {
        Mf = sn.onerror, sn.onerror = function(t, e, n, r, s) {
            return Os("error", {
                column: r,
                error: s,
                line: n,
                msg: t,
                url: e
            }), Mf && !Mf.__SENTRY_LOADER__ ? Mf.apply(this, arguments) : !1
        }, sn.onerror.__SENTRY_INSTRUMENTED__ = !0
    }
    let Df = null;

    function tae() {
        Df = sn.onunhandledrejection, sn.onunhandledrejection = function(t) {
            return Os("unhandledrejection", t), Df && !Df.__SENTRY_LOADER__ ? Df.apply(this, arguments) : !0
        }, sn.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
    }

    function nae() {
        const t = typeof WeakSet == "function",
            e = t ? new WeakSet : [];

        function n(s) {
            if (t) return e.has(s) ? !0 : (e.add(s), !1);
            for (let i = 0; i < e.length; i++)
                if (e[i] === s) return !0;
            return e.push(s), !1
        }

        function r(s) {
            if (t) e.delete(s);
            else
                for (let i = 0; i < e.length; i++)
                    if (e[i] === s) {
                        e.splice(i, 1);
                        break
                    }
        }
        return [n, r]
    }

    function rl() {
        const t = ws,
            e = t.crypto || t.msCrypto;
        if (e && e.randomUUID) return e.randomUUID().replace(/-/g, "");
        const n = e && e.getRandomValues ? () => e.getRandomValues(new Uint8Array(1))[0] : () => Math.random() * 16;
        return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, r => (r ^ (n() & 15) >> r / 4).toString(16))
    }

    function cC(t) {
        return t.exception && t.exception.values ? t.exception.values[0] : void 0
    }

    function co(t) {
        const {
            message: e,
            event_id: n
        } = t;
        if (e) return e;
        const r = cC(t);
        return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>"
    }

    function G1(t, e, n) {
        const r = t.exception = t.exception || {},
            s = r.values = r.values || [],
            i = s[0] = s[0] || {};
        i.value || (i.value = e || ""), i.type || (i.type = n || "Error")
    }

    function kd(t, e) {
        const n = cC(t);
        if (!n) return;
        const r = {
                type: "generic",
                handled: !0
            },
            s = n.mechanism;
        if (n.mechanism = {
                ...r,
                ...s,
                ...e
            }, e && "data" in e) {
            const i = {
                ...s && s.data,
                ...e.data
            };
            n.mechanism.data = i
        }
    }

    function rae(t) {
        return Array.isArray(t) ? t : [t]
    }

    function sae() {
        return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__
    }

    function iae() {
        return !sae() && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]"
    }

    function oae(t, e) {
        return t.require(e)
    }

    function aae(t, e = 100, n = 1 / 0) {
        try {
            return W1("", t, e, n)
        } catch (r) {
            return {
                ERROR: `**non-serializable** (${r})`
            }
        }
    }

    function uC(t, e = 3, n = 100 * 1024) {
        const r = aae(t, e);
        return hae(r) > n ? uC(t, e - 1, n) : r
    }

    function W1(t, e, n = 1 / 0, r = 1 / 0, s = nae()) {
        const [i, a] = s;
        if (e == null || ["number", "boolean", "string"].includes(typeof e) && !Aoe(e)) return e;
        const c = cae(t, e);
        if (!c.startsWith("[object ")) return c;
        if (e.__sentry_skip_normalization__) return e;
        const l = typeof e.__sentry_override_normalization_depth__ == "number" ? e.__sentry_override_normalization_depth__ : n;
        if (l === 0) return c.replace("object ", "");
        if (i(e)) return "[Circular ~]";
        const h = e;
        if (h && typeof h.toJSON == "function") try {
            const v = h.toJSON();
            return W1("", v, l - 1, r, s)
        } catch {}
        const d = Array.isArray(e) ? [] : {};
        let p = 0;
        const g = aC(e);
        for (const v in g) {
            if (!Object.prototype.hasOwnProperty.call(g, v)) continue;
            if (p >= r) {
                d[v] = "[MaxProperties ~]";
                break
            }
            const b = g[v];
            d[v] = W1(v, b, l - 1, r, s), p++
        }
        return a(e), d
    }

    function cae(t, e) {
        try {
            if (t === "domain" && e && typeof e == "object" && e._events) return "[Domain]";
            if (t === "domainEmitter") return "[DomainEmitter]";
            if (typeof global < "u" && e === global) return "[Global]";
            if (typeof window < "u" && e === window) return "[Window]";
            if (typeof document < "u" && e === document) return "[Document]";
            if (Ooe(e)) return "[SyntheticEvent]";
            if (typeof e == "number" && e !== e) return "[NaN]";
            if (typeof e == "function") return `[Function: ${wo(e)}]`;
            if (typeof e == "symbol") return `[${String(e)}]`;
            if (typeof e == "bigint") return `[BigInt: ${String(e)}]`;
            const n = uae(e);
            return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`
        } catch (n) {
            return `**non-serializable** (${n})`
        }
    }

    function uae(t) {
        const e = Object.getPrototypeOf(t);
        return e ? e.constructor.name : "null prototype"
    }

    function lae(t) {
        return ~-encodeURI(t).split(/%..|./).length
    }

    function hae(t) {
        return lae(JSON.stringify(t))
    }
    var Si;
    (function(t) {
        t[t.PENDING = 0] = "PENDING";
        const n = 1;
        t[t.RESOLVED = n] = "RESOLVED";
        const r = 2;
        t[t.REJECTED = r] = "REJECTED"
    })(Si || (Si = {}));
    class Ws {
        __init() {
            this._state = Si.PENDING
        }
        __init2() {
            this._handlers = []
        }
        constructor(e) {
            Ws.prototype.__init.call(this), Ws.prototype.__init2.call(this), Ws.prototype.__init3.call(this), Ws.prototype.__init4.call(this), Ws.prototype.__init5.call(this), Ws.prototype.__init6.call(this);
            try {
                e(this._resolve, this._reject)
            } catch (n) {
                this._reject(n)
            }
        }
        then(e, n) {
            return new Ws((r, s) => {
                this._handlers.push([!1, i => {
                    if (!e) r(i);
                    else try {
                        r(e(i))
                    } catch (a) {
                        s(a)
                    }
                }, i => {
                    if (!n) s(i);
                    else try {
                        r(n(i))
                    } catch (a) {
                        s(a)
                    }
                }]), this._executeHandlers()
            })
        } catch (e) {
            return this.then(n => n, e)
        } finally(e) {
            return new Ws((n, r) => {
                let s, i;
                return this.then(a => {
                    i = !1, s = a, e && e()
                }, a => {
                    i = !0, s = a, e && e()
                }).then(() => {
                    if (i) {
                        r(s);
                        return
                    }
                    n(s)
                })
            })
        }
        __init3() {
            this._resolve = e => {
                this._setResult(Si.RESOLVED, e)
            }
        }
        __init4() {
            this._reject = e => {
                this._setResult(Si.REJECTED, e)
            }
        }
        __init5() {
            this._setResult = (e, n) => {
                if (this._state === Si.PENDING) {
                    if (nC(n)) {
                        n.then(this._resolve, this._reject);
                        return
                    }
                    this._state = e, this._value = n, this._executeHandlers()
                }
            }
        }
        __init6() {
            this._executeHandlers = () => {
                if (this._state === Si.PENDING) return;
                const e = this._handlers.slice();
                this._handlers = [], e.forEach(n => {
                    n[0] || (this._state === Si.RESOLVED && n[1](this._value), this._state === Si.REJECTED && n[2](this._value), n[0] = !0)
                })
            }
        }
    }

    function q_(t) {
        if (!t) return {};
        const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
        if (!e) return {};
        const n = e[6] || "",
            r = e[8] || "";
        return {
            host: e[4],
            path: e[5],
            protocol: e[2],
            search: n,
            hash: r,
            relative: e[5] + n + r
        }
    }
    const fae = ["fatal", "error", "warning", "log", "info", "debug"];

    function dae(t) {
        return t === "warn" ? "warning" : fae.includes(t) ? t : "log"
    }
    const lC = oh(),
        H1 = {
            nowSeconds: () => Date.now() / 1e3
        };

    function pae() {
        const {
            performance: t
        } = lC;
        if (!t || !t.now) return;
        const e = Date.now() - t.now();
        return {
            now: () => t.now(),
            timeOrigin: e
        }
    }

    function mae() {
        try {
            return oae(Mk, "perf_hooks").performance
        } catch {
            return
        }
    }
    const V_ = iae() ? mae() : pae(),
        Hw = V_ === void 0 ? H1 : {
            nowSeconds: () => (V_.timeOrigin + V_.now()) / 1e3
        },
        hC = H1.nowSeconds.bind(H1),
        fC = Hw.nowSeconds.bind(Hw);
    (() => {
        const {
            performance: t
        } = lC;
        if (!t || !t.now) return;
        const e = 3600 * 1e3,
            n = t.now(),
            r = Date.now(),
            s = t.timeOrigin ? Math.abs(t.timeOrigin + n - r) : e,
            i = s < e,
            a = t.timing && t.timing.navigationStart,
            l = typeof a == "number" ? Math.abs(a + n - r) : e,
            h = l < e;
        return i || h ? s <= l ? t.timeOrigin : a : r
    })();
    const gae = "production";

    function _ae(t) {
        const e = fC(),
            n = {
                sid: rl(),
                init: !0,
                timestamp: e,
                started: e,
                duration: 0,
                status: "ok",
                errors: 0,
                ignoreDuration: !1,
                toJSON: () => vae(n)
            };
        return t && fm(n, t), n
    }

    function fm(t, e = {}) {
        if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address), !t.did && !e.did && (t.did = e.user.id || e.user.email || e.user.username)), t.timestamp = e.timestamp || fC(), e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration), e.sid && (t.sid = e.sid.length === 32 ? e.sid : rl()), e.init !== void 0 && (t.init = e.init), !t.did && e.did && (t.did = `${e.did}`), typeof e.started == "number" && (t.started = e.started), t.ignoreDuration) t.duration = void 0;
        else if (typeof e.duration == "number") t.duration = e.duration;
        else {
            const n = t.timestamp - t.started;
            t.duration = n >= 0 ? n : 0
        }
        e.release && (t.release = e.release), e.environment && (t.environment = e.environment), !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress), !t.userAgent && e.userAgent && (t.userAgent = e.userAgent), typeof e.errors == "number" && (t.errors = e.errors), e.status && (t.status = e.status)
    }

    function yae(t, e) {
        let n = {};
        e ? n = {
            status: e
        } : t.status === "ok" && (n = {
            status: "exited"
        }), fm(t, n)
    }

    function vae(t) {
        return Boe({
            sid: `${t.sid}`,
            init: t.init,
            started: new Date(t.started * 1e3).toISOString(),
            timestamp: new Date(t.timestamp * 1e3).toISOString(),
            status: t.status,
            errors: t.errors,
            did: typeof t.did == "number" || typeof t.did == "string" ? `${t.did}` : void 0,
            duration: t.duration,
            attrs: {
                release: t.release,
                environment: t.environment,
                ip_address: t.ipAddress,
                user_agent: t.userAgent
            }
        })
    }
    const bae = 100;
    class Tc {
        constructor() {
            this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}
        }
        static clone(e) {
            const n = new Tc;
            return e && (n._breadcrumbs = [...e._breadcrumbs], n._tags = {
                ...e._tags
            }, n._extra = {
                ...e._extra
            }, n._contexts = {
                ...e._contexts
            }, n._user = e._user, n._level = e._level, n._span = e._span, n._session = e._session, n._transactionName = e._transactionName, n._fingerprint = e._fingerprint, n._eventProcessors = [...e._eventProcessors], n._requestSession = e._requestSession, n._attachments = [...e._attachments], n._sdkProcessingMetadata = {
                ...e._sdkProcessingMetadata
            }), n
        }
        addScopeListener(e) {
            this._scopeListeners.push(e)
        }
        addEventProcessor(e) {
            return this._eventProcessors.push(e), this
        }
        setUser(e) {
            return this._user = e || {}, this._session && fm(this._session, {
                user: e
            }), this._notifyScopeListeners(), this
        }
        getUser() {
            return this._user
        }
        getRequestSession() {
            return this._requestSession
        }
        setRequestSession(e) {
            return this._requestSession = e, this
        }
        setTags(e) {
            return this._tags = {
                ...this._tags,
                ...e
            }, this._notifyScopeListeners(), this
        }
        setTag(e, n) {
            return this._tags = {
                ...this._tags,
                [e]: n
            }, this._notifyScopeListeners(), this
        }
        setExtras(e) {
            return this._extra = {
                ...this._extra,
                ...e
            }, this._notifyScopeListeners(), this
        }
        setExtra(e, n) {
            return this._extra = {
                ...this._extra,
                [e]: n
            }, this._notifyScopeListeners(), this
        }
        setFingerprint(e) {
            return this._fingerprint = e, this._notifyScopeListeners(), this
        }
        setLevel(e) {
            return this._level = e, this._notifyScopeListeners(), this
        }
        setTransactionName(e) {
            return this._transactionName = e, this._notifyScopeListeners(), this
        }
        setContext(e, n) {
            return n === null ? delete this._contexts[e] : this._contexts[e] = n, this._notifyScopeListeners(), this
        }
        setSpan(e) {
            return this._span = e, this._notifyScopeListeners(), this
        }
        getSpan() {
            return this._span
        }
        getTransaction() {
            const e = this.getSpan();
            return e && e.transaction
        }
        setSession(e) {
            return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this
        }
        getSession() {
            return this._session
        }
        update(e) {
            if (!e) return this;
            if (typeof e == "function") {
                const n = e(this);
                return n instanceof Tc ? n : this
            }
            return e instanceof Tc ? (this._tags = {
                ...this._tags,
                ...e._tags
            }, this._extra = {
                ...this._extra,
                ...e._extra
            }, this._contexts = {
                ...this._contexts,
                ...e._contexts
            }, e._user && Object.keys(e._user).length && (this._user = e._user), e._level && (this._level = e._level), e._fingerprint && (this._fingerprint = e._fingerprint), e._requestSession && (this._requestSession = e._requestSession)) : lm(e) && (e = e, this._tags = {
                ...this._tags,
                ...e.tags
            }, this._extra = {
                ...this._extra,
                ...e.extra
            }, this._contexts = {
                ...this._contexts,
                ...e.contexts
            }, e.user && (this._user = e.user), e.level && (this._level = e.level), e.fingerprint && (this._fingerprint = e.fingerprint), e.requestSession && (this._requestSession = e.requestSession)), this
        }
        clear() {
            return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this
        }
        addBreadcrumb(e, n) {
            const r = typeof n == "number" ? n : bae;
            if (r <= 0) return this;
            const s = {
                timestamp: hC(),
                ...e
            };
            return this._breadcrumbs = [...this._breadcrumbs, s].slice(-r), this._notifyScopeListeners(), this
        }
        getLastBreadcrumb() {
            return this._breadcrumbs[this._breadcrumbs.length - 1]
        }
        clearBreadcrumbs() {
            return this._breadcrumbs = [], this._notifyScopeListeners(), this
        }
        addAttachment(e) {
            return this._attachments.push(e), this
        }
        getAttachments() {
            return this._attachments
        }
        clearAttachments() {
            return this._attachments = [], this
        }
        applyToEvent(e, n = {}) {
            if (this._extra && Object.keys(this._extra).length && (e.extra = {
                    ...this._extra,
                    ...e.extra
                }), this._tags && Object.keys(this._tags).length && (e.tags = {
                    ...this._tags,
                    ...e.tags
                }), this._user && Object.keys(this._user).length && (e.user = {
                    ...this._user,
                    ...e.user
                }), this._contexts && Object.keys(this._contexts).length && (e.contexts = {
                    ...this._contexts,
                    ...e.contexts
                }), this._level && (e.level = this._level), this._transactionName && (e.transaction = this._transactionName), this._span) {
                e.contexts = {
                    trace: this._span.getTraceContext(),
                    ...e.contexts
                };
                const r = this._span.transaction;
                if (r) {
                    e.sdkProcessingMetadata = {
                        dynamicSamplingContext: r.getDynamicSamplingContext(),
                        ...e.sdkProcessingMetadata
                    };
                    const s = r.name;
                    s && (e.tags = {
                        transaction: s,
                        ...e.tags
                    })
                }
            }
            return this._applyFingerprint(e), e.breadcrumbs = [...e.breadcrumbs || [], ...this._breadcrumbs], e.breadcrumbs = e.breadcrumbs.length > 0 ? e.breadcrumbs : void 0, e.sdkProcessingMetadata = {
                ...e.sdkProcessingMetadata,
                ...this._sdkProcessingMetadata
            }, this._notifyEventProcessors([...dC(), ...this._eventProcessors], e, n)
        }
        setSDKProcessingMetadata(e) {
            return this._sdkProcessingMetadata = {
                ...this._sdkProcessingMetadata,
                ...e
            }, this
        }
        _notifyEventProcessors(e, n, r, s = 0) {
            return new Ws((i, a) => {
                const c = e[s];
                if (n === null || typeof c != "function") i(n);
                else {
                    const l = c({
                        ...n
                    }, r);
                    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && c.id && l === null && yn.log(`Event processor "${c.id}" dropped event`), nC(l) ? l.then(h => this._notifyEventProcessors(e, h, r, s + 1).then(i)).then(null, a) : this._notifyEventProcessors(e, l, r, s + 1).then(i).then(null, a)
                }
            })
        }
        _notifyScopeListeners() {
            this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(e => {
                e(this)
            }), this._notifyingListeners = !1)
        }
        _applyFingerprint(e) {
            e.fingerprint = e.fingerprint ? rae(e.fingerprint) : [], this._fingerprint && (e.fingerprint = e.fingerprint.concat(this._fingerprint)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint
        }
    }

    function dC() {
        return u0("globalEventProcessors", () => [])
    }

    function pC(t) {
        dC().push(t)
    }
    const mC = 4,
        Eae = 100;
    class gC {
        constructor(e, n = new Tc, r = mC) {
            this._version = r, this._stack = [{
                scope: n
            }], e && this.bindClient(e)
        }
        isOlderThan(e) {
            return this._version < e
        }
        bindClient(e) {
            const n = this.getStackTop();
            n.client = e, e && e.setupIntegrations && e.setupIntegrations()
        }
        pushScope() {
            const e = Tc.clone(this.getScope());
            return this.getStack().push({
                client: this.getClient(),
                scope: e
            }), e
        }
        popScope() {
            return this.getStack().length <= 1 ? !1 : !!this.getStack().pop()
        }
        withScope(e) {
            const n = this.pushScope();
            try {
                e(n)
            } finally {
                this.popScope()
            }
        }
        getClient() {
            return this.getStackTop().client
        }
        getScope() {
            return this.getStackTop().scope
        }
        getStack() {
            return this._stack
        }
        getStackTop() {
            return this._stack[this._stack.length - 1]
        }
        captureException(e, n) {
            const r = this._lastEventId = n && n.event_id ? n.event_id : rl(),
                s = new Error("Sentry syntheticException");
            return this._withClient((i, a) => {
                i.captureException(e, {
                    originalException: e,
                    syntheticException: s,
                    ...n,
                    event_id: r
                }, a)
            }), r
        }
        captureMessage(e, n, r) {
            const s = this._lastEventId = r && r.event_id ? r.event_id : rl(),
                i = new Error(e);
            return this._withClient((a, c) => {
                a.captureMessage(e, n, {
                    originalException: e,
                    syntheticException: i,
                    ...r,
                    event_id: s
                }, c)
            }), s
        }
        captureEvent(e, n) {
            const r = n && n.event_id ? n.event_id : rl();
            return e.type || (this._lastEventId = r), this._withClient((s, i) => {
                s.captureEvent(e, {
                    ...n,
                    event_id: r
                }, i)
            }), r
        }
        lastEventId() {
            return this._lastEventId
        }
        addBreadcrumb(e, n) {
            const {
                scope: r,
                client: s
            } = this.getStackTop();
            if (!s) return;
            const {
                beforeBreadcrumb: i = null,
                maxBreadcrumbs: a = Eae
            } = s.getOptions && s.getOptions() || {};
            if (a <= 0) return;
            const l = {
                    timestamp: hC(),
                    ...e
                },
                h = i ? sC(() => i(l, n)) : l;
            h !== null && (s.emit && s.emit("beforeAddBreadcrumb", h, n), r.addBreadcrumb(h, a))
        }
        setUser(e) {
            this.getScope().setUser(e)
        }
        setTags(e) {
            this.getScope().setTags(e)
        }
        setExtras(e) {
            this.getScope().setExtras(e)
        }
        setTag(e, n) {
            this.getScope().setTag(e, n)
        }
        setExtra(e, n) {
            this.getScope().setExtra(e, n)
        }
        setContext(e, n) {
            this.getScope().setContext(e, n)
        }
        configureScope(e) {
            const {
                scope: n,
                client: r
            } = this.getStackTop();
            r && e(n)
        }
        run(e) {
            const n = Kw(this);
            try {
                e(this)
            } finally {
                Kw(n)
            }
        }
        getIntegration(e) {
            const n = this.getClient();
            if (!n) return null;
            try {
                return n.getIntegration(e)
            } catch {
                return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.warn(`Cannot retrieve integration ${e.id} from the current Hub`), null
            }
        }
        startTransaction(e, n) {
            const r = this._callExtensionMethod("startTransaction", e, n);
            return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && !r && console.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`), r
        }
        traceHeaders() {
            return this._callExtensionMethod("traceHeaders")
        }
        captureSession(e = !1) {
            if (e) return this.endSession();
            this._sendSessionUpdate()
        }
        endSession() {
            const n = this.getStackTop().scope,
                r = n.getSession();
            r && yae(r), this._sendSessionUpdate(), n.setSession()
        }
        startSession(e) {
            const {
                scope: n,
                client: r
            } = this.getStackTop(), {
                release: s,
                environment: i = gae
            } = r && r.getOptions() || {}, {
                userAgent: a
            } = ws.navigator || {}, c = _ae({
                release: s,
                environment: i,
                user: n.getUser(),
                ...a && {
                    userAgent: a
                },
                ...e
            }), l = n.getSession && n.getSession();
            return l && l.status === "ok" && fm(l, {
                status: "exited"
            }), this.endSession(), n.setSession(c), c
        }
        shouldSendDefaultPii() {
            const e = this.getClient(),
                n = e && e.getOptions();
            return !!(n && n.sendDefaultPii)
        }
        _sendSessionUpdate() {
            const {
                scope: e,
                client: n
            } = this.getStackTop(), r = e.getSession();
            r && n && n.captureSession && n.captureSession(r)
        }
        _withClient(e) {
            const {
                scope: n,
                client: r
            } = this.getStackTop();
            r && e(r, n)
        }
        _callExtensionMethod(e, ...n) {
            const s = dm().__SENTRY__;
            if (s && s.extensions && typeof s.extensions[e] == "function") return s.extensions[e].apply(this, n);
            (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.warn(`Extension method ${e} couldn't be found, doing nothing.`)
        }
    }

    function dm() {
        return ws.__SENTRY__ = ws.__SENTRY__ || {
            extensions: {},
            hub: void 0
        }, ws
    }

    function Kw(t) {
        const e = dm(),
            n = K1(e);
        return _C(e, t), n
    }

    function pr() {
        const t = dm();
        if (t.__SENTRY__ && t.__SENTRY__.acs) {
            const e = t.__SENTRY__.acs.getCurrentHub();
            if (e) return e
        }
        return Sae(t)
    }

    function Sae(t = dm()) {
        return (!Tae(t) || K1(t).isOlderThan(mC)) && _C(t, new gC), K1(t)
    }

    function Tae(t) {
        return !!(t && t.__SENTRY__ && t.__SENTRY__.hub)
    }

    function K1(t) {
        return u0("hub", () => new gC, t)
    }

    function _C(t, e) {
        if (!t) return !1;
        const n = t.__SENTRY__ = t.__SENTRY__ || {};
        return n.hub = e, !0
    }

    function wae(t, e) {
        return pr().captureException(t, {
            captureContext: e
        })
    }

    function Oae(t) {
        pr().withScope(t)
    }

    function Aae(t) {
        const e = t.protocol ? `${t.protocol}:` : "",
            n = t.port ? `:${t.port}` : "";
        return `${e}//${t.host}${n}${t.path?`/${t.path}`:""}/api/`
    }

    function Cae(t, e) {
        const n = $oe(t),
            r = `${Aae(n)}embed/error-page/`;
        let s = `dsn=${Roe(n)}`;
        for (const i in e)
            if (i !== "dsn")
                if (i === "user") {
                    const a = e.user;
                    if (!a) continue;
                    a.name && (s += `&name=${encodeURIComponent(a.name)}`), a.email && (s += `&email=${encodeURIComponent(a.email)}`)
                } else s += `&${encodeURIComponent(i)}=${encodeURIComponent(e[i])}`;
        return `${r}?${s}`
    }
    let Yw;
    class vl {
        constructor() {
            vl.prototype.__init.call(this)
        }
        static __initStatic() {
            this.id = "FunctionToString"
        }
        __init() {
            this.name = vl.id
        }
        setupOnce() {
            Yw = Function.prototype.toString;
            try {
                Function.prototype.toString = function(...e) {
                    const n = l0(this) || this;
                    return Yw.apply(n, e)
                }
            } catch {}
        }
    }
    vl.__initStatic();
    const Iae = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
    class wc {
        static __initStatic() {
            this.id = "InboundFilters"
        }
        __init() {
            this.name = wc.id
        }
        constructor(e = {}) {
            this._options = e, wc.prototype.__init.call(this)
        }
        setupOnce(e, n) {
            const r = s => {
                const i = n();
                if (i) {
                    const a = i.getIntegration(wc);
                    if (a) {
                        const c = i.getClient(),
                            l = c ? c.getOptions() : {},
                            h = kae(a._options, l);
                        return Nae(s, h) ? null : s
                    }
                }
                return s
            };
            r.id = this.name, e(r)
        }
    }
    wc.__initStatic();

    function kae(t = {}, e = {}) {
        return {
            allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
            denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
            ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...Iae],
            ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []],
            ignoreInternal: t.ignoreInternal !== void 0 ? t.ignoreInternal : !0
        }
    }

    function Nae(t, e) {
        return e.ignoreInternal && $ae(t) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.warn(`Event dropped due to being internal Sentry Error.
Event: ${co(t)}`), !0) : xae(t, e.ignoreErrors) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${co(t)}`), !0) : Pae(t, e.ignoreTransactions) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${co(t)}`), !0) : Rae(t, e.denyUrls) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${co(t)}.
Url: ${Nd(t)}`), !0) : Mae(t, e.allowUrls) ? !1 : ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${co(t)}.
Url: ${Nd(t)}`), !0)
    }

    function xae(t, e) {
        return t.type || !e || !e.length ? !1 : Dae(t).some(n => hm(n, e))
    }

    function Pae(t, e) {
        if (t.type !== "transaction" || !e || !e.length) return !1;
        const n = t.transaction;
        return n ? hm(n, e) : !1
    }

    function Rae(t, e) {
        if (!e || !e.length) return !1;
        const n = Nd(t);
        return n ? hm(n, e) : !1
    }

    function Mae(t, e) {
        if (!e || !e.length) return !0;
        const n = Nd(t);
        return n ? hm(n, e) : !0
    }

    function Dae(t) {
        if (t.message) return [t.message];
        if (t.exception) {
            const {
                values: e
            } = t.exception;
            try {
                const {
                    type: n = "",
                    value: r = ""
                } = e && e[e.length - 1] || {};
                return [`${r}`, `${n}: ${r}`]
            } catch {
                return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.error(`Cannot extract message for event ${co(t)}`), []
            }
        }
        return []
    }

    function $ae(t) {
        try {
            return t.exception.values[0].type === "SentryError"
        } catch {}
        return !1
    }

    function Lae(t = []) {
        for (let e = t.length - 1; e >= 0; e--) {
            const n = t[e];
            if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]") return n.filename || null
        }
        return null
    }

    function Nd(t) {
        try {
            let e;
            try {
                e = t.exception.values[0].stacktrace.frames
            } catch {}
            return e ? Lae(e) : null
        } catch {
            return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.error(`Cannot extract url for event ${co(t)}`), null
        }
    }
    const Bn = ws;
    let Y1 = 0;

    function yC() {
        return Y1 > 0
    }

    function Fae() {
        Y1++, setTimeout(() => {
            Y1--
        })
    }

    function Fc(t, e = {}, n) {
        if (typeof t != "function") return t;
        try {
            const s = t.__sentry_wrapped__;
            if (s) return s;
            if (l0(t)) return t
        } catch {
            return t
        }
        const r = function() {
            const s = Array.prototype.slice.call(arguments);
            try {
                n && typeof n == "function" && n.apply(this, arguments);
                const i = s.map(a => Fc(a, e));
                return t.apply(this, i)
            } catch (i) {
                throw Fae(), Oae(a => {
                    a.addEventProcessor(c => (e.mechanism && (G1(c, void 0, void 0), kd(c, e.mechanism)), c.extra = {
                        ...c.extra,
                        arguments: s
                    }, c)), wae(i)
                }), i
            }
        };
        try {
            for (const s in t) Object.prototype.hasOwnProperty.call(t, s) && (r[s] = t[s])
        } catch {}
        oC(r, t), iC(t, "__sentry_wrapped__", r);
        try {
            Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
                get() {
                    return t.name
                }
            })
        } catch {}
        return r
    }

    function vC(t, e) {
        const n = h0(t, e),
            r = {
                type: e && e.name,
                value: Vae(e)
            };
        return n.length && (r.stacktrace = {
            frames: n
        }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r
    }

    function Uae(t, e, n, r) {
        const i = pr().getClient(),
            a = i && i.getOptions().normalizeDepth,
            c = {
                exception: {
                    values: [{
                        type: c0(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
                        value: `Non-Error ${r?"promise rejection":"exception"} captured with keys: ${Uoe(e)}`
                    }]
                },
                extra: {
                    __serialized__: uC(e, a)
                }
            };
        if (n) {
            const l = h0(t, n);
            l.length && (c.exception.values[0].stacktrace = {
                frames: l
            })
        }
        return c
    }

    function j_(t, e) {
        return {
            exception: {
                values: [vC(t, e)]
            }
        }
    }

    function h0(t, e) {
        const n = e.stacktrace || e.stack || "",
            r = qae(e);
        try {
            return t(n, r)
        } catch {}
        return []
    }
    const Bae = /Minified React error #\d+;/i;

    function qae(t) {
        if (t) {
            if (typeof t.framesToPop == "number") return t.framesToPop;
            if (Bae.test(t.message)) return 1
        }
        return 0
    }

    function Vae(t) {
        const e = t && t.message;
        return e ? e.error && typeof e.error.message == "string" ? e.error.message : e : "No error message"
    }

    function bC(t, e, n, r, s) {
        let i;
        if (tC(e) && e.error) return j_(t, e.error);
        if ($w(e) || Eoe(e)) {
            const a = e;
            if ("stack" in e) i = j_(t, e);
            else {
                const c = a.name || ($w(a) ? "DOMError" : "DOMException"),
                    l = a.message ? `${c}: ${a.message}` : c;
                i = zw(t, l, n, r), G1(i, l)
            }
            return "code" in a && (i.tags = {
                ...i.tags,
                "DOMException.code": `${a.code}`
            }), i
        }
        return eC(e) ? j_(t, e) : lm(e) || c0(e) ? (i = Uae(t, e, n, s), kd(i, {
            synthetic: !0
        }), i) : (i = zw(t, e, n, r), G1(i, `${e}`, void 0), kd(i, {
            synthetic: !0
        }), i)
    }

    function zw(t, e, n, r) {
        const s = {
            message: e
        };
        if (r && n) {
            const i = h0(t, n);
            i.length && (s.exception = {
                values: [{
                    value: e,
                    stacktrace: {
                        frames: i
                    }
                }]
            })
        }
        return s
    }
    const $f = 1024,
        jae = "Breadcrumbs";
    class bl {
        static __initStatic() {
            this.id = jae
        }
        __init() {
            this.name = bl.id
        }
        constructor(e) {
            bl.prototype.__init.call(this), this.options = {
                console: !0,
                dom: !0,
                fetch: !0,
                history: !0,
                sentry: !0,
                xhr: !0,
                ...e
            }
        }
        setupOnce() {
            this.options.console && ca("console", Wae), this.options.dom && ca("dom", Gae(this.options.dom)), this.options.xhr && ca("xhr", Hae), this.options.fetch && ca("fetch", Kae), this.options.history && ca("history", Yae)
        }
        addSentryBreadcrumb(e) {
            this.options.sentry && pr().addBreadcrumb({
                category: `sentry.${e.type==="transaction"?"transaction":"event"}`,
                event_id: e.event_id,
                level: e.level,
                message: co(e)
            }, {
                event: e
            })
        }
    }
    bl.__initStatic();

    function Gae(t) {
        function e(n) {
            let r, s = typeof t == "object" ? t.serializeAttribute : void 0,
                i = typeof t == "object" && typeof t.maxStringLength == "number" ? t.maxStringLength : void 0;
            i && i > $f && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.warn(`\`dom.maxStringLength\` cannot exceed ${$f}, but a value of ${i} was configured. Sentry will use ${$f} instead.`), i = $f), typeof s == "string" && (s = [s]);
            try {
                const a = n.event;
                r = zae(a) ? B1(a.target, {
                    keyAttrs: s,
                    maxStringLength: i
                }) : B1(a, {
                    keyAttrs: s,
                    maxStringLength: i
                })
            } catch {
                r = "<unknown>"
            }
            r.length !== 0 && pr().addBreadcrumb({
                category: `ui.${n.name}`,
                message: r
            }, {
                event: n.event,
                name: n.name,
                global: n.global
            })
        }
        return e
    }

    function Wae(t) {
        for (let n = 0; n < t.args.length; n++)
            if (t.args[n] === "ref=Ref<") {
                t.args[n + 1] = "viewRef";
                break
            } const e = {
            category: "console",
            data: {
                arguments: t.args,
                logger: "console"
            },
            level: dae(t.level),
            message: Uw(t.args, " ")
        };
        if (t.level === "assert")
            if (t.args[0] === !1) e.message = `Assertion failed: ${Uw(t.args.slice(1)," ")||"console.assert"}`, e.data.arguments = t.args.slice(1);
            else return;
        pr().addBreadcrumb(e, {
            input: t.args,
            level: t.level
        })
    }

    function Hae(t) {
        const {
            startTimestamp: e,
            endTimestamp: n
        } = t, r = t.xhr[Hu];
        if (!e || !n || !r) return;
        const {
            method: s,
            url: i,
            status_code: a,
            body: c
        } = r, l = {
            method: s,
            url: i,
            status_code: a
        }, h = {
            xhr: t.xhr,
            input: c,
            startTimestamp: e,
            endTimestamp: n
        };
        pr().addBreadcrumb({
            category: "xhr",
            data: l,
            type: "http"
        }, h)
    }

    function Kae(t) {
        const {
            startTimestamp: e,
            endTimestamp: n
        } = t;
        if (n && !(t.fetchData.url.match(/sentry_key/) && t.fetchData.method === "POST"))
            if (t.error) {
                const r = t.fetchData,
                    s = {
                        data: t.error,
                        input: t.args,
                        startTimestamp: e,
                        endTimestamp: n
                    };
                pr().addBreadcrumb({
                    category: "fetch",
                    data: r,
                    level: "error",
                    type: "http"
                }, s)
            } else {
                const r = {
                        ...t.fetchData,
                        status_code: t.response && t.response.status
                    },
                    s = {
                        input: t.args,
                        response: t.response,
                        startTimestamp: e,
                        endTimestamp: n
                    };
                pr().addBreadcrumb({
                    category: "fetch",
                    data: r,
                    type: "http"
                }, s)
            }
    }

    function Yae(t) {
        let e = t.from,
            n = t.to;
        const r = q_(Bn.location.href);
        let s = q_(e);
        const i = q_(n);
        s.path || (s = r), r.protocol === i.protocol && r.host === i.host && (n = i.relative), r.protocol === s.protocol && r.host === s.host && (e = s.relative), pr().addBreadcrumb({
            category: "navigation",
            data: {
                from: e,
                to: n
            }
        })
    }

    function zae(t) {
        return t && !!t.target
    }
    class _o {
        static __initStatic() {
            this.id = "GlobalHandlers"
        }
        __init() {
            this.name = _o.id
        }
        __init2() {
            this._installFunc = {
                onerror: Zae,
                onunhandledrejection: Xae
            }
        }
        constructor(e) {
            _o.prototype.__init.call(this), _o.prototype.__init2.call(this), this._options = {
                onerror: !0,
                onunhandledrejection: !0,
                ...e
            }
        }
        setupOnce() {
            Error.stackTraceLimit = 50;
            const e = this._options;
            for (const n in e) {
                const r = this._installFunc[n];
                r && e[n] && (ece(n), r(), this._installFunc[n] = void 0)
            }
        }
    }
    _o.__initStatic();

    function Zae() {
        ca("error", t => {
            const [e, n, r] = TC();
            if (!e.getIntegration(_o)) return;
            const {
                msg: s,
                url: i,
                line: a,
                column: c,
                error: l
            } = t;
            if (yC() || l && l.__sentry_own_request__) return;
            const h = l === void 0 && Sa(s) ? Jae(s, i, a, c) : EC(bC(n, l || s, void 0, r, !1), i, a, c);
            h.level = "error", SC(e, l, h, "onerror")
        })
    }

    function Xae() {
        ca("unhandledrejection", t => {
            const [e, n, r] = TC();
            if (!e.getIntegration(_o)) return;
            let s = t;
            try {
                "reason" in t ? s = t.reason : "detail" in t && "reason" in t.detail && (s = t.detail.reason)
            } catch {}
            if (yC() || s && s.__sentry_own_request__) return !0;
            const i = Soe(s) ? Qae(s) : bC(n, s, void 0, r, !0);
            i.level = "error", SC(e, s, i, "onunhandledrejection")
        })
    }

    function Qae(t) {
        return {
            exception: {
                values: [{
                    type: "UnhandledRejection",
                    value: `Non-Error promise rejection captured with value: ${String(t)}`
                }]
            }
        }
    }

    function Jae(t, e, n, r) {
        const s = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
        let i = tC(t) ? t.message : t,
            a = "Error";
        const c = i.match(s);
        return c && (a = c[1], i = c[2]), EC({
            exception: {
                values: [{
                    type: a,
                    value: i
                }]
            }
        }, e, n, r)
    }

    function EC(t, e, n, r) {
        const s = t.exception = t.exception || {},
            i = s.values = s.values || [],
            a = i[0] = i[0] || {},
            c = a.stacktrace = a.stacktrace || {},
            l = c.frames = c.frames || [],
            h = isNaN(parseInt(r, 10)) ? void 0 : r,
            d = isNaN(parseInt(n, 10)) ? void 0 : n,
            p = Sa(e) && e.length > 0 ? e : Noe();
        return l.length === 0 && l.push({
            colno: h,
            filename: p,
            function: "?",
            in_app: !0,
            lineno: d
        }), t
    }

    function ece(t) {
        (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.log(`Global Handler attached: ${t}`)
    }

    function SC(t, e, n, r) {
        kd(n, {
            handled: !1,
            type: r
        }), t.captureEvent(n, {
            originalException: e
        })
    }

    function TC() {
        const t = pr(),
            e = t.getClient(),
            n = e && e.getOptions() || {
                stackParser: () => [],
                attachStacktrace: !1
            };
        return [t, n.stackParser, n.attachStacktrace]
    }
    const tce = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
    class El {
        static __initStatic() {
            this.id = "TryCatch"
        }
        __init() {
            this.name = El.id
        }
        constructor(e) {
            El.prototype.__init.call(this), this._options = {
                XMLHttpRequest: !0,
                eventTarget: !0,
                requestAnimationFrame: !0,
                setInterval: !0,
                setTimeout: !0,
                ...e
            }
        }
        setupOnce() {
            this._options.setTimeout && jn(Bn, "setTimeout", Zw), this._options.setInterval && jn(Bn, "setInterval", Zw), this._options.requestAnimationFrame && jn(Bn, "requestAnimationFrame", nce), this._options.XMLHttpRequest && "XMLHttpRequest" in Bn && jn(XMLHttpRequest.prototype, "send", rce);
            const e = this._options.eventTarget;
            e && (Array.isArray(e) ? e : tce).forEach(sce)
        }
    }
    El.__initStatic();

    function Zw(t) {
        return function(...e) {
            const n = e[0];
            return e[0] = Fc(n, {
                mechanism: {
                    data: {
                        function: wo(t)
                    },
                    handled: !0,
                    type: "instrument"
                }
            }), t.apply(this, e)
        }
    }

    function nce(t) {
        return function(e) {
            return t.apply(this, [Fc(e, {
                mechanism: {
                    data: {
                        function: "requestAnimationFrame",
                        handler: wo(t)
                    },
                    handled: !0,
                    type: "instrument"
                }
            })])
        }
    }

    function rce(t) {
        return function(...e) {
            const n = this;
            return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(s => {
                s in n && typeof n[s] == "function" && jn(n, s, function(i) {
                    const a = {
                            mechanism: {
                                data: {
                                    function: s,
                                    handler: wo(i)
                                },
                                handled: !0,
                                type: "instrument"
                            }
                        },
                        c = l0(i);
                    return c && (a.mechanism.data.handler = wo(c)), Fc(i, a)
                })
            }), t.apply(this, e)
        }
    }

    function sce(t) {
        const e = Bn,
            n = e[t] && e[t].prototype;
        !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (jn(n, "addEventListener", function(r) {
            return function(s, i, a) {
                try {
                    typeof i.handleEvent == "function" && (i.handleEvent = Fc(i.handleEvent, {
                        mechanism: {
                            data: {
                                function: "handleEvent",
                                handler: wo(i),
                                target: t
                            },
                            handled: !0,
                            type: "instrument"
                        }
                    }))
                } catch {}
                return r.apply(this, [s, Fc(i, {
                    mechanism: {
                        data: {
                            function: "addEventListener",
                            handler: wo(i),
                            target: t
                        },
                        handled: !0,
                        type: "instrument"
                    }
                }), a])
            }
        }), jn(n, "removeEventListener", function(r) {
            return function(s, i, a) {
                const c = i;
                try {
                    const l = c && c.__sentry_wrapped__;
                    l && r.call(this, s, l, a)
                } catch {}
                return r.call(this, s, c, a)
            }
        }))
    }
    const ice = "cause",
        oce = 5;
    class Oc {
        static __initStatic() {
            this.id = "LinkedErrors"
        }
        __init() {
            this.name = Oc.id
        }
        constructor(e = {}) {
            Oc.prototype.__init.call(this), this._key = e.key || ice, this._limit = e.limit || oce
        }
        setupOnce() {
            const e = pr().getClient();
            e && pC((n, r) => {
                const s = pr().getIntegration(Oc);
                return s ? ace(e.getOptions().stackParser, s._key, s._limit, n, r) : n
            })
        }
    }
    Oc.__initStatic();

    function ace(t, e, n, r, s) {
        if (!r.exception || !r.exception.values || !s || !hu(s.originalException, Error)) return r;
        const i = wC(t, n, s.originalException, e);
        return r.exception.values = [...i, ...r.exception.values], r
    }

    function wC(t, e, n, r, s = []) {
        if (!hu(n[r], Error) || s.length + 1 >= e) return s;
        const i = vC(t, n[r]);
        return wC(t, e, n[r], r, [i, ...s])
    }
    class Ac {
        constructor() {
            Ac.prototype.__init.call(this)
        }
        static __initStatic() {
            this.id = "HttpContext"
        }
        __init() {
            this.name = Ac.id
        }
        setupOnce() {
            pC(e => {
                if (pr().getIntegration(Ac)) {
                    if (!Bn.navigator && !Bn.location && !Bn.document) return e;
                    const n = e.request && e.request.url || Bn.location && Bn.location.href,
                        {
                            referrer: r
                        } = Bn.document || {},
                        {
                            userAgent: s
                        } = Bn.navigator || {},
                        i = {
                            ...e.request && e.request.headers,
                            ...r && {
                                Referer: r
                            },
                            ...s && {
                                "User-Agent": s
                            }
                        },
                        a = {
                            ...e.request,
                            ...n && {
                                url: n
                            },
                            headers: i
                        };
                    return {
                        ...e,
                        request: a
                    }
                }
                return e
            })
        }
    }
    Ac.__initStatic();
    class Cc {
        constructor() {
            Cc.prototype.__init.call(this)
        }
        static __initStatic() {
            this.id = "Dedupe"
        }
        __init() {
            this.name = Cc.id
        }
        setupOnce(e, n) {
            const r = s => {
                if (s.type) return s;
                const i = n().getIntegration(Cc);
                if (i) {
                    try {
                        if (cce(s, i._previousEvent)) return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.warn("Event dropped due to being a duplicate of previously captured event."), null
                    } catch {
                        return i._previousEvent = s
                    }
                    return i._previousEvent = s
                }
                return s
            };
            r.id = this.name, e(r)
        }
    }
    Cc.__initStatic();

    function cce(t, e) {
        return e ? !!(uce(t, e) || lce(t, e)) : !1
    }

    function uce(t, e) {
        const n = t.message,
            r = e.message;
        return !(!n && !r || n && !r || !n && r || n !== r || !AC(t, e) || !OC(t, e))
    }

    function lce(t, e) {
        const n = Xw(e),
            r = Xw(t);
        return !(!n || !r || n.type !== r.type || n.value !== r.value || !AC(t, e) || !OC(t, e))
    }

    function OC(t, e) {
        let n = Qw(t),
            r = Qw(e);
        if (!n && !r) return !0;
        if (n && !r || !n && r || (n = n, r = r, r.length !== n.length)) return !1;
        for (let s = 0; s < r.length; s++) {
            const i = r[s],
                a = n[s];
            if (i.filename !== a.filename || i.lineno !== a.lineno || i.colno !== a.colno || i.function !== a.function) return !1
        }
        return !0
    }

    function AC(t, e) {
        let n = t.fingerprint,
            r = e.fingerprint;
        if (!n && !r) return !0;
        if (n && !r || !n && r) return !1;
        n = n, r = r;
        try {
            return n.join("") === r.join("")
        } catch {
            return !1
        }
    }

    function Xw(t) {
        return t.exception && t.exception.values && t.exception.values[0]
    }

    function Qw(t) {
        const e = t.exception;
        if (e) try {
            return e.values[0].stacktrace.frames
        } catch {
            return
        }
    }
    new wc, new vl, new El, new bl, new _o, new Oc, new Cc, new Ac;

    function hce(t = {}, e = pr()) {
        if (!Bn.document) {
            (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.error("Global document not defined in showReportDialog call");
            return
        }
        const {
            client: n,
            scope: r
        } = e.getStackTop(), s = t.dsn || n && n.getDsn();
        if (!s) {
            (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.error("DSN not configured for showReportDialog call");
            return
        }
        r && (t.user = {
            ...r.getUser(),
            ...t.user
        }), t.eventId || (t.eventId = e.lastEventId());
        const i = Bn.document.createElement("script");
        i.async = !0, i.src = Cae(s, t), t.onLoad && (i.onload = t.onLoad);
        const a = Bn.document.head || Bn.document.body;
        a ? a.appendChild(i) : (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && yn.error("Not injecting report dialog. No injection point found in HTML")
    }
    const fce = yt({
            setup() {
                return {
                    fatalError: mo(ih.fatal.error)
                }
            },
            computed: {
                message() {
                    var r, s, i, a;
                    const t = ((s = (r = this.fatalError) == null ? void 0 : r.event) == null ? void 0 : s.event_id) ?? "Unknown";
                    let e = "";
                    const n = (a = (i = this.fatalError) == null ? void 0 : i.hint) == null ? void 0 : a.originalException;
                    return n ? typeof n == "string" ? e = n : e = n.message : e = "An unknown error occured", `Version:
${window.tv.manifest.loader.version}

Event ID:
${t}

${e}`
                }
            },
            methods: {
                onFeedbackClick() {
                    var t, e;
                    hce({
                        id: ((e = (t = this.fatalError) == null ? void 0 : t.event) == null ? void 0 : e.event_id) ?? "Unknown"
                    })
                }
            }
        }),
        ah = t => (Di("data-v-a7272d53"), t = t(), $i(), t),
        dce = {
            class: "jbg fatal"
        },
        pce = {
            class: "constrain"
        },
        mce = ah(() => W("a", {
            class: "logo",
            href: "/",
            "aria-label": "Jackbox Games Logo"
        }, null, -1)),
        gce = {
            class: "content"
        },
        _ce = ah(() => W("h1", null, "You have encountered an error", -1)),
        yce = ah(() => W("p", null, "Something went wrong! But don't worry, you can try a few things to get going.", -1)),
        vce = ah(() => W("ul", null, [W("li", null, "Refresh the page"), W("li", null, "Turn off adblockers or other browser extensions."), W("li", null, "Check your connection to the Internet."), W("li", null, "Make sure you're using an up-to-date browser."), W("li", null, "If that doesn't work, let us know.")], -1)),
        bce = ah(() => W("hr", null, null, -1)),
        Ece = {
            class: "error"
        };

    function Sce(t, e, n, r, s, i) {
        return Y(), X("div", dce, [W("div", pce, [mce, W("div", gce, [_ce, yce, vce, W("button", {
            onClick: e[0] || (e[0] = (...a) => t.onFeedbackClick && t.onFeedbackClick(...a))
        }, "Tell us what happened"), bce, W("pre", Ece, _t(t.message), 1)])])])
    }
    const Tce = ct(fce, [
            ["render", Sce],
            ["__scopeId", "data-v-a7272d53"]
        ]),
        Lf = Nc({
            hasCrashed: !1
        }),
        wce = {
            install: t => {
                if (t.config.globalProperties.$handleEcastError) return;
                t.provide(ih.fatal.error, Lr(() => Lf));
                const e = (n, r) => {
                    var s, i;
                    if (n instanceof el.EcastEntityNotFound || n instanceof el.EcastFilterError || n instanceof el.EcastRateLimitExceeded || n instanceof Error && ((s = n.message) != null && s.includes("Socket not ready to send")) || n instanceof Error && ((i = n.message) != null && i.includes("No connection available"))) return console.warn(n);
                    throw r ? console.error(r, n) : console.error(n), n
                };
                window.tv.onError = async (n, r) => {
                    if (n.level === "error" && (Lf.hasCrashed = !0, Lf.event = n, Lf.hint = r), t.config.globalProperties.$debugRecorder) return await t.config.globalProperties.$debugRecorder.sendToEcast()
                }, t.component("Fatal", Tce), t.config.globalProperties.$handleEcastError = e
            }
        };
    var Oce = XA,
        Ace = QA;

    function Cce(t, e) {
        e = Oce(e, t);
        for (var n = 0, r = e.length; t != null && n < r;) t = t[Ace(e[n++])];
        return n && n == r ? t : void 0
    }
    var Ice = Cce,
        kce = Ice;

    function Nce(t, e, n) {
        var r = t == null ? void 0 : kce(t, e);
        return r === void 0 ? n : r
    }
    var xce = Nce;
    const Pce = eu(xce);
    var Rce = Math.floor,
        Mce = Math.random;

    function Dce(t, e) {
        return t + Rce(Mce() * (e - t + 1))
    }
    var $ce = Dce,
        Lce = $ce;

    function Fce(t) {
        var e = t.length;
        return e ? t[Lce(0, e - 1)] : void 0
    }
    var CC = Fce,
        Uce = zA;

    function Bce(t, e) {
        return Uce(e, function(n) {
            return t[n]
        })
    }
    var qce = Bce,
        Vce = qce,
        jce = cm;

    function Gce(t) {
        return t == null ? [] : Vce(t, jce(t))
    }
    var Wce = Gce,
        Hce = CC,
        Kce = Wce;

    function Yce(t) {
        return Hce(Kce(t))
    }
    var zce = Yce,
        Zce = CC,
        Xce = zce,
        Qce = Ro;

    function Jce(t) {
        var e = Qce(t) ? Zce : Xce;
        return e(t)
    }
    var eue = Jce;
    const tue = eu(eue);

    function Jw(t, e) {
        const n = t.global.locale,
            r = t.global.messages[n],
            s = Pce(r, e);
        return Array.isArray(s) || console.warn(`[i18nPlugin] Translation with key ${e} is not an array`), tue(s)
    }
    const nue = {
            install: (t, e) => {
                t.directive("ts", (n, r) => {
                    const s = Jw(e.i18n, r.value);
                    n.textContent = s || ""
                }), t.config.globalProperties.$ts = function(r) {
                    return Jw(e.i18n, r) || ""
                }, t.config.globalProperties.$t = e.i18n.global.t, t.config.globalProperties.$tc = e.i18n.global.tc, t.config.globalProperties.$te = e.i18n.global.te, t.config.globalProperties.$tm = e.i18n.global.tm
            }
        },
        rue = yt({
            props: {
                image: String,
                text: String,
                subtext: String,
                classes: {
                    type: [Array, String],
                    default: () => "jbg"
                },
                dismissText: String
            }
        }),
        sue = "main/pp10/nopus-opus/assets/928ef0da.png",
        iue = "main/pp10/nopus-opus/assets/0bb76a2d.png",
        oue = "main/pp10/nopus-opus/assets/ed4469b3.png",
        aue = {
            key: 0,
            class: "image",
            src: sue,
            alt: "Kicked"
        },
        cue = {
            key: 1,
            class: "image",
            src: iue,
            alt: "Thank You"
        },
        uue = {
            key: 2,
            class: "image",
            src: oue,
            alt: "Error"
        },
        lue = {
            class: "text"
        },
        hue = {
            key: 3,
            class: "subtext"
        },
        fue = {
            class: "actions"
        };

    function due(t, e, n, r, s, i) {
        const a = fn("bb");
        return Y(), X("div", {
            class: mt(["error-model", t.classes])
        }, [t.image === "tear" ? (Y(), X("img", aue)) : t.image === "moon" ? (Y(), X("img", cue)) : (Y(), X("img", uue)), Ge(W("h3", lue, null, 512), [
            [a, t.text]
        ]), t.subtext ? Ge((Y(), X("h3", hue, null, 512)), [
            [a, t.subtext]
        ]) : Ve("", !0), W("div", fue, [Ge(W("button", {
            onClick: e[0] || (e[0] = xi(c => t.$emit("resolve"), ["prevent"]))
        }, null, 512), [
            [a, t.dismissText]
        ])])], 2)
    }
    const pue = ct(rue, [
            ["render", due],
            ["__scopeId", "data-v-39debcb6"]
        ]),
        mue = yt({
            props: {
                text: String,
                subtext: String,
                classes: {
                    type: [Array, String],
                    default: () => "jbg"
                },
                options: Array
            },
            emits: ["resolve"]
        }),
        gue = {
            class: "text"
        },
        _ue = {
            key: 0,
            class: "subtext"
        },
        yue = {
            class: "actions"
        },
        vue = ["onClick"];

    function bue(t, e, n, r, s, i) {
        const a = fn("bb");
        return Y(), X("div", {
            class: mt(["options-modal", t.classes])
        }, [Ge(W("h3", gue, null, 512), [
            [a, t.text]
        ]), t.subtext ? Ge((Y(), X("h3", _ue, null, 512)), [
            [a, t.subtext]
        ]) : Ve("", !0), W("div", yue, [(Y(!0), X(St, null, In(t.options, (c, l) => Ge((Y(), X("button", {
            key: l,
            class: mt(c.classes),
            onClick: xi(h => t.$emit("resolve", c.value), ["prevent"])
        }, null, 10, vue)), [
            [a, c.text]
        ])), 128))])], 2)
    }
    const Eue = ct(mue, [
            ["render", bue],
            ["__scopeId", "data-v-adb60058"]
        ]),
        Sue = yt({
            data() {
                return {
                    classes: "jbg",
                    props: null,
                    resolve: null,
                    content: null
                }
            },
            beforeMount() {
                this.$registerModal(this)
            },
            methods: {
                show(t, e = {}, n = {}) {
                    return this.props = e, this.classes = n.classes || "jbg", t === "Error" ? this.content = pue : t === "Options" ? this.content = Eue : this.content = t, new Promise(r => {
                        this.resolve = r
                    })
                },
                onResolve(...t) {
                    this.props = null, this.resolve(...t)
                },
                onBackgroundClick() {
                    this.props = null, this.resolve()
                }
            }
        });

    function Tue(t, e, n, r, s, i) {
        return Y(), Vt(xs, {
            name: "modal-transition"
        }, {
            default: cs(() => [t.props ? (Y(), X("div", {
                key: 0,
                class: mt(["modal", t.classes]),
                onKeyup: e[0] || (e[0] = Yy((...a) => t.onBackgroundClick && t.onBackgroundClick(...a), ["esc"])),
                onClick: e[1] || (e[1] = xi((...a) => t.onBackgroundClick && t.onBackgroundClick(...a), ["self"]))
            }, [t.content ? (Y(), Vt(qy(t.content), Up({
                key: 0,
                class: "content"
            }, t.props, {
                onResolve: t.onResolve
            }), null, 16, ["onResolve"])) : Ve("", !0)], 34)) : Ve("", !0)]),
            _: 1
        })
    }
    const wue = ct(Sue, [
            ["render", Tue],
            ["__scopeId", "data-v-dc92e8d3"]
        ]),
        Oue = {
            install: t => {
                if (t.config.globalProperties.$showModal) return;
                let e;
                const n = () => {
                        if (!e) throw new Error("No ModalComponent is registered");
                        return e.onBackgroundClick()
                    },
                    r = (i, a, c) => {
                        if (!e) throw new Error("No ModalComponent is registered");
                        return e.show(i, a, c)
                    },
                    s = i => {
                        e = i
                    };
                t.component("Modal", wue), t.config.globalProperties.$hideModal = n, t.config.globalProperties.$showModal = r, t.config.globalProperties.$registerModal = s
            }
        },
        Aue = {
            install: t => {
                const e = new Map;
                t.directive("pointerbox", {
                    mounted(n, r) {
                        const s = new E1(n, {
                            restrictToBox: r.modifiers.restrict,
                            isMultitouch: r.modifiers.multi
                        });
                        e.set(n, s)
                    },
                    unmounted(n) {
                        var r;
                        (r = e.get(n)) == null || r.destroy(), e.delete(n)
                    }
                }), t.directive("pointerbox-translate", {
                    mounted(n, r) {
                        n.setAttribute("data-pointerboxtranslateid", r.value.id ?? ""), n.setAttribute("data-pointerboxtranslatewidth", r.value.width ?? ""), n.setAttribute("data-pointerboxtranslateheight", r.value.height ?? "")
                    },
                    unmounted(n) {
                        n.removeAttribute("data-pointerboxtranslateid"), n.removeAttribute("data-pointerboxtranslatewidth"), n.removeAttribute("data-pointerboxtranslateheight")
                    }
                })
            }
        },
        Cue = yt({
            setup() {
                return {
                    announcment: mo(ih.textDescriptions.announcement)
                }
            },
            ecastKeys: {
                textDescriptions: "textDescriptions"
            },
            data() {
                return {
                    lines: []
                }
            },
            computed: {
                textDescriptions() {
                    return !this.$ecastValues || !this.$ecastValues.textDescriptions ? null : this.$ecastValues.textDescriptions
                }
            },
            watch: {
                announcment: function(e) {
                    this.lines.push({
                        id: Math.random(),
                        category: "announce",
                        text: e
                    })
                },
                "textDescriptions.latestDescriptions": function(e) {
                    !e || !e.length || e.forEach(n => {
                        n.id !== void 0 && this.lines.find(r => r.id === n.id) || this.lines.push(n)
                    })
                }
            }
        }),
        Iue = {
            class: "text-descriptions",
            role: "log",
            "aria-atomic": "false",
            "aria-relevant": "additions",
            "aria-live": "polite"
        };

    function kue(t, e, n, r, s, i) {
        return Y(), X("div", Iue, [(Y(!0), X(St, null, In(t.lines, a => (Y(), X("p", {
            key: a.id
        }, _t(a.text), 1))), 128))])
    }
    const Nue = ct(Cue, [
            ["render", kue]
        ]),
        e3 = Qr(""),
        xue = {
            install: t => {
                if (t.config.globalProperties.$announce) return;
                t.provide(ih.textDescriptions.announcement, Lr(() => e3.value));
                const e = n => {
                    e3.value = n
                };
                t.component("TextDescriptions", Nue), t.config.globalProperties.$announce = e
            }
        },
        Pue = {
            install: t => {
                let e = "",
                    n = "";
                const r = i => i instanceof Function ? i() : i,
                    s = i => {
                        const a = document.querySelector('meta[name="theme-color"]');
                        a && (document.body && (document.body.style.background = i), a.setAttribute("content", i), n = i)
                    };
                t.config.globalProperties.$setThemeColor = function(a) {
                    this.$options.themeColor = a, s(a)
                }, t.mixin({
                    mounted() {
                        if (!this.$options.themeColor) return;
                        const i = r(this.$options.themeColor);
                        s(i), this.$attrs.name === "game" && (e = i)
                    },
                    beforeDestroy() {
                        !this.$options.themeColor || r(this.$options.themeColor) !== n || s(e)
                    }
                })
            }
        },
        Rue = {
            install: t => {
                t.config.globalProperties.$vibrate = (e = [100, 100]) => {
                    var n;
                    if (!((n = window.navigator) != null && n.vibrate)) return !1;
                    try {
                        return window.navigator.vibrate(e), !0
                    } catch {
                        return !1
                    }
                }
            }
        };
    /*!
     * shared v9.2.2
     * (c) 2022 kazuya kawaguchi
     * Released under the MIT License.
     */
    const z1 = typeof window < "u",
        Mue = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol",
        Fo = t => Mue ? Symbol(t) : t,
        Due = (t, e, n) => $ue({
            l: t,
            k: e,
            s: n
        }),
        $ue = t => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"),
        kn = t => typeof t == "number" && isFinite(t),
        Lue = t => d0(t) === "[object Date]",
        Oo = t => d0(t) === "[object RegExp]",
        pm = t => rt(t) && Object.keys(t).length === 0;

    function Fue(t, e) {
        typeof console < "u" && (console.warn("[intlify] " + t), e && console.warn(e.stack))
    }
    const Hn = Object.assign;

    function t3(t) {
        return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
    }
    const Uue = Object.prototype.hasOwnProperty;

    function f0(t, e) {
        return Uue.call(t, e)
    }
    const Kt = Array.isArray,
        _n = t => typeof t == "function",
        Me = t => typeof t == "string",
        Ot = t => typeof t == "boolean",
        Yt = t => t !== null && typeof t == "object",
        IC = Object.prototype.toString,
        d0 = t => IC.call(t),
        rt = t => d0(t) === "[object Object]",
        Bue = t => t == null ? "" : Kt(t) || rt(t) && t.toString === IC ? JSON.stringify(t, null, 2) : String(t);
    /*!
     * message-compiler v9.2.2
     * (c) 2022 kazuya kawaguchi
     * Released under the MIT License.
     */
    const Nt = {
        EXPECTED_TOKEN: 1,
        INVALID_TOKEN_IN_PLACEHOLDER: 2,
        UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
        UNKNOWN_ESCAPE_SEQUENCE: 4,
        INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
        UNBALANCED_CLOSING_BRACE: 6,
        UNTERMINATED_CLOSING_BRACE: 7,
        EMPTY_PLACEHOLDER: 8,
        NOT_ALLOW_NEST_PLACEHOLDER: 9,
        INVALID_LINKED_FORMAT: 10,
        MUST_HAVE_MESSAGES_IN_PLURAL: 11,
        UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
        UNEXPECTED_EMPTY_LINKED_KEY: 13,
        UNEXPECTED_LEXICAL_ANALYSIS: 14,
        __EXTEND_POINT__: 15
    };

    function mm(t, e, n = {}) {
        const {
            domain: r,
            messages: s,
            args: i
        } = n, a = t, c = new SyntaxError(String(a));
        return c.code = t, e && (c.location = e), c.domain = r, c
    }

    function que(t) {
        throw t
    }

    function Vue(t, e, n) {
        return {
            line: t,
            column: e,
            offset: n
        }
    }

    function Z1(t, e, n) {
        const r = {
            start: t,
            end: e
        };
        return n != null && (r.source = n), r
    }
    const yi = " ",
        jue = "\r",
        lr = `
`,
        Gue = String.fromCharCode(8232),
        Wue = String.fromCharCode(8233);

    function Hue(t) {
        const e = t;
        let n = 0,
            r = 1,
            s = 1,
            i = 0;
        const a = B => e[B] === jue && e[B + 1] === lr,
            c = B => e[B] === lr,
            l = B => e[B] === Wue,
            h = B => e[B] === Gue,
            d = B => a(B) || c(B) || l(B) || h(B),
            p = () => n,
            g = () => r,
            v = () => s,
            b = () => i,
            T = B => a(B) || l(B) || h(B) ? lr : e[B],
            m = () => T(n),
            w = () => T(n + i);

        function P() {
            return i = 0, d(n) && (r++, s = 0), a(n) && n++, n++, s++, e[n]
        }

        function V() {
            return a(n + i) && i++, i++, e[n + i]
        }

        function M() {
            n = 0, r = 1, s = 1, i = 0
        }

        function I(B = 0) {
            i = B
        }

        function L() {
            const B = n + i;
            for (; B !== n;) P();
            i = 0
        }
        return {
            index: p,
            line: g,
            column: v,
            peekOffset: b,
            charAt: T,
            currentChar: m,
            currentPeek: w,
            next: P,
            peek: V,
            reset: M,
            resetPeek: I,
            skipToPeek: L
        }
    }
    const no = void 0,
        n3 = "'",
        Kue = "tokenizer";

    function Yue(t, e = {}) {
        const n = e.location !== !1,
            r = Hue(t),
            s = () => r.index(),
            i = () => Vue(r.line(), r.column(), r.index()),
            a = i(),
            c = s(),
            l = {
                currentType: 14,
                offset: c,
                startLoc: a,
                endLoc: a,
                lastType: 14,
                lastOffset: c,
                lastStartLoc: a,
                lastEndLoc: a,
                braceNest: 0,
                inLinked: !1,
                text: ""
            },
            h = () => l,
            {
                onError: d
            } = e;

        function p(y, E, C, ...D) {
            const Z = h();
            if (E.column += C, E.offset += C, d) {
                const oe = Z1(Z.startLoc, E),
                    pe = mm(y, oe, {
                        domain: Kue,
                        args: D
                    });
                d(pe)
            }
        }

        function g(y, E, C) {
            y.endLoc = i(), y.currentType = E;
            const D = {
                type: E
            };
            return n && (D.loc = Z1(y.startLoc, y.endLoc)), C != null && (D.value = C), D
        }
        const v = y => g(y, 14);

        function b(y, E) {
            return y.currentChar() === E ? (y.next(), E) : (p(Nt.EXPECTED_TOKEN, i(), 0, E), "")
        }

        function T(y) {
            let E = "";
            for (; y.currentPeek() === yi || y.currentPeek() === lr;) E += y.currentPeek(), y.peek();
            return E
        }

        function m(y) {
            const E = T(y);
            return y.skipToPeek(), E
        }

        function w(y) {
            if (y === no) return !1;
            const E = y.charCodeAt(0);
            return E >= 97 && E <= 122 || E >= 65 && E <= 90 || E === 95
        }

        function P(y) {
            if (y === no) return !1;
            const E = y.charCodeAt(0);
            return E >= 48 && E <= 57
        }

        function V(y, E) {
            const {
                currentType: C
            } = E;
            if (C !== 2) return !1;
            T(y);
            const D = w(y.currentPeek());
            return y.resetPeek(), D
        }

        function M(y, E) {
            const {
                currentType: C
            } = E;
            if (C !== 2) return !1;
            T(y);
            const D = y.currentPeek() === "-" ? y.peek() : y.currentPeek(),
                Z = P(D);
            return y.resetPeek(), Z
        }

        function I(y, E) {
            const {
                currentType: C
            } = E;
            if (C !== 2) return !1;
            T(y);
            const D = y.currentPeek() === n3;
            return y.resetPeek(), D
        }

        function L(y, E) {
            const {
                currentType: C
            } = E;
            if (C !== 8) return !1;
            T(y);
            const D = y.currentPeek() === ".";
            return y.resetPeek(), D
        }

        function B(y, E) {
            const {
                currentType: C
            } = E;
            if (C !== 9) return !1;
            T(y);
            const D = w(y.currentPeek());
            return y.resetPeek(), D
        }

        function q(y, E) {
            const {
                currentType: C
            } = E;
            if (!(C === 8 || C === 12)) return !1;
            T(y);
            const D = y.currentPeek() === ":";
            return y.resetPeek(), D
        }

        function se(y, E) {
            const {
                currentType: C
            } = E;
            if (C !== 10) return !1;
            const D = () => {
                    const oe = y.currentPeek();
                    return oe === "{" ? w(y.peek()) : oe === "@" || oe === "%" || oe === "|" || oe === ":" || oe === "." || oe === yi || !oe ? !1 : oe === lr ? (y.peek(), D()) : w(oe)
                },
                Z = D();
            return y.resetPeek(), Z
        }

        function ce(y) {
            T(y);
            const E = y.currentPeek() === "|";
            return y.resetPeek(), E
        }

        function ue(y) {
            const E = T(y),
                C = y.currentPeek() === "%" && y.peek() === "{";
            return y.resetPeek(), {
                isModulo: C,
                hasSpace: E.length > 0
            }
        }

        function ee(y, E = !0) {
            const C = (Z = !1, oe = "", pe = !1) => {
                    const _e = y.currentPeek();
                    return _e === "{" ? oe === "%" ? !1 : Z : _e === "@" || !_e ? oe === "%" ? !0 : Z : _e === "%" ? (y.peek(), C(Z, "%", !0)) : _e === "|" ? oe === "%" || pe ? !0 : !(oe === yi || oe === lr) : _e === yi ? (y.peek(), C(!0, yi, pe)) : _e === lr ? (y.peek(), C(!0, lr, pe)) : !0
                },
                D = C();
            return E && y.resetPeek(), D
        }

        function ge(y, E) {
            const C = y.currentChar();
            return C === no ? no : E(C) ? (y.next(), C) : null
        }

        function G(y) {
            return ge(y, C => {
                const D = C.charCodeAt(0);
                return D >= 97 && D <= 122 || D >= 65 && D <= 90 || D >= 48 && D <= 57 || D === 95 || D === 36
            })
        }

        function le(y) {
            return ge(y, C => {
                const D = C.charCodeAt(0);
                return D >= 48 && D <= 57
            })
        }

        function fe(y) {
            return ge(y, C => {
                const D = C.charCodeAt(0);
                return D >= 48 && D <= 57 || D >= 65 && D <= 70 || D >= 97 && D <= 102
            })
        }

        function me(y) {
            let E = "",
                C = "";
            for (; E = le(y);) C += E;
            return C
        }

        function Te(y) {
            m(y);
            const E = y.currentChar();
            return E !== "%" && p(Nt.EXPECTED_TOKEN, i(), 0, E), y.next(), "%"
        }

        function we(y) {
            let E = "";
            for (;;) {
                const C = y.currentChar();
                if (C === "{" || C === "}" || C === "@" || C === "|" || !C) break;
                if (C === "%")
                    if (ee(y)) E += C, y.next();
                    else break;
                else if (C === yi || C === lr)
                    if (ee(y)) E += C, y.next();
                    else {
                        if (ce(y)) break;
                        E += C, y.next()
                    }
                else E += C, y.next()
            }
            return E
        }

        function ke(y) {
            m(y);
            let E = "",
                C = "";
            for (; E = G(y);) C += E;
            return y.currentChar() === no && p(Nt.UNTERMINATED_CLOSING_BRACE, i(), 0), C
        }

        function Ie(y) {
            m(y);
            let E = "";
            return y.currentChar() === "-" ? (y.next(), E += `-${me(y)}`) : E += me(y), y.currentChar() === no && p(Nt.UNTERMINATED_CLOSING_BRACE, i(), 0), E
        }

        function $e(y) {
            m(y), b(y, "'");
            let E = "",
                C = "";
            const D = oe => oe !== n3 && oe !== lr;
            for (; E = ge(y, D);) E === "\\" ? C += At(y) : C += E;
            const Z = y.currentChar();
            return Z === lr || Z === no ? (p(Nt.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, i(), 0), Z === lr && (y.next(), b(y, "'")), C) : (b(y, "'"), C)
        }

        function At(y) {
            const E = y.currentChar();
            switch (E) {
                case "\\":
                case "'":
                    return y.next(), `\\${E}`;
                case "u":
                    return $t(y, E, 4);
                case "U":
                    return $t(y, E, 6);
                default:
                    return p(Nt.UNKNOWN_ESCAPE_SEQUENCE, i(), 0, E), ""
            }
        }

        function $t(y, E, C) {
            b(y, E);
            let D = "";
            for (let Z = 0; Z < C; Z++) {
                const oe = fe(y);
                if (!oe) {
                    p(Nt.INVALID_UNICODE_ESCAPE_SEQUENCE, i(), 0, `\\${E}${D}${y.currentChar()}`);
                    break
                }
                D += oe
            }
            return `\\${E}${D}`
        }

        function qe(y) {
            m(y);
            let E = "",
                C = "";
            const D = Z => Z !== "{" && Z !== "}" && Z !== yi && Z !== lr;
            for (; E = ge(y, D);) C += E;
            return C
        }

        function Xe(y) {
            let E = "",
                C = "";
            for (; E = G(y);) C += E;
            return C
        }

        function tt(y) {
            const E = (C = !1, D) => {
                const Z = y.currentChar();
                return Z === "{" || Z === "%" || Z === "@" || Z === "|" || !Z || Z === yi ? D : Z === lr ? (D += Z, y.next(), E(C, D)) : (D += Z, y.next(), E(!0, D))
            };
            return E(!1, "")
        }

        function S(y) {
            m(y);
            const E = b(y, "|");
            return m(y), E
        }

        function k(y, E) {
            let C = null;
            switch (y.currentChar()) {
                case "{":
                    return E.braceNest >= 1 && p(Nt.NOT_ALLOW_NEST_PLACEHOLDER, i(), 0), y.next(), C = g(E, 2, "{"), m(y), E.braceNest++, C;
                case "}":
                    return E.braceNest > 0 && E.currentType === 2 && p(Nt.EMPTY_PLACEHOLDER, i(), 0), y.next(), C = g(E, 3, "}"), E.braceNest--, E.braceNest > 0 && m(y), E.inLinked && E.braceNest === 0 && (E.inLinked = !1), C;
                case "@":
                    return E.braceNest > 0 && p(Nt.UNTERMINATED_CLOSING_BRACE, i(), 0), C = H(y, E) || v(E), E.braceNest = 0, C;
                default:
                    let Z = !0,
                        oe = !0,
                        pe = !0;
                    if (ce(y)) return E.braceNest > 0 && p(Nt.UNTERMINATED_CLOSING_BRACE, i(), 0), C = g(E, 1, S(y)), E.braceNest = 0, E.inLinked = !1, C;
                    if (E.braceNest > 0 && (E.currentType === 5 || E.currentType === 6 || E.currentType === 7)) return p(Nt.UNTERMINATED_CLOSING_BRACE, i(), 0), E.braceNest = 0, K(y, E);
                    if (Z = V(y, E)) return C = g(E, 5, ke(y)), m(y), C;
                    if (oe = M(y, E)) return C = g(E, 6, Ie(y)), m(y), C;
                    if (pe = I(y, E)) return C = g(E, 7, $e(y)), m(y), C;
                    if (!Z && !oe && !pe) return C = g(E, 13, qe(y)), p(Nt.INVALID_TOKEN_IN_PLACEHOLDER, i(), 0, C.value), m(y), C;
                    break
            }
            return C
        }

        function H(y, E) {
            const {
                currentType: C
            } = E;
            let D = null;
            const Z = y.currentChar();
            switch ((C === 8 || C === 9 || C === 12 || C === 10) && (Z === lr || Z === yi) && p(Nt.INVALID_LINKED_FORMAT, i(), 0), Z) {
                case "@":
                    return y.next(), D = g(E, 8, "@"), E.inLinked = !0, D;
                case ".":
                    return m(y), y.next(), g(E, 9, ".");
                case ":":
                    return m(y), y.next(), g(E, 10, ":");
                default:
                    return ce(y) ? (D = g(E, 1, S(y)), E.braceNest = 0, E.inLinked = !1, D) : L(y, E) || q(y, E) ? (m(y), H(y, E)) : B(y, E) ? (m(y), g(E, 12, Xe(y))) : se(y, E) ? (m(y), Z === "{" ? k(y, E) || D : g(E, 11, tt(y))) : (C === 8 && p(Nt.INVALID_LINKED_FORMAT, i(), 0), E.braceNest = 0, E.inLinked = !1, K(y, E))
            }
        }

        function K(y, E) {
            let C = {
                type: 14
            };
            if (E.braceNest > 0) return k(y, E) || v(E);
            if (E.inLinked) return H(y, E) || v(E);
            switch (y.currentChar()) {
                case "{":
                    return k(y, E) || v(E);
                case "}":
                    return p(Nt.UNBALANCED_CLOSING_BRACE, i(), 0), y.next(), g(E, 3, "}");
                case "@":
                    return H(y, E) || v(E);
                default:
                    if (ce(y)) return C = g(E, 1, S(y)), E.braceNest = 0, E.inLinked = !1, C;
                    const {
                        isModulo: Z, hasSpace: oe
                    } = ue(y);
                    if (Z) return oe ? g(E, 0, we(y)) : g(E, 4, Te(y));
                    if (ee(y)) return g(E, 0, we(y));
                    break
            }
            return C
        }

        function A() {
            const {
                currentType: y,
                offset: E,
                startLoc: C,
                endLoc: D
            } = l;
            return l.lastType = y, l.lastOffset = E, l.lastStartLoc = C, l.lastEndLoc = D, l.offset = s(), l.startLoc = i(), r.currentChar() === no ? g(l, 14) : K(r, l)
        }
        return {
            nextToken: A,
            currentOffset: s,
            currentPosition: i,
            context: h
        }
    }
    const zue = "parser",
        Zue = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

    function Xue(t, e, n) {
        switch (t) {
            case "\\\\":
                return "\\";
            case "\\'":
                return "'";
            default: {
                const r = parseInt(e || n, 16);
                return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : ""
            }
        }
    }

    function Que(t = {}) {
        const e = t.location !== !1,
            {
                onError: n
            } = t;

        function r(w, P, V, M, ...I) {
            const L = w.currentPosition();
            if (L.offset += M, L.column += M, n) {
                const B = Z1(V, L),
                    q = mm(P, B, {
                        domain: zue,
                        args: I
                    });
                n(q)
            }
        }

        function s(w, P, V) {
            const M = {
                type: w,
                start: P,
                end: P
            };
            return e && (M.loc = {
                start: V,
                end: V
            }), M
        }

        function i(w, P, V, M) {
            w.end = P, M && (w.type = M), e && w.loc && (w.loc.end = V)
        }

        function a(w, P) {
            const V = w.context(),
                M = s(3, V.offset, V.startLoc);
            return M.value = P, i(M, w.currentOffset(), w.currentPosition()), M
        }

        function c(w, P) {
            const V = w.context(),
                {
                    lastOffset: M,
                    lastStartLoc: I
                } = V,
                L = s(5, M, I);
            return L.index = parseInt(P, 10), w.nextToken(), i(L, w.currentOffset(), w.currentPosition()), L
        }

        function l(w, P) {
            const V = w.context(),
                {
                    lastOffset: M,
                    lastStartLoc: I
                } = V,
                L = s(4, M, I);
            return L.key = P, w.nextToken(), i(L, w.currentOffset(), w.currentPosition()), L
        }

        function h(w, P) {
            const V = w.context(),
                {
                    lastOffset: M,
                    lastStartLoc: I
                } = V,
                L = s(9, M, I);
            return L.value = P.replace(Zue, Xue), w.nextToken(), i(L, w.currentOffset(), w.currentPosition()), L
        }

        function d(w) {
            const P = w.nextToken(),
                V = w.context(),
                {
                    lastOffset: M,
                    lastStartLoc: I
                } = V,
                L = s(8, M, I);
            return P.type !== 12 ? (r(w, Nt.UNEXPECTED_EMPTY_LINKED_MODIFIER, V.lastStartLoc, 0), L.value = "", i(L, M, I), {
                nextConsumeToken: P,
                node: L
            }) : (P.value == null && r(w, Nt.UNEXPECTED_LEXICAL_ANALYSIS, V.lastStartLoc, 0, Gs(P)), L.value = P.value || "", i(L, w.currentOffset(), w.currentPosition()), {
                node: L
            })
        }

        function p(w, P) {
            const V = w.context(),
                M = s(7, V.offset, V.startLoc);
            return M.value = P, i(M, w.currentOffset(), w.currentPosition()), M
        }

        function g(w) {
            const P = w.context(),
                V = s(6, P.offset, P.startLoc);
            let M = w.nextToken();
            if (M.type === 9) {
                const I = d(w);
                V.modifier = I.node, M = I.nextConsumeToken || w.nextToken()
            }
            switch (M.type !== 10 && r(w, Nt.UNEXPECTED_LEXICAL_ANALYSIS, P.lastStartLoc, 0, Gs(M)), M = w.nextToken(), M.type === 2 && (M = w.nextToken()), M.type) {
                case 11:
                    M.value == null && r(w, Nt.UNEXPECTED_LEXICAL_ANALYSIS, P.lastStartLoc, 0, Gs(M)), V.key = p(w, M.value || "");
                    break;
                case 5:
                    M.value == null && r(w, Nt.UNEXPECTED_LEXICAL_ANALYSIS, P.lastStartLoc, 0, Gs(M)), V.key = l(w, M.value || "");
                    break;
                case 6:
                    M.value == null && r(w, Nt.UNEXPECTED_LEXICAL_ANALYSIS, P.lastStartLoc, 0, Gs(M)), V.key = c(w, M.value || "");
                    break;
                case 7:
                    M.value == null && r(w, Nt.UNEXPECTED_LEXICAL_ANALYSIS, P.lastStartLoc, 0, Gs(M)), V.key = h(w, M.value || "");
                    break;
                default:
                    r(w, Nt.UNEXPECTED_EMPTY_LINKED_KEY, P.lastStartLoc, 0);
                    const I = w.context(),
                        L = s(7, I.offset, I.startLoc);
                    return L.value = "", i(L, I.offset, I.startLoc), V.key = L, i(V, I.offset, I.startLoc), {
                        nextConsumeToken: M,
                        node: V
                    }
            }
            return i(V, w.currentOffset(), w.currentPosition()), {
                node: V
            }
        }

        function v(w) {
            const P = w.context(),
                V = P.currentType === 1 ? w.currentOffset() : P.offset,
                M = P.currentType === 1 ? P.endLoc : P.startLoc,
                I = s(2, V, M);
            I.items = [];
            let L = null;
            do {
                const se = L || w.nextToken();
                switch (L = null, se.type) {
                    case 0:
                        se.value == null && r(w, Nt.UNEXPECTED_LEXICAL_ANALYSIS, P.lastStartLoc, 0, Gs(se)), I.items.push(a(w, se.value || ""));
                        break;
                    case 6:
                        se.value == null && r(w, Nt.UNEXPECTED_LEXICAL_ANALYSIS, P.lastStartLoc, 0, Gs(se)), I.items.push(c(w, se.value || ""));
                        break;
                    case 5:
                        se.value == null && r(w, Nt.UNEXPECTED_LEXICAL_ANALYSIS, P.lastStartLoc, 0, Gs(se)), I.items.push(l(w, se.value || ""));
                        break;
                    case 7:
                        se.value == null && r(w, Nt.UNEXPECTED_LEXICAL_ANALYSIS, P.lastStartLoc, 0, Gs(se)), I.items.push(h(w, se.value || ""));
                        break;
                    case 8:
                        const ce = g(w);
                        I.items.push(ce.node), L = ce.nextConsumeToken || null;
                        break
                }
            } while (P.currentType !== 14 && P.currentType !== 1);
            const B = P.currentType === 1 ? P.lastOffset : w.currentOffset(),
                q = P.currentType === 1 ? P.lastEndLoc : w.currentPosition();
            return i(I, B, q), I
        }

        function b(w, P, V, M) {
            const I = w.context();
            let L = M.items.length === 0;
            const B = s(1, P, V);
            B.cases = [], B.cases.push(M);
            do {
                const q = v(w);
                L || (L = q.items.length === 0), B.cases.push(q)
            } while (I.currentType !== 14);
            return L && r(w, Nt.MUST_HAVE_MESSAGES_IN_PLURAL, V, 0), i(B, w.currentOffset(), w.currentPosition()), B
        }

        function T(w) {
            const P = w.context(),
                {
                    offset: V,
                    startLoc: M
                } = P,
                I = v(w);
            return P.currentType === 14 ? I : b(w, V, M, I)
        }

        function m(w) {
            const P = Yue(w, Hn({}, t)),
                V = P.context(),
                M = s(0, V.offset, V.startLoc);
            return e && M.loc && (M.loc.source = w), M.body = T(P), V.currentType !== 14 && r(P, Nt.UNEXPECTED_LEXICAL_ANALYSIS, V.lastStartLoc, 0, w[V.offset] || ""), i(M, P.currentOffset(), P.currentPosition()), M
        }
        return {
            parse: m
        }
    }

    function Gs(t) {
        if (t.type === 14) return "EOF";
        const e = (t.value || "").replace(/\r?\n/gu, "\\n");
        return e.length > 10 ? e.slice(0, 9) + "" : e
    }

    function Jue(t, e = {}) {
        const n = {
            ast: t,
            helpers: new Set
        };
        return {
            context: () => n,
            helper: i => (n.helpers.add(i), i)
        }
    }

    function r3(t, e) {
        for (let n = 0; n < t.length; n++) p0(t[n], e)
    }

    function p0(t, e) {
        switch (t.type) {
            case 1:
                r3(t.cases, e), e.helper("plural");
                break;
            case 2:
                r3(t.items, e);
                break;
            case 6:
                p0(t.key, e), e.helper("linked"), e.helper("type");
                break;
            case 5:
                e.helper("interpolate"), e.helper("list");
                break;
            case 4:
                e.helper("interpolate"), e.helper("named");
                break
        }
    }

    function ele(t, e = {}) {
        const n = Jue(t);
        n.helper("normalize"), t.body && p0(t.body, n);
        const r = n.context();
        t.helpers = Array.from(r.helpers)
    }

    function tle(t, e) {
        const {
            sourceMap: n,
            filename: r,
            breakLineCode: s,
            needIndent: i
        } = e, a = {
            source: t.loc.source,
            filename: r,
            code: "",
            column: 1,
            line: 1,
            offset: 0,
            map: void 0,
            breakLineCode: s,
            needIndent: i,
            indentLevel: 0
        }, c = () => a;

        function l(T, m) {
            a.code += T
        }

        function h(T, m = !0) {
            const w = m ? s : "";
            l(i ? w + "  ".repeat(T) : w)
        }

        function d(T = !0) {
            const m = ++a.indentLevel;
            T && h(m)
        }

        function p(T = !0) {
            const m = --a.indentLevel;
            T && h(m)
        }

        function g() {
            h(a.indentLevel)
        }
        return {
            context: c,
            push: l,
            indent: d,
            deindent: p,
            newline: g,
            helper: T => `_${T}`,
            needIndent: () => a.needIndent
        }
    }

    function nle(t, e) {
        const {
            helper: n
        } = t;
        t.push(`${n("linked")}(`), Uc(t, e.key), e.modifier ? (t.push(", "), Uc(t, e.modifier), t.push(", _type")) : t.push(", undefined, _type"), t.push(")")
    }

    function rle(t, e) {
        const {
            helper: n,
            needIndent: r
        } = t;
        t.push(`${n("normalize")}([`), t.indent(r());
        const s = e.items.length;
        for (let i = 0; i < s && (Uc(t, e.items[i]), i !== s - 1); i++) t.push(", ");
        t.deindent(r()), t.push("])")
    }

    function sle(t, e) {
        const {
            helper: n,
            needIndent: r
        } = t;
        if (e.cases.length > 1) {
            t.push(`${n("plural")}([`), t.indent(r());
            const s = e.cases.length;
            for (let i = 0; i < s && (Uc(t, e.cases[i]), i !== s - 1); i++) t.push(", ");
            t.deindent(r()), t.push("])")
        }
    }

    function ile(t, e) {
        e.body ? Uc(t, e.body) : t.push("null")
    }

    function Uc(t, e) {
        const {
            helper: n
        } = t;
        switch (e.type) {
            case 0:
                ile(t, e);
                break;
            case 1:
                sle(t, e);
                break;
            case 2:
                rle(t, e);
                break;
            case 6:
                nle(t, e);
                break;
            case 8:
                t.push(JSON.stringify(e.value), e);
                break;
            case 7:
                t.push(JSON.stringify(e.value), e);
                break;
            case 5:
                t.push(`${n("interpolate")}(${n("list")}(${e.index}))`, e);
                break;
            case 4:
                t.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(e.key)}))`, e);
                break;
            case 9:
                t.push(JSON.stringify(e.value), e);
                break;
            case 3:
                t.push(JSON.stringify(e.value), e);
                break
        }
    }
    const ole = (t, e = {}) => {
        const n = Me(e.mode) ? e.mode : "normal",
            r = Me(e.filename) ? e.filename : "message.intl",
            s = !!e.sourceMap,
            i = e.breakLineCode != null ? e.breakLineCode : n === "arrow" ? ";" : `
`,
            a = e.needIndent ? e.needIndent : n !== "arrow",
            c = t.helpers || [],
            l = tle(t, {
                mode: n,
                filename: r,
                sourceMap: s,
                breakLineCode: i,
                needIndent: a
            });
        l.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), l.indent(a), c.length > 0 && (l.push(`const { ${c.map(p=>`${p}: _${p}`).join(", ")} } = ctx`), l.newline()), l.push("return "), Uc(l, t), l.deindent(a), l.push("}");
        const {
            code: h,
            map: d
        } = l.context();
        return {
            ast: t,
            code: h,
            map: d ? d.toJSON() : void 0
        }
    };

    function ale(t, e = {}) {
        const n = Hn({}, e),
            s = Que(n).parse(t);
        return ele(s, n), ole(s, n)
    }
    /*!
     * core-base v9.2.2
     * (c) 2022 kazuya kawaguchi
     * Released under the MIT License.
     */
    const Uo = [];
    Uo[0] = {
        w: [0],
        i: [3, 0],
        "[": [4],
        o: [7]
    };
    Uo[1] = {
        w: [1],
        ".": [2],
        "[": [4],
        o: [7]
    };
    Uo[2] = {
        w: [2],
        i: [3, 0],
        0: [3, 0]
    };
    Uo[3] = {
        i: [3, 0],
        0: [3, 0],
        w: [1, 1],
        ".": [2, 1],
        "[": [4, 1],
        o: [7, 1]
    };
    Uo[4] = {
        "'": [5, 0],
        '"': [6, 0],
        "[": [4, 2],
        "]": [1, 3],
        o: 8,
        l: [4, 0]
    };
    Uo[5] = {
        "'": [4, 0],
        o: 8,
        l: [5, 0]
    };
    Uo[6] = {
        '"': [4, 0],
        o: 8,
        l: [6, 0]
    };
    const cle = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

    function ule(t) {
        return cle.test(t)
    }

    function lle(t) {
        const e = t.charCodeAt(0),
            n = t.charCodeAt(t.length - 1);
        return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t
    }

    function hle(t) {
        if (t == null) return "o";
        switch (t.charCodeAt(0)) {
            case 91:
            case 93:
            case 46:
            case 34:
            case 39:
                return t;
            case 95:
            case 36:
            case 45:
                return "i";
            case 9:
            case 10:
            case 13:
            case 160:
            case 65279:
            case 8232:
            case 8233:
                return "w"
        }
        return "i"
    }

    function fle(t) {
        const e = t.trim();
        return t.charAt(0) === "0" && isNaN(parseInt(t)) ? !1 : ule(e) ? lle(e) : "*" + e
    }

    function dle(t) {
        const e = [];
        let n = -1,
            r = 0,
            s = 0,
            i, a, c, l, h, d, p;
        const g = [];
        g[0] = () => {
            a === void 0 ? a = c : a += c
        }, g[1] = () => {
            a !== void 0 && (e.push(a), a = void 0)
        }, g[2] = () => {
            g[0](), s++
        }, g[3] = () => {
            if (s > 0) s--, r = 4, g[0]();
            else {
                if (s = 0, a === void 0 || (a = fle(a), a === !1)) return !1;
                g[1]()
            }
        };

        function v() {
            const b = t[n + 1];
            if (r === 5 && b === "'" || r === 6 && b === '"') return n++, c = "\\" + b, g[0](), !0
        }
        for (; r !== null;)
            if (n++, i = t[n], !(i === "\\" && v())) {
                if (l = hle(i), p = Uo[r], h = p[l] || p.l || 8, h === 8 || (r = h[0], h[1] !== void 0 && (d = g[h[1]], d && (c = i, d() === !1)))) return;
                if (r === 7) return e
            }
    }
    const s3 = new Map;

    function ple(t, e) {
        return Yt(t) ? t[e] : null
    }

    function mle(t, e) {
        if (!Yt(t)) return null;
        let n = s3.get(e);
        if (n || (n = dle(e), n && s3.set(e, n)), !n) return null;
        const r = n.length;
        let s = t,
            i = 0;
        for (; i < r;) {
            const a = s[n[i]];
            if (a === void 0) return null;
            s = a, i++
        }
        return s
    }
    const gle = t => t,
        _le = t => "",
        yle = "text",
        vle = t => t.length === 0 ? "" : t.join(""),
        ble = Bue;

    function i3(t, e) {
        return t = Math.abs(t), e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0
    }

    function Ele(t) {
        const e = kn(t.pluralIndex) ? t.pluralIndex : -1;
        return t.named && (kn(t.named.count) || kn(t.named.n)) ? kn(t.named.count) ? t.named.count : kn(t.named.n) ? t.named.n : e : e
    }

    function Sle(t, e) {
        e.count || (e.count = t), e.n || (e.n = t)
    }

    function Tle(t = {}) {
        const e = t.locale,
            n = Ele(t),
            r = Yt(t.pluralRules) && Me(e) && _n(t.pluralRules[e]) ? t.pluralRules[e] : i3,
            s = Yt(t.pluralRules) && Me(e) && _n(t.pluralRules[e]) ? i3 : void 0,
            i = w => w[r(n, w.length, s)],
            a = t.list || [],
            c = w => a[w],
            l = t.named || {};
        kn(t.pluralIndex) && Sle(n, l);
        const h = w => l[w];

        function d(w) {
            const P = _n(t.messages) ? t.messages(w) : Yt(t.messages) ? t.messages[w] : !1;
            return P || (t.parent ? t.parent.message(w) : _le)
        }
        const p = w => t.modifiers ? t.modifiers[w] : gle,
            g = rt(t.processor) && _n(t.processor.normalize) ? t.processor.normalize : vle,
            v = rt(t.processor) && _n(t.processor.interpolate) ? t.processor.interpolate : ble,
            b = rt(t.processor) && Me(t.processor.type) ? t.processor.type : yle,
            m = {
                list: c,
                named: h,
                plural: i,
                linked: (w, ...P) => {
                    const [V, M] = P;
                    let I = "text",
                        L = "";
                    P.length === 1 ? Yt(V) ? (L = V.modifier || L, I = V.type || I) : Me(V) && (L = V || L) : P.length === 2 && (Me(V) && (L = V || L), Me(M) && (I = M || I));
                    let B = d(w)(m);
                    return I === "vnode" && Kt(B) && L && (B = B[0]), L ? p(L)(B, I) : B
                },
                message: d,
                type: b,
                interpolate: v,
                normalize: g
            };
        return m
    }

    function wle(t, e, n) {
        return [...new Set([n, ...Kt(e) ? e : Yt(e) ? Object.keys(e) : Me(e) ? [e] : [n]])]
    }

    function kC(t, e, n) {
        const r = Me(n) ? n : ch,
            s = t;
        s.__localeChainCache || (s.__localeChainCache = new Map);
        let i = s.__localeChainCache.get(r);
        if (!i) {
            i = [];
            let a = [n];
            for (; Kt(a);) a = o3(i, a, e);
            const c = Kt(e) || !rt(e) ? e : e.default ? e.default : null;
            a = Me(c) ? [c] : c, Kt(a) && o3(i, a, !1), s.__localeChainCache.set(r, i)
        }
        return i
    }

    function o3(t, e, n) {
        let r = !0;
        for (let s = 0; s < e.length && Ot(r); s++) {
            const i = e[s];
            Me(i) && (r = Ole(t, e[s], n))
        }
        return r
    }

    function Ole(t, e, n) {
        let r;
        const s = e.split("-");
        do {
            const i = s.join("-");
            r = Ale(t, i, n), s.splice(-1, 1)
        } while (s.length && r === !0);
        return r
    }

    function Ale(t, e, n) {
        let r = !1;
        if (!t.includes(e) && (r = !0, e)) {
            r = e[e.length - 1] !== "!";
            const s = e.replace(/!/g, "");
            t.push(s), (Kt(n) || rt(n)) && n[s] && (r = n[s])
        }
        return r
    }
    const Cle = "9.2.2",
        gm = -1,
        ch = "en-US",
        a3 = "",
        c3 = t => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;

    function Ile() {
        return {
            upper: (t, e) => e === "text" && Me(t) ? t.toUpperCase() : e === "vnode" && Yt(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
            lower: (t, e) => e === "text" && Me(t) ? t.toLowerCase() : e === "vnode" && Yt(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
            capitalize: (t, e) => e === "text" && Me(t) ? c3(t) : e === "vnode" && Yt(t) && "__v_isVNode" in t ? c3(t.children) : t
        }
    }
    let NC;

    function kle(t) {
        NC = t
    }
    let xC;

    function Nle(t) {
        xC = t
    }
    let PC;

    function xle(t) {
        PC = t
    }
    let u3 = 0;

    function Ple(t = {}) {
        const e = Me(t.version) ? t.version : Cle,
            n = Me(t.locale) ? t.locale : ch,
            r = Kt(t.fallbackLocale) || rt(t.fallbackLocale) || Me(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : n,
            s = rt(t.messages) ? t.messages : {
                [n]: {}
            },
            i = rt(t.datetimeFormats) ? t.datetimeFormats : {
                [n]: {}
            },
            a = rt(t.numberFormats) ? t.numberFormats : {
                [n]: {}
            },
            c = Hn({}, t.modifiers || {}, Ile()),
            l = t.pluralRules || {},
            h = _n(t.missing) ? t.missing : null,
            d = Ot(t.missingWarn) || Oo(t.missingWarn) ? t.missingWarn : !0,
            p = Ot(t.fallbackWarn) || Oo(t.fallbackWarn) ? t.fallbackWarn : !0,
            g = !!t.fallbackFormat,
            v = !!t.unresolving,
            b = _n(t.postTranslation) ? t.postTranslation : null,
            T = rt(t.processor) ? t.processor : null,
            m = Ot(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
            w = !!t.escapeParameter,
            P = _n(t.messageCompiler) ? t.messageCompiler : NC,
            V = _n(t.messageResolver) ? t.messageResolver : xC || ple,
            M = _n(t.localeFallbacker) ? t.localeFallbacker : PC || wle,
            I = Yt(t.fallbackContext) ? t.fallbackContext : void 0,
            L = _n(t.onWarn) ? t.onWarn : Fue,
            B = t,
            q = Yt(B.__datetimeFormatters) ? B.__datetimeFormatters : new Map,
            se = Yt(B.__numberFormatters) ? B.__numberFormatters : new Map,
            ce = Yt(B.__meta) ? B.__meta : {};
        u3++;
        const ue = {
            version: e,
            cid: u3,
            locale: n,
            fallbackLocale: r,
            messages: s,
            modifiers: c,
            pluralRules: l,
            missing: h,
            missingWarn: d,
            fallbackWarn: p,
            fallbackFormat: g,
            unresolving: v,
            postTranslation: b,
            processor: T,
            warnHtmlMessage: m,
            escapeParameter: w,
            messageCompiler: P,
            messageResolver: V,
            localeFallbacker: M,
            fallbackContext: I,
            onWarn: L,
            __meta: ce
        };
        return ue.datetimeFormats = i, ue.numberFormats = a, ue.__datetimeFormatters = q, ue.__numberFormatters = se, ue
    }

    function m0(t, e, n, r, s) {
        const {
            missing: i,
            onWarn: a
        } = t;
        if (i !== null) {
            const c = i(t, n, e, s);
            return Me(c) ? c : e
        } else return e
    }

    function qu(t, e, n) {
        const r = t;
        r.__localeChainCache = new Map, t.localeFallbacker(t, n, e)
    }
    const Rle = t => t;
    let l3 = Object.create(null);

    function Mle(t, e = {}) {
        {
            const r = (e.onCacheKey || Rle)(t),
                s = l3[r];
            if (s) return s;
            let i = !1;
            const a = e.onError || que;
            e.onError = h => {
                i = !0, a(h)
            };
            const {
                code: c
            } = ale(t, e), l = new Function(`return ${c}`)();
            return i ? l : l3[r] = l
        }
    }
    let RC = Nt.__EXTEND_POINT__;
    const G_ = () => ++RC,
        uc = {
            INVALID_ARGUMENT: RC,
            INVALID_DATE_ARGUMENT: G_(),
            INVALID_ISO_DATE_ARGUMENT: G_(),
            __EXTEND_POINT__: G_()
        };

    function lc(t) {
        return mm(t, null, void 0)
    }
    const h3 = () => "",
        _a = t => _n(t);

    function f3(t, ...e) {
        const {
            fallbackFormat: n,
            postTranslation: r,
            unresolving: s,
            messageCompiler: i,
            fallbackLocale: a,
            messages: c
        } = t, [l, h] = X1(...e), d = Ot(h.missingWarn) ? h.missingWarn : t.missingWarn, p = Ot(h.fallbackWarn) ? h.fallbackWarn : t.fallbackWarn, g = Ot(h.escapeParameter) ? h.escapeParameter : t.escapeParameter, v = !!h.resolvedMessage, b = Me(h.default) || Ot(h.default) ? Ot(h.default) ? i ? l : () => l : h.default : n ? i ? l : () => l : "", T = n || b !== "", m = Me(h.locale) ? h.locale : t.locale;
        g && Dle(h);
        let [w, P, V] = v ? [l, m, c[m] || {}] : MC(t, l, m, a, p, d), M = w, I = l;
        if (!v && !(Me(M) || _a(M)) && T && (M = b, I = M), !v && (!(Me(M) || _a(M)) || !Me(P))) return s ? gm : l;
        let L = !1;
        const B = () => {
                L = !0
            },
            q = _a(M) ? M : DC(t, l, P, M, I, B);
        if (L) return M;
        const se = Fle(t, P, V, h),
            ce = Tle(se),
            ue = $le(t, q, ce);
        return r ? r(ue, l) : ue
    }

    function Dle(t) {
        Kt(t.list) ? t.list = t.list.map(e => Me(e) ? t3(e) : e) : Yt(t.named) && Object.keys(t.named).forEach(e => {
            Me(t.named[e]) && (t.named[e] = t3(t.named[e]))
        })
    }

    function MC(t, e, n, r, s, i) {
        const {
            messages: a,
            onWarn: c,
            messageResolver: l,
            localeFallbacker: h
        } = t, d = h(t, r, n);
        let p = {},
            g, v = null;
        const b = "translate";
        for (let T = 0; T < d.length && (g = d[T], p = a[g] || {}, (v = l(p, e)) === null && (v = p[e]), !(Me(v) || _n(v))); T++) {
            const m = m0(t, e, g, i, b);
            m !== e && (v = m)
        }
        return [v, g, p]
    }

    function DC(t, e, n, r, s, i) {
        const {
            messageCompiler: a,
            warnHtmlMessage: c
        } = t;
        if (_a(r)) {
            const h = r;
            return h.locale = h.locale || n, h.key = h.key || e, h
        }
        if (a == null) {
            const h = () => r;
            return h.locale = n, h.key = e, h
        }
        const l = a(r, Lle(t, n, s, r, c, i));
        return l.locale = n, l.key = e, l.source = r, l
    }

    function $le(t, e, n) {
        return e(n)
    }

    function X1(...t) {
        const [e, n, r] = t, s = {};
        if (!Me(e) && !kn(e) && !_a(e)) throw lc(uc.INVALID_ARGUMENT);
        const i = kn(e) ? String(e) : (_a(e), e);
        return kn(n) ? s.plural = n : Me(n) ? s.default = n : rt(n) && !pm(n) ? s.named = n : Kt(n) && (s.list = n), kn(r) ? s.plural = r : Me(r) ? s.default = r : rt(r) && Hn(s, r), [i, s]
    }

    function Lle(t, e, n, r, s, i) {
        return {
            warnHtmlMessage: s,
            onError: a => {
                throw i && i(a), a
            },
            onCacheKey: a => Due(e, n, a)
        }
    }

    function Fle(t, e, n, r) {
        const {
            modifiers: s,
            pluralRules: i,
            messageResolver: a,
            fallbackLocale: c,
            fallbackWarn: l,
            missingWarn: h,
            fallbackContext: d
        } = t, g = {
            locale: e,
            modifiers: s,
            pluralRules: i,
            messages: v => {
                let b = a(n, v);
                if (b == null && d) {
                    const [, , T] = MC(d, v, e, c, l, h);
                    b = a(T, v)
                }
                if (Me(b)) {
                    let T = !1;
                    const w = DC(t, v, e, b, v, () => {
                        T = !0
                    });
                    return T ? h3 : w
                } else return _a(b) ? b : h3
            }
        };
        return t.processor && (g.processor = t.processor), r.list && (g.list = r.list), r.named && (g.named = r.named), kn(r.plural) && (g.pluralIndex = r.plural), g
    }

    function d3(t, ...e) {
        const {
            datetimeFormats: n,
            unresolving: r,
            fallbackLocale: s,
            onWarn: i,
            localeFallbacker: a
        } = t, {
            __datetimeFormatters: c
        } = t, [l, h, d, p] = Q1(...e), g = Ot(d.missingWarn) ? d.missingWarn : t.missingWarn;
        Ot(d.fallbackWarn) ? d.fallbackWarn : t.fallbackWarn;
        const v = !!d.part,
            b = Me(d.locale) ? d.locale : t.locale,
            T = a(t, s, b);
        if (!Me(l) || l === "") return new Intl.DateTimeFormat(b, p).format(h);
        let m = {},
            w, P = null;
        const V = "datetime format";
        for (let L = 0; L < T.length && (w = T[L], m = n[w] || {}, P = m[l], !rt(P)); L++) m0(t, l, w, g, V);
        if (!rt(P) || !Me(w)) return r ? gm : l;
        let M = `${w}__${l}`;
        pm(p) || (M = `${M}__${JSON.stringify(p)}`);
        let I = c.get(M);
        return I || (I = new Intl.DateTimeFormat(w, Hn({}, P, p)), c.set(M, I)), v ? I.formatToParts(h) : I.format(h)
    }
    const $C = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];

    function Q1(...t) {
        const [e, n, r, s] = t, i = {};
        let a = {},
            c;
        if (Me(e)) {
            const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
            if (!l) throw lc(uc.INVALID_ISO_DATE_ARGUMENT);
            const h = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
            c = new Date(h);
            try {
                c.toISOString()
            } catch {
                throw lc(uc.INVALID_ISO_DATE_ARGUMENT)
            }
        } else if (Lue(e)) {
            if (isNaN(e.getTime())) throw lc(uc.INVALID_DATE_ARGUMENT);
            c = e
        } else if (kn(e)) c = e;
        else throw lc(uc.INVALID_ARGUMENT);
        return Me(n) ? i.key = n : rt(n) && Object.keys(n).forEach(l => {
            $C.includes(l) ? a[l] = n[l] : i[l] = n[l]
        }), Me(r) ? i.locale = r : rt(r) && (a = r), rt(s) && (a = s), [i.key || "", c, i, a]
    }

    function p3(t, e, n) {
        const r = t;
        for (const s in n) {
            const i = `${e}__${s}`;
            r.__datetimeFormatters.has(i) && r.__datetimeFormatters.delete(i)
        }
    }

    function m3(t, ...e) {
        const {
            numberFormats: n,
            unresolving: r,
            fallbackLocale: s,
            onWarn: i,
            localeFallbacker: a
        } = t, {
            __numberFormatters: c
        } = t, [l, h, d, p] = J1(...e), g = Ot(d.missingWarn) ? d.missingWarn : t.missingWarn;
        Ot(d.fallbackWarn) ? d.fallbackWarn : t.fallbackWarn;
        const v = !!d.part,
            b = Me(d.locale) ? d.locale : t.locale,
            T = a(t, s, b);
        if (!Me(l) || l === "") return new Intl.NumberFormat(b, p).format(h);
        let m = {},
            w, P = null;
        const V = "number format";
        for (let L = 0; L < T.length && (w = T[L], m = n[w] || {}, P = m[l], !rt(P)); L++) m0(t, l, w, g, V);
        if (!rt(P) || !Me(w)) return r ? gm : l;
        let M = `${w}__${l}`;
        pm(p) || (M = `${M}__${JSON.stringify(p)}`);
        let I = c.get(M);
        return I || (I = new Intl.NumberFormat(w, Hn({}, P, p)), c.set(M, I)), v ? I.formatToParts(h) : I.format(h)
    }
    const LC = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];

    function J1(...t) {
        const [e, n, r, s] = t, i = {};
        let a = {};
        if (!kn(e)) throw lc(uc.INVALID_ARGUMENT);
        const c = e;
        return Me(n) ? i.key = n : rt(n) && Object.keys(n).forEach(l => {
            LC.includes(l) ? a[l] = n[l] : i[l] = n[l]
        }), Me(r) ? i.locale = r : rt(r) && (a = r), rt(s) && (a = s), [i.key || "", c, i, a]
    }

    function g3(t, e, n) {
        const r = t;
        for (const s in n) {
            const i = `${e}__${s}`;
            r.__numberFormatters.has(i) && r.__numberFormatters.delete(i)
        }
    }
    /*!
     * vue-i18n v9.2.2
     * (c) 2022 kazuya kawaguchi
     * Released under the MIT License.
     */
    const Ule = "9.2.2";
    let FC = Nt.__EXTEND_POINT__;
    const br = () => ++FC,
        Tn = {
            UNEXPECTED_RETURN_TYPE: FC,
            INVALID_ARGUMENT: br(),
            MUST_BE_CALL_SETUP_TOP: br(),
            NOT_INSLALLED: br(),
            NOT_AVAILABLE_IN_LEGACY_MODE: br(),
            REQUIRED_VALUE: br(),
            INVALID_VALUE: br(),
            CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: br(),
            NOT_INSLALLED_WITH_PROVIDE: br(),
            UNEXPECTED_ERROR: br(),
            NOT_COMPATIBLE_LEGACY_VUE_I18N: br(),
            BRIDGE_SUPPORT_VUE_2_ONLY: br(),
            MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: br(),
            NOT_AVAILABLE_COMPOSITION_IN_LEGACY: br(),
            __EXTEND_POINT__: br()
        };

    function xn(t, ...e) {
        return mm(t, null, void 0)
    }
    const ey = Fo("__transrateVNode"),
        ty = Fo("__datetimeParts"),
        ny = Fo("__numberParts"),
        UC = Fo("__setPluralRules");
    Fo("__intlifyMeta");
    const BC = Fo("__injectWithOption");

    function ry(t) {
        if (!Yt(t)) return t;
        for (const e in t)
            if (f0(t, e))
                if (!e.includes(".")) Yt(t[e]) && ry(t[e]);
                else {
                    const n = e.split("."),
                        r = n.length - 1;
                    let s = t;
                    for (let i = 0; i < r; i++) n[i] in s || (s[n[i]] = {}), s = s[n[i]];
                    s[n[r]] = t[e], delete t[e], Yt(s[n[r]]) && ry(s[n[r]])
                } return t
    }

    function _m(t, e) {
        const {
            messages: n,
            __i18n: r,
            messageResolver: s,
            flatJson: i
        } = e, a = rt(n) ? n : Kt(r) ? {} : {
            [t]: {}
        };
        if (Kt(r) && r.forEach(c => {
                if ("locale" in c && "resource" in c) {
                    const {
                        locale: l,
                        resource: h
                    } = c;
                    l ? (a[l] = a[l] || {}, sl(h, a[l])) : sl(h, a)
                } else Me(c) && sl(JSON.parse(c), a)
            }), s == null && i)
            for (const c in a) f0(a, c) && ry(a[c]);
        return a
    }
    const Ff = t => !Yt(t) || Kt(t);

    function sl(t, e) {
        if (Ff(t) || Ff(e)) throw xn(Tn.INVALID_VALUE);
        for (const n in t) f0(t, n) && (Ff(t[n]) || Ff(e[n]) ? e[n] = t[n] : sl(t[n], e[n]))
    }

    function Ble(t) {
        return t.type
    }

    function qC(t, e, n) {
        let r = Yt(e.messages) ? e.messages : {};
        "__i18nGlobal" in n && (r = _m(t.locale.value, {
            messages: r,
            __i18n: n.__i18nGlobal
        }));
        const s = Object.keys(r);
        s.length && s.forEach(i => {
            t.mergeLocaleMessage(i, r[i])
        }); {
            if (Yt(e.datetimeFormats)) {
                const i = Object.keys(e.datetimeFormats);
                i.length && i.forEach(a => {
                    t.mergeDateTimeFormat(a, e.datetimeFormats[a])
                })
            }
            if (Yt(e.numberFormats)) {
                const i = Object.keys(e.numberFormats);
                i.length && i.forEach(a => {
                    t.mergeNumberFormat(a, e.numberFormats[a])
                })
            }
        }
    }

    function _3(t) {
        return Qe(Kl, null, t, 0)
    }
    let y3 = 0;

    function v3(t) {
        return (e, n, r, s) => t(n, r, pl() || void 0, s)
    }

    function g0(t = {}, e) {
        const {
            __root: n
        } = t, r = n === void 0;
        let s = Ot(t.inheritLocale) ? t.inheritLocale : !0;
        const i = Qr(n && s ? n.locale.value : Me(t.locale) ? t.locale : ch),
            a = Qr(n && s ? n.fallbackLocale.value : Me(t.fallbackLocale) || Kt(t.fallbackLocale) || rt(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : i.value),
            c = Qr(_m(i.value, t)),
            l = Qr(rt(t.datetimeFormats) ? t.datetimeFormats : {
                [i.value]: {}
            }),
            h = Qr(rt(t.numberFormats) ? t.numberFormats : {
                [i.value]: {}
            });
        let d = n ? n.missingWarn : Ot(t.missingWarn) || Oo(t.missingWarn) ? t.missingWarn : !0,
            p = n ? n.fallbackWarn : Ot(t.fallbackWarn) || Oo(t.fallbackWarn) ? t.fallbackWarn : !0,
            g = n ? n.fallbackRoot : Ot(t.fallbackRoot) ? t.fallbackRoot : !0,
            v = !!t.fallbackFormat,
            b = _n(t.missing) ? t.missing : null,
            T = _n(t.missing) ? v3(t.missing) : null,
            m = _n(t.postTranslation) ? t.postTranslation : null,
            w = n ? n.warnHtmlMessage : Ot(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
            P = !!t.escapeParameter;
        const V = n ? n.modifiers : rt(t.modifiers) ? t.modifiers : {};
        let M = t.pluralRules || n && n.pluralRules,
            I;
        I = (() => {
            const re = {
                version: Ule,
                locale: i.value,
                fallbackLocale: a.value,
                messages: c.value,
                modifiers: V,
                pluralRules: M,
                missing: T === null ? void 0 : T,
                missingWarn: d,
                fallbackWarn: p,
                fallbackFormat: v,
                unresolving: !0,
                postTranslation: m === null ? void 0 : m,
                warnHtmlMessage: w,
                escapeParameter: P,
                messageResolver: t.messageResolver,
                __meta: {
                    framework: "vue"
                }
            };
            return re.datetimeFormats = l.value, re.numberFormats = h.value, re.__datetimeFormatters = rt(I) ? I.__datetimeFormatters : void 0, re.__numberFormatters = rt(I) ? I.__numberFormatters : void 0, Ple(re)
        })(), qu(I, i.value, a.value);

        function B() {
            return [i.value, a.value, c.value, l.value, h.value]
        }
        const q = Lr({
                get: () => i.value,
                set: re => {
                    i.value = re, I.locale = i.value
                }
            }),
            se = Lr({
                get: () => a.value,
                set: re => {
                    a.value = re, I.fallbackLocale = a.value, qu(I, i.value, re)
                }
            }),
            ce = Lr(() => c.value),
            ue = Lr(() => l.value),
            ee = Lr(() => h.value);

        function ge() {
            return _n(m) ? m : null
        }

        function G(re) {
            m = re, I.postTranslation = re
        }

        function le() {
            return b
        }

        function fe(re) {
            re !== null && (T = v3(re)), b = re, I.missing = T
        }
        const me = (re, ae, Re, De, Je, dt) => {
            B();
            let U;
            if (U = re(I), kn(U) && U === gm) {
                const [$, te] = ae();
                return n && g ? De(n) : Je($)
            } else {
                if (dt(U)) return U;
                throw xn(Tn.UNEXPECTED_RETURN_TYPE)
            }
        };

        function Te(...re) {
            return me(ae => Reflect.apply(f3, null, [ae, ...re]), () => X1(...re), "translate", ae => Reflect.apply(ae.t, ae, [...re]), ae => ae, ae => Me(ae))
        }

        function we(...re) {
            const [ae, Re, De] = re;
            if (De && !Yt(De)) throw xn(Tn.INVALID_ARGUMENT);
            return Te(ae, Re, Hn({
                resolvedMessage: !0
            }, De || {}))
        }

        function ke(...re) {
            return me(ae => Reflect.apply(d3, null, [ae, ...re]), () => Q1(...re), "datetime format", ae => Reflect.apply(ae.d, ae, [...re]), () => a3, ae => Me(ae))
        }

        function Ie(...re) {
            return me(ae => Reflect.apply(m3, null, [ae, ...re]), () => J1(...re), "number format", ae => Reflect.apply(ae.n, ae, [...re]), () => a3, ae => Me(ae))
        }

        function $e(re) {
            return re.map(ae => Me(ae) || kn(ae) || Ot(ae) ? _3(String(ae)) : ae)
        }
        const $t = {
            normalize: $e,
            interpolate: re => re,
            type: "vnode"
        };

        function qe(...re) {
            return me(ae => {
                let Re;
                const De = ae;
                try {
                    De.processor = $t, Re = Reflect.apply(f3, null, [De, ...re])
                } finally {
                    De.processor = null
                }
                return Re
            }, () => X1(...re), "translate", ae => ae[ey](...re), ae => [_3(ae)], ae => Kt(ae))
        }

        function Xe(...re) {
            return me(ae => Reflect.apply(m3, null, [ae, ...re]), () => J1(...re), "number format", ae => ae[ny](...re), () => [], ae => Me(ae) || Kt(ae))
        }

        function tt(...re) {
            return me(ae => Reflect.apply(d3, null, [ae, ...re]), () => Q1(...re), "datetime format", ae => ae[ty](...re), () => [], ae => Me(ae) || Kt(ae))
        }

        function S(re) {
            M = re, I.pluralRules = M
        }

        function k(re, ae) {
            const Re = Me(ae) ? ae : i.value,
                De = A(Re);
            return I.messageResolver(De, re) !== null
        }

        function H(re) {
            let ae = null;
            const Re = kC(I, a.value, i.value);
            for (let De = 0; De < Re.length; De++) {
                const Je = c.value[Re[De]] || {},
                    dt = I.messageResolver(Je, re);
                if (dt != null) {
                    ae = dt;
                    break
                }
            }
            return ae
        }

        function K(re) {
            const ae = H(re);
            return ae ?? (n ? n.tm(re) || {} : {})
        }

        function A(re) {
            return c.value[re] || {}
        }

        function y(re, ae) {
            c.value[re] = ae, I.messages = c.value
        }

        function E(re, ae) {
            c.value[re] = c.value[re] || {}, sl(ae, c.value[re]), I.messages = c.value
        }

        function C(re) {
            return l.value[re] || {}
        }

        function D(re, ae) {
            l.value[re] = ae, I.datetimeFormats = l.value, p3(I, re, ae)
        }

        function Z(re, ae) {
            l.value[re] = Hn(l.value[re] || {}, ae), I.datetimeFormats = l.value, p3(I, re, ae)
        }

        function oe(re) {
            return h.value[re] || {}
        }

        function pe(re, ae) {
            h.value[re] = ae, I.numberFormats = h.value, g3(I, re, ae)
        }

        function _e(re, ae) {
            h.value[re] = Hn(h.value[re] || {}, ae), I.numberFormats = h.value, g3(I, re, ae)
        }
        y3++, n && z1 && (pa(n.locale, re => {
            s && (i.value = re, I.locale = re, qu(I, i.value, a.value))
        }), pa(n.fallbackLocale, re => {
            s && (a.value = re, I.fallbackLocale = re, qu(I, i.value, a.value))
        }));
        const he = {
            id: y3,
            locale: q,
            fallbackLocale: se,
            get inheritLocale() {
                return s
            },
            set inheritLocale(re) {
                s = re, re && n && (i.value = n.locale.value, a.value = n.fallbackLocale.value, qu(I, i.value, a.value))
            },
            get availableLocales() {
                return Object.keys(c.value).sort()
            },
            messages: ce,
            get modifiers() {
                return V
            },
            get pluralRules() {
                return M || {}
            },
            get isGlobal() {
                return r
            },
            get missingWarn() {
                return d
            },
            set missingWarn(re) {
                d = re, I.missingWarn = d
            },
            get fallbackWarn() {
                return p
            },
            set fallbackWarn(re) {
                p = re, I.fallbackWarn = p
            },
            get fallbackRoot() {
                return g
            },
            set fallbackRoot(re) {
                g = re
            },
            get fallbackFormat() {
                return v
            },
            set fallbackFormat(re) {
                v = re, I.fallbackFormat = v
            },
            get warnHtmlMessage() {
                return w
            },
            set warnHtmlMessage(re) {
                w = re, I.warnHtmlMessage = re
            },
            get escapeParameter() {
                return P
            },
            set escapeParameter(re) {
                P = re, I.escapeParameter = re
            },
            t: Te,
            getLocaleMessage: A,
            setLocaleMessage: y,
            mergeLocaleMessage: E,
            getPostTranslationHandler: ge,
            setPostTranslationHandler: G,
            getMissingHandler: le,
            setMissingHandler: fe,
            [UC]: S
        };
        return he.datetimeFormats = ue, he.numberFormats = ee, he.rt = we, he.te = k, he.tm = K, he.d = ke, he.n = Ie, he.getDateTimeFormat = C, he.setDateTimeFormat = D, he.mergeDateTimeFormat = Z, he.getNumberFormat = oe, he.setNumberFormat = pe, he.mergeNumberFormat = _e, he[BC] = t.__injectWithOption, he[ey] = qe, he[ty] = tt, he[ny] = Xe, he
    }

    function qle(t) {
        const e = Me(t.locale) ? t.locale : ch,
            n = Me(t.fallbackLocale) || Kt(t.fallbackLocale) || rt(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : e,
            r = _n(t.missing) ? t.missing : void 0,
            s = Ot(t.silentTranslationWarn) || Oo(t.silentTranslationWarn) ? !t.silentTranslationWarn : !0,
            i = Ot(t.silentFallbackWarn) || Oo(t.silentFallbackWarn) ? !t.silentFallbackWarn : !0,
            a = Ot(t.fallbackRoot) ? t.fallbackRoot : !0,
            c = !!t.formatFallbackMessages,
            l = rt(t.modifiers) ? t.modifiers : {},
            h = t.pluralizationRules,
            d = _n(t.postTranslation) ? t.postTranslation : void 0,
            p = Me(t.warnHtmlInMessage) ? t.warnHtmlInMessage !== "off" : !0,
            g = !!t.escapeParameterHtml,
            v = Ot(t.sync) ? t.sync : !0;
        let b = t.messages;
        if (rt(t.sharedMessages)) {
            const I = t.sharedMessages;
            b = Object.keys(I).reduce((B, q) => {
                const se = B[q] || (B[q] = {});
                return Hn(se, I[q]), B
            }, b || {})
        }
        const {
            __i18n: T,
            __root: m,
            __injectWithOption: w
        } = t, P = t.datetimeFormats, V = t.numberFormats, M = t.flatJson;
        return {
            locale: e,
            fallbackLocale: n,
            messages: b,
            flatJson: M,
            datetimeFormats: P,
            numberFormats: V,
            missing: r,
            missingWarn: s,
            fallbackWarn: i,
            fallbackRoot: a,
            fallbackFormat: c,
            modifiers: l,
            pluralRules: h,
            postTranslation: d,
            warnHtmlMessage: p,
            escapeParameter: g,
            messageResolver: t.messageResolver,
            inheritLocale: v,
            __i18n: T,
            __root: m,
            __injectWithOption: w
        }
    }

    function sy(t = {}, e) {
        {
            const n = g0(qle(t)),
                r = {
                    id: n.id,
                    get locale() {
                        return n.locale.value
                    },
                    set locale(s) {
                        n.locale.value = s
                    },
                    get fallbackLocale() {
                        return n.fallbackLocale.value
                    },
                    set fallbackLocale(s) {
                        n.fallbackLocale.value = s
                    },
                    get messages() {
                        return n.messages.value
                    },
                    get datetimeFormats() {
                        return n.datetimeFormats.value
                    },
                    get numberFormats() {
                        return n.numberFormats.value
                    },
                    get availableLocales() {
                        return n.availableLocales
                    },
                    get formatter() {
                        return {
                            interpolate() {
                                return []
                            }
                        }
                    },
                    set formatter(s) {},
                    get missing() {
                        return n.getMissingHandler()
                    },
                    set missing(s) {
                        n.setMissingHandler(s)
                    },
                    get silentTranslationWarn() {
                        return Ot(n.missingWarn) ? !n.missingWarn : n.missingWarn
                    },
                    set silentTranslationWarn(s) {
                        n.missingWarn = Ot(s) ? !s : s
                    },
                    get silentFallbackWarn() {
                        return Ot(n.fallbackWarn) ? !n.fallbackWarn : n.fallbackWarn
                    },
                    set silentFallbackWarn(s) {
                        n.fallbackWarn = Ot(s) ? !s : s
                    },
                    get modifiers() {
                        return n.modifiers
                    },
                    get formatFallbackMessages() {
                        return n.fallbackFormat
                    },
                    set formatFallbackMessages(s) {
                        n.fallbackFormat = s
                    },
                    get postTranslation() {
                        return n.getPostTranslationHandler()
                    },
                    set postTranslation(s) {
                        n.setPostTranslationHandler(s)
                    },
                    get sync() {
                        return n.inheritLocale
                    },
                    set sync(s) {
                        n.inheritLocale = s
                    },
                    get warnHtmlInMessage() {
                        return n.warnHtmlMessage ? "warn" : "off"
                    },
                    set warnHtmlInMessage(s) {
                        n.warnHtmlMessage = s !== "off"
                    },
                    get escapeParameterHtml() {
                        return n.escapeParameter
                    },
                    set escapeParameterHtml(s) {
                        n.escapeParameter = s
                    },
                    get preserveDirectiveContent() {
                        return !0
                    },
                    set preserveDirectiveContent(s) {},
                    get pluralizationRules() {
                        return n.pluralRules || {}
                    },
                    __composer: n,
                    t(...s) {
                        const [i, a, c] = s, l = {};
                        let h = null,
                            d = null;
                        if (!Me(i)) throw xn(Tn.INVALID_ARGUMENT);
                        const p = i;
                        return Me(a) ? l.locale = a : Kt(a) ? h = a : rt(a) && (d = a), Kt(c) ? h = c : rt(c) && (d = c), Reflect.apply(n.t, n, [p, h || d || {}, l])
                    },
                    rt(...s) {
                        return Reflect.apply(n.rt, n, [...s])
                    },
                    tc(...s) {
                        const [i, a, c] = s, l = {
                            plural: 1
                        };
                        let h = null,
                            d = null;
                        if (!Me(i)) throw xn(Tn.INVALID_ARGUMENT);
                        const p = i;
                        return Me(a) ? l.locale = a : kn(a) ? l.plural = a : Kt(a) ? h = a : rt(a) && (d = a), Me(c) ? l.locale = c : Kt(c) ? h = c : rt(c) && (d = c), Reflect.apply(n.t, n, [p, h || d || {}, l])
                    },
                    te(s, i) {
                        return n.te(s, i)
                    },
                    tm(s) {
                        return n.tm(s)
                    },
                    getLocaleMessage(s) {
                        return n.getLocaleMessage(s)
                    },
                    setLocaleMessage(s, i) {
                        n.setLocaleMessage(s, i)
                    },
                    mergeLocaleMessage(s, i) {
                        n.mergeLocaleMessage(s, i)
                    },
                    d(...s) {
                        return Reflect.apply(n.d, n, [...s])
                    },
                    getDateTimeFormat(s) {
                        return n.getDateTimeFormat(s)
                    },
                    setDateTimeFormat(s, i) {
                        n.setDateTimeFormat(s, i)
                    },
                    mergeDateTimeFormat(s, i) {
                        n.mergeDateTimeFormat(s, i)
                    },
                    n(...s) {
                        return Reflect.apply(n.n, n, [...s])
                    },
                    getNumberFormat(s) {
                        return n.getNumberFormat(s)
                    },
                    setNumberFormat(s, i) {
                        n.setNumberFormat(s, i)
                    },
                    mergeNumberFormat(s, i) {
                        n.mergeNumberFormat(s, i)
                    },
                    getChoiceIndex(s, i) {
                        return -1
                    },
                    __onComponentInstanceCreated(s) {
                        const {
                            componentInstanceCreatedListener: i
                        } = t;
                        i && i(s, r)
                    }
                };
            return r
        }
    }
    const _0 = {
        tag: {
            type: [String, Object]
        },
        locale: {
            type: String
        },
        scope: {
            type: String,
            validator: t => t === "parent" || t === "global",
            default: "parent"
        },
        i18n: {
            type: Object
        }
    };

    function Vle({
        slots: t
    }, e) {
        return e.length === 1 && e[0] === "default" ? (t.default ? t.default() : []).reduce((r, s) => r = [...r, ...Kt(s.children) ? s.children : [s]], []) : e.reduce((n, r) => {
            const s = t[r];
            return s && (n[r] = s()), n
        }, {})
    }

    function VC(t) {
        return St
    }
    const b3 = {
        name: "i18n-t",
        props: Hn({
            keypath: {
                type: String,
                required: !0
            },
            plural: {
                type: [Number, String],
                validator: t => kn(t) || !isNaN(t)
            }
        }, _0),
        setup(t, e) {
            const {
                slots: n,
                attrs: r
            } = e, s = t.i18n || y0({
                useScope: t.scope,
                __useComponent: !0
            });
            return () => {
                const i = Object.keys(n).filter(p => p !== "_"),
                    a = {};
                t.locale && (a.locale = t.locale), t.plural !== void 0 && (a.plural = Me(t.plural) ? +t.plural : t.plural);
                const c = Vle(e, i),
                    l = s[ey](t.keypath, c, a),
                    h = Hn({}, r),
                    d = Me(t.tag) || Yt(t.tag) ? t.tag : VC();
                return Ky(d, h, l)
            }
        }
    };

    function jle(t) {
        return Kt(t) && !Me(t[0])
    }

    function jC(t, e, n, r) {
        const {
            slots: s,
            attrs: i
        } = e;
        return () => {
            const a = {
                part: !0
            };
            let c = {};
            t.locale && (a.locale = t.locale), Me(t.format) ? a.key = t.format : Yt(t.format) && (Me(t.format.key) && (a.key = t.format.key), c = Object.keys(t.format).reduce((g, v) => n.includes(v) ? Hn({}, g, {
                [v]: t.format[v]
            }) : g, {}));
            const l = r(t.value, a, c);
            let h = [a.key];
            Kt(l) ? h = l.map((g, v) => {
                const b = s[g.type],
                    T = b ? b({
                        [g.type]: g.value,
                        index: v,
                        parts: l
                    }) : [g.value];
                return jle(T) && (T[0].key = `${g.type}-${v}`), T
            }) : Me(l) && (h = [l]);
            const d = Hn({}, i),
                p = Me(t.tag) || Yt(t.tag) ? t.tag : VC();
            return Ky(p, d, h)
        }
    }
    const E3 = {
            name: "i18n-n",
            props: Hn({
                value: {
                    type: Number,
                    required: !0
                },
                format: {
                    type: [String, Object]
                }
            }, _0),
            setup(t, e) {
                const n = t.i18n || y0({
                    useScope: "parent",
                    __useComponent: !0
                });
                return jC(t, e, LC, (...r) => n[ny](...r))
            }
        },
        S3 = {
            name: "i18n-d",
            props: Hn({
                value: {
                    type: [Number, Date],
                    required: !0
                },
                format: {
                    type: [String, Object]
                }
            }, _0),
            setup(t, e) {
                const n = t.i18n || y0({
                    useScope: "parent",
                    __useComponent: !0
                });
                return jC(t, e, $C, (...r) => n[ty](...r))
            }
        };

    function Gle(t, e) {
        const n = t;
        if (t.mode === "composition") return n.__getInstance(e) || t.global; {
            const r = n.__getInstance(e);
            return r != null ? r.__composer : t.global.__composer
        }
    }

    function Wle(t) {
        const e = a => {
            const {
                instance: c,
                modifiers: l,
                value: h
            } = a;
            if (!c || !c.$) throw xn(Tn.UNEXPECTED_ERROR);
            const d = Gle(t, c.$),
                p = T3(h);
            return [Reflect.apply(d.t, d, [...w3(p)]), d]
        };
        return {
            created: (a, c) => {
                const [l, h] = e(c);
                z1 && t.global === h && (a.__i18nWatcher = pa(h.locale, () => {
                    c.instance && c.instance.$forceUpdate()
                })), a.__composer = h, a.textContent = l
            },
            unmounted: a => {
                z1 && a.__i18nWatcher && (a.__i18nWatcher(), a.__i18nWatcher = void 0, delete a.__i18nWatcher), a.__composer && (a.__composer = void 0, delete a.__composer)
            },
            beforeUpdate: (a, {
                value: c
            }) => {
                if (a.__composer) {
                    const l = a.__composer,
                        h = T3(c);
                    a.textContent = Reflect.apply(l.t, l, [...w3(h)])
                }
            },
            getSSRProps: a => {
                const [c] = e(a);
                return {
                    textContent: c
                }
            }
        }
    }

    function T3(t) {
        if (Me(t)) return {
            path: t
        };
        if (rt(t)) {
            if (!("path" in t)) throw xn(Tn.REQUIRED_VALUE, "path");
            return t
        } else throw xn(Tn.INVALID_VALUE)
    }

    function w3(t) {
        const {
            path: e,
            locale: n,
            args: r,
            choice: s,
            plural: i
        } = t, a = {}, c = r || {};
        return Me(n) && (a.locale = n), kn(s) && (a.plural = s), kn(i) && (a.plural = i), [e, c, a]
    }

    function Hle(t, e, ...n) {
        const r = rt(n[0]) ? n[0] : {},
            s = !!r.useI18nComponentName;
        (Ot(r.globalInstall) ? r.globalInstall : !0) && (t.component(s ? "i18n" : b3.name, b3), t.component(E3.name, E3), t.component(S3.name, S3)), t.directive("t", Wle(e))
    }

    function Kle(t, e, n) {
        return {
            beforeCreate() {
                const r = pl();
                if (!r) throw xn(Tn.UNEXPECTED_ERROR);
                const s = this.$options;
                if (s.i18n) {
                    const i = s.i18n;
                    s.__i18n && (i.__i18n = s.__i18n), i.__root = e, this === this.$root ? this.$i18n = O3(t, i) : (i.__injectWithOption = !0, this.$i18n = sy(i))
                } else s.__i18n ? this === this.$root ? this.$i18n = O3(t, s) : this.$i18n = sy({
                    __i18n: s.__i18n,
                    __injectWithOption: !0,
                    __root: e
                }) : this.$i18n = t;
                s.__i18nGlobal && qC(e, s, s), t.__onComponentInstanceCreated(this.$i18n), n.__setInstance(r, this.$i18n), this.$t = (...i) => this.$i18n.t(...i), this.$rt = (...i) => this.$i18n.rt(...i), this.$tc = (...i) => this.$i18n.tc(...i), this.$te = (i, a) => this.$i18n.te(i, a), this.$d = (...i) => this.$i18n.d(...i), this.$n = (...i) => this.$i18n.n(...i), this.$tm = i => this.$i18n.tm(i)
            },
            mounted() {},
            unmounted() {
                const r = pl();
                if (!r) throw xn(Tn.UNEXPECTED_ERROR);
                delete this.$t, delete this.$rt, delete this.$tc, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, n.__deleteInstance(r), delete this.$i18n
            }
        }
    }

    function O3(t, e) {
        t.locale = e.locale || t.locale, t.fallbackLocale = e.fallbackLocale || t.fallbackLocale, t.missing = e.missing || t.missing, t.silentTranslationWarn = e.silentTranslationWarn || t.silentFallbackWarn, t.silentFallbackWarn = e.silentFallbackWarn || t.silentFallbackWarn, t.formatFallbackMessages = e.formatFallbackMessages || t.formatFallbackMessages, t.postTranslation = e.postTranslation || t.postTranslation, t.warnHtmlInMessage = e.warnHtmlInMessage || t.warnHtmlInMessage, t.escapeParameterHtml = e.escapeParameterHtml || t.escapeParameterHtml, t.sync = e.sync || t.sync, t.__composer[UC](e.pluralizationRules || t.pluralizationRules);
        const n = _m(t.locale, {
            messages: e.messages,
            __i18n: e.__i18n
        });
        return Object.keys(n).forEach(r => t.mergeLocaleMessage(r, n[r])), e.datetimeFormats && Object.keys(e.datetimeFormats).forEach(r => t.mergeDateTimeFormat(r, e.datetimeFormats[r])), e.numberFormats && Object.keys(e.numberFormats).forEach(r => t.mergeNumberFormat(r, e.numberFormats[r])), t
    }
    const Yle = Fo("global-vue-i18n");

    function zle(t = {}, e) {
        const n = Ot(t.legacy) ? t.legacy : !0,
            r = Ot(t.globalInjection) ? t.globalInjection : !0,
            s = n ? !!t.allowComposition : !0,
            i = new Map,
            [a, c] = Zle(t, n),
            l = Fo("");

        function h(g) {
            return i.get(g) || null
        }

        function d(g, v) {
            i.set(g, v)
        }

        function p(g) {
            i.delete(g)
        } {
            const g = {
                get mode() {
                    return n ? "legacy" : "composition"
                },
                get allowComposition() {
                    return s
                },
                async install(v, ...b) {
                    v.__VUE_I18N_SYMBOL__ = l, v.provide(v.__VUE_I18N_SYMBOL__, g), !n && r && ihe(v, g.global), Hle(v, g, ...b), n && v.mixin(Kle(c, c.__composer, g));
                    const T = v.unmount;
                    v.unmount = () => {
                        g.dispose(), T()
                    }
                },
                get global() {
                    return c
                },
                dispose() {
                    a.stop()
                },
                __instances: i,
                __getInstance: h,
                __setInstance: d,
                __deleteInstance: p
            };
            return g
        }
    }

    function y0(t = {}) {
        const e = pl();
        if (e == null) throw xn(Tn.MUST_BE_CALL_SETUP_TOP);
        if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__) throw xn(Tn.NOT_INSLALLED);
        const n = Xle(e),
            r = Jle(n),
            s = Ble(e),
            i = Qle(t, s);
        if (n.mode === "legacy" && !t.__useComponent) {
            if (!n.allowComposition) throw xn(Tn.NOT_AVAILABLE_IN_LEGACY_MODE);
            return nhe(e, i, r, t)
        }
        if (i === "global") return qC(r, t, s), r;
        if (i === "parent") {
            let l = ehe(n, e, t.__useComponent);
            return l == null && (l = r), l
        }
        const a = n;
        let c = a.__getInstance(e);
        if (c == null) {
            const l = Hn({}, t);
            "__i18n" in s && (l.__i18n = s.__i18n), r && (l.__root = r), c = g0(l), the(a, e), a.__setInstance(e, c)
        }
        return c
    }

    function Zle(t, e, n) {
        const r = IR(); {
            const s = e ? r.run(() => sy(t)) : r.run(() => g0(t));
            if (s == null) throw xn(Tn.UNEXPECTED_ERROR);
            return [r, s]
        }
    }

    function Xle(t) {
        {
            const e = mo(t.isCE ? Yle : t.appContext.app.__VUE_I18N_SYMBOL__);
            if (!e) throw xn(t.isCE ? Tn.NOT_INSLALLED_WITH_PROVIDE : Tn.UNEXPECTED_ERROR);
            return e
        }
    }

    function Qle(t, e) {
        return pm(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local"
    }

    function Jle(t) {
        return t.mode === "composition" ? t.global : t.global.__composer
    }

    function ehe(t, e, n = !1) {
        let r = null;
        const s = e.root;
        let i = e.parent;
        for (; i != null;) {
            const a = t;
            if (t.mode === "composition") r = a.__getInstance(i);
            else {
                const c = a.__getInstance(i);
                c != null && (r = c.__composer, n && r && !r[BC] && (r = null))
            }
            if (r != null || s === i) break;
            i = i.parent
        }
        return r
    }

    function the(t, e, n) {
        Fy(() => {}, e), Uy(() => {
            t.__deleteInstance(e)
        }, e)
    }

    function nhe(t, e, n, r = {}) {
        const s = e === "local",
            i = sM(null);
        if (s && t.proxy && !(t.proxy.$options.i18n || t.proxy.$options.__i18n)) throw xn(Tn.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
        const a = Ot(r.inheritLocale) ? r.inheritLocale : !0,
            c = Qr(s && a ? n.locale.value : Me(r.locale) ? r.locale : ch),
            l = Qr(s && a ? n.fallbackLocale.value : Me(r.fallbackLocale) || Kt(r.fallbackLocale) || rt(r.fallbackLocale) || r.fallbackLocale === !1 ? r.fallbackLocale : c.value),
            h = Qr(_m(c.value, r)),
            d = Qr(rt(r.datetimeFormats) ? r.datetimeFormats : {
                [c.value]: {}
            }),
            p = Qr(rt(r.numberFormats) ? r.numberFormats : {
                [c.value]: {}
            }),
            g = s ? n.missingWarn : Ot(r.missingWarn) || Oo(r.missingWarn) ? r.missingWarn : !0,
            v = s ? n.fallbackWarn : Ot(r.fallbackWarn) || Oo(r.fallbackWarn) ? r.fallbackWarn : !0,
            b = s ? n.fallbackRoot : Ot(r.fallbackRoot) ? r.fallbackRoot : !0,
            T = !!r.fallbackFormat,
            m = _n(r.missing) ? r.missing : null,
            w = _n(r.postTranslation) ? r.postTranslation : null,
            P = s ? n.warnHtmlMessage : Ot(r.warnHtmlMessage) ? r.warnHtmlMessage : !0,
            V = !!r.escapeParameter,
            M = s ? n.modifiers : rt(r.modifiers) ? r.modifiers : {},
            I = r.pluralRules || s && n.pluralRules;

        function L() {
            return [c.value, l.value, h.value, d.value, p.value]
        }
        const B = Lr({
                get: () => i.value ? i.value.locale.value : c.value,
                set: E => {
                    i.value && (i.value.locale.value = E), c.value = E
                }
            }),
            q = Lr({
                get: () => i.value ? i.value.fallbackLocale.value : l.value,
                set: E => {
                    i.value && (i.value.fallbackLocale.value = E), l.value = E
                }
            }),
            se = Lr(() => i.value ? i.value.messages.value : h.value),
            ce = Lr(() => d.value),
            ue = Lr(() => p.value);

        function ee() {
            return i.value ? i.value.getPostTranslationHandler() : w
        }

        function ge(E) {
            i.value && i.value.setPostTranslationHandler(E)
        }

        function G() {
            return i.value ? i.value.getMissingHandler() : m
        }

        function le(E) {
            i.value && i.value.setMissingHandler(E)
        }

        function fe(E) {
            return L(), E()
        }

        function me(...E) {
            return i.value ? fe(() => Reflect.apply(i.value.t, null, [...E])) : fe(() => "")
        }

        function Te(...E) {
            return i.value ? Reflect.apply(i.value.rt, null, [...E]) : ""
        }

        function we(...E) {
            return i.value ? fe(() => Reflect.apply(i.value.d, null, [...E])) : fe(() => "")
        }

        function ke(...E) {
            return i.value ? fe(() => Reflect.apply(i.value.n, null, [...E])) : fe(() => "")
        }

        function Ie(E) {
            return i.value ? i.value.tm(E) : {}
        }

        function $e(E, C) {
            return i.value ? i.value.te(E, C) : !1
        }

        function At(E) {
            return i.value ? i.value.getLocaleMessage(E) : {}
        }

        function $t(E, C) {
            i.value && (i.value.setLocaleMessage(E, C), h.value[E] = C)
        }

        function qe(E, C) {
            i.value && i.value.mergeLocaleMessage(E, C)
        }

        function Xe(E) {
            return i.value ? i.value.getDateTimeFormat(E) : {}
        }

        function tt(E, C) {
            i.value && (i.value.setDateTimeFormat(E, C), d.value[E] = C)
        }

        function S(E, C) {
            i.value && i.value.mergeDateTimeFormat(E, C)
        }

        function k(E) {
            return i.value ? i.value.getNumberFormat(E) : {}
        }

        function H(E, C) {
            i.value && (i.value.setNumberFormat(E, C), p.value[E] = C)
        }

        function K(E, C) {
            i.value && i.value.mergeNumberFormat(E, C)
        }
        const A = {
            get id() {
                return i.value ? i.value.id : -1
            },
            locale: B,
            fallbackLocale: q,
            messages: se,
            datetimeFormats: ce,
            numberFormats: ue,
            get inheritLocale() {
                return i.value ? i.value.inheritLocale : a
            },
            set inheritLocale(E) {
                i.value && (i.value.inheritLocale = E)
            },
            get availableLocales() {
                return i.value ? i.value.availableLocales : Object.keys(h.value)
            },
            get modifiers() {
                return i.value ? i.value.modifiers : M
            },
            get pluralRules() {
                return i.value ? i.value.pluralRules : I
            },
            get isGlobal() {
                return i.value ? i.value.isGlobal : !1
            },
            get missingWarn() {
                return i.value ? i.value.missingWarn : g
            },
            set missingWarn(E) {
                i.value && (i.value.missingWarn = E)
            },
            get fallbackWarn() {
                return i.value ? i.value.fallbackWarn : v
            },
            set fallbackWarn(E) {
                i.value && (i.value.missingWarn = E)
            },
            get fallbackRoot() {
                return i.value ? i.value.fallbackRoot : b
            },
            set fallbackRoot(E) {
                i.value && (i.value.fallbackRoot = E)
            },
            get fallbackFormat() {
                return i.value ? i.value.fallbackFormat : T
            },
            set fallbackFormat(E) {
                i.value && (i.value.fallbackFormat = E)
            },
            get warnHtmlMessage() {
                return i.value ? i.value.warnHtmlMessage : P
            },
            set warnHtmlMessage(E) {
                i.value && (i.value.warnHtmlMessage = E)
            },
            get escapeParameter() {
                return i.value ? i.value.escapeParameter : V
            },
            set escapeParameter(E) {
                i.value && (i.value.escapeParameter = E)
            },
            t: me,
            getPostTranslationHandler: ee,
            setPostTranslationHandler: ge,
            getMissingHandler: G,
            setMissingHandler: le,
            rt: Te,
            d: we,
            n: ke,
            tm: Ie,
            te: $e,
            getLocaleMessage: At,
            setLocaleMessage: $t,
            mergeLocaleMessage: qe,
            getDateTimeFormat: Xe,
            setDateTimeFormat: tt,
            mergeDateTimeFormat: S,
            getNumberFormat: k,
            setNumberFormat: H,
            mergeNumberFormat: K
        };

        function y(E) {
            E.locale.value = c.value, E.fallbackLocale.value = l.value, Object.keys(h.value).forEach(C => {
                E.mergeLocaleMessage(C, h.value[C])
            }), Object.keys(d.value).forEach(C => {
                E.mergeDateTimeFormat(C, d.value[C])
            }), Object.keys(p.value).forEach(C => {
                E.mergeNumberFormat(C, p.value[C])
            }), E.escapeParameter = V, E.fallbackFormat = T, E.fallbackRoot = b, E.fallbackWarn = v, E.missingWarn = g, E.warnHtmlMessage = P
        }
        return B5(() => {
            if (t.proxy == null || t.proxy.$i18n == null) throw xn(Tn.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
            const E = i.value = t.proxy.$i18n.__composer;
            e === "global" ? (c.value = E.locale.value, l.value = E.fallbackLocale.value, h.value = E.messages.value, d.value = E.datetimeFormats.value, p.value = E.numberFormats.value) : s && y(E)
        }), A
    }
    const rhe = ["locale", "fallbackLocale", "availableLocales"],
        she = ["t", "rt", "d", "n", "tm"];

    function ihe(t, e) {
        const n = Object.create(null);
        rhe.forEach(r => {
            const s = Object.getOwnPropertyDescriptor(e, r);
            if (!s) throw xn(Tn.UNEXPECTED_ERROR);
            const i = qn(s.value) ? {
                get() {
                    return s.value.value
                },
                set(a) {
                    s.value.value = a
                }
            } : {
                get() {
                    return s.get && s.get()
                }
            };
            Object.defineProperty(n, r, i)
        }), t.config.globalProperties.$i18n = n, she.forEach(r => {
            const s = Object.getOwnPropertyDescriptor(e, r);
            if (!s || !s.value) throw xn(Tn.UNEXPECTED_ERROR);
            Object.defineProperty(t.config.globalProperties, `$${r}`, s)
        })
    }
    kle(Mle);
    Nle(mle);
    xle(kC);
    const ohe = yt({
            data() {
                return {
                    isVisible: !1,
                    options: null,
                    timeout: null
                }
            },
            beforeMount() {
                this.$registerToast(this)
            },
            methods: {
                show(t) {
                    this.isVisible = !0, this.options = t, this.timeout && (window.clearTimeout(this.timeout), this.timeout = null), t.duration && (this.timeout = window.setTimeout(() => {
                        this.hide()
                    }, t.duration))
                },
                hide() {
                    this.isVisible = !1, this.options = null, this.timeout && (window.clearTimeout(this.timeout), this.timeout = null)
                }
            }
        }),
        ahe = "main/pp10/nopus-opus/assets/c8afd972.svg",
        che = {
            class: "constrain"
        },
        uhe = {
            class: "text"
        },
        lhe = {
            class: "subtext"
        },
        hhe = {
            key: 0,
            class: "warning"
        },
        fhe = {
            key: 1,
            class: "spinner"
        },
        dhe = {
            key: 2,
            class: "pause"
        };

    function phe(t, e, n, r, s, i) {
        return Y(), Vt(xs, {
            name: "toast-transition"
        }, {
            default: cs(() => [t.isVisible && t.options ? (Y(), X("div", {
                key: 0,
                class: mt([t.options.type, "jbg toast"])
            }, [W("div", che, [W("img", {
                class: "close",
                alt: "close",
                src: ahe,
                onClick: e[0] || (e[0] = (...a) => t.hide && t.hide(...a)),
                onKeydown: e[1] || (e[1] = Yy((...a) => t.hide && t.hide(...a), ["esc"]))
            }, null, 32), W("p", uhe, _t(t.options.text), 1), W("p", lhe, _t(t.options.subtext), 1), t.options.warning ? (Y(), X("p", hhe, _t(t.options.warning), 1)) : Ve("", !0), t.options.type === "reconnecting" || t.options.type === "paused" ? (Y(), X("div", fhe)) : Ve("", !0), t.options.type === "paused" ? (Y(), X("div", dhe)) : Ve("", !0)])], 2)) : Ve("", !0)]),
            _: 1
        })
    }
    const mhe = ct(ohe, [
            ["render", phe],
            ["__scopeId", "data-v-6d2a2aa3"]
        ]),
        ghe = {
            install: t => {
                if (t.config.globalProperties.$showToast) return;
                let e;
                const n = i => {
                        if (!e) throw new Error("No ToastComponent is registered to show");
                        e.show(i)
                    },
                    r = () => {
                        if (!e) throw new Error("No ToastComponent is registered to hide");
                        e.hide()
                    },
                    s = i => {
                        e = i
                    };
                t.component("Toast", mhe), t.config.globalProperties.$showToast = n, t.config.globalProperties.$hideToast = r, t.config.globalProperties.$registerToast = s
            }
        },
        _he = yt({
            props: {
                options: Object,
                mainView: Object
            },
            setup() {
                return {
                    fatalError: mo(ih.fatal.error)
                }
            },
            data() {
                return {
                    isKicked: !1
                }
            },
            computed: {
                ecast() {
                    return this.$ecast
                },
                ecastValues() {
                    return this.$ecastValues ? this.$ecastValues : null
                },
                classes() {
                    return [`locale-${this.$i18n.locale}`]
                },
                shouldShowFatal() {
                    var t;
                    return ((t = this.fatalError) == null ? void 0 : t.hasCrashed) ?? !1
                }
            },
            watch: {
                "ecastValues.hostIsPaused": function(e) {
                    e ? this.$showToast({
                        type: "paused",
                        text: this.$t("TOAST.PAUSED.TEXT"),
                        subtext: this.$t("TOAST.PAUSED.SUBTEXT")
                    }) : this.$hideToast()
                }
            },
            beforeMount() {
                this.$ecast.on("connection", t => {
                    this.onConnection(t)
                }), this.$ecast.on("client/connected", t => {
                    this.onClientConnected(t)
                }), this.$ecast.on("client/disconnected", t => {
                    this.onClientDisconnected(t)
                }), this.$ecast.on("room/exit", () => {
                    this.onRoomExit()
                }), this.$ecast.on("client/kicked", () => {
                    this.onClientKicked()
                }), this.$ecast.on("socketClose", () => {
                    this.onSocketClose()
                })
            },
            beforeUnmount() {},
            methods: {
                onConnection(t) {
                    switch (t.status) {
                        case "waiting":
                        case "connecting":
                            this.$showToast({
                                type: "reconnecting",
                                text: this.$t("TOAST.RECONNECTING.CONTROLLER.TEXT"),
                                subtext: this.$t("TOAST.RECONNECTING.CONTROLLER.SUBTEXT", {
                                    attempt: t.attempt
                                })
                            });
                            break;
                        case "connected":
                            this.$showToast({
                                type: "generic",
                                text: this.$t("TOAST.RECONNECTED.TEXT"),
                                subtext: this.$t("TOAST.RECONNECTED.SUBTEXT"),
                                duration: 1500
                            });
                            break
                    }
                },
                onClientConnected(t) {
                    t.role === "host" && t.reconnect && this.$showToast({
                        type: "generic",
                        text: this.$t("TOAST.RECONNECTED.TEXT"),
                        subtext: this.$t("TOAST.RECONNECTED.SUBTEXT"),
                        duration: 1500
                    })
                },
                onClientDisconnected(t) {
                    t.role === "host" && this.$showToast({
                        type: "reconnecting",
                        text: this.$t("TOAST.RECONNECTING.GAME.TEXT"),
                        subtext: this.$t("TOAST.RECONNECTING.GAME.SUBTEXT")
                    })
                },
                async onRoomExit() {
                    this.$hideToast(), await this.$showModal("Error", {
                        image: "moon",
                        text: this.$t("ERROR.ROOM_DISCONNECTED"),
                        subtext: this.$t("ERROR.ROOM_DESTROYED"),
                        dismissText: this.$t("ACTION.OK")
                    }), window.location.reload()
                },
                async onClientKicked() {
                    this.isKicked = !0, this.$hideToast(), await this.$showModal("Error", {
                        image: "tear",
                        text: this.$t("ERROR.ROOM_DISCONNECTED"),
                        subtext: this.$t("ERROR.PLAYER_KICKED"),
                        dismissText: this.$t("ACTION.OK")
                    }), window.location.reload()
                },
                async onSocketClose() {
                    this.isKicked || (this.$hideToast(), await this.$showModal("Error", {
                        image: "moon",
                        text: this.$t("ERROR.ROOM_DISCONNECTED"),
                        dismissText: this.$t("ACTION.OK")
                    }), window.location.reload())
                }
            }
        });

    function yhe(t, e, n, r, s, i) {
        const a = ot("Fatal"),
            c = ot("TextDescriptions"),
            l = ot("Debug"),
            h = ot("Modal"),
            d = ot("Toast");
        return t.shouldShowFatal ? (Y(), Vt(a, {
            key: 0
        })) : (Y(), X(St, {
            key: 1
        }, [Qe(c), (Y(), Vt(qy(t.mainView), Up({
            id: "game",
            class: t.classes
        }, t.ecastValues), null, 16, ["class"])), Qe(l), Qe(h), Qe(d)], 64))
    }
    const A3 = ct(_he, [
            ["render", yhe]
        ]),
        vhe = t => {
            let e;
            window.tv.register({
                connect: (n, r) => (r ? e = r.setClient(Sr.WSClient, n) : e = new Sr.WSClient(n), e.connect()),
                mount: n => {
                    var a, c, l;
                    A3.name = n.app;
                    let r = HD(A3, {
                            options: n,
                            mainView: t.MainView
                        }),
                        s;
                    (a = n.room) != null && a.locale && (s = n.room.locale), (l = (c = n.match) == null ? void 0 : c.params) != null && l.locale && (s = n.match.params.locale), vc.set(s);
                    const i = zle({
                        fallbackLocale: "en",
                        locale: vc.locale,
                        messages: vc.mergeMessages(wY, t.messages ?? {})
                    });
                    if (r.use(Tee), r.use(Oue), r.use(Jse, {
                            replayer: n.replayer,
                            client: e,
                            room: n.room
                        }), r.use(boe, {
                            wsClient: e,
                            room: n.room,
                            welcome: n.welcome
                        }), r.use(wce), r.use(i), r.use(nue, {
                            i18n: i
                        }), r.use(xue), r.use(Pue), r.use(ghe), r.use(Rue), t.plugins) {
                        const h = d => d.plugin === void 0;
                        t.plugins.forEach(d => {
                            if (h(d)) {
                                r.use(d);
                                return
                            }
                            r.use(d.plugin, ...d.options)
                        })
                    }
                    return r.mount("#app"), () => {
                        r.unmount(), r = null
                    }
                },
                info: n => ({
                    tag: n.app,
                    version: n.version,
                    type: n.type,
                    wrapper: "vue",
                    branch: n.branch
                })
            })
        },
        bhe = {
            AVATARS: {
                0: "calm light green bird with a single dark green feather on its head",
                1: "punky yellow bird with yellow feathers that look like a mohawk",
                2: "fancy teal bird with round yellow feathers on its head and tail",
                3: "sleek red bird with a pointy head and curly black tail",
                4: "tufted green bird with yellow wings",
                5: "wild magenta bird with light pink, unkempt feathers on its head",
                6: "dramatic white bird with angular black eyebrow feathers",
                7: "flamboyant purple bird with forward feathers on its head and a big curly tail",
                8: "chill brown bird with a foxy tail",
                9: "cute pink bird with a tail that looks like ice cream cones",
                10: "dorky blue bird with perfect hair",
                11: "emo pink bird with feathers brushed forward on its head"
            },
            CHANGE_AVATAR: "Change Avatar",
            LOGO: "the Dodo Re Mi logo"
        },
        Ehe = {
            CHANGE_AVATAR: "change avatar",
            SONG_DOWN: "scroll to the next song {songName}",
            SONG_UP: "scroll to the previous song {songName}",
            SELECT_SONG: "select song {songName}"
        },
        She = {
            BASS: "Bass",
            MELODY: "Melody",
            COUNTER: "Counter",
            DRUMS: "Drums",
            PERCUSSION: "Percussion",
            HARMONY: "Harmony",
            SIGNATURE: "Signature"
        },
        The = {
            WHEN: "When the screen says to",
            GET_READY: "Get Ready",
            TAP_HERE: "TAP[break][/break]HERE[break][/break][info](OR PRESS THE SPACEBAR)[/info]",
            TAP: "tap",
            SYNCED: "synced",
            SYNCING: "Syncing"
        },
        whe = {
            SHARE: "Share the music"
        },
        Ohe = {
            CONTINUOUS: "Tap and hold notes when they enter the zone below",
            DISCRETE: "Tap notes when they fill the circles below",
            RESYNC: "The game is paused. We will resync when the game is ready.",
            IN_PROGRESS: "You have joinded this song is in progress. Pause and unpause the game to resync."
        },
        Ahe = {
            SURVIVED: "Survived",
            EATEN: "Eaten"
        },
        Che = {
            VERY_EASY: "Super Easy",
            EASY: "Easy",
            MEDIUM: "Medium",
            HARD: "Hard",
            VERY_HARD: "Super Hard"
        },
        Ihe = {
            PERFECT: "perfect",
            GOOD: "good",
            OKAY: "okay"
        },
        khe = {
            BACK_TO_MENU: "Back to Game Menu",
            BEST_SCORE: "Best Score",
            CHANGE_HOST: "Change[break][/break]Host?",
            CHOOSE_HOST: "Choose New Host",
            CHOOSE_INSTRUMENT: "Choose Instrument",
            CHOOSE_SONG: "Choose Song",
            COMPLETED_PARTS: "Parts Survived",
            DIFFICULTY: "Difficulty",
            END_SESSION: "End Session",
            LANES: "Lanes",
            LOADING: "Loading",
            NEVERMIND: "Nevermind",
            NEW_SONG: "New Song",
            RETRY_SONG: "Retry Song",
            SELECT_SONG: "Select Song",
            SONG_PART: "Song Part",
            START_SONG: "Start Song",
            TEST_IT: "Test It Out",
            THANKS: "Thanks for playing",
            VOTE_SONG: "Vote for a Song",
            WAITING_FOR: "Waiting for {vipName}",
            WHAT_NEXT: "What's Next?"
        },
        Nhe = {
            WELCOME: "Welcome to Dodo Re Mi",
            SILENT: "Please turn Silent Mode OFF on your device",
            VOLUME: "Turn your volume UP",
            POWER_SAVER: "Make sure your device is NOT on Power Save Mode",
            TEST: "TEST YOUR AUDIO ",
            GO: "Let's Go"
        },
        xhe = {
            ALT: bhe,
            ARIA: Ehe,
            BEATMAPS: She,
            COUNT_IN: The,
            CREDITS: whe,
            INFO: Ohe,
            RESULTS: Ahe,
            DIFFICULTY: Che,
            QUALITY: Ihe,
            MENU: khe,
            WELCOME: Nhe
        },
        Phe = {
            AVATARS: {
                0: "oiseau calme vert clair avec une seule plume vert fonc sur sa tte",
                1: "oiseau jaune punk avec plumes jaunes faon crte",
                2: "oiseau chic bleu sarcelle avec plumes jaunes rondes sur sa tte et sa queue",
                3: "oiseau rouge au plumage soyeux avec une tte pointue et une queue noire boucle",
                4: "oiseau vert touffu avec ailes jaunes",
                5: "oiseau sauvage magenta avec plumes hirsutes rose clair sur sa tte",
                6: "oiseau blanc dramatique avec plumes noires angulaires au niveau des sourcils",
                7: "oiseau violet flamboyant avec plumes vers l'avant sur sa tte et une grande queue frise",
                8: "oiseau marron relax avec queue rousse",
                9: "oiseau rose mignon avec une queue en forme de cornet de glace",
                10: "oiseau bleu intello au plumage trs soign",
                11: "oiseau rose emo avec plumes de sa tte coiffes vers l'avant"
            },
            CHANGE_AVATAR: "Changer d'avatar",
            LOGO: "logo Dodo R Mi"
        },
        Rhe = {
            CHANGE_AVATAR: "changer d'avatar",
            SONG_DOWN: "faire dfiler jusqu' la prochaine chanson {songName}",
            SONG_UP: "faire dfiler jusqu' la chanson prcdente {songName}",
            SELECT_SONG: "choisir la chanson {songName}"
        },
        Mhe = {
            BASS: "Basse",
            MELODY: "Mlodie",
            COUNTER: "Contre",
            DRUMS: "Batterie",
            PERCUSSION: "Percussion",
            HARMONY: "Harmonie",
            SIGNATURE: "Signature"
        },
        Dhe = {
            WHEN: "Lorsque l'cran indique",
            GET_READY: "Prparez-vous",
            TAP_HERE: "TOUCHER[break][/break]ICI[break][/break][info](OU APPUYER SUR LA BARRE D'ESPACE)[/info]",
            TAP: "toucher",
            SYNCED: "synchronis",
            SYNCING: "Synchro en cours"
        },
        $he = {
            SHARE: "Partager la musique"
        },
        Lhe = {
            SURVIVED: "Survcu",
            EATEN: "Mang"
        },
        Fhe = {
            VERY_EASY: "Super facile",
            EASY: "Facile",
            MEDIUM: "Moyen",
            HARD: "Difficile",
            VERY_HARD: "Super difficile"
        },
        Uhe = {
            BACK_TO_MENU: "Retour au menu du jeu",
            BEST_SCORE: "Meilleur score",
            CHANGE_HOST: "Changer[break][/break]d'hte?",
            CHOOSE_HOST: "Choisissez un nouvel hte",
            CHOOSE_INSTRUMENT: "Choisissez un instrument",
            CHOOSE_SONG: "Choisissez une chanson",
            COMPLETED_PARTS: "Sections survcues",
            DIFFICULTY: "Difficult",
            END_SESSION: "Terminer la session",
            LANES: "Lanes",
            LOADING: "Chargement",
            NEVERMIND: "Nevermind",
            NEW_SONG: "Nouvelle chanson",
            RETRY_SONG: "Ressayer la chanson",
            SELECT_SONG: "Choisir la chanson",
            SONG_PART: "Section de la chanson",
            START_SONG: "Lancer la chanson",
            TEST_IT: "Tester",
            THANKS: "Merci d'avoir jou!",
            VOTE_SONG: "Votez pour une chanson",
            WAITING_FOR: "En attente de {vipName}",
            WHAT_NEXT: "Et ensuite?"
        },
        Bhe = {
            WELCOME: "Bienvenue dans Dodo R Mi",
            SILENT: "Veuillez dsactiver le mode silencieux sur votre appareil",
            VOLUME: "Augmentez le volume",
            POWER_SAVER: "Assurez-vous que votre appareil n'est PAS en mode conomie d'nergie",
            TEST: "TESTEZ VOTRE AUDIO ",
            GO: "C'est parti!"
        },
        qhe = {
            ALT: Phe,
            ARIA: Rhe,
            BEATMAPS: Mhe,
            COUNT_IN: Dhe,
            CREDITS: $he,
            RESULTS: Lhe,
            DIFFICULTY: Fhe,
            MENU: Uhe,
            WELCOME: Bhe
        },
        Vhe = {
            AVATARS: {
                0: "uccello calmo di colore verde chiaro con un'unica piuma verde scuro sulla testa",
                1: "uccello punk di colore giallo con piume gialle che sembrano un taglio alla moicana",
                2: "uccello splendido di colore verde acqua con piume gialle rotonde sulla testa e sulla coda",
                3: "uccello sinuoso di colore rosso con una testa a punta e una coda nera arricciata",
                4: "uccello di colore verde con un ciuffo e le ali gialle",
                5: "uccello selvatico di colore magenta con piume arruffate rosa chiaro in testa",
                6: "uccello vistoso di colore bianco con piume nere ad angolo come sopracciglia",
                7: "uccello appariscente di colore viola con piume all'ins sulla testa e una grande coda arricciata",
                8: "uccello calmo di colore marrone con una coda di volpe",
                9: "uccello carino di colore rosa con una coda che ricorda dei coni gelato",
                10: "uccello maldestro di colore blu con capelli perfetti",
                11: "uccello emo di colore rosa con piume pettinate in avanti sulla testa"
            },
            CHANGE_AVATAR: "Cambia avatar",
            LOGO: "il logo di Dodo Re Mi"
        },
        jhe = {
            CHANGE_AVATAR: "cambia avatar",
            SONG_DOWN: "scorri alla canzone successiva {songName}",
            SONG_UP: "scorri alla canzone precedente {songName}",
            SELECT_SONG: "seleziona canzone {songName}"
        },
        Ghe = {
            BASS: "Basso",
            MELODY: "Melodia",
            COUNTER: "Controcanto",
            DRUMS: "Batteria",
            PERCUSSION: "Percussioni",
            HARMONY: "Armonia",
            SIGNATURE: "Alterazione"
        },
        Whe = {
            WHEN: "Quando lo schermo dice di",
            GET_READY: "Preparati",
            TAP_HERE: "TOCCA[break][/break]QUI[break][/break][info](O PREMI LA BARRA SPAZIATRICE)[/info]",
            TAP: "tocca",
            SYNCED: "sincronizzato",
            SYNCING: "Sincronizzazione"
        },
        Hhe = {
            SHARE: "Condividi la musica"
        },
        Khe = {
            SURVIVED: "Se l' cavata",
            EATEN: " stat mangiat"
        },
        Yhe = {
            VERY_EASY: "Facilissima",
            EASY: "Facile",
            MEDIUM: "Media",
            HARD: "Difficile",
            VERY_HARD: "Difficilissima"
        },
        zhe = {
            BACK_TO_MENU: "Torna al menu di gioco",
            BEST_SCORE: "Miglior punteggio",
            CHANGE_HOST: "Cambia[break][/break]ospite?",
            CHOOSE_HOST: "Scegli un nuovo ospite",
            CHOOSE_INSTRUMENT: "Scegli strumento",
            CHOOSE_SONG: "Scegli canzone",
            COMPLETED_PARTS: "Parti sopravvissute",
            DIFFICULTY: "Difficolt",
            END_SESSION: "Termina sessione",
            LANES: "Corsie",
            LOADING: "Caricamento",
            NEVERMIND: "Non importa",
            NEW_SONG: "Nuova canzone",
            RETRY_SONG: "Riprova canzone",
            SELECT_SONG: "Seleziona canzone",
            SONG_PART: "Parte della canzone",
            START_SONG: "Avvia canzone",
            TEST_IT: "Provala",
            THANKS: "Grazie per aver scelto di giocare con noi",
            VOTE_SONG: "Vota una canzone",
            WAITING_FOR: "In attesa di {vipName}",
            WHAT_NEXT: "Che si fa dopo?"
        },
        Zhe = {
            WELCOME: "Ti diamo il benvenuto a Dodo Re Mi",
            SILENT: "Disattiva la modalit silenziosa sul dispositivo",
            VOLUME: "Alza il volume",
            POWER_SAVER: "Assicurati che il dispositivo NON sia in modalit di risparmio energetico",
            TEST: "PROVA L'AUDIO ",
            GO: "Iniziamo"
        },
        Xhe = {
            ALT: Vhe,
            ARIA: jhe,
            BEATMAPS: Ghe,
            COUNT_IN: Whe,
            CREDITS: Hhe,
            RESULTS: Khe,
            DIFFICULTY: Yhe,
            MENU: zhe,
            WELCOME: Zhe
        },
        Qhe = {
            AVATARS: {
                0: "ruhiger hellgrner Vogel mit einer einzigen dunklen Feder auf dem Kopf",
                1: "punkiger gelber Vogel mit gelben Federn, die wir ein Irokesenschnitt aussehen",
                2: "schicker trkiser Vogel mit runden, gelben Federn auf dem Kopf sowie einem Schwanz",
                3: "geschmeidiger roter Vogel mit einem spitzen Kopf und einem lockigen schwarzen Schwanz",
                4: "grner Vogel mit gelben Flgeln",
                5: "wilder magentafarbener Vogel mit ungegltteten hellrosa Federn auf dem Kopf",
                6: "dramatisch aussehender weier Vogel mit rechteckigen schwarzen Federn als Augenbrauen",
                7: "extravaganter lila Vogel mit nach vorne zeigenden Federn auf dem Kopf sowie einem groen, gelockten Schwanz",
                8: "entspannter brauner Vogel mit einem Fuchsartigen Schwanz",
                9: "niedlicher rosa Vogel mit einem Schwanz, der wie Eiswaffeln aussieht",
                10: "einfltig aussehender blauer Vogel mit perfektem Federkleid",
                11: "rosa Emo-Vogel, dessen Kopffedern nach vorn gebrstet sind"
            },
            CHANGE_AVATAR: "Avatar wechseln",
            LOGO: "das Dodo Re Mi-Logo "
        },
        Jhe = {
            CHANGE_AVATAR: "Avatar wechseln",
            SONG_DOWN: "Zum nchsten Lied scrollen: {songName}",
            SONG_UP: "Zum vorigen Lied scrollen: {songName}",
            SELECT_SONG: "Lied auswhlen: {songName}"
        },
        efe = {
            BASS: "Bass",
            MELODY: "Melodie",
            COUNTER: "Gegenstimme",
            DRUMS: "Schlagzeug",
            PERCUSSION: "Perkussion",
            HARMONY: "Harmonie",
            SIGNATURE: "Sonderinstrument"
        },
        tfe = {
            WHEN: "Wenn auf dem Bildschirm steht:",
            GET_READY: "Bereitmachen",
            TAP_HERE: "DRCKE[break][/break]HIER[break][/break][info](ODER DRCKE DIE LEERTASTE)[/info]",
            TAP: "DRCK",
            SYNCED: "Synchronisiert",
            SYNCING: "Synchronisierung luft"
        },
        nfe = {
            SHARE: "Teile eure Musik"
        },
        rfe = {
            SURVIVED: "berlebt",
            EATEN: "Gefressen"
        },
        sfe = {
            VERY_EASY: "Supereinfach",
            EASY: "Einfach",
            MEDIUM: "Mittel",
            HARD: "Schwer",
            VERY_HARD: "Superschwer"
        },
        ife = {
            BACK_TO_MENU: "Zurck zum Spielmen",
            BEST_SCORE: "Bester Punktestand",
            CHANGE_HOST: "Gastgeber[break][/break]wechseln?",
            CHOOSE_HOST: "Neuen Gastgeber whlen",
            CHOOSE_INSTRUMENT: "Instrument whlen",
            CHOOSE_SONG: "Lied whlen",
            COMPLETED_PARTS: "berlebte Abschnitte",
            DIFFICULTY: "Schwierigkeitsgrad",
            END_SESSION: "Konzert beenden",
            LANES: "Spuren",
            LOADING: "Lade",
            NEVERMIND: "Schon gut",
            NEW_SONG: "Neues Lied",
            RETRY_SONG: "Lied erneut versuchen",
            SELECT_SONG: "Lied auswhlen",
            SONG_PART: "Lied-Abschnitt",
            START_SONG: "Lied starten",
            TEST_IT: "Ausprobieren",
            THANKS: "Danke frs Spielen",
            VOTE_SONG: "Stimme fr ein Lied ab",
            WAITING_FOR: "Warte auf {vipName}",
            WHAT_NEXT: "Was jetzt?"
        },
        ofe = {
            WELCOME: "Willkommen zu Dodo Re Mi",
            SILENT: "Bitte stelle sicher, dass dein Gert nicht stumm geschaltet ist",
            VOLUME: "Mach dein Gert LAUTER",
            POWER_SAVER: "Stell sicher, dass dein Gert NICHT im Akkusparmodus ist",
            TEST: "TESTE DEINE AUDIOAUSGABE ",
            GO: "Los geht's"
        },
        afe = {
            ALT: Qhe,
            ARIA: Jhe,
            BEATMAPS: efe,
            COUNT_IN: tfe,
            CREDITS: nfe,
            RESULTS: rfe,
            DIFFICULTY: sfe,
            MENU: ife,
            WELCOME: ofe
        },
        cfe = {
            AVATARS: {
                0: "pjaro sereno de color verde claro con una sola pluma verde oscuro en la cabeza",
                1: "pjaro amarillo macarra con plumas amarillas que parecen un peinado mohicano",
                2: "pjaro elegante con plumas amarillas redondas en la cabeza y la cola",
                3: "pjaro rojo distinguido con la cabeza puntiaguda y una cola negra rizada",
                4: "pjaro verde con muchas plumas y alas amarillas",
                5: "pjaro silvestre magenta con plumas rosa claro despeinadas en la cabeza",
                6: "pjaro blanco dramtico con plumas negras angulares a modo de ceja",
                7: "pjaro morado extravagante con plumas hacia delante en la cabeza y una gran cola rizada",
                8: "pjaro marrn tranquilo con cola de zorro",
                9: "pjaro rosa bonito con una cola que parece unos cucuruchos de helado",
                10: "pjaro azul tontorrn con un peinado ideal",
                11: "pjaro rosa emo con plumas peinadas hacia delante en la cabeza"
            },
            CHANGE_AVATAR: "Cambiar avatar",
            LOGO: "el logotipo de Dodo Re Mi"
        },
        ufe = {
            CHANGE_AVATAR: "cambiar avatar",
            SONG_DOWN: "ir a la cancin siguiente {songName}",
            SONG_UP: "volver a la cancin anterior {songName}",
            SELECT_SONG: "elegir cancin {songName}"
        },
        lfe = {
            BASS: "Bajo",
            MELODY: "Meloda",
            COUNTER: "Contrapunto",
            DRUMS: "Batera",
            PERCUSSION: "Percusin",
            HARMONY: "Armona",
            SIGNATURE: "Comps"
        },
        hfe = {
            WHEN: "Cuando lo indique la pantalla",
            GET_READY: "Preprate",
            TAP_HERE: "TOCA[break][/break]AQU[break][/break][info](O DALE A LA BARRA ESPACIADORA)[/info]",
            TAP: "toca",
            SYNCED: "sincronizado",
            SYNCING: "Sincronizando"
        },
        ffe = {
            SHARE: "Compartir la msica"
        },
        dfe = {
            SURVIVED: "Superviviente",
            EATEN: "Devorado"
        },
        pfe = {
            VERY_EASY: "Muy fcil",
            EASY: "Fcil",
            MEDIUM: "Normal",
            HARD: "Difcil",
            VERY_HARD: "Muy difcil"
        },
        mfe = {
            BACK_TO_MENU: "Volver al men del juego",
            BEST_SCORE: "Mejor puntuacin",
            CHANGE_HOST: "Cambiar[break][/break]anfitrin?",
            CHOOSE_HOST: "Elige un nuevo anfitrin",
            CHOOSE_INSTRUMENT: "Elegir instrumento",
            CHOOSE_SONG: "Elegir cancin",
            COMPLETED_PARTS: "Partes sobrevividas",
            DIFFICULTY: "Dificultad",
            END_SESSION: "Finalizar sesin",
            LANES: "Pistas",
            LOADING: "Cargando",
            NEVERMIND: "Da igual",
            NEW_SONG: "Nueva cancin",
            RETRY_SONG: "Volver a intentar",
            SELECT_SONG: "Seleccionar cancin",
            SONG_PART: "Parte de la cancin",
            START_SONG: "Empezar cancin",
            TEST_IT: "Probar",
            THANKS: "Gracias por jugar",
            VOTE_SONG: "Vota una cancin",
            WAITING_FOR: "Esperando a {vipName}",
            WHAT_NEXT: "Qu hay a continuacin?"
        },
        gfe = {
            WELCOME: "Os doy la bienvenida a Dodo Re Mi",
            SILENT: "Desactivad el modo silencio de vuestro dispositivo",
            VOLUME: "Y SUBID bien el volumen",
            POWER_SAVER: "Aseguraos de que vuestro dispositivo NO est en modo ahorro de energa",
            TEST: "PROBAD EL SONIDO ",
            GO: "Vamos"
        },
        _fe = {
            ALT: cfe,
            ARIA: ufe,
            BEATMAPS: lfe,
            COUNT_IN: hfe,
            CREDITS: ffe,
            RESULTS: dfe,
            DIFFICULTY: pfe,
            MENU: mfe,
            WELCOME: gfe
        },
        yfe = {
            AVATARS: {
                0: "ave tranquila de color verde claro con una sola pluma verde oscura en la cabeza",
                1: "ave amarilla con plumas amarillas en forma de cresta punk",
                2: "ave distinguida verde azulada con plumas amarillas en la cabeza y cola",
                3: "ave roja elegante con la cabeza puntiaguda y cola negra enrulada",
                4: "ave verde con copete y alas amarillas",
                5: "ave magenta con tonos rosados y plumas alborotadas en la cabeza",
                6: "ave blanca impresionante con cejas angulares de plumas negras",
                7: "ave violeta llamativa con plumas hacia adelante en la cabeza y una cola larga y enrulada",
                8: "ave marrn tranquila con cola de zorro",
                9: "ave rosa adorable con una cola que parece un cono de helado",
                10: "ave azul tonta con cabello perfecto",
                11: "ave rosa rebelde con plumas peinadas hacia adelante en la cabeza"
            },
            CHANGE_AVATAR: "Cambiar avatar",
            LOGO: "el logotipo de Dodo Re Mi"
        },
        vfe = {
            CHANGE_AVATAR: "cambiar avatar",
            SONG_DOWN: "avanza a la siguiente cancin {songName}",
            SONG_UP: "retrocede a la siguiente cancin {songName}",
            SELECT_SONG: "elige la cancin {songName}"
        },
        bfe = {
            BASS: "Bajo",
            MELODY: "Meloda",
            COUNTER: "Contra",
            DRUMS: "Batera",
            PERCUSSION: "Percusin",
            HARMONY: "Armona",
            SIGNATURE: "Armadura"
        },
        Efe = {
            WHEN: "Cuando la pantalla dice",
            GET_READY: "Preprate",
            TAP_HERE: "TOCA[break][/break]AQU[break][/break][info](O TOCA LA BARRA ESPACIADORA)[/info]",
            TAP: "toca",
            SYNCED: "sincronizado",
            SYNCING: "Sincronizando"
        },
        Sfe = {
            SHARE: "Comparte la msica"
        },
        Tfe = {
            SURVIVED: "Sobreviviste",
            EATEN: "Te comieron"
        },
        wfe = {
            VERY_EASY: "Superfcil",
            EASY: "Fcil",
            MEDIUM: "Medio",
            HARD: "Difcil",
            VERY_HARD: "Superdifcil"
        },
        Ofe = {
            BACK_TO_MENU: "Volver al men del juego",
            BEST_SCORE: "Mejor puntuacin",
            CHANGE_HOST: "Cambiar[break][/break]anfitrin?",
            CHOOSE_HOST: "Elegir nuevo anfitrin",
            CHOOSE_INSTRUMENT: "Elige un instrumento",
            CHOOSE_SONG: "Elige una cancin",
            COMPLETED_PARTS: "Partes sobrevividas",
            DIFFICULTY: "Dificultad",
            END_SESSION: "Finalizar sesin",
            LANES: "Pistas",
            LOADING: "Cargando",
            NEVERMIND: "Olvidar",
            NEW_SONG: "Nueva cancin",
            RETRY_SONG: "Volver a intentar la cancin",
            SELECT_SONG: "Elegir la cancin",
            SONG_PART: "Parte de la cancin",
            START_SONG: "Comenzar cancin",
            TEST_IT: "Intento de prueba",
            THANKS: "Gracias por jugar",
            VOTE_SONG: "Votar por una cancin",
            WAITING_FOR: "Esperando a {vipName}",
            WHAT_NEXT: "Qu sigue?"
        },
        Afe = {
            WELCOME: "Bienvenidos a Dodo Re Mi",
            SILENT: "Quita el modo silencioso de tu dispositivo",
            VOLUME: "SUBE el volumen",
            POWER_SAVER: "Asegrate de que tu dispositivo NO est usando ahorro de batera",
            TEST: "PRUEBA TU SONIDO ",
            GO: "Vamos"
        },
        Cfe = {
            ALT: yfe,
            ARIA: vfe,
            BEATMAPS: bfe,
            COUNT_IN: Efe,
            CREDITS: Sfe,
            RESULTS: Tfe,
            DIFFICULTY: wfe,
            MENU: Ofe,
            WELCOME: Afe
        },
        Ife = {
            en: xhe,
            fr: qhe,
            it: Xhe,
            de: afe,
            es: _fe,
            "es-XL": Cfe
        },
        kfe = yt({
            props: {
                avatar: {
                    type: Number,
                    required: !0
                }
            }
        }),
        Tt = t => (Di("data-v-762a6505"), t = t(), $i(), t),
        Nfe = Tt(() => W("path", {
            class: "legs",
            d: "m260.33,479.5c.14,9.96-15.51,9.97-15.36,0,0,0,0-69.65,0-69.65h15.36v69.65Zm45.85-69.65h-15.49v69.65c0,4.24,3.44,7.68,7.68,7.68s7.68-3.44,7.68-7.68l.13-69.65Z"
        }, null, -1)),
        xfe = {
            class: "dancer"
        },
        Pfe = {
            key: 0
        },
        Rfe = Tt(() => W("path", {
            class: "body",
            d: "m427.34,191.3c-31.47-32.8-78.21-44.55-122.57-35.13-107.61,20.57-142.69,175.09-176.04,263.77,40.53,20.16,86.68,26.16,131.6,24.48,40.59-.35,85.58-5.03,121.13-23.13,85.67-37.54,106.25-162.21,45.88-229.98"
        }, null, -1)),
        Mfe = Tt(() => W("path", {
            class: "feathers",
            d: "m91.21,270.01c-14.4-23.74-23.13-39.67-26.2-47.8-13.81,47.97-3.21,102.5,25.15,143.21-14.53-7.92-28.44-16.34-41.47-25.82,7.83,39.15,45.74,69,83.16,81.3,0,0,12.37-46.11,20.31-68.63-27.13-32.83-47.45-60.25-60.95-82.26m141.58,11.04c-67.49-1.5-131.89,229.74-27.26,87.83-.19,4.84-6.88,27.27-2.78,30.81,13.63,7.21,40.81-25.98,47.61-36.28,6.28-10.33,11.81-21.51,14.88-33.31,4.93-22.08-7.48-49.46-32.44-49.05m74.29-176.81c-4.9-17.55-9.09-40.99-26.39-49.82-18.45-7.86-31.49,15.17-24.67,30.91,1.85,4.86,6.08,11.01,12.67,18.43,19.77,19.58,31.8,37.05,36.09,52.41-.14,1.98,5.89-.63,7.68-.34-.18-15.36-2.8-40.04-5.38-51.58Z"
        }, null, -1)),
        Dfe = [Rfe, Mfe],
        $fe = {
            key: 1
        },
        Lfe = Tt(() => W("path", {
            class: "body",
            d: "m341.25,153.29c-38.56-1.39-79.06,10.63-104.91,40.51-57.31,63.16-79.73,147.99-108.6,226.14,41.16,19.52,87.26,26.43,132.6,24.48,40.58-.35,85.58-5.04,121.13-23.13,121.51-54.31,102.75-263.79-40.22-267.99"
        }, null, -1)),
        Ffe = Tt(() => W("path", {
            class: "feathers",
            d: "m109.06,219.14c2.5-5.46-5.75-4.52-9.79-4.03-39.06,7.01-61.12,54.76-56.25,92.05-10.25-10.47-21.39-18.52-38.49-23.61-1.06,67.22,62.63,119.11,124.2,136.4,2.69-8,5.44-15.97,8.25-23.9-39.64-30.25-28.75-114.47,21.6-125.36-18.53-30.58-55.85-19.23-67.38,10.27.68-21.55,7.69-42.59,17.85-61.81m102.42,62.49c-18.35,3.35-34.86,26.3-42.33,44.35l-.19.1c6.44-2.87,12.27-5.83,19.39-9.98-21.03,34.19-27.3,44.35-32.44,53.46.63-.75-4.81,9.27-.86,6.72,8.01-3.54,16.45-5.93,24.09-10.17-2.68,4.18-30.04,48.15-32.06,50.87,3.15,5.9,23.87-3.26,31.67-5.57,26.97-10.75,40.36-14.32,58.26-31.68,33.96-27.61,29.19-109.02-25.53-98.1m97.23-249.52c.05-8.48-8.66,3.14-10.27,4.42-26.13,30.97-44.83,73.77-50.1,113.07-4-22.91-5.67-51.71-7.97-73.62-1.08-1.87-2.69-1.12-3.74.67-20.11,31.18-32.02,77.36-29.56,118.83-2.19-2.56-9.77-28.42-14.59-26.78-12.68,16.3-9.49,63.01,7.1,76.12,32.21-56.04,73.46-93.81,141.67-90.51,3.25-43.42,14.66-93.2,32.73-129.29,1.15-2.18,1.15-3.62,0-4.32-35.94,14.1-58.18,56.83-71.12,94.16.45-27.58,2.4-55.16,5.86-82.74Z"
        }, null, -1)),
        Ufe = [Lfe, Ffe],
        Bfe = {
            key: 2
        },
        qfe = Tt(() => W("path", {
            class: "body",
            d: "m351.9,153.06c-145.64-15.71-184.78,160.75-224.16,266.88,89.43,38.11,223.82,39.36,297.02-31.42,70.05-74.69,38.65-225.27-72.85-235.46"
        }, null, -1)),
        Vfe = Tt(() => W("path", {
            class: "feathers",
            d: "m113.47,246.69c-35.76-6.86-45.17,27.33-34.07,56.15-55.31-80.2-106.43,21.56-23.32,54.52-32.26-8.59-45.14,25.83-20.93,44.63,24.52,17.96,67.15,21.49,106.26,23.8l-12.67-5.86c.45-1.41,23.77-68.79,25.05-72.37-6.65-15.19-11.54-31.26-16.03-47.13-6.5-17.76-4.85-45.92-24.28-53.75m170.18,86.68c-2.51-10.55-4.98-18.29-9.69-26.3.7,1.66-80.95-2.59-74.68-7.97-15.37,9.52-35.22,22.73-42.14,39.16-11.36,22.64,12.88,37.22,32.25,24.86-29.74,49.46,39.51,65.92,45.21,8.16,8.34,55.32,69.47,40.79,49.05-37.91m80.44-177.38c33.47-101.26-65.61-124.6-59.32-41.85-13.57-88.04-114.45-68.93-60.76,22.27-47.46-62.94-91.28,31.16-17.66,68.92,33.85-47.51,91.74-58.07,137.74-49.34Z"
        }, null, -1)),
        jfe = Tt(() => W("path", {
            class: "feathers top",
            d: "m113.09,283.64c-11.66-9.82-20.87,2.23-21.4,15.84-2.52,11.61,10.17,38.26,15.93,45.5-8.19-8.89-16.8-16.89-25.82-24-14.93-9.86-17.88-18.87-31.48-12.29-24.95,23.13,25.18,53.01,47.8,63.93-19.74-2.81-53.5-15.77-53.75,12.48,2.89,24.52,63.86,26.44,85.81,30.62,6.53-19.13,13.15-38.23,19.87-57.3-9.24-22.94-33.37-75.14-36.95-74.77m162.79,28.8c-13.93-42.75-71.8-26.05-92.14,1.83-21.19,24.14,3.54,44.63,25.05,20.44-27.69,53.52,25.56,52.2,27.64-3.17,5.59,51.37,62.08,38.4,39.45-19.1m-9.69-142.64c-12.78-8.26-26.29-22.61-41.66-22.37-8.73,1.79-12.37,10.44-12.29,19.97.19,9.66,7.39,19.39,21.6,29.18,9.47-10.69,19.83-20.23,32.35-26.78m9.21-71.32c-38.71-1.94-22.95,39.69-4.51,68.92,12.13-5.97,25.37-10.09,38.97-12.19-11.64-26.16-14.25-50.99-34.46-56.73m74.29,7.77c-26.28-31.77-36.59,28.66-37.63,48.66,13.13-1.8,26.98-2.43,39.83-.86,2.9-14.29,6.18-36.66-2.21-47.8Z"
        }, null, -1)),
        Gfe = [qfe, Vfe, jfe],
        Wfe = {
            key: 3
        },
        Hfe = Tt(() => W("path", {
            class: "body",
            d: "m218.19,214.53c-2.01,3.1-8.51,12.63-10.27,15.65h-.19l.1.1-1.34,2.11c.13-.13.26-.26.38-.38-36.49,57.91-56.56,123.97-79.13,187.94,45.57,23.03,98.75,26.56,149.01,24.09,55.1-1.7,113.65-15.19,150.6-57.3,41.89-47.62,45.66-127.64,11.71-180.16-37.62-55.4-91.5-94.41-141.87-134-2.55,36.93-61.38,111.5-79,141.96"
        }, null, -1)),
        Kfe = Tt(() => W("path", {
            class: "feathers",
            d: "m149.66,293.53c-36.47-63.88-136.29-26.41-129.96,43.87,5.24,58.16,71.55,74.35,119.5,87.35l-10.46-4.8c1.47-4.29,2.94-8.54,4.42-12.77-30.44-9.38-86.83-38.82-57.21-76.21,12.46-14.48,21.62-18.29,36.67-18.81,18.61-.52,23.87,13.07,11.23,26.11-4.66,5.37-16.09,6.29-24.48,6.05-6.27-1.15-4.03.83,6.72,5.95,11.46,6.39,23.46,2.01,31.58-7.1,13.11-12.5,21.09-32.75,12-49.62m100.11-14.21c-.64-3.01-1.54-5.7-2.69-8.06-22.95,16.23-44.73,30.18-59.41,52.89-10.37,15.58-17.59,33.56-20.25,52.02-.1,7.77-5.13,21.57-1.73,27.84,53.71-15.65,98.83-66.1,84.08-124.69"
        }, null, -1)),
        Yfe = [Hfe, Kfe],
        zfe = {
            key: 4
        },
        Zfe = Tt(() => W("path", {
            class: "body",
            d: "m236.81,193.32c-25.47,27.04-43.71,59.29-58.65,93.01.62,4.16-33.49,89.64-44.92,93.11-91.3,60.83,6.69,77.13,46.26,58.26,59.52,12.23,147.51,10.47,201.95-16.41,88.43-38.42,108.35-172.68,38.49-236.8,15.99-26.52,13.5-68-9.21-89.56-.83,0-1.67.67-2.5,2.02-4.99,8.77-11.1,16.54-18.33,23.32-.53-18.07-16.16-50.56-31.67-61.34-23.32,43.95-87.93,93.72-121.42,134.38"
        }, null, -1)),
        Xfe = Tt(() => W("path", {
            class: "feathers",
            d: "m125.95,386.92c2.69-2.94,5.12-5.44,7.29-7.49-25.92,22.78-53.87,32.94-89.07,39.55-2.35.51-3.73.72-4.22,2.69,15.36,7.61,22.66,9.68,38.3,9.98,19.43,23.65,67.84,17.75,93.01,9.5-4.3,1.11-18.17,3.42-23.61,2.78-11.83-.19-36.01-5.54-15.36-17.28,9.01-5.54-11.97-1.77-19.01-3.94-15.2-3.06-16.9-3.87-6.34-14.59,8.02-8.31,11.21-13.04,19-21.21m115.47-52.12c19.73-22.74,8.47-65.6-22.75-69.3-17.45-2.73-28.01,9.35-40.51,20.83-10.28,9.48-29.76,29-43.58,42.91-31.37,36.38,62.93,46.26,80.34,32.35,10.17-7.68,19-16.61,26.49-26.78"
        }, null, -1)),
        Qfe = Tt(() => W("path", {
            class: "feathers top",
            d: "m129.7,344.21c-.38-3.78,1.25-8.77,4.9-14.97-13.25,13.12-24.16,23.26-32.73,30.43-3.08,3.03-12.92,9.59-12.67,13.82,5.11,18.76,51.8-.95,64.79-9.21-20.41,22.94-2.16,24.48,17.85,18.81,15.42-4.24,30.06-11.63,43.1-21.5-25.22,10.86-45.21,9.97-34.84-21.21-11.24,5.83-19.16,11.6-30.33,12.86-8.86.91-18.5.02-20.06-9.02m50.68-4.51c-.06.19-.16.42-.29.67.06-.06.16-.13.29-.19v-.48Z"
        }, null, -1)),
        Jfe = [Zfe, Xfe, Qfe],
        ede = {
            key: 5
        },
        tde = Tt(() => W("path", {
            class: "body",
            d: "m210.84,442.81c56.23,3.81,119.7,3.04,170.61-21.7,127.76-57.95,98.22-278.38-53.96-267.87-124.91,2.33-161.79,162.01-198.83,266.52-.26.73,5.97,2.68,6.82,3.07,0,0,75.37,19.97,75.37,19.97Z"
        }, null, -1)),
        nde = Tt(() => W("path", {
            class: "feathers",
            d: "m69.51,236.77c-6.08-11.91-11.43-24.16-16.03-36.77-.45-1.22-1.28-1.6-2.5-1.15-6.1,32.73-6.78,67.49.67,99.95,29.91,33.07,59.43,58.91,83.91,84.78v.1c-36.59-23-90.98-58.41-135.56-86.12l4.61,12.1-.1-.58c8.02,18.4,14.88,40.8,32.26,52.52,30.96,15.16,62.04,22.62,95.72,32.07l-126.44-11.04c6.25,8.57,24.48,21.37,33.03,26.69,23.12,4.87,62.57-5.34,92.55-7.59-13.84,4.1-22.19,6.91-44.84,12.87-25.53,7.9-35.73,6.36-51.94,15.46,18.83,3.91,37.99,7.04,56.93,10.56,2.05.58,3.97.29,5.76-.86,10.69-6.66,21.47-13.12,32.36-19.39l-1.25-.58c5.31-15.68,10.72-31.33,16.23-46.95-15.75-25.47-62.28-109.7-75.37-136.05m184.05,165.23c10.01,10.73,1.55-48.09,1.54-52.23,2.76-9.07-58.64-42.27-66.82-43.4-.75-.78-3.22,1.31-3.26,2.59-21.55,38.38-45.37,105.85-65,151.89-5.42,14.97,35.22-28.17,37.93-29.09,7.42-7.62,18.05-15.61,23.81-23.91,3.93-19.53,4.6-47.2,6.14-66.63,3.29,43.42,4.8,65.46,9.5,99.66,1.16,3.18,2.05,28.71,5.95,20.93,11.7-25.41,16.85-52.07,22.75-76.91-.26-3.69-.83-4.18-2.98-8.83-4.84-11.49-7.08-21.11-13.35-31.88,14.42,19.85,29.11,39.13,43.78,57.8m3.36-226.97c3.2-2.11,6.5-4.03,9.89-5.76-76.57-56.32-89.3-76.68-161.39-47.24,46.55,20.93,91.14,32.88,138.64,62.31-61.65-16.4-66.5-17.49-99.37,3.46-7.23,4.03-20.29,13.06-39.17,27.07,31.02-6.67,82.11-7.93,120.11-8.93,9.11-11.37,19.6-22.5,31.3-30.92m45.12-53c-8.19-27.91-14.05-45.6-17.57-53.09-5.21-14.4-55.62-48.65-66.63-57.7-3.28-2.83-5.22-3.03-6.82-6.05-.77-1.09-.74-.7.1,1.15,11.19,21.92,49.99,96.01,65.29,133.65,12.61,29.19,9.12,26.05-10.46-9.41-34.28-66.82-60.17-72.27-117.23-75.75,38.17,29.82,89,75.59,118.96,113.96,13.94-7.46,29.6-12.23,45.51-14.31-3.46-8.13-7.17-18.95-11.14-32.45Z"
        }, null, -1)),
        rde = [tde, nde],
        sde = {
            key: 6
        },
        ide = Tt(() => W("path", {
            class: "body",
            d: "m279.24,163.66c-94.04,38.57-119.14,172.16-150.5,256.28,40.52,20.19,86.68,26.14,131.6,24.48,40.58-.35,85.58-5.04,121.13-23.13,89.04-38.68,108.55-174.44,37.15-238.04,0,0-52.8-55.08-139.37-19.58Z"
        }, null, -1)),
        ode = Tt(() => W("path", {
            class: "feathers",
            d: "m89.48,240.93c-15.29-20,19.54,103.96,24.96,131.79l-106.16-10.85c-2.18-.13-3.42.42-3.74,1.63-.32,1.15.51,2.21,2.5,3.17,56.28,27.25,78.63,38.72,125.16,54.9l-3.46-1.63c7.55-22.14,15.2-44.25,22.94-66.33-.58-1.09-1.18-2.21-1.82-3.36l-60.37-109.33m110,41.95l1.92,26.4c-13.79,22.54-35.56,62.51-46.84,84.76-.89,2.37-2.72,6.21-5.47,11.52-2.75,5.31-2.37,6.14,1.15,2.5s12.16-9.79,25.92-18.43c13.55-8.07,69.55-45.6,80.24-51.26-8.25-14.69-36.13-39.68-56.92-55.48m116.62-128.53c-38.44-20.67-78.72-41.12-112.11-54.71,12.58,19.44,52.13,46.81,75.25,64.02,46.91,33.09,55.9,37.67,111.34,74.1,25.45-43.3,55.02-106.52,55.58-157.7-9.4,16.01-55.43,94.59-63.83,108.75-17.53-8.83-39.61-20.32-66.23-34.46Z"
        }, null, -1)),
        ade = [ide, ode],
        cde = {
            key: 7
        },
        ude = Tt(() => W("path", {
            class: "body",
            d: "m427.34,191.3c-3.93-4.1-24.27-43.38-24.27-43.38l-12.67,17.12c-177.99-49.1-214.07,124.01-261.67,254.9,76.87,34.7,175.82,33.8,252.73,1.35,85.67-37.55,106.25-162.22,45.88-229.99"
        }, null, -1)),
        lde = Tt(() => W("path", {
            class: "feathers",
            d: "m252.65,330.67c-.89-4.25,4.64-7.56,6.43-2.98,1.17,3.77-.51,18.08-.19,28.32,3.82,10.62,19.04,17.95,28.41,9.5,11.85-12.62,8.2-33.24,6.14-52.02-3.07-41.9-77.78-31.47-114.03-28.99-21.54,2.88-37.88,19.02-43.19,40.12-2.84,13.98-4.55,36.58,10.84,43.19,8.6,4,21.41-2.57,24.09-12.19,1.16-6.18-.1-20.03-.58-26.11-.71-5.9,6.44-5.67,5.86-.1.71,10.39-1.9,21.55,2.21,31.39,3.68,10.54,17.88,12.96,25.92,5.76,11.01-8.2,5.84-28.29,7.01-40.03,1.46-2.64,5.15-2.13,7.01-.1h-.19c1.26,12.97-4.11,30.53,7.01,40.12,11.08,8.7,25.07,2.28,27.36-11.14,0,0-.1-24.76-.1-24.76m-18.43-143.4c-5.47,12.61-7.58,13.09-7.01,17.85l.58-.1v-.38c64.9-65.28,104.61-6.53,177.28-22.08-5.12-7.53-5.21-18.59-4.13-27.55,4.6-1.13,1.62,2.86,1.82,5.85.12,6.78.35,15.84,5.18,20.93.83-.26.1.1.1.1,20.17,26.14,55.37,20.23,68.25-9.79,5.93-15.28,3.61-44.77-18.72-42.62-15.78-1.06-30.92,4.21-47.03,2.4-64.37-15.42-142.41-6.61-176.32,55.39M160.12,7.97C-17.74,62.21-69.08,370.46,138.53,424.26l-9.41-4.32c2.11-6.14,4.22-12.29,6.33-18.43-92.51-58.72-102.12-224.9-5.28-280.76,19.54-10.9,61.56-19.46,67.29,7.2-.62,14.86-20.8,20.17-33.12,16.8l-.48,1.54c31.8,21.92,74.81,6.62,104.62-13.24,42.89-26.56,43.68-88.53,3.07-116.91C239.63-5.74,196.6-2.13,160.12,7.97Z"
        }, null, -1)),
        hde = [ude, lde],
        fde = {
            key: 8
        },
        dde = Tt(() => W("path", {
            class: "body",
            d: "m427.34,191.3c-169.76-133.72-259.43,94.21-298.61,228.64,76.87,34.7,175.82,33.8,252.73,1.35,85.67-37.55,106.25-162.22,45.88-229.99"
        }, null, -1)),
        pde = Tt(() => W("path", {
            class: "feathers",
            d: "m53.77,206.95c-14.84,11.47-32.03,24.91-37.15,42.14,0,.58.1,1.12.29,1.63,17.91-9.5,38.82-6.5,17.66,14.88-90.52,75.1,23.6,135.74,94.16,154.35,1.54-4.54,3.1-9.09,4.7-13.63-70.15-39.32-.62-99.2,24-144.55,40.99-85.66-48.79-97.97-103.67-54.81M372.82,65.37c-18.71-5.95-30.65,16.2-34.36,30.91-2.13,14.27.12,19.63,6.53,38.78-21.17-33.93-55.37-11.29-43.96,21.79,11.6,26.94,38.47,44.71,60.95,61.72,7.44,4.27,15.13,13.57,24.28,9.6,1.15.77,4.61-3.36,10.37-12.38,13.2-21.74,24.77-40.42,32.64-63.83,9.14-28.96-14.31-65.94-31.39-18.62.1-23.91,1.51-57.98-25.05-67.96Z"
        }, null, -1)),
        mde = Tt(() => W("path", {
            class: "feathers top",
            d: "m245.82,340.95c5.44-5,6.11-7.18,10.65-11.71,5.58,2.14-19.15,22.58-22.75,28.41-1.48,1.41-35.64,41.3-36.67,40.99,223.36-26.37-65.09-269.62-50.87-27.36,14.51-32.07,31.31-54.8,58.07-77.75l2.3.58c-23.88,20.74-44.08,47.68-60.18,79.57,1.38,7.84,1.25,17.4,5.76,23.61,12.88,4.69,26.95,2.53,43.87,1.44,10.38-14.71,37.56-42.46,49.82-57.78"
        }, null, -1)),
        gde = [dde, pde, mde],
        _de = {
            key: 9
        },
        yde = Tt(() => W("path", {
            class: "body",
            d: "m427.34,191.3c-31.47-32.8-78.21-44.55-122.57-35.13-107.61,20.57-142.69,175.09-176.04,263.77,40.53,20.16,86.68,26.16,131.6,24.48,40.59-.35,85.58-5.03,121.13-23.13,85.67-37.54,106.25-162.21,45.88-229.98"
        }, null, -1)),
        vde = Tt(() => W("path", {
            class: "feathers",
            d: "m152.25,296.79l.1-.48-.1-.19.19-.19-60.95,5.18c-.55.67,36.59,103.62,36.57,104.34-.38-.86-44.88-99.04-45.21-99.83l-48.47,37.15c-.54.91,94.93,74.25,95.12,74.87,10.52-18.22,19.47-99.49,22.75-120.85m92.15-5.47l-.48-.29-88.11,50.97-6.05,3.46v.1h-.29c21.05,12.82,72.74,44.28,93.11,56.73h.38l1.44-110.96m115.57-190.34c-.1-21.6-29.46-29.99-44.15-16.7-7.52,7.49-21.91,24.83-18.05,33.88l.96-.19c.06-.19.16-.38.29-.58,0-.06.06-.1.19-.1,4.17-9.11,12.59-17.97,23.13-18.72,7.76.07,13.21,9.5,9.21,16.22-6.02,13.51-21.52,6.14-31.48,4.7-2.95,1.02-7.64-.17-10.65,1.06h.77c-8.92,1.79-12.56,5.87-20.54,6.34-10.25.77-19.94-11.87-11.61-20.25,0-.06.03-.1.1-.1,10.51-6.97,24.71,3.65,31,12.19h1.06c2.06-7.6-9.77-17.59-17.28-24.38-14.86-14.78-42.09-8.82-47.32,11.71-4.32,33.31,36.57,48.46,59.41,28.32l3.26,26.01c6.33-2.13,13-3.72,19.68-4.9l-1.92-23.04c22.25,12.91,57.49-2.85,53.94-31.48Z"
        }, null, -1)),
        bde = Tt(() => W("path", {
            class: "feathers top",
            d: "m74.89,281.05c-47.97-52.91-107.51,40.7-40.22,62.39l-.29-.29v-.38l48.47-37.15c.02.24.25.67.38.86.38-9.34-2.4-17.82-8.35-25.44m74.48,64.41c-.06.06-.1.13-.1.19-.13,0-.16.06-.1.19-12.81,22.8,14.73,40.89,30.24,19.29-11.83,24.16,16.97,39.93,31.39,17.76-.1-.1-61.38-37.3-61.43-37.43m-4.51-101.27c-38.78-30.78-87.09,21.68-53.37,57.69-.09-.2-.09-.57,0-.77l60.95-5.18-.19.19.1.19-.1.48c11.51-16.08,8.25-40.4-7.39-52.6m96.37,158.86c.33-.37.51-.82.77-1.15l-30.81-18.72v.1c-.13,0-.16.06-.1.19-12.89,22.44,14.76,40.75,30.14,19.58Z"
        }, null, -1)),
        Ede = [yde, vde, bde],
        Sde = {
            key: 10
        },
        Tde = Tt(() => W("path", {
            class: "body",
            d: "m304.87,156.08c-94.26,18.24-129.7,135.36-159.05,214.34-28.49-43.69-51.63-89.82-71.56-136.34l-2.44.81c-18.73,13.21-35.38,31.72-44.06,53.18.1.19,21.13,22.6,21.12,22.84h-.1l-.1.1c26.15,27.64,55.01,56.67,88.69,83.89-2.91,8.36-5.8,16.69-8.64,25.05,54.48,27.37,117.77,27.38,177.19,21.98,46.2-4.96,90.89-20.74,121.42-55.19,79.89-98.68,16.6-258.5-122.48-230.65"
        }, null, -1)),
        wde = Tt(() => W("path", {
            class: "feathers",
            d: "m89.04,403.38c17.26,7.98,27.6,12.45,40.99,16.7,2.75-8.06,5.54-16.13,8.35-24.19-33.66-27.2-62.56-56.27-88.69-83.89l.1-.1h.1l-.1-.19c-11.15,15.21-30.54,39.24-29.37,50.97,17.33,15.15,44.04,29.03,68.63,40.7m42.04-156.07c-.32-.96-.8-1.5-1.44-1.63l-.1-.48c-13.48,6.6-26.19,14.97-39.35,25.92,14.37,31.47,36.86,69.44,56.63,100.31,3.77-10.75,7.38-21.51,11.33-32.16-8.28-29.01-17.06-65.48-27.07-91.95m115.05,122.25c6.13-36.91-27.08-33.22-39.16-6.72,8.07-48.16-29.3-25.38-46.75-1.06-26.41,72.58,4.08,65.57,45.31,7.1-.28,4.96-6.81,27.18-2.78,30.81,12.53,6.73,35.55-20.75,43.39-30.14m135.43-254.8c2.95-43.91-102.06-29.37-125.26-13.73-6.2,3.41-13.67,9.14-11.33,17.38,3.07,20.6,5.14,41.44,6.05,62.49,35.81-27.95,90.1-34.1,131.69-18.24.38-15.93,0-31.9-1.15-47.9Z"
        }, null, -1)),
        Ode = Tt(() => W("path", {
            class: "feathers top",
            d: "m260,343.38c16.26-30.58-6.86-74.89-43.87-57.49-29.05,14.9-44.25,46-56.92,76.88,8-11.73,35.66-38.3,46.36-22.56,1.26,3.73,1.06,20.48.38,23.61,12.12-26.55,45.3-30.14,39.16,6.72,6.13-8.51,11.06-17.36,14.88-27.16"
        }, null, -1)),
        Ade = [Tde, wde, Ode],
        Cde = {
            key: 11
        },
        Ide = Tt(() => W("path", {
            class: "body",
            d: "m304.87,155.69c-85.74,16.74-119.78,111.87-148.39,183.91-6.33,17.8-12.45,35.72-18.62,53.56-8.48,14.16-18.75,34.65-27.55,47.8-24.06,34.26,7.13,7.01,18.14,1.25.64,1.76-28.12,58.72-21.79,57.88,16.92-11.3,32.49-32.36,46.46-46.55,1.4,2.36,3.01,27.01,7.77,25.44,8.99-13.85,14.43-30.22,19.77-41.47,59.1,12.05,146.8,10.1,200.8-16.6,138.74-67.15,89.2-299.08-76.6-265.21"
        }, null, -1)),
        kde = Tt(() => W("path", {
            class: "eyes emo",
            d: "m439.63,242.46c1.85-14.67-22.74-14.91-22.75,0,0,7.63,20.64,16.7,22.75,0Zm-129.77,5.57c0,14.91,23.17,14.78,22.75,0-.45-15.75-22.75-14.32-22.75,0Z"
        }, null, -1)),
        Nde = Tt(() => W("path", {
            class: "feathers",
            d: "m276.74,343.92c1.35-1.72,1.91-2.45,1.63-3.94-9.73,4.74-23.71,12.96-41.95,24.67,2.97-3.38,2.62-21.3,5.28-24.86l-29.76,11.04c-2.3.75,10.79-26.92,8.93-26.2l-19.48,1.63,12.86-27.93-.1.48c.79-2.14,1.71-4.69,2.5-6.43-24.13,17.33-45.57,41.59-65.56,62.58v.1c-4.15,6.18,37.59-10.12,38.01-9.21-59.33,95.27-48.45,72.61,30.72,23.61.19,19.01.13,30.52-.19,34.55-.06,4.03.42,5.57,1.44,4.61,18.29-22.35,35.51-39.67,55.67-64.69m115.85-160.58c-.9-.7-.64.35.77,3.17,1.81,3.02,7.33,19.65,9.02,27.07-16.92-11.48-36.93-27.72-53.66-36.28,1.87,3.82,7.79,24.53,8.73,25.34-10.82-5.54-26.29-13.25-35.8-13.53-.26,0-.48.03-.67.1.26.19.54.35.86.48v.1c18.92,11.21,36.79,24.41,53.56,39.16,3.46.81-10.11-24.38-9.79-25.15,21.98,14.47,41.22,33.92,60.76,50.97,2.53-1.85-2.32-13.06-3.74-20.35-.13,0-.64-1.86-.58-1.92-1.79-6.21-3.74-12.32-5.86-18.33,9.02,5.12,17.63,10.24,25.82,15.36,4.88,2.35,1.92-4.41.19-7.1-6.54-12.54-19.62-35.37-33.21-40.31,3.14,4.03,8.06,11.68,14.78,22.94-6.85-6.33-23.64-16.66-31.2-21.69Z"
        }, null, -1)),
        xde = [Ide, kde, Nde],
        Pde = {
            key: 12
        },
        Rde = Tt(() => W("path", {
            class: "body",
            d: "m402.51,289.92c0,89.27-38.24,154.39-125.03,154.39s-125.03-65.11-125.03-154.39,51.05-172.02,125.03-172.02,125.03,82.74,125.03,172.02Z"
        }, null, -1)),
        Mde = Tt(() => W("path", {
            class: "feathers",
            d: "m236.37,386.86c0,6.79-5.51,12.3-12.3,12.3s-12.3-5.51-12.3-12.3,5.51-12.3,12.3-12.3,12.3,5.51,12.3,12.3Zm-44.51-59.29c-9.06,0-16.4,7.34-16.4,16.4s7.34,16.4,16.4,16.4,16.4-7.34,16.4-16.4-7.34-16.4-16.4-16.4Zm158.83,25.17c-5.13,0-9.28,4.16-9.28,9.28s4.16,9.28,9.28,9.28,9.28-4.16,9.28-9.28-4.16-9.28-9.28-9.28Zm-43.44,46.42c-7.74,0-14.01,6.27-14.01,14.01s6.27,14.01,14.01,14.01,14.01-6.27,14.01-14.01-6.27-14.01-14.01-14.01Zm-63.48-115.75c-5.47,0-9.91,4.44-9.91,9.91s4.44,9.91,9.91,9.91,9.91-4.44,9.91-9.91-4.44-9.91-9.91-9.91Zm53.57,35.27c-8.5,0-15.38,6.89-15.38,15.38s6.89,15.38,15.38,15.38,15.38-6.89,15.38-15.38-6.89-15.38-15.38-15.38Zm-106.49-45.59c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm17.41-101.68c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm62.43,244.03c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm52.32-122.12c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm-66.44,63.85c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm25.37-109.33c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Zm30.77-112.84c-2.68,0-4.85,2.17-4.85,4.85s2.17,4.85,4.85,4.85,4.85-2.17,4.85-4.85-2.17-4.85-4.85-4.85Z"
        }, null, -1)),
        Dde = [Rde, Mde],
        $de = Tt(() => W("path", {
            class: "eyes",
            d: "m439.63,242.46c.33-14.78-23.12-14.9-22.75,0-.4,14.8,23.1,14.68,22.75,0Zm-129.77,5.57c0,14.91,23.17,14.78,22.75,0-.45-15.75-22.75-14.32-22.75,0Z"
        }, null, -1)),
        Lde = Tt(() => W("path", {
            class: "beak",
            d: "m345.85,298.42c5.42,46.48,82.83,42.85,88.98-.77l4.13-2.88c2.94-.32,4.77-1.09,5.47-2.3.17-15.23-11.4-29.2-23.04-37.82-30.82-20.14-79.86,6.01-75.54,43.77Z"
        }, null, -1)),
        Fde = Tt(() => W("path", {
            class: "mouth",
            d: "m437.81,295.45l.19-.19h.19c-1.11-1.38-107.2-1.04-91.76,3.36,24.28.89,66.94-1.43,89.17-1.34-.1-.42.77-.8,1.06-.96.32-.35.56-.69.96-.67.06-.13.13-.19.19-.19Z"
        }, null, -1));

    function Ude(t, e, n, r, s, i) {
        return Y(), X("svg", {
            viewBox: "0 0 500 500",
            class: mt(["avatar", `avatar-${t.avatar}`])
        }, [Nfe, W("g", xfe, [t.avatar === 0 ? (Y(), X("g", Pfe, Dfe)) : t.avatar === 1 ? (Y(), X("g", $fe, Ufe)) : t.avatar === 2 ? (Y(), X("g", Bfe, Gfe)) : t.avatar === 3 ? (Y(), X("g", Wfe, Yfe)) : t.avatar === 4 ? (Y(), X("g", zfe, Jfe)) : t.avatar === 5 ? (Y(), X("g", ede, rde)) : t.avatar === 6 ? (Y(), X("g", sde, ade)) : t.avatar === 7 ? (Y(), X("g", cde, hde)) : t.avatar === 8 ? (Y(), X("g", fde, gde)) : t.avatar === 9 ? (Y(), X("g", _de, Ede)) : t.avatar === 10 ? (Y(), X("g", Sde, Ade)) : t.avatar === 11 ? (Y(), X("g", Cde, xde)) : t.avatar === 99 ? (Y(), X("g", Pde, Dde)) : Ve("", !0), $de, Lde, Fde])], 2)
    }
    const v0 = ct(kfe, [
            ["render", Ude],
            ["__scopeId", "data-v-762a6505"]
        ]),
        Bde = yt({
            props: {
                title: {
                    type: String,
                    required: !1
                },
                titleKey: {
                    type: String,
                    required: !1
                }
            },
            emits: {
                didRequestClose: () => !0
            },
            methods: {
                onCloseClick() {
                    this.$emit("didRequestClose")
                }
            }
        }),
        GC = t => (Di("data-v-626bed06"), t = t(), $i(), t),
        qde = {
            class: "contents"
        },
        Vde = {
            class: "title-container"
        },
        jde = GC(() => W("svg", {
            class: "bg",
            viewBox: "0 0 400 50",
            preserveAspectRatio: "none"
        }, [W("polygon", {
            class: "shadow",
            points: "15.78 3.27 .78 17.86 0 30.06 13.2 46.13 383.7 48.21 400 31.55 398.45 17.56 385.51 4.46 15.78 3.27"
        }), W("polygon", {
            class: "foreground",
            points: "21.99 0 3.48 19.05 2.73 29.03 21.08 50 378.53 50 397.15 29.76 395.32 19.64 378.53 1.05 21.99 0"
        })], -1)),
        Gde = {
            key: 0,
            class: "title"
        },
        Wde = {
            key: 1,
            class: "title"
        },
        Hde = {
            class: "content-container"
        },
        Kde = GC(() => W("svg", {
            class: "bg",
            viewBox: "0 0 400 200",
            preserveAspectRatio: "none"
        }, [W("polygon", {
            class: "shadow",
            points: "30.1 1.94 4.54 19.13 0 180.59 11.36 192.24 386.65 197.78 400 183.64 400 21.35 372.45 5.55 30.1 1.94"
        }), W("polygon", {
            class: "foreground",
            points: "38.91 0 7.38 20.24 7.38 180.87 18.74 194.73 381.82 200 395.46 184.75 394.6 24.12 365.35 2.77 38.91 0"
        })], -1));

    function Yde(t, e, n, r, s, i) {
        const a = fn("t");
        return Y(), X("div", {
            class: "modal",
            onClick: e[0] || (e[0] = xi((...c) => t.onCloseClick && t.onCloseClick(...c), ["self"])),
            onKeyup: e[1] || (e[1] = Yy((...c) => t.onCloseClick && t.onCloseClick(...c), ["esc"]))
        }, [W("div", qde, [W("div", Vde, [jde, t.title ? (Y(), X("h3", Gde, _t(t.title), 1)) : Ve("", !0), t.titleKey ? Ge((Y(), X("h3", Wde, null, 512)), [
            [a, t.titleKey]
        ]) : Ve("", !0)]), W("div", Hde, [Kde, LM(t.$slots, "default", {}, void 0, !0)])])], 32)
    }
    const WC = ct(Bde, [
            ["render", Yde],
            ["__scopeId", "data-v-626bed06"]
        ]),
        zde = yt({
            components: {
                AvatarSVG: v0,
                BaseModal: WC
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                players: {
                    type: Object,
                    required: !0
                },
                responseKey: {
                    type: String,
                    required: !0
                }
            },
            emits: {
                didRequestClose: () => !0
            },
            computed: {
                choices() {
                    return Object.keys(this.players).filter(t => !(t === `${this.info.id}` || this.info.inSong && this.players[t].inSong === !1)).map(t => {
                        const e = this.players[t];
                        return {
                            avatar: e.avatar,
                            id: parseInt(t, 10),
                            label: e.name
                        }
                    })
                }
            },
            methods: {
                onCloseClick() {
                    this.$emit("didRequestClose")
                },
                async onChoiceClick(t) {
                    try {
                        await this.$ecast.updateObject(this.responseKey, {
                            changeVip: t
                        })
                    } catch (e) {
                        this.$handleEcastError(e)
                    }
                    this.$emit("didRequestClose")
                }
            }
        }),
        Zde = ["onClick"];

    function Xde(t, e, n, r, s, i) {
        const a = ot("AvatarSVG"),
            c = ot("BaseModal"),
            l = fn("t");
        return Y(), Vt(c, {
            "title-key": "MENU.CHOOSE_HOST"
        }, {
            default: cs(() => [(Y(!0), X(St, null, In(t.choices, (h, d) => (Y(), X("button", {
                key: d,
                class: "choice has-icon",
                onClick: xi(p => t.onChoiceClick(h.id), ["prevent"])
            }, [Nn(_t(h.label) + " ", 1), Qe(a, {
                focusable: "false",
                avatar: h.avatar,
                class: "icon"
            }, null, 8, ["avatar"])], 8, Zde))), 128)), Ge(W("button", {
                class: "secondary close",
                onClick: e[0] || (e[0] = (...h) => t.onCloseClick && t.onCloseClick(...h))
            }, null, 512), [
                [l, "NEVERMIND"]
            ])]),
            _: 1
        }, 8, ["title-key"])
    }
    const ym = ct(zde, [
            ["render", Xde]
        ]),
        Qde = yt({
            components: {
                AvatarSVG: v0
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                isVip: {
                    type: Boolean,
                    default: () => !1
                },
                players: {
                    type: Object,
                    required: !1
                },
                responseKey: {
                    type: String,
                    required: !1
                }
            },
            emits: {
                didRequestChangeVip: () => !0
            },
            methods: {
                async onAvatarClick() {
                    if (!this.players || !this.responseKey) return;
                    const t = Object.values(this.players).map(s => s.avatar),
                        e = [],
                        n = [];
                    let r = this.info.avatar;
                    for (let s = 0; s < 12; s++) t.includes(s) || (s < this.info.avatar ? e.push(s) : n.push(s));
                    n.length ? r = n[0] : e.length && (r = e[0]);
                    try {
                        await this.$ecast.updateObject(this.responseKey, {
                            changeAvatar: r
                        })
                    } catch (s) {
                        this.$handleEcastError(s)
                    }
                },
                onChangeHostClick() {
                    this.isVip && this.$emit("didRequestChangeVip")
                }
            }
        }),
        Jde = {
            class: "player-header"
        },
        epe = {
            class: "constrain"
        },
        tpe = {
            key: 0,
            class: "name"
        },
        npe = {
            key: 1,
            class: "name"
        },
        rpe = ["aria-label", "disabled"];

    function spe(t, e, n, r, s, i) {
        const a = ot("AvatarSVG"),
            c = fn("t"),
            l = fn("bb");
        return Y(), X("div", Jde, [W("div", epe, [t.info.isAudience ? Ge((Y(), X("p", tpe, null, 512)), [
            [c, "AUDIENCE.NAME"]
        ]) : (Y(), X("p", npe, _t(t.info.name), 1)), W("button", {
            class: "change-avatar",
            "aria-label": t.$t("ARIA.CHANGE_AVATAR"),
            disabled: !t.responseKey,
            onClick: e[0] || (e[0] = (...h) => t.onAvatarClick && t.onAvatarClick(...h))
        }, [Qe(a, {
            focusable: "false",
            avatar: t.info.avatar
        }, null, 8, ["avatar"])], 8, rpe), t.isVip ? Ge((Y(), X("button", {
            key: 2,
            class: "change-host",
            onClick: e[1] || (e[1] = (...h) => t.onChangeHostClick && t.onChangeHostClick(...h))
        }, null, 512)), [
            [l, t.$t("MENU.CHANGE_HOST")]
        ]) : Ve("", !0)])])
    }
    const fu = ct(Qde, [
            ["render", spe],
            ["__scopeId", "data-v-8ebc1bd5"]
        ]),
        ipe = yt({
            components: {
                ChangeVIP: ym,
                PlayerHeader: fu
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                },
                players: {
                    type: Object,
                    required: !0
                },
                renders: {
                    type: Array,
                    required: !0
                }
            },
            data() {
                return {
                    showChangeVIP: !1
                }
            },
            computed: {
                vipName() {
                    const t = Object.keys(this.players).find(e => this.players[e].isVip);
                    return t !== void 0 ? this.players[t].name : ""
                }
            },
            methods: {
                onDidRequestChangeVIP() {
                    this.showChangeVIP = !0
                },
                onDidRequestModalClose() {
                    this.showChangeVIP = !1
                },
                async onChoiceClick(t) {
                    if (this.player.responseKey) try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            [t]: !0
                        })
                    } catch (e) {
                        this.$handleEcastError(e)
                    }
                },
                async onShareClick(t) {
                    const e = {
                        title: t.title,
                        text: t.survived ? "WE SURVIVED" : "WE WERE LUNCH",
                        url: t.renderUrl
                    };
                    try {
                        const n = await navigator.share(e)
                    } catch (n) {
                        console.warn(n)
                    }
                }
            }
        }),
        ope = {
            class: "credits"
        },
        ape = {
            class: "constrain menu has-header"
        },
        cpe = {
            class: "title-wrapper"
        },
        upe = {
            key: 0,
            class: "title"
        },
        lpe = {
            key: 0,
            class: "choices-wrapper"
        },
        hpe = {
            class: "choices"
        },
        fpe = {
            class: "title"
        },
        dpe = {
            class: "shareables"
        },
        ppe = {
            class: "name"
        },
        mpe = {
            preload: "none",
            controls: ""
        },
        gpe = ["src"],
        _pe = ["onClick"];

    function ype(t, e, n, r, s, i) {
        const a = ot("PlayerHeader"),
            c = ot("ChangeVIP"),
            l = fn("t");
        return Y(), X("div", ope, [W("div", ape, [W("div", cpe, [t.info.isVip ? Ge((Y(), X("h3", upe, null, 512)), [
            [l, "POST_GAME.PLAY_AGAIN"]
        ]) : Ve("", !0)]), t.info.isVip ? (Y(), X("div", lpe, [W("div", hpe, [Ge(W("button", {
            onClick: e[0] || (e[0] = h => t.onChoiceClick("back"))
        }, null, 512), [
            [l, "MENU.BACK_TO_MENU"]
        ])])])) : Ve("", !0), Ge(W("h3", fpe, null, 512), [
            [l, "CREDITS.SHARE"]
        ]), W("div", dpe, [(Y(!0), X(St, null, In(t.renders, (h, d) => (Y(), X("div", {
            key: d,
            class: "sharable"
        }, [W("p", ppe, _t(h.title), 1), W("audio", mpe, [W("source", {
            src: h.renderUrl,
            type: "audio/mpeg"
        }, null, 8, gpe)]), W("button", {
            onClick: p => t.onShareClick(h)
        }, "SHARE", 8, _pe)]))), 128))])]), Qe(a, {
            info: t.info,
            "is-vip": t.info.isVip && !t.info.isSolo,
            players: t.players,
            "response-key": t.player.responseKey,
            onDidRequestChangeVip: t.onDidRequestChangeVIP
        }, null, 8, ["info", "is-vip", "players", "response-key", "onDidRequestChangeVip"]), Qe(xs, {
            name: "modal"
        }, {
            default: cs(() => [t.showChangeVIP ? (Y(), Vt(c, {
                key: 0,
                info: t.info,
                players: t.players,
                "response-key": t.player.responseKey,
                onDidRequestClose: t.onDidRequestModalClose
            }, null, 8, ["info", "players", "response-key", "onDidRequestClose"])) : Ve("", !0)]),
            _: 1
        })])
    }
    const vpe = ct(ipe, [
        ["render", ype]
    ]);
    class Ii {
        static difficultyI18ByNumber(e) {
            return this.difficulty.numberToI18n[e]
        }
        static categoryI18nBySlug(e) {
            return this.category.slugToI18n[e]
        }
        static categoryI18ByKey(e) {
            return this.category.keyToI18n[e]
        }
        static categoryKeyBySlug(e) {
            return this.category.slugToKey[e]
        }
        static categorySlugByKey(e) {
            return this.category.keyToSlug[e]
        }
        static instrumentIconBySlug(e) {
            return this.instrument.slugToIcon[e]
        }
    }
    Ce(Ii, "difficulty", {
        numberToI18n: ["", "DIFFICULTY.VERY_EASY", "DIFFICULTY.EASY", "DIFFICULTY.MEDIUM", "DIFFICULTY.HARD", "DIFFICULTY.VERY_HARD"]
    }), Ce(Ii, "category", {
        slugToI18n: {
            "aux-percussion": "BEATMAPS.PERCUSSION",
            bass: "BEATMAPS.BASS",
            "counter-melody": "BEATMAPS.COUNTER",
            drums: "BEATMAPS.DRUMS",
            harmony: "BEATMAPS.HARMONY",
            melody: "BEATMAPS.MELODY",
            signature: "BEATMAPS.SIGNATURE"
        },
        keyToI18n: {
            AuxPercussion: "BEATMAPS.PERCUSSION",
            Bass: "BEATMAPS.BASS",
            CounterMelody: "BEATMAPS.COUNTER",
            Drums: "BEATMAPS.DRUMS",
            Harmony: "BEATMAPS.HARMONY",
            Melody: "BEATMAPS.MELODY",
            Signature: "BEATMAPS.SIGNATURE"
        },
        slugToKey: {
            "aux-percussion": "AuxPercussion",
            bass: "Bass",
            "counter-melody": "CounterMelody",
            drums: "Drums",
            harmony: "Harmony",
            melody: "Melody",
            signature: "Signature"
        },
        keyToSlug: {
            AuxPercussion: "aux-percussion",
            Bass: "bass",
            CounterMelody: "counter-melody",
            Drums: "drums",
            Harmony: "harmony",
            Melody: "melody",
            Signature: "signature"
        }
    }), Ce(Ii, "instrument", {
        slugToIcon: {
            "agnes-the-dog": "dog",
            "agnes-the-dog-howls": "dog",
            "alarm-clock": "clock",
            "arp-synth": "synth",
            banjo: "banjo",
            "bari-sax": "sax",
            "bass-flute": "flute",
            bassoon: "flute",
            beatbox: "mouth",
            bitdrums: "synth",
            bottlecaps: "shaker",
            "burpin-conga": "mouth",
            "burps-melody": "mouth",
            cajon: "woodblock",
            cannon: "canon",
            "car-alarm": "car",
            castanets: "castanets",
            "casual-saxophone": "sax",
            caxixi: "shaker",
            "cello-bowed": "cello",
            "cello-plucked": "cello",
            "cheeks-melody": "mouth",
            "cheeks-percussion": "mouth",
            clarinet: "flute",
            "constant-scream": "mouth",
            "continuous-doug": "mouth",
            "continuous-jan": "mouth",
            "continuous-kazoo": "kazoo",
            "continuous-natures-bugle": "poop",
            "contrabass-clarinet": "flute",
            "contrabass-flute": "flute",
            contrabassoon: "flute",
            "cow-bell": "bell",
            cussin: "mouth",
            didgeridoo: "whistle",
            "dinner-bell": "bell",
            "dj-drums": "synth",
            "double-bass-bowed": "cello",
            "double-bass-plucked": "cello",
            doug: "mouth",
            "drum-set-clean": "drumKit",
            "eb-soprano-clarinet": "flute",
            "electric-bass": "guitar",
            euphonium: "tuba",
            "extra-sloppy-horn": "trombone",
            "extra-tall-bongos": "tallBongo",
            "fast-food-cup": "cup",
            "field-drums": "snare",
            flugelhorn: "frenchHorn",
            flute: "flute",
            "french-horn-redo": "frenchHorn",
            gargles: "mouth",
            gong: "gong",
            "grandmas-piano": "piano",
            guiro: "fish",
            "guitar-acoustic-chords": "guitar",
            "guitar-acoustic-notes": "guitar",
            "guitar-electric-chords": "guitar",
            "guitar-electric-noamp": "guitar",
            "guitar-metal-chords": "guitar",
            "guitar-metal-notes": "guitar",
            "guitar-rock-chords": "guitar",
            "guitar-rock-notes": "guitar",
            "h0-ly-crap": "poop",
            "husky-clarinet": "flute",
            "jaw-harp": "mouth",
            "jazz-drums": "drumKit",
            kazoo: "kazoo",
            "kettle-drums": "snare",
            "kung-fu-drums": "hands",
            "lil-ukulele-friend-redo": "guitar",
            "lip-flipper": "mouth",
            "little-congas": "bongos",
            "marching-bass-drum": "snare",
            "marching-drums": "snare",
            marimba: "xylophone",
            mario: "mouth",
            "mommy-sax": "sax",
            "music-box": "woodblock",
            oboe: "flute",
            ocarina: "ocarina",
            piccolo: "flute",
            "piccolo-trumpet": "trumpet",
            "pieces-of-wood": "sticks",
            "pluck-synth": "synth",
            "plucky-violin": "cello",
            "plucky-violins-cousin": "cello",
            "pots-n-pans": "pots",
            "rain-stick": "whistle",
            "rave-synth": "synth",
            rhodes: "piano",
            "robot-synth": "synth",
            "shaky-shaker": "shaker",
            "shy-flute": "flute",
            "sloppy-horn-sampler": "trombone",
            "sloppy-horn-senior": "trombone",
            "snap-clap-stomp": "hands",
            "snare-drum": "snare",
            "squeeze-box": "accordion",
            "tall-bongos": "tallBongo",
            tamborine: "tamborine",
            "taz-the-cat": "cat",
            "the-beef": "synth",
            tootsaphone: "sax",
            trumpet: "trumpet",
            tuba: "tuba",
            tutorial: "cap",
            "uncle-sax": "sax",
            vibes: "xylophone",
            vibraslap: "vibraslap",
            violin: "cello",
            "violins-cousin": "cello",
            "voice-alto": "mouth",
            "voice-soprano": "mouth",
            "weird-oboe": "flute",
            whistle: "mouth",
            "wind-chimes": "chimes",
            "wobble-bass": "guitar",
            "wood-block": "woodblock"
        }
    });
    const HC = "14.7.77",
        C3 = (t, e, n) => ({
            endTime: e,
            insertTime: n,
            type: "exponentialRampToValue",
            value: t
        }),
        I3 = (t, e, n) => ({
            endTime: e,
            insertTime: n,
            type: "linearRampToValue",
            value: t
        }),
        iy = (t, e) => ({
            startTime: e,
            type: "setValue",
            value: t
        }),
        KC = (t, e, n) => ({
            duration: n,
            startTime: e,
            type: "setValueCurve",
            values: t
        }),
        YC = (t, e, {
            startTime: n,
            target: r,
            timeConstant: s
        }) => r + (e - r) * Math.exp((n - t) / s),
        hc = t => t.type === "exponentialRampToValue",
        xd = t => t.type === "linearRampToValue",
        ao = t => hc(t) || xd(t),
        b0 = t => t.type === "setValue",
        Ti = t => t.type === "setValueCurve",
        Pd = (t, e, n, r) => {
            const s = t[e];
            return s === void 0 ? r : ao(s) || b0(s) ? s.value : Ti(s) ? s.values[s.values.length - 1] : YC(n, Pd(t, e - 1, s.startTime, r), s)
        },
        k3 = (t, e, n, r, s) => n === void 0 ? [r.insertTime, s] : ao(n) ? [n.endTime, n.value] : b0(n) ? [n.startTime, n.value] : Ti(n) ? [n.startTime + n.duration, n.values[n.values.length - 1]] : [n.startTime, Pd(t, e - 1, n.startTime, s)],
        oy = t => t.type === "cancelAndHold",
        ay = t => t.type === "cancelScheduledValues",
        ro = t => oy(t) || ay(t) ? t.cancelTime : hc(t) || xd(t) ? t.endTime : t.startTime,
        N3 = (t, e, n, {
            endTime: r,
            value: s
        }) => n === s ? s : 0 < n && 0 < s || n < 0 && s < 0 ? n * (s / n) ** ((t - e) / (r - e)) : 0,
        x3 = (t, e, n, {
            endTime: r,
            value: s
        }) => n + (t - e) / (r - e) * (s - n),
        bpe = (t, e) => {
            const n = Math.floor(e),
                r = Math.ceil(e);
            return n === r ? t[n] : (1 - (e - n)) * t[n] + (1 - (r - e)) * t[r]
        },
        Epe = (t, {
            duration: e,
            startTime: n,
            values: r
        }) => {
            const s = (t - n) / e * (r.length - 1);
            return bpe(r, s)
        },
        Uf = t => t.type === "setTarget";
    class Spe {
        constructor(e) {
            this._automationEvents = [], this._currenTime = 0, this._defaultValue = e
        } [Symbol.iterator]() {
            return this._automationEvents[Symbol.iterator]()
        }
        add(e) {
            const n = ro(e);
            if (oy(e) || ay(e)) {
                const r = this._automationEvents.findIndex(i => ay(e) && Ti(i) ? i.startTime + i.duration >= n : ro(i) >= n),
                    s = this._automationEvents[r];
                if (r !== -1 && (this._automationEvents = this._automationEvents.slice(0, r)), oy(e)) {
                    const i = this._automationEvents[this._automationEvents.length - 1];
                    if (s !== void 0 && ao(s)) {
                        if (Uf(i)) throw new Error("The internal list is malformed.");
                        const a = Ti(i) ? i.startTime + i.duration : ro(i),
                            c = Ti(i) ? i.values[i.values.length - 1] : i.value,
                            l = hc(s) ? N3(n, a, c, s) : x3(n, a, c, s),
                            h = hc(s) ? C3(l, n, this._currenTime) : I3(l, n, this._currenTime);
                        this._automationEvents.push(h)
                    }
                    i !== void 0 && Uf(i) && this._automationEvents.push(iy(this.getValue(n), n)), i !== void 0 && Ti(i) && i.startTime + i.duration > n && (this._automationEvents[this._automationEvents.length - 1] = KC(new Float32Array([6, 7]), i.startTime, n - i.startTime))
                }
            } else {
                const r = this._automationEvents.findIndex(a => ro(a) > n),
                    s = r === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[r - 1];
                if (s !== void 0 && Ti(s) && ro(s) + s.duration > n) return !1;
                const i = hc(e) ? C3(e.value, e.endTime, this._currenTime) : xd(e) ? I3(e.value, n, this._currenTime) : e;
                if (r === -1) this._automationEvents.push(i);
                else {
                    if (Ti(e) && n + e.duration > ro(this._automationEvents[r])) return !1;
                    this._automationEvents.splice(r, 0, i)
                }
            }
            return !0
        }
        flush(e) {
            const n = this._automationEvents.findIndex(r => ro(r) > e);
            if (n > 1) {
                const r = this._automationEvents.slice(n - 1),
                    s = r[0];
                Uf(s) && r.unshift(iy(Pd(this._automationEvents, n - 2, s.startTime, this._defaultValue), s.startTime)), this._automationEvents = r
            }
        }
        getValue(e) {
            if (this._automationEvents.length === 0) return this._defaultValue;
            const n = this._automationEvents.findIndex(a => ro(a) > e),
                r = this._automationEvents[n],
                s = (n === -1 ? this._automationEvents.length : n) - 1,
                i = this._automationEvents[s];
            if (i !== void 0 && Uf(i) && (r === void 0 || !ao(r) || r.insertTime > e)) return YC(e, Pd(this._automationEvents, s - 1, i.startTime, this._defaultValue), i);
            if (i !== void 0 && b0(i) && (r === void 0 || !ao(r))) return i.value;
            if (i !== void 0 && Ti(i) && (r === void 0 || !ao(r) || i.startTime + i.duration > e)) return e < i.startTime + i.duration ? Epe(e, i) : i.values[i.values.length - 1];
            if (i !== void 0 && ao(i) && (r === void 0 || !ao(r))) return i.value;
            if (r !== void 0 && hc(r)) {
                const [a, c] = k3(this._automationEvents, s, i, r, this._defaultValue);
                return N3(e, a, c, r)
            }
            if (r !== void 0 && xd(r)) {
                const [a, c] = k3(this._automationEvents, s, i, r, this._defaultValue);
                return x3(e, a, c, r)
            }
            return this._defaultValue
        }
    }
    const Tpe = t => ({
            cancelTime: t,
            type: "cancelAndHold"
        }),
        wpe = t => ({
            cancelTime: t,
            type: "cancelScheduledValues"
        }),
        Ope = (t, e) => ({
            endTime: e,
            type: "exponentialRampToValue",
            value: t
        }),
        Ape = (t, e) => ({
            endTime: e,
            type: "linearRampToValue",
            value: t
        }),
        Cpe = (t, e, n) => ({
            startTime: e,
            target: t,
            timeConstant: n,
            type: "setTarget"
        }),
        Ipe = () => new DOMException("", "AbortError"),
        kpe = t => (e, n, [r, s, i], a) => {
            t(e[s], [n, r, i], c => c[0] === n && c[1] === r, a)
        },
        Npe = t => (e, n, r) => {
            const s = [];
            for (let i = 0; i < r.numberOfInputs; i += 1) s.push(new Set);
            t.set(e, {
                activeInputs: s,
                outputs: new Set,
                passiveInputs: new WeakMap,
                renderer: n
            })
        },
        xpe = t => (e, n) => {
            t.set(e, {
                activeInputs: new Set,
                passiveInputs: new WeakMap,
                renderer: n
            })
        },
        Bc = new WeakSet,
        zC = new WeakMap,
        E0 = new WeakMap,
        ZC = new WeakMap,
        S0 = new WeakMap,
        vm = new WeakMap,
        XC = new WeakMap,
        cy = new WeakMap,
        uy = new WeakMap,
        ly = new WeakMap,
        QC = {
            construct() {
                return QC
            }
        },
        Ppe = t => {
            try {
                const e = new Proxy(t, QC);
                new e
            } catch {
                return !1
            }
            return !0
        },
        P3 = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/,
        R3 = (t, e) => {
            const n = [];
            let r = t.replace(/^[\s]+/, ""),
                s = r.match(P3);
            for (; s !== null;) {
                const i = s[1].slice(1, -1),
                    a = s[0].replace(/([\s]+)?;?$/, "").replace(i, new URL(i, e).toString());
                n.push(a), r = r.slice(s[0].length).replace(/^[\s]+/, ""), s = r.match(P3)
            }
            return [n.join(";"), r]
        },
        M3 = t => {
            if (t !== void 0 && !Array.isArray(t)) throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")
        },
        D3 = t => {
            if (!Ppe(t)) throw new TypeError("The given value for processorCtor should be a constructor.");
            if (t.prototype === null || typeof t.prototype != "object") throw new TypeError("The given value for processorCtor should have a prototype.")
        },
        Rpe = (t, e, n, r, s, i, a, c, l, h, d, p, g) => {
            let v = 0;
            return (b, T, m = {
                credentials: "omit"
            }) => {
                const w = d.get(b);
                if (w !== void 0 && w.has(T)) return Promise.resolve();
                const P = h.get(b);
                if (P !== void 0) {
                    const I = P.get(T);
                    if (I !== void 0) return I
                }
                const V = i(b),
                    M = V.audioWorklet === void 0 ? s(T).then(([I, L]) => {
                        const [B, q] = R3(I, L), se = `${B};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${q}
})})(window,'_AWGS')`;
                        return n(se)
                    }).then(() => {
                        const I = g._AWGS.pop();
                        if (I === void 0) throw new SyntaxError;
                        r(V.currentTime, V.sampleRate, () => I(class {}, void 0, (L, B) => {
                            if (L.trim() === "") throw e();
                            const q = uy.get(V);
                            if (q !== void 0) {
                                if (q.has(L)) throw e();
                                D3(B), M3(B.parameterDescriptors), q.set(L, B)
                            } else D3(B), M3(B.parameterDescriptors), uy.set(V, new Map([
                                [L, B]
                            ]))
                        }, V.sampleRate, void 0, void 0))
                    }) : Promise.all([s(T), Promise.resolve(t(p, p))]).then(([
                        [I, L], B
                    ]) => {
                        const q = v + 1;
                        v = q;
                        const [se, ce] = R3(I, L), G = `${se};((AudioWorkletProcessor,registerProcessor)=>{${ce}
})(${B?"AudioWorkletProcessor":"class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${B?"":"__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${B?"":"i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${q}',class extends AudioWorkletProcessor{process(){return !1}})`, le = new Blob([G], {
                            type: "application/javascript; charset=utf-8"
                        }), fe = URL.createObjectURL(le);
                        return V.audioWorklet.addModule(fe, m).then(() => {
                            if (c(V)) return V;
                            const me = a(V);
                            return me.audioWorklet.addModule(fe, m).then(() => me)
                        }).then(me => {
                            if (l === null) throw new SyntaxError;
                            try {
                                new l(me, `__sac${q}`)
                            } catch {
                                throw new SyntaxError
                            }
                        }).finally(() => URL.revokeObjectURL(fe))
                    });
                return P === void 0 ? h.set(b, new Map([
                    [T, M]
                ])) : P.set(T, M), M.then(() => {
                    const I = d.get(b);
                    I === void 0 ? d.set(b, new Set([T])) : I.add(T)
                }).finally(() => {
                    const I = h.get(b);
                    I !== void 0 && I.delete(T)
                }), M
            }
        },
        As = (t, e) => {
            const n = t.get(e);
            if (n === void 0) throw new Error("A value with the given key could not be found.");
            return n
        },
        bm = (t, e) => {
            const n = Array.from(t).filter(e);
            if (n.length > 1) throw Error("More than one element was found.");
            if (n.length === 0) throw Error("No element was found.");
            const [r] = n;
            return t.delete(r), r
        },
        JC = (t, e, n, r) => {
            const s = As(t, e),
                i = bm(s, a => a[0] === n && a[1] === r);
            return s.size === 0 && t.delete(e), i
        },
        uh = t => As(XC, t),
        qc = t => {
            if (Bc.has(t)) throw new Error("The AudioNode is already stored.");
            Bc.add(t), uh(t).forEach(e => e(!0))
        },
        eI = t => "port" in t,
        lh = t => {
            if (!Bc.has(t)) throw new Error("The AudioNode is not stored.");
            Bc.delete(t), uh(t).forEach(e => e(!1))
        },
        hy = (t, e) => {
            !eI(t) && e.every(n => n.size === 0) && lh(t)
        },
        Mpe = (t, e, n, r, s, i, a, c, l, h, d, p, g) => {
            const v = new WeakMap;
            return (b, T, m, w, P) => {
                const {
                    activeInputs: V,
                    passiveInputs: M
                } = i(T), {
                    outputs: I
                } = i(b), L = c(b), B = q => {
                    const se = l(T),
                        ce = l(b);
                    if (q) {
                        const ue = JC(M, b, m, w);
                        t(V, b, ue, !1), !P && !p(b) && n(ce, se, m, w), g(T) && qc(T)
                    } else {
                        const ue = r(V, b, m, w);
                        e(M, w, ue, !1), !P && !p(b) && s(ce, se, m, w);
                        const ee = a(T);
                        if (ee === 0) d(T) && hy(T, V);
                        else {
                            const ge = v.get(T);
                            ge !== void 0 && clearTimeout(ge), v.set(T, setTimeout(() => {
                                d(T) && hy(T, V)
                            }, ee * 1e3))
                        }
                    }
                };
                return h(I, [T, m, w], q => q[0] === T && q[1] === m && q[2] === w, !0) ? (L.add(B), d(b) ? t(V, b, [m, w, B], !0) : e(M, w, [b, m, B], !0), !0) : !1
            }
        },
        Dpe = t => (e, n, [r, s, i], a) => {
            const c = e.get(r);
            c === void 0 ? e.set(r, new Set([
                [s, n, i]
            ])) : t(c, [s, n, i], l => l[0] === s && l[1] === n, a)
        },
        $pe = t => (e, n) => {
            const r = t(e, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                gain: 0
            });
            n.connect(r).connect(e.destination);
            const s = () => {
                n.removeEventListener("ended", s), n.disconnect(r), r.disconnect()
            };
            n.addEventListener("ended", s)
        },
        Lpe = t => (e, n) => {
            t(e).add(n)
        },
        Fpe = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            fftSize: 2048,
            maxDecibels: -30,
            minDecibels: -100,
            smoothingTimeConstant: .8
        },
        Upe = (t, e, n, r, s, i) => class extends t {
            constructor(c, l) {
                const h = s(c),
                    d = {
                        ...Fpe,
                        ...l
                    },
                    p = r(h, d),
                    g = i(h) ? e() : null;
                super(c, !1, p, g), this._nativeAnalyserNode = p
            }
            get fftSize() {
                return this._nativeAnalyserNode.fftSize
            }
            set fftSize(c) {
                this._nativeAnalyserNode.fftSize = c
            }
            get frequencyBinCount() {
                return this._nativeAnalyserNode.frequencyBinCount
            }
            get maxDecibels() {
                return this._nativeAnalyserNode.maxDecibels
            }
            set maxDecibels(c) {
                const l = this._nativeAnalyserNode.maxDecibels;
                if (this._nativeAnalyserNode.maxDecibels = c, !(c > this._nativeAnalyserNode.minDecibels)) throw this._nativeAnalyserNode.maxDecibels = l, n()
            }
            get minDecibels() {
                return this._nativeAnalyserNode.minDecibels
            }
            set minDecibels(c) {
                const l = this._nativeAnalyserNode.minDecibels;
                if (this._nativeAnalyserNode.minDecibels = c, !(this._nativeAnalyserNode.maxDecibels > c)) throw this._nativeAnalyserNode.minDecibels = l, n()
            }
            get smoothingTimeConstant() {
                return this._nativeAnalyserNode.smoothingTimeConstant
            }
            set smoothingTimeConstant(c) {
                this._nativeAnalyserNode.smoothingTimeConstant = c
            }
            getByteFrequencyData(c) {
                this._nativeAnalyserNode.getByteFrequencyData(c)
            }
            getByteTimeDomainData(c) {
                this._nativeAnalyserNode.getByteTimeDomainData(c)
            }
            getFloatFrequencyData(c) {
                this._nativeAnalyserNode.getFloatFrequencyData(c)
            }
            getFloatTimeDomainData(c) {
                this._nativeAnalyserNode.getFloatTimeDomainData(c)
            }
        },
        ir = (t, e) => t.context === e,
        Bpe = (t, e, n) => () => {
            const r = new WeakMap,
                s = async (i, a) => {
                    let c = e(i);
                    if (!ir(c, a)) {
                        const h = {
                            channelCount: c.channelCount,
                            channelCountMode: c.channelCountMode,
                            channelInterpretation: c.channelInterpretation,
                            fftSize: c.fftSize,
                            maxDecibels: c.maxDecibels,
                            minDecibels: c.minDecibels,
                            smoothingTimeConstant: c.smoothingTimeConstant
                        };
                        c = t(a, h)
                    }
                    return r.set(a, c), await n(i, a, c), c
                };
            return {
                render(i, a) {
                    const c = r.get(a);
                    return c !== void 0 ? Promise.resolve(c) : s(i, a)
                }
            }
        },
        Rd = t => {
            try {
                t.copyToChannel(new Float32Array(1), 0, -1)
            } catch {
                return !1
            }
            return !0
        },
        ii = () => new DOMException("", "IndexSizeError"),
        T0 = t => {
            t.getChannelData = (e => n => {
                try {
                    return e.call(t, n)
                } catch (r) {
                    throw r.code === 12 ? ii() : r
                }
            })(t.getChannelData)
        },
        qpe = {
            numberOfChannels: 1
        },
        Vpe = (t, e, n, r, s, i, a, c) => {
            let l = null;
            return class tI {
                constructor(d) {
                    if (s === null) throw new Error("Missing the native OfflineAudioContext constructor.");
                    const {
                        length: p,
                        numberOfChannels: g,
                        sampleRate: v
                    } = {
                        ...qpe,
                        ...d
                    };
                    l === null && (l = new s(1, 1, 44100));
                    const b = r !== null && e(i, i) ? new r({
                        length: p,
                        numberOfChannels: g,
                        sampleRate: v
                    }) : l.createBuffer(g, p, v);
                    if (b.numberOfChannels === 0) throw n();
                    return typeof b.copyFromChannel != "function" ? (a(b), T0(b)) : e(Rd, () => Rd(b)) || c(b), t.add(b), b
                }
                static[Symbol.hasInstance](d) {
                    return d !== null && typeof d == "object" && Object.getPrototypeOf(d) === tI.prototype || t.has(d)
                }
            }
        },
        Tr = -34028234663852886e22,
        hr = -Tr,
        ki = t => Bc.has(t),
        jpe = {
            buffer: null,
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            loop: !1,
            loopEnd: 0,
            loopStart: 0,
            playbackRate: 1
        },
        Gpe = (t, e, n, r, s, i, a, c) => class extends t {
            constructor(h, d) {
                const p = i(h),
                    g = {
                        ...jpe,
                        ...d
                    },
                    v = s(p, g),
                    b = a(p),
                    T = b ? e() : null;
                super(h, !1, v, T), this._audioBufferSourceNodeRenderer = T, this._isBufferNullified = !1, this._isBufferSet = g.buffer !== null, this._nativeAudioBufferSourceNode = v, this._onended = null, this._playbackRate = n(this, b, v.playbackRate, hr, Tr)
            }
            get buffer() {
                return this._isBufferNullified ? null : this._nativeAudioBufferSourceNode.buffer
            }
            set buffer(h) {
                if (this._nativeAudioBufferSourceNode.buffer = h, h !== null) {
                    if (this._isBufferSet) throw r();
                    this._isBufferSet = !0
                }
            }
            get loop() {
                return this._nativeAudioBufferSourceNode.loop
            }
            set loop(h) {
                this._nativeAudioBufferSourceNode.loop = h
            }
            get loopEnd() {
                return this._nativeAudioBufferSourceNode.loopEnd
            }
            set loopEnd(h) {
                this._nativeAudioBufferSourceNode.loopEnd = h
            }
            get loopStart() {
                return this._nativeAudioBufferSourceNode.loopStart
            }
            set loopStart(h) {
                this._nativeAudioBufferSourceNode.loopStart = h
            }
            get onended() {
                return this._onended
            }
            set onended(h) {
                const d = typeof h == "function" ? c(this, h) : null;
                this._nativeAudioBufferSourceNode.onended = d;
                const p = this._nativeAudioBufferSourceNode.onended;
                this._onended = p !== null && p === d ? h : p
            }
            get playbackRate() {
                return this._playbackRate
            }
            start(h = 0, d = 0, p) {
                if (this._nativeAudioBufferSourceNode.start(h, d, p), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.start = p === void 0 ? [h, d] : [h, d, p]), this.context.state !== "closed") {
                    qc(this);
                    const g = () => {
                        this._nativeAudioBufferSourceNode.removeEventListener("ended", g), ki(this) && lh(this)
                    };
                    this._nativeAudioBufferSourceNode.addEventListener("ended", g)
                }
            }
            stop(h = 0) {
                this._nativeAudioBufferSourceNode.stop(h), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.stop = h)
            }
        },
        Wpe = (t, e, n, r, s) => () => {
            const i = new WeakMap;
            let a = null,
                c = null;
            const l = async (h, d) => {
                let p = n(h);
                const g = ir(p, d);
                if (!g) {
                    const v = {
                        buffer: p.buffer,
                        channelCount: p.channelCount,
                        channelCountMode: p.channelCountMode,
                        channelInterpretation: p.channelInterpretation,
                        loop: p.loop,
                        loopEnd: p.loopEnd,
                        loopStart: p.loopStart,
                        playbackRate: p.playbackRate.value
                    };
                    p = e(d, v), a !== null && p.start(...a), c !== null && p.stop(c)
                }
                return i.set(d, p), g ? await t(d, h.playbackRate, p.playbackRate) : await r(d, h.playbackRate, p.playbackRate), await s(h, d, p), p
            };
            return {
                set start(h) {
                    a = h
                },
                set stop(h) {
                    c = h
                },
                render(h, d) {
                    const p = i.get(d);
                    return p !== void 0 ? Promise.resolve(p) : l(h, d)
                }
            }
        },
        Hpe = t => "playbackRate" in t,
        Kpe = t => "frequency" in t && "gain" in t,
        Ype = t => "offset" in t,
        zpe = t => !("frequency" in t) && "gain" in t,
        Zpe = t => "detune" in t && "frequency" in t,
        Xpe = t => "pan" in t,
        fr = t => As(zC, t),
        hh = t => As(ZC, t),
        fy = (t, e) => {
            const {
                activeInputs: n
            } = fr(t);
            n.forEach(s => s.forEach(([i]) => {
                e.includes(t) || fy(i, [...e, t])
            }));
            const r = Hpe(t) ? [t.playbackRate] : eI(t) ? Array.from(t.parameters.values()) : Kpe(t) ? [t.Q, t.detune, t.frequency, t.gain] : Ype(t) ? [t.offset] : zpe(t) ? [t.gain] : Zpe(t) ? [t.detune, t.frequency] : Xpe(t) ? [t.pan] : [];
            for (const s of r) {
                const i = hh(s);
                i !== void 0 && i.activeInputs.forEach(([a]) => fy(a, e))
            }
            ki(t) && lh(t)
        },
        nI = t => {
            fy(t.destination, [])
        },
        Qpe = t => t === void 0 || typeof t == "number" || typeof t == "string" && (t === "balanced" || t === "interactive" || t === "playback"),
        Jpe = (t, e, n, r, s, i, a, c, l) => class extends t {
            constructor(d = {}) {
                if (l === null) throw new Error("Missing the native AudioContext constructor.");
                let p;
                try {
                    p = new l(d)
                } catch (b) {
                    throw b.code === 12 && b.message === "sampleRate is not in range" ? n() : b
                }
                if (p === null) throw r();
                if (!Qpe(d.latencyHint)) throw new TypeError(`The provided value '${d.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
                if (d.sampleRate !== void 0 && p.sampleRate !== d.sampleRate) throw n();
                super(p, 2);
                const {
                    latencyHint: g
                } = d, {
                    sampleRate: v
                } = p;
                if (this._baseLatency = typeof p.baseLatency == "number" ? p.baseLatency : g === "balanced" ? 512 / v : g === "interactive" || g === void 0 ? 256 / v : g === "playback" ? 1024 / v : Math.max(2, Math.min(128, Math.round(g * v / 128))) * 128 / v, this._nativeAudioContext = p, l.name === "webkitAudioContext" ? (this._nativeGainNode = p.createGain(), this._nativeOscillatorNode = p.createOscillator(), this._nativeGainNode.gain.value = 1e-37, this._nativeOscillatorNode.connect(this._nativeGainNode).connect(p.destination), this._nativeOscillatorNode.start()) : (this._nativeGainNode = null, this._nativeOscillatorNode = null), this._state = null, p.state === "running") {
                    this._state = "suspended";
                    const b = () => {
                        this._state === "suspended" && (this._state = null), p.removeEventListener("statechange", b)
                    };
                    p.addEventListener("statechange", b)
                }
            }
            get baseLatency() {
                return this._baseLatency
            }
            get state() {
                return this._state !== null ? this._state : this._nativeAudioContext.state
            }
            close() {
                return this.state === "closed" ? this._nativeAudioContext.close().then(() => {
                    throw e()
                }) : (this._state === "suspended" && (this._state = null), this._nativeAudioContext.close().then(() => {
                    this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(), this._nativeGainNode.disconnect(), this._nativeOscillatorNode.disconnect()), nI(this)
                }))
            }
            createMediaElementSource(d) {
                return new s(this, {
                    mediaElement: d
                })
            }
            createMediaStreamDestination() {
                return new i(this)
            }
            createMediaStreamSource(d) {
                return new a(this, {
                    mediaStream: d
                })
            }
            createMediaStreamTrackSource(d) {
                return new c(this, {
                    mediaStreamTrack: d
                })
            }
            resume() {
                return this._state === "suspended" ? new Promise((d, p) => {
                    const g = () => {
                        this._nativeAudioContext.removeEventListener("statechange", g), this._nativeAudioContext.state === "running" ? d() : this.resume().then(d, p)
                    };
                    this._nativeAudioContext.addEventListener("statechange", g)
                }) : this._nativeAudioContext.resume().catch(d => {
                    throw d === void 0 || d.code === 15 ? e() : d
                })
            }
            suspend() {
                return this._nativeAudioContext.suspend().catch(d => {
                    throw d === void 0 ? e() : d
                })
            }
        },
        eme = (t, e, n, r, s, i, a, c) => class extends t {
            constructor(h, d) {
                const p = i(h),
                    g = a(p),
                    v = s(p, d, g),
                    b = g ? e(c) : null;
                super(h, !1, v, b), this._isNodeOfNativeOfflineAudioContext = g, this._nativeAudioDestinationNode = v
            }
            get channelCount() {
                return this._nativeAudioDestinationNode.channelCount
            }
            set channelCount(h) {
                if (this._isNodeOfNativeOfflineAudioContext) throw r();
                if (h > this._nativeAudioDestinationNode.maxChannelCount) throw n();
                this._nativeAudioDestinationNode.channelCount = h
            }
            get channelCountMode() {
                return this._nativeAudioDestinationNode.channelCountMode
            }
            set channelCountMode(h) {
                if (this._isNodeOfNativeOfflineAudioContext) throw r();
                this._nativeAudioDestinationNode.channelCountMode = h
            }
            get maxChannelCount() {
                return this._nativeAudioDestinationNode.maxChannelCount
            }
        },
        tme = t => {
            const e = new WeakMap,
                n = async (r, s) => {
                    const i = s.destination;
                    return e.set(s, i), await t(r, s, i), i
                };
            return {
                render(r, s) {
                    const i = e.get(s);
                    return i !== void 0 ? Promise.resolve(i) : n(r, s)
                }
            }
        },
        nme = (t, e, n, r, s, i, a, c) => (l, h) => {
            const d = h.listener,
                p = () => {
                    const I = new Float32Array(1),
                        L = e(h, {
                            channelCount: 1,
                            channelCountMode: "explicit",
                            channelInterpretation: "speakers",
                            numberOfInputs: 9
                        }),
                        B = a(h);
                    let q = !1,
                        se = [0, 0, -1, 0, 1, 0],
                        ce = [0, 0, 0];
                    const ue = () => {
                            if (q) return;
                            q = !0;
                            const le = r(h, 256, 9, 0);
                            le.onaudioprocess = ({
                                inputBuffer: fe
                            }) => {
                                const me = [i(fe, I, 0), i(fe, I, 1), i(fe, I, 2), i(fe, I, 3), i(fe, I, 4), i(fe, I, 5)];
                                me.some((we, ke) => we !== se[ke]) && (d.setOrientation(...me), se = me);
                                const Te = [i(fe, I, 6), i(fe, I, 7), i(fe, I, 8)];
                                Te.some((we, ke) => we !== ce[ke]) && (d.setPosition(...Te), ce = Te)
                            }, L.connect(le)
                        },
                        ee = le => fe => {
                            fe !== se[le] && (se[le] = fe, d.setOrientation(...se))
                        },
                        ge = le => fe => {
                            fe !== ce[le] && (ce[le] = fe, d.setPosition(...ce))
                        },
                        G = (le, fe, me) => {
                            const Te = n(h, {
                                channelCount: 1,
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                offset: fe
                            });
                            Te.connect(L, 0, le), Te.start(), Object.defineProperty(Te.offset, "defaultValue", {
                                get() {
                                    return fe
                                }
                            });
                            const we = t({
                                context: l
                            }, B, Te.offset, hr, Tr);
                            return c(we, "value", ke => () => ke.call(we), ke => Ie => {
                                try {
                                    ke.call(we, Ie)
                                } catch ($e) {
                                    if ($e.code !== 9) throw $e
                                }
                                ue(), B && me(Ie)
                            }), we.cancelAndHoldAtTime = (ke => B ? () => {
                                throw s()
                            } : (...Ie) => {
                                const $e = ke.apply(we, Ie);
                                return ue(), $e
                            })(we.cancelAndHoldAtTime), we.cancelScheduledValues = (ke => B ? () => {
                                throw s()
                            } : (...Ie) => {
                                const $e = ke.apply(we, Ie);
                                return ue(), $e
                            })(we.cancelScheduledValues), we.exponentialRampToValueAtTime = (ke => B ? () => {
                                throw s()
                            } : (...Ie) => {
                                const $e = ke.apply(we, Ie);
                                return ue(), $e
                            })(we.exponentialRampToValueAtTime), we.linearRampToValueAtTime = (ke => B ? () => {
                                throw s()
                            } : (...Ie) => {
                                const $e = ke.apply(we, Ie);
                                return ue(), $e
                            })(we.linearRampToValueAtTime), we.setTargetAtTime = (ke => B ? () => {
                                throw s()
                            } : (...Ie) => {
                                const $e = ke.apply(we, Ie);
                                return ue(), $e
                            })(we.setTargetAtTime), we.setValueAtTime = (ke => B ? () => {
                                throw s()
                            } : (...Ie) => {
                                const $e = ke.apply(we, Ie);
                                return ue(), $e
                            })(we.setValueAtTime), we.setValueCurveAtTime = (ke => B ? () => {
                                throw s()
                            } : (...Ie) => {
                                const $e = ke.apply(we, Ie);
                                return ue(), $e
                            })(we.setValueCurveAtTime), we
                        };
                    return {
                        forwardX: G(0, 0, ee(0)),
                        forwardY: G(1, 0, ee(1)),
                        forwardZ: G(2, -1, ee(2)),
                        positionX: G(6, 0, ge(0)),
                        positionY: G(7, 0, ge(1)),
                        positionZ: G(8, 0, ge(2)),
                        upX: G(3, 0, ee(3)),
                        upY: G(4, 1, ee(4)),
                        upZ: G(5, 0, ee(5))
                    }
                },
                {
                    forwardX: g,
                    forwardY: v,
                    forwardZ: b,
                    positionX: T,
                    positionY: m,
                    positionZ: w,
                    upX: P,
                    upY: V,
                    upZ: M
                } = d.forwardX === void 0 ? p() : d;
            return {
                get forwardX() {
                    return g
                },
                get forwardY() {
                    return v
                },
                get forwardZ() {
                    return b
                },
                get positionX() {
                    return T
                },
                get positionY() {
                    return m
                },
                get positionZ() {
                    return w
                },
                get upX() {
                    return P
                },
                get upY() {
                    return V
                },
                get upZ() {
                    return M
                }
            }
        },
        Md = t => "context" in t,
        fh = t => Md(t[0]),
        Ra = (t, e, n, r) => {
            for (const s of t)
                if (n(s)) {
                    if (r) return !1;
                    throw Error("The set contains at least one similar element.")
                } return t.add(e), !0
        },
        $3 = (t, e, [n, r], s) => {
            Ra(t, [e, n, r], i => i[0] === e && i[1] === n, s)
        },
        L3 = (t, [e, n, r], s) => {
            const i = t.get(e);
            i === void 0 ? t.set(e, new Set([
                [n, r]
            ])) : Ra(i, [n, r], a => a[0] === n, s)
        },
        du = t => "inputs" in t,
        Dd = (t, e, n, r) => {
            if (du(e)) {
                const s = e.inputs[r];
                return t.connect(s, n, 0), [s, n, 0]
            }
            return t.connect(e, n, r), [e, n, r]
        },
        rI = (t, e, n) => {
            for (const r of t)
                if (r[0] === e && r[1] === n) return t.delete(r), r;
            return null
        },
        rme = (t, e, n) => bm(t, r => r[0] === e && r[1] === n),
        sI = (t, e) => {
            if (!uh(t).delete(e)) throw new Error("Missing the expected event listener.")
        },
        iI = (t, e, n) => {
            const r = As(t, e),
                s = bm(r, i => i[0] === n);
            return r.size === 0 && t.delete(e), s
        },
        $d = (t, e, n, r) => {
            du(e) ? t.disconnect(e.inputs[r], n, 0) : t.disconnect(e, n, r)
        },
        Jt = t => As(E0, t),
        Sl = t => As(S0, t),
        Ta = t => cy.has(t),
        Jf = t => !Bc.has(t),
        F3 = (t, e) => new Promise(n => {
            if (e !== null) n(!0);
            else {
                const r = t.createScriptProcessor(256, 1, 1),
                    s = t.createGain(),
                    i = t.createBuffer(1, 2, 44100),
                    a = i.getChannelData(0);
                a[0] = 1, a[1] = 1;
                const c = t.createBufferSource();
                c.buffer = i, c.loop = !0, c.connect(r).connect(t.destination), c.connect(s), c.disconnect(s), r.onaudioprocess = l => {
                    const h = l.inputBuffer.getChannelData(0);
                    Array.prototype.some.call(h, d => d === 1) ? n(!0) : n(!1), c.stop(), r.onaudioprocess = null, c.disconnect(r), r.disconnect(t.destination)
                }, c.start()
            }
        }),
        W_ = (t, e) => {
            const n = new Map;
            for (const r of t)
                for (const s of r) {
                    const i = n.get(s);
                    n.set(s, i === void 0 ? 1 : i + 1)
                }
            n.forEach((r, s) => e(s, r))
        },
        Ld = t => "context" in t,
        sme = t => {
            const e = new Map;
            t.connect = (n => (r, s = 0, i = 0) => {
                const a = Ld(r) ? n(r, s, i) : n(r, s),
                    c = e.get(r);
                return c === void 0 ? e.set(r, [{
                    input: i,
                    output: s
                }]) : c.every(l => l.input !== i || l.output !== s) && c.push({
                    input: i,
                    output: s
                }), a
            })(t.connect.bind(t)), t.disconnect = (n => (r, s, i) => {
                if (n.apply(t), r === void 0) e.clear();
                else if (typeof r == "number")
                    for (const [a, c] of e) {
                        const l = c.filter(h => h.output !== r);
                        l.length === 0 ? e.delete(a) : e.set(a, l)
                    } else if (e.has(r))
                        if (s === void 0) e.delete(r);
                        else {
                            const a = e.get(r);
                            if (a !== void 0) {
                                const c = a.filter(l => l.output !== s && (l.input !== i || i === void 0));
                                c.length === 0 ? e.delete(r) : e.set(r, c)
                            }
                        } for (const [a, c] of e) c.forEach(l => {
                    Ld(a) ? t.connect(a, l.output, l.input) : t.connect(a, l.output)
                })
            })(t.disconnect)
        },
        ime = (t, e, n, r) => {
            const {
                activeInputs: s,
                passiveInputs: i
            } = hh(e), {
                outputs: a
            } = fr(t), c = uh(t), l = h => {
                const d = Jt(t),
                    p = Sl(e);
                if (h) {
                    const g = iI(i, t, n);
                    $3(s, t, g, !1), !r && !Ta(t) && d.connect(p, n)
                } else {
                    const g = rme(s, t, n);
                    L3(i, g, !1), !r && !Ta(t) && d.disconnect(p, n)
                }
            };
            return Ra(a, [e, n], h => h[0] === e && h[1] === n, !0) ? (c.add(l), ki(t) ? $3(s, t, [n, l], !0) : L3(i, [t, n, l], !0), !0) : !1
        },
        ome = (t, e, n, r) => {
            const {
                activeInputs: s,
                passiveInputs: i
            } = fr(e), a = rI(s[r], t, n);
            return a === null ? [JC(i, t, n, r)[2], !1] : [a[2], !0]
        },
        ame = (t, e, n) => {
            const {
                activeInputs: r,
                passiveInputs: s
            } = hh(e), i = rI(r, t, n);
            return i === null ? [iI(s, t, n)[1], !1] : [i[2], !0]
        },
        w0 = (t, e, n, r, s) => {
            const [i, a] = ome(t, n, r, s);
            if (i !== null && (sI(t, i), a && !e && !Ta(t) && $d(Jt(t), Jt(n), r, s)), ki(n)) {
                const {
                    activeInputs: c
                } = fr(n);
                hy(n, c)
            }
        },
        O0 = (t, e, n, r) => {
            const [s, i] = ame(t, n, r);
            s !== null && (sI(t, s), i && !e && !Ta(t) && Jt(t).disconnect(Sl(n), r))
        },
        cme = (t, e) => {
            const n = fr(t),
                r = [];
            for (const s of n.outputs) fh(s) ? w0(t, e, ...s) : O0(t, e, ...s), r.push(s[0]);
            return n.outputs.clear(), r
        },
        ume = (t, e, n) => {
            const r = fr(t),
                s = [];
            for (const i of r.outputs) i[1] === n && (fh(i) ? w0(t, e, ...i) : O0(t, e, ...i), s.push(i[0]), r.outputs.delete(i));
            return s
        },
        lme = (t, e, n, r, s) => {
            const i = fr(t);
            return Array.from(i.outputs).filter(a => a[0] === n && (r === void 0 || a[1] === r) && (s === void 0 || a[2] === s)).map(a => (fh(a) ? w0(t, e, ...a) : O0(t, e, ...a), i.outputs.delete(a), a[0]))
        },
        hme = (t, e, n, r, s, i, a, c, l, h, d, p, g, v, b, T) => class extends h {
            constructor(w, P, V, M) {
                super(V), this._context = w, this._nativeAudioNode = V;
                const I = d(w);
                p(I) && n(F3, () => F3(I, T)) !== !0 && sme(V), E0.set(this, V), XC.set(this, new Set), w.state !== "closed" && P && qc(this), t(this, M, V)
            }
            get channelCount() {
                return this._nativeAudioNode.channelCount
            }
            set channelCount(w) {
                this._nativeAudioNode.channelCount = w
            }
            get channelCountMode() {
                return this._nativeAudioNode.channelCountMode
            }
            set channelCountMode(w) {
                this._nativeAudioNode.channelCountMode = w
            }
            get channelInterpretation() {
                return this._nativeAudioNode.channelInterpretation
            }
            set channelInterpretation(w) {
                this._nativeAudioNode.channelInterpretation = w
            }
            get context() {
                return this._context
            }
            get numberOfInputs() {
                return this._nativeAudioNode.numberOfInputs
            }
            get numberOfOutputs() {
                return this._nativeAudioNode.numberOfOutputs
            }
            connect(w, P = 0, V = 0) {
                if (P < 0 || P >= this._nativeAudioNode.numberOfOutputs) throw s();
                const M = d(this._context),
                    I = b(M);
                if (g(w) || v(w)) throw i();
                if (Md(w)) {
                    const q = Jt(w);
                    try {
                        const ce = Dd(this._nativeAudioNode, q, P, V),
                            ue = Jf(this);
                        (I || ue) && this._nativeAudioNode.disconnect(...ce), this.context.state !== "closed" && !ue && Jf(w) && qc(w)
                    } catch (ce) {
                        throw ce.code === 12 ? i() : ce
                    }
                    if (e(this, w, P, V, I)) {
                        const ce = l([this], w);
                        W_(ce, r(I))
                    }
                    return w
                }
                const L = Sl(w);
                if (L.name === "playbackRate" && L.maxValue === 1024) throw a();
                try {
                    this._nativeAudioNode.connect(L, P), (I || Jf(this)) && this._nativeAudioNode.disconnect(L, P)
                } catch (q) {
                    throw q.code === 12 ? i() : q
                }
                if (ime(this, w, P, I)) {
                    const q = l([this], w);
                    W_(q, r(I))
                }
            }
            disconnect(w, P, V) {
                let M;
                const I = d(this._context),
                    L = b(I);
                if (w === void 0) M = cme(this, L);
                else if (typeof w == "number") {
                    if (w < 0 || w >= this.numberOfOutputs) throw s();
                    M = ume(this, L, w)
                } else {
                    if (P !== void 0 && (P < 0 || P >= this.numberOfOutputs) || Md(w) && V !== void 0 && (V < 0 || V >= w.numberOfInputs)) throw s();
                    if (M = lme(this, L, w, P, V), M.length === 0) throw i()
                }
                for (const B of M) {
                    const q = l([this], B);
                    W_(q, c)
                }
            }
        },
        fme = (t, e, n, r, s, i, a, c, l, h, d, p, g) => (v, b, T, m = null, w = null) => {
            const P = new Spe(T.defaultValue),
                V = b ? r(P) : null,
                M = {
                    get defaultValue() {
                        return T.defaultValue
                    },
                    get maxValue() {
                        return m === null ? T.maxValue : m
                    },
                    get minValue() {
                        return w === null ? T.minValue : w
                    },
                    get value() {
                        return T.value
                    },
                    set value(I) {
                        T.value = I, M.setValueAtTime(I, v.context.currentTime)
                    },
                    cancelAndHoldAtTime(I) {
                        if (typeof T.cancelAndHoldAtTime == "function") V === null && P.flush(v.context.currentTime), P.add(s(I)), T.cancelAndHoldAtTime(I);
                        else {
                            const L = Array.from(P).pop();
                            V === null && P.flush(v.context.currentTime), P.add(s(I));
                            const B = Array.from(P).pop();
                            T.cancelScheduledValues(I), L !== B && B !== void 0 && (B.type === "exponentialRampToValue" ? T.exponentialRampToValueAtTime(B.value, B.endTime) : B.type === "linearRampToValue" ? T.linearRampToValueAtTime(B.value, B.endTime) : B.type === "setValue" ? T.setValueAtTime(B.value, B.startTime) : B.type === "setValueCurve" && T.setValueCurveAtTime(B.values, B.startTime, B.duration))
                        }
                        return M
                    },
                    cancelScheduledValues(I) {
                        return V === null && P.flush(v.context.currentTime), P.add(i(I)), T.cancelScheduledValues(I), M
                    },
                    exponentialRampToValueAtTime(I, L) {
                        if (I === 0) throw new RangeError;
                        if (!Number.isFinite(L) || L < 0) throw new RangeError;
                        return V === null && P.flush(v.context.currentTime), P.add(a(I, L)), T.exponentialRampToValueAtTime(I, L), M
                    },
                    linearRampToValueAtTime(I, L) {
                        return V === null && P.flush(v.context.currentTime), P.add(c(I, L)), T.linearRampToValueAtTime(I, L), M
                    },
                    setTargetAtTime(I, L, B) {
                        return V === null && P.flush(v.context.currentTime), P.add(l(I, L, B)), T.setTargetAtTime(I, L, B), M
                    },
                    setValueAtTime(I, L) {
                        return V === null && P.flush(v.context.currentTime), P.add(h(I, L)), T.setValueAtTime(I, L), M
                    },
                    setValueCurveAtTime(I, L, B) {
                        const q = I instanceof Float32Array ? I : new Float32Array(I);
                        if (p !== null && p.name === "webkitAudioContext") {
                            const se = L + B,
                                ce = v.context.sampleRate,
                                ue = Math.ceil(L * ce),
                                ee = Math.floor(se * ce),
                                ge = ee - ue,
                                G = new Float32Array(ge);
                            for (let fe = 0; fe < ge; fe += 1) {
                                const me = (q.length - 1) / B * ((ue + fe) / ce - L),
                                    Te = Math.floor(me),
                                    we = Math.ceil(me);
                                G[fe] = Te === we ? q[Te] : (1 - (me - Te)) * q[Te] + (1 - (we - me)) * q[we]
                            }
                            V === null && P.flush(v.context.currentTime), P.add(d(G, L, B)), T.setValueCurveAtTime(G, L, B);
                            const le = ee / ce;
                            le < se && g(M, G[G.length - 1], le), g(M, q[q.length - 1], se)
                        } else V === null && P.flush(v.context.currentTime), P.add(d(q, L, B)), T.setValueCurveAtTime(q, L, B);
                        return M
                    }
                };
            return n.set(M, T), e.set(M, v), t(M, V), M
        },
        dme = t => ({
            replay(e) {
                for (const n of t)
                    if (n.type === "exponentialRampToValue") {
                        const {
                            endTime: r,
                            value: s
                        } = n;
                        e.exponentialRampToValueAtTime(s, r)
                    } else if (n.type === "linearRampToValue") {
                    const {
                        endTime: r,
                        value: s
                    } = n;
                    e.linearRampToValueAtTime(s, r)
                } else if (n.type === "setTarget") {
                    const {
                        startTime: r,
                        target: s,
                        timeConstant: i
                    } = n;
                    e.setTargetAtTime(s, r, i)
                } else if (n.type === "setValue") {
                    const {
                        startTime: r,
                        value: s
                    } = n;
                    e.setValueAtTime(s, r)
                } else if (n.type === "setValueCurve") {
                    const {
                        duration: r,
                        startTime: s,
                        values: i
                    } = n;
                    e.setValueCurveAtTime(i, s, r)
                } else throw new Error("Can't apply an unknown automation.")
            }
        });
    class oI {
        constructor(e) {
            this._map = new Map(e)
        }
        get size() {
            return this._map.size
        }
        entries() {
            return this._map.entries()
        }
        forEach(e, n = null) {
            return this._map.forEach((r, s) => e.call(n, r, s, this))
        }
        get(e) {
            return this._map.get(e)
        }
        has(e) {
            return this._map.has(e)
        }
        keys() {
            return this._map.keys()
        }
        values() {
            return this._map.values()
        }
    }
    const pme = {
            channelCount: 2,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: 1,
            numberOfOutputs: 1,
            parameterData: {},
            processorOptions: {}
        },
        mme = (t, e, n, r, s, i, a, c, l, h, d, p, g, v) => class extends e {
            constructor(T, m, w) {
                var P;
                const V = c(T),
                    M = l(V),
                    I = d({
                        ...pme,
                        ...w
                    });
                g(I);
                const L = uy.get(V),
                    B = L == null ? void 0 : L.get(m),
                    q = M || V.state !== "closed" ? V : (P = a(V)) !== null && P !== void 0 ? P : V,
                    se = s(q, M ? null : T.baseLatency, h, m, B, I),
                    ce = M ? r(m, I, B) : null;
                super(T, !0, se, ce);
                const ue = [];
                se.parameters.forEach((ge, G) => {
                    const le = n(this, M, ge);
                    ue.push([G, le])
                }), this._nativeAudioWorkletNode = se, this._onprocessorerror = null, this._parameters = new oI(ue), M && t(V, this);
                const {
                    activeInputs: ee
                } = i(this);
                p(se, ee)
            }
            get onprocessorerror() {
                return this._onprocessorerror
            }
            set onprocessorerror(T) {
                const m = typeof T == "function" ? v(this, T) : null;
                this._nativeAudioWorkletNode.onprocessorerror = m;
                const w = this._nativeAudioWorkletNode.onprocessorerror;
                this._onprocessorerror = w !== null && w === m ? T : w
            }
            get parameters() {
                return this._parameters === null ? this._nativeAudioWorkletNode.parameters : this._parameters
            }
            get port() {
                return this._nativeAudioWorkletNode.port
            }
        };

    function Fd(t, e, n, r, s) {
        if (typeof t.copyFromChannel == "function") e[n].byteLength === 0 && (e[n] = new Float32Array(128)), t.copyFromChannel(e[n], r, s);
        else {
            const i = t.getChannelData(r);
            if (e[n].byteLength === 0) e[n] = i.slice(s, s + 128);
            else {
                const a = new Float32Array(i.buffer, s * Float32Array.BYTES_PER_ELEMENT, 128);
                e[n].set(a)
            }
        }
    }
    const aI = (t, e, n, r, s) => {
            typeof t.copyToChannel == "function" ? e[n].byteLength !== 0 && t.copyToChannel(e[n], r, s) : e[n].byteLength !== 0 && t.getChannelData(r).set(e[n], s)
        },
        Ud = (t, e) => {
            const n = [];
            for (let r = 0; r < t; r += 1) {
                const s = [],
                    i = typeof e == "number" ? e : e[r];
                for (let a = 0; a < i; a += 1) s.push(new Float32Array(128));
                n.push(s)
            }
            return n
        },
        gme = (t, e) => {
            const n = As(ly, t),
                r = Jt(e);
            return As(n, r)
        },
        _me = async (t, e, n, r, s, i, a) => {
            const c = e === null ? Math.ceil(t.context.length / 128) * 128 : e.length,
                l = r.channelCount * r.numberOfInputs,
                h = s.reduce((m, w) => m + w, 0),
                d = h === 0 ? null : n.createBuffer(h, c, n.sampleRate);
            if (i === void 0) throw new Error("Missing the processor constructor.");
            const p = fr(t),
                g = await gme(n, t),
                v = Ud(r.numberOfInputs, r.channelCount),
                b = Ud(r.numberOfOutputs, s),
                T = Array.from(t.parameters.keys()).reduce((m, w) => ({
                    ...m,
                    [w]: new Float32Array(128)
                }), {});
            for (let m = 0; m < c; m += 128) {
                if (r.numberOfInputs > 0 && e !== null)
                    for (let w = 0; w < r.numberOfInputs; w += 1)
                        for (let P = 0; P < r.channelCount; P += 1) Fd(e, v[w], P, P, m);
                i.parameterDescriptors !== void 0 && e !== null && i.parameterDescriptors.forEach(({
                    name: w
                }, P) => {
                    Fd(e, T, w, l + P, m)
                });
                for (let w = 0; w < r.numberOfInputs; w += 1)
                    for (let P = 0; P < s[w]; P += 1) b[w][P].byteLength === 0 && (b[w][P] = new Float32Array(128));
                try {
                    const w = v.map((V, M) => p.activeInputs[M].size === 0 ? [] : V),
                        P = a(m / n.sampleRate, n.sampleRate, () => g.process(w, b, T));
                    if (d !== null)
                        for (let V = 0, M = 0; V < r.numberOfOutputs; V += 1) {
                            for (let I = 0; I < s[V]; I += 1) aI(d, b[V], I, M + I, m);
                            M += s[V]
                        }
                    if (!P) break
                } catch (w) {
                    t.dispatchEvent(new ErrorEvent("processorerror", {
                        colno: w.colno,
                        filename: w.filename,
                        lineno: w.lineno,
                        message: w.message
                    }));
                    break
                }
            }
            return d
        }, yme = (t, e, n, r, s, i, a, c, l, h, d, p, g, v, b, T) => (m, w, P) => {
            const V = new WeakMap;
            let M = null;
            const I = async (L, B) => {
                let q = d(L),
                    se = null;
                const ce = ir(q, B),
                    ue = Array.isArray(w.outputChannelCount) ? w.outputChannelCount : Array.from(w.outputChannelCount);
                if (p === null) {
                    const ee = ue.reduce((fe, me) => fe + me, 0),
                        ge = s(B, {
                            channelCount: Math.max(1, ee),
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            numberOfOutputs: Math.max(1, ee)
                        }),
                        G = [];
                    for (let fe = 0; fe < L.numberOfOutputs; fe += 1) G.push(r(B, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "speakers",
                        numberOfInputs: ue[fe]
                    }));
                    const le = a(B, {
                        channelCount: w.channelCount,
                        channelCountMode: w.channelCountMode,
                        channelInterpretation: w.channelInterpretation,
                        gain: 1
                    });
                    le.connect = e.bind(null, G), le.disconnect = l.bind(null, G), se = [ge, G, le]
                } else ce || (q = new p(B, m));
                if (V.set(B, se === null ? q : se[2]), se !== null) {
                    if (M === null) {
                        if (P === void 0) throw new Error("Missing the processor constructor.");
                        if (g === null) throw new Error("Missing the native OfflineAudioContext constructor.");
                        const me = L.channelCount * L.numberOfInputs,
                            Te = P.parameterDescriptors === void 0 ? 0 : P.parameterDescriptors.length,
                            we = me + Te;
                        M = _me(L, we === 0 ? null : await (async () => {
                            const Ie = new g(we, Math.ceil(L.context.length / 128) * 128, B.sampleRate),
                                $e = [],
                                At = [];
                            for (let Xe = 0; Xe < w.numberOfInputs; Xe += 1) $e.push(a(Ie, {
                                channelCount: w.channelCount,
                                channelCountMode: w.channelCountMode,
                                channelInterpretation: w.channelInterpretation,
                                gain: 1
                            })), At.push(s(Ie, {
                                channelCount: w.channelCount,
                                channelCountMode: "explicit",
                                channelInterpretation: "discrete",
                                numberOfOutputs: w.channelCount
                            }));
                            const $t = await Promise.all(Array.from(L.parameters.values()).map(async Xe => {
                                    const tt = i(Ie, {
                                        channelCount: 1,
                                        channelCountMode: "explicit",
                                        channelInterpretation: "discrete",
                                        offset: Xe.value
                                    });
                                    return await v(Ie, Xe, tt.offset), tt
                                })),
                                qe = r(Ie, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "speakers",
                                    numberOfInputs: Math.max(1, me + Te)
                                });
                            for (let Xe = 0; Xe < w.numberOfInputs; Xe += 1) {
                                $e[Xe].connect(At[Xe]);
                                for (let tt = 0; tt < w.channelCount; tt += 1) At[Xe].connect(qe, tt, Xe * w.channelCount + tt)
                            }
                            for (const [Xe, tt] of $t.entries()) tt.connect(qe, 0, me + Xe), tt.start(0);
                            return qe.connect(Ie.destination), await Promise.all($e.map(Xe => b(L, Ie, Xe))), T(Ie)
                        })(), B, w, ue, P, h)
                    }
                    const ee = await M,
                        ge = n(B, {
                            buffer: null,
                            channelCount: 2,
                            channelCountMode: "max",
                            channelInterpretation: "speakers",
                            loop: !1,
                            loopEnd: 0,
                            loopStart: 0,
                            playbackRate: 1
                        }),
                        [G, le, fe] = se;
                    ee !== null && (ge.buffer = ee, ge.start(0)), ge.connect(G);
                    for (let me = 0, Te = 0; me < L.numberOfOutputs; me += 1) {
                        const we = le[me];
                        for (let ke = 0; ke < ue[me]; ke += 1) G.connect(we, Te + ke, ke);
                        Te += ue[me]
                    }
                    return fe
                }
                if (ce)
                    for (const [ee, ge] of L.parameters.entries()) await t(B, ge, q.parameters.get(ee));
                else
                    for (const [ee, ge] of L.parameters.entries()) await v(B, ge, q.parameters.get(ee));
                return await b(L, B, q), q
            };
            return {
                render(L, B) {
                    c(B, L);
                    const q = V.get(B);
                    return q !== void 0 ? Promise.resolve(q) : I(L, B)
                }
            }
        }, vme = (t, e, n, r, s, i, a, c, l, h, d, p, g, v, b, T, m, w, P, V) => class extends b {
            constructor(I, L) {
                super(I, L), this._nativeContext = I, this._audioWorklet = t === void 0 ? void 0 : {
                    addModule: (B, q) => t(this, B, q)
                }
            }
            get audioWorklet() {
                return this._audioWorklet
            }
            createAnalyser() {
                return new e(this)
            }
            createBiquadFilter() {
                return new s(this)
            }
            createBuffer(I, L, B) {
                return new n({
                    length: L,
                    numberOfChannels: I,
                    sampleRate: B
                })
            }
            createBufferSource() {
                return new r(this)
            }
            createChannelMerger(I = 6) {
                return new i(this, {
                    numberOfInputs: I
                })
            }
            createChannelSplitter(I = 6) {
                return new a(this, {
                    numberOfOutputs: I
                })
            }
            createConstantSource() {
                return new c(this)
            }
            createConvolver() {
                return new l(this)
            }
            createDelay(I = 1) {
                return new d(this, {
                    maxDelayTime: I
                })
            }
            createDynamicsCompressor() {
                return new p(this)
            }
            createGain() {
                return new g(this)
            }
            createIIRFilter(I, L) {
                return new v(this, {
                    feedback: L,
                    feedforward: I
                })
            }
            createOscillator() {
                return new T(this)
            }
            createPanner() {
                return new m(this)
            }
            createPeriodicWave(I, L, B = {
                disableNormalization: !1
            }) {
                return new w(this, {
                    ...B,
                    imag: L,
                    real: I
                })
            }
            createStereoPanner() {
                return new P(this)
            }
            createWaveShaper() {
                return new V(this)
            }
            decodeAudioData(I, L, B) {
                return h(this._nativeContext, I).then(q => (typeof L == "function" && L(q), q), q => {
                    throw typeof B == "function" && B(q), q
                })
            }
        }, bme = {
            Q: 1,
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            detune: 0,
            frequency: 350,
            gain: 0,
            type: "lowpass"
        }, Eme = (t, e, n, r, s, i, a, c) => class extends t {
            constructor(h, d) {
                const p = i(h),
                    g = {
                        ...bme,
                        ...d
                    },
                    v = s(p, g),
                    b = a(p),
                    T = b ? n() : null;
                super(h, !1, v, T), this._Q = e(this, b, v.Q, hr, Tr), this._detune = e(this, b, v.detune, 1200 * Math.log2(hr), -1200 * Math.log2(hr)), this._frequency = e(this, b, v.frequency, h.sampleRate / 2, 0), this._gain = e(this, b, v.gain, 40 * Math.log10(hr), Tr), this._nativeBiquadFilterNode = v, c(this, 1)
            }
            get detune() {
                return this._detune
            }
            get frequency() {
                return this._frequency
            }
            get gain() {
                return this._gain
            }
            get Q() {
                return this._Q
            }
            get type() {
                return this._nativeBiquadFilterNode.type
            }
            set type(h) {
                this._nativeBiquadFilterNode.type = h
            }
            getFrequencyResponse(h, d, p) {
                try {
                    this._nativeBiquadFilterNode.getFrequencyResponse(h, d, p)
                } catch (g) {
                    throw g.code === 11 ? r() : g
                }
                if (h.length !== d.length || d.length !== p.length) throw r()
            }
        }, Sme = (t, e, n, r, s) => () => {
            const i = new WeakMap,
                a = async (c, l) => {
                    let h = n(c);
                    const d = ir(h, l);
                    if (!d) {
                        const p = {
                            Q: h.Q.value,
                            channelCount: h.channelCount,
                            channelCountMode: h.channelCountMode,
                            channelInterpretation: h.channelInterpretation,
                            detune: h.detune.value,
                            frequency: h.frequency.value,
                            gain: h.gain.value,
                            type: h.type
                        };
                        h = e(l, p)
                    }
                    return i.set(l, h), d ? (await t(l, c.Q, h.Q), await t(l, c.detune, h.detune), await t(l, c.frequency, h.frequency), await t(l, c.gain, h.gain)) : (await r(l, c.Q, h.Q), await r(l, c.detune, h.detune), await r(l, c.frequency, h.frequency), await r(l, c.gain, h.gain)), await s(c, l, h), h
                };
            return {
                render(c, l) {
                    const h = i.get(l);
                    return h !== void 0 ? Promise.resolve(h) : a(c, l)
                }
            }
        }, Tme = (t, e) => (n, r) => {
            const s = e.get(n);
            if (s !== void 0) return s;
            const i = t.get(n);
            if (i !== void 0) return i;
            try {
                const a = r();
                return a instanceof Promise ? (t.set(n, a), a.catch(() => !1).then(c => (t.delete(n), e.set(n, c), c))) : (e.set(n, a), a)
            } catch {
                return e.set(n, !1), !1
            }
        }, wme = {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: 6
        }, Ome = (t, e, n, r, s) => class extends t {
            constructor(a, c) {
                const l = r(a),
                    h = {
                        ...wme,
                        ...c
                    },
                    d = n(l, h),
                    p = s(l) ? e() : null;
                super(a, !1, d, p)
            }
        }, Ame = (t, e, n) => () => {
            const r = new WeakMap,
                s = async (i, a) => {
                    let c = e(i);
                    if (!ir(c, a)) {
                        const h = {
                            channelCount: c.channelCount,
                            channelCountMode: c.channelCountMode,
                            channelInterpretation: c.channelInterpretation,
                            numberOfInputs: c.numberOfInputs
                        };
                        c = t(a, h)
                    }
                    return r.set(a, c), await n(i, a, c), c
                };
            return {
                render(i, a) {
                    const c = r.get(a);
                    return c !== void 0 ? Promise.resolve(c) : s(i, a)
                }
            }
        }, Cme = {
            channelCount: 6,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            numberOfOutputs: 6
        }, Ime = (t, e, n, r, s, i) => class extends t {
            constructor(c, l) {
                const h = r(c),
                    d = i({
                        ...Cme,
                        ...l
                    }),
                    p = n(h, d),
                    g = s(h) ? e() : null;
                super(c, !1, p, g)
            }
        }, kme = (t, e, n) => () => {
            const r = new WeakMap,
                s = async (i, a) => {
                    let c = e(i);
                    if (!ir(c, a)) {
                        const h = {
                            channelCount: c.channelCount,
                            channelCountMode: c.channelCountMode,
                            channelInterpretation: c.channelInterpretation,
                            numberOfOutputs: c.numberOfOutputs
                        };
                        c = t(a, h)
                    }
                    return r.set(a, c), await n(i, a, c), c
                };
            return {
                render(i, a) {
                    const c = r.get(a);
                    return c !== void 0 ? Promise.resolve(c) : s(i, a)
                }
            }
        }, Nme = t => (e, n, r) => t(n, e, r), xme = t => (e, n, r = 0, s = 0) => {
            const i = e[r];
            if (i === void 0) throw t();
            return Ld(n) ? i.connect(n, 0, s) : i.connect(n, 0)
        }, Pme = t => (e, n) => {
            const r = t(e, {
                    buffer: null,
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    loop: !1,
                    loopEnd: 0,
                    loopStart: 0,
                    playbackRate: 1
                }),
                s = e.createBuffer(1, 2, 44100);
            return r.buffer = s, r.loop = !0, r.connect(n), r.start(), () => {
                r.stop(), r.disconnect(n)
            }
        }, Rme = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            offset: 1
        }, Mme = (t, e, n, r, s, i, a) => class extends t {
            constructor(l, h) {
                const d = s(l),
                    p = {
                        ...Rme,
                        ...h
                    },
                    g = r(d, p),
                    v = i(d),
                    b = v ? n() : null;
                super(l, !1, g, b), this._constantSourceNodeRenderer = b, this._nativeConstantSourceNode = g, this._offset = e(this, v, g.offset, hr, Tr), this._onended = null
            }
            get offset() {
                return this._offset
            }
            get onended() {
                return this._onended
            }
            set onended(l) {
                const h = typeof l == "function" ? a(this, l) : null;
                this._nativeConstantSourceNode.onended = h;
                const d = this._nativeConstantSourceNode.onended;
                this._onended = d !== null && d === h ? l : d
            }
            start(l = 0) {
                if (this._nativeConstantSourceNode.start(l), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.start = l), this.context.state !== "closed") {
                    qc(this);
                    const h = () => {
                        this._nativeConstantSourceNode.removeEventListener("ended", h), ki(this) && lh(this)
                    };
                    this._nativeConstantSourceNode.addEventListener("ended", h)
                }
            }
            stop(l = 0) {
                this._nativeConstantSourceNode.stop(l), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.stop = l)
            }
        }, Dme = (t, e, n, r, s) => () => {
            const i = new WeakMap;
            let a = null,
                c = null;
            const l = async (h, d) => {
                let p = n(h);
                const g = ir(p, d);
                if (!g) {
                    const v = {
                        channelCount: p.channelCount,
                        channelCountMode: p.channelCountMode,
                        channelInterpretation: p.channelInterpretation,
                        offset: p.offset.value
                    };
                    p = e(d, v), a !== null && p.start(a), c !== null && p.stop(c)
                }
                return i.set(d, p), g ? await t(d, h.offset, p.offset) : await r(d, h.offset, p.offset), await s(h, d, p), p
            };
            return {
                set start(h) {
                    a = h
                },
                set stop(h) {
                    c = h
                },
                render(h, d) {
                    const p = i.get(d);
                    return p !== void 0 ? Promise.resolve(p) : l(h, d)
                }
            }
        }, $me = t => e => (t[0] = e, t[0]), Lme = {
            buffer: null,
            channelCount: 2,
            channelCountMode: "clamped-max",
            channelInterpretation: "speakers",
            disableNormalization: !1
        }, Fme = (t, e, n, r, s, i) => class extends t {
            constructor(c, l) {
                const h = r(c),
                    d = {
                        ...Lme,
                        ...l
                    },
                    p = n(h, d),
                    v = s(h) ? e() : null;
                super(c, !1, p, v), this._isBufferNullified = !1, this._nativeConvolverNode = p, d.buffer !== null && i(this, d.buffer.duration)
            }
            get buffer() {
                return this._isBufferNullified ? null : this._nativeConvolverNode.buffer
            }
            set buffer(c) {
                if (this._nativeConvolverNode.buffer = c, c === null && this._nativeConvolverNode.buffer !== null) {
                    const l = this._nativeConvolverNode.context;
                    this._nativeConvolverNode.buffer = l.createBuffer(1, 1, l.sampleRate), this._isBufferNullified = !0, i(this, 0)
                } else this._isBufferNullified = !1, i(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration)
            }
            get normalize() {
                return this._nativeConvolverNode.normalize
            }
            set normalize(c) {
                this._nativeConvolverNode.normalize = c
            }
        }, Ume = (t, e, n) => () => {
            const r = new WeakMap,
                s = async (i, a) => {
                    let c = e(i);
                    if (!ir(c, a)) {
                        const h = {
                            buffer: c.buffer,
                            channelCount: c.channelCount,
                            channelCountMode: c.channelCountMode,
                            channelInterpretation: c.channelInterpretation,
                            disableNormalization: !c.normalize
                        };
                        c = t(a, h)
                    }
                    return r.set(a, c), du(c) ? await n(i, a, c.inputs[0]) : await n(i, a, c), c
                };
            return {
                render(i, a) {
                    const c = r.get(a);
                    return c !== void 0 ? Promise.resolve(c) : s(i, a)
                }
            }
        }, Bme = (t, e) => (n, r, s) => {
            if (e === null) throw new Error("Missing the native OfflineAudioContext constructor.");
            try {
                return new e(n, r, s)
            } catch (i) {
                throw i.name === "SyntaxError" ? t() : i
            }
        }, qme = () => new DOMException("", "DataCloneError"), U3 = t => {
            const {
                port1: e,
                port2: n
            } = new MessageChannel;
            return new Promise(r => {
                const s = () => {
                    n.onmessage = null, e.close(), n.close(), r()
                };
                n.onmessage = () => s();
                try {
                    e.postMessage(t, [t])
                } finally {
                    s()
                }
            })
        }, Vme = (t, e, n, r, s, i, a, c, l, h, d) => (p, g) => {
            const v = a(p) ? p : i(p);
            if (s.has(g)) {
                const b = n();
                return Promise.reject(b)
            }
            try {
                s.add(g)
            } catch {}
            return e(l, () => l(v)) ? v.decodeAudioData(g).then(b => (U3(g).catch(() => {}), e(c, () => c(b)) || d(b), t.add(b), b)) : new Promise((b, T) => {
                const m = async () => {
                    try {
                        await U3(g)
                    } catch {}
                }, w = P => {
                    T(P), m()
                };
                try {
                    v.decodeAudioData(g, P => {
                        typeof P.copyFromChannel != "function" && (h(P), T0(P)), t.add(P), m().then(() => b(P))
                    }, P => {
                        w(P === null ? r() : P)
                    })
                } catch (P) {
                    w(P)
                }
            })
        }, jme = (t, e, n, r, s, i, a, c) => (l, h) => {
            const d = e.get(l);
            if (d === void 0) throw new Error("Missing the expected cycle count.");
            const p = i(l.context),
                g = c(p);
            if (d === h) {
                if (e.delete(l), !g && a(l)) {
                    const v = r(l),
                        {
                            outputs: b
                        } = n(l);
                    for (const T of b)
                        if (fh(T)) {
                            const m = r(T[0]);
                            t(v, m, T[1], T[2])
                        } else {
                            const m = s(T[0]);
                            v.connect(m, T[1])
                        }
                }
            } else e.set(l, d - h)
        }, Gme = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            delayTime: 0,
            maxDelayTime: 1
        }, Wme = (t, e, n, r, s, i, a) => class extends t {
            constructor(l, h) {
                const d = s(l),
                    p = {
                        ...Gme,
                        ...h
                    },
                    g = r(d, p),
                    v = i(d),
                    b = v ? n(p.maxDelayTime) : null;
                super(l, !1, g, b), this._delayTime = e(this, v, g.delayTime), a(this, p.maxDelayTime)
            }
            get delayTime() {
                return this._delayTime
            }
        }, Hme = (t, e, n, r, s) => i => {
            const a = new WeakMap,
                c = async (l, h) => {
                    let d = n(l);
                    const p = ir(d, h);
                    if (!p) {
                        const g = {
                            channelCount: d.channelCount,
                            channelCountMode: d.channelCountMode,
                            channelInterpretation: d.channelInterpretation,
                            delayTime: d.delayTime.value,
                            maxDelayTime: i
                        };
                        d = e(h, g)
                    }
                    return a.set(h, d), p ? await t(h, l.delayTime, d.delayTime) : await r(h, l.delayTime, d.delayTime), await s(l, h, d), d
                };
            return {
                render(l, h) {
                    const d = a.get(h);
                    return d !== void 0 ? Promise.resolve(d) : c(l, h)
                }
            }
        }, Kme = t => (e, n, r, s) => t(e[s], i => i[0] === n && i[1] === r), Yme = t => (e, n) => {
            t(e).delete(n)
        }, zme = t => "delayTime" in t, Zme = (t, e, n) => function r(s, i) {
            const a = Md(i) ? i : n(t, i);
            if (zme(a)) return [];
            if (s[0] === a) return [s];
            if (s.includes(a)) return [];
            const {
                outputs: c
            } = e(a);
            return Array.from(c).map(l => r([...s, a], l[0])).reduce((l, h) => l.concat(h), [])
        }, Bf = (t, e, n) => {
            const r = e[n];
            if (r === void 0) throw t();
            return r
        }, Xme = t => (e, n = void 0, r = void 0, s = 0) => n === void 0 ? e.forEach(i => i.disconnect()) : typeof n == "number" ? Bf(t, e, n).disconnect() : Ld(n) ? r === void 0 ? e.forEach(i => i.disconnect(n)) : s === void 0 ? Bf(t, e, r).disconnect(n, 0) : Bf(t, e, r).disconnect(n, 0, s) : r === void 0 ? e.forEach(i => i.disconnect(n)) : Bf(t, e, r).disconnect(n, 0), Qme = {
            attack: .003,
            channelCount: 2,
            channelCountMode: "clamped-max",
            channelInterpretation: "speakers",
            knee: 30,
            ratio: 12,
            release: .25,
            threshold: -24
        }, Jme = (t, e, n, r, s, i, a, c) => class extends t {
            constructor(h, d) {
                const p = i(h),
                    g = {
                        ...Qme,
                        ...d
                    },
                    v = r(p, g),
                    b = a(p),
                    T = b ? n() : null;
                super(h, !1, v, T), this._attack = e(this, b, v.attack), this._knee = e(this, b, v.knee), this._nativeDynamicsCompressorNode = v, this._ratio = e(this, b, v.ratio), this._release = e(this, b, v.release), this._threshold = e(this, b, v.threshold), c(this, .006)
            }
            get attack() {
                return this._attack
            }
            get channelCount() {
                return this._nativeDynamicsCompressorNode.channelCount
            }
            set channelCount(h) {
                const d = this._nativeDynamicsCompressorNode.channelCount;
                if (this._nativeDynamicsCompressorNode.channelCount = h, h > 2) throw this._nativeDynamicsCompressorNode.channelCount = d, s()
            }
            get channelCountMode() {
                return this._nativeDynamicsCompressorNode.channelCountMode
            }
            set channelCountMode(h) {
                const d = this._nativeDynamicsCompressorNode.channelCountMode;
                if (this._nativeDynamicsCompressorNode.channelCountMode = h, h === "max") throw this._nativeDynamicsCompressorNode.channelCountMode = d, s()
            }
            get knee() {
                return this._knee
            }
            get ratio() {
                return this._ratio
            }
            get reduction() {
                return typeof this._nativeDynamicsCompressorNode.reduction.value == "number" ? this._nativeDynamicsCompressorNode.reduction.value : this._nativeDynamicsCompressorNode.reduction
            }
            get release() {
                return this._release
            }
            get threshold() {
                return this._threshold
            }
        }, ege = (t, e, n, r, s) => () => {
            const i = new WeakMap,
                a = async (c, l) => {
                    let h = n(c);
                    const d = ir(h, l);
                    if (!d) {
                        const p = {
                            attack: h.attack.value,
                            channelCount: h.channelCount,
                            channelCountMode: h.channelCountMode,
                            channelInterpretation: h.channelInterpretation,
                            knee: h.knee.value,
                            ratio: h.ratio.value,
                            release: h.release.value,
                            threshold: h.threshold.value
                        };
                        h = e(l, p)
                    }
                    return i.set(l, h), d ? (await t(l, c.attack, h.attack), await t(l, c.knee, h.knee), await t(l, c.ratio, h.ratio), await t(l, c.release, h.release), await t(l, c.threshold, h.threshold)) : (await r(l, c.attack, h.attack), await r(l, c.knee, h.knee), await r(l, c.ratio, h.ratio), await r(l, c.release, h.release), await r(l, c.threshold, h.threshold)), await s(c, l, h), h
                };
            return {
                render(c, l) {
                    const h = i.get(l);
                    return h !== void 0 ? Promise.resolve(h) : a(c, l)
                }
            }
        }, tge = () => new DOMException("", "EncodingError"), nge = t => e => new Promise((n, r) => {
            if (t === null) {
                r(new SyntaxError);
                return
            }
            const s = t.document.head;
            if (s === null) r(new SyntaxError);
            else {
                const i = t.document.createElement("script"),
                    a = new Blob([e], {
                        type: "application/javascript"
                    }),
                    c = URL.createObjectURL(a),
                    l = t.onerror,
                    h = () => {
                        t.onerror = l, URL.revokeObjectURL(c)
                    };
                t.onerror = (d, p, g, v, b) => {
                    if (p === c || p === t.location.href && g === 1 && v === 1) return h(), r(b), !1;
                    if (l !== null) return l(d, p, g, v, b)
                }, i.onerror = () => {
                    h(), r(new SyntaxError)
                }, i.onload = () => {
                    h(), n()
                }, i.src = c, i.type = "module", s.appendChild(i)
            }
        }), rge = t => class {
            constructor(n) {
                this._nativeEventTarget = n, this._listeners = new WeakMap
            }
            addEventListener(n, r, s) {
                if (r !== null) {
                    let i = this._listeners.get(r);
                    i === void 0 && (i = t(this, r), typeof r == "function" && this._listeners.set(r, i)), this._nativeEventTarget.addEventListener(n, i, s)
                }
            }
            dispatchEvent(n) {
                return this._nativeEventTarget.dispatchEvent(n)
            }
            removeEventListener(n, r, s) {
                const i = r === null ? void 0 : this._listeners.get(r);
                this._nativeEventTarget.removeEventListener(n, i === void 0 ? null : i, s)
            }
        }, sge = t => (e, n, r) => {
            Object.defineProperties(t, {
                currentFrame: {
                    configurable: !0,
                    get() {
                        return Math.round(e * n)
                    }
                },
                currentTime: {
                    configurable: !0,
                    get() {
                        return e
                    }
                }
            });
            try {
                return r()
            } finally {
                t !== null && (delete t.currentFrame, delete t.currentTime)
            }
        }, ige = t => async e => {
            try {
                const n = await fetch(e);
                if (n.ok) return [await n.text(), n.url]
            } catch {}
            throw t()
        }, oge = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            gain: 1
        }, age = (t, e, n, r, s, i) => class extends t {
            constructor(c, l) {
                const h = s(c),
                    d = {
                        ...oge,
                        ...l
                    },
                    p = r(h, d),
                    g = i(h),
                    v = g ? n() : null;
                super(c, !1, p, v), this._gain = e(this, g, p.gain, hr, Tr)
            }
            get gain() {
                return this._gain
            }
        }, cge = (t, e, n, r, s) => () => {
            const i = new WeakMap,
                a = async (c, l) => {
                    let h = n(c);
                    const d = ir(h, l);
                    if (!d) {
                        const p = {
                            channelCount: h.channelCount,
                            channelCountMode: h.channelCountMode,
                            channelInterpretation: h.channelInterpretation,
                            gain: h.gain.value
                        };
                        h = e(l, p)
                    }
                    return i.set(l, h), d ? await t(l, c.gain, h.gain) : await r(l, c.gain, h.gain), await s(c, l, h), h
                };
            return {
                render(c, l) {
                    const h = i.get(l);
                    return h !== void 0 ? Promise.resolve(h) : a(c, l)
                }
            }
        }, uge = (t, e) => n => e(t, n), lge = t => e => {
            const n = t(e);
            if (n.renderer === null) throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
            return n.renderer
        }, hge = t => e => {
            var n;
            return (n = t.get(e)) !== null && n !== void 0 ? n : 0
        }, fge = t => e => {
            const n = t(e);
            if (n.renderer === null) throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
            return n.renderer
        }, dge = t => e => t.get(e), Ln = () => new DOMException("", "InvalidStateError"), pge = t => e => {
            const n = t.get(e);
            if (n === void 0) throw Ln();
            return n
        }, mge = (t, e) => n => {
            let r = t.get(n);
            if (r !== void 0) return r;
            if (e === null) throw new Error("Missing the native OfflineAudioContext constructor.");
            return r = new e(1, 1, 44100), t.set(n, r), r
        }, gge = t => e => {
            const n = t.get(e);
            if (n === void 0) throw new Error("The context has no set of AudioWorkletNodes.");
            return n
        }, Em = () => new DOMException("", "InvalidAccessError"), _ge = t => {
            t.getFrequencyResponse = (e => (n, r, s) => {
                if (n.length !== r.length || r.length !== s.length) throw Em();
                return e.call(t, n, r, s)
            })(t.getFrequencyResponse)
        }, yge = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers"
        }, vge = (t, e, n, r, s, i) => class extends t {
            constructor(c, l) {
                const h = r(c),
                    d = s(h),
                    p = {
                        ...yge,
                        ...l
                    },
                    g = e(h, d ? null : c.baseLatency, p),
                    v = d ? n(p.feedback, p.feedforward) : null;
                super(c, !1, g, v), _ge(g), this._nativeIIRFilterNode = g, i(this, 1)
            }
            getFrequencyResponse(c, l, h) {
                return this._nativeIIRFilterNode.getFrequencyResponse(c, l, h)
            }
        }, cI = (t, e, n, r, s, i, a, c, l, h, d) => {
            const p = h.length;
            let g = c;
            for (let v = 0; v < p; v += 1) {
                let b = n[0] * h[v];
                for (let T = 1; T < s; T += 1) {
                    const m = g - T & l - 1;
                    b += n[T] * i[m], b -= t[T] * a[m]
                }
                for (let T = s; T < r; T += 1) b += n[T] * i[g - T & l - 1];
                for (let T = s; T < e; T += 1) b -= t[T] * a[g - T & l - 1];
                i[g] = h[v], a[g] = b, g = g + 1 & l - 1, d[v] = b
            }
            return g
        }, bge = (t, e, n, r) => {
            const s = n instanceof Float64Array ? n : new Float64Array(n),
                i = r instanceof Float64Array ? r : new Float64Array(r),
                a = s.length,
                c = i.length,
                l = Math.min(a, c);
            if (s[0] !== 1) {
                for (let b = 0; b < a; b += 1) i[b] /= s[0];
                for (let b = 1; b < c; b += 1) s[b] /= s[0]
            }
            const h = 32,
                d = new Float32Array(h),
                p = new Float32Array(h),
                g = e.createBuffer(t.numberOfChannels, t.length, t.sampleRate),
                v = t.numberOfChannels;
            for (let b = 0; b < v; b += 1) {
                const T = t.getChannelData(b),
                    m = g.getChannelData(b);
                d.fill(0), p.fill(0), cI(s, a, i, c, l, d, p, 0, h, T, m)
            }
            return g
        }, Ege = (t, e, n, r, s) => (i, a) => {
            const c = new WeakMap;
            let l = null;
            const h = async (d, p) => {
                let g = null,
                    v = e(d);
                const b = ir(v, p);
                if (p.createIIRFilter === void 0 ? g = t(p, {
                        buffer: null,
                        channelCount: 2,
                        channelCountMode: "max",
                        channelInterpretation: "speakers",
                        loop: !1,
                        loopEnd: 0,
                        loopStart: 0,
                        playbackRate: 1
                    }) : b || (v = p.createIIRFilter(a, i)), c.set(p, g === null ? v : g), g !== null) {
                    if (l === null) {
                        if (n === null) throw new Error("Missing the native OfflineAudioContext constructor.");
                        const m = new n(d.context.destination.channelCount, d.context.length, p.sampleRate);
                        l = (async () => {
                            await r(d, m, m.destination);
                            const w = await s(m);
                            return bge(w, p, i, a)
                        })()
                    }
                    const T = await l;
                    return g.buffer = T, g.start(0), g
                }
                return await r(d, p, v), v
            };
            return {
                render(d, p) {
                    const g = c.get(p);
                    return g !== void 0 ? Promise.resolve(g) : h(d, p)
                }
            }
        }, Sge = (t, e, n, r, s, i) => a => (c, l) => {
            const h = t.get(c);
            if (h === void 0) {
                if (!a && i(c)) {
                    const d = r(c),
                        {
                            outputs: p
                        } = n(c);
                    for (const g of p)
                        if (fh(g)) {
                            const v = r(g[0]);
                            e(d, v, g[1], g[2])
                        } else {
                            const v = s(g[0]);
                            d.disconnect(v, g[1])
                        }
                }
                t.set(c, l)
            } else t.set(c, h + l)
        }, Tge = (t, e) => n => {
            const r = t.get(n);
            return e(r) || e(n)
        }, wge = (t, e) => n => t.has(n) || e(n), Oge = (t, e) => n => t.has(n) || e(n), Age = (t, e) => n => {
            const r = t.get(n);
            return e(r) || e(n)
        }, Cge = t => e => t !== null && e instanceof t, Ige = t => e => t !== null && typeof t.AudioNode == "function" && e instanceof t.AudioNode, kge = t => e => t !== null && typeof t.AudioParam == "function" && e instanceof t.AudioParam, Nge = (t, e) => n => t(n) || e(n), xge = t => e => t !== null && e instanceof t, Pge = t => t !== null && t.isSecureContext, Rge = (t, e, n, r) => class extends t {
            constructor(i, a) {
                const c = n(i),
                    l = e(c, a);
                if (r(c)) throw TypeError();
                super(i, !0, l, null), this._nativeMediaElementAudioSourceNode = l
            }
            get mediaElement() {
                return this._nativeMediaElementAudioSourceNode.mediaElement
            }
        }, Mge = {
            channelCount: 2,
            channelCountMode: "explicit",
            channelInterpretation: "speakers"
        }, Dge = (t, e, n, r) => class extends t {
            constructor(i, a) {
                const c = n(i);
                if (r(c)) throw new TypeError;
                const l = {
                        ...Mge,
                        ...a
                    },
                    h = e(c, l);
                super(i, !1, h, null), this._nativeMediaStreamAudioDestinationNode = h
            }
            get stream() {
                return this._nativeMediaStreamAudioDestinationNode.stream
            }
        }, $ge = (t, e, n, r) => class extends t {
            constructor(i, a) {
                const c = n(i),
                    l = e(c, a);
                if (r(c)) throw new TypeError;
                super(i, !0, l, null), this._nativeMediaStreamAudioSourceNode = l
            }
            get mediaStream() {
                return this._nativeMediaStreamAudioSourceNode.mediaStream
            }
        }, Lge = (t, e, n) => class extends t {
            constructor(s, i) {
                const a = n(s),
                    c = e(a, i);
                super(s, !0, c, null)
            }
        }, Fge = (t, e, n, r, s, i) => class extends n {
            constructor(c, l) {
                super(c), this._nativeContext = c, vm.set(this, c), r(c) && s.set(c, new Set), this._destination = new t(this, l), this._listener = e(this, c), this._onstatechange = null
            }
            get currentTime() {
                return this._nativeContext.currentTime
            }
            get destination() {
                return this._destination
            }
            get listener() {
                return this._listener
            }
            get onstatechange() {
                return this._onstatechange
            }
            set onstatechange(c) {
                const l = typeof c == "function" ? i(this, c) : null;
                this._nativeContext.onstatechange = l;
                const h = this._nativeContext.onstatechange;
                this._onstatechange = h !== null && h === l ? c : h
            }
            get sampleRate() {
                return this._nativeContext.sampleRate
            }
            get state() {
                return this._nativeContext.state
            }
        }, Tl = t => {
            const e = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
            try {
                const n = t.decodeAudioData(e.buffer, () => {});
                return n === void 0 ? !1 : (n.catch(() => {}), !0)
            } catch {}
            return !1
        }, Uge = (t, e) => (n, r, s) => {
            const i = new Set;
            return n.connect = (a => (c, l = 0, h = 0) => {
                const d = i.size === 0;
                if (e(c)) return a.call(n, c, l, h), t(i, [c, l, h], p => p[0] === c && p[1] === l && p[2] === h, !0), d && r(), c;
                a.call(n, c, l), t(i, [c, l], p => p[0] === c && p[1] === l, !0), d && r()
            })(n.connect), n.disconnect = (a => (c, l, h) => {
                const d = i.size > 0;
                if (c === void 0) a.apply(n), i.clear();
                else if (typeof c == "number") {
                    a.call(n, c);
                    for (const g of i) g[1] === c && i.delete(g)
                } else {
                    e(c) ? a.call(n, c, l, h) : a.call(n, c, l);
                    for (const g of i) g[0] === c && (l === void 0 || g[1] === l) && (h === void 0 || g[2] === h) && i.delete(g)
                }
                const p = i.size === 0;
                d && p && s()
            })(n.disconnect), n
        }, nn = (t, e, n) => {
            const r = e[n];
            r !== void 0 && r !== t[n] && (t[n] = r)
        }, Pn = (t, e) => {
            nn(t, e, "channelCount"), nn(t, e, "channelCountMode"), nn(t, e, "channelInterpretation")
        }, B3 = t => typeof t.getFloatTimeDomainData == "function", Bge = t => {
            t.getFloatTimeDomainData = e => {
                const n = new Uint8Array(e.length);
                t.getByteTimeDomainData(n);
                const r = Math.max(n.length, t.fftSize);
                for (let s = 0; s < r; s += 1) e[s] = (n[s] - 128) * .0078125;
                return e
            }
        }, qge = (t, e) => (n, r) => {
            const s = n.createAnalyser();
            if (Pn(s, r), !(r.maxDecibels > r.minDecibels)) throw e();
            return nn(s, r, "fftSize"), nn(s, r, "maxDecibels"), nn(s, r, "minDecibels"), nn(s, r, "smoothingTimeConstant"), t(B3, () => B3(s)) || Bge(s), s
        }, Vge = t => t === null ? null : t.hasOwnProperty("AudioBuffer") ? t.AudioBuffer : null, ln = (t, e, n) => {
            const r = e[n];
            r !== void 0 && r !== t[n].value && (t[n].value = r)
        }, jge = t => {
            t.start = (e => {
                let n = !1;
                return (r = 0, s = 0, i) => {
                    if (n) throw Ln();
                    e.call(t, r, s, i), n = !0
                }
            })(t.start)
        }, A0 = t => {
            t.start = (e => (n = 0, r = 0, s) => {
                if (typeof s == "number" && s < 0 || r < 0 || n < 0) throw new RangeError("The parameters can't be negative.");
                e.call(t, n, r, s)
            })(t.start)
        }, C0 = t => {
            t.stop = (e => (n = 0) => {
                if (n < 0) throw new RangeError("The parameter can't be negative.");
                e.call(t, n)
            })(t.stop)
        }, Gge = (t, e, n, r, s, i, a, c, l, h, d) => (p, g) => {
            const v = p.createBufferSource();
            return Pn(v, g), ln(v, g, "playbackRate"), nn(v, g, "buffer"), nn(v, g, "loop"), nn(v, g, "loopEnd"), nn(v, g, "loopStart"), e(n, () => n(p)) || jge(v), e(r, () => r(p)) || l(v), e(s, () => s(p)) || h(v, p), e(i, () => i(p)) || A0(v), e(a, () => a(p)) || d(v, p), e(c, () => c(p)) || C0(v), t(p, v), v
        }, Wge = t => t === null ? null : t.hasOwnProperty("AudioContext") ? t.AudioContext : t.hasOwnProperty("webkitAudioContext") ? t.webkitAudioContext : null, Hge = (t, e) => (n, r, s) => {
            const i = n.destination;
            if (i.channelCount !== r) try {
                i.channelCount = r
            } catch {}
            s && i.channelCountMode !== "explicit" && (i.channelCountMode = "explicit"), i.maxChannelCount === 0 && Object.defineProperty(i, "maxChannelCount", {
                value: r
            });
            const a = t(n, {
                channelCount: r,
                channelCountMode: i.channelCountMode,
                channelInterpretation: i.channelInterpretation,
                gain: 1
            });
            return e(a, "channelCount", c => () => c.call(a), c => l => {
                c.call(a, l);
                try {
                    i.channelCount = l
                } catch (h) {
                    if (l > i.maxChannelCount) throw h
                }
            }), e(a, "channelCountMode", c => () => c.call(a), c => l => {
                c.call(a, l), i.channelCountMode = l
            }), e(a, "channelInterpretation", c => () => c.call(a), c => l => {
                c.call(a, l), i.channelInterpretation = l
            }), Object.defineProperty(a, "maxChannelCount", {
                get: () => i.maxChannelCount
            }), a.connect(i), a
        }, Kge = t => t === null ? null : t.hasOwnProperty("AudioWorkletNode") ? t.AudioWorkletNode : null, Yge = t => {
            const {
                port1: e
            } = new MessageChannel;
            try {
                e.postMessage(t)
            } finally {
                e.close()
            }
        }, zge = (t, e, n, r, s) => (i, a, c, l, h, d) => {
            if (c !== null) try {
                const p = new c(i, l, d),
                    g = new Map;
                let v = null;
                if (Object.defineProperties(p, {
                        channelCount: {
                            get: () => d.channelCount,
                            set: () => {
                                throw t()
                            }
                        },
                        channelCountMode: {
                            get: () => "explicit",
                            set: () => {
                                throw t()
                            }
                        },
                        onprocessorerror: {
                            get: () => v,
                            set: b => {
                                typeof v == "function" && p.removeEventListener("processorerror", v), v = typeof b == "function" ? b : null, typeof v == "function" && p.addEventListener("processorerror", v)
                            }
                        }
                    }), p.addEventListener = (b => (...T) => {
                        if (T[0] === "processorerror") {
                            const m = typeof T[1] == "function" ? T[1] : typeof T[1] == "object" && T[1] !== null && typeof T[1].handleEvent == "function" ? T[1].handleEvent : null;
                            if (m !== null) {
                                const w = g.get(T[1]);
                                w !== void 0 ? T[1] = w : (T[1] = P => {
                                    P.type === "error" ? (Object.defineProperties(P, {
                                        type: {
                                            value: "processorerror"
                                        }
                                    }), m(P)) : m(new ErrorEvent(T[0], {
                                        ...P
                                    }))
                                }, g.set(m, T[1]))
                            }
                        }
                        return b.call(p, "error", T[1], T[2]), b.call(p, ...T)
                    })(p.addEventListener), p.removeEventListener = (b => (...T) => {
                        if (T[0] === "processorerror") {
                            const m = g.get(T[1]);
                            m !== void 0 && (g.delete(T[1]), T[1] = m)
                        }
                        return b.call(p, "error", T[1], T[2]), b.call(p, T[0], T[1], T[2])
                    })(p.removeEventListener), d.numberOfOutputs !== 0) {
                    const b = n(i, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: 0
                    });
                    return p.connect(b).connect(i.destination), s(p, () => b.disconnect(), () => b.connect(i.destination))
                }
                return p
            } catch (p) {
                throw p.code === 11 ? r() : p
            }
            if (h === void 0) throw r();
            return Yge(d), e(i, a, h, d)
        }, uI = (t, e) => t === null ? 512 : Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(t * e))))), Zge = t => new Promise((e, n) => {
            const {
                port1: r,
                port2: s
            } = new MessageChannel;
            r.onmessage = ({
                data: i
            }) => {
                r.close(), s.close(), e(i)
            }, r.onmessageerror = ({
                data: i
            }) => {
                r.close(), s.close(), n(i)
            }, s.postMessage(t)
        }), Xge = async (t, e) => {
            const n = await Zge(e);
            return new t(n)
        }, Qge = (t, e, n, r) => {
            let s = ly.get(t);
            s === void 0 && (s = new WeakMap, ly.set(t, s));
            const i = Xge(n, r);
            return s.set(e, i), i
        }, Jge = (t, e, n, r, s, i, a, c, l, h, d, p, g) => (v, b, T, m) => {
            if (m.numberOfInputs === 0 && m.numberOfOutputs === 0) throw l();
            const w = Array.isArray(m.outputChannelCount) ? m.outputChannelCount : Array.from(m.outputChannelCount);
            if (w.some(C => C < 1)) throw l();
            if (w.length !== m.numberOfOutputs) throw e();
            if (m.channelCountMode !== "explicit") throw l();
            const P = m.channelCount * m.numberOfInputs,
                V = w.reduce((C, D) => C + D, 0),
                M = T.parameterDescriptors === void 0 ? 0 : T.parameterDescriptors.length;
            if (P + M > 6 || V > 6) throw l();
            const I = new MessageChannel,
                L = [],
                B = [];
            for (let C = 0; C < m.numberOfInputs; C += 1) L.push(a(v, {
                channelCount: m.channelCount,
                channelCountMode: m.channelCountMode,
                channelInterpretation: m.channelInterpretation,
                gain: 1
            })), B.push(s(v, {
                channelCount: m.channelCount,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                numberOfOutputs: m.channelCount
            }));
            const q = [];
            if (T.parameterDescriptors !== void 0)
                for (const {
                        defaultValue: C,
                        maxValue: D,
                        minValue: Z,
                        name: oe
                    }
                    of T.parameterDescriptors) {
                    const pe = i(v, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        offset: m.parameterData[oe] !== void 0 ? m.parameterData[oe] : C === void 0 ? 0 : C
                    });
                    Object.defineProperties(pe.offset, {
                        defaultValue: {
                            get: () => C === void 0 ? 0 : C
                        },
                        maxValue: {
                            get: () => D === void 0 ? hr : D
                        },
                        minValue: {
                            get: () => Z === void 0 ? Tr : Z
                        }
                    }), q.push(pe)
                }
            const se = r(v, {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "speakers",
                    numberOfInputs: Math.max(1, P + M)
                }),
                ce = uI(b, v.sampleRate),
                ue = c(v, ce, P + M, Math.max(1, V)),
                ee = s(v, {
                    channelCount: Math.max(1, V),
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    numberOfOutputs: Math.max(1, V)
                }),
                ge = [];
            for (let C = 0; C < m.numberOfOutputs; C += 1) ge.push(r(v, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "speakers",
                numberOfInputs: w[C]
            }));
            for (let C = 0; C < m.numberOfInputs; C += 1) {
                L[C].connect(B[C]);
                for (let D = 0; D < m.channelCount; D += 1) B[C].connect(se, D, C * m.channelCount + D)
            }
            const G = new oI(T.parameterDescriptors === void 0 ? [] : T.parameterDescriptors.map(({
                name: C
            }, D) => {
                const Z = q[D];
                return Z.connect(se, 0, P + D), Z.start(0), [C, Z.offset]
            }));
            se.connect(ue);
            let le = m.channelInterpretation,
                fe = null;
            const me = m.numberOfOutputs === 0 ? [ue] : ge,
                Te = {
                    get bufferSize() {
                        return ce
                    },
                    get channelCount() {
                        return m.channelCount
                    },
                    set channelCount(C) {
                        throw n()
                    },
                    get channelCountMode() {
                        return m.channelCountMode
                    },
                    set channelCountMode(C) {
                        throw n()
                    },
                    get channelInterpretation() {
                        return le
                    },
                    set channelInterpretation(C) {
                        for (const D of L) D.channelInterpretation = C;
                        le = C
                    },
                    get context() {
                        return ue.context
                    },
                    get inputs() {
                        return L
                    },
                    get numberOfInputs() {
                        return m.numberOfInputs
                    },
                    get numberOfOutputs() {
                        return m.numberOfOutputs
                    },
                    get onprocessorerror() {
                        return fe
                    },
                    set onprocessorerror(C) {
                        typeof fe == "function" && Te.removeEventListener("processorerror", fe), fe = typeof C == "function" ? C : null, typeof fe == "function" && Te.addEventListener("processorerror", fe)
                    },
                    get parameters() {
                        return G
                    },
                    get port() {
                        return I.port2
                    },
                    addEventListener(...C) {
                        return ue.addEventListener(C[0], C[1], C[2])
                    },
                    connect: t.bind(null, me),
                    disconnect: h.bind(null, me),
                    dispatchEvent(...C) {
                        return ue.dispatchEvent(C[0])
                    },
                    removeEventListener(...C) {
                        return ue.removeEventListener(C[0], C[1], C[2])
                    }
                },
                we = new Map;
            I.port1.addEventListener = (C => (...D) => {
                if (D[0] === "message") {
                    const Z = typeof D[1] == "function" ? D[1] : typeof D[1] == "object" && D[1] !== null && typeof D[1].handleEvent == "function" ? D[1].handleEvent : null;
                    if (Z !== null) {
                        const oe = we.get(D[1]);
                        oe !== void 0 ? D[1] = oe : (D[1] = pe => {
                            d(v.currentTime, v.sampleRate, () => Z(pe))
                        }, we.set(Z, D[1]))
                    }
                }
                return C.call(I.port1, D[0], D[1], D[2])
            })(I.port1.addEventListener), I.port1.removeEventListener = (C => (...D) => {
                if (D[0] === "message") {
                    const Z = we.get(D[1]);
                    Z !== void 0 && (we.delete(D[1]), D[1] = Z)
                }
                return C.call(I.port1, D[0], D[1], D[2])
            })(I.port1.removeEventListener);
            let ke = null;
            Object.defineProperty(I.port1, "onmessage", {
                get: () => ke,
                set: C => {
                    typeof ke == "function" && I.port1.removeEventListener("message", ke), ke = typeof C == "function" ? C : null, typeof ke == "function" && (I.port1.addEventListener("message", ke), I.port1.start())
                }
            }), T.prototype.port = I.port1;
            let Ie = null;
            Qge(v, Te, T, m).then(C => Ie = C);
            const At = Ud(m.numberOfInputs, m.channelCount),
                $t = Ud(m.numberOfOutputs, w),
                qe = T.parameterDescriptors === void 0 ? [] : T.parameterDescriptors.reduce((C, {
                    name: D
                }) => ({
                    ...C,
                    [D]: new Float32Array(128)
                }), {});
            let Xe = !0;
            const tt = () => {
                    m.numberOfOutputs > 0 && ue.disconnect(ee);
                    for (let C = 0, D = 0; C < m.numberOfOutputs; C += 1) {
                        const Z = ge[C];
                        for (let oe = 0; oe < w[C]; oe += 1) ee.disconnect(Z, D + oe, oe);
                        D += w[C]
                    }
                },
                S = new Map;
            ue.onaudioprocess = ({
                inputBuffer: C,
                outputBuffer: D
            }) => {
                if (Ie !== null) {
                    const Z = p(Te);
                    for (let oe = 0; oe < ce; oe += 128) {
                        for (let pe = 0; pe < m.numberOfInputs; pe += 1)
                            for (let _e = 0; _e < m.channelCount; _e += 1) Fd(C, At[pe], _e, _e, oe);
                        T.parameterDescriptors !== void 0 && T.parameterDescriptors.forEach(({
                            name: pe
                        }, _e) => {
                            Fd(C, qe, pe, P + _e, oe)
                        });
                        for (let pe = 0; pe < m.numberOfInputs; pe += 1)
                            for (let _e = 0; _e < w[pe]; _e += 1) $t[pe][_e].byteLength === 0 && ($t[pe][_e] = new Float32Array(128));
                        try {
                            const pe = At.map((he, re) => {
                                if (Z[re].size > 0) return S.set(re, ce / 128), he;
                                const Re = S.get(re);
                                return Re === void 0 ? [] : (he.every(De => De.every(Je => Je === 0)) && (Re === 1 ? S.delete(re) : S.set(re, Re - 1)), he)
                            });
                            Xe = d(v.currentTime + oe / v.sampleRate, v.sampleRate, () => Ie.process(pe, $t, qe));
                            for (let he = 0, re = 0; he < m.numberOfOutputs; he += 1) {
                                for (let ae = 0; ae < w[he]; ae += 1) aI(D, $t[he], ae, re + ae, oe);
                                re += w[he]
                            }
                        } catch (pe) {
                            Xe = !1, Te.dispatchEvent(new ErrorEvent("processorerror", {
                                colno: pe.colno,
                                filename: pe.filename,
                                lineno: pe.lineno,
                                message: pe.message
                            }))
                        }
                        if (!Xe) {
                            for (let pe = 0; pe < m.numberOfInputs; pe += 1) {
                                L[pe].disconnect(B[pe]);
                                for (let _e = 0; _e < m.channelCount; _e += 1) B[oe].disconnect(se, _e, pe * m.channelCount + _e)
                            }
                            if (T.parameterDescriptors !== void 0) {
                                const pe = T.parameterDescriptors.length;
                                for (let _e = 0; _e < pe; _e += 1) {
                                    const he = q[_e];
                                    he.disconnect(se, 0, P + _e), he.stop()
                                }
                            }
                            se.disconnect(ue), ue.onaudioprocess = null, k ? tt() : A();
                            break
                        }
                    }
                }
            };
            let k = !1;
            const H = a(v, {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    gain: 0
                }),
                K = () => ue.connect(H).connect(v.destination),
                A = () => {
                    ue.disconnect(H), H.disconnect()
                },
                y = () => {
                    if (Xe) {
                        A(), m.numberOfOutputs > 0 && ue.connect(ee);
                        for (let C = 0, D = 0; C < m.numberOfOutputs; C += 1) {
                            const Z = ge[C];
                            for (let oe = 0; oe < w[C]; oe += 1) ee.connect(Z, D + oe, oe);
                            D += w[C]
                        }
                    }
                    k = !0
                },
                E = () => {
                    Xe && (K(), tt()), k = !1
                };
            return K(), g(Te, y, E)
        }, lI = (t, e) => {
            const n = t.createBiquadFilter();
            return Pn(n, e), ln(n, e, "Q"), ln(n, e, "detune"), ln(n, e, "frequency"), ln(n, e, "gain"), nn(n, e, "type"), n
        }, e_e = (t, e) => (n, r) => {
            const s = n.createChannelMerger(r.numberOfInputs);
            return t !== null && t.name === "webkitAudioContext" && e(n, s), Pn(s, r), s
        }, t_e = t => {
            const e = t.numberOfOutputs;
            Object.defineProperty(t, "channelCount", {
                get: () => e,
                set: n => {
                    if (n !== e) throw Ln()
                }
            }), Object.defineProperty(t, "channelCountMode", {
                get: () => "explicit",
                set: n => {
                    if (n !== "explicit") throw Ln()
                }
            }), Object.defineProperty(t, "channelInterpretation", {
                get: () => "discrete",
                set: n => {
                    if (n !== "discrete") throw Ln()
                }
            })
        }, dh = (t, e) => {
            const n = t.createChannelSplitter(e.numberOfOutputs);
            return Pn(n, e), t_e(n), n
        }, n_e = (t, e, n, r, s) => (i, a) => {
            if (i.createConstantSource === void 0) return n(i, a);
            const c = i.createConstantSource();
            return Pn(c, a), ln(c, a, "offset"), e(r, () => r(i)) || A0(c), e(s, () => s(i)) || C0(c), t(i, c), c
        }, pu = (t, e) => (t.connect = e.connect.bind(e), t.disconnect = e.disconnect.bind(e), t), r_e = (t, e, n, r) => (s, {
            offset: i,
            ...a
        }) => {
            const c = s.createBuffer(1, 2, 44100),
                l = e(s, {
                    buffer: null,
                    channelCount: 2,
                    channelCountMode: "max",
                    channelInterpretation: "speakers",
                    loop: !1,
                    loopEnd: 0,
                    loopStart: 0,
                    playbackRate: 1
                }),
                h = n(s, {
                    ...a,
                    gain: i
                }),
                d = c.getChannelData(0);
            d[0] = 1, d[1] = 1, l.buffer = c, l.loop = !0;
            const p = {
                    get bufferSize() {},
                    get channelCount() {
                        return h.channelCount
                    },
                    set channelCount(b) {
                        h.channelCount = b
                    },
                    get channelCountMode() {
                        return h.channelCountMode
                    },
                    set channelCountMode(b) {
                        h.channelCountMode = b
                    },
                    get channelInterpretation() {
                        return h.channelInterpretation
                    },
                    set channelInterpretation(b) {
                        h.channelInterpretation = b
                    },
                    get context() {
                        return h.context
                    },
                    get inputs() {
                        return []
                    },
                    get numberOfInputs() {
                        return l.numberOfInputs
                    },
                    get numberOfOutputs() {
                        return h.numberOfOutputs
                    },
                    get offset() {
                        return h.gain
                    },
                    get onended() {
                        return l.onended
                    },
                    set onended(b) {
                        l.onended = b
                    },
                    addEventListener(...b) {
                        return l.addEventListener(b[0], b[1], b[2])
                    },
                    dispatchEvent(...b) {
                        return l.dispatchEvent(b[0])
                    },
                    removeEventListener(...b) {
                        return l.removeEventListener(b[0], b[1], b[2])
                    },
                    start(b = 0) {
                        l.start.call(l, b)
                    },
                    stop(b = 0) {
                        l.stop.call(l, b)
                    }
                },
                g = () => l.connect(h),
                v = () => l.disconnect(h);
            return t(s, l), r(pu(p, h), g, v)
        }, s_e = (t, e) => (n, r) => {
            const s = n.createConvolver();
            if (Pn(s, r), r.disableNormalization === s.normalize && (s.normalize = !r.disableNormalization), nn(s, r, "buffer"), r.channelCount > 2 || (e(s, "channelCount", i => () => i.call(s), i => a => {
                    if (a > 2) throw t();
                    return i.call(s, a)
                }), r.channelCountMode === "max")) throw t();
            return e(s, "channelCountMode", i => () => i.call(s), i => a => {
                if (a === "max") throw t();
                return i.call(s, a)
            }), s
        }, hI = (t, e) => {
            const n = t.createDelay(e.maxDelayTime);
            return Pn(n, e), ln(n, e, "delayTime"), n
        }, i_e = t => (e, n) => {
            const r = e.createDynamicsCompressor();
            if (Pn(r, n), n.channelCount > 2 || n.channelCountMode === "max") throw t();
            return ln(r, n, "attack"), ln(r, n, "knee"), ln(r, n, "ratio"), ln(r, n, "release"), ln(r, n, "threshold"), r
        }, Cr = (t, e) => {
            const n = t.createGain();
            return Pn(n, e), ln(n, e, "gain"), n
        }, o_e = t => (e, n, r) => {
            if (e.createIIRFilter === void 0) return t(e, n, r);
            const s = e.createIIRFilter(r.feedforward, r.feedback);
            return Pn(s, r), s
        };

    function a_e(t, e) {
        const n = e[0] * e[0] + e[1] * e[1];
        return [(t[0] * e[0] + t[1] * e[1]) / n, (t[1] * e[0] - t[0] * e[1]) / n]
    }

    function c_e(t, e) {
        return [t[0] * e[0] - t[1] * e[1], t[0] * e[1] + t[1] * e[0]]
    }

    function q3(t, e) {
        let n = [0, 0];
        for (let r = t.length - 1; r >= 0; r -= 1) n = c_e(n, e), n[0] += t[r];
        return n
    }
    const u_e = (t, e, n, r) => (s, i, {
            channelCount: a,
            channelCountMode: c,
            channelInterpretation: l,
            feedback: h,
            feedforward: d
        }) => {
            const p = uI(i, s.sampleRate),
                g = h instanceof Float64Array ? h : new Float64Array(h),
                v = d instanceof Float64Array ? d : new Float64Array(d),
                b = g.length,
                T = v.length,
                m = Math.min(b, T);
            if (b === 0 || b > 20) throw r();
            if (g[0] === 0) throw e();
            if (T === 0 || T > 20) throw r();
            if (v[0] === 0) throw e();
            if (g[0] !== 1) {
                for (let q = 0; q < T; q += 1) v[q] /= g[0];
                for (let q = 1; q < b; q += 1) g[q] /= g[0]
            }
            const w = n(s, p, a, a);
            w.channelCount = a, w.channelCountMode = c, w.channelInterpretation = l;
            const P = 32,
                V = [],
                M = [],
                I = [];
            for (let q = 0; q < a; q += 1) {
                V.push(0);
                const se = new Float32Array(P),
                    ce = new Float32Array(P);
                se.fill(0), ce.fill(0), M.push(se), I.push(ce)
            }
            w.onaudioprocess = q => {
                const se = q.inputBuffer,
                    ce = q.outputBuffer,
                    ue = se.numberOfChannels;
                for (let ee = 0; ee < ue; ee += 1) {
                    const ge = se.getChannelData(ee),
                        G = ce.getChannelData(ee);
                    V[ee] = cI(g, b, v, T, m, M[ee], I[ee], V[ee], P, ge, G)
                }
            };
            const L = s.sampleRate / 2;
            return pu({
                get bufferSize() {
                    return p
                },
                get channelCount() {
                    return w.channelCount
                },
                set channelCount(q) {
                    w.channelCount = q
                },
                get channelCountMode() {
                    return w.channelCountMode
                },
                set channelCountMode(q) {
                    w.channelCountMode = q
                },
                get channelInterpretation() {
                    return w.channelInterpretation
                },
                set channelInterpretation(q) {
                    w.channelInterpretation = q
                },
                get context() {
                    return w.context
                },
                get inputs() {
                    return [w]
                },
                get numberOfInputs() {
                    return w.numberOfInputs
                },
                get numberOfOutputs() {
                    return w.numberOfOutputs
                },
                addEventListener(...q) {
                    return w.addEventListener(q[0], q[1], q[2])
                },
                dispatchEvent(...q) {
                    return w.dispatchEvent(q[0])
                },
                getFrequencyResponse(q, se, ce) {
                    if (q.length !== se.length || se.length !== ce.length) throw t();
                    const ue = q.length;
                    for (let ee = 0; ee < ue; ee += 1) {
                        const ge = -Math.PI * (q[ee] / L),
                            G = [Math.cos(ge), Math.sin(ge)],
                            le = q3(v, G),
                            fe = q3(g, G),
                            me = a_e(le, fe);
                        se[ee] = Math.sqrt(me[0] * me[0] + me[1] * me[1]), ce[ee] = Math.atan2(me[1], me[0])
                    }
                },
                removeEventListener(...q) {
                    return w.removeEventListener(q[0], q[1], q[2])
                }
            }, w)
        },
        l_e = (t, e) => t.createMediaElementSource(e.mediaElement),
        h_e = (t, e) => {
            const n = t.createMediaStreamDestination();
            return Pn(n, e), n.numberOfOutputs === 1 && Object.defineProperty(n, "numberOfOutputs", {
                get: () => 0
            }), n
        },
        f_e = (t, {
            mediaStream: e
        }) => {
            const n = e.getAudioTracks();
            n.sort((i, a) => i.id < a.id ? -1 : i.id > a.id ? 1 : 0);
            const r = n.slice(0, 1),
                s = t.createMediaStreamSource(new MediaStream(r));
            return Object.defineProperty(s, "mediaStream", {
                value: e
            }), s
        },
        d_e = (t, e) => (n, {
            mediaStreamTrack: r
        }) => {
            if (typeof n.createMediaStreamTrackSource == "function") return n.createMediaStreamTrackSource(r);
            const s = new MediaStream([r]),
                i = n.createMediaStreamSource(s);
            if (r.kind !== "audio") throw t();
            if (e(n)) throw new TypeError;
            return i
        },
        p_e = t => t === null ? null : t.hasOwnProperty("OfflineAudioContext") ? t.OfflineAudioContext : t.hasOwnProperty("webkitOfflineAudioContext") ? t.webkitOfflineAudioContext : null,
        m_e = (t, e, n, r, s, i) => (a, c) => {
            const l = a.createOscillator();
            return Pn(l, c), ln(l, c, "detune"), ln(l, c, "frequency"), c.periodicWave !== void 0 ? l.setPeriodicWave(c.periodicWave) : nn(l, c, "type"), e(n, () => n(a)) || A0(l), e(r, () => r(a)) || i(l, a), e(s, () => s(a)) || C0(l), t(a, l), l
        },
        g_e = t => (e, n) => {
            const r = e.createPanner();
            return r.orientationX === void 0 ? t(e, n) : (Pn(r, n), ln(r, n, "orientationX"), ln(r, n, "orientationY"), ln(r, n, "orientationZ"), ln(r, n, "positionX"), ln(r, n, "positionY"), ln(r, n, "positionZ"), nn(r, n, "coneInnerAngle"), nn(r, n, "coneOuterAngle"), nn(r, n, "coneOuterGain"), nn(r, n, "distanceModel"), nn(r, n, "maxDistance"), nn(r, n, "panningModel"), nn(r, n, "refDistance"), nn(r, n, "rolloffFactor"), r)
        },
        __e = (t, e, n, r, s, i, a, c, l, h) => (d, {
            coneInnerAngle: p,
            coneOuterAngle: g,
            coneOuterGain: v,
            distanceModel: b,
            maxDistance: T,
            orientationX: m,
            orientationY: w,
            orientationZ: P,
            panningModel: V,
            positionX: M,
            positionY: I,
            positionZ: L,
            refDistance: B,
            rolloffFactor: q,
            ...se
        }) => {
            const ce = d.createPanner();
            if (se.channelCount > 2 || se.channelCountMode === "max") throw a();
            Pn(ce, se);
            const ue = {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete"
                },
                ee = n(d, {
                    ...ue,
                    channelInterpretation: "speakers",
                    numberOfInputs: 6
                }),
                ge = r(d, {
                    ...se,
                    gain: 1
                }),
                G = r(d, {
                    ...ue,
                    gain: 1
                }),
                le = r(d, {
                    ...ue,
                    gain: 0
                }),
                fe = r(d, {
                    ...ue,
                    gain: 0
                }),
                me = r(d, {
                    ...ue,
                    gain: 0
                }),
                Te = r(d, {
                    ...ue,
                    gain: 0
                }),
                we = r(d, {
                    ...ue,
                    gain: 0
                }),
                ke = s(d, 256, 6, 1),
                Ie = i(d, {
                    ...ue,
                    curve: new Float32Array([1, 1]),
                    oversample: "none"
                });
            let $e = [m, w, P],
                At = [M, I, L];
            const $t = new Float32Array(1);
            ke.onaudioprocess = ({
                inputBuffer: S
            }) => {
                const k = [l(S, $t, 0), l(S, $t, 1), l(S, $t, 2)];
                k.some((K, A) => K !== $e[A]) && (ce.setOrientation(...k), $e = k);
                const H = [l(S, $t, 3), l(S, $t, 4), l(S, $t, 5)];
                H.some((K, A) => K !== At[A]) && (ce.setPosition(...H), At = H)
            }, Object.defineProperty(le.gain, "defaultValue", {
                get: () => 0
            }), Object.defineProperty(fe.gain, "defaultValue", {
                get: () => 0
            }), Object.defineProperty(me.gain, "defaultValue", {
                get: () => 0
            }), Object.defineProperty(Te.gain, "defaultValue", {
                get: () => 0
            }), Object.defineProperty(we.gain, "defaultValue", {
                get: () => 0
            });
            const qe = {
                get bufferSize() {},
                get channelCount() {
                    return ce.channelCount
                },
                set channelCount(S) {
                    if (S > 2) throw a();
                    ge.channelCount = S, ce.channelCount = S
                },
                get channelCountMode() {
                    return ce.channelCountMode
                },
                set channelCountMode(S) {
                    if (S === "max") throw a();
                    ge.channelCountMode = S, ce.channelCountMode = S
                },
                get channelInterpretation() {
                    return ce.channelInterpretation
                },
                set channelInterpretation(S) {
                    ge.channelInterpretation = S, ce.channelInterpretation = S
                },
                get coneInnerAngle() {
                    return ce.coneInnerAngle
                },
                set coneInnerAngle(S) {
                    ce.coneInnerAngle = S
                },
                get coneOuterAngle() {
                    return ce.coneOuterAngle
                },
                set coneOuterAngle(S) {
                    ce.coneOuterAngle = S
                },
                get coneOuterGain() {
                    return ce.coneOuterGain
                },
                set coneOuterGain(S) {
                    if (S < 0 || S > 1) throw e();
                    ce.coneOuterGain = S
                },
                get context() {
                    return ce.context
                },
                get distanceModel() {
                    return ce.distanceModel
                },
                set distanceModel(S) {
                    ce.distanceModel = S
                },
                get inputs() {
                    return [ge]
                },
                get maxDistance() {
                    return ce.maxDistance
                },
                set maxDistance(S) {
                    if (S < 0) throw new RangeError;
                    ce.maxDistance = S
                },
                get numberOfInputs() {
                    return ce.numberOfInputs
                },
                get numberOfOutputs() {
                    return ce.numberOfOutputs
                },
                get orientationX() {
                    return G.gain
                },
                get orientationY() {
                    return le.gain
                },
                get orientationZ() {
                    return fe.gain
                },
                get panningModel() {
                    return ce.panningModel
                },
                set panningModel(S) {
                    ce.panningModel = S
                },
                get positionX() {
                    return me.gain
                },
                get positionY() {
                    return Te.gain
                },
                get positionZ() {
                    return we.gain
                },
                get refDistance() {
                    return ce.refDistance
                },
                set refDistance(S) {
                    if (S < 0) throw new RangeError;
                    ce.refDistance = S
                },
                get rolloffFactor() {
                    return ce.rolloffFactor
                },
                set rolloffFactor(S) {
                    if (S < 0) throw new RangeError;
                    ce.rolloffFactor = S
                },
                addEventListener(...S) {
                    return ge.addEventListener(S[0], S[1], S[2])
                },
                dispatchEvent(...S) {
                    return ge.dispatchEvent(S[0])
                },
                removeEventListener(...S) {
                    return ge.removeEventListener(S[0], S[1], S[2])
                }
            };
            p !== qe.coneInnerAngle && (qe.coneInnerAngle = p), g !== qe.coneOuterAngle && (qe.coneOuterAngle = g), v !== qe.coneOuterGain && (qe.coneOuterGain = v), b !== qe.distanceModel && (qe.distanceModel = b), T !== qe.maxDistance && (qe.maxDistance = T), m !== qe.orientationX.value && (qe.orientationX.value = m), w !== qe.orientationY.value && (qe.orientationY.value = w), P !== qe.orientationZ.value && (qe.orientationZ.value = P), V !== qe.panningModel && (qe.panningModel = V), M !== qe.positionX.value && (qe.positionX.value = M), I !== qe.positionY.value && (qe.positionY.value = I), L !== qe.positionZ.value && (qe.positionZ.value = L), B !== qe.refDistance && (qe.refDistance = B), q !== qe.rolloffFactor && (qe.rolloffFactor = q), ($e[0] !== 1 || $e[1] !== 0 || $e[2] !== 0) && ce.setOrientation(...$e), (At[0] !== 0 || At[1] !== 0 || At[2] !== 0) && ce.setPosition(...At);
            const Xe = () => {
                    ge.connect(ce), t(ge, Ie, 0, 0), Ie.connect(G).connect(ee, 0, 0), Ie.connect(le).connect(ee, 0, 1), Ie.connect(fe).connect(ee, 0, 2), Ie.connect(me).connect(ee, 0, 3), Ie.connect(Te).connect(ee, 0, 4), Ie.connect(we).connect(ee, 0, 5), ee.connect(ke).connect(d.destination)
                },
                tt = () => {
                    ge.disconnect(ce), c(ge, Ie, 0, 0), Ie.disconnect(G), G.disconnect(ee), Ie.disconnect(le), le.disconnect(ee), Ie.disconnect(fe), fe.disconnect(ee), Ie.disconnect(me), me.disconnect(ee), Ie.disconnect(Te), Te.disconnect(ee), Ie.disconnect(we), we.disconnect(ee), ee.disconnect(ke), ke.disconnect(d.destination)
                };
            return h(pu(qe, ce), Xe, tt)
        },
        y_e = t => (e, {
            disableNormalization: n,
            imag: r,
            real: s
        }) => {
            const i = r instanceof Float32Array ? r : new Float32Array(r),
                a = s instanceof Float32Array ? s : new Float32Array(s),
                c = e.createPeriodicWave(a, i, {
                    disableNormalization: n
                });
            if (Array.from(r).length < 2) throw t();
            return c
        },
        ph = (t, e, n, r) => t.createScriptProcessor(e, n, r),
        v_e = (t, e) => (n, r) => {
            const s = r.channelCountMode;
            if (s === "clamped-max") throw e();
            if (n.createStereoPanner === void 0) return t(n, r);
            const i = n.createStereoPanner();
            return Pn(i, r), ln(i, r, "pan"), Object.defineProperty(i, "channelCountMode", {
                get: () => s,
                set: a => {
                    if (a !== s) throw e()
                }
            }), i
        },
        b_e = (t, e, n, r, s, i) => {
            const c = new Float32Array([1, 1]),
                l = Math.PI / 2,
                h = {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete"
                },
                d = {
                    ...h,
                    oversample: "none"
                },
                p = (b, T, m, w) => {
                    const P = new Float32Array(16385),
                        V = new Float32Array(16385);
                    for (let se = 0; se < 16385; se += 1) {
                        const ce = se / 16384 * l;
                        P[se] = Math.cos(ce), V[se] = Math.sin(ce)
                    }
                    const M = n(b, {
                            ...h,
                            gain: 0
                        }),
                        I = r(b, {
                            ...d,
                            curve: P
                        }),
                        L = r(b, {
                            ...d,
                            curve: c
                        }),
                        B = n(b, {
                            ...h,
                            gain: 0
                        }),
                        q = r(b, {
                            ...d,
                            curve: V
                        });
                    return {
                        connectGraph() {
                            T.connect(M), T.connect(L.inputs === void 0 ? L : L.inputs[0]), T.connect(B), L.connect(m), m.connect(I.inputs === void 0 ? I : I.inputs[0]), m.connect(q.inputs === void 0 ? q : q.inputs[0]), I.connect(M.gain), q.connect(B.gain), M.connect(w, 0, 0), B.connect(w, 0, 1)
                        },
                        disconnectGraph() {
                            T.disconnect(M), T.disconnect(L.inputs === void 0 ? L : L.inputs[0]), T.disconnect(B), L.disconnect(m), m.disconnect(I.inputs === void 0 ? I : I.inputs[0]), m.disconnect(q.inputs === void 0 ? q : q.inputs[0]), I.disconnect(M.gain), q.disconnect(B.gain), M.disconnect(w, 0, 0), B.disconnect(w, 0, 1)
                        }
                    }
                },
                g = (b, T, m, w) => {
                    const P = new Float32Array(16385),
                        V = new Float32Array(16385),
                        M = new Float32Array(16385),
                        I = new Float32Array(16385),
                        L = Math.floor(16385 / 2);
                    for (let me = 0; me < 16385; me += 1)
                        if (me > L) {
                            const Te = (me - L) / (16384 - L) * l;
                            P[me] = Math.cos(Te), V[me] = Math.sin(Te), M[me] = 0, I[me] = 1
                        } else {
                            const Te = me / (16384 - L) * l;
                            P[me] = 1, V[me] = 0, M[me] = Math.cos(Te), I[me] = Math.sin(Te)
                        } const B = e(b, {
                            channelCount: 2,
                            channelCountMode: "explicit",
                            channelInterpretation: "discrete",
                            numberOfOutputs: 2
                        }),
                        q = n(b, {
                            ...h,
                            gain: 0
                        }),
                        se = r(b, {
                            ...d,
                            curve: P
                        }),
                        ce = n(b, {
                            ...h,
                            gain: 0
                        }),
                        ue = r(b, {
                            ...d,
                            curve: V
                        }),
                        ee = r(b, {
                            ...d,
                            curve: c
                        }),
                        ge = n(b, {
                            ...h,
                            gain: 0
                        }),
                        G = r(b, {
                            ...d,
                            curve: M
                        }),
                        le = n(b, {
                            ...h,
                            gain: 0
                        }),
                        fe = r(b, {
                            ...d,
                            curve: I
                        });
                    return {
                        connectGraph() {
                            T.connect(B), T.connect(ee.inputs === void 0 ? ee : ee.inputs[0]), B.connect(q, 0), B.connect(ce, 0), B.connect(ge, 1), B.connect(le, 1), ee.connect(m), m.connect(se.inputs === void 0 ? se : se.inputs[0]), m.connect(ue.inputs === void 0 ? ue : ue.inputs[0]), m.connect(G.inputs === void 0 ? G : G.inputs[0]), m.connect(fe.inputs === void 0 ? fe : fe.inputs[0]), se.connect(q.gain), ue.connect(ce.gain), G.connect(ge.gain), fe.connect(le.gain), q.connect(w, 0, 0), ge.connect(w, 0, 0), ce.connect(w, 0, 1), le.connect(w, 0, 1)
                        },
                        disconnectGraph() {
                            T.disconnect(B), T.disconnect(ee.inputs === void 0 ? ee : ee.inputs[0]), B.disconnect(q, 0), B.disconnect(ce, 0), B.disconnect(ge, 1), B.disconnect(le, 1), ee.disconnect(m), m.disconnect(se.inputs === void 0 ? se : se.inputs[0]), m.disconnect(ue.inputs === void 0 ? ue : ue.inputs[0]), m.disconnect(G.inputs === void 0 ? G : G.inputs[0]), m.disconnect(fe.inputs === void 0 ? fe : fe.inputs[0]), se.disconnect(q.gain), ue.disconnect(ce.gain), G.disconnect(ge.gain), fe.disconnect(le.gain), q.disconnect(w, 0, 0), ge.disconnect(w, 0, 0), ce.disconnect(w, 0, 1), le.disconnect(w, 0, 1)
                        }
                    }
                },
                v = (b, T, m, w, P) => {
                    if (T === 1) return p(b, m, w, P);
                    if (T === 2) return g(b, m, w, P);
                    throw s()
                };
            return (b, {
                channelCount: T,
                channelCountMode: m,
                pan: w,
                ...P
            }) => {
                if (m === "max") throw s();
                const V = t(b, {
                        ...P,
                        channelCount: 1,
                        channelCountMode: m,
                        numberOfInputs: 2
                    }),
                    M = n(b, {
                        ...P,
                        channelCount: T,
                        channelCountMode: m,
                        gain: 1
                    }),
                    I = n(b, {
                        channelCount: 1,
                        channelCountMode: "explicit",
                        channelInterpretation: "discrete",
                        gain: w
                    });
                let {
                    connectGraph: L,
                    disconnectGraph: B
                } = v(b, T, M, I, V);
                Object.defineProperty(I.gain, "defaultValue", {
                    get: () => 0
                }), Object.defineProperty(I.gain, "maxValue", {
                    get: () => 1
                }), Object.defineProperty(I.gain, "minValue", {
                    get: () => -1
                });
                const q = {
                    get bufferSize() {},
                    get channelCount() {
                        return M.channelCount
                    },
                    set channelCount(ee) {
                        M.channelCount !== ee && (se && B(), {
                            connectGraph: L,
                            disconnectGraph: B
                        } = v(b, ee, M, I, V), se && L()), M.channelCount = ee
                    },
                    get channelCountMode() {
                        return M.channelCountMode
                    },
                    set channelCountMode(ee) {
                        if (ee === "clamped-max" || ee === "max") throw s();
                        M.channelCountMode = ee
                    },
                    get channelInterpretation() {
                        return M.channelInterpretation
                    },
                    set channelInterpretation(ee) {
                        M.channelInterpretation = ee
                    },
                    get context() {
                        return M.context
                    },
                    get inputs() {
                        return [M]
                    },
                    get numberOfInputs() {
                        return M.numberOfInputs
                    },
                    get numberOfOutputs() {
                        return M.numberOfOutputs
                    },
                    get pan() {
                        return I.gain
                    },
                    addEventListener(...ee) {
                        return M.addEventListener(ee[0], ee[1], ee[2])
                    },
                    dispatchEvent(...ee) {
                        return M.dispatchEvent(ee[0])
                    },
                    removeEventListener(...ee) {
                        return M.removeEventListener(ee[0], ee[1], ee[2])
                    }
                };
                let se = !1;
                const ce = () => {
                        L(), se = !0
                    },
                    ue = () => {
                        B(), se = !1
                    };
                return i(pu(q, V), ce, ue)
            }
        },
        E_e = (t, e, n, r, s, i, a) => (c, l) => {
            const h = c.createWaveShaper();
            if (i !== null && i.name === "webkitAudioContext" && c.createGain().gain.automationRate === void 0) return n(c, l);
            Pn(h, l);
            const d = l.curve === null || l.curve instanceof Float32Array ? l.curve : new Float32Array(l.curve);
            if (d !== null && d.length < 2) throw e();
            nn(h, {
                curve: d
            }, "curve"), nn(h, l, "oversample");
            let p = null,
                g = !1;
            return a(h, "curve", T => () => T.call(h), T => m => (T.call(h, m), g && (r(m) && p === null ? p = t(c, h) : !r(m) && p !== null && (p(), p = null)), m)), s(h, () => {
                g = !0, r(h.curve) && (p = t(c, h))
            }, () => {
                g = !1, p !== null && (p(), p = null)
            })
        },
        S_e = (t, e, n, r, s) => (i, {
            curve: a,
            oversample: c,
            ...l
        }) => {
            const h = i.createWaveShaper(),
                d = i.createWaveShaper();
            Pn(h, l), Pn(d, l);
            const p = n(i, {
                    ...l,
                    gain: 1
                }),
                g = n(i, {
                    ...l,
                    gain: -1
                }),
                v = n(i, {
                    ...l,
                    gain: 1
                }),
                b = n(i, {
                    ...l,
                    gain: -1
                });
            let T = null,
                m = !1,
                w = null;
            const P = {
                get bufferSize() {},
                get channelCount() {
                    return h.channelCount
                },
                set channelCount(I) {
                    p.channelCount = I, g.channelCount = I, h.channelCount = I, v.channelCount = I, d.channelCount = I, b.channelCount = I
                },
                get channelCountMode() {
                    return h.channelCountMode
                },
                set channelCountMode(I) {
                    p.channelCountMode = I, g.channelCountMode = I, h.channelCountMode = I, v.channelCountMode = I, d.channelCountMode = I, b.channelCountMode = I
                },
                get channelInterpretation() {
                    return h.channelInterpretation
                },
                set channelInterpretation(I) {
                    p.channelInterpretation = I, g.channelInterpretation = I, h.channelInterpretation = I, v.channelInterpretation = I, d.channelInterpretation = I, b.channelInterpretation = I
                },
                get context() {
                    return h.context
                },
                get curve() {
                    return w
                },
                set curve(I) {
                    if (I !== null && I.length < 2) throw e();
                    if (I === null) h.curve = I, d.curve = I;
                    else {
                        const L = I.length,
                            B = new Float32Array(L + 2 - L % 2),
                            q = new Float32Array(L + 2 - L % 2);
                        B[0] = I[0], q[0] = -I[L - 1];
                        const se = Math.ceil((L + 1) / 2),
                            ce = (L + 1) / 2 - 1;
                        for (let ue = 1; ue < se; ue += 1) {
                            const ee = ue / se * ce,
                                ge = Math.floor(ee),
                                G = Math.ceil(ee);
                            B[ue] = ge === G ? I[ge] : (1 - (ee - ge)) * I[ge] + (1 - (G - ee)) * I[G], q[ue] = ge === G ? -I[L - 1 - ge] : -((1 - (ee - ge)) * I[L - 1 - ge]) - (1 - (G - ee)) * I[L - 1 - G]
                        }
                        B[se] = L % 2 === 1 ? I[se - 1] : (I[se - 2] + I[se - 1]) / 2, h.curve = B, d.curve = q
                    }
                    w = I, m && (r(w) && T === null ? T = t(i, p) : T !== null && (T(), T = null))
                },
                get inputs() {
                    return [p]
                },
                get numberOfInputs() {
                    return h.numberOfInputs
                },
                get numberOfOutputs() {
                    return h.numberOfOutputs
                },
                get oversample() {
                    return h.oversample
                },
                set oversample(I) {
                    h.oversample = I, d.oversample = I
                },
                addEventListener(...I) {
                    return p.addEventListener(I[0], I[1], I[2])
                },
                dispatchEvent(...I) {
                    return p.dispatchEvent(I[0])
                },
                removeEventListener(...I) {
                    return p.removeEventListener(I[0], I[1], I[2])
                }
            };
            a !== null && (P.curve = a instanceof Float32Array ? a : new Float32Array(a)), c !== P.oversample && (P.oversample = c);
            const V = () => {
                    p.connect(h).connect(v), p.connect(g).connect(d).connect(b).connect(v), m = !0, r(w) && (T = t(i, p))
                },
                M = () => {
                    p.disconnect(h), h.disconnect(v), p.disconnect(g), g.disconnect(d), d.disconnect(b), b.disconnect(v), m = !1, T !== null && (T(), T = null)
                };
            return s(pu(P, v), V, M)
        },
        mr = () => new DOMException("", "NotSupportedError"),
        T_e = {
            numberOfChannels: 1
        },
        w_e = (t, e, n, r, s) => class extends t {
            constructor(a, c, l) {
                let h;
                if (typeof a == "number" && c !== void 0 && l !== void 0) h = {
                    length: c,
                    numberOfChannels: a,
                    sampleRate: l
                };
                else if (typeof a == "object") h = a;
                else throw new Error("The given parameters are not valid.");
                const {
                    length: d,
                    numberOfChannels: p,
                    sampleRate: g
                } = {
                    ...T_e,
                    ...h
                }, v = r(p, d, g);
                e(Tl, () => Tl(v)) || v.addEventListener("statechange", (() => {
                    let b = 0;
                    const T = m => {
                        this._state === "running" && (b > 0 ? (v.removeEventListener("statechange", T), m.stopImmediatePropagation(), this._waitForThePromiseToSettle(m)) : b += 1)
                    };
                    return T
                })()), super(v, p), this._length = d, this._nativeOfflineAudioContext = v, this._state = null
            }
            get length() {
                return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length
            }
            get state() {
                return this._state === null ? this._nativeOfflineAudioContext.state : this._state
            }
            startRendering() {
                return this._state === "running" ? Promise.reject(n()) : (this._state = "running", s(this.destination, this._nativeOfflineAudioContext).finally(() => {
                    this._state = null, nI(this)
                }))
            }
            _waitForThePromiseToSettle(a) {
                this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(a) : setTimeout(() => this._waitForThePromiseToSettle(a))
            }
        },
        O_e = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            detune: 0,
            frequency: 440,
            periodicWave: void 0,
            type: "sine"
        },
        A_e = (t, e, n, r, s, i, a) => class extends t {
            constructor(l, h) {
                const d = s(l),
                    p = {
                        ...O_e,
                        ...h
                    },
                    g = n(d, p),
                    v = i(d),
                    b = v ? r() : null,
                    T = l.sampleRate / 2;
                super(l, !1, g, b), this._detune = e(this, v, g.detune, 153600, -153600), this._frequency = e(this, v, g.frequency, T, -T), this._nativeOscillatorNode = g, this._onended = null, this._oscillatorNodeRenderer = b, this._oscillatorNodeRenderer !== null && p.periodicWave !== void 0 && (this._oscillatorNodeRenderer.periodicWave = p.periodicWave)
            }
            get detune() {
                return this._detune
            }
            get frequency() {
                return this._frequency
            }
            get onended() {
                return this._onended
            }
            set onended(l) {
                const h = typeof l == "function" ? a(this, l) : null;
                this._nativeOscillatorNode.onended = h;
                const d = this._nativeOscillatorNode.onended;
                this._onended = d !== null && d === h ? l : d
            }
            get type() {
                return this._nativeOscillatorNode.type
            }
            set type(l) {
                this._nativeOscillatorNode.type = l, this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = null)
            }
            setPeriodicWave(l) {
                this._nativeOscillatorNode.setPeriodicWave(l), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = l)
            }
            start(l = 0) {
                if (this._nativeOscillatorNode.start(l), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.start = l), this.context.state !== "closed") {
                    qc(this);
                    const h = () => {
                        this._nativeOscillatorNode.removeEventListener("ended", h), ki(this) && lh(this)
                    };
                    this._nativeOscillatorNode.addEventListener("ended", h)
                }
            }
            stop(l = 0) {
                this._nativeOscillatorNode.stop(l), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.stop = l)
            }
        },
        C_e = (t, e, n, r, s) => () => {
            const i = new WeakMap;
            let a = null,
                c = null,
                l = null;
            const h = async (d, p) => {
                let g = n(d);
                const v = ir(g, p);
                if (!v) {
                    const b = {
                        channelCount: g.channelCount,
                        channelCountMode: g.channelCountMode,
                        channelInterpretation: g.channelInterpretation,
                        detune: g.detune.value,
                        frequency: g.frequency.value,
                        periodicWave: a === null ? void 0 : a,
                        type: g.type
                    };
                    g = e(p, b), c !== null && g.start(c), l !== null && g.stop(l)
                }
                return i.set(p, g), v ? (await t(p, d.detune, g.detune), await t(p, d.frequency, g.frequency)) : (await r(p, d.detune, g.detune), await r(p, d.frequency, g.frequency)), await s(d, p, g), g
            };
            return {
                set periodicWave(d) {
                    a = d
                },
                set start(d) {
                    c = d
                },
                set stop(d) {
                    l = d
                },
                render(d, p) {
                    const g = i.get(p);
                    return g !== void 0 ? Promise.resolve(g) : h(d, p)
                }
            }
        },
        I_e = {
            channelCount: 2,
            channelCountMode: "clamped-max",
            channelInterpretation: "speakers",
            coneInnerAngle: 360,
            coneOuterAngle: 360,
            coneOuterGain: 0,
            distanceModel: "inverse",
            maxDistance: 1e4,
            orientationX: 1,
            orientationY: 0,
            orientationZ: 0,
            panningModel: "equalpower",
            positionX: 0,
            positionY: 0,
            positionZ: 0,
            refDistance: 1,
            rolloffFactor: 1
        },
        k_e = (t, e, n, r, s, i, a) => class extends t {
            constructor(l, h) {
                const d = s(l),
                    p = {
                        ...I_e,
                        ...h
                    },
                    g = n(d, p),
                    v = i(d),
                    b = v ? r() : null;
                super(l, !1, g, b), this._nativePannerNode = g, this._orientationX = e(this, v, g.orientationX, hr, Tr), this._orientationY = e(this, v, g.orientationY, hr, Tr), this._orientationZ = e(this, v, g.orientationZ, hr, Tr), this._positionX = e(this, v, g.positionX, hr, Tr), this._positionY = e(this, v, g.positionY, hr, Tr), this._positionZ = e(this, v, g.positionZ, hr, Tr), a(this, 1)
            }
            get coneInnerAngle() {
                return this._nativePannerNode.coneInnerAngle
            }
            set coneInnerAngle(l) {
                this._nativePannerNode.coneInnerAngle = l
            }
            get coneOuterAngle() {
                return this._nativePannerNode.coneOuterAngle
            }
            set coneOuterAngle(l) {
                this._nativePannerNode.coneOuterAngle = l
            }
            get coneOuterGain() {
                return this._nativePannerNode.coneOuterGain
            }
            set coneOuterGain(l) {
                this._nativePannerNode.coneOuterGain = l
            }
            get distanceModel() {
                return this._nativePannerNode.distanceModel
            }
            set distanceModel(l) {
                this._nativePannerNode.distanceModel = l
            }
            get maxDistance() {
                return this._nativePannerNode.maxDistance
            }
            set maxDistance(l) {
                this._nativePannerNode.maxDistance = l
            }
            get orientationX() {
                return this._orientationX
            }
            get orientationY() {
                return this._orientationY
            }
            get orientationZ() {
                return this._orientationZ
            }
            get panningModel() {
                return this._nativePannerNode.panningModel
            }
            set panningModel(l) {
                this._nativePannerNode.panningModel = l
            }
            get positionX() {
                return this._positionX
            }
            get positionY() {
                return this._positionY
            }
            get positionZ() {
                return this._positionZ
            }
            get refDistance() {
                return this._nativePannerNode.refDistance
            }
            set refDistance(l) {
                this._nativePannerNode.refDistance = l
            }
            get rolloffFactor() {
                return this._nativePannerNode.rolloffFactor
            }
            set rolloffFactor(l) {
                this._nativePannerNode.rolloffFactor = l
            }
        },
        N_e = (t, e, n, r, s, i, a, c, l, h) => () => {
            const d = new WeakMap;
            let p = null;
            const g = async (v, b) => {
                let T = null,
                    m = i(v);
                const w = {
                        channelCount: m.channelCount,
                        channelCountMode: m.channelCountMode,
                        channelInterpretation: m.channelInterpretation
                    },
                    P = {
                        ...w,
                        coneInnerAngle: m.coneInnerAngle,
                        coneOuterAngle: m.coneOuterAngle,
                        coneOuterGain: m.coneOuterGain,
                        distanceModel: m.distanceModel,
                        maxDistance: m.maxDistance,
                        panningModel: m.panningModel,
                        refDistance: m.refDistance,
                        rolloffFactor: m.rolloffFactor
                    },
                    V = ir(m, b);
                if ("bufferSize" in m) T = r(b, {
                    ...w,
                    gain: 1
                });
                else if (!V) {
                    const M = {
                        ...P,
                        orientationX: m.orientationX.value,
                        orientationY: m.orientationY.value,
                        orientationZ: m.orientationZ.value,
                        positionX: m.positionX.value,
                        positionY: m.positionY.value,
                        positionZ: m.positionZ.value
                    };
                    m = s(b, M)
                }
                if (d.set(b, T === null ? m : T), T !== null) {
                    if (p === null) {
                        if (a === null) throw new Error("Missing the native OfflineAudioContext constructor.");
                        const ue = new a(6, v.context.length, b.sampleRate),
                            ee = e(ue, {
                                channelCount: 1,
                                channelCountMode: "explicit",
                                channelInterpretation: "speakers",
                                numberOfInputs: 6
                            });
                        ee.connect(ue.destination), p = (async () => {
                            const ge = await Promise.all([v.orientationX, v.orientationY, v.orientationZ, v.positionX, v.positionY, v.positionZ].map(async (G, le) => {
                                const fe = n(ue, {
                                    channelCount: 1,
                                    channelCountMode: "explicit",
                                    channelInterpretation: "discrete",
                                    offset: le === 0 ? 1 : 0
                                });
                                return await c(ue, G, fe.offset), fe
                            }));
                            for (let G = 0; G < 6; G += 1) ge[G].connect(ee, 0, G), ge[G].start(0);
                            return h(ue)
                        })()
                    }
                    const M = await p,
                        I = r(b, {
                            ...w,
                            gain: 1
                        });
                    await l(v, b, I);
                    const L = [];
                    for (let ue = 0; ue < M.numberOfChannels; ue += 1) L.push(M.getChannelData(ue));
                    let B = [L[0][0], L[1][0], L[2][0]],
                        q = [L[3][0], L[4][0], L[5][0]],
                        se = r(b, {
                            ...w,
                            gain: 1
                        }),
                        ce = s(b, {
                            ...P,
                            orientationX: B[0],
                            orientationY: B[1],
                            orientationZ: B[2],
                            positionX: q[0],
                            positionY: q[1],
                            positionZ: q[2]
                        });
                    I.connect(se).connect(ce.inputs[0]), ce.connect(T);
                    for (let ue = 128; ue < M.length; ue += 128) {
                        const ee = [L[0][ue], L[1][ue], L[2][ue]],
                            ge = [L[3][ue], L[4][ue], L[5][ue]];
                        if (ee.some((G, le) => G !== B[le]) || ge.some((G, le) => G !== q[le])) {
                            B = ee, q = ge;
                            const G = ue / b.sampleRate;
                            se.gain.setValueAtTime(0, G), se = r(b, {
                                ...w,
                                gain: 0
                            }), ce = s(b, {
                                ...P,
                                orientationX: B[0],
                                orientationY: B[1],
                                orientationZ: B[2],
                                positionX: q[0],
                                positionY: q[1],
                                positionZ: q[2]
                            }), se.gain.setValueAtTime(1, G), I.connect(se).connect(ce.inputs[0]), ce.connect(T)
                        }
                    }
                    return T
                }
                return V ? (await t(b, v.orientationX, m.orientationX), await t(b, v.orientationY, m.orientationY), await t(b, v.orientationZ, m.orientationZ), await t(b, v.positionX, m.positionX), await t(b, v.positionY, m.positionY), await t(b, v.positionZ, m.positionZ)) : (await c(b, v.orientationX, m.orientationX), await c(b, v.orientationY, m.orientationY), await c(b, v.orientationZ, m.orientationZ), await c(b, v.positionX, m.positionX), await c(b, v.positionY, m.positionY), await c(b, v.positionZ, m.positionZ)), du(m) ? await l(v, b, m.inputs[0]) : await l(v, b, m), m
            };
            return {
                render(v, b) {
                    const T = d.get(b);
                    return T !== void 0 ? Promise.resolve(T) : g(v, b)
                }
            }
        },
        x_e = {
            disableNormalization: !1
        },
        P_e = (t, e, n, r) => class fI {
            constructor(i, a) {
                const c = e(i),
                    l = r({
                        ...x_e,
                        ...a
                    }),
                    h = t(c, l);
                return n.add(h), h
            }
            static[Symbol.hasInstance](i) {
                return i !== null && typeof i == "object" && Object.getPrototypeOf(i) === fI.prototype || n.has(i)
            }
        },
        R_e = (t, e) => (n, r, s) => (t(r).replay(s), e(r, n, s)),
        M_e = (t, e, n) => async (r, s, i) => {
            const a = t(r);
            await Promise.all(a.activeInputs.map((c, l) => Array.from(c).map(async ([h, d]) => {
                const g = await e(h).render(h, s),
                    v = r.context.destination;
                !n(h) && (r !== v || !n(r)) && g.connect(i, d, l)
            })).reduce((c, l) => [...c, ...l], []))
        }, D_e = (t, e, n) => async (r, s, i) => {
            const a = e(r);
            await Promise.all(Array.from(a.activeInputs).map(async ([c, l]) => {
                const d = await t(c).render(c, s);
                n(c) || d.connect(i, l)
            }))
        }, $_e = (t, e, n, r) => s => t(Tl, () => Tl(s)) ? Promise.resolve(t(r, r)).then(i => {
            if (!i) {
                const a = n(s, 512, 0, 1);
                s.oncomplete = () => {
                    a.onaudioprocess = null, a.disconnect()
                }, a.onaudioprocess = () => s.currentTime, a.connect(s.destination)
            }
            return s.startRendering()
        }) : new Promise(i => {
            const a = e(s, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                gain: 0
            });
            s.oncomplete = c => {
                a.disconnect(), i(c.renderedBuffer)
            }, a.connect(s.destination), s.startRendering()
        }), L_e = t => (e, n) => {
            t.set(e, n)
        }, F_e = t => (e, n) => t.set(e, n), U_e = (t, e, n, r, s, i, a, c) => (l, h) => n(l).render(l, h).then(() => Promise.all(Array.from(r(h)).map(d => n(d).render(d, h)))).then(() => s(h)).then(d => (typeof d.copyFromChannel != "function" ? (a(d), T0(d)) : e(i, () => i(d)) || c(d), t.add(d), d)), B_e = {
            channelCount: 2,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            pan: 0
        }, q_e = (t, e, n, r, s, i) => class extends t {
            constructor(c, l) {
                const h = s(c),
                    d = {
                        ...B_e,
                        ...l
                    },
                    p = n(h, d),
                    g = i(h),
                    v = g ? r() : null;
                super(c, !1, p, v), this._pan = e(this, g, p.pan)
            }
            get pan() {
                return this._pan
            }
        }, V_e = (t, e, n, r, s) => () => {
            const i = new WeakMap,
                a = async (c, l) => {
                    let h = n(c);
                    const d = ir(h, l);
                    if (!d) {
                        const p = {
                            channelCount: h.channelCount,
                            channelCountMode: h.channelCountMode,
                            channelInterpretation: h.channelInterpretation,
                            pan: h.pan.value
                        };
                        h = e(l, p)
                    }
                    return i.set(l, h), d ? await t(l, c.pan, h.pan) : await r(l, c.pan, h.pan), du(h) ? await s(c, l, h.inputs[0]) : await s(c, l, h), h
                };
            return {
                render(c, l) {
                    const h = i.get(l);
                    return h !== void 0 ? Promise.resolve(h) : a(c, l)
                }
            }
        }, j_e = t => () => {
            if (t === null) return !1;
            try {
                new t({
                    length: 1,
                    sampleRate: 44100
                })
            } catch {
                return !1
            }
            return !0
        }, G_e = (t, e) => async () => {
            if (t === null) return !0;
            if (e === null) return !1;
            const n = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
                    type: "application/javascript; charset=utf-8"
                }),
                r = new e(1, 128, 44100),
                s = URL.createObjectURL(n);
            let i = !1,
                a = !1;
            try {
                await r.audioWorklet.addModule(s);
                const c = new t(r, "a", {
                        numberOfOutputs: 0
                    }),
                    l = r.createOscillator();
                c.port.onmessage = () => i = !0, c.onprocessorerror = () => a = !0, l.connect(c), l.start(0), await r.startRendering()
            } catch {} finally {
                URL.revokeObjectURL(s)
            }
            return i && !a
        }, W_e = (t, e) => () => {
            if (e === null) return Promise.resolve(!1);
            const n = new e(1, 1, 44100),
                r = t(n, {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    gain: 0
                });
            return new Promise(s => {
                n.oncomplete = () => {
                    r.disconnect(), s(n.currentTime !== 0)
                }, n.startRendering()
            })
        }, H_e = () => new DOMException("", "UnknownError"), K_e = {
            channelCount: 2,
            channelCountMode: "max",
            channelInterpretation: "speakers",
            curve: null,
            oversample: "none"
        }, Y_e = (t, e, n, r, s, i, a) => class extends t {
            constructor(l, h) {
                const d = s(l),
                    p = {
                        ...K_e,
                        ...h
                    },
                    g = n(d, p),
                    b = i(d) ? r() : null;
                super(l, !0, g, b), this._isCurveNullified = !1, this._nativeWaveShaperNode = g, a(this, 1)
            }
            get curve() {
                return this._isCurveNullified ? null : this._nativeWaveShaperNode.curve
            }
            set curve(l) {
                if (l === null) this._isCurveNullified = !0, this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
                else {
                    if (l.length < 2) throw e();
                    this._isCurveNullified = !1, this._nativeWaveShaperNode.curve = l
                }
            }
            get oversample() {
                return this._nativeWaveShaperNode.oversample
            }
            set oversample(l) {
                this._nativeWaveShaperNode.oversample = l
            }
        }, z_e = (t, e, n) => () => {
            const r = new WeakMap,
                s = async (i, a) => {
                    let c = e(i);
                    if (!ir(c, a)) {
                        const h = {
                            channelCount: c.channelCount,
                            channelCountMode: c.channelCountMode,
                            channelInterpretation: c.channelInterpretation,
                            curve: c.curve,
                            oversample: c.oversample
                        };
                        c = t(a, h)
                    }
                    return r.set(a, c), du(c) ? await n(i, a, c.inputs[0]) : await n(i, a, c), c
                };
            return {
                render(i, a) {
                    const c = r.get(a);
                    return c !== void 0 ? Promise.resolve(c) : s(i, a)
                }
            }
        }, Z_e = () => typeof window > "u" ? null : window, X_e = (t, e) => n => {
            n.copyFromChannel = (r, s, i = 0) => {
                const a = t(i),
                    c = t(s);
                if (c >= n.numberOfChannels) throw e();
                const l = n.length,
                    h = n.getChannelData(c),
                    d = r.length;
                for (let p = a < 0 ? -a : 0; p + a < l && p < d; p += 1) r[p] = h[p + a]
            }, n.copyToChannel = (r, s, i = 0) => {
                const a = t(i),
                    c = t(s);
                if (c >= n.numberOfChannels) throw e();
                const l = n.length,
                    h = n.getChannelData(c),
                    d = r.length;
                for (let p = a < 0 ? -a : 0; p + a < l && p < d; p += 1) h[p + a] = r[p]
            }
        }, Q_e = t => e => {
            e.copyFromChannel = (n => (r, s, i = 0) => {
                const a = t(i),
                    c = t(s);
                if (a < e.length) return n.call(e, r, c, a)
            })(e.copyFromChannel), e.copyToChannel = (n => (r, s, i = 0) => {
                const a = t(i),
                    c = t(s);
                if (a < e.length) return n.call(e, r, c, a)
            })(e.copyToChannel)
        }, J_e = t => (e, n) => {
            const r = n.createBuffer(1, 1, 44100);
            e.buffer === null && (e.buffer = r), t(e, "buffer", s => () => {
                const i = s.call(e);
                return i === r ? null : i
            }, s => i => s.call(e, i === null ? r : i))
        }, e1e = (t, e) => (n, r) => {
            r.channelCount = 1, r.channelCountMode = "explicit", Object.defineProperty(r, "channelCount", {
                get: () => 1,
                set: () => {
                    throw t()
                }
            }), Object.defineProperty(r, "channelCountMode", {
                get: () => "explicit",
                set: () => {
                    throw t()
                }
            });
            const s = n.createBufferSource();
            e(r, () => {
                const c = r.numberOfInputs;
                for (let l = 0; l < c; l += 1) s.connect(r, 0, l)
            }, () => s.disconnect(r))
        }, dI = (t, e, n) => t.copyFromChannel === void 0 ? t.getChannelData(n)[0] : (t.copyFromChannel(e, n), e[0]), pI = t => {
            if (t === null) return !1;
            const e = t.length;
            return e % 2 !== 0 ? t[Math.floor(e / 2)] !== 0 : t[e / 2 - 1] + t[e / 2] !== 0
        }, mh = (t, e, n, r) => {
            let s = t;
            for (; !s.hasOwnProperty(e);) s = Object.getPrototypeOf(s);
            const {
                get: i,
                set: a
            } = Object.getOwnPropertyDescriptor(s, e);
            Object.defineProperty(t, e, {
                get: n(i),
                set: r(a)
            })
        }, t1e = t => ({
            ...t,
            outputChannelCount: t.outputChannelCount !== void 0 ? t.outputChannelCount : t.numberOfInputs === 1 && t.numberOfOutputs === 1 ? [t.channelCount] : Array.from({
                length: t.numberOfOutputs
            }, () => 1)
        }), n1e = t => ({
            ...t,
            channelCount: t.numberOfOutputs
        }), r1e = t => {
            const {
                imag: e,
                real: n
            } = t;
            return e === void 0 ? n === void 0 ? {
                ...t,
                imag: [0, 0],
                real: [0, 0]
            } : {
                ...t,
                imag: Array.from(n, () => 0),
                real: n
            } : n === void 0 ? {
                ...t,
                imag: e,
                real: Array.from(e, () => 0)
            } : {
                ...t,
                imag: e,
                real: n
            }
        }, mI = (t, e, n) => {
            try {
                t.setValueAtTime(e, n)
            } catch (r) {
                if (r.code !== 9) throw r;
                mI(t, e, n + 1e-7)
            }
        }, s1e = t => {
            const e = t.createBufferSource();
            e.start();
            try {
                e.start()
            } catch {
                return !0
            }
            return !1
        }, i1e = t => {
            const e = t.createBufferSource(),
                n = t.createBuffer(1, 1, 44100);
            e.buffer = n;
            try {
                e.start(0, 1)
            } catch {
                return !1
            }
            return !0
        }, o1e = t => {
            const e = t.createBufferSource();
            e.start();
            try {
                e.stop()
            } catch {
                return !1
            }
            return !0
        }, I0 = t => {
            const e = t.createOscillator();
            try {
                e.start(-1)
            } catch (n) {
                return n instanceof RangeError
            }
            return !1
        }, gI = t => {
            const e = t.createBuffer(1, 1, 44100),
                n = t.createBufferSource();
            n.buffer = e, n.start(), n.stop();
            try {
                return n.stop(), !0
            } catch {
                return !1
            }
        }, k0 = t => {
            const e = t.createOscillator();
            try {
                e.stop(-1)
            } catch (n) {
                return n instanceof RangeError
            }
            return !1
        }, a1e = t => {
            const {
                port1: e,
                port2: n
            } = new MessageChannel;
            try {
                e.postMessage(t)
            } finally {
                e.close(), n.close()
            }
        }, c1e = t => {
            t.start = (e => (n = 0, r = 0, s) => {
                const i = t.buffer,
                    a = i === null ? r : Math.min(i.duration, r);
                i !== null && a > i.duration - .5 / t.context.sampleRate ? e.call(t, n, 0, 0) : e.call(t, n, a, s)
            })(t.start)
        }, _I = (t, e) => {
            const n = e.createGain();
            t.connect(n);
            const r = (s => () => {
                s.call(t, n), t.removeEventListener("ended", r)
            })(t.disconnect);
            t.addEventListener("ended", r), pu(t, n), t.stop = (s => {
                let i = !1;
                return (a = 0) => {
                    if (i) try {
                        s.call(t, a)
                    } catch {
                        n.gain.setValueAtTime(0, a)
                    } else s.call(t, a), i = !0
                }
            })(t.stop)
        }, mu = (t, e) => n => {
            const r = {
                value: t
            };
            return Object.defineProperties(n, {
                currentTarget: r,
                target: r
            }), typeof e == "function" ? e.call(t, n) : e.handleEvent.call(t, n)
        }, u1e = kpe(Ra), l1e = Dpe(Ra), h1e = Kme(bm), yI = new WeakMap, f1e = hge(yI), Ms = Tme(new Map, new WeakMap), Zs = Z_e(), vI = qge(Ms, ii), N0 = lge(fr), Yn = M_e(fr, N0, Ta), d1e = Bpe(vI, Jt, Yn), zt = pge(vm), Bi = p_e(Zs), Ut = xge(Bi), bI = new WeakMap, EI = rge(mu), gh = Wge(Zs), x0 = Cge(gh), P0 = Ige(Zs), SI = kge(Zs), wl = Kge(Zs), En = hme(Npe(zC), Mpe(u1e, l1e, Dd, h1e, $d, fr, f1e, uh, Jt, Ra, ki, Ta, Jf), Ms, Sge(cy, $d, fr, Jt, Sl, ki), ii, Em, mr, jme(Dd, cy, fr, Jt, Sl, zt, ki, Ut), Zme(bI, fr, As), EI, zt, x0, P0, SI, Ut, wl), p1e = Upe(En, d1e, ii, vI, zt, Ut), R0 = new WeakSet, V3 = Vge(Zs), TI = $me(new Uint32Array(1)), M0 = X_e(TI, ii), D0 = Q_e(TI), m1e = Vpe(R0, Ms, mr, V3, Bi, j_e(V3), M0, D0), Sm = $pe(Cr), wI = D_e(N0, hh, Ta), oi = Nme(wI), gu = Gge(Sm, Ms, s1e, i1e, o1e, I0, gI, k0, c1e, J_e(mh), _I), ai = R_e(fge(hh), wI), g1e = Wpe(oi, gu, Jt, ai, Yn), Ds = fme(xpe(ZC), bI, S0, dme, Tpe, wpe, Ope, Ape, Cpe, iy, KC, gh, mI), _1e = Gpe(En, g1e, Ds, Ln, gu, zt, Ut, mu), y1e = eme(En, tme, ii, Ln, Hge(Cr, mh), zt, Ut, Yn), v1e = Sme(oi, lI, Jt, ai, Yn), Ma = F_e(yI), b1e = Eme(En, Ds, v1e, Em, lI, zt, Ut, Ma), Bo = Uge(Ra, P0), E1e = e1e(Ln, Bo), qo = e_e(gh, E1e), S1e = Ame(qo, Jt, Yn), T1e = Ome(En, S1e, qo, zt, Ut), w1e = kme(dh, Jt, Yn), O1e = Ime(En, w1e, dh, zt, Ut, n1e), A1e = r_e(Sm, gu, Cr, Bo), _u = n_e(Sm, Ms, A1e, I0, k0), C1e = Dme(oi, _u, Jt, ai, Yn), I1e = Mme(En, Ds, C1e, _u, zt, Ut, mu), OI = s_e(mr, mh), k1e = Ume(OI, Jt, Yn), N1e = Fme(En, k1e, OI, zt, Ut, Ma), x1e = Hme(oi, hI, Jt, ai, Yn), P1e = Wme(En, Ds, x1e, hI, zt, Ut, Ma), AI = i_e(mr), R1e = ege(oi, AI, Jt, ai, Yn), M1e = Jme(En, Ds, R1e, AI, mr, zt, Ut, Ma), D1e = cge(oi, Cr, Jt, ai, Yn), $1e = age(En, Ds, D1e, Cr, zt, Ut), L1e = u_e(Em, Ln, ph, mr), Tm = $_e(Ms, Cr, ph, W_e(Cr, Bi)), F1e = Ege(gu, Jt, Bi, Yn, Tm), U1e = o_e(L1e), B1e = vge(En, U1e, F1e, zt, Ut, Ma), q1e = nme(Ds, qo, _u, ph, mr, dI, Ut, mh), CI = new WeakMap, V1e = Fge(y1e, q1e, EI, Ut, CI, mu), II = m_e(Sm, Ms, I0, gI, k0, _I), j1e = C_e(oi, II, Jt, ai, Yn), G1e = A_e(En, Ds, II, j1e, zt, Ut, mu), kI = Pme(gu), W1e = S_e(kI, Ln, Cr, pI, Bo), wm = E_e(kI, Ln, W1e, pI, Bo, gh, mh), H1e = __e(Dd, Ln, qo, Cr, ph, wm, mr, $d, dI, Bo), NI = g_e(H1e), K1e = N_e(oi, qo, _u, Cr, NI, Jt, Bi, ai, Yn, Tm), Y1e = k_e(En, Ds, NI, K1e, zt, Ut, Ma), z1e = y_e(ii), Z1e = P_e(z1e, zt, new WeakSet, r1e), X1e = b_e(qo, dh, Cr, wm, mr, Bo), xI = v_e(X1e, mr), Q1e = V_e(oi, xI, Jt, ai, Yn), J1e = q_e(En, Ds, xI, Q1e, zt, Ut), eye = z_e(wm, Jt, Yn), tye = Y_e(En, Ln, wm, eye, zt, Ut, Ma), PI = Pge(Zs), $0 = sge(Zs), RI = new WeakMap, nye = mge(RI, Bi), rye = PI ? Rpe(Ms, mr, nge(Zs), $0, ige(Ipe), zt, nye, Ut, wl, new WeakMap, new WeakMap, G_e(wl, Bi), Zs) : void 0, sye = Nge(x0, Ut), iye = Vme(R0, Ms, qme, tge, new WeakSet, zt, sye, Rd, Tl, M0, D0), MI = vme(rye, p1e, m1e, _1e, b1e, T1e, O1e, I1e, N1e, iye, P1e, M1e, $1e, B1e, V1e, G1e, Y1e, Z1e, J1e, tye), oye = Rge(En, l_e, zt, Ut), aye = Dge(En, h_e, zt, Ut), cye = $ge(En, f_e, zt, Ut), uye = d_e(Ln, Ut), lye = Lge(En, uye, zt), hye = Jpe(MI, Ln, mr, H_e, oye, aye, cye, lye, gh), L0 = gge(CI), fye = Lpe(L0), DI = xme(ii), dye = Yme(L0), $I = Xme(ii), LI = new WeakMap, pye = uge(LI, As), mye = Jge(DI, ii, Ln, qo, dh, _u, Cr, ph, mr, $I, $0, pye, Bo), gye = zge(Ln, mye, Cr, mr, Bo), _ye = yme(oi, DI, gu, qo, dh, _u, Cr, dye, $I, $0, Jt, wl, Bi, ai, Yn, Tm), yye = dge(RI), vye = L_e(LI), j3 = PI ? mme(fye, En, Ds, _ye, gye, fr, yye, zt, Ut, wl, t1e, vye, a1e, mu) : void 0, bye = Bme(mr, Bi), Eye = U_e(R0, Ms, N0, L0, Tm, Rd, M0, D0), Sye = w_e(MI, Ms, Ln, bye, Eye), Tye = Tge(vm, x0), wye = wge(E0, P0), Oye = Oge(S0, SI), Aye = Age(vm, Ut);

    function Ke(t, e) {
        if (!t) throw new Error(e)
    }

    function Cs(t, e, n = 1 / 0) {
        if (!(e <= t && t <= n)) throw new RangeError(`Value must be within [${e}, ${n}], got: ${t}`)
    }

    function FI(t) {
        !t.isOffline && t.state !== "running" && F0('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.')
    }
    let UI = console;

    function Cye(...t) {
        UI.log(...t)
    }

    function F0(...t) {
        UI.warn(...t)
    }

    function rs(t) {
        return typeof t > "u"
    }

    function Et(t) {
        return !rs(t)
    }

    function Iye(t) {
        return typeof t == "function"
    }

    function Ri(t) {
        return typeof t == "number"
    }

    function ya(t) {
        return Object.prototype.toString.call(t) === "[object Object]" && t.constructor === Object
    }

    function kye(t) {
        return typeof t == "boolean"
    }

    function Fr(t) {
        return Array.isArray(t)
    }

    function Xs(t) {
        return typeof t == "string"
    }

    function qf(t) {
        return Xs(t) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(t)
    }

    function Nye(t) {
        return new hye(t)
    }

    function xye(t, e, n) {
        return new Sye(t, e, n)
    }
    const va = typeof self == "object" ? self : null,
        Pye = va && (va.hasOwnProperty("AudioContext") || va.hasOwnProperty("webkitAudioContext"));

    function Rye(t, e, n) {
        return Ke(Et(j3), "This node only works in a secure context (https or localhost)"), new j3(t, e, n)
    }

    function $s(t, e, n, r) {
        var s = arguments.length,
            i = s < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r,
            a;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") i = Reflect.decorate(t, e, n, r);
        else
            for (var c = t.length - 1; c >= 0; c--)(a = t[c]) && (i = (s < 3 ? a(i) : s > 3 ? a(e, n, i) : a(e, n)) || i);
        return s > 3 && i && Object.defineProperty(e, n, i), i
    }

    function vn(t, e, n, r) {
        function s(i) {
            return i instanceof n ? i : new n(function(a) {
                a(i)
            })
        }
        return new(n || (n = Promise))(function(i, a) {
            function c(d) {
                try {
                    h(r.next(d))
                } catch (p) {
                    a(p)
                }
            }

            function l(d) {
                try {
                    h(r.throw(d))
                } catch (p) {
                    a(p)
                }
            }

            function h(d) {
                d.done ? i(d.value) : s(d.value).then(c, l)
            }
            h((r = r.apply(t, e || [])).next())
        })
    }
    class Mye {
        constructor(e, n, r) {
            this._callback = e, this._type = n, this._updateInterval = r, this._createClock()
        }
        _createWorker() {
            const e = new Blob([`
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval*1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`], {
                    type: "text/javascript"
                }),
                n = URL.createObjectURL(e),
                r = new Worker(n);
            r.onmessage = this._callback.bind(this), this._worker = r
        }
        _createTimeout() {
            this._timeout = setTimeout(() => {
                this._createTimeout(), this._callback()
            }, this._updateInterval * 1e3)
        }
        _createClock() {
            if (this._type === "worker") try {
                this._createWorker()
            } catch {
                this._type = "timeout", this._createClock()
            } else this._type === "timeout" && this._createTimeout()
        }
        _disposeClock() {
            this._timeout && (clearTimeout(this._timeout), this._timeout = 0), this._worker && (this._worker.terminate(), this._worker.onmessage = null)
        }
        get updateInterval() {
            return this._updateInterval
        }
        set updateInterval(e) {
            this._updateInterval = Math.max(e, 128 / 44100), this._type === "worker" && this._worker.postMessage(Math.max(e * 1e3, 1))
        }
        get type() {
            return this._type
        }
        set type(e) {
            this._disposeClock(), this._type = e, this._createClock()
        }
        dispose() {
            this._disposeClock()
        }
    }

    function wa(t) {
        return Oye(t)
    }

    function yo(t) {
        return wye(t)
    }

    function ed(t) {
        return Aye(t)
    }

    function ic(t) {
        return Tye(t)
    }

    function BI(t) {
        return t instanceof AudioBuffer
    }

    function Dye(t, e) {
        return t === "value" || wa(e) || yo(e) || BI(e)
    }

    function ss(t, ...e) {
        if (!e.length) return t;
        const n = e.shift();
        if (ya(t) && ya(n))
            for (const r in n) Dye(r, n[r]) ? t[r] = n[r] : ya(n[r]) ? (t[r] || Object.assign(t, {
                [r]: {}
            }), ss(t[r], n[r])) : Object.assign(t, {
                [r]: n[r]
            });
        return ss(t, ...e)
    }

    function $ye(t, e) {
        return t.length === e.length && t.every((n, r) => e[r] === n)
    }

    function J(t, e, n = [], r) {
        const s = {},
            i = Array.from(e);
        if (ya(i[0]) && r && !Reflect.has(i[0], r) && (Object.keys(i[0]).some(c => Reflect.has(t, c)) || (ss(s, {
                [r]: i[0]
            }), n.splice(n.indexOf(r), 1), i.shift())), i.length === 1 && ya(i[0])) ss(s, i[0]);
        else
            for (let a = 0; a < n.length; a++) Et(i[a]) && (s[n[a]] = i[a]);
        return ss(t, s)
    }

    function Lye(t) {
        return t.constructor.getDefaults()
    }

    function Ic(t, e) {
        return rs(t) ? e : t
    }

    function tr(t, e) {
        return e.forEach(n => {
            Reflect.has(t, n) && delete t[n]
        }), t
    }
    /**
     * Tone.js
     * @author Yotam Mann
     * @license http://opensource.org/licenses/MIT MIT License
     * @copyright 2014-2019 Yotam Mann
     */
    class qi {
        constructor() {
            this.debug = !1, this._wasDisposed = !1
        }
        static getDefaults() {
            return {}
        }
        log(...e) {
            (this.debug || va && this.toString() === va.TONE_DEBUG_CLASS) && Cye(this, ...e)
        }
        dispose() {
            return this._wasDisposed = !0, this
        }
        get disposed() {
            return this._wasDisposed
        }
        toString() {
            return this.name
        }
    }
    qi.version = HC;
    const U0 = 1e-6;

    function Bd(t, e) {
        return t > e + U0
    }

    function dy(t, e) {
        return Bd(t, e) || ys(t, e)
    }

    function qI(t, e) {
        return t + U0 < e
    }

    function ys(t, e) {
        return Math.abs(t - e) < U0
    }

    function Fye(t, e, n) {
        return Math.max(Math.min(t, n), e)
    }
    class ci extends qi {
        constructor() {
            super(), this.name = "Timeline", this._timeline = [];
            const e = J(ci.getDefaults(), arguments, ["memory"]);
            this.memory = e.memory, this.increasing = e.increasing
        }
        static getDefaults() {
            return {
                memory: 1 / 0,
                increasing: !1
            }
        }
        get length() {
            return this._timeline.length
        }
        add(e) {
            if (Ke(Reflect.has(e, "time"), "Timeline: events must have a time attribute"), e.time = e.time.valueOf(), this.increasing && this.length) {
                const n = this._timeline[this.length - 1];
                Ke(dy(e.time, n.time), "The time must be greater than or equal to the last scheduled time"), this._timeline.push(e)
            } else {
                const n = this._search(e.time);
                this._timeline.splice(n + 1, 0, e)
            }
            if (this.length > this.memory) {
                const n = this.length - this.memory;
                this._timeline.splice(0, n)
            }
            return this
        }
        remove(e) {
            const n = this._timeline.indexOf(e);
            return n !== -1 && this._timeline.splice(n, 1), this
        }
        get(e, n = "time") {
            const r = this._search(e, n);
            return r !== -1 ? this._timeline[r] : null
        }
        peek() {
            return this._timeline[0]
        }
        shift() {
            return this._timeline.shift()
        }
        getAfter(e, n = "time") {
            const r = this._search(e, n);
            return r + 1 < this._timeline.length ? this._timeline[r + 1] : null
        }
        getBefore(e) {
            const n = this._timeline.length;
            if (n > 0 && this._timeline[n - 1].time < e) return this._timeline[n - 1];
            const r = this._search(e);
            return r - 1 >= 0 ? this._timeline[r - 1] : null
        }
        cancel(e) {
            if (this._timeline.length > 1) {
                let n = this._search(e);
                if (n >= 0)
                    if (ys(this._timeline[n].time, e)) {
                        for (let r = n; r >= 0 && ys(this._timeline[r].time, e); r--) n = r;
                        this._timeline = this._timeline.slice(0, n)
                    } else this._timeline = this._timeline.slice(0, n + 1);
                else this._timeline = []
            } else this._timeline.length === 1 && dy(this._timeline[0].time, e) && (this._timeline = []);
            return this
        }
        cancelBefore(e) {
            const n = this._search(e);
            return n >= 0 && (this._timeline = this._timeline.slice(n + 1)), this
        }
        previousEvent(e) {
            const n = this._timeline.indexOf(e);
            return n > 0 ? this._timeline[n - 1] : null
        }
        _search(e, n = "time") {
            if (this._timeline.length === 0) return -1;
            let r = 0;
            const s = this._timeline.length;
            let i = s;
            if (s > 0 && this._timeline[s - 1][n] <= e) return s - 1;
            for (; r < i;) {
                let a = Math.floor(r + (i - r) / 2);
                const c = this._timeline[a],
                    l = this._timeline[a + 1];
                if (ys(c[n], e)) {
                    for (let h = a; h < this._timeline.length; h++) {
                        const d = this._timeline[h];
                        if (ys(d[n], e)) a = h;
                        else break
                    }
                    return a
                } else {
                    if (qI(c[n], e) && Bd(l[n], e)) return a;
                    Bd(c[n], e) ? i = a : r = a + 1
                }
            }
            return -1
        }
        _iterate(e, n = 0, r = this._timeline.length - 1) {
            this._timeline.slice(n, r + 1).forEach(e)
        }
        forEach(e) {
            return this._iterate(e), this
        }
        forEachBefore(e, n) {
            const r = this._search(e);
            return r !== -1 && this._iterate(n, 0, r), this
        }
        forEachAfter(e, n) {
            const r = this._search(e);
            return this._iterate(n, r + 1), this
        }
        forEachBetween(e, n, r) {
            let s = this._search(e),
                i = this._search(n);
            return s !== -1 && i !== -1 ? (this._timeline[s].time !== e && (s += 1), this._timeline[i].time === n && (i -= 1), this._iterate(r, s, i)) : s === -1 && this._iterate(r, 0, i), this
        }
        forEachFrom(e, n) {
            let r = this._search(e);
            for (; r >= 0 && this._timeline[r].time >= e;) r--;
            return this._iterate(n, r + 1), this
        }
        forEachAtTime(e, n) {
            const r = this._search(e);
            if (r !== -1 && ys(this._timeline[r].time, e)) {
                let s = r;
                for (let i = r; i >= 0 && ys(this._timeline[i].time, e); i--) s = i;
                this._iterate(i => {
                    n(i)
                }, s, r)
            }
            return this
        }
        dispose() {
            return super.dispose(), this._timeline = [], this
        }
    }
    const VI = [];

    function Om(t) {
        VI.push(t)
    }

    function Uye(t) {
        VI.forEach(e => e(t))
    }
    const jI = [];

    function Am(t) {
        jI.push(t)
    }

    function Bye(t) {
        jI.forEach(e => e(t))
    }
    class _h extends qi {
        constructor() {
            super(...arguments), this.name = "Emitter"
        }
        on(e, n) {
            return e.split(/\W+/).forEach(s => {
                rs(this._events) && (this._events = {}), this._events.hasOwnProperty(s) || (this._events[s] = []), this._events[s].push(n)
            }), this
        }
        once(e, n) {
            const r = (...s) => {
                n(...s), this.off(e, r)
            };
            return this.on(e, r), this
        }
        off(e, n) {
            return e.split(/\W+/).forEach(s => {
                if (rs(this._events) && (this._events = {}), this._events.hasOwnProperty(e))
                    if (rs(n)) this._events[e] = [];
                    else {
                        const i = this._events[e];
                        for (let a = i.length - 1; a >= 0; a--) i[a] === n && i.splice(a, 1)
                    }
            }), this
        }
        emit(e, ...n) {
            if (this._events && this._events.hasOwnProperty(e)) {
                const r = this._events[e].slice(0);
                for (let s = 0, i = r.length; s < i; s++) r[s].apply(this, n)
            }
            return this
        }
        static mixin(e) {
            ["on", "once", "off", "emit"].forEach(n => {
                const r = Object.getOwnPropertyDescriptor(_h.prototype, n);
                Object.defineProperty(e.prototype, n, r)
            })
        }
        dispose() {
            return super.dispose(), this._events = void 0, this
        }
    }
    class GI extends _h {
        constructor() {
            super(...arguments), this.isOffline = !1
        }
        toJSON() {
            return {}
        }
    }
    class yh extends GI {
        constructor() {
            super(), this.name = "Context", this._constants = new Map, this._timeouts = new ci, this._timeoutIds = 0, this._initialized = !1, this.isOffline = !1, this._workletModules = new Map;
            const e = J(yh.getDefaults(), arguments, ["context"]);
            e.context ? this._context = e.context : this._context = Nye({
                latencyHint: e.latencyHint
            }), this._ticker = new Mye(this.emit.bind(this, "tick"), e.clockSource, e.updateInterval), this.on("tick", this._timeoutLoop.bind(this)), this._context.onstatechange = () => {
                this.emit("statechange", this.state)
            }, this._setLatencyHint(e.latencyHint), this.lookAhead = e.lookAhead
        }
        static getDefaults() {
            return {
                clockSource: "worker",
                latencyHint: "interactive",
                lookAhead: .1,
                updateInterval: .05
            }
        }
        initialize() {
            return this._initialized || (Uye(this), this._initialized = !0), this
        }
        createAnalyser() {
            return this._context.createAnalyser()
        }
        createOscillator() {
            return this._context.createOscillator()
        }
        createBufferSource() {
            return this._context.createBufferSource()
        }
        createBiquadFilter() {
            return this._context.createBiquadFilter()
        }
        createBuffer(e, n, r) {
            return this._context.createBuffer(e, n, r)
        }
        createChannelMerger(e) {
            return this._context.createChannelMerger(e)
        }
        createChannelSplitter(e) {
            return this._context.createChannelSplitter(e)
        }
        createConstantSource() {
            return this._context.createConstantSource()
        }
        createConvolver() {
            return this._context.createConvolver()
        }
        createDelay(e) {
            return this._context.createDelay(e)
        }
        createDynamicsCompressor() {
            return this._context.createDynamicsCompressor()
        }
        createGain() {
            return this._context.createGain()
        }
        createIIRFilter(e, n) {
            return this._context.createIIRFilter(e, n)
        }
        createPanner() {
            return this._context.createPanner()
        }
        createPeriodicWave(e, n, r) {
            return this._context.createPeriodicWave(e, n, r)
        }
        createStereoPanner() {
            return this._context.createStereoPanner()
        }
        createWaveShaper() {
            return this._context.createWaveShaper()
        }
        createMediaStreamSource(e) {
            return Ke(ic(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamSource(e)
        }
        createMediaElementSource(e) {
            return Ke(ic(this._context), "Not available if OfflineAudioContext"), this._context.createMediaElementSource(e)
        }
        createMediaStreamDestination() {
            return Ke(ic(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamDestination()
        }
        decodeAudioData(e) {
            return this._context.decodeAudioData(e)
        }
        get currentTime() {
            return this._context.currentTime
        }
        get state() {
            return this._context.state
        }
        get sampleRate() {
            return this._context.sampleRate
        }
        get listener() {
            return this.initialize(), this._listener
        }
        set listener(e) {
            Ke(!this._initialized, "The listener cannot be set after initialization."), this._listener = e
        }
        get transport() {
            return this.initialize(), this._transport
        }
        set transport(e) {
            Ke(!this._initialized, "The transport cannot be set after initialization."), this._transport = e
        }
        get draw() {
            return this.initialize(), this._draw
        }
        set draw(e) {
            Ke(!this._initialized, "Draw cannot be set after initialization."), this._draw = e
        }
        get destination() {
            return this.initialize(), this._destination
        }
        set destination(e) {
            Ke(!this._initialized, "The destination cannot be set after initialization."), this._destination = e
        }
        createAudioWorkletNode(e, n) {
            return Rye(this.rawContext, e, n)
        }
        addAudioWorkletModule(e, n) {
            return vn(this, void 0, void 0, function*() {
                Ke(Et(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)"), this._workletModules.has(n) || this._workletModules.set(n, this.rawContext.audioWorklet.addModule(e)), yield this._workletModules.get(n)
            })
        }
        workletsAreReady() {
            return vn(this, void 0, void 0, function*() {
                const e = [];
                this._workletModules.forEach(n => e.push(n)), yield Promise.all(e)
            })
        }
        get updateInterval() {
            return this._ticker.updateInterval
        }
        set updateInterval(e) {
            this._ticker.updateInterval = e
        }
        get clockSource() {
            return this._ticker.type
        }
        set clockSource(e) {
            this._ticker.type = e
        }
        get latencyHint() {
            return this._latencyHint
        }
        _setLatencyHint(e) {
            let n = 0;
            if (this._latencyHint = e, Xs(e)) switch (e) {
                case "interactive":
                    n = .1;
                    break;
                case "playback":
                    n = .5;
                    break;
                case "balanced":
                    n = .25;
                    break
            }
            this.lookAhead = n, this.updateInterval = n / 2
        }
        get rawContext() {
            return this._context
        }
        now() {
            return this._context.currentTime + this.lookAhead
        }
        immediate() {
            return this._context.currentTime
        }
        resume() {
            return ic(this._context) ? this._context.resume() : Promise.resolve()
        }
        close() {
            return vn(this, void 0, void 0, function*() {
                ic(this._context) && (yield this._context.close()), this._initialized && Bye(this)
            })
        }
        getConstant(e) {
            if (this._constants.has(e)) return this._constants.get(e); {
                const n = this._context.createBuffer(1, 128, this._context.sampleRate),
                    r = n.getChannelData(0);
                for (let i = 0; i < r.length; i++) r[i] = e;
                const s = this._context.createBufferSource();
                return s.channelCount = 1, s.channelCountMode = "explicit", s.buffer = n, s.loop = !0, s.start(0), this._constants.set(e, s), s
            }
        }
        dispose() {
            return super.dispose(), this._ticker.dispose(), this._timeouts.dispose(), Object.keys(this._constants).map(e => this._constants[e].disconnect()), this
        }
        _timeoutLoop() {
            const e = this.now();
            let n = this._timeouts.peek();
            for (; this._timeouts.length && n && n.time <= e;) n.callback(), this._timeouts.shift(), n = this._timeouts.peek()
        }
        setTimeout(e, n) {
            this._timeoutIds++;
            const r = this.now();
            return this._timeouts.add({
                callback: e,
                id: this._timeoutIds,
                time: r + n
            }), this._timeoutIds
        }
        clearTimeout(e) {
            return this._timeouts.forEach(n => {
                n.id === e && this._timeouts.remove(n)
            }), this
        }
        clearInterval(e) {
            return this.clearTimeout(e)
        }
        setInterval(e, n) {
            const r = ++this._timeoutIds,
                s = () => {
                    const i = this.now();
                    this._timeouts.add({
                        callback: () => {
                            e(), s()
                        },
                        id: r,
                        time: i + n
                    })
                };
            return s(), r
        }
    }
    class qye extends GI {
        constructor() {
            super(...arguments), this.lookAhead = 0, this.latencyHint = 0, this.isOffline = !1
        }
        createAnalyser() {
            return {}
        }
        createOscillator() {
            return {}
        }
        createBufferSource() {
            return {}
        }
        createBiquadFilter() {
            return {}
        }
        createBuffer(e, n, r) {
            return {}
        }
        createChannelMerger(e) {
            return {}
        }
        createChannelSplitter(e) {
            return {}
        }
        createConstantSource() {
            return {}
        }
        createConvolver() {
            return {}
        }
        createDelay(e) {
            return {}
        }
        createDynamicsCompressor() {
            return {}
        }
        createGain() {
            return {}
        }
        createIIRFilter(e, n) {
            return {}
        }
        createPanner() {
            return {}
        }
        createPeriodicWave(e, n, r) {
            return {}
        }
        createStereoPanner() {
            return {}
        }
        createWaveShaper() {
            return {}
        }
        createMediaStreamSource(e) {
            return {}
        }
        createMediaElementSource(e) {
            return {}
        }
        createMediaStreamDestination() {
            return {}
        }
        decodeAudioData(e) {
            return Promise.resolve({})
        }
        createAudioWorkletNode(e, n) {
            return {}
        }
        get rawContext() {
            return {}
        }
        addAudioWorkletModule(e, n) {
            return vn(this, void 0, void 0, function*() {
                return Promise.resolve()
            })
        }
        resume() {
            return Promise.resolve()
        }
        setTimeout(e, n) {
            return 0
        }
        clearTimeout(e) {
            return this
        }
        setInterval(e, n) {
            return 0
        }
        clearInterval(e) {
            return this
        }
        getConstant(e) {
            return {}
        }
        get currentTime() {
            return 0
        }
        get state() {
            return {}
        }
        get sampleRate() {
            return 0
        }
        get listener() {
            return {}
        }
        get transport() {
            return {}
        }
        get draw() {
            return {}
        }
        set draw(e) {}
        get destination() {
            return {}
        }
        set destination(e) {}
        now() {
            return 0
        }
        immediate() {
            return 0
        }
    }

    function je(t, e) {
        Fr(e) ? e.forEach(n => je(t, n)) : Object.defineProperty(t, e, {
            enumerable: !0,
            writable: !1
        })
    }

    function vh(t, e) {
        Fr(e) ? e.forEach(n => vh(t, n)) : Object.defineProperty(t, e, {
            writable: !0
        })
    }
    const ft = () => {};
    class It extends qi {
        constructor() {
            super(), this.name = "ToneAudioBuffer", this.onload = ft;
            const e = J(It.getDefaults(), arguments, ["url", "onload", "onerror"]);
            this.reverse = e.reverse, this.onload = e.onload, e.url && BI(e.url) || e.url instanceof It ? this.set(e.url) : Xs(e.url) && this.load(e.url).catch(e.onerror)
        }
        static getDefaults() {
            return {
                onerror: ft,
                onload: ft,
                reverse: !1
            }
        }
        get sampleRate() {
            return this._buffer ? this._buffer.sampleRate : es().sampleRate
        }
        set(e) {
            return e instanceof It ? e.loaded ? this._buffer = e.get() : e.onload = () => {
                this.set(e), this.onload(this)
            } : this._buffer = e, this._reversed && this._reverse(), this
        }
        get() {
            return this._buffer
        }
        load(e) {
            return vn(this, void 0, void 0, function*() {
                const n = It.load(e).then(r => {
                    this.set(r), this.onload(this)
                });
                It.downloads.push(n);
                try {
                    yield n
                } finally {
                    const r = It.downloads.indexOf(n);
                    It.downloads.splice(r, 1)
                }
                return this
            })
        }
        dispose() {
            return super.dispose(), this._buffer = void 0, this
        }
        fromArray(e) {
            const n = Fr(e) && e[0].length > 0,
                r = n ? e.length : 1,
                s = n ? e[0].length : e.length,
                i = es(),
                a = i.createBuffer(r, s, i.sampleRate),
                c = !n && r === 1 ? [e] : e;
            for (let l = 0; l < r; l++) a.copyToChannel(c[l], l);
            return this._buffer = a, this
        }
        toMono(e) {
            if (Ri(e)) this.fromArray(this.toArray(e));
            else {
                let n = new Float32Array(this.length);
                const r = this.numberOfChannels;
                for (let s = 0; s < r; s++) {
                    const i = this.toArray(s);
                    for (let a = 0; a < i.length; a++) n[a] += i[a]
                }
                n = n.map(s => s / r), this.fromArray(n)
            }
            return this
        }
        toArray(e) {
            if (Ri(e)) return this.getChannelData(e);
            if (this.numberOfChannels === 1) return this.toArray(0); {
                const n = [];
                for (let r = 0; r < this.numberOfChannels; r++) n[r] = this.getChannelData(r);
                return n
            }
        }
        getChannelData(e) {
            return this._buffer ? this._buffer.getChannelData(e) : new Float32Array(0)
        }
        slice(e, n = this.duration) {
            const r = Math.floor(e * this.sampleRate),
                s = Math.floor(n * this.sampleRate);
            Ke(r < s, "The start time must be less than the end time");
            const i = s - r,
                a = es().createBuffer(this.numberOfChannels, i, this.sampleRate);
            for (let c = 0; c < this.numberOfChannels; c++) a.copyToChannel(this.getChannelData(c).subarray(r, s), c);
            return new It(a)
        }
        _reverse() {
            if (this.loaded)
                for (let e = 0; e < this.numberOfChannels; e++) this.getChannelData(e).reverse();
            return this
        }
        get loaded() {
            return this.length > 0
        }
        get duration() {
            return this._buffer ? this._buffer.duration : 0
        }
        get length() {
            return this._buffer ? this._buffer.length : 0
        }
        get numberOfChannels() {
            return this._buffer ? this._buffer.numberOfChannels : 0
        }
        get reverse() {
            return this._reversed
        }
        set reverse(e) {
            this._reversed !== e && (this._reversed = e, this._reverse())
        }
        static fromArray(e) {
            return new It().fromArray(e)
        }
        static fromUrl(e) {
            return vn(this, void 0, void 0, function*() {
                return yield new It().load(e)
            })
        }
        static load(e) {
            return vn(this, void 0, void 0, function*() {
                const n = e.match(/\[([^\]\[]+\|.+)\]$/);
                if (n) {
                    const c = n[1].split("|");
                    let l = c[0];
                    for (const h of c)
                        if (It.supportsType(h)) {
                            l = h;
                            break
                        } e = e.replace(n[0], l)
                }
                const r = It.baseUrl === "" || It.baseUrl.endsWith("/") ? It.baseUrl : It.baseUrl + "/",
                    s = yield fetch(r + e);
                if (!s.ok) throw new Error(`could not load url: ${e}`);
                const i = yield s.arrayBuffer();
                return yield es().decodeAudioData(i)
            })
        }
        static supportsType(e) {
            const n = e.split("."),
                r = n[n.length - 1];
            return document.createElement("audio").canPlayType("audio/" + r) !== ""
        }
        static loaded() {
            return vn(this, void 0, void 0, function*() {
                for (yield Promise.resolve(); It.downloads.length;) yield It.downloads[0]
            })
        }
    }
    It.baseUrl = "";
    It.downloads = [];
    class Cm extends yh {
        constructor() {
            super({
                clockSource: "offline",
                context: ed(arguments[0]) ? arguments[0] : xye(arguments[0], arguments[1] * arguments[2], arguments[2]),
                lookAhead: 0,
                updateInterval: ed(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
            }), this.name = "OfflineContext", this._currentTime = 0, this.isOffline = !0, this._duration = ed(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1]
        }
        now() {
            return this._currentTime
        }
        get currentTime() {
            return this._currentTime
        }
        _renderClock(e) {
            return vn(this, void 0, void 0, function*() {
                let n = 0;
                for (; this._duration - this._currentTime >= 0;) {
                    this.emit("tick"), this._currentTime += 128 / this.sampleRate, n++;
                    const r = Math.floor(this.sampleRate / 128);
                    e && n % r === 0 && (yield new Promise(s => setTimeout(s, 1)))
                }
            })
        }
        render(e = !0) {
            return vn(this, void 0, void 0, function*() {
                yield this.workletsAreReady(), yield this._renderClock(e);
                const n = yield this._context.startRendering();
                return new It(n)
            })
        }
        close() {
            return Promise.resolve()
        }
    }
    const WI = new qye;
    let kc = WI;

    function es() {
        return kc === WI && Pye && Vye(new yh), kc
    }

    function Vye(t) {
        ic(t) ? kc = new yh(t) : ed(t) ? kc = new Cm(t) : kc = t
    }

    function HI() {
        return kc.resume()
    }
    if (va && !va.TONE_SILENCE_LOGGING) {
        const e = ` * Tone.js v${HC} * `;
        console.log(`%c${e}`, "background: #000; color: #fff")
    }

    function qd(t) {
        return Math.pow(10, t / 20)
    }

    function B0(t) {
        return 20 * (Math.log(t) / Math.LN10)
    }

    function Oa(t) {
        return Math.pow(2, t / 12)
    }
    let Im = 440;

    function jye() {
        return Im
    }

    function Gye(t) {
        Im = t
    }

    function ha(t) {
        return Math.round(km(t))
    }

    function km(t) {
        return 69 + 12 * Math.log2(t / Im)
    }

    function KI(t) {
        return Im * Math.pow(2, (t - 69) / 12)
    }
    class q0 extends qi {
        constructor(e, n, r) {
            super(), this.defaultUnits = "s", this._val = n, this._units = r, this.context = e, this._expressions = this._getExpressions()
        }
        _getExpressions() {
            return {
                hz: {
                    method: e => this._frequencyToUnits(parseFloat(e)),
                    regexp: /^(\d+(?:\.\d+)?)hz$/i
                },
                i: {
                    method: e => this._ticksToUnits(parseInt(e, 10)),
                    regexp: /^(\d+)i$/i
                },
                m: {
                    method: e => this._beatsToUnits(parseInt(e, 10) * this._getTimeSignature()),
                    regexp: /^(\d+)m$/i
                },
                n: {
                    method: (e, n) => {
                        const r = parseInt(e, 10),
                            s = n === "." ? 1.5 : 1;
                        return r === 1 ? this._beatsToUnits(this._getTimeSignature()) * s : this._beatsToUnits(4 / r) * s
                    },
                    regexp: /^(\d+)n(\.?)$/i
                },
                number: {
                    method: e => this._expressions[this.defaultUnits].method.call(this, e),
                    regexp: /^(\d+(?:\.\d+)?)$/
                },
                s: {
                    method: e => this._secondsToUnits(parseFloat(e)),
                    regexp: /^(\d+(?:\.\d+)?)s$/
                },
                samples: {
                    method: e => parseInt(e, 10) / this.context.sampleRate,
                    regexp: /^(\d+)samples$/
                },
                t: {
                    method: e => {
                        const n = parseInt(e, 10);
                        return this._beatsToUnits(8 / (Math.floor(n) * 3))
                    },
                    regexp: /^(\d+)t$/i
                },
                tr: {
                    method: (e, n, r) => {
                        let s = 0;
                        return e && e !== "0" && (s += this._beatsToUnits(this._getTimeSignature() * parseFloat(e))), n && n !== "0" && (s += this._beatsToUnits(parseFloat(n))), r && r !== "0" && (s += this._beatsToUnits(parseFloat(r) / 4)), s
                    },
                    regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
                }
            }
        }
        valueOf() {
            if (this._val instanceof q0 && this.fromType(this._val), rs(this._val)) return this._noArg();
            if (Xs(this._val) && rs(this._units)) {
                for (const e in this._expressions)
                    if (this._expressions[e].regexp.test(this._val.trim())) {
                        this._units = e;
                        break
                    }
            } else if (ya(this._val)) {
                let e = 0;
                for (const n in this._val)
                    if (Et(this._val[n])) {
                        const r = this._val[n],
                            s = new this.constructor(this.context, n).valueOf() * r;
                        e += s
                    } return e
            }
            if (Et(this._units)) {
                const e = this._expressions[this._units],
                    n = this._val.toString().trim().match(e.regexp);
                return n ? e.method.apply(this, n.slice(1)) : e.method.call(this, this._val)
            } else return Xs(this._val) ? parseFloat(this._val) : this._val
        }
        _frequencyToUnits(e) {
            return 1 / e
        }
        _beatsToUnits(e) {
            return 60 / this._getBpm() * e
        }
        _secondsToUnits(e) {
            return e
        }
        _ticksToUnits(e) {
            return e * this._beatsToUnits(1) / this._getPPQ()
        }
        _noArg() {
            return this._now()
        }
        _getBpm() {
            return this.context.transport.bpm.value
        }
        _getTimeSignature() {
            return this.context.transport.timeSignature
        }
        _getPPQ() {
            return this.context.transport.PPQ
        }
        fromType(e) {
            switch (this._units = void 0, this.defaultUnits) {
                case "s":
                    this._val = e.toSeconds();
                    break;
                case "i":
                    this._val = e.toTicks();
                    break;
                case "hz":
                    this._val = e.toFrequency();
                    break;
                case "midi":
                    this._val = e.toMidi();
                    break
            }
            return this
        }
        toFrequency() {
            return 1 / this.toSeconds()
        }
        toSamples() {
            return this.toSeconds() * this.context.sampleRate
        }
        toMilliseconds() {
            return this.toSeconds() * 1e3
        }
    }
    class Ss extends q0 {
        constructor() {
            super(...arguments), this.name = "TimeClass"
        }
        _getExpressions() {
            return Object.assign(super._getExpressions(), {
                now: {
                    method: e => this._now() + new this.constructor(this.context, e).valueOf(),
                    regexp: /^\+(.+)/
                },
                quantize: {
                    method: e => {
                        const n = new Ss(this.context, e).valueOf();
                        return this._secondsToUnits(this.context.transport.nextSubdivision(n))
                    },
                    regexp: /^@(.+)/
                }
            })
        }
        quantize(e, n = 1) {
            const r = new this.constructor(this.context, e).valueOf(),
                s = this.valueOf(),
                c = Math.round(s / r) * r - s;
            return s + c * n
        }
        toNotation() {
            const e = this.toSeconds(),
                n = ["1m"];
            for (let i = 1; i < 9; i++) {
                const a = Math.pow(2, i);
                n.push(a + "n."), n.push(a + "n"), n.push(a + "t")
            }
            n.push("0");
            let r = n[0],
                s = new Ss(this.context, n[0]).toSeconds();
            return n.forEach(i => {
                const a = new Ss(this.context, i).toSeconds();
                Math.abs(a - e) < Math.abs(s - e) && (r = i, s = a)
            }), r
        }
        toBarsBeatsSixteenths() {
            const e = this._beatsToUnits(1);
            let n = this.valueOf() / e;
            n = parseFloat(n.toFixed(4));
            const r = Math.floor(n / this._getTimeSignature());
            let s = n % 1 * 4;
            n = Math.floor(n) % this._getTimeSignature();
            const i = s.toString();
            return i.length > 3 && (s = parseFloat(parseFloat(i).toFixed(3))), [r, n, s].join(":")
        }
        toTicks() {
            const e = this._beatsToUnits(1),
                n = this.valueOf() / e;
            return Math.round(n * this._getPPQ())
        }
        toSeconds() {
            return this.valueOf()
        }
        toMidi() {
            return ha(this.toFrequency())
        }
        _now() {
            return this.context.now()
        }
    }
    class Gn extends Ss {
        constructor() {
            super(...arguments), this.name = "Frequency", this.defaultUnits = "hz"
        }
        static get A4() {
            return jye()
        }
        static set A4(e) {
            Gye(e)
        }
        _getExpressions() {
            return Object.assign({}, super._getExpressions(), {
                midi: {
                    regexp: /^(\d+(?:\.\d+)?midi)/,
                    method(e) {
                        return this.defaultUnits === "midi" ? e : Gn.mtof(e)
                    }
                },
                note: {
                    regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,
                    method(e, n) {
                        const s = Wye[e.toLowerCase()] + (parseInt(n, 10) + 1) * 12;
                        return this.defaultUnits === "midi" ? s : Gn.mtof(s)
                    }
                },
                tr: {
                    regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
                    method(e, n, r) {
                        let s = 1;
                        return e && e !== "0" && (s *= this._beatsToUnits(this._getTimeSignature() * parseFloat(e))), n && n !== "0" && (s *= this._beatsToUnits(parseFloat(n))), r && r !== "0" && (s *= this._beatsToUnits(parseFloat(r) / 4)), s
                    }
                }
            })
        }
        transpose(e) {
            return new Gn(this.context, this.valueOf() * Oa(e))
        }
        harmonize(e) {
            return e.map(n => this.transpose(n))
        }
        toMidi() {
            return ha(this.valueOf())
        }
        toNote() {
            const e = this.toFrequency(),
                n = Math.log2(e / Gn.A4);
            let r = Math.round(12 * n) + 57;
            const s = Math.floor(r / 12);
            return s < 0 && (r += -12 * s), Hye[r % 12] + s.toString()
        }
        toSeconds() {
            return 1 / super.toSeconds()
        }
        toTicks() {
            const e = this._beatsToUnits(1),
                n = this.valueOf() / e;
            return Math.floor(n * this._getPPQ())
        }
        _noArg() {
            return 0
        }
        _frequencyToUnits(e) {
            return e
        }
        _ticksToUnits(e) {
            return 1 / (e * 60 / (this._getBpm() * this._getPPQ()))
        }
        _beatsToUnits(e) {
            return 1 / super._beatsToUnits(e)
        }
        _secondsToUnits(e) {
            return 1 / e
        }
        static mtof(e) {
            return KI(e)
        }
        static ftom(e) {
            return ha(e)
        }
    }
    const Wye = {
            cbb: -2,
            cb: -1,
            c: 0,
            "c#": 1,
            cx: 2,
            dbb: 0,
            db: 1,
            d: 2,
            "d#": 3,
            dx: 4,
            ebb: 2,
            eb: 3,
            e: 4,
            "e#": 5,
            ex: 6,
            fbb: 3,
            fb: 4,
            f: 5,
            "f#": 6,
            fx: 7,
            gbb: 5,
            gb: 6,
            g: 7,
            "g#": 8,
            gx: 9,
            abb: 7,
            ab: 8,
            a: 9,
            "a#": 10,
            ax: 11,
            bbb: 9,
            bb: 10,
            b: 11,
            "b#": 12,
            bx: 13
        },
        Hye = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

    function Vd(t, e) {
        return new Gn(es(), t, e)
    }
    class il extends Ss {
        constructor() {
            super(...arguments), this.name = "TransportTime"
        }
        _now() {
            return this.context.transport.seconds
        }
    }
    class Or extends qi {
        constructor() {
            super();
            const e = J(Or.getDefaults(), arguments, ["context"]);
            this.defaultContext ? this.context = this.defaultContext : this.context = e.context
        }
        static getDefaults() {
            return {
                context: es()
            }
        }
        now() {
            return this.context.currentTime + this.context.lookAhead
        }
        immediate() {
            return this.context.currentTime
        }
        get sampleTime() {
            return 1 / this.context.sampleRate
        }
        get blockTime() {
            return 128 / this.context.sampleRate
        }
        toSeconds(e) {
            return new Ss(this.context, e).toSeconds()
        }
        toFrequency(e) {
            return new Gn(this.context, e).toFrequency()
        }
        toTicks(e) {
            return new il(this.context, e).toTicks()
        }
        _getPartialProperties(e) {
            const n = this.get();
            return Object.keys(n).forEach(r => {
                rs(e[r]) && delete n[r]
            }), n
        }
        get() {
            const e = Lye(this);
            return Object.keys(e).forEach(n => {
                if (Reflect.has(this, n)) {
                    const r = this[n];
                    Et(r) && Et(r.value) && Et(r.setValueAtTime) ? e[n] = r.value : r instanceof Or ? e[n] = r._getPartialProperties(e[n]) : Fr(r) || Ri(r) || Xs(r) || kye(r) ? e[n] = r : delete e[n]
                }
            }), e
        }
        set(e) {
            return Object.keys(e).forEach(n => {
                Reflect.has(this, n) && Et(this[n]) && (this[n] && Et(this[n].value) && Et(this[n].setValueAtTime) ? this[n].value !== e[n] && (this[n].value = e[n]) : this[n] instanceof Or ? this[n].set(e[n]) : this[n] = e[n])
            }), this
        }
    }
    class V0 extends ci {
        constructor(e = "stopped") {
            super(), this.name = "StateTimeline", this._initial = e, this.setStateAtTime(this._initial, 0)
        }
        getValueAtTime(e) {
            const n = this.get(e);
            return n !== null ? n.state : this._initial
        }
        setStateAtTime(e, n, r) {
            return Cs(n, 0), this.add(Object.assign({}, r, {
                state: e,
                time: n
            })), this
        }
        getLastState(e, n) {
            const r = this._search(n);
            for (let s = r; s >= 0; s--) {
                const i = this._timeline[s];
                if (i.state === e) return i
            }
        }
        getNextState(e, n) {
            const r = this._search(n);
            if (r !== -1)
                for (let s = r; s < this._timeline.length; s++) {
                    const i = this._timeline[s];
                    if (i.state === e) return i
                }
        }
    }
    class at extends Or {
        constructor() {
            super(J(at.getDefaults(), arguments, ["param", "units", "convert"])), this.name = "Param", this.overridden = !1, this._minOutput = 1e-7;
            const e = J(at.getDefaults(), arguments, ["param", "units", "convert"]);
            for (Ke(Et(e.param) && (wa(e.param) || e.param instanceof at), "param must be an AudioParam"); !wa(e.param);) e.param = e.param._param;
            this._swappable = Et(e.swappable) ? e.swappable : !1, this._swappable ? (this.input = this.context.createGain(), this._param = e.param, this.input.connect(this._param)) : this._param = this.input = e.param, this._events = new ci(1e3), this._initialValue = this._param.defaultValue, this.units = e.units, this.convert = e.convert, this._minValue = e.minValue, this._maxValue = e.maxValue, Et(e.value) && e.value !== this._toType(this._initialValue) && this.setValueAtTime(e.value, 0)
        }
        static getDefaults() {
            return Object.assign(Or.getDefaults(), {
                convert: !0,
                units: "number"
            })
        }
        get value() {
            const e = this.now();
            return this.getValueAtTime(e)
        }
        set value(e) {
            this.cancelScheduledValues(this.now()), this.setValueAtTime(e, this.now())
        }
        get minValue() {
            return Et(this._minValue) ? this._minValue : this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples" ? 0 : this.units === "audioRange" ? -1 : this.units === "decibels" ? -1 / 0 : this._param.minValue
        }
        get maxValue() {
            return Et(this._maxValue) ? this._maxValue : this.units === "normalRange" || this.units === "audioRange" ? 1 : this._param.maxValue
        }
        _is(e, n) {
            return this.units === n
        }
        _assertRange(e) {
            return Et(this.maxValue) && Et(this.minValue) && Cs(e, this._fromType(this.minValue), this._fromType(this.maxValue)), e
        }
        _fromType(e) {
            return this.convert && !this.overridden ? this._is(e, "time") ? this.toSeconds(e) : this._is(e, "decibels") ? qd(e) : this._is(e, "frequency") ? this.toFrequency(e) : e : this.overridden ? 0 : e
        }
        _toType(e) {
            return this.convert && this.units === "decibels" ? B0(e) : e
        }
        setValueAtTime(e, n) {
            const r = this.toSeconds(n),
                s = this._fromType(e);
            return Ke(isFinite(s) && isFinite(r), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`), this._assertRange(s), this.log(this.units, "setValueAtTime", e, r), this._events.add({
                time: r,
                type: "setValueAtTime",
                value: s
            }), this._param.setValueAtTime(s, r), this
        }
        getValueAtTime(e) {
            const n = Math.max(this.toSeconds(e), 0),
                r = this._events.getAfter(n),
                s = this._events.get(n);
            let i = this._initialValue;
            if (s === null) i = this._initialValue;
            else if (s.type === "setTargetAtTime" && (r === null || r.type === "setValueAtTime")) {
                const a = this._events.getBefore(s.time);
                let c;
                a === null ? c = this._initialValue : c = a.value, s.type === "setTargetAtTime" && (i = this._exponentialApproach(s.time, c, s.value, s.constant, n))
            } else if (r === null) i = s.value;
            else if (r.type === "linearRampToValueAtTime" || r.type === "exponentialRampToValueAtTime") {
                let a = s.value;
                if (s.type === "setTargetAtTime") {
                    const c = this._events.getBefore(s.time);
                    c === null ? a = this._initialValue : a = c.value
                }
                r.type === "linearRampToValueAtTime" ? i = this._linearInterpolate(s.time, a, r.time, r.value, n) : i = this._exponentialInterpolate(s.time, a, r.time, r.value, n)
            } else i = s.value;
            return this._toType(i)
        }
        setRampPoint(e) {
            e = this.toSeconds(e);
            let n = this.getValueAtTime(e);
            return this.cancelAndHoldAtTime(e), this._fromType(n) === 0 && (n = this._toType(this._minOutput)), this.setValueAtTime(n, e), this
        }
        linearRampToValueAtTime(e, n) {
            const r = this._fromType(e),
                s = this.toSeconds(n);
            return Ke(isFinite(r) && isFinite(s), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`), this._assertRange(r), this._events.add({
                time: s,
                type: "linearRampToValueAtTime",
                value: r
            }), this.log(this.units, "linearRampToValueAtTime", e, s), this._param.linearRampToValueAtTime(r, s), this
        }
        exponentialRampToValueAtTime(e, n) {
            let r = this._fromType(e);
            r = ys(r, 0) ? this._minOutput : r, this._assertRange(r);
            const s = this.toSeconds(n);
            return Ke(isFinite(r) && isFinite(s), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`), this._events.add({
                time: s,
                type: "exponentialRampToValueAtTime",
                value: r
            }), this.log(this.units, "exponentialRampToValueAtTime", e, s), this._param.exponentialRampToValueAtTime(r, s), this
        }
        exponentialRampTo(e, n, r) {
            return r = this.toSeconds(r), this.setRampPoint(r), this.exponentialRampToValueAtTime(e, r + this.toSeconds(n)), this
        }
        linearRampTo(e, n, r) {
            return r = this.toSeconds(r), this.setRampPoint(r), this.linearRampToValueAtTime(e, r + this.toSeconds(n)), this
        }
        targetRampTo(e, n, r) {
            return r = this.toSeconds(r), this.setRampPoint(r), this.exponentialApproachValueAtTime(e, r, n), this
        }
        exponentialApproachValueAtTime(e, n, r) {
            n = this.toSeconds(n), r = this.toSeconds(r);
            const s = Math.log(r + 1) / Math.log(200);
            return this.setTargetAtTime(e, n, s), this.cancelAndHoldAtTime(n + r * .9), this.linearRampToValueAtTime(e, n + r), this
        }
        setTargetAtTime(e, n, r) {
            const s = this._fromType(e);
            Ke(isFinite(r) && r > 0, "timeConstant must be a number greater than 0");
            const i = this.toSeconds(n);
            return this._assertRange(s), Ke(isFinite(s) && isFinite(i), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(e)}, ${JSON.stringify(n)}`), this._events.add({
                constant: r,
                time: i,
                type: "setTargetAtTime",
                value: s
            }), this.log(this.units, "setTargetAtTime", e, i, r), this._param.setTargetAtTime(s, i, r), this
        }
        setValueCurveAtTime(e, n, r, s = 1) {
            r = this.toSeconds(r), n = this.toSeconds(n);
            const i = this._fromType(e[0]) * s;
            this.setValueAtTime(this._toType(i), n);
            const a = r / (e.length - 1);
            for (let c = 1; c < e.length; c++) {
                const l = this._fromType(e[c]) * s;
                this.linearRampToValueAtTime(this._toType(l), n + c * a)
            }
            return this
        }
        cancelScheduledValues(e) {
            const n = this.toSeconds(e);
            return Ke(isFinite(n), `Invalid argument to cancelScheduledValues: ${JSON.stringify(e)}`), this._events.cancel(n), this._param.cancelScheduledValues(n), this.log(this.units, "cancelScheduledValues", n), this
        }
        cancelAndHoldAtTime(e) {
            const n = this.toSeconds(e),
                r = this._fromType(this.getValueAtTime(n));
            Ke(isFinite(n), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(e)}`), this.log(this.units, "cancelAndHoldAtTime", n, "value=" + r);
            const s = this._events.get(n),
                i = this._events.getAfter(n);
            return s && ys(s.time, n) ? i ? (this._param.cancelScheduledValues(i.time), this._events.cancel(i.time)) : (this._param.cancelAndHoldAtTime(n), this._events.cancel(n + this.sampleTime)) : i && (this._param.cancelScheduledValues(i.time), this._events.cancel(i.time), i.type === "linearRampToValueAtTime" ? this.linearRampToValueAtTime(this._toType(r), n) : i.type === "exponentialRampToValueAtTime" && this.exponentialRampToValueAtTime(this._toType(r), n)), this._events.add({
                time: n,
                type: "setValueAtTime",
                value: r
            }), this._param.setValueAtTime(r, n), this
        }
        rampTo(e, n = .1, r) {
            return this.units === "frequency" || this.units === "bpm" || this.units === "decibels" ? this.exponentialRampTo(e, n, r) : this.linearRampTo(e, n, r), this
        }
        apply(e) {
            const n = this.context.currentTime;
            e.setValueAtTime(this.getValueAtTime(n), n);
            const r = this._events.get(n);
            if (r && r.type === "setTargetAtTime") {
                const s = this._events.getAfter(r.time),
                    i = s ? s.time : n + 2,
                    a = (i - n) / 10;
                for (let c = n; c < i; c += a) e.linearRampToValueAtTime(this.getValueAtTime(c), c)
            }
            return this._events.forEachAfter(this.context.currentTime, s => {
                s.type === "cancelScheduledValues" ? e.cancelScheduledValues(s.time) : s.type === "setTargetAtTime" ? e.setTargetAtTime(s.value, s.time, s.constant) : e[s.type](s.value, s.time)
            }), this
        }
        setParam(e) {
            Ke(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
            const n = this.input;
            return n.disconnect(this._param), this.apply(e), this._param = e, n.connect(this._param), this
        }
        dispose() {
            return super.dispose(), this._events.dispose(), this
        }
        get defaultValue() {
            return this._toType(this._param.defaultValue)
        }
        _exponentialApproach(e, n, r, s, i) {
            return r + (n - r) * Math.exp(-(i - e) / s)
        }
        _linearInterpolate(e, n, r, s, i) {
            return n + (s - n) * ((i - e) / (r - e))
        }
        _exponentialInterpolate(e, n, r, s, i) {
            return n * Math.pow(s / n, (i - e) / (r - e))
        }
    }
    class Ne extends Or {
        constructor() {
            super(...arguments), this.name = "ToneAudioNode", this._internalChannels = []
        }
        get numberOfInputs() {
            return Et(this.input) ? wa(this.input) || this.input instanceof at ? 1 : this.input.numberOfInputs : 0
        }
        get numberOfOutputs() {
            return Et(this.output) ? this.output.numberOfOutputs : 0
        }
        _isAudioNode(e) {
            return Et(e) && (e instanceof Ne || yo(e))
        }
        _getInternalNodes() {
            const e = this._internalChannels.slice(0);
            return this._isAudioNode(this.input) && e.push(this.input), this._isAudioNode(this.output) && this.input !== this.output && e.push(this.output), e
        }
        _setChannelProperties(e) {
            this._getInternalNodes().forEach(r => {
                r.channelCount = e.channelCount, r.channelCountMode = e.channelCountMode, r.channelInterpretation = e.channelInterpretation
            })
        }
        _getChannelProperties() {
            const e = this._getInternalNodes();
            Ke(e.length > 0, "ToneAudioNode does not have any internal nodes");
            const n = e[0];
            return {
                channelCount: n.channelCount,
                channelCountMode: n.channelCountMode,
                channelInterpretation: n.channelInterpretation
            }
        }
        get channelCount() {
            return this._getChannelProperties().channelCount
        }
        set channelCount(e) {
            const n = this._getChannelProperties();
            this._setChannelProperties(Object.assign(n, {
                channelCount: e
            }))
        }
        get channelCountMode() {
            return this._getChannelProperties().channelCountMode
        }
        set channelCountMode(e) {
            const n = this._getChannelProperties();
            this._setChannelProperties(Object.assign(n, {
                channelCountMode: e
            }))
        }
        get channelInterpretation() {
            return this._getChannelProperties().channelInterpretation
        }
        set channelInterpretation(e) {
            const n = this._getChannelProperties();
            this._setChannelProperties(Object.assign(n, {
                channelInterpretation: e
            }))
        }
        connect(e, n = 0, r = 0) {
            return os(this, e, n, r), this
        }
        toDestination() {
            return this.connect(this.context.destination), this
        }
        toMaster() {
            return F0("toMaster() has been renamed toDestination()"), this.toDestination()
        }
        disconnect(e, n = 0, r = 0) {
            return YI(this, e, n, r), this
        }
        chain(...e) {
            return is(this, ...e), this
        }
        fan(...e) {
            return e.forEach(n => this.connect(n)), this
        }
        dispose() {
            return super.dispose(), Et(this.input) && (this.input instanceof Ne ? this.input.dispose() : yo(this.input) && this.input.disconnect()), Et(this.output) && (this.output instanceof Ne ? this.output.dispose() : yo(this.output) && this.output.disconnect()), this._internalChannels = [], this
        }
    }

    function is(...t) {
        const e = t.shift();
        t.reduce((n, r) => (n instanceof Ne ? n.connect(r) : yo(n) && os(n, r), r), e)
    }

    function os(t, e, n = 0, r = 0) {
        for (Ke(Et(t), "Cannot connect from undefined node"), Ke(Et(e), "Cannot connect to undefined node"), (e instanceof Ne || yo(e)) && Ke(e.numberOfInputs > 0, "Cannot connect to node with no inputs"), Ke(t.numberOfOutputs > 0, "Cannot connect from node with no outputs"); e instanceof Ne || e instanceof at;) Et(e.input) && (e = e.input);
        for (; t instanceof Ne;) Et(t.output) && (t = t.output);
        wa(e) ? t.connect(e, n) : t.connect(e, n, r)
    }

    function YI(t, e, n = 0, r = 0) {
        if (Et(e))
            for (; e instanceof Ne;) e = e.input;
        for (; !yo(t);) Et(t.output) && (t = t.output);
        wa(e) ? t.disconnect(e, n) : yo(e) ? t.disconnect(e, n, r) : t.disconnect()
    }
    class Be extends Ne {
        constructor() {
            super(J(Be.getDefaults(), arguments, ["gain", "units"])), this.name = "Gain", this._gainNode = this.context.createGain(), this.input = this._gainNode, this.output = this._gainNode;
            const e = J(Be.getDefaults(), arguments, ["gain", "units"]);
            this.gain = new at({
                context: this.context,
                convert: e.convert,
                param: this._gainNode.gain,
                units: e.units,
                value: e.gain,
                minValue: e.minValue,
                maxValue: e.maxValue
            }), je(this, "gain")
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                convert: !0,
                gain: 1,
                units: "gain"
            })
        }
        dispose() {
            return super.dispose(), this._gainNode.disconnect(), this.gain.dispose(), this
        }
    }
    class Vc extends Ne {
        constructor(e) {
            super(e), this.onended = ft, this._startTime = -1, this._stopTime = -1, this._timeout = -1, this.output = new Be({
                context: this.context,
                gain: 0
            }), this._gainNode = this.output, this.getStateAtTime = function(n) {
                const r = this.toSeconds(n);
                return this._startTime !== -1 && r >= this._startTime && (this._stopTime === -1 || r <= this._stopTime) ? "started" : "stopped"
            }, this._fadeIn = e.fadeIn, this._fadeOut = e.fadeOut, this._curve = e.curve, this.onended = e.onended
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                curve: "linear",
                fadeIn: 0,
                fadeOut: 0,
                onended: ft
            })
        }
        _startGain(e, n = 1) {
            Ke(this._startTime === -1, "Source cannot be started more than once");
            const r = this.toSeconds(this._fadeIn);
            return this._startTime = e + r, this._startTime = Math.max(this._startTime, this.context.currentTime), r > 0 ? (this._gainNode.gain.setValueAtTime(0, e), this._curve === "linear" ? this._gainNode.gain.linearRampToValueAtTime(n, e + r) : this._gainNode.gain.exponentialApproachValueAtTime(n, e, r)) : this._gainNode.gain.setValueAtTime(n, e), this
        }
        stop(e) {
            return this.log("stop", e), this._stopGain(this.toSeconds(e)), this
        }
        _stopGain(e) {
            Ke(this._startTime !== -1, "'start' must be called before 'stop'"), this.cancelStop();
            const n = this.toSeconds(this._fadeOut);
            return this._stopTime = this.toSeconds(e) + n, this._stopTime = Math.max(this._stopTime, this.context.currentTime), n > 0 ? this._curve === "linear" ? this._gainNode.gain.linearRampTo(0, n, e) : this._gainNode.gain.targetRampTo(0, n, e) : (this._gainNode.gain.cancelAndHoldAtTime(e), this._gainNode.gain.setValueAtTime(0, e)), this.context.clearTimeout(this._timeout), this._timeout = this.context.setTimeout(() => {
                const r = this._curve === "exponential" ? n * 2 : 0;
                this._stopSource(this.now() + r), this._onended()
            }, this._stopTime - this.context.currentTime), this
        }
        _onended() {
            if (this.onended !== ft && (this.onended(this), this.onended = ft, !this.context.isOffline)) {
                const e = () => this.dispose();
                typeof window.requestIdleCallback < "u" ? window.requestIdleCallback(e) : setTimeout(e, 1e3)
            }
        }
        get state() {
            return this.getStateAtTime(this.now())
        }
        cancelStop() {
            return this.log("cancelStop"), Ke(this._startTime !== -1, "Source is not started"), this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime), this.context.clearTimeout(this._timeout), this._stopTime = -1, this
        }
        dispose() {
            return super.dispose(), this._gainNode.disconnect(), this
        }
    }
    class jd extends Vc {
        constructor() {
            super(J(jd.getDefaults(), arguments, ["offset"])), this.name = "ToneConstantSource", this._source = this.context.createConstantSource();
            const e = J(jd.getDefaults(), arguments, ["offset"]);
            os(this._source, this._gainNode), this.offset = new at({
                context: this.context,
                convert: e.convert,
                param: this._source.offset,
                units: e.units,
                value: e.offset,
                minValue: e.minValue,
                maxValue: e.maxValue
            })
        }
        static getDefaults() {
            return Object.assign(Vc.getDefaults(), {
                convert: !0,
                offset: 1,
                units: "number"
            })
        }
        start(e) {
            const n = this.toSeconds(e);
            return this.log("start", n), this._startGain(n), this._source.start(n), this
        }
        _stopSource(e) {
            this._source.stop(e)
        }
        dispose() {
            return super.dispose(), this.state === "started" && this.stop(), this._source.disconnect(), this.offset.dispose(), this
        }
    }
    class Ye extends Ne {
        constructor() {
            super(J(Ye.getDefaults(), arguments, ["value", "units"])), this.name = "Signal", this.override = !0;
            const e = J(Ye.getDefaults(), arguments, ["value", "units"]);
            this.output = this._constantSource = new jd({
                context: this.context,
                convert: e.convert,
                offset: e.value,
                units: e.units,
                minValue: e.minValue,
                maxValue: e.maxValue
            }), this._constantSource.start(0), this.input = this._param = this._constantSource.offset
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                convert: !0,
                units: "number",
                value: 0
            })
        }
        connect(e, n = 0, r = 0) {
            return Nm(this, e, n, r), this
        }
        dispose() {
            return super.dispose(), this._param.dispose(), this._constantSource.dispose(), this
        }
        setValueAtTime(e, n) {
            return this._param.setValueAtTime(e, n), this
        }
        getValueAtTime(e) {
            return this._param.getValueAtTime(e)
        }
        setRampPoint(e) {
            return this._param.setRampPoint(e), this
        }
        linearRampToValueAtTime(e, n) {
            return this._param.linearRampToValueAtTime(e, n), this
        }
        exponentialRampToValueAtTime(e, n) {
            return this._param.exponentialRampToValueAtTime(e, n), this
        }
        exponentialRampTo(e, n, r) {
            return this._param.exponentialRampTo(e, n, r), this
        }
        linearRampTo(e, n, r) {
            return this._param.linearRampTo(e, n, r), this
        }
        targetRampTo(e, n, r) {
            return this._param.targetRampTo(e, n, r), this
        }
        exponentialApproachValueAtTime(e, n, r) {
            return this._param.exponentialApproachValueAtTime(e, n, r), this
        }
        setTargetAtTime(e, n, r) {
            return this._param.setTargetAtTime(e, n, r), this
        }
        setValueCurveAtTime(e, n, r, s) {
            return this._param.setValueCurveAtTime(e, n, r, s), this
        }
        cancelScheduledValues(e) {
            return this._param.cancelScheduledValues(e), this
        }
        cancelAndHoldAtTime(e) {
            return this._param.cancelAndHoldAtTime(e), this
        }
        rampTo(e, n, r) {
            return this._param.rampTo(e, n, r), this
        }
        get value() {
            return this._param.value
        }
        set value(e) {
            this._param.value = e
        }
        get convert() {
            return this._param.convert
        }
        set convert(e) {
            this._param.convert = e
        }
        get units() {
            return this._param.units
        }
        get overridden() {
            return this._param.overridden
        }
        set overridden(e) {
            this._param.overridden = e
        }
        get maxValue() {
            return this._param.maxValue
        }
        get minValue() {
            return this._param.minValue
        }
        apply(e) {
            return this._param.apply(e), this
        }
    }

    function Nm(t, e, n, r) {
        (e instanceof at || wa(e) || e instanceof Ye && e.override) && (e.cancelScheduledValues(0), e.setValueAtTime(0, 0), e instanceof Ye && (e.overridden = !0)), os(t, e, n, r)
    }
    class Gd extends at {
        constructor() {
            super(J(Gd.getDefaults(), arguments, ["value"])), this.name = "TickParam", this._events = new ci(1 / 0), this._multiplier = 1;
            const e = J(Gd.getDefaults(), arguments, ["value"]);
            this._multiplier = e.multiplier, this._events.cancel(0), this._events.add({
                ticks: 0,
                time: 0,
                type: "setValueAtTime",
                value: this._fromType(e.value)
            }), this.setValueAtTime(e.value, 0)
        }
        static getDefaults() {
            return Object.assign(at.getDefaults(), {
                multiplier: 1,
                units: "hertz",
                value: 1
            })
        }
        setTargetAtTime(e, n, r) {
            n = this.toSeconds(n), this.setRampPoint(n);
            const s = this._fromType(e),
                i = this._events.get(n),
                a = Math.round(Math.max(1 / r, 1));
            for (let c = 0; c <= a; c++) {
                const l = r * c + n,
                    h = this._exponentialApproach(i.time, i.value, s, r, l);
                this.linearRampToValueAtTime(this._toType(h), l)
            }
            return this
        }
        setValueAtTime(e, n) {
            const r = this.toSeconds(n);
            super.setValueAtTime(e, n);
            const s = this._events.get(r),
                i = this._events.previousEvent(s),
                a = this._getTicksUntilEvent(i, r);
            return s.ticks = Math.max(a, 0), this
        }
        linearRampToValueAtTime(e, n) {
            const r = this.toSeconds(n);
            super.linearRampToValueAtTime(e, n);
            const s = this._events.get(r),
                i = this._events.previousEvent(s),
                a = this._getTicksUntilEvent(i, r);
            return s.ticks = Math.max(a, 0), this
        }
        exponentialRampToValueAtTime(e, n) {
            n = this.toSeconds(n);
            const r = this._fromType(e),
                s = this._events.get(n),
                i = Math.round(Math.max((n - s.time) * 10, 1)),
                a = (n - s.time) / i;
            for (let c = 0; c <= i; c++) {
                const l = a * c + s.time,
                    h = this._exponentialInterpolate(s.time, s.value, n, r, l);
                this.linearRampToValueAtTime(this._toType(h), l)
            }
            return this
        }
        _getTicksUntilEvent(e, n) {
            if (e === null) e = {
                ticks: 0,
                time: 0,
                type: "setValueAtTime",
                value: 0
            };
            else if (rs(e.ticks)) {
                const a = this._events.previousEvent(e);
                e.ticks = this._getTicksUntilEvent(a, e.time)
            }
            const r = this._fromType(this.getValueAtTime(e.time));
            let s = this._fromType(this.getValueAtTime(n));
            const i = this._events.get(n);
            return i && i.time === n && i.type === "setValueAtTime" && (s = this._fromType(this.getValueAtTime(n - this.sampleTime))), .5 * (n - e.time) * (r + s) + e.ticks
        }
        getTicksAtTime(e) {
            const n = this.toSeconds(e),
                r = this._events.get(n);
            return Math.max(this._getTicksUntilEvent(r, n), 0)
        }
        getDurationOfTicks(e, n) {
            const r = this.toSeconds(n),
                s = this.getTicksAtTime(n);
            return this.getTimeOfTick(s + e) - r
        }
        getTimeOfTick(e) {
            const n = this._events.get(e, "ticks"),
                r = this._events.getAfter(e, "ticks");
            if (n && n.ticks === e) return n.time;
            if (n && r && r.type === "linearRampToValueAtTime" && n.value !== r.value) {
                const s = this._fromType(this.getValueAtTime(n.time)),
                    a = (this._fromType(this.getValueAtTime(r.time)) - s) / (r.time - n.time),
                    c = Math.sqrt(Math.pow(s, 2) - 2 * a * (n.ticks - e)),
                    l = (-s + c) / a,
                    h = (-s - c) / a;
                return (l > 0 ? l : h) + n.time
            } else return n ? n.value === 0 ? 1 / 0 : n.time + (e - n.ticks) / n.value : e / this._initialValue
        }
        ticksToTime(e, n) {
            return this.getDurationOfTicks(e, n)
        }
        timeToTicks(e, n) {
            const r = this.toSeconds(n),
                s = this.toSeconds(e),
                i = this.getTicksAtTime(r);
            return this.getTicksAtTime(r + s) - i
        }
        _fromType(e) {
            return this.units === "bpm" && this.multiplier ? 1 / (60 / e / this.multiplier) : super._fromType(e)
        }
        _toType(e) {
            return this.units === "bpm" && this.multiplier ? e / this.multiplier * 60 : super._toType(e)
        }
        get multiplier() {
            return this._multiplier
        }
        set multiplier(e) {
            const n = this.value;
            this._multiplier = e, this.cancelScheduledValues(0), this.setValueAtTime(n, 0)
        }
    }
    class Wd extends Ye {
        constructor() {
            super(J(Wd.getDefaults(), arguments, ["value"])), this.name = "TickSignal";
            const e = J(Wd.getDefaults(), arguments, ["value"]);
            this.input = this._param = new Gd({
                context: this.context,
                convert: e.convert,
                multiplier: e.multiplier,
                param: this._constantSource.offset,
                units: e.units,
                value: e.value
            })
        }
        static getDefaults() {
            return Object.assign(Ye.getDefaults(), {
                multiplier: 1,
                units: "hertz",
                value: 1
            })
        }
        ticksToTime(e, n) {
            return this._param.ticksToTime(e, n)
        }
        timeToTicks(e, n) {
            return this._param.timeToTicks(e, n)
        }
        getTimeOfTick(e) {
            return this._param.getTimeOfTick(e)
        }
        getDurationOfTicks(e, n) {
            return this._param.getDurationOfTicks(e, n)
        }
        getTicksAtTime(e) {
            return this._param.getTicksAtTime(e)
        }
        get multiplier() {
            return this._param.multiplier
        }
        set multiplier(e) {
            this._param.multiplier = e
        }
        dispose() {
            return super.dispose(), this._param.dispose(), this
        }
    }
    class Hd extends Or {
        constructor() {
            super(J(Hd.getDefaults(), arguments, ["frequency"])), this.name = "TickSource", this._state = new V0, this._tickOffset = new ci;
            const e = J(Hd.getDefaults(), arguments, ["frequency"]);
            this.frequency = new Wd({
                context: this.context,
                units: e.units,
                value: e.frequency
            }), je(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.setTicksAtTime(0, 0)
        }
        static getDefaults() {
            return Object.assign({
                frequency: 1,
                units: "hertz"
            }, Or.getDefaults())
        }
        get state() {
            return this.getStateAtTime(this.now())
        }
        start(e, n) {
            const r = this.toSeconds(e);
            return this._state.getValueAtTime(r) !== "started" && (this._state.setStateAtTime("started", r), Et(n) && this.setTicksAtTime(n, r)), this
        }
        stop(e) {
            const n = this.toSeconds(e);
            if (this._state.getValueAtTime(n) === "stopped") {
                const r = this._state.get(n);
                r && r.time > 0 && (this._tickOffset.cancel(r.time), this._state.cancel(r.time))
            }
            return this._state.cancel(n), this._state.setStateAtTime("stopped", n), this.setTicksAtTime(0, n), this
        }
        pause(e) {
            const n = this.toSeconds(e);
            return this._state.getValueAtTime(n) === "started" && this._state.setStateAtTime("paused", n), this
        }
        cancel(e) {
            return e = this.toSeconds(e), this._state.cancel(e), this._tickOffset.cancel(e), this
        }
        getTicksAtTime(e) {
            const n = this.toSeconds(e),
                r = this._state.getLastState("stopped", n),
                s = {
                    state: "paused",
                    time: n
                };
            this._state.add(s);
            let i = r,
                a = 0;
            return this._state.forEachBetween(r.time, n + this.sampleTime, c => {
                let l = i.time;
                const h = this._tickOffset.get(c.time);
                h && h.time >= i.time && (a = h.ticks, l = h.time), i.state === "started" && c.state !== "started" && (a += this.frequency.getTicksAtTime(c.time) - this.frequency.getTicksAtTime(l)), i = c
            }), this._state.remove(s), a
        }
        get ticks() {
            return this.getTicksAtTime(this.now())
        }
        set ticks(e) {
            this.setTicksAtTime(e, this.now())
        }
        get seconds() {
            return this.getSecondsAtTime(this.now())
        }
        set seconds(e) {
            const n = this.now(),
                r = this.frequency.timeToTicks(e, n);
            this.setTicksAtTime(r, n)
        }
        getSecondsAtTime(e) {
            e = this.toSeconds(e);
            const n = this._state.getLastState("stopped", e),
                r = {
                    state: "paused",
                    time: e
                };
            this._state.add(r);
            let s = n,
                i = 0;
            return this._state.forEachBetween(n.time, e + this.sampleTime, a => {
                let c = s.time;
                const l = this._tickOffset.get(a.time);
                l && l.time >= s.time && (i = l.seconds, c = l.time), s.state === "started" && a.state !== "started" && (i += a.time - c), s = a
            }), this._state.remove(r), i
        }
        setTicksAtTime(e, n) {
            return n = this.toSeconds(n), this._tickOffset.cancel(n), this._tickOffset.add({
                seconds: this.frequency.getDurationOfTicks(e, n),
                ticks: e,
                time: n
            }), this
        }
        getStateAtTime(e) {
            return e = this.toSeconds(e), this._state.getValueAtTime(e)
        }
        getTimeOfTick(e, n = this.now()) {
            const r = this._tickOffset.get(n),
                s = this._state.get(n),
                i = Math.max(r.time, s.time),
                a = this.frequency.getTicksAtTime(i) + e - r.ticks;
            return this.frequency.getTimeOfTick(a)
        }
        forEachTickBetween(e, n, r) {
            let s = this._state.get(e);
            this._state.forEachBetween(e, n, a => {
                s && s.state === "started" && a.state !== "started" && this.forEachTickBetween(Math.max(s.time, e), a.time - this.sampleTime, r), s = a
            });
            let i = null;
            if (s && s.state === "started") {
                const a = Math.max(s.time, e),
                    c = this.frequency.getTicksAtTime(a),
                    l = this.frequency.getTicksAtTime(s.time),
                    h = c - l;
                let d = Math.ceil(h) - h;
                d = ys(d, 1) ? 0 : d;
                let p = this.frequency.getTimeOfTick(c + d);
                for (; p < n;) {
                    try {
                        r(p, Math.round(this.getTicksAtTime(p)))
                    } catch (g) {
                        i = g;
                        break
                    }
                    p += this.frequency.getDurationOfTicks(1, p)
                }
            }
            if (i) throw i;
            return this
        }
        dispose() {
            return super.dispose(), this._state.dispose(), this._tickOffset.dispose(), this.frequency.dispose(), this
        }
    }
    class Ol extends Or {
        constructor() {
            super(J(Ol.getDefaults(), arguments, ["callback", "frequency"])), this.name = "Clock", this.callback = ft, this._lastUpdate = 0, this._state = new V0("stopped"), this._boundLoop = this._loop.bind(this);
            const e = J(Ol.getDefaults(), arguments, ["callback", "frequency"]);
            this.callback = e.callback, this._tickSource = new Hd({
                context: this.context,
                frequency: e.frequency,
                units: e.units
            }), this._lastUpdate = 0, this.frequency = this._tickSource.frequency, je(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.context.on("tick", this._boundLoop)
        }
        static getDefaults() {
            return Object.assign(Or.getDefaults(), {
                callback: ft,
                frequency: 1,
                units: "hertz"
            })
        }
        get state() {
            return this._state.getValueAtTime(this.now())
        }
        start(e, n) {
            FI(this.context);
            const r = this.toSeconds(e);
            return this.log("start", r), this._state.getValueAtTime(r) !== "started" && (this._state.setStateAtTime("started", r), this._tickSource.start(r, n), r < this._lastUpdate && this.emit("start", r, n)), this
        }
        stop(e) {
            const n = this.toSeconds(e);
            return this.log("stop", n), this._state.cancel(n), this._state.setStateAtTime("stopped", n), this._tickSource.stop(n), n < this._lastUpdate && this.emit("stop", n), this
        }
        pause(e) {
            const n = this.toSeconds(e);
            return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n), this._tickSource.pause(n), n < this._lastUpdate && this.emit("pause", n)), this
        }
        get ticks() {
            return Math.ceil(this.getTicksAtTime(this.now()))
        }
        set ticks(e) {
            this._tickSource.ticks = e
        }
        get seconds() {
            return this._tickSource.seconds
        }
        set seconds(e) {
            this._tickSource.seconds = e
        }
        getSecondsAtTime(e) {
            return this._tickSource.getSecondsAtTime(e)
        }
        setTicksAtTime(e, n) {
            return this._tickSource.setTicksAtTime(e, n), this
        }
        getTimeOfTick(e, n = this.now()) {
            return this._tickSource.getTimeOfTick(e, n)
        }
        getTicksAtTime(e) {
            return this._tickSource.getTicksAtTime(e)
        }
        nextTickTime(e, n) {
            const r = this.toSeconds(n),
                s = this.getTicksAtTime(r);
            return this._tickSource.getTimeOfTick(s + e, r)
        }
        _loop() {
            const e = this._lastUpdate,
                n = this.now();
            this._lastUpdate = n, this.log("loop", e, n), e !== n && (this._state.forEachBetween(e, n, r => {
                switch (r.state) {
                    case "started":
                        const s = this._tickSource.getTicksAtTime(r.time);
                        this.emit("start", r.time, s);
                        break;
                    case "stopped":
                        r.time !== 0 && this.emit("stop", r.time);
                        break;
                    case "paused":
                        this.emit("pause", r.time);
                        break
                }
            }), this._tickSource.forEachTickBetween(e, n, (r, s) => {
                this.callback(r, s)
            }))
        }
        getStateAtTime(e) {
            const n = this.toSeconds(e);
            return this._state.getValueAtTime(n)
        }
        dispose() {
            return super.dispose(), this.context.off("tick", this._boundLoop), this._tickSource.dispose(), this._state.dispose(), this
        }
    }
    _h.mixin(Ol);
    class Ur extends Ne {
        constructor() {
            super(J(Ur.getDefaults(), arguments, ["delayTime", "maxDelay"])), this.name = "Delay";
            const e = J(Ur.getDefaults(), arguments, ["delayTime", "maxDelay"]),
                n = this.toSeconds(e.maxDelay);
            this._maxDelay = Math.max(n, this.toSeconds(e.delayTime)), this._delayNode = this.input = this.output = this.context.createDelay(n), this.delayTime = new at({
                context: this.context,
                param: this._delayNode.delayTime,
                units: "time",
                value: e.delayTime,
                minValue: 0,
                maxValue: this.maxDelay
            }), je(this, "delayTime")
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                delayTime: 0,
                maxDelay: 1
            })
        }
        get maxDelay() {
            return this._maxDelay
        }
        dispose() {
            return super.dispose(), this._delayNode.disconnect(), this.delayTime.dispose(), this
        }
    }
    class bh extends qi {
        constructor() {
            super(), this.name = "ToneAudioBuffers", this._buffers = new Map, this._loadingCount = 0;
            const e = J(bh.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
            this.baseUrl = e.baseUrl, Object.keys(e.urls).forEach(n => {
                this._loadingCount++;
                const r = e.urls[n];
                this.add(n, r, this._bufferLoaded.bind(this, e.onload), e.onerror)
            })
        }
        static getDefaults() {
            return {
                baseUrl: "",
                onerror: ft,
                onload: ft,
                urls: {}
            }
        }
        has(e) {
            return this._buffers.has(e.toString())
        }
        get(e) {
            return Ke(this.has(e), `ToneAudioBuffers has no buffer named: ${e}`), this._buffers.get(e.toString())
        }
        _bufferLoaded(e) {
            this._loadingCount--, this._loadingCount === 0 && e && e()
        }
        get loaded() {
            return Array.from(this._buffers).every(([e, n]) => n.loaded)
        }
        add(e, n, r = ft, s = ft) {
            return Xs(n) ? this._buffers.set(e.toString(), new It(this.baseUrl + n, r, s)) : this._buffers.set(e.toString(), new It(n, r, s)), this
        }
        dispose() {
            return super.dispose(), this._buffers.forEach(e => e.dispose()), this._buffers.clear(), this
        }
    }
    class Kd extends Gn {
        constructor() {
            super(...arguments), this.name = "MidiClass", this.defaultUnits = "midi"
        }
        _frequencyToUnits(e) {
            return ha(super._frequencyToUnits(e))
        }
        _ticksToUnits(e) {
            return ha(super._ticksToUnits(e))
        }
        _beatsToUnits(e) {
            return ha(super._beatsToUnits(e))
        }
        _secondsToUnits(e) {
            return ha(super._secondsToUnits(e))
        }
        toMidi() {
            return this.valueOf()
        }
        toFrequency() {
            return KI(this.toMidi())
        }
        transpose(e) {
            return new Kd(this.context, this.toMidi() + e)
        }
    }
    class Ai extends il {
        constructor() {
            super(...arguments), this.name = "Ticks", this.defaultUnits = "i"
        }
        _now() {
            return this.context.transport.ticks
        }
        _beatsToUnits(e) {
            return this._getPPQ() * e
        }
        _secondsToUnits(e) {
            return Math.floor(e / (60 / this._getBpm()) * this._getPPQ())
        }
        _ticksToUnits(e) {
            return e
        }
        toTicks() {
            return this.valueOf()
        }
        toSeconds() {
            return this.valueOf() / this._getPPQ() * (60 / this._getBpm())
        }
    }
    class Kye extends Or {
        constructor() {
            super(...arguments), this.name = "Draw", this.expiration = .25, this.anticipation = .008, this._events = new ci, this._boundDrawLoop = this._drawLoop.bind(this), this._animationFrame = -1
        }
        schedule(e, n) {
            return this._events.add({
                callback: e,
                time: this.toSeconds(n)
            }), this._events.length === 1 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)), this
        }
        cancel(e) {
            return this._events.cancel(this.toSeconds(e)), this
        }
        _drawLoop() {
            const e = this.context.currentTime;
            for (; this._events.length && this._events.peek().time - this.anticipation <= e;) {
                const n = this._events.shift();
                n && e - n.time <= this.expiration && n.callback()
            }
            this._events.length > 0 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop))
        }
        dispose() {
            return super.dispose(), this._events.dispose(), cancelAnimationFrame(this._animationFrame), this
        }
    }
    Om(t => {
        t.draw = new Kye({
            context: t
        })
    });
    Am(t => {
        t.draw.dispose()
    });
    class Yye extends qi {
        constructor() {
            super(...arguments), this.name = "IntervalTimeline", this._root = null, this._length = 0
        }
        add(e) {
            Ke(Et(e.time), "Events must have a time property"), Ke(Et(e.duration), "Events must have a duration parameter"), e.time = e.time.valueOf();
            let n = new zye(e.time, e.time + e.duration, e);
            for (this._root === null ? this._root = n : this._root.insert(n), this._length++; n !== null;) n.updateHeight(), n.updateMax(), this._rebalance(n), n = n.parent;
            return this
        }
        remove(e) {
            if (this._root !== null) {
                const n = [];
                this._root.search(e.time, n);
                for (const r of n)
                    if (r.event === e) {
                        this._removeNode(r), this._length--;
                        break
                    }
            }
            return this
        }
        get length() {
            return this._length
        }
        cancel(e) {
            return this.forEachFrom(e, n => this.remove(n)), this
        }
        _setRoot(e) {
            this._root = e, this._root !== null && (this._root.parent = null)
        }
        _replaceNodeInParent(e, n) {
            e.parent !== null ? (e.isLeftChild() ? e.parent.left = n : e.parent.right = n, this._rebalance(e.parent)) : this._setRoot(n)
        }
        _removeNode(e) {
            if (e.left === null && e.right === null) this._replaceNodeInParent(e, null);
            else if (e.right === null) this._replaceNodeInParent(e, e.left);
            else if (e.left === null) this._replaceNodeInParent(e, e.right);
            else {
                const n = e.getBalance();
                let r, s = null;
                if (n > 0)
                    if (e.left.right === null) r = e.left, r.right = e.right, s = r;
                    else {
                        for (r = e.left.right; r.right !== null;) r = r.right;
                        r.parent && (r.parent.right = r.left, s = r.parent, r.left = e.left, r.right = e.right)
                    }
                else if (e.right.left === null) r = e.right, r.left = e.left, s = r;
                else {
                    for (r = e.right.left; r.left !== null;) r = r.left;
                    r.parent && (r.parent.left = r.right, s = r.parent, r.left = e.left, r.right = e.right)
                }
                e.parent !== null ? e.isLeftChild() ? e.parent.left = r : e.parent.right = r : this._setRoot(r), s && this._rebalance(s)
            }
            e.dispose()
        }
        _rotateLeft(e) {
            const n = e.parent,
                r = e.isLeftChild(),
                s = e.right;
            s && (e.right = s.left, s.left = e), n !== null ? r ? n.left = s : n.right = s : this._setRoot(s)
        }
        _rotateRight(e) {
            const n = e.parent,
                r = e.isLeftChild(),
                s = e.left;
            s && (e.left = s.right, s.right = e), n !== null ? r ? n.left = s : n.right = s : this._setRoot(s)
        }
        _rebalance(e) {
            const n = e.getBalance();
            n > 1 && e.left ? e.left.getBalance() < 0 ? this._rotateLeft(e.left) : this._rotateRight(e) : n < -1 && e.right && (e.right.getBalance() > 0 ? this._rotateRight(e.right) : this._rotateLeft(e))
        }
        get(e) {
            if (this._root !== null) {
                const n = [];
                if (this._root.search(e, n), n.length > 0) {
                    let r = n[0];
                    for (let s = 1; s < n.length; s++) n[s].low > r.low && (r = n[s]);
                    return r.event
                }
            }
            return null
        }
        forEach(e) {
            if (this._root !== null) {
                const n = [];
                this._root.traverse(r => n.push(r)), n.forEach(r => {
                    r.event && e(r.event)
                })
            }
            return this
        }
        forEachAtTime(e, n) {
            if (this._root !== null) {
                const r = [];
                this._root.search(e, r), r.forEach(s => {
                    s.event && n(s.event)
                })
            }
            return this
        }
        forEachFrom(e, n) {
            if (this._root !== null) {
                const r = [];
                this._root.searchAfter(e, r), r.forEach(s => {
                    s.event && n(s.event)
                })
            }
            return this
        }
        dispose() {
            return super.dispose(), this._root !== null && this._root.traverse(e => e.dispose()), this._root = null, this
        }
    }
    class zye {
        constructor(e, n, r) {
            this._left = null, this._right = null, this.parent = null, this.height = 0, this.event = r, this.low = e, this.high = n, this.max = this.high
        }
        insert(e) {
            e.low <= this.low ? this.left === null ? this.left = e : this.left.insert(e) : this.right === null ? this.right = e : this.right.insert(e)
        }
        search(e, n) {
            e > this.max || (this.left !== null && this.left.search(e, n), this.low <= e && this.high > e && n.push(this), !(this.low > e) && this.right !== null && this.right.search(e, n))
        }
        searchAfter(e, n) {
            this.low >= e && (n.push(this), this.left !== null && this.left.searchAfter(e, n)), this.right !== null && this.right.searchAfter(e, n)
        }
        traverse(e) {
            e(this), this.left !== null && this.left.traverse(e), this.right !== null && this.right.traverse(e)
        }
        updateHeight() {
            this.left !== null && this.right !== null ? this.height = Math.max(this.left.height, this.right.height) + 1 : this.right !== null ? this.height = this.right.height + 1 : this.left !== null ? this.height = this.left.height + 1 : this.height = 0
        }
        updateMax() {
            this.max = this.high, this.left !== null && (this.max = Math.max(this.max, this.left.max)), this.right !== null && (this.max = Math.max(this.max, this.right.max))
        }
        getBalance() {
            let e = 0;
            return this.left !== null && this.right !== null ? e = this.left.height - this.right.height : this.left !== null ? e = this.left.height + 1 : this.right !== null && (e = -(this.right.height + 1)), e
        }
        isLeftChild() {
            return this.parent !== null && this.parent.left === this
        }
        get left() {
            return this._left
        }
        set left(e) {
            this._left = e, e !== null && (e.parent = this), this.updateHeight(), this.updateMax()
        }
        get right() {
            return this._right
        }
        set right(e) {
            this._right = e, e !== null && (e.parent = this), this.updateHeight(), this.updateMax()
        }
        dispose() {
            this.parent = null, this._left = null, this._right = null, this.event = null
        }
    }
    class Qs extends Ne {
        constructor() {
            super(J(Qs.getDefaults(), arguments, ["volume"])), this.name = "Volume";
            const e = J(Qs.getDefaults(), arguments, ["volume"]);
            this.input = this.output = new Be({
                context: this.context,
                gain: e.volume,
                units: "decibels"
            }), this.volume = this.output.gain, je(this, "volume"), this._unmutedVolume = e.volume, this.mute = e.mute
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                mute: !1,
                volume: 0
            })
        }
        get mute() {
            return this.volume.value === -1 / 0
        }
        set mute(e) {
            !this.mute && e ? (this._unmutedVolume = this.volume.value, this.volume.value = -1 / 0) : this.mute && !e && (this.volume.value = this._unmutedVolume)
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this.volume.dispose(), this
        }
    }
    class Yd extends Ne {
        constructor() {
            super(J(Yd.getDefaults(), arguments)), this.name = "Destination", this.input = new Qs({
                context: this.context
            }), this.output = new Be({
                context: this.context
            }), this.volume = this.input.volume;
            const e = J(Yd.getDefaults(), arguments);
            is(this.input, this.output, this.context.rawContext.destination), this.mute = e.mute, this._internalChannels = [this.input, this.context.rawContext.destination, this.output]
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                mute: !1,
                volume: 0
            })
        }
        get mute() {
            return this.input.mute
        }
        set mute(e) {
            this.input.mute = e
        }
        chain(...e) {
            return this.input.disconnect(), e.unshift(this.input), e.push(this.output), is(...e), this
        }
        get maxChannelCount() {
            return this.context.rawContext.destination.maxChannelCount
        }
        dispose() {
            return super.dispose(), this.volume.dispose(), this
        }
    }
    Om(t => {
        t.destination = new Yd({
            context: t
        })
    });
    Am(t => {
        t.destination.dispose()
    });
    class Zye extends qi {
        constructor(e) {
            super(), this.name = "TimelineValue", this._timeline = new ci({
                memory: 10
            }), this._initialValue = e
        }
        set(e, n) {
            return this._timeline.add({
                value: e,
                time: n
            }), this
        }
        get(e) {
            const n = this._timeline.get(e);
            return n ? n.value : this._initialValue
        }
    }
    class Ao {
        constructor(e, n) {
            this.id = Ao._eventId++;
            const r = Object.assign(Ao.getDefaults(), n);
            this.transport = e, this.callback = r.callback, this._once = r.once, this.time = r.time
        }
        static getDefaults() {
            return {
                callback: ft,
                once: !1,
                time: 0
            }
        }
        invoke(e) {
            this.callback && (this.callback(e), this._once && this.transport.clear(this.id))
        }
        dispose() {
            return this.callback = void 0, this
        }
    }
    Ao._eventId = 0;
    class j0 extends Ao {
        constructor(e, n) {
            super(e, n), this._currentId = -1, this._nextId = -1, this._nextTick = this.time, this._boundRestart = this._restart.bind(this);
            const r = Object.assign(j0.getDefaults(), n);
            this.duration = new Ai(e.context, r.duration).valueOf(), this._interval = new Ai(e.context, r.interval).valueOf(), this._nextTick = r.time, this.transport.on("start", this._boundRestart), this.transport.on("loopStart", this._boundRestart), this.context = this.transport.context, this._restart()
        }
        static getDefaults() {
            return Object.assign({}, Ao.getDefaults(), {
                duration: 1 / 0,
                interval: 1,
                once: !1
            })
        }
        invoke(e) {
            this._createEvents(e), super.invoke(e)
        }
        _createEvents(e) {
            const n = this.transport.getTicksAtTime(e);
            n >= this.time && n >= this._nextTick && this._nextTick + this._interval < this.time + this.duration && (this._nextTick += this._interval, this._currentId = this._nextId, this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new Ai(this.context, this._nextTick).toSeconds()))
        }
        _restart(e) {
            this.transport.clear(this._currentId), this.transport.clear(this._nextId), this._nextTick = this.time;
            const n = this.transport.getTicksAtTime(e);
            n > this.time && (this._nextTick = this.time + Math.ceil((n - this.time) / this._interval) * this._interval), this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new Ai(this.context, this._nextTick).toSeconds()), this._nextTick += this._interval, this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new Ai(this.context, this._nextTick).toSeconds())
        }
        dispose() {
            return super.dispose(), this.transport.clear(this._currentId), this.transport.clear(this._nextId), this.transport.off("start", this._boundRestart), this.transport.off("loopStart", this._boundRestart), this
        }
    }
    class Al extends Or {
        constructor() {
            super(J(Al.getDefaults(), arguments)), this.name = "Transport", this._loop = new Zye(!1), this._loopStart = 0, this._loopEnd = 0, this._scheduledEvents = {}, this._timeline = new ci, this._repeatedEvents = new Yye, this._syncedSignals = [], this._swingAmount = 0;
            const e = J(Al.getDefaults(), arguments);
            this._ppq = e.ppq, this._clock = new Ol({
                callback: this._processTick.bind(this),
                context: this.context,
                frequency: 0,
                units: "bpm"
            }), this._bindClockEvents(), this.bpm = this._clock.frequency, this._clock.frequency.multiplier = e.ppq, this.bpm.setValueAtTime(e.bpm, 0), je(this, "bpm"), this._timeSignature = e.timeSignature, this._swingTicks = e.ppq / 2
        }
        static getDefaults() {
            return Object.assign(Or.getDefaults(), {
                bpm: 120,
                loopEnd: "4m",
                loopStart: 0,
                ppq: 192,
                swing: 0,
                swingSubdivision: "8n",
                timeSignature: 4
            })
        }
        _processTick(e, n) {
            if (this._loop.get(e) && n >= this._loopEnd && (this.emit("loopEnd", e), this._clock.setTicksAtTime(this._loopStart, e), n = this._loopStart, this.emit("loopStart", e, this._clock.getSecondsAtTime(e)), this.emit("loop", e)), this._swingAmount > 0 && n % this._ppq !== 0 && n % (this._swingTicks * 2) !== 0) {
                const r = n % (this._swingTicks * 2) / (this._swingTicks * 2),
                    s = Math.sin(r * Math.PI) * this._swingAmount;
                e += new Ai(this.context, this._swingTicks * 2 / 3).toSeconds() * s
            }
            this._timeline.forEachAtTime(n, r => r.invoke(e))
        }
        schedule(e, n) {
            const r = new Ao(this, {
                callback: e,
                time: new il(this.context, n).toTicks()
            });
            return this._addEvent(r, this._timeline)
        }
        scheduleRepeat(e, n, r, s = 1 / 0) {
            const i = new j0(this, {
                callback: e,
                duration: new Ss(this.context, s).toTicks(),
                interval: new Ss(this.context, n).toTicks(),
                time: new il(this.context, r).toTicks()
            });
            return this._addEvent(i, this._repeatedEvents)
        }
        scheduleOnce(e, n) {
            const r = new Ao(this, {
                callback: e,
                once: !0,
                time: new il(this.context, n).toTicks()
            });
            return this._addEvent(r, this._timeline)
        }
        clear(e) {
            if (this._scheduledEvents.hasOwnProperty(e)) {
                const n = this._scheduledEvents[e.toString()];
                n.timeline.remove(n.event), n.event.dispose(), delete this._scheduledEvents[e.toString()]
            }
            return this
        }
        _addEvent(e, n) {
            return this._scheduledEvents[e.id.toString()] = {
                event: e,
                timeline: n
            }, n.add(e), e.id
        }
        cancel(e = 0) {
            const n = this.toTicks(e);
            return this._timeline.forEachFrom(n, r => this.clear(r.id)), this._repeatedEvents.forEachFrom(n, r => this.clear(r.id)), this
        }
        _bindClockEvents() {
            this._clock.on("start", (e, n) => {
                n = new Ai(this.context, n).toSeconds(), this.emit("start", e, n)
            }), this._clock.on("stop", e => {
                this.emit("stop", e)
            }), this._clock.on("pause", e => {
                this.emit("pause", e)
            })
        }
        get state() {
            return this._clock.getStateAtTime(this.now())
        }
        start(e, n) {
            let r;
            return Et(n) && (r = this.toTicks(n)), this._clock.start(e, r), this
        }
        stop(e) {
            return this._clock.stop(e), this
        }
        pause(e) {
            return this._clock.pause(e), this
        }
        toggle(e) {
            return e = this.toSeconds(e), this._clock.getStateAtTime(e) !== "started" ? this.start(e) : this.stop(e), this
        }
        get timeSignature() {
            return this._timeSignature
        }
        set timeSignature(e) {
            Fr(e) && (e = e[0] / e[1] * 4), this._timeSignature = e
        }
        get loopStart() {
            return new Ss(this.context, this._loopStart, "i").toSeconds()
        }
        set loopStart(e) {
            this._loopStart = this.toTicks(e)
        }
        get loopEnd() {
            return new Ss(this.context, this._loopEnd, "i").toSeconds()
        }
        set loopEnd(e) {
            this._loopEnd = this.toTicks(e)
        }
        get loop() {
            return this._loop.get(this.now())
        }
        set loop(e) {
            this._loop.set(e, this.now())
        }
        setLoopPoints(e, n) {
            return this.loopStart = e, this.loopEnd = n, this
        }
        get swing() {
            return this._swingAmount
        }
        set swing(e) {
            this._swingAmount = e
        }
        get swingSubdivision() {
            return new Ai(this.context, this._swingTicks).toNotation()
        }
        set swingSubdivision(e) {
            this._swingTicks = this.toTicks(e)
        }
        get position() {
            const e = this.now(),
                n = this._clock.getTicksAtTime(e);
            return new Ai(this.context, n).toBarsBeatsSixteenths()
        }
        set position(e) {
            const n = this.toTicks(e);
            this.ticks = n
        }
        get seconds() {
            return this._clock.seconds
        }
        set seconds(e) {
            const n = this.now(),
                r = this._clock.frequency.timeToTicks(e, n);
            this.ticks = r
        }
        get progress() {
            if (this.loop) {
                const e = this.now();
                return (this._clock.getTicksAtTime(e) - this._loopStart) / (this._loopEnd - this._loopStart)
            } else return 0
        }
        get ticks() {
            return this._clock.ticks
        }
        set ticks(e) {
            if (this._clock.ticks !== e) {
                const n = this.now();
                if (this.state === "started") {
                    const r = this._clock.getTicksAtTime(n),
                        s = this._clock.frequency.getDurationOfTicks(Math.ceil(r) - r, n),
                        i = n + s;
                    this.emit("stop", i), this._clock.setTicksAtTime(e, i), this.emit("start", i, this._clock.getSecondsAtTime(i))
                } else this._clock.setTicksAtTime(e, n)
            }
        }
        getTicksAtTime(e) {
            return Math.round(this._clock.getTicksAtTime(e))
        }
        getSecondsAtTime(e) {
            return this._clock.getSecondsAtTime(e)
        }
        get PPQ() {
            return this._clock.frequency.multiplier
        }
        set PPQ(e) {
            this._clock.frequency.multiplier = e
        }
        nextSubdivision(e) {
            if (e = this.toTicks(e), this.state !== "started") return 0; {
                const n = this.now(),
                    r = this.getTicksAtTime(n),
                    s = e - r % e;
                return this._clock.nextTickTime(s, n)
            }
        }
        syncSignal(e, n) {
            if (!n) {
                const s = this.now();
                if (e.getValueAtTime(s) !== 0) {
                    const a = 1 / (60 / this.bpm.getValueAtTime(s) / this.PPQ);
                    n = e.getValueAtTime(s) / a
                } else n = 0
            }
            const r = new Be(n);
            return this.bpm.connect(r), r.connect(e._param), this._syncedSignals.push({
                initial: e.value,
                ratio: r,
                signal: e
            }), e.value = 0, this
        }
        unsyncSignal(e) {
            for (let n = this._syncedSignals.length - 1; n >= 0; n--) {
                const r = this._syncedSignals[n];
                r.signal === e && (r.ratio.dispose(), r.signal.value = r.initial, this._syncedSignals.splice(n, 1))
            }
            return this
        }
        dispose() {
            return super.dispose(), this._clock.dispose(), vh(this, "bpm"), this._timeline.dispose(), this._repeatedEvents.dispose(), this
        }
    }
    _h.mixin(Al);
    Om(t => {
        t.transport = new Al({
            context: t
        })
    });
    Am(t => {
        t.transport.dispose()
    });
    class On extends Ne {
        constructor(e) {
            super(e), this.input = void 0, this._state = new V0("stopped"), this._synced = !1, this._scheduled = [], this._syncedStart = ft, this._syncedStop = ft, this._state.memory = 100, this._state.increasing = !0, this._volume = this.output = new Qs({
                context: this.context,
                mute: e.mute,
                volume: e.volume
            }), this.volume = this._volume.volume, je(this, "volume"), this.onstop = e.onstop
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                mute: !1,
                onstop: ft,
                volume: 0
            })
        }
        get state() {
            return this._synced ? this.context.transport.state === "started" ? this._state.getValueAtTime(this.context.transport.seconds) : "stopped" : this._state.getValueAtTime(this.now())
        }
        get mute() {
            return this._volume.mute
        }
        set mute(e) {
            this._volume.mute = e
        }
        _clampToCurrentTime(e) {
            return this._synced ? e : Math.max(e, this.context.currentTime)
        }
        start(e, n, r) {
            let s = rs(e) && this._synced ? this.context.transport.seconds : this.toSeconds(e);
            if (s = this._clampToCurrentTime(s), !this._synced && this._state.getValueAtTime(s) === "started") Ke(Bd(s, this._state.get(s).time), "Start time must be strictly greater than previous start time"), this._state.cancel(s), this._state.setStateAtTime("started", s), this.log("restart", s), this.restart(s, n, r);
            else if (this.log("start", s), this._state.setStateAtTime("started", s), this._synced) {
                const i = this._state.get(s);
                i && (i.offset = this.toSeconds(Ic(n, 0)), i.duration = r ? this.toSeconds(r) : void 0);
                const a = this.context.transport.schedule(c => {
                    this._start(c, n, r)
                }, s);
                this._scheduled.push(a), this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > s && this._syncedStart(this.now(), this.context.transport.seconds)
            } else FI(this.context), this._start(s, n, r);
            return this
        }
        stop(e) {
            let n = rs(e) && this._synced ? this.context.transport.seconds : this.toSeconds(e);
            if (n = this._clampToCurrentTime(n), this._state.getValueAtTime(n) === "started" || Et(this._state.getNextState("started", n))) {
                if (this.log("stop", n), !this._synced) this._stop(n);
                else {
                    const r = this.context.transport.schedule(this._stop.bind(this), n);
                    this._scheduled.push(r)
                }
                this._state.cancel(n), this._state.setStateAtTime("stopped", n)
            }
            return this
        }
        restart(e, n, r) {
            return e = this.toSeconds(e), this._state.getValueAtTime(e) === "started" && (this._state.cancel(e), this._restart(e, n, r)), this
        }
        sync() {
            return this._synced || (this._synced = !0, this._syncedStart = (e, n) => {
                if (n > 0) {
                    const r = this._state.get(n);
                    if (r && r.state === "started" && r.time !== n) {
                        const s = n - this.toSeconds(r.time);
                        let i;
                        r.duration && (i = this.toSeconds(r.duration) - s), this._start(e, this.toSeconds(r.offset) + s, i)
                    }
                }
            }, this._syncedStop = e => {
                const n = this.context.transport.getSecondsAtTime(Math.max(e - this.sampleTime, 0));
                this._state.getValueAtTime(n) === "started" && this._stop(e)
            }, this.context.transport.on("start", this._syncedStart), this.context.transport.on("loopStart", this._syncedStart), this.context.transport.on("stop", this._syncedStop), this.context.transport.on("pause", this._syncedStop), this.context.transport.on("loopEnd", this._syncedStop)), this
        }
        unsync() {
            return this._synced && (this.context.transport.off("stop", this._syncedStop), this.context.transport.off("pause", this._syncedStop), this.context.transport.off("loopEnd", this._syncedStop), this.context.transport.off("start", this._syncedStart), this.context.transport.off("loopStart", this._syncedStart)), this._synced = !1, this._scheduled.forEach(e => this.context.transport.clear(e)), this._scheduled = [], this._state.cancel(0), this._stop(0), this
        }
        dispose() {
            return super.dispose(), this.onstop = ft, this.unsync(), this._volume.dispose(), this._state.dispose(), this
        }
    }
    class Js extends Vc {
        constructor() {
            super(J(Js.getDefaults(), arguments, ["url", "onload"])), this.name = "ToneBufferSource", this._source = this.context.createBufferSource(), this._internalChannels = [this._source], this._sourceStarted = !1, this._sourceStopped = !1;
            const e = J(Js.getDefaults(), arguments, ["url", "onload"]);
            os(this._source, this._gainNode), this._source.onended = () => this._stopSource(), this.playbackRate = new at({
                context: this.context,
                param: this._source.playbackRate,
                units: "positive",
                value: e.playbackRate
            }), this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this._buffer = new It(e.url, e.onload, e.onerror), this._internalChannels.push(this._source)
        }
        static getDefaults() {
            return Object.assign(Vc.getDefaults(), {
                url: new It,
                loop: !1,
                loopEnd: 0,
                loopStart: 0,
                onload: ft,
                onerror: ft,
                playbackRate: 1
            })
        }
        get fadeIn() {
            return this._fadeIn
        }
        set fadeIn(e) {
            this._fadeIn = e
        }
        get fadeOut() {
            return this._fadeOut
        }
        set fadeOut(e) {
            this._fadeOut = e
        }
        get curve() {
            return this._curve
        }
        set curve(e) {
            this._curve = e
        }
        start(e, n, r, s = 1) {
            Ke(this.buffer.loaded, "buffer is either not set or not loaded");
            const i = this.toSeconds(e);
            this._startGain(i, s), this.loop ? n = Ic(n, this.loopStart) : n = Ic(n, 0);
            let a = Math.max(this.toSeconds(n), 0);
            if (this.loop) {
                const c = this.toSeconds(this.loopEnd) || this.buffer.duration,
                    l = this.toSeconds(this.loopStart),
                    h = c - l;
                dy(a, c) && (a = (a - l) % h + l), ys(a, this.buffer.duration) && (a = 0)
            }
            if (this._source.buffer = this.buffer.get(), this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration, qI(a, this.buffer.duration) && (this._sourceStarted = !0, this._source.start(i, a)), Et(r)) {
                let c = this.toSeconds(r);
                c = Math.max(c, 0), this.stop(i + c)
            }
            return this
        }
        _stopSource(e) {
            !this._sourceStopped && this._sourceStarted && (this._sourceStopped = !0, this._source.stop(this.toSeconds(e)), this._onended())
        }
        get loopStart() {
            return this._source.loopStart
        }
        set loopStart(e) {
            this._source.loopStart = this.toSeconds(e)
        }
        get loopEnd() {
            return this._source.loopEnd
        }
        set loopEnd(e) {
            this._source.loopEnd = this.toSeconds(e)
        }
        get buffer() {
            return this._buffer
        }
        set buffer(e) {
            this._buffer.set(e)
        }
        get loop() {
            return this._source.loop
        }
        set loop(e) {
            this._source.loop = e, this._sourceStarted && this.cancelStop()
        }
        dispose() {
            return super.dispose(), this._source.onended = null, this._source.disconnect(), this._buffer.dispose(), this.playbackRate.dispose(), this
        }
    }
    class Co extends On {
        constructor() {
            super(J(Co.getDefaults(), arguments, ["type"])), this.name = "Noise", this._source = null;
            const e = J(Co.getDefaults(), arguments, ["type"]);
            this._playbackRate = e.playbackRate, this.type = e.type, this._fadeIn = e.fadeIn, this._fadeOut = e.fadeOut
        }
        static getDefaults() {
            return Object.assign(On.getDefaults(), {
                fadeIn: 0,
                fadeOut: 0,
                playbackRate: 1,
                type: "white"
            })
        }
        get type() {
            return this._type
        }
        set type(e) {
            if (Ke(e in G3, "Noise: invalid type: " + e), this._type !== e && (this._type = e, this.state === "started")) {
                const n = this.now();
                this._stop(n), this._start(n)
            }
        }
        get playbackRate() {
            return this._playbackRate
        }
        set playbackRate(e) {
            this._playbackRate = e, this._source && (this._source.playbackRate.value = e)
        }
        _start(e) {
            const n = G3[this._type];
            this._source = new Js({
                url: n,
                context: this.context,
                fadeIn: this._fadeIn,
                fadeOut: this._fadeOut,
                loop: !0,
                onended: () => this.onstop(this),
                playbackRate: this._playbackRate
            }).connect(this.output), this._source.start(this.toSeconds(e), Math.random() * (n.duration - .001))
        }
        _stop(e) {
            this._source && (this._source.stop(this.toSeconds(e)), this._source = null)
        }
        get fadeIn() {
            return this._fadeIn
        }
        set fadeIn(e) {
            this._fadeIn = e, this._source && (this._source.fadeIn = this._fadeIn)
        }
        get fadeOut() {
            return this._fadeOut
        }
        set fadeOut(e) {
            this._fadeOut = e, this._source && (this._source.fadeOut = this._fadeOut)
        }
        _restart(e) {
            this._stop(e), this._start(e)
        }
        dispose() {
            return super.dispose(), this._source && this._source.disconnect(), this
        }
    }
    const nc = 44100 * 5,
        H_ = 2,
        vi = {
            brown: null,
            pink: null,
            white: null
        },
        G3 = {
            get brown() {
                if (!vi.brown) {
                    const t = [];
                    for (let e = 0; e < H_; e++) {
                        const n = new Float32Array(nc);
                        t[e] = n;
                        let r = 0;
                        for (let s = 0; s < nc; s++) {
                            const i = Math.random() * 2 - 1;
                            n[s] = (r + .02 * i) / 1.02, r = n[s], n[s] *= 3.5
                        }
                    }
                    vi.brown = new It().fromArray(t)
                }
                return vi.brown
            },
            get pink() {
                if (!vi.pink) {
                    const t = [];
                    for (let e = 0; e < H_; e++) {
                        const n = new Float32Array(nc);
                        t[e] = n;
                        let r, s, i, a, c, l, h;
                        r = s = i = a = c = l = h = 0;
                        for (let d = 0; d < nc; d++) {
                            const p = Math.random() * 2 - 1;
                            r = .99886 * r + p * .0555179, s = .99332 * s + p * .0750759, i = .969 * i + p * .153852, a = .8665 * a + p * .3104856, c = .55 * c + p * .5329522, l = -.7616 * l - p * .016898, n[d] = r + s + i + a + c + l + h + p * .5362, n[d] *= .11, h = p * .115926
                        }
                    }
                    vi.pink = new It().fromArray(t)
                }
                return vi.pink
            },
            get white() {
                if (!vi.white) {
                    const t = [];
                    for (let e = 0; e < H_; e++) {
                        const n = new Float32Array(nc);
                        t[e] = n;
                        for (let r = 0; r < nc; r++) n[r] = Math.random() * 2 - 1
                    }
                    vi.white = new It().fromArray(t)
                }
                return vi.white
            }
        };

    function Da(t, e) {
        return vn(this, void 0, void 0, function*() {
            const n = e / t.context.sampleRate,
                r = new Cm(1, n, t.context.sampleRate);
            return new t.constructor(Object.assign(t.get(), {
                frequency: 2 / n,
                detune: 0,
                context: r
            })).toDestination().start(0), (yield r.render()).getChannelData(0)
        })
    }
    class Cl extends Vc {
        constructor() {
            super(J(Cl.getDefaults(), arguments, ["frequency", "type"])), this.name = "ToneOscillatorNode", this._oscillator = this.context.createOscillator(), this._internalChannels = [this._oscillator];
            const e = J(Cl.getDefaults(), arguments, ["frequency", "type"]);
            os(this._oscillator, this._gainNode), this.type = e.type, this.frequency = new at({
                context: this.context,
                param: this._oscillator.frequency,
                units: "frequency",
                value: e.frequency
            }), this.detune = new at({
                context: this.context,
                param: this._oscillator.detune,
                units: "cents",
                value: e.detune
            }), je(this, ["frequency", "detune"])
        }
        static getDefaults() {
            return Object.assign(Vc.getDefaults(), {
                detune: 0,
                frequency: 440,
                type: "sine"
            })
        }
        start(e) {
            const n = this.toSeconds(e);
            return this.log("start", n), this._startGain(n), this._oscillator.start(n), this
        }
        _stopSource(e) {
            this._oscillator.stop(e)
        }
        setPeriodicWave(e) {
            return this._oscillator.setPeriodicWave(e), this
        }
        get type() {
            return this._oscillator.type
        }
        set type(e) {
            this._oscillator.type = e
        }
        dispose() {
            return super.dispose(), this.state === "started" && this.stop(), this._oscillator.disconnect(), this.frequency.dispose(), this.detune.dispose(), this
        }
    }
    class rn extends On {
        constructor() {
            super(J(rn.getDefaults(), arguments, ["frequency", "type"])), this.name = "Oscillator", this._oscillator = null;
            const e = J(rn.getDefaults(), arguments, ["frequency", "type"]);
            this.frequency = new Ye({
                context: this.context,
                units: "frequency",
                value: e.frequency
            }), je(this, "frequency"), this.detune = new Ye({
                context: this.context,
                units: "cents",
                value: e.detune
            }), je(this, "detune"), this._partials = e.partials, this._partialCount = e.partialCount, this._type = e.type, e.partialCount && e.type !== "custom" && (this._type = this.baseType + e.partialCount.toString()), this.phase = e.phase
        }
        static getDefaults() {
            return Object.assign(On.getDefaults(), {
                detune: 0,
                frequency: 440,
                partialCount: 0,
                partials: [],
                phase: 0,
                type: "sine"
            })
        }
        _start(e) {
            const n = this.toSeconds(e),
                r = new Cl({
                    context: this.context,
                    onended: () => this.onstop(this)
                });
            this._oscillator = r, this._wave ? this._oscillator.setPeriodicWave(this._wave) : this._oscillator.type = this._type, this._oscillator.connect(this.output), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.start(n)
        }
        _stop(e) {
            const n = this.toSeconds(e);
            this._oscillator && this._oscillator.stop(n)
        }
        _restart(e) {
            const n = this.toSeconds(e);
            return this.log("restart", n), this._oscillator && this._oscillator.cancelStop(), this._state.cancel(n), this
        }
        syncFrequency() {
            return this.context.transport.syncSignal(this.frequency), this
        }
        unsyncFrequency() {
            return this.context.transport.unsyncSignal(this.frequency), this
        }
        _getCachedPeriodicWave() {
            if (this._type === "custom") return rn._periodicWaveCache.find(n => n.phase === this._phase && $ye(n.partials, this._partials)); {
                const e = rn._periodicWaveCache.find(n => n.type === this._type && n.phase === this._phase);
                return this._partialCount = e ? e.partialCount : this._partialCount, e
            }
        }
        get type() {
            return this._type
        }
        set type(e) {
            this._type = e;
            const n = ["sine", "square", "sawtooth", "triangle"].indexOf(e) !== -1;
            if (this._phase === 0 && n) this._wave = void 0, this._partialCount = 0, this._oscillator !== null && (this._oscillator.type = e);
            else {
                const r = this._getCachedPeriodicWave();
                if (Et(r)) {
                    const {
                        partials: s,
                        wave: i
                    } = r;
                    this._wave = i, this._partials = s, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave)
                } else {
                    const [s, i] = this._getRealImaginary(e, this._phase), a = this.context.createPeriodicWave(s, i);
                    this._wave = a, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave), rn._periodicWaveCache.push({
                        imag: i,
                        partialCount: this._partialCount,
                        partials: this._partials,
                        phase: this._phase,
                        real: s,
                        type: this._type,
                        wave: this._wave
                    }), rn._periodicWaveCache.length > 100 && rn._periodicWaveCache.shift()
                }
            }
        }
        get baseType() {
            return this._type.replace(this.partialCount.toString(), "")
        }
        set baseType(e) {
            this.partialCount && this._type !== "custom" && e !== "custom" ? this.type = e + this.partialCount : this.type = e
        }
        get partialCount() {
            return this._partialCount
        }
        set partialCount(e) {
            Cs(e, 0);
            let n = this._type;
            const r = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
            if (r && (n = r[1]), this._type !== "custom") e === 0 ? this.type = n : this.type = n + e.toString();
            else {
                const s = new Float32Array(e);
                this._partials.forEach((i, a) => s[a] = i), this._partials = Array.from(s), this.type = this._type
            }
        }
        _getRealImaginary(e, n) {
            let s = 2048;
            const i = new Float32Array(s),
                a = new Float32Array(s);
            let c = 1;
            if (e === "custom") {
                if (c = this._partials.length + 1, this._partialCount = this._partials.length, s = c, this._partials.length === 0) return [i, a]
            } else {
                const l = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(e);
                l ? (c = parseInt(l[2], 10) + 1, this._partialCount = parseInt(l[2], 10), e = l[1], c = Math.max(c, 2), s = c) : this._partialCount = 0, this._partials = []
            }
            for (let l = 1; l < s; ++l) {
                const h = 2 / (l * Math.PI);
                let d;
                switch (e) {
                    case "sine":
                        d = l <= c ? 1 : 0, this._partials[l - 1] = d;
                        break;
                    case "square":
                        d = l & 1 ? 2 * h : 0, this._partials[l - 1] = d;
                        break;
                    case "sawtooth":
                        d = h * (l & 1 ? 1 : -1), this._partials[l - 1] = d;
                        break;
                    case "triangle":
                        l & 1 ? d = 2 * (h * h) * (l - 1 >> 1 & 1 ? -1 : 1) : d = 0, this._partials[l - 1] = d;
                        break;
                    case "custom":
                        d = this._partials[l - 1];
                        break;
                    default:
                        throw new TypeError("Oscillator: invalid type: " + e)
                }
                d !== 0 ? (i[l] = -d * Math.sin(n * l), a[l] = d * Math.cos(n * l)) : (i[l] = 0, a[l] = 0)
            }
            return [i, a]
        }
        _inverseFFT(e, n, r) {
            let s = 0;
            const i = e.length;
            for (let a = 0; a < i; a++) s += e[a] * Math.cos(a * r) + n[a] * Math.sin(a * r);
            return s
        }
        getInitialValue() {
            const [e, n] = this._getRealImaginary(this._type, 0);
            let r = 0;
            const s = Math.PI * 2,
                i = 32;
            for (let a = 0; a < i; a++) r = Math.max(this._inverseFFT(e, n, a / i * s), r);
            return Fye(-this._inverseFFT(e, n, this._phase) / r, -1, 1)
        }
        get partials() {
            return this._partials.slice(0, this.partialCount)
        }
        set partials(e) {
            this._partials = e, this._partialCount = this._partials.length, e.length && (this.type = "custom")
        }
        get phase() {
            return this._phase * (180 / Math.PI)
        }
        set phase(e) {
            this._phase = e * Math.PI / 180, this.type = this._type
        }
        asArray(e = 1024) {
            return vn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this._oscillator !== null && this._oscillator.dispose(), this._wave = void 0, this.frequency.dispose(), this.detune.dispose(), this
        }
    }
    rn._periodicWaveCache = [];
    class Br extends Ne {
        constructor() {
            super(Object.assign(J(Br.getDefaults(), arguments, ["context"])))
        }
        connect(e, n = 0, r = 0) {
            return Nm(this, e, n, r), this
        }
    }
    class Is extends Br {
        constructor() {
            super(Object.assign(J(Is.getDefaults(), arguments, ["mapping", "length"]))), this.name = "WaveShaper", this._shaper = this.context.createWaveShaper(), this.input = this._shaper, this.output = this._shaper;
            const e = J(Is.getDefaults(), arguments, ["mapping", "length"]);
            Fr(e.mapping) || e.mapping instanceof Float32Array ? this.curve = Float32Array.from(e.mapping) : Iye(e.mapping) && this.setMap(e.mapping, e.length)
        }
        static getDefaults() {
            return Object.assign(Ye.getDefaults(), {
                length: 1024
            })
        }
        setMap(e, n = 1024) {
            const r = new Float32Array(n);
            for (let s = 0, i = n; s < i; s++) {
                const a = s / (i - 1) * 2 - 1;
                r[s] = e(a, s)
            }
            return this.curve = r, this
        }
        get curve() {
            return this._shaper.curve
        }
        set curve(e) {
            this._shaper.curve = e
        }
        get oversample() {
            return this._shaper.oversample
        }
        set oversample(e) {
            const n = ["none", "2x", "4x"].some(r => r.includes(e));
            Ke(n, "oversampling must be either 'none', '2x', or '4x'"), this._shaper.oversample = e
        }
        dispose() {
            return super.dispose(), this._shaper.disconnect(), this
        }
    }
    class G0 extends Br {
        constructor() {
            super(...arguments), this.name = "AudioToGain", this._norm = new Is({
                context: this.context,
                mapping: e => (e + 1) / 2
            }), this.input = this._norm, this.output = this._norm
        }
        dispose() {
            return super.dispose(), this._norm.dispose(), this
        }
    }
    class on extends Ye {
        constructor() {
            super(Object.assign(J(on.getDefaults(), arguments, ["value"]))), this.name = "Multiply", this.override = !1;
            const e = J(on.getDefaults(), arguments, ["value"]);
            this._mult = this.input = this.output = new Be({
                context: this.context,
                minValue: e.minValue,
                maxValue: e.maxValue
            }), this.factor = this._param = this._mult.gain, this.factor.setValueAtTime(e.value, 0)
        }
        static getDefaults() {
            return Object.assign(Ye.getDefaults(), {
                value: 0
            })
        }
        dispose() {
            return super.dispose(), this._mult.dispose(), this
        }
    }
    class Il extends On {
        constructor() {
            super(J(Il.getDefaults(), arguments, ["frequency", "type", "modulationType"])), this.name = "AMOscillator", this._modulationScale = new G0({
                context: this.context
            }), this._modulationNode = new Be({
                context: this.context
            });
            const e = J(Il.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
            this._carrier = new rn({
                context: this.context,
                detune: e.detune,
                frequency: e.frequency,
                onstop: () => this.onstop(this),
                phase: e.phase,
                type: e.type
            }), this.frequency = this._carrier.frequency, this.detune = this._carrier.detune, this._modulator = new rn({
                context: this.context,
                phase: e.phase,
                type: e.modulationType
            }), this.harmonicity = new on({
                context: this.context,
                units: "positive",
                value: e.harmonicity
            }), this.frequency.chain(this.harmonicity, this._modulator.frequency), this._modulator.chain(this._modulationScale, this._modulationNode.gain), this._carrier.chain(this._modulationNode, this.output), je(this, ["frequency", "detune", "harmonicity"])
        }
        static getDefaults() {
            return Object.assign(rn.getDefaults(), {
                harmonicity: 1,
                modulationType: "square"
            })
        }
        _start(e) {
            this._modulator.start(e), this._carrier.start(e)
        }
        _stop(e) {
            this._modulator.stop(e), this._carrier.stop(e)
        }
        _restart(e) {
            this._modulator.restart(e), this._carrier.restart(e)
        }
        get type() {
            return this._carrier.type
        }
        set type(e) {
            this._carrier.type = e
        }
        get baseType() {
            return this._carrier.baseType
        }
        set baseType(e) {
            this._carrier.baseType = e
        }
        get partialCount() {
            return this._carrier.partialCount
        }
        set partialCount(e) {
            this._carrier.partialCount = e
        }
        get modulationType() {
            return this._modulator.type
        }
        set modulationType(e) {
            this._modulator.type = e
        }
        get phase() {
            return this._carrier.phase
        }
        set phase(e) {
            this._carrier.phase = e, this._modulator.phase = e
        }
        get partials() {
            return this._carrier.partials
        }
        set partials(e) {
            this._carrier.partials = e
        }
        asArray(e = 1024) {
            return vn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this._modulationScale.dispose(), this
        }
    }
    class jc extends On {
        constructor() {
            super(J(jc.getDefaults(), arguments, ["frequency", "type", "modulationType"])), this.name = "FMOscillator", this._modulationNode = new Be({
                context: this.context,
                gain: 0
            });
            const e = J(jc.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
            this._carrier = new rn({
                context: this.context,
                detune: e.detune,
                frequency: 0,
                onstop: () => this.onstop(this),
                phase: e.phase,
                type: e.type
            }), this.detune = this._carrier.detune, this.frequency = new Ye({
                context: this.context,
                units: "frequency",
                value: e.frequency
            }), this._modulator = new rn({
                context: this.context,
                phase: e.phase,
                type: e.modulationType
            }), this.harmonicity = new on({
                context: this.context,
                units: "positive",
                value: e.harmonicity
            }), this.modulationIndex = new on({
                context: this.context,
                units: "positive",
                value: e.modulationIndex
            }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.frequency.chain(this.modulationIndex, this._modulationNode), this._modulator.connect(this._modulationNode.gain), this._modulationNode.connect(this._carrier.frequency), this._carrier.connect(this.output), this.detune.connect(this._modulator.detune), je(this, ["modulationIndex", "frequency", "detune", "harmonicity"])
        }
        static getDefaults() {
            return Object.assign(rn.getDefaults(), {
                harmonicity: 1,
                modulationIndex: 2,
                modulationType: "square"
            })
        }
        _start(e) {
            this._modulator.start(e), this._carrier.start(e)
        }
        _stop(e) {
            this._modulator.stop(e), this._carrier.stop(e)
        }
        _restart(e) {
            return this._modulator.restart(e), this._carrier.restart(e), this
        }
        get type() {
            return this._carrier.type
        }
        set type(e) {
            this._carrier.type = e
        }
        get baseType() {
            return this._carrier.baseType
        }
        set baseType(e) {
            this._carrier.baseType = e
        }
        get partialCount() {
            return this._carrier.partialCount
        }
        set partialCount(e) {
            this._carrier.partialCount = e
        }
        get modulationType() {
            return this._modulator.type
        }
        set modulationType(e) {
            this._modulator.type = e
        }
        get phase() {
            return this._carrier.phase
        }
        set phase(e) {
            this._carrier.phase = e, this._modulator.phase = e
        }
        get partials() {
            return this._carrier.partials
        }
        set partials(e) {
            this._carrier.partials = e
        }
        asArray(e = 1024) {
            return vn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this.frequency.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this.modulationIndex.dispose(), this
        }
    }
    class Gc extends On {
        constructor() {
            super(J(Gc.getDefaults(), arguments, ["frequency", "width"])), this.name = "PulseOscillator", this._widthGate = new Be({
                context: this.context,
                gain: 0
            }), this._thresh = new Is({
                context: this.context,
                mapping: n => n <= 0 ? -1 : 1
            });
            const e = J(Gc.getDefaults(), arguments, ["frequency", "width"]);
            this.width = new Ye({
                context: this.context,
                units: "audioRange",
                value: e.width
            }), this._triangle = new rn({
                context: this.context,
                detune: e.detune,
                frequency: e.frequency,
                onstop: () => this.onstop(this),
                phase: e.phase,
                type: "triangle"
            }), this.frequency = this._triangle.frequency, this.detune = this._triangle.detune, this._triangle.chain(this._thresh, this.output), this.width.chain(this._widthGate, this._thresh), je(this, ["width", "frequency", "detune"])
        }
        static getDefaults() {
            return Object.assign(On.getDefaults(), {
                detune: 0,
                frequency: 440,
                phase: 0,
                type: "pulse",
                width: .2
            })
        }
        _start(e) {
            e = this.toSeconds(e), this._triangle.start(e), this._widthGate.gain.setValueAtTime(1, e)
        }
        _stop(e) {
            e = this.toSeconds(e), this._triangle.stop(e), this._widthGate.gain.cancelScheduledValues(e), this._widthGate.gain.setValueAtTime(0, e)
        }
        _restart(e) {
            this._triangle.restart(e), this._widthGate.gain.cancelScheduledValues(e), this._widthGate.gain.setValueAtTime(1, e)
        }
        get phase() {
            return this._triangle.phase
        }
        set phase(e) {
            this._triangle.phase = e
        }
        get type() {
            return "pulse"
        }
        get baseType() {
            return "pulse"
        }
        get partials() {
            return []
        }
        get partialCount() {
            return 0
        }
        set carrierType(e) {
            this._triangle.type = e
        }
        asArray(e = 1024) {
            return vn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this._triangle.dispose(), this.width.dispose(), this._widthGate.dispose(), this._thresh.dispose(), this
        }
    }
    class kl extends On {
        constructor() {
            super(J(kl.getDefaults(), arguments, ["frequency", "type", "spread"])), this.name = "FatOscillator", this._oscillators = [];
            const e = J(kl.getDefaults(), arguments, ["frequency", "type", "spread"]);
            this.frequency = new Ye({
                context: this.context,
                units: "frequency",
                value: e.frequency
            }), this.detune = new Ye({
                context: this.context,
                units: "cents",
                value: e.detune
            }), this._spread = e.spread, this._type = e.type, this._phase = e.phase, this._partials = e.partials, this._partialCount = e.partialCount, this.count = e.count, je(this, ["frequency", "detune"])
        }
        static getDefaults() {
            return Object.assign(rn.getDefaults(), {
                count: 3,
                spread: 20,
                type: "sawtooth"
            })
        }
        _start(e) {
            e = this.toSeconds(e), this._forEach(n => n.start(e))
        }
        _stop(e) {
            e = this.toSeconds(e), this._forEach(n => n.stop(e))
        }
        _restart(e) {
            this._forEach(n => n.restart(e))
        }
        _forEach(e) {
            for (let n = 0; n < this._oscillators.length; n++) e(this._oscillators[n], n)
        }
        get type() {
            return this._type
        }
        set type(e) {
            this._type = e, this._forEach(n => n.type = e)
        }
        get spread() {
            return this._spread
        }
        set spread(e) {
            if (this._spread = e, this._oscillators.length > 1) {
                const n = -e / 2,
                    r = e / (this._oscillators.length - 1);
                this._forEach((s, i) => s.detune.value = n + r * i)
            }
        }
        get count() {
            return this._oscillators.length
        }
        set count(e) {
            if (Cs(e, 1), this._oscillators.length !== e) {
                this._forEach(n => n.dispose()), this._oscillators = [];
                for (let n = 0; n < e; n++) {
                    const r = new rn({
                        context: this.context,
                        volume: -6 - e * 1.1,
                        type: this._type,
                        phase: this._phase + n / e * 360,
                        partialCount: this._partialCount,
                        onstop: n === 0 ? () => this.onstop(this) : ft
                    });
                    this.type === "custom" && (r.partials = this._partials), this.frequency.connect(r.frequency), this.detune.connect(r.detune), r.detune.overridden = !1, r.connect(this.output), this._oscillators[n] = r
                }
                this.spread = this._spread, this.state === "started" && this._forEach(n => n.start())
            }
        }
        get phase() {
            return this._phase
        }
        set phase(e) {
            this._phase = e, this._forEach((n, r) => n.phase = this._phase + r / this.count * 360)
        }
        get baseType() {
            return this._oscillators[0].baseType
        }
        set baseType(e) {
            this._forEach(n => n.baseType = e), this._type = this._oscillators[0].type
        }
        get partials() {
            return this._oscillators[0].partials
        }
        set partials(e) {
            this._partials = e, this._partialCount = this._partials.length, e.length && (this._type = "custom", this._forEach(n => n.partials = e))
        }
        get partialCount() {
            return this._oscillators[0].partialCount
        }
        set partialCount(e) {
            this._partialCount = e, this._forEach(n => n.partialCount = e), this._type = this._oscillators[0].type
        }
        asArray(e = 1024) {
            return vn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this._forEach(e => e.dispose()), this
        }
    }
    class Nl extends On {
        constructor() {
            super(J(Nl.getDefaults(), arguments, ["frequency", "modulationFrequency"])), this.name = "PWMOscillator", this.sourceType = "pwm", this._scale = new on({
                context: this.context,
                value: 2
            });
            const e = J(Nl.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
            this._pulse = new Gc({
                context: this.context,
                frequency: e.modulationFrequency
            }), this._pulse.carrierType = "sine", this.modulationFrequency = this._pulse.frequency, this._modulator = new rn({
                context: this.context,
                detune: e.detune,
                frequency: e.frequency,
                onstop: () => this.onstop(this),
                phase: e.phase
            }), this.frequency = this._modulator.frequency, this.detune = this._modulator.detune, this._modulator.chain(this._scale, this._pulse.width), this._pulse.connect(this.output), je(this, ["modulationFrequency", "frequency", "detune"])
        }
        static getDefaults() {
            return Object.assign(On.getDefaults(), {
                detune: 0,
                frequency: 440,
                modulationFrequency: .4,
                phase: 0,
                type: "pwm"
            })
        }
        _start(e) {
            e = this.toSeconds(e), this._modulator.start(e), this._pulse.start(e)
        }
        _stop(e) {
            e = this.toSeconds(e), this._modulator.stop(e), this._pulse.stop(e)
        }
        _restart(e) {
            this._modulator.restart(e), this._pulse.restart(e)
        }
        get type() {
            return "pwm"
        }
        get baseType() {
            return "pwm"
        }
        get partials() {
            return []
        }
        get partialCount() {
            return 0
        }
        get phase() {
            return this._modulator.phase
        }
        set phase(e) {
            this._modulator.phase = e
        }
        asArray(e = 1024) {
            return vn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this._pulse.dispose(), this._scale.dispose(), this._modulator.dispose(), this
        }
    }
    const W3 = {
        am: Il,
        fat: kl,
        fm: jc,
        oscillator: rn,
        pulse: Gc,
        pwm: Nl
    };
    class as extends On {
        constructor() {
            super(J(as.getDefaults(), arguments, ["frequency", "type"])), this.name = "OmniOscillator";
            const e = J(as.getDefaults(), arguments, ["frequency", "type"]);
            this.frequency = new Ye({
                context: this.context,
                units: "frequency",
                value: e.frequency
            }), this.detune = new Ye({
                context: this.context,
                units: "cents",
                value: e.detune
            }), je(this, ["frequency", "detune"]), this.set(e)
        }
        static getDefaults() {
            return Object.assign(rn.getDefaults(), jc.getDefaults(), Il.getDefaults(), kl.getDefaults(), Gc.getDefaults(), Nl.getDefaults())
        }
        _start(e) {
            this._oscillator.start(e)
        }
        _stop(e) {
            this._oscillator.stop(e)
        }
        _restart(e) {
            return this._oscillator.restart(e), this
        }
        get type() {
            let e = "";
            return ["am", "fm", "fat"].some(n => this._sourceType === n) && (e = this._sourceType), e + this._oscillator.type
        }
        set type(e) {
            e.substr(0, 2) === "fm" ? (this._createNewOscillator("fm"), this._oscillator = this._oscillator, this._oscillator.type = e.substr(2)) : e.substr(0, 2) === "am" ? (this._createNewOscillator("am"), this._oscillator = this._oscillator, this._oscillator.type = e.substr(2)) : e.substr(0, 3) === "fat" ? (this._createNewOscillator("fat"), this._oscillator = this._oscillator, this._oscillator.type = e.substr(3)) : e === "pwm" ? (this._createNewOscillator("pwm"), this._oscillator = this._oscillator) : e === "pulse" ? this._createNewOscillator("pulse") : (this._createNewOscillator("oscillator"), this._oscillator = this._oscillator, this._oscillator.type = e)
        }
        get partials() {
            return this._oscillator.partials
        }
        set partials(e) {
            !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partials = e)
        }
        get partialCount() {
            return this._oscillator.partialCount
        }
        set partialCount(e) {
            !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partialCount = e)
        }
        set(e) {
            return Reflect.has(e, "type") && e.type && (this.type = e.type), super.set(e), this
        }
        _createNewOscillator(e) {
            if (e !== this._sourceType) {
                this._sourceType = e;
                const n = W3[e],
                    r = this.now();
                if (this._oscillator) {
                    const s = this._oscillator;
                    s.stop(r), this.context.setTimeout(() => s.dispose(), this.blockTime)
                }
                this._oscillator = new n({
                    context: this.context
                }), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.connect(this.output), this._oscillator.onstop = () => this.onstop(this), this.state === "started" && this._oscillator.start(r)
            }
        }
        get phase() {
            return this._oscillator.phase
        }
        set phase(e) {
            this._oscillator.phase = e
        }
        get sourceType() {
            return this._sourceType
        }
        set sourceType(e) {
            let n = "sine";
            this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse" && (n = this._oscillator.type), e === "fm" ? this.type = "fm" + n : e === "am" ? this.type = "am" + n : e === "fat" ? this.type = "fat" + n : e === "oscillator" ? this.type = n : e === "pulse" ? this.type = "pulse" : e === "pwm" && (this.type = "pwm")
        }
        _getOscType(e, n) {
            return e instanceof W3[n]
        }
        get baseType() {
            return this._oscillator.baseType
        }
        set baseType(e) {
            !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && e !== "pulse" && e !== "pwm" && (this._oscillator.baseType = e)
        }
        get width() {
            if (this._getOscType(this._oscillator, "pulse")) return this._oscillator.width
        }
        get count() {
            if (this._getOscType(this._oscillator, "fat")) return this._oscillator.count
        }
        set count(e) {
            this._getOscType(this._oscillator, "fat") && Ri(e) && (this._oscillator.count = e)
        }
        get spread() {
            if (this._getOscType(this._oscillator, "fat")) return this._oscillator.spread
        }
        set spread(e) {
            this._getOscType(this._oscillator, "fat") && Ri(e) && (this._oscillator.spread = e)
        }
        get modulationType() {
            if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) return this._oscillator.modulationType
        }
        set modulationType(e) {
            (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && Xs(e) && (this._oscillator.modulationType = e)
        }
        get modulationIndex() {
            if (this._getOscType(this._oscillator, "fm")) return this._oscillator.modulationIndex
        }
        get harmonicity() {
            if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) return this._oscillator.harmonicity
        }
        get modulationFrequency() {
            if (this._getOscType(this._oscillator, "pwm")) return this._oscillator.modulationFrequency
        }
        asArray(e = 1024) {
            return vn(this, void 0, void 0, function*() {
                return Da(this, e)
            })
        }
        dispose() {
            return super.dispose(), this.detune.dispose(), this.frequency.dispose(), this._oscillator.dispose(), this
        }
    }
    class yu extends Ye {
        constructor() {
            super(Object.assign(J(yu.getDefaults(), arguments, ["value"]))), this.override = !1, this.name = "Add", this._sum = new Be({
                context: this.context
            }), this.input = this._sum, this.output = this._sum, this.addend = this._param, is(this._constantSource, this._sum)
        }
        static getDefaults() {
            return Object.assign(Ye.getDefaults(), {
                value: 0
            })
        }
        dispose() {
            return super.dispose(), this._sum.dispose(), this
        }
    }
    class Mi extends Br {
        constructor() {
            super(Object.assign(J(Mi.getDefaults(), arguments, ["min", "max"]))), this.name = "Scale";
            const e = J(Mi.getDefaults(), arguments, ["min", "max"]);
            this._mult = this.input = new on({
                context: this.context,
                value: e.max - e.min
            }), this._add = this.output = new yu({
                context: this.context,
                value: e.min
            }), this._min = e.min, this._max = e.max, this.input.connect(this.output)
        }
        static getDefaults() {
            return Object.assign(Br.getDefaults(), {
                max: 1,
                min: 0
            })
        }
        get min() {
            return this._min
        }
        set min(e) {
            this._min = e, this._setRange()
        }
        get max() {
            return this._max
        }
        set max(e) {
            this._max = e, this._setRange()
        }
        _setRange() {
            this._add.value = this._min, this._mult.value = this._max - this._min
        }
        dispose() {
            return super.dispose(), this._add.dispose(), this._mult.dispose(), this
        }
    }
    class W0 extends Br {
        constructor() {
            super(Object.assign(J(W0.getDefaults(), arguments))), this.name = "Zero", this._gain = new Be({
                context: this.context
            }), this.output = this._gain, this.input = void 0, os(this.context.getConstant(0), this._gain)
        }
        dispose() {
            return super.dispose(), YI(this.context.getConstant(0), this._gain), this
        }
    }
    class dr extends Ne {
        constructor() {
            super(J(dr.getDefaults(), arguments, ["frequency", "min", "max"])), this.name = "LFO", this._stoppedValue = 0, this._units = "number", this.convert = !0, this._fromType = at.prototype._fromType, this._toType = at.prototype._toType, this._is = at.prototype._is, this._clampValue = at.prototype._clampValue;
            const e = J(dr.getDefaults(), arguments, ["frequency", "min", "max"]);
            this._oscillator = new rn(e), this.frequency = this._oscillator.frequency, this._amplitudeGain = new Be({
                context: this.context,
                gain: e.amplitude,
                units: "normalRange"
            }), this.amplitude = this._amplitudeGain.gain, this._stoppedSignal = new Ye({
                context: this.context,
                units: "audioRange",
                value: 0
            }), this._zeros = new W0({
                context: this.context
            }), this._a2g = new G0({
                context: this.context
            }), this._scaler = this.output = new Mi({
                context: this.context,
                max: e.max,
                min: e.min
            }), this.units = e.units, this.min = e.min, this.max = e.max, this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler), this._zeros.connect(this._a2g), this._stoppedSignal.connect(this._a2g), je(this, ["amplitude", "frequency"]), this.phase = e.phase
        }
        static getDefaults() {
            return Object.assign(rn.getDefaults(), {
                amplitude: 1,
                frequency: "4n",
                max: 1,
                min: 0,
                type: "sine",
                units: "number"
            })
        }
        start(e) {
            return e = this.toSeconds(e), this._stoppedSignal.setValueAtTime(0, e), this._oscillator.start(e), this
        }
        stop(e) {
            return e = this.toSeconds(e), this._stoppedSignal.setValueAtTime(this._stoppedValue, e), this._oscillator.stop(e), this
        }
        sync() {
            return this._oscillator.sync(), this._oscillator.syncFrequency(), this
        }
        unsync() {
            return this._oscillator.unsync(), this._oscillator.unsyncFrequency(), this
        }
        _setStoppedValue() {
            this._stoppedValue = this._oscillator.getInitialValue(), this._stoppedSignal.value = this._stoppedValue
        }
        get min() {
            return this._toType(this._scaler.min)
        }
        set min(e) {
            e = this._fromType(e), this._scaler.min = e
        }
        get max() {
            return this._toType(this._scaler.max)
        }
        set max(e) {
            e = this._fromType(e), this._scaler.max = e
        }
        get type() {
            return this._oscillator.type
        }
        set type(e) {
            this._oscillator.type = e, this._setStoppedValue()
        }
        get partials() {
            return this._oscillator.partials
        }
        set partials(e) {
            this._oscillator.partials = e, this._setStoppedValue()
        }
        get phase() {
            return this._oscillator.phase
        }
        set phase(e) {
            this._oscillator.phase = e, this._setStoppedValue()
        }
        get units() {
            return this._units
        }
        set units(e) {
            const n = this.min,
                r = this.max;
            this._units = e, this.min = n, this.max = r
        }
        get state() {
            return this._oscillator.state
        }
        connect(e, n, r) {
            return (e instanceof at || e instanceof Ye) && (this.convert = e.convert, this.units = e.units), Nm(this, e, n, r), this
        }
        dispose() {
            return super.dispose(), this._oscillator.dispose(), this._stoppedSignal.dispose(), this._zeros.dispose(), this._scaler.dispose(), this._a2g.dispose(), this._amplitudeGain.dispose(), this.amplitude.dispose(), this
        }
    }

    function zI(t, e = 1 / 0) {
        const n = new WeakMap;
        return function(r, s) {
            Reflect.defineProperty(r, s, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    return n.get(this)
                },
                set: function(i) {
                    Cs(i, t, e), n.set(this, i)
                }
            })
        }
    }

    function Vi(t, e = 1 / 0) {
        const n = new WeakMap;
        return function(r, s) {
            Reflect.defineProperty(r, s, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    return n.get(this)
                },
                set: function(i) {
                    Cs(this.toSeconds(i), t, e), n.set(this, i)
                }
            })
        }
    }
    class Aa extends On {
        constructor() {
            super(J(Aa.getDefaults(), arguments, ["url", "onload"])), this.name = "Player", this._activeSources = new Set;
            const e = J(Aa.getDefaults(), arguments, ["url", "onload"]);
            this._buffer = new It({
                onload: this._onload.bind(this, e.onload),
                onerror: e.onerror,
                reverse: e.reverse,
                url: e.url
            }), this.autostart = e.autostart, this._loop = e.loop, this._loopStart = e.loopStart, this._loopEnd = e.loopEnd, this._playbackRate = e.playbackRate, this.fadeIn = e.fadeIn, this.fadeOut = e.fadeOut
        }
        static getDefaults() {
            return Object.assign(On.getDefaults(), {
                autostart: !1,
                fadeIn: 0,
                fadeOut: 0,
                loop: !1,
                loopEnd: 0,
                loopStart: 0,
                onload: ft,
                onerror: ft,
                playbackRate: 1,
                reverse: !1
            })
        }
        load(e) {
            return vn(this, void 0, void 0, function*() {
                return yield this._buffer.load(e), this._onload(), this
            })
        }
        _onload(e = ft) {
            e(), this.autostart && this.start()
        }
        _onSourceEnd(e) {
            this.onstop(this), this._activeSources.delete(e), this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started" && (this._state.cancel(this.now()), this._state.setStateAtTime("stopped", this.now()))
        }
        start(e, n, r) {
            return super.start(e, n, r), this
        }
        _start(e, n, r) {
            this._loop ? n = Ic(n, this._loopStart) : n = Ic(n, 0);
            const s = this.toSeconds(n),
                i = r;
            r = Ic(r, Math.max(this._buffer.duration - s, 0));
            let a = this.toSeconds(r);
            a = a / this._playbackRate, e = this.toSeconds(e);
            const c = new Js({
                url: this._buffer,
                context: this.context,
                fadeIn: this.fadeIn,
                fadeOut: this.fadeOut,
                loop: this._loop,
                loopEnd: this._loopEnd,
                loopStart: this._loopStart,
                onended: this._onSourceEnd.bind(this),
                playbackRate: this._playbackRate
            }).connect(this.output);
            !this._loop && !this._synced && (this._state.cancel(e + a), this._state.setStateAtTime("stopped", e + a, {
                implicitEnd: !0
            })), this._activeSources.add(c), this._loop && rs(i) ? c.start(e, s) : c.start(e, s, a - this.toSeconds(this.fadeOut))
        }
        _stop(e) {
            const n = this.toSeconds(e);
            this._activeSources.forEach(r => r.stop(n))
        }
        restart(e, n, r) {
            return super.restart(e, n, r), this
        }
        _restart(e, n, r) {
            this._stop(e), this._start(e, n, r)
        }
        seek(e, n) {
            const r = this.toSeconds(n);
            if (this._state.getValueAtTime(r) === "started") {
                const s = this.toSeconds(e);
                this._stop(r), this._start(r, s)
            }
            return this
        }
        setLoopPoints(e, n) {
            return this.loopStart = e, this.loopEnd = n, this
        }
        get loopStart() {
            return this._loopStart
        }
        set loopStart(e) {
            this._loopStart = e, this.buffer.loaded && Cs(this.toSeconds(e), 0, this.buffer.duration), this._activeSources.forEach(n => {
                n.loopStart = e
            })
        }
        get loopEnd() {
            return this._loopEnd
        }
        set loopEnd(e) {
            this._loopEnd = e, this.buffer.loaded && Cs(this.toSeconds(e), 0, this.buffer.duration), this._activeSources.forEach(n => {
                n.loopEnd = e
            })
        }
        get buffer() {
            return this._buffer
        }
        set buffer(e) {
            this._buffer.set(e)
        }
        get loop() {
            return this._loop
        }
        set loop(e) {
            if (this._loop !== e && (this._loop = e, this._activeSources.forEach(n => {
                    n.loop = e
                }), e)) {
                const n = this._state.getNextState("stopped", this.now());
                n && this._state.cancel(n.time)
            }
        }
        get playbackRate() {
            return this._playbackRate
        }
        set playbackRate(e) {
            this._playbackRate = e;
            const n = this.now(),
                r = this._state.getNextState("stopped", n);
            r && r.implicitEnd && (this._state.cancel(r.time), this._activeSources.forEach(s => s.cancelStop())), this._activeSources.forEach(s => {
                s.playbackRate.setValueAtTime(e, n)
            })
        }
        get reverse() {
            return this._buffer.reverse
        }
        set reverse(e) {
            this._buffer.reverse = e
        }
        get loaded() {
            return this._buffer.loaded
        }
        dispose() {
            return super.dispose(), this._activeSources.forEach(e => e.dispose()), this._activeSources.clear(), this._buffer.dispose(), this
        }
    }
    $s([Vi(0)], Aa.prototype, "fadeIn", void 0);
    $s([Vi(0)], Aa.prototype, "fadeOut", void 0);
    class xl extends Ne {
        constructor() {
            super(J(xl.getDefaults(), arguments, ["urls", "onload"], "urls")), this.name = "Players", this.input = void 0, this._players = new Map;
            const e = J(xl.getDefaults(), arguments, ["urls", "onload"], "urls");
            this._volume = this.output = new Qs({
                context: this.context,
                volume: e.volume
            }), this.volume = this._volume.volume, je(this, "volume"), this._buffers = new bh({
                urls: e.urls,
                onload: e.onload,
                baseUrl: e.baseUrl,
                onerror: e.onerror
            }), this.mute = e.mute, this._fadeIn = e.fadeIn, this._fadeOut = e.fadeOut
        }
        static getDefaults() {
            return Object.assign(On.getDefaults(), {
                baseUrl: "",
                fadeIn: 0,
                fadeOut: 0,
                mute: !1,
                onload: ft,
                onerror: ft,
                urls: {},
                volume: 0
            })
        }
        get mute() {
            return this._volume.mute
        }
        set mute(e) {
            this._volume.mute = e
        }
        get fadeIn() {
            return this._fadeIn
        }
        set fadeIn(e) {
            this._fadeIn = e, this._players.forEach(n => {
                n.fadeIn = e
            })
        }
        get fadeOut() {
            return this._fadeOut
        }
        set fadeOut(e) {
            this._fadeOut = e, this._players.forEach(n => {
                n.fadeOut = e
            })
        }
        get state() {
            return Array.from(this._players).some(([n, r]) => r.state === "started") ? "started" : "stopped"
        }
        has(e) {
            return this._buffers.has(e)
        }
        player(e) {
            if (Ke(this.has(e), `No Player with the name ${e} exists on this object`), !this._players.has(e)) {
                const n = new Aa({
                    context: this.context,
                    fadeIn: this._fadeIn,
                    fadeOut: this._fadeOut,
                    url: this._buffers.get(e)
                }).connect(this.output);
                this._players.set(e, n)
            }
            return this._players.get(e)
        }
        get loaded() {
            return this._buffers.loaded
        }
        add(e, n, r) {
            return Ke(!this._buffers.has(e), "A buffer with that name already exists on this object"), this._buffers.add(e, n, r), this
        }
        stopAll(e) {
            return this._players.forEach(n => n.stop(e)), this
        }
        dispose() {
            return super.dispose(), this._volume.dispose(), this.volume.dispose(), this._players.forEach(e => e.dispose()), this._buffers.dispose(), this
        }
    }
    class Xye extends Br {
        constructor() {
            super(...arguments), this.name = "Abs", this._abs = new Is({
                context: this.context,
                mapping: e => Math.abs(e) < .001 ? 0 : Math.abs(e)
            }), this.input = this._abs, this.output = this._abs
        }
        dispose() {
            return super.dispose(), this._abs.dispose(), this
        }
    }
    class Qye extends Br {
        constructor() {
            super(...arguments), this.name = "GainToAudio", this._norm = new Is({
                context: this.context,
                mapping: e => Math.abs(e) * 2 - 1
            }), this.input = this._norm, this.output = this._norm
        }
        dispose() {
            return super.dispose(), this._norm.dispose(), this
        }
    }
    class ZI extends Br {
        constructor() {
            super(...arguments), this.name = "Negate", this._multiply = new on({
                context: this.context,
                value: -1
            }), this.input = this._multiply, this.output = this._multiply
        }
        dispose() {
            return super.dispose(), this._multiply.dispose(), this
        }
    }
    class vu extends Ye {
        constructor() {
            super(Object.assign(J(vu.getDefaults(), arguments, ["value"]))), this.override = !1, this.name = "Subtract", this._sum = new Be({
                context: this.context
            }), this.input = this._sum, this.output = this._sum, this._neg = new ZI({
                context: this.context
            }), this.subtrahend = this._param, is(this._constantSource, this._neg, this._sum)
        }
        static getDefaults() {
            return Object.assign(Ye.getDefaults(), {
                value: 0
            })
        }
        dispose() {
            return super.dispose(), this._neg.dispose(), this._sum.dispose(), this
        }
    }
    class H0 extends Br {
        constructor() {
            super(Object.assign(J(H0.getDefaults(), arguments))), this.name = "GreaterThanZero", this._thresh = this.output = new Is({
                context: this.context,
                length: 127,
                mapping: e => e <= 0 ? 0 : 1
            }), this._scale = this.input = new on({
                context: this.context,
                value: 1e4
            }), this._scale.connect(this._thresh)
        }
        dispose() {
            return super.dispose(), this._scale.dispose(), this._thresh.dispose(), this
        }
    }
    class zd extends Ye {
        constructor() {
            super(Object.assign(J(zd.getDefaults(), arguments, ["value"]))), this.name = "GreaterThan", this.override = !1;
            const e = J(zd.getDefaults(), arguments, ["value"]);
            this._subtract = this.input = new vu({
                context: this.context,
                value: e.value
            }), this._gtz = this.output = new H0({
                context: this.context
            }), this.comparator = this._param = this._subtract.subtrahend, je(this, "comparator"), this._subtract.connect(this._gtz)
        }
        static getDefaults() {
            return Object.assign(Ye.getDefaults(), {
                value: 0
            })
        }
        dispose() {
            return super.dispose(), this._gtz.dispose(), this._subtract.dispose(), this.comparator.dispose(), this
        }
    }
    class Pl extends Br {
        constructor() {
            super(Object.assign(J(Pl.getDefaults(), arguments, ["value"]))), this.name = "Pow";
            const e = J(Pl.getDefaults(), arguments, ["value"]);
            this._exponentScaler = this.input = this.output = new Is({
                context: this.context,
                mapping: this._expFunc(e.value),
                length: 8192
            }), this._exponent = e.value
        }
        static getDefaults() {
            return Object.assign(Br.getDefaults(), {
                value: 1
            })
        }
        _expFunc(e) {
            return n => Math.pow(Math.abs(n), e)
        }
        get value() {
            return this._exponent
        }
        set value(e) {
            this._exponent = e, this._exponentScaler.setMap(this._expFunc(this._exponent))
        }
        dispose() {
            return super.dispose(), this._exponentScaler.dispose(), this
        }
    }
    class Zd extends Mi {
        constructor() {
            super(Object.assign(J(Zd.getDefaults(), arguments, ["min", "max", "exponent"]))), this.name = "ScaleExp";
            const e = J(Zd.getDefaults(), arguments, ["min", "max", "exponent"]);
            this.input = this._exp = new Pl({
                context: this.context,
                value: e.exponent
            }), this._exp.connect(this._mult)
        }
        static getDefaults() {
            return Object.assign(Mi.getDefaults(), {
                exponent: 1
            })
        }
        get exponent() {
            return this._exp.value
        }
        set exponent(e) {
            this._exp.value = e
        }
        dispose() {
            return super.dispose(), this._exp.dispose(), this
        }
    }
    class Kn extends Ne {
        constructor() {
            super(J(Kn.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "Envelope", this._sig = new Ye({
                context: this.context,
                value: 0
            }), this.output = this._sig, this.input = void 0;
            const e = J(Kn.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
            this.attack = e.attack, this.decay = e.decay, this.sustain = e.sustain, this.release = e.release, this.attackCurve = e.attackCurve, this.releaseCurve = e.releaseCurve, this.decayCurve = e.decayCurve
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                attack: .01,
                attackCurve: "linear",
                decay: .1,
                decayCurve: "exponential",
                release: 1,
                releaseCurve: "exponential",
                sustain: .5
            })
        }
        get value() {
            return this.getValueAtTime(this.now())
        }
        _getCurve(e, n) {
            if (Xs(e)) return e; {
                let r;
                for (r in Vf)
                    if (Vf[r][n] === e) return r;
                return e
            }
        }
        _setCurve(e, n, r) {
            if (Xs(r) && Reflect.has(Vf, r)) {
                const s = Vf[r];
                ya(s) ? e !== "_decayCurve" && (this[e] = s[n]) : this[e] = s
            } else if (Fr(r) && e !== "_decayCurve") this[e] = r;
            else throw new Error("Envelope: invalid curve: " + r)
        }
        get attackCurve() {
            return this._getCurve(this._attackCurve, "In")
        }
        set attackCurve(e) {
            this._setCurve("_attackCurve", "In", e)
        }
        get releaseCurve() {
            return this._getCurve(this._releaseCurve, "Out")
        }
        set releaseCurve(e) {
            this._setCurve("_releaseCurve", "Out", e)
        }
        get decayCurve() {
            return this._decayCurve
        }
        set decayCurve(e) {
            Ke(["linear", "exponential"].some(n => n === e), `Invalid envelope curve: ${e}`), this._decayCurve = e
        }
        triggerAttack(e, n = 1) {
            this.log("triggerAttack", e, n), e = this.toSeconds(e);
            let s = this.toSeconds(this.attack);
            const i = this.toSeconds(this.decay),
                a = this.getValueAtTime(e);
            if (a > 0) {
                const c = 1 / s;
                s = (1 - a) / c
            }
            if (s < this.sampleTime) this._sig.cancelScheduledValues(e), this._sig.setValueAtTime(n, e);
            else if (this._attackCurve === "linear") this._sig.linearRampTo(n, s, e);
            else if (this._attackCurve === "exponential") this._sig.targetRampTo(n, s, e);
            else {
                this._sig.cancelAndHoldAtTime(e);
                let c = this._attackCurve;
                for (let l = 1; l < c.length; l++)
                    if (c[l - 1] <= a && a <= c[l]) {
                        c = this._attackCurve.slice(l), c[0] = a;
                        break
                    } this._sig.setValueCurveAtTime(c, e, s, n)
            }
            if (i && this.sustain < 1) {
                const c = n * this.sustain,
                    l = e + s;
                this.log("decay", l), this._decayCurve === "linear" ? this._sig.linearRampToValueAtTime(c, i + l) : this._sig.exponentialApproachValueAtTime(c, l, i)
            }
            return this
        }
        triggerRelease(e) {
            this.log("triggerRelease", e), e = this.toSeconds(e);
            const n = this.getValueAtTime(e);
            if (n > 0) {
                const r = this.toSeconds(this.release);
                r < this.sampleTime ? this._sig.setValueAtTime(0, e) : this._releaseCurve === "linear" ? this._sig.linearRampTo(0, r, e) : this._releaseCurve === "exponential" ? this._sig.targetRampTo(0, r, e) : (Ke(Fr(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array"), this._sig.cancelAndHoldAtTime(e), this._sig.setValueCurveAtTime(this._releaseCurve, e, r, n))
            }
            return this
        }
        getValueAtTime(e) {
            return this._sig.getValueAtTime(e)
        }
        triggerAttackRelease(e, n, r = 1) {
            return n = this.toSeconds(n), this.triggerAttack(n, r), this.triggerRelease(n + this.toSeconds(e)), this
        }
        cancel(e) {
            return this._sig.cancelScheduledValues(this.toSeconds(e)), this
        }
        connect(e, n = 0, r = 0) {
            return Nm(this, e, n, r), this
        }
        asArray(e = 1024) {
            return vn(this, void 0, void 0, function*() {
                const n = e / this.context.sampleRate,
                    r = new Cm(1, n, this.context.sampleRate),
                    s = this.toSeconds(this.attack) + this.toSeconds(this.decay),
                    i = s + this.toSeconds(this.release),
                    a = i * .1,
                    c = i + a,
                    l = new this.constructor(Object.assign(this.get(), {
                        attack: n * this.toSeconds(this.attack) / c,
                        decay: n * this.toSeconds(this.decay) / c,
                        release: n * this.toSeconds(this.release) / c,
                        context: r
                    }));
                return l._sig.toDestination(), l.triggerAttackRelease(n * (s + a) / c, 0), (yield r.render()).getChannelData(0)
            })
        }
        dispose() {
            return super.dispose(), this._sig.dispose(), this
        }
    }
    $s([Vi(0)], Kn.prototype, "attack", void 0);
    $s([Vi(0)], Kn.prototype, "decay", void 0);
    $s([zI(0, 1)], Kn.prototype, "sustain", void 0);
    $s([Vi(0)], Kn.prototype, "release", void 0);
    const Vf = (() => {
        let e, n;
        const r = [];
        for (e = 0; e < 128; e++) r[e] = Math.sin(e / (128 - 1) * (Math.PI / 2));
        const s = [],
            i = 6.4;
        for (e = 0; e < 128 - 1; e++) {
            n = e / (128 - 1);
            const g = Math.sin(n * (Math.PI * 2) * i - Math.PI / 2) + 1;
            s[e] = g / 10 + n * .83
        }
        s[128 - 1] = 1;
        const a = [],
            c = 5;
        for (e = 0; e < 128; e++) a[e] = Math.ceil(e / (128 - 1) * c) / c;
        const l = [];
        for (e = 0; e < 128; e++) n = e / (128 - 1), l[e] = .5 * (1 - Math.cos(Math.PI * n));
        const h = [];
        for (e = 0; e < 128; e++) {
            n = e / (128 - 1);
            const g = Math.pow(n, 3) * 4 + .2,
                v = Math.cos(g * Math.PI * 2 * n);
            h[e] = Math.abs(v * (1 - n))
        }

        function d(g) {
            const v = new Array(g.length);
            for (let b = 0; b < g.length; b++) v[b] = 1 - g[b];
            return v
        }

        function p(g) {
            return g.slice(0).reverse()
        }
        return {
            bounce: {
                In: d(h),
                Out: h
            },
            cosine: {
                In: r,
                Out: p(r)
            },
            exponential: "exponential",
            linear: "linear",
            ripple: {
                In: s,
                Out: d(s)
            },
            sine: {
                In: l,
                Out: d(l)
            },
            step: {
                In: a,
                Out: d(a)
            }
        }
    })();
    let ei = class py extends Ne {
        constructor() {
            super(J(py.getDefaults(), arguments)), this._scheduledEvents = [], this._synced = !1, this._original_triggerAttack = this.triggerAttack, this._original_triggerRelease = this.triggerRelease;
            const e = J(py.getDefaults(), arguments);
            this._volume = this.output = new Qs({
                context: this.context,
                volume: e.volume
            }), this.volume = this._volume.volume, je(this, "volume")
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                volume: 0
            })
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 0)), this
        }
        _syncState() {
            let e = !1;
            return this._synced || (this._synced = !0, e = !0), e
        }
        _syncMethod(e, n) {
            const r = this["_original_" + e] = this[e];
            this[e] = (...s) => {
                const i = s[n],
                    a = this.context.transport.schedule(c => {
                        s[n] = c, r.apply(this, s)
                    }, i);
                this._scheduledEvents.push(a)
            }
        }
        unsync() {
            return this._scheduledEvents.forEach(e => this.context.transport.clear(e)), this._scheduledEvents = [], this._synced && (this._synced = !1, this.triggerAttack = this._original_triggerAttack, this.triggerRelease = this._original_triggerRelease), this
        }
        triggerAttackRelease(e, n, r, s) {
            const i = this.toSeconds(r),
                a = this.toSeconds(n);
            return this.triggerAttack(e, i, s), this.triggerRelease(i + a), this
        }
        dispose() {
            return super.dispose(), this._volume.dispose(), this.unsync(), this._scheduledEvents = [], this
        }
    };
    class Wn extends ei {
        constructor() {
            super(J(Wn.getDefaults(), arguments));
            const e = J(Wn.getDefaults(), arguments);
            this.portamento = e.portamento, this.onsilence = e.onsilence
        }
        static getDefaults() {
            return Object.assign(ei.getDefaults(), {
                detune: 0,
                onsilence: ft,
                portamento: 0
            })
        }
        triggerAttack(e, n, r = 1) {
            this.log("triggerAttack", e, n, r);
            const s = this.toSeconds(n);
            return this._triggerEnvelopeAttack(s, r), this.setNote(e, s), this
        }
        triggerRelease(e) {
            this.log("triggerRelease", e);
            const n = this.toSeconds(e);
            return this._triggerEnvelopeRelease(n), this
        }
        setNote(e, n) {
            const r = this.toSeconds(n),
                s = e instanceof Gn ? e.toFrequency() : e;
            if (this.portamento > 0 && this.getLevelAtTime(r) > .05) {
                const i = this.toSeconds(this.portamento);
                this.frequency.exponentialRampTo(s, i, r)
            } else this.frequency.setValueAtTime(s, r);
            return this
        }
    }
    $s([Vi(0)], Wn.prototype, "portamento", void 0);
    class Eh extends Kn {
        constructor() {
            super(J(Eh.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "AmplitudeEnvelope", this._gainNode = new Be({
                context: this.context,
                gain: 0
            }), this.output = this._gainNode, this.input = this._gainNode, this._sig.connect(this._gainNode.gain), this.output = this._gainNode, this.input = this._gainNode
        }
        dispose() {
            return super.dispose(), this._gainNode.dispose(), this
        }
    }
    class ti extends Wn {
        constructor() {
            super(J(ti.getDefaults(), arguments)), this.name = "Synth";
            const e = J(ti.getDefaults(), arguments);
            this.oscillator = new as(Object.assign({
                context: this.context,
                detune: e.detune,
                onstop: () => this.onsilence(this)
            }, e.oscillator)), this.frequency = this.oscillator.frequency, this.detune = this.oscillator.detune, this.envelope = new Eh(Object.assign({
                context: this.context
            }, e.envelope)), this.oscillator.chain(this.envelope, this.output), je(this, ["oscillator", "frequency", "detune", "envelope"])
        }
        static getDefaults() {
            return Object.assign(Wn.getDefaults(), {
                envelope: Object.assign(tr(Kn.getDefaults(), Object.keys(Ne.getDefaults())), {
                    attack: .005,
                    decay: .1,
                    release: 1,
                    sustain: .3
                }),
                oscillator: Object.assign(tr(as.getDefaults(), [...Object.keys(On.getDefaults()), "frequency", "detune"]), {
                    type: "triangle"
                })
            })
        }
        _triggerEnvelopeAttack(e, n) {
            if (this.envelope.triggerAttack(e, n), this.oscillator.start(e), this.envelope.sustain === 0) {
                const r = this.toSeconds(this.envelope.attack),
                    s = this.toSeconds(this.envelope.decay);
                this.oscillator.stop(e + r + s)
            }
        }
        _triggerEnvelopeRelease(e) {
            this.envelope.triggerRelease(e), this.oscillator.stop(e + this.toSeconds(this.envelope.release))
        }
        getLevelAtTime(e) {
            return e = this.toSeconds(e), this.envelope.getValueAtTime(e)
        }
        dispose() {
            return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this
        }
    }
    class Wc extends Wn {
        constructor() {
            super(J(Wc.getDefaults(), arguments)), this.name = "ModulationSynth";
            const e = J(Wc.getDefaults(), arguments);
            this._carrier = new ti({
                context: this.context,
                oscillator: e.oscillator,
                envelope: e.envelope,
                onsilence: () => this.onsilence(this),
                volume: -10
            }), this._modulator = new ti({
                context: this.context,
                oscillator: e.modulation,
                envelope: e.modulationEnvelope,
                volume: -10
            }), this.oscillator = this._carrier.oscillator, this.envelope = this._carrier.envelope, this.modulation = this._modulator.oscillator, this.modulationEnvelope = this._modulator.envelope, this.frequency = new Ye({
                context: this.context,
                units: "frequency"
            }), this.detune = new Ye({
                context: this.context,
                value: e.detune,
                units: "cents"
            }), this.harmonicity = new on({
                context: this.context,
                value: e.harmonicity,
                minValue: 0
            }), this._modulationNode = new Be({
                context: this.context,
                gain: 0
            }), je(this, ["frequency", "harmonicity", "oscillator", "envelope", "modulation", "modulationEnvelope", "detune"])
        }
        static getDefaults() {
            return Object.assign(Wn.getDefaults(), {
                harmonicity: 3,
                oscillator: Object.assign(tr(as.getDefaults(), [...Object.keys(On.getDefaults()), "frequency", "detune"]), {
                    type: "sine"
                }),
                envelope: Object.assign(tr(Kn.getDefaults(), Object.keys(Ne.getDefaults())), {
                    attack: .01,
                    decay: .01,
                    sustain: 1,
                    release: .5
                }),
                modulation: Object.assign(tr(as.getDefaults(), [...Object.keys(On.getDefaults()), "frequency", "detune"]), {
                    type: "square"
                }),
                modulationEnvelope: Object.assign(tr(Kn.getDefaults(), Object.keys(Ne.getDefaults())), {
                    attack: .5,
                    decay: 0,
                    sustain: 1,
                    release: .5
                })
            })
        }
        _triggerEnvelopeAttack(e, n) {
            this._carrier._triggerEnvelopeAttack(e, n), this._modulator._triggerEnvelopeAttack(e, n)
        }
        _triggerEnvelopeRelease(e) {
            return this._carrier._triggerEnvelopeRelease(e), this._modulator._triggerEnvelopeRelease(e), this
        }
        getLevelAtTime(e) {
            return e = this.toSeconds(e), this.envelope.getValueAtTime(e)
        }
        dispose() {
            return super.dispose(), this._carrier.dispose(), this._modulator.dispose(), this.frequency.dispose(), this.detune.dispose(), this.harmonicity.dispose(), this._modulationNode.dispose(), this
        }
    }
    class xm extends Wc {
        constructor() {
            super(J(xm.getDefaults(), arguments)), this.name = "AMSynth", this._modulationScale = new G0({
                context: this.context
            }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.detune.fan(this._carrier.detune, this._modulator.detune), this._modulator.chain(this._modulationScale, this._modulationNode.gain), this._carrier.chain(this._modulationNode, this.output)
        }
        dispose() {
            return super.dispose(), this._modulationScale.dispose(), this
        }
    }
    class Rl extends Ne {
        constructor() {
            super(J(Rl.getDefaults(), arguments, ["frequency", "type"])), this.name = "BiquadFilter";
            const e = J(Rl.getDefaults(), arguments, ["frequency", "type"]);
            this._filter = this.context.createBiquadFilter(), this.input = this.output = this._filter, this.Q = new at({
                context: this.context,
                units: "number",
                value: e.Q,
                param: this._filter.Q
            }), this.frequency = new at({
                context: this.context,
                units: "frequency",
                value: e.frequency,
                param: this._filter.frequency
            }), this.detune = new at({
                context: this.context,
                units: "cents",
                value: e.detune,
                param: this._filter.detune
            }), this.gain = new at({
                context: this.context,
                units: "decibels",
                convert: !1,
                value: e.gain,
                param: this._filter.gain
            }), this.type = e.type
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                Q: 1,
                type: "lowpass",
                frequency: 350,
                detune: 0,
                gain: 0
            })
        }
        get type() {
            return this._filter.type
        }
        set type(e) {
            Ke(["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass", "peaking"].indexOf(e) !== -1, `Invalid filter type: ${e}`), this._filter.type = e
        }
        getFrequencyResponse(e = 128) {
            const n = new Float32Array(e);
            for (let a = 0; a < e; a++) {
                const l = Math.pow(a / e, 2) * (2e4 - 20) + 20;
                n[a] = l
            }
            const r = new Float32Array(e),
                s = new Float32Array(e),
                i = this.context.createBiquadFilter();
            return i.type = this.type, i.Q.value = this.Q.value, i.frequency.value = this.frequency.value, i.gain.value = this.gain.value, i.getFrequencyResponse(n, r, s), r
        }
        dispose() {
            return super.dispose(), this._filter.disconnect(), this.Q.dispose(), this.frequency.dispose(), this.gain.dispose(), this.detune.dispose(), this
        }
    }
    class wr extends Ne {
        constructor() {
            super(J(wr.getDefaults(), arguments, ["frequency", "type", "rolloff"])), this.name = "Filter", this.input = new Be({
                context: this.context
            }), this.output = new Be({
                context: this.context
            }), this._filters = [];
            const e = J(wr.getDefaults(), arguments, ["frequency", "type", "rolloff"]);
            this._filters = [], this.Q = new Ye({
                context: this.context,
                units: "positive",
                value: e.Q
            }), this.frequency = new Ye({
                context: this.context,
                units: "frequency",
                value: e.frequency
            }), this.detune = new Ye({
                context: this.context,
                units: "cents",
                value: e.detune
            }), this.gain = new Ye({
                context: this.context,
                units: "decibels",
                convert: !1,
                value: e.gain
            }), this._type = e.type, this.rolloff = e.rolloff, je(this, ["detune", "frequency", "gain", "Q"])
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                Q: 1,
                detune: 0,
                frequency: 350,
                gain: 0,
                rolloff: -12,
                type: "lowpass"
            })
        }
        get type() {
            return this._type
        }
        set type(e) {
            Ke(["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass", "peaking"].indexOf(e) !== -1, `Invalid filter type: ${e}`), this._type = e, this._filters.forEach(r => r.type = e)
        }
        get rolloff() {
            return this._rolloff
        }
        set rolloff(e) {
            const n = Ri(e) ? e : parseInt(e, 10),
                r = [-12, -24, -48, -96];
            let s = r.indexOf(n);
            Ke(s !== -1, `rolloff can only be ${r.join(", ")}`), s += 1, this._rolloff = n, this.input.disconnect(), this._filters.forEach(i => i.disconnect()), this._filters = new Array(s);
            for (let i = 0; i < s; i++) {
                const a = new Rl({
                    context: this.context
                });
                a.type = this._type, this.frequency.connect(a.frequency), this.detune.connect(a.detune), this.Q.connect(a.Q), this.gain.connect(a.gain), this._filters[i] = a
            }
            this._internalChannels = this._filters, is(this.input, ...this._internalChannels, this.output)
        }
        getFrequencyResponse(e = 128) {
            const n = new Rl({
                    frequency: this.frequency.value,
                    gain: this.gain.value,
                    Q: this.Q.value,
                    type: this._type,
                    detune: this.detune.value
                }),
                r = new Float32Array(e).map(() => 1);
            return this._filters.forEach(() => {
                n.getFrequencyResponse(e).forEach((i, a) => r[a] *= i)
            }), n.dispose(), r
        }
        dispose() {
            return super.dispose(), this._filters.forEach(e => {
                e.dispose()
            }), vh(this, ["detune", "frequency", "gain", "Q"]), this.frequency.dispose(), this.Q.dispose(), this.detune.dispose(), this.gain.dispose(), this
        }
    }
    class Ml extends Kn {
        constructor() {
            super(J(Ml.getDefaults(), arguments, ["attack", "decay", "sustain", "release"])), this.name = "FrequencyEnvelope";
            const e = J(Ml.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
            this._octaves = e.octaves, this._baseFrequency = this.toFrequency(e.baseFrequency), this._exponent = this.input = new Pl({
                context: this.context,
                value: e.exponent
            }), this._scale = this.output = new Mi({
                context: this.context,
                min: this._baseFrequency,
                max: this._baseFrequency * Math.pow(2, this._octaves)
            }), this._sig.chain(this._exponent, this._scale)
        }
        static getDefaults() {
            return Object.assign(Kn.getDefaults(), {
                baseFrequency: 200,
                exponent: 1,
                octaves: 4
            })
        }
        get baseFrequency() {
            return this._baseFrequency
        }
        set baseFrequency(e) {
            const n = this.toFrequency(e);
            Cs(n, 0), this._baseFrequency = n, this._scale.min = this._baseFrequency, this.octaves = this._octaves
        }
        get octaves() {
            return this._octaves
        }
        set octaves(e) {
            this._octaves = e, this._scale.max = this._baseFrequency * Math.pow(2, e)
        }
        get exponent() {
            return this._exponent.value
        }
        set exponent(e) {
            this._exponent.value = e
        }
        dispose() {
            return super.dispose(), this._exponent.dispose(), this._scale.dispose(), this
        }
    }
    class Ci extends Wn {
        constructor() {
            super(J(Ci.getDefaults(), arguments)), this.name = "MonoSynth";
            const e = J(Ci.getDefaults(), arguments);
            this.oscillator = new as(Object.assign(e.oscillator, {
                context: this.context,
                detune: e.detune,
                onstop: () => this.onsilence(this)
            })), this.frequency = this.oscillator.frequency, this.detune = this.oscillator.detune, this.filter = new wr(Object.assign(e.filter, {
                context: this.context
            })), this.filterEnvelope = new Ml(Object.assign(e.filterEnvelope, {
                context: this.context
            })), this.envelope = new Eh(Object.assign(e.envelope, {
                context: this.context
            })), this.oscillator.chain(this.filter, this.envelope, this.output), this.filterEnvelope.connect(this.filter.frequency), je(this, ["oscillator", "frequency", "detune", "filter", "filterEnvelope", "envelope"])
        }
        static getDefaults() {
            return Object.assign(Wn.getDefaults(), {
                envelope: Object.assign(tr(Kn.getDefaults(), Object.keys(Ne.getDefaults())), {
                    attack: .005,
                    decay: .1,
                    release: 1,
                    sustain: .9
                }),
                filter: Object.assign(tr(wr.getDefaults(), Object.keys(Ne.getDefaults())), {
                    Q: 1,
                    rolloff: -12,
                    type: "lowpass"
                }),
                filterEnvelope: Object.assign(tr(Ml.getDefaults(), Object.keys(Ne.getDefaults())), {
                    attack: .6,
                    baseFrequency: 200,
                    decay: .2,
                    exponent: 2,
                    octaves: 3,
                    release: 2,
                    sustain: .5
                }),
                oscillator: Object.assign(tr(as.getDefaults(), Object.keys(On.getDefaults())), {
                    type: "sawtooth"
                })
            })
        }
        _triggerEnvelopeAttack(e, n = 1) {
            if (this.envelope.triggerAttack(e, n), this.filterEnvelope.triggerAttack(e), this.oscillator.start(e), this.envelope.sustain === 0) {
                const r = this.toSeconds(this.envelope.attack),
                    s = this.toSeconds(this.envelope.decay);
                this.oscillator.stop(e + r + s)
            }
        }
        _triggerEnvelopeRelease(e) {
            this.envelope.triggerRelease(e), this.filterEnvelope.triggerRelease(e), this.oscillator.stop(e + this.toSeconds(this.envelope.release))
        }
        getLevelAtTime(e) {
            return e = this.toSeconds(e), this.envelope.getValueAtTime(e)
        }
        dispose() {
            return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this.filterEnvelope.dispose(), this.filter.dispose(), this
        }
    }
    class Xd extends Wn {
        constructor() {
            super(J(Xd.getDefaults(), arguments)), this.name = "DuoSynth";
            const e = J(Xd.getDefaults(), arguments);
            this.voice0 = new Ci(Object.assign(e.voice0, {
                context: this.context,
                onsilence: () => this.onsilence(this)
            })), this.voice1 = new Ci(Object.assign(e.voice1, {
                context: this.context
            })), this.harmonicity = new on({
                context: this.context,
                units: "positive",
                value: e.harmonicity
            }), this._vibrato = new dr({
                frequency: e.vibratoRate,
                context: this.context,
                min: -50,
                max: 50
            }), this._vibrato.start(), this.vibratoRate = this._vibrato.frequency, this._vibratoGain = new Be({
                context: this.context,
                units: "normalRange",
                gain: e.vibratoAmount
            }), this.vibratoAmount = this._vibratoGain.gain, this.frequency = new Ye({
                context: this.context,
                units: "frequency",
                value: 440
            }), this.detune = new Ye({
                context: this.context,
                units: "cents",
                value: e.detune
            }), this.frequency.connect(this.voice0.frequency), this.frequency.chain(this.harmonicity, this.voice1.frequency), this._vibrato.connect(this._vibratoGain), this._vibratoGain.fan(this.voice0.detune, this.voice1.detune), this.detune.fan(this.voice0.detune, this.voice1.detune), this.voice0.connect(this.output), this.voice1.connect(this.output), je(this, ["voice0", "voice1", "frequency", "vibratoAmount", "vibratoRate"])
        }
        getLevelAtTime(e) {
            return e = this.toSeconds(e), this.voice0.envelope.getValueAtTime(e) + this.voice1.envelope.getValueAtTime(e)
        }
        static getDefaults() {
            return ss(Wn.getDefaults(), {
                vibratoAmount: .5,
                vibratoRate: 5,
                harmonicity: 1.5,
                voice0: ss(tr(Ci.getDefaults(), Object.keys(Wn.getDefaults())), {
                    filterEnvelope: {
                        attack: .01,
                        decay: 0,
                        sustain: 1,
                        release: .5
                    },
                    envelope: {
                        attack: .01,
                        decay: 0,
                        sustain: 1,
                        release: .5
                    }
                }),
                voice1: ss(tr(Ci.getDefaults(), Object.keys(Wn.getDefaults())), {
                    filterEnvelope: {
                        attack: .01,
                        decay: 0,
                        sustain: 1,
                        release: .5
                    },
                    envelope: {
                        attack: .01,
                        decay: 0,
                        sustain: 1,
                        release: .5
                    }
                })
            })
        }
        _triggerEnvelopeAttack(e, n) {
            this.voice0._triggerEnvelopeAttack(e, n), this.voice1._triggerEnvelopeAttack(e, n)
        }
        _triggerEnvelopeRelease(e) {
            return this.voice0._triggerEnvelopeRelease(e), this.voice1._triggerEnvelopeRelease(e), this
        }
        dispose() {
            return super.dispose(), this.voice0.dispose(), this.voice1.dispose(), this.frequency.dispose(), this.detune.dispose(), this._vibrato.dispose(), this.vibratoRate.dispose(), this._vibratoGain.dispose(), this.harmonicity.dispose(), this
        }
    }
    class Dl extends Wc {
        constructor() {
            super(J(Dl.getDefaults(), arguments)), this.name = "FMSynth";
            const e = J(Dl.getDefaults(), arguments);
            this.modulationIndex = new on({
                context: this.context,
                value: e.modulationIndex
            }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.frequency.chain(this.modulationIndex, this._modulationNode), this.detune.fan(this._carrier.detune, this._modulator.detune), this._modulator.connect(this._modulationNode.gain), this._modulationNode.connect(this._carrier.frequency), this._carrier.connect(this.output)
        }
        static getDefaults() {
            return Object.assign(Wc.getDefaults(), {
                modulationIndex: 10
            })
        }
        dispose() {
            return super.dispose(), this.modulationIndex.dispose(), this
        }
    }
    const H3 = [1, 1.483, 1.932, 2.546, 2.63, 3.897];
    class Qd extends Wn {
        constructor() {
            super(J(Qd.getDefaults(), arguments)), this.name = "MetalSynth", this._oscillators = [], this._freqMultipliers = [];
            const e = J(Qd.getDefaults(), arguments);
            this.detune = new Ye({
                context: this.context,
                units: "cents",
                value: e.detune
            }), this.frequency = new Ye({
                context: this.context,
                units: "frequency"
            }), this._amplitude = new Be({
                context: this.context,
                gain: 0
            }).connect(this.output), this._highpass = new wr({
                Q: 0,
                context: this.context,
                type: "highpass"
            }).connect(this._amplitude);
            for (let n = 0; n < H3.length; n++) {
                const r = new jc({
                    context: this.context,
                    harmonicity: e.harmonicity,
                    modulationIndex: e.modulationIndex,
                    modulationType: "square",
                    onstop: n === 0 ? () => this.onsilence(this) : ft,
                    type: "square"
                });
                r.connect(this._highpass), this._oscillators[n] = r;
                const s = new on({
                    context: this.context,
                    value: H3[n]
                });
                this._freqMultipliers[n] = s, this.frequency.chain(s, r.frequency), this.detune.connect(r.detune)
            }
            this._filterFreqScaler = new Mi({
                context: this.context,
                max: 7e3,
                min: this.toFrequency(e.resonance)
            }), this.envelope = new Kn({
                attack: e.envelope.attack,
                attackCurve: "linear",
                context: this.context,
                decay: e.envelope.decay,
                release: e.envelope.release,
                sustain: 0
            }), this.envelope.chain(this._filterFreqScaler, this._highpass.frequency), this.envelope.connect(this._amplitude.gain), this._octaves = e.octaves, this.octaves = e.octaves
        }
        static getDefaults() {
            return ss(Wn.getDefaults(), {
                envelope: Object.assign(tr(Kn.getDefaults(), Object.keys(Ne.getDefaults())), {
                    attack: .001,
                    decay: 1.4,
                    release: .2
                }),
                harmonicity: 5.1,
                modulationIndex: 32,
                octaves: 1.5,
                resonance: 4e3
            })
        }
        _triggerEnvelopeAttack(e, n = 1) {
            return this.envelope.triggerAttack(e, n), this._oscillators.forEach(r => r.start(e)), this.envelope.sustain === 0 && this._oscillators.forEach(r => {
                r.stop(e + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay))
            }), this
        }
        _triggerEnvelopeRelease(e) {
            return this.envelope.triggerRelease(e), this._oscillators.forEach(n => n.stop(e + this.toSeconds(this.envelope.release))), this
        }
        getLevelAtTime(e) {
            return e = this.toSeconds(e), this.envelope.getValueAtTime(e)
        }
        get modulationIndex() {
            return this._oscillators[0].modulationIndex.value
        }
        set modulationIndex(e) {
            this._oscillators.forEach(n => n.modulationIndex.value = e)
        }
        get harmonicity() {
            return this._oscillators[0].harmonicity.value
        }
        set harmonicity(e) {
            this._oscillators.forEach(n => n.harmonicity.value = e)
        }
        get resonance() {
            return this._filterFreqScaler.min
        }
        set resonance(e) {
            this._filterFreqScaler.min = this.toFrequency(e), this.octaves = this._octaves
        }
        get octaves() {
            return this._octaves
        }
        set octaves(e) {
            this._octaves = e, this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, e)
        }
        dispose() {
            return super.dispose(), this._oscillators.forEach(e => e.dispose()), this._freqMultipliers.forEach(e => e.dispose()), this.frequency.dispose(), this.detune.dispose(), this._filterFreqScaler.dispose(), this._amplitude.dispose(), this.envelope.dispose(), this._highpass.dispose(), this
        }
    }
    class Hc extends ti {
        constructor() {
            super(J(Hc.getDefaults(), arguments)), this.name = "MembraneSynth", this.portamento = 0;
            const e = J(Hc.getDefaults(), arguments);
            this.pitchDecay = e.pitchDecay, this.octaves = e.octaves, je(this, ["oscillator", "envelope"])
        }
        static getDefaults() {
            return ss(Wn.getDefaults(), ti.getDefaults(), {
                envelope: {
                    attack: .001,
                    attackCurve: "exponential",
                    decay: .4,
                    release: 1.4,
                    sustain: .01
                },
                octaves: 10,
                oscillator: {
                    type: "sine"
                },
                pitchDecay: .05
            })
        }
        setNote(e, n) {
            const r = this.toSeconds(n),
                s = this.toFrequency(e instanceof Gn ? e.toFrequency() : e),
                i = s * this.octaves;
            return this.oscillator.frequency.setValueAtTime(i, r), this.oscillator.frequency.exponentialRampToValueAtTime(s, r + this.toSeconds(this.pitchDecay)), this
        }
        dispose() {
            return super.dispose(), this
        }
    }
    $s([zI(0)], Hc.prototype, "octaves", void 0);
    $s([Vi(0)], Hc.prototype, "pitchDecay", void 0);
    class Jd extends ei {
        constructor() {
            super(J(Jd.getDefaults(), arguments)), this.name = "NoiseSynth";
            const e = J(Jd.getDefaults(), arguments);
            this.noise = new Co(Object.assign({
                context: this.context
            }, e.noise)), this.envelope = new Eh(Object.assign({
                context: this.context
            }, e.envelope)), this.noise.chain(this.envelope, this.output)
        }
        static getDefaults() {
            return Object.assign(ei.getDefaults(), {
                envelope: Object.assign(tr(Kn.getDefaults(), Object.keys(Ne.getDefaults())), {
                    decay: .1,
                    sustain: 0
                }),
                noise: Object.assign(tr(Co.getDefaults(), Object.keys(On.getDefaults())), {
                    type: "white"
                })
            })
        }
        triggerAttack(e, n = 1) {
            return e = this.toSeconds(e), this.envelope.triggerAttack(e, n), this.noise.start(e), this.envelope.sustain === 0 && this.noise.stop(e + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay)), this
        }
        triggerRelease(e) {
            return e = this.toSeconds(e), this.envelope.triggerRelease(e), this.noise.stop(e + this.toSeconds(this.envelope.release)), this
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 0), this._syncMethod("triggerRelease", 0)), this
        }
        triggerAttackRelease(e, n, r = 1) {
            return n = this.toSeconds(n), e = this.toSeconds(e), this.triggerAttack(n, r), this.triggerRelease(n + e), this
        }
        dispose() {
            return super.dispose(), this.noise.dispose(), this.envelope.dispose(), this
        }
    }
    const K0 = new Set;

    function Y0(t) {
        K0.add(t)
    }

    function XI(t, e) {
        const n = `registerProcessor("${t}", ${e})`;
        K0.add(n)
    }

    function Jye() {
        return Array.from(K0).join(`
`)
    }
    class my extends Ne {
        constructor(e) {
            super(e), this.name = "ToneAudioWorklet", this.workletOptions = {}, this.onprocessorerror = ft;
            const n = URL.createObjectURL(new Blob([Jye()], {
                    type: "text/javascript"
                })),
                r = this._audioWorkletName();
            this._dummyGain = this.context.createGain(), this._dummyParam = this._dummyGain.gain, this.context.addAudioWorkletModule(n, r).then(() => {
                this.disposed || (this._worklet = this.context.createAudioWorkletNode(r, this.workletOptions), this._worklet.onprocessorerror = this.onprocessorerror.bind(this), this.onReady(this._worklet))
            })
        }
        dispose() {
            return super.dispose(), this._dummyGain.disconnect(), this._worklet && (this._worklet.port.postMessage("dispose"), this._worklet.disconnect()), this
        }
    }
    const eve = `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`;
    Y0(eve);
    const tve = `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;
    Y0(tve);
    const nve = `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`;
    Y0(nve);
    const QI = "feedback-comb-filter",
        rve = `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`;
    XI(QI, rve);
    class $l extends my {
        constructor() {
            super(J($l.getDefaults(), arguments, ["delayTime", "resonance"])), this.name = "FeedbackCombFilter";
            const e = J($l.getDefaults(), arguments, ["delayTime", "resonance"]);
            this.input = new Be({
                context: this.context
            }), this.output = new Be({
                context: this.context
            }), this.delayTime = new at({
                context: this.context,
                value: e.delayTime,
                units: "time",
                minValue: 0,
                maxValue: 1,
                param: this._dummyParam,
                swappable: !0
            }), this.resonance = new at({
                context: this.context,
                value: e.resonance,
                units: "normalRange",
                param: this._dummyParam,
                swappable: !0
            }), je(this, ["resonance", "delayTime"])
        }
        _audioWorkletName() {
            return QI
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                delayTime: .1,
                resonance: .5
            })
        }
        onReady(e) {
            is(this.input, e, this.output);
            const n = e.parameters.get("delayTime");
            this.delayTime.setParam(n);
            const r = e.parameters.get("feedback");
            this.resonance.setParam(r)
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this.output.dispose(), this.delayTime.dispose(), this.resonance.dispose(), this
        }
    }
    class Ll extends Ne {
        constructor() {
            super(J(Ll.getDefaults(), arguments, ["frequency", "type"])), this.name = "OnePoleFilter";
            const e = J(Ll.getDefaults(), arguments, ["frequency", "type"]);
            this._frequency = e.frequency, this._type = e.type, this.input = new Be({
                context: this.context
            }), this.output = new Be({
                context: this.context
            }), this._createFilter()
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                frequency: 880,
                type: "lowpass"
            })
        }
        _createFilter() {
            const e = this._filter,
                n = this.toFrequency(this._frequency),
                r = 1 / (2 * Math.PI * n);
            if (this._type === "lowpass") {
                const s = 1 / (r * this.context.sampleRate),
                    i = s - 1;
                this._filter = this.context.createIIRFilter([s, 0], [1, i])
            } else {
                const s = 1 / (r * this.context.sampleRate) - 1;
                this._filter = this.context.createIIRFilter([1, -1], [1, s])
            }
            this.input.chain(this._filter, this.output), e && this.context.setTimeout(() => {
                this.disposed || (this.input.disconnect(e), e.disconnect())
            }, this.blockTime)
        }
        get frequency() {
            return this._frequency
        }
        set frequency(e) {
            this._frequency = e, this._createFilter()
        }
        get type() {
            return this._type
        }
        set type(e) {
            this._type = e, this._createFilter()
        }
        getFrequencyResponse(e = 128) {
            const n = new Float32Array(e);
            for (let i = 0; i < e; i++) {
                const c = Math.pow(i / e, 2) * (2e4 - 20) + 20;
                n[i] = c
            }
            const r = new Float32Array(e),
                s = new Float32Array(e);
            return this._filter.getFrequencyResponse(n, r, s), r
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this.output.dispose(), this._filter.disconnect(), this
        }
    }
    class Fl extends Ne {
        constructor() {
            super(J(Fl.getDefaults(), arguments, ["delayTime", "resonance", "dampening"])), this.name = "LowpassCombFilter";
            const e = J(Fl.getDefaults(), arguments, ["delayTime", "resonance", "dampening"]);
            this._combFilter = this.output = new $l({
                context: this.context,
                delayTime: e.delayTime,
                resonance: e.resonance
            }), this.delayTime = this._combFilter.delayTime, this.resonance = this._combFilter.resonance, this._lowpass = this.input = new Ll({
                context: this.context,
                frequency: e.dampening,
                type: "lowpass"
            }), this._lowpass.connect(this._combFilter)
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                dampening: 3e3,
                delayTime: .1,
                resonance: .5
            })
        }
        get dampening() {
            return this._lowpass.frequency
        }
        set dampening(e) {
            this._lowpass.frequency = e
        }
        dispose() {
            return super.dispose(), this._combFilter.dispose(), this._lowpass.dispose(), this
        }
    }
    class ep extends ei {
        constructor() {
            super(J(ep.getDefaults(), arguments)), this.name = "PluckSynth";
            const e = J(ep.getDefaults(), arguments);
            this._noise = new Co({
                context: this.context,
                type: "pink"
            }), this.attackNoise = e.attackNoise, this._lfcf = new Fl({
                context: this.context,
                dampening: e.dampening,
                resonance: e.resonance
            }), this.resonance = e.resonance, this.release = e.release, this._noise.connect(this._lfcf), this._lfcf.connect(this.output)
        }
        static getDefaults() {
            return ss(ei.getDefaults(), {
                attackNoise: 1,
                dampening: 4e3,
                resonance: .7,
                release: 1
            })
        }
        get dampening() {
            return this._lfcf.dampening
        }
        set dampening(e) {
            this._lfcf.dampening = e
        }
        triggerAttack(e, n) {
            const r = this.toFrequency(e);
            n = this.toSeconds(n);
            const s = 1 / r;
            return this._lfcf.delayTime.setValueAtTime(s, n), this._noise.start(n), this._noise.stop(n + s * this.attackNoise), this._lfcf.resonance.cancelScheduledValues(n), this._lfcf.resonance.setValueAtTime(this.resonance, n), this
        }
        triggerRelease(e) {
            return this._lfcf.resonance.linearRampTo(0, this.release, e), this
        }
        dispose() {
            return super.dispose(), this._noise.dispose(), this._lfcf.dispose(), this
        }
    }
    class fa extends ei {
        constructor() {
            super(J(fa.getDefaults(), arguments, ["voice", "options"])), this.name = "PolySynth", this._availableVoices = [], this._activeVoices = [], this._voices = [], this._gcTimeout = -1, this._averageActiveVoices = 0;
            const e = J(fa.getDefaults(), arguments, ["voice", "options"]);
            Ke(!Ri(e.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
            const n = e.voice.getDefaults();
            this.options = Object.assign(n, e.options), this.voice = e.voice, this.maxPolyphony = e.maxPolyphony, this._dummyVoice = this._getNextAvailableVoice();
            const r = this._voices.indexOf(this._dummyVoice);
            this._voices.splice(r, 1), this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1)
        }
        static getDefaults() {
            return Object.assign(ei.getDefaults(), {
                maxPolyphony: 32,
                options: {},
                voice: ti
            })
        }
        get activeVoices() {
            return this._activeVoices.length
        }
        _makeVoiceAvailable(e) {
            this._availableVoices.push(e);
            const n = this._activeVoices.findIndex(r => r.voice === e);
            this._activeVoices.splice(n, 1)
        }
        _getNextAvailableVoice() {
            if (this._availableVoices.length) return this._availableVoices.shift();
            if (this._voices.length < this.maxPolyphony) {
                const e = new this.voice(Object.assign(this.options, {
                    context: this.context,
                    onsilence: this._makeVoiceAvailable.bind(this)
                }));
                return e.connect(this.output), this._voices.push(e), e
            } else F0("Max polyphony exceeded. Note dropped.")
        }
        _collectGarbage() {
            if (this._averageActiveVoices = Math.max(this._averageActiveVoices * .95, this.activeVoices), this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
                const e = this._availableVoices.shift(),
                    n = this._voices.indexOf(e);
                this._voices.splice(n, 1), this.context.isOffline || e.dispose()
            }
        }
        _triggerAttack(e, n, r) {
            e.forEach(s => {
                const i = new Kd(this.context, s).toMidi(),
                    a = this._getNextAvailableVoice();
                a && (a.triggerAttack(s, n, r), this._activeVoices.push({
                    midi: i,
                    voice: a,
                    released: !1
                }), this.log("triggerAttack", s, n))
            })
        }
        _triggerRelease(e, n) {
            e.forEach(r => {
                const s = new Kd(this.context, r).toMidi(),
                    i = this._activeVoices.find(({
                        midi: a,
                        released: c
                    }) => a === s && !c);
                i && (i.voice.triggerRelease(n), i.released = !0, this.log("triggerRelease", r, n))
            })
        }
        _scheduleEvent(e, n, r, s) {
            Ke(!this.disposed, "Synth was already disposed"), r <= this.now() ? e === "attack" ? this._triggerAttack(n, r, s) : this._triggerRelease(n, r) : this.context.setTimeout(() => {
                this._scheduleEvent(e, n, r, s)
            }, r - this.now())
        }
        triggerAttack(e, n, r) {
            Array.isArray(e) || (e = [e]);
            const s = this.toSeconds(n);
            return this._scheduleEvent("attack", e, s, r), this
        }
        triggerRelease(e, n) {
            Array.isArray(e) || (e = [e]);
            const r = this.toSeconds(n);
            return this._scheduleEvent("release", e, r), this
        }
        triggerAttackRelease(e, n, r, s) {
            const i = this.toSeconds(r);
            if (this.triggerAttack(e, i, s), Fr(n)) {
                Ke(Fr(e), "If the duration is an array, the notes must also be an array"), e = e;
                for (let a = 0; a < e.length; a++) {
                    const c = n[Math.min(a, n.length - 1)],
                        l = this.toSeconds(c);
                    Ke(l > 0, "The duration must be greater than 0"), this.triggerRelease(e[a], i + l)
                }
            } else {
                const a = this.toSeconds(n);
                Ke(a > 0, "The duration must be greater than 0"), this.triggerRelease(e, i + a)
            }
            return this
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
        }
        set(e) {
            const n = tr(e, ["onsilence", "context"]);
            return this.options = ss(this.options, n), this._voices.forEach(r => r.set(n)), this._dummyVoice.set(n), this
        }
        get() {
            return this._dummyVoice.get()
        }
        releaseAll(e) {
            const n = this.toSeconds(e);
            return this._activeVoices.forEach(({
                voice: r
            }) => {
                r.triggerRelease(n)
            }), this
        }
        dispose() {
            return super.dispose(), this._dummyVoice.dispose(), this._voices.forEach(e => e.dispose()), this._activeVoices = [], this._availableVoices = [], this.context.clearInterval(this._gcTimeout), this
        }
    }
    class Kc extends ei {
        constructor() {
            super(J(Kc.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "Sampler", this._activeSources = new Map;
            const e = J(Kc.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls"),
                n = {};
            Object.keys(e.urls).forEach(r => {
                const s = parseInt(r, 10);
                if (Ke(qf(r) || Ri(s) && isFinite(s), `url key is neither a note or midi pitch: ${r}`), qf(r)) {
                    const i = new Gn(this.context, r).toMidi();
                    n[i] = e.urls[r]
                } else Ri(s) && isFinite(s) && (n[s] = e.urls[s])
            }), this._buffers = new bh({
                urls: n,
                onload: e.onload,
                baseUrl: e.baseUrl,
                onerror: e.onerror
            }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this._buffers.loaded && Promise.resolve().then(e.onload)
        }
        static getDefaults() {
            return Object.assign(ei.getDefaults(), {
                attack: 0,
                baseUrl: "",
                curve: "exponential",
                onload: ft,
                onerror: ft,
                release: .1,
                urls: {}
            })
        }
        _findClosest(e) {
            let r = 0;
            for (; r < 96;) {
                if (this._buffers.has(e + r)) return -r;
                if (this._buffers.has(e - r)) return r;
                r++
            }
            throw new Error(`No available buffers for note: ${e}`)
        }
        triggerAttack(e, n, r = 1) {
            return this.log("triggerAttack", e, n, r), Array.isArray(e) || (e = [e]), e.forEach(s => {
                const i = km(new Gn(this.context, s).toFrequency()),
                    a = Math.round(i),
                    c = i - a,
                    l = this._findClosest(a),
                    h = a - l,
                    d = this._buffers.get(h),
                    p = Oa(l + c),
                    g = new Js({
                        url: d,
                        context: this.context,
                        curve: this.curve,
                        fadeIn: this.attack,
                        fadeOut: this.release,
                        playbackRate: p
                    }).connect(this.output);
                g.start(n, 0, d.duration / p, r), Fr(this._activeSources.get(a)) || this._activeSources.set(a, []), this._activeSources.get(a).push(g), g.onended = () => {
                    if (this._activeSources && this._activeSources.has(a)) {
                        const v = this._activeSources.get(a),
                            b = v.indexOf(g);
                        b !== -1 && v.splice(b, 1)
                    }
                }
            }), this
        }
        triggerRelease(e, n) {
            return this.log("triggerRelease", e, n), Array.isArray(e) || (e = [e]), e.forEach(r => {
                const s = new Gn(this.context, r).toMidi();
                if (this._activeSources.has(s) && this._activeSources.get(s).length) {
                    const i = this._activeSources.get(s);
                    n = this.toSeconds(n), i.forEach(a => {
                        a.stop(n)
                    }), this._activeSources.set(s, [])
                }
            }), this
        }
        releaseAll(e) {
            const n = this.toSeconds(e);
            return this._activeSources.forEach(r => {
                for (; r.length;) r.shift().stop(n)
            }), this
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
        }
        triggerAttackRelease(e, n, r, s = 1) {
            const i = this.toSeconds(r);
            return this.triggerAttack(e, i, s), Fr(n) ? (Ke(Fr(e), "notes must be an array when duration is array"), e.forEach((a, c) => {
                const l = n[Math.min(c, n.length - 1)];
                this.triggerRelease(a, i + this.toSeconds(l))
            })) : this.triggerRelease(e, i + this.toSeconds(n)), this
        }
        add(e, n, r) {
            if (Ke(qf(e) || isFinite(e), `note must be a pitch or midi: ${e}`), qf(e)) {
                const s = new Gn(this.context, e).toMidi();
                this._buffers.add(s, n, r)
            } else this._buffers.add(e, n, r);
            return this
        }
        get loaded() {
            return this._buffers.loaded
        }
        dispose() {
            return super.dispose(), this._buffers.dispose(), this._activeSources.forEach(e => {
                e.forEach(n => n.dispose())
            }), this._activeSources.clear(), this
        }
    }
    $s([Vi(0)], Kc.prototype, "attack", void 0);
    $s([Vi(0)], Kc.prototype, "release", void 0);
    class Yc extends Ne {
        constructor() {
            super(Object.assign(J(Yc.getDefaults(), arguments, ["fade"]))), this.name = "CrossFade", this._panner = this.context.createStereoPanner(), this._split = this.context.createChannelSplitter(2), this._g2a = new Qye({
                context: this.context
            }), this.a = new Be({
                context: this.context,
                gain: 0
            }), this.b = new Be({
                context: this.context,
                gain: 0
            }), this.output = new Be({
                context: this.context
            }), this._internalChannels = [this.a, this.b];
            const e = J(Yc.getDefaults(), arguments, ["fade"]);
            this.fade = new Ye({
                context: this.context,
                units: "normalRange",
                value: e.fade
            }), je(this, "fade"), this.context.getConstant(1).connect(this._panner), this._panner.connect(this._split), this._panner.channelCount = 1, this._panner.channelCountMode = "explicit", os(this._split, this.a.gain, 0), os(this._split, this.b.gain, 1), this.fade.chain(this._g2a, this._panner.pan), this.a.connect(this.output), this.b.connect(this.output)
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                fade: .5
            })
        }
        dispose() {
            return super.dispose(), this.a.dispose(), this.b.dispose(), this.output.dispose(), this.fade.dispose(), this._g2a.dispose(), this._panner.disconnect(), this._split.disconnect(), this
        }
    }
    class Rn extends Ne {
        constructor(e) {
            super(e), this.name = "Effect", this._dryWet = new Yc({
                context: this.context
            }), this.wet = this._dryWet.fade, this.effectSend = new Be({
                context: this.context
            }), this.effectReturn = new Be({
                context: this.context
            }), this.input = new Be({
                context: this.context
            }), this.output = this._dryWet, this.input.fan(this._dryWet.a, this.effectSend), this.effectReturn.connect(this._dryWet.b), this.wet.setValueAtTime(e.wet, 0), this._internalChannels = [this.effectReturn, this.effectSend], je(this, "wet")
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                wet: 1
            })
        }
        connectEffect(e) {
            return this._internalChannels.push(e), this.effectSend.chain(e, this.effectReturn), this
        }
        dispose() {
            return super.dispose(), this._dryWet.dispose(), this.effectSend.dispose(), this.effectReturn.dispose(), this.wet.dispose(), this
        }
    }
    class tp extends Rn {
        constructor(e) {
            super(e), this.name = "LFOEffect", this._lfo = new dr({
                context: this.context,
                frequency: e.frequency,
                amplitude: e.depth
            }), this.depth = this._lfo.amplitude, this.frequency = this._lfo.frequency, this.type = e.type, je(this, ["frequency", "depth"])
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                frequency: 1,
                type: "sine",
                depth: 1
            })
        }
        start(e) {
            return this._lfo.start(e), this
        }
        stop(e) {
            return this._lfo.stop(e), this
        }
        sync() {
            return this._lfo.sync(), this
        }
        unsync() {
            return this._lfo.unsync(), this
        }
        get type() {
            return this._lfo.type
        }
        set type(e) {
            this._lfo.type = e
        }
        dispose() {
            return super.dispose(), this._lfo.dispose(), this.frequency.dispose(), this.depth.dispose(), this
        }
    }
    class Ul extends tp {
        constructor() {
            super(J(Ul.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"])), this.name = "AutoFilter";
            const e = J(Ul.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"]);
            this.filter = new wr(Object.assign(e.filter, {
                context: this.context
            })), this.connectEffect(this.filter), this._lfo.connect(this.filter.frequency), this.octaves = e.octaves, this.baseFrequency = e.baseFrequency
        }
        static getDefaults() {
            return Object.assign(tp.getDefaults(), {
                baseFrequency: 200,
                octaves: 2.6,
                filter: {
                    type: "lowpass",
                    rolloff: -12,
                    Q: 1
                }
            })
        }
        get baseFrequency() {
            return this._lfo.min
        }
        set baseFrequency(e) {
            this._lfo.min = this.toFrequency(e), this.octaves = this._octaves
        }
        get octaves() {
            return this._octaves
        }
        set octaves(e) {
            this._octaves = e, this._lfo.max = this._lfo.min * Math.pow(2, e)
        }
        dispose() {
            return super.dispose(), this.filter.dispose(), this
        }
    }
    class zc extends Ne {
        constructor() {
            super(Object.assign(J(zc.getDefaults(), arguments, ["pan"]))), this.name = "Panner", this._panner = this.context.createStereoPanner(), this.input = this._panner, this.output = this._panner;
            const e = J(zc.getDefaults(), arguments, ["pan"]);
            this.pan = new at({
                context: this.context,
                param: this._panner.pan,
                value: e.pan,
                minValue: -1,
                maxValue: 1
            }), this._panner.channelCount = e.channelCount, this._panner.channelCountMode = "explicit", je(this, "pan")
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                pan: 0,
                channelCount: 1
            })
        }
        dispose() {
            return super.dispose(), this._panner.disconnect(), this.pan.dispose(), this
        }
    }
    class Bl extends tp {
        constructor() {
            super(J(Bl.getDefaults(), arguments, ["frequency"])), this.name = "AutoPanner";
            const e = J(Bl.getDefaults(), arguments, ["frequency"]);
            this._panner = new zc({
                context: this.context,
                channelCount: e.channelCount
            }), this.connectEffect(this._panner), this._lfo.connect(this._panner.pan), this._lfo.min = -1, this._lfo.max = 1
        }
        static getDefaults() {
            return Object.assign(tp.getDefaults(), {
                channelCount: 1
            })
        }
        dispose() {
            return super.dispose(), this._panner.dispose(), this
        }
    }
    class ql extends Ne {
        constructor() {
            super(J(ql.getDefaults(), arguments, ["smoothing"])), this.name = "Follower";
            const e = J(ql.getDefaults(), arguments, ["smoothing"]);
            this._abs = this.input = new Xye({
                context: this.context
            }), this._lowpass = this.output = new Ll({
                context: this.context,
                frequency: 1 / this.toSeconds(e.smoothing),
                type: "lowpass"
            }), this._abs.connect(this._lowpass), this._smoothing = e.smoothing
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                smoothing: .05
            })
        }
        get smoothing() {
            return this._smoothing
        }
        set smoothing(e) {
            this._smoothing = e, this._lowpass.frequency = 1 / this.toSeconds(this.smoothing)
        }
        dispose() {
            return super.dispose(), this._abs.dispose(), this._lowpass.dispose(), this
        }
    }
    class np extends Rn {
        constructor() {
            super(J(np.getDefaults(), arguments, ["baseFrequency", "octaves", "sensitivity"])), this.name = "AutoWah";
            const e = J(np.getDefaults(), arguments, ["baseFrequency", "octaves", "sensitivity"]);
            this._follower = new ql({
                context: this.context,
                smoothing: e.follower
            }), this._sweepRange = new Zd({
                context: this.context,
                min: 0,
                max: 1,
                exponent: .5
            }), this._baseFrequency = this.toFrequency(e.baseFrequency), this._octaves = e.octaves, this._inputBoost = new Be({
                context: this.context
            }), this._bandpass = new wr({
                context: this.context,
                rolloff: -48,
                frequency: 0,
                Q: e.Q
            }), this._peaking = new wr({
                context: this.context,
                type: "peaking"
            }), this._peaking.gain.value = e.gain, this.gain = this._peaking.gain, this.Q = this._bandpass.Q, this.effectSend.chain(this._inputBoost, this._follower, this._sweepRange), this._sweepRange.connect(this._bandpass.frequency), this._sweepRange.connect(this._peaking.frequency), this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn), this._setSweepRange(), this.sensitivity = e.sensitivity, je(this, ["gain", "Q"])
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                baseFrequency: 100,
                octaves: 6,
                sensitivity: 0,
                Q: 2,
                gain: 2,
                follower: .2
            })
        }
        get octaves() {
            return this._octaves
        }
        set octaves(e) {
            this._octaves = e, this._setSweepRange()
        }
        get follower() {
            return this._follower.smoothing
        }
        set follower(e) {
            this._follower.smoothing = e
        }
        get baseFrequency() {
            return this._baseFrequency
        }
        set baseFrequency(e) {
            this._baseFrequency = this.toFrequency(e), this._setSweepRange()
        }
        get sensitivity() {
            return B0(1 / this._inputBoost.gain.value)
        }
        set sensitivity(e) {
            this._inputBoost.gain.value = 1 / qd(e)
        }
        _setSweepRange() {
            this._sweepRange.min = this._baseFrequency, this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2)
        }
        dispose() {
            return super.dispose(), this._follower.dispose(), this._sweepRange.dispose(), this._bandpass.dispose(), this._peaking.dispose(), this._inputBoost.dispose(), this
        }
    }
    const JI = "bit-crusher",
        sve = `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;
    XI(JI, sve);
    class rp extends Rn {
        constructor() {
            super(J(rp.getDefaults(), arguments, ["bits"])), this.name = "BitCrusher";
            const e = J(rp.getDefaults(), arguments, ["bits"]);
            this._bitCrusherWorklet = new sp({
                context: this.context,
                bits: e.bits
            }), this.connectEffect(this._bitCrusherWorklet), this.bits = this._bitCrusherWorklet.bits
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                bits: 4
            })
        }
        dispose() {
            return super.dispose(), this._bitCrusherWorklet.dispose(), this
        }
    }
    class sp extends my {
        constructor() {
            super(J(sp.getDefaults(), arguments)), this.name = "BitCrusherWorklet";
            const e = J(sp.getDefaults(), arguments);
            this.input = new Be({
                context: this.context
            }), this.output = new Be({
                context: this.context
            }), this.bits = new at({
                context: this.context,
                value: e.bits,
                units: "positive",
                minValue: 1,
                maxValue: 16,
                param: this._dummyParam,
                swappable: !0
            })
        }
        static getDefaults() {
            return Object.assign(my.getDefaults(), {
                bits: 12
            })
        }
        _audioWorkletName() {
            return JI
        }
        onReady(e) {
            is(this.input, e, this.output);
            const n = e.parameters.get("bits");
            this.bits.setParam(n)
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this.output.dispose(), this.bits.dispose(), this
        }
    }
    class ip extends Rn {
        constructor() {
            super(J(ip.getDefaults(), arguments, ["order"])), this.name = "Chebyshev";
            const e = J(ip.getDefaults(), arguments, ["order"]);
            this._shaper = new Is({
                context: this.context,
                length: 4096
            }), this._order = e.order, this.connectEffect(this._shaper), this.order = e.order, this.oversample = e.oversample
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                order: 1,
                oversample: "none"
            })
        }
        _getCoefficient(e, n, r) {
            return r.has(n) || (n === 0 ? r.set(n, 0) : n === 1 ? r.set(n, e) : r.set(n, 2 * e * this._getCoefficient(e, n - 1, r) - this._getCoefficient(e, n - 2, r))), r.get(n)
        }
        get order() {
            return this._order
        }
        set order(e) {
            this._order = e, this._shaper.setMap(n => this._getCoefficient(n, e, new Map))
        }
        get oversample() {
            return this._shaper.oversample
        }
        set oversample(e) {
            this._shaper.oversample = e
        }
        dispose() {
            return super.dispose(), this._shaper.dispose(), this
        }
    }
    class Zc extends Ne {
        constructor() {
            super(J(Zc.getDefaults(), arguments, ["channels"])), this.name = "Split";
            const e = J(Zc.getDefaults(), arguments, ["channels"]);
            this._splitter = this.input = this.output = this.context.createChannelSplitter(e.channels), this._internalChannels = [this._splitter]
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                channels: 2
            })
        }
        dispose() {
            return super.dispose(), this._splitter.disconnect(), this
        }
    }
    class Ca extends Ne {
        constructor() {
            super(J(Ca.getDefaults(), arguments, ["channels"])), this.name = "Merge";
            const e = J(Ca.getDefaults(), arguments, ["channels"]);
            this._merger = this.output = this.input = this.context.createChannelMerger(e.channels)
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                channels: 2
            })
        }
        dispose() {
            return super.dispose(), this._merger.disconnect(), this
        }
    }
    class ni extends Ne {
        constructor(e) {
            super(e), this.name = "StereoEffect", this.input = new Be({
                context: this.context
            }), this.input.channelCount = 2, this.input.channelCountMode = "explicit", this._dryWet = this.output = new Yc({
                context: this.context,
                fade: e.wet
            }), this.wet = this._dryWet.fade, this._split = new Zc({
                context: this.context,
                channels: 2
            }), this._merge = new Ca({
                context: this.context,
                channels: 2
            }), this.input.connect(this._split), this.input.connect(this._dryWet.a), this._merge.connect(this._dryWet.b), je(this, ["wet"])
        }
        connectEffectLeft(...e) {
            this._split.connect(e[0], 0, 0), is(...e), os(e[e.length - 1], this._merge, 0, 0)
        }
        connectEffectRight(...e) {
            this._split.connect(e[0], 1, 0), is(...e), os(e[e.length - 1], this._merge, 0, 1)
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                wet: 1
            })
        }
        dispose() {
            return super.dispose(), this._dryWet.dispose(), this._split.dispose(), this._merge.dispose(), this
        }
    }
    class gy extends ni {
        constructor(e) {
            super(e), this.feedback = new Ye({
                context: this.context,
                value: e.feedback,
                units: "normalRange"
            }), this._feedbackL = new Be({
                context: this.context
            }), this._feedbackR = new Be({
                context: this.context
            }), this._feedbackSplit = new Zc({
                context: this.context,
                channels: 2
            }), this._feedbackMerge = new Ca({
                context: this.context,
                channels: 2
            }), this._merge.connect(this._feedbackSplit), this._feedbackMerge.connect(this._split), this._feedbackSplit.connect(this._feedbackL, 0, 0), this._feedbackL.connect(this._feedbackMerge, 0, 0), this._feedbackSplit.connect(this._feedbackR, 1, 0), this._feedbackR.connect(this._feedbackMerge, 0, 1), this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain), je(this, ["feedback"])
        }
        static getDefaults() {
            return Object.assign(ni.getDefaults(), {
                feedback: .5
            })
        }
        dispose() {
            return super.dispose(), this.feedback.dispose(), this._feedbackL.dispose(), this._feedbackR.dispose(), this._feedbackSplit.dispose(), this._feedbackMerge.dispose(), this
        }
    }
    class op extends gy {
        constructor() {
            super(J(op.getDefaults(), arguments, ["frequency", "delayTime", "depth"])), this.name = "Chorus";
            const e = J(op.getDefaults(), arguments, ["frequency", "delayTime", "depth"]);
            this._depth = e.depth, this._delayTime = e.delayTime / 1e3, this._lfoL = new dr({
                context: this.context,
                frequency: e.frequency,
                min: 0,
                max: 1
            }), this._lfoR = new dr({
                context: this.context,
                frequency: e.frequency,
                min: 0,
                max: 1,
                phase: 180
            }), this._delayNodeL = new Ur({
                context: this.context
            }), this._delayNodeR = new Ur({
                context: this.context
            }), this.frequency = this._lfoL.frequency, je(this, ["frequency"]), this._lfoL.frequency.connect(this._lfoR.frequency), this.connectEffectLeft(this._delayNodeL), this.connectEffectRight(this._delayNodeR), this._lfoL.connect(this._delayNodeL.delayTime), this._lfoR.connect(this._delayNodeR.delayTime), this.depth = this._depth, this.type = e.type, this.spread = e.spread
        }
        static getDefaults() {
            return Object.assign(gy.getDefaults(), {
                frequency: 1.5,
                delayTime: 3.5,
                depth: .7,
                type: "sine",
                spread: 180,
                feedback: 0,
                wet: .5
            })
        }
        get depth() {
            return this._depth
        }
        set depth(e) {
            this._depth = e;
            const n = this._delayTime * e;
            this._lfoL.min = Math.max(this._delayTime - n, 0), this._lfoL.max = this._delayTime + n, this._lfoR.min = Math.max(this._delayTime - n, 0), this._lfoR.max = this._delayTime + n
        }
        get delayTime() {
            return this._delayTime * 1e3
        }
        set delayTime(e) {
            this._delayTime = e / 1e3, this.depth = this._depth
        }
        get type() {
            return this._lfoL.type
        }
        set type(e) {
            this._lfoL.type = e, this._lfoR.type = e
        }
        get spread() {
            return this._lfoR.phase - this._lfoL.phase
        }
        set spread(e) {
            this._lfoL.phase = 90 - e / 2, this._lfoR.phase = e / 2 + 90
        }
        start(e) {
            return this._lfoL.start(e), this._lfoR.start(e), this
        }
        stop(e) {
            return this._lfoL.stop(e), this._lfoR.stop(e), this
        }
        sync() {
            return this._lfoL.sync(), this._lfoR.sync(), this
        }
        unsync() {
            return this._lfoL.unsync(), this._lfoR.unsync(), this
        }
        dispose() {
            return super.dispose(), this._lfoL.dispose(), this._lfoR.dispose(), this._delayNodeL.dispose(), this._delayNodeR.dispose(), this.frequency.dispose(), this
        }
    }
    class ap extends Rn {
        constructor() {
            super(J(ap.getDefaults(), arguments, ["distortion"])), this.name = "Distortion";
            const e = J(ap.getDefaults(), arguments, ["distortion"]);
            this._shaper = new Is({
                context: this.context,
                length: 4096
            }), this._distortion = e.distortion, this.connectEffect(this._shaper), this.distortion = e.distortion, this.oversample = e.oversample
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                distortion: .4,
                oversample: "none"
            })
        }
        get distortion() {
            return this._distortion
        }
        set distortion(e) {
            this._distortion = e;
            const n = e * 100,
                r = Math.PI / 180;
            this._shaper.setMap(s => Math.abs(s) < .001 ? 0 : (3 + n) * s * 20 * r / (Math.PI + n * Math.abs(s)))
        }
        get oversample() {
            return this._shaper.oversample
        }
        set oversample(e) {
            this._shaper.oversample = e
        }
        dispose() {
            return super.dispose(), this._shaper.dispose(), this
        }
    }
    class cp extends Rn {
        constructor(e) {
            super(e), this.name = "FeedbackEffect", this._feedbackGain = new Be({
                context: this.context,
                gain: e.feedback,
                units: "normalRange"
            }), this.feedback = this._feedbackGain.gain, je(this, "feedback"), this.effectReturn.chain(this._feedbackGain, this.effectSend)
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                feedback: .125
            })
        }
        dispose() {
            return super.dispose(), this._feedbackGain.dispose(), this.feedback.dispose(), this
        }
    }
    class up extends cp {
        constructor() {
            super(J(up.getDefaults(), arguments, ["delayTime", "feedback"])), this.name = "FeedbackDelay";
            const e = J(up.getDefaults(), arguments, ["delayTime", "feedback"]);
            this._delayNode = new Ur({
                context: this.context,
                delayTime: e.delayTime,
                maxDelay: e.maxDelay
            }), this.delayTime = this._delayNode.delayTime, this.connectEffect(this._delayNode), je(this, "delayTime")
        }
        static getDefaults() {
            return Object.assign(cp.getDefaults(), {
                delayTime: .25,
                maxDelay: 1
            })
        }
        dispose() {
            return super.dispose(), this._delayNode.dispose(), this.delayTime.dispose(), this
        }
    }
    class ive extends Ne {
        constructor(e) {
            super(e), this.name = "PhaseShiftAllpass", this.input = new Be({
                context: this.context
            }), this.output = new Be({
                context: this.context
            }), this.offset90 = new Be({
                context: this.context
            });
            const n = [.6923878, .9360654322959, .988229522686, .9987488452737],
                r = [.4021921162426, .856171088242, .9722909545651, .9952884791278];
            this._bank0 = this._createAllPassFilterBank(n), this._bank1 = this._createAllPassFilterBank(r), this._oneSampleDelay = this.context.createIIRFilter([0, 1], [1, 0]), is(this.input, ...this._bank0, this._oneSampleDelay, this.output), is(this.input, ...this._bank1, this.offset90)
        }
        _createAllPassFilterBank(e) {
            return e.map(r => {
                const s = [
                    [r * r, 0, -1],
                    [1, 0, -(r * r)]
                ];
                return this.context.createIIRFilter(s[0], s[1])
            })
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this.output.dispose(), this.offset90.dispose(), this._bank0.forEach(e => e.disconnect()), this._bank1.forEach(e => e.disconnect()), this._oneSampleDelay.disconnect(), this
        }
    }
    class lp extends Rn {
        constructor() {
            super(J(lp.getDefaults(), arguments, ["frequency"])), this.name = "FrequencyShifter";
            const e = J(lp.getDefaults(), arguments, ["frequency"]);
            this.frequency = new Ye({
                context: this.context,
                units: "frequency",
                value: e.frequency,
                minValue: -this.context.sampleRate / 2,
                maxValue: this.context.sampleRate / 2
            }), this._sine = new Cl({
                context: this.context,
                type: "sine"
            }), this._cosine = new rn({
                context: this.context,
                phase: -90,
                type: "sine"
            }), this._sineMultiply = new on({
                context: this.context
            }), this._cosineMultiply = new on({
                context: this.context
            }), this._negate = new ZI({
                context: this.context
            }), this._add = new yu({
                context: this.context
            }), this._phaseShifter = new ive({
                context: this.context
            }), this.effectSend.connect(this._phaseShifter), this.frequency.fan(this._sine.frequency, this._cosine.frequency), this._phaseShifter.offset90.connect(this._cosineMultiply), this._cosine.connect(this._cosineMultiply.factor), this._phaseShifter.connect(this._sineMultiply), this._sine.connect(this._sineMultiply.factor), this._sineMultiply.connect(this._negate), this._cosineMultiply.connect(this._add), this._negate.connect(this._add.addend), this._add.connect(this.effectReturn);
            const n = this.immediate();
            this._sine.start(n), this._cosine.start(n)
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                frequency: 0
            })
        }
        dispose() {
            return super.dispose(), this.frequency.dispose(), this._add.dispose(), this._cosine.dispose(), this._cosineMultiply.dispose(), this._negate.dispose(), this._phaseShifter.dispose(), this._sine.dispose(), this._sineMultiply.dispose(), this
        }
    }
    const K3 = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100],
        Y3 = [225, 556, 441, 341];
    class hp extends ni {
        constructor() {
            super(J(hp.getDefaults(), arguments, ["roomSize", "dampening"])), this.name = "Freeverb", this._combFilters = [], this._allpassFiltersL = [], this._allpassFiltersR = [];
            const e = J(hp.getDefaults(), arguments, ["roomSize", "dampening"]);
            this.roomSize = new Ye({
                context: this.context,
                value: e.roomSize,
                units: "normalRange"
            }), this._allpassFiltersL = Y3.map(n => {
                const r = this.context.createBiquadFilter();
                return r.type = "allpass", r.frequency.value = n, r
            }), this._allpassFiltersR = Y3.map(n => {
                const r = this.context.createBiquadFilter();
                return r.type = "allpass", r.frequency.value = n, r
            }), this._combFilters = K3.map((n, r) => {
                const s = new Fl({
                    context: this.context,
                    dampening: e.dampening,
                    delayTime: n
                });
                return r < K3.length / 2 ? this.connectEffectLeft(s, ...this._allpassFiltersL) : this.connectEffectRight(s, ...this._allpassFiltersR), this.roomSize.connect(s.resonance), s
            }), je(this, ["roomSize"])
        }
        static getDefaults() {
            return Object.assign(ni.getDefaults(), {
                roomSize: .7,
                dampening: 3e3
            })
        }
        get dampening() {
            return this._combFilters[0].dampening
        }
        set dampening(e) {
            this._combFilters.forEach(n => n.dampening = e)
        }
        dispose() {
            return super.dispose(), this._allpassFiltersL.forEach(e => e.disconnect()), this._allpassFiltersR.forEach(e => e.disconnect()), this._combFilters.forEach(e => e.dispose()), this.roomSize.dispose(), this
        }
    }
    const z3 = [1687 / 25e3, 1601 / 25e3, 2053 / 25e3, 2251 / 25e3],
        ove = [.773, .802, .753, .733],
        ave = [347, 113, 37];
    class fp extends ni {
        constructor() {
            super(J(fp.getDefaults(), arguments, ["roomSize"])), this.name = "JCReverb", this._allpassFilters = [], this._feedbackCombFilters = [];
            const e = J(fp.getDefaults(), arguments, ["roomSize"]);
            this.roomSize = new Ye({
                context: this.context,
                value: e.roomSize,
                units: "normalRange"
            }), this._scaleRoomSize = new Mi({
                context: this.context,
                min: -.733,
                max: .197
            }), this._allpassFilters = ave.map(n => {
                const r = this.context.createBiquadFilter();
                return r.type = "allpass", r.frequency.value = n, r
            }), this._feedbackCombFilters = z3.map((n, r) => {
                const s = new $l({
                    context: this.context,
                    delayTime: n
                });
                return this._scaleRoomSize.connect(s.resonance), s.resonance.value = ove[r], r < z3.length / 2 ? this.connectEffectLeft(...this._allpassFilters, s) : this.connectEffectRight(...this._allpassFilters, s), s
            }), this.roomSize.connect(this._scaleRoomSize), je(this, ["roomSize"])
        }
        static getDefaults() {
            return Object.assign(ni.getDefaults(), {
                roomSize: .5
            })
        }
        dispose() {
            return super.dispose(), this._allpassFilters.forEach(e => e.disconnect()), this._feedbackCombFilters.forEach(e => e.dispose()), this.roomSize.dispose(), this._scaleRoomSize.dispose(), this
        }
    }
    class Z3 extends gy {
        constructor(e) {
            super(e), this._feedbackL.disconnect(), this._feedbackL.connect(this._feedbackMerge, 0, 1), this._feedbackR.disconnect(), this._feedbackR.connect(this._feedbackMerge, 0, 0), je(this, ["feedback"])
        }
    }
    class dp extends Z3 {
        constructor() {
            super(J(dp.getDefaults(), arguments, ["delayTime", "feedback"])), this.name = "PingPongDelay";
            const e = J(dp.getDefaults(), arguments, ["delayTime", "feedback"]);
            this._leftDelay = new Ur({
                context: this.context,
                maxDelay: e.maxDelay
            }), this._rightDelay = new Ur({
                context: this.context,
                maxDelay: e.maxDelay
            }), this._rightPreDelay = new Ur({
                context: this.context,
                maxDelay: e.maxDelay
            }), this.delayTime = new Ye({
                context: this.context,
                units: "time",
                value: e.delayTime
            }), this.connectEffectLeft(this._leftDelay), this.connectEffectRight(this._rightPreDelay, this._rightDelay), this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime), this._feedbackL.disconnect(), this._feedbackL.connect(this._rightDelay), je(this, ["delayTime"])
        }
        static getDefaults() {
            return Object.assign(Z3.getDefaults(), {
                delayTime: .25,
                maxDelay: 1
            })
        }
        dispose() {
            return super.dispose(), this._leftDelay.dispose(), this._rightDelay.dispose(), this._rightPreDelay.dispose(), this.delayTime.dispose(), this
        }
    }
    class pp extends cp {
        constructor() {
            super(J(pp.getDefaults(), arguments, ["pitch"])), this.name = "PitchShift";
            const e = J(pp.getDefaults(), arguments, ["pitch"]);
            this._frequency = new Ye({
                context: this.context
            }), this._delayA = new Ur({
                maxDelay: 1,
                context: this.context
            }), this._lfoA = new dr({
                context: this.context,
                min: 0,
                max: .1,
                type: "sawtooth"
            }).connect(this._delayA.delayTime), this._delayB = new Ur({
                maxDelay: 1,
                context: this.context
            }), this._lfoB = new dr({
                context: this.context,
                min: 0,
                max: .1,
                type: "sawtooth",
                phase: 180
            }).connect(this._delayB.delayTime), this._crossFade = new Yc({
                context: this.context
            }), this._crossFadeLFO = new dr({
                context: this.context,
                min: 0,
                max: 1,
                type: "triangle",
                phase: 90
            }).connect(this._crossFade.fade), this._feedbackDelay = new Ur({
                delayTime: e.delayTime,
                context: this.context
            }), this.delayTime = this._feedbackDelay.delayTime, je(this, "delayTime"), this._pitch = e.pitch, this._windowSize = e.windowSize, this._delayA.connect(this._crossFade.a), this._delayB.connect(this._crossFade.b), this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency), this.effectSend.fan(this._delayA, this._delayB), this._crossFade.chain(this._feedbackDelay, this.effectReturn);
            const n = this.now();
            this._lfoA.start(n), this._lfoB.start(n), this._crossFadeLFO.start(n), this.windowSize = this._windowSize
        }
        static getDefaults() {
            return Object.assign(cp.getDefaults(), {
                pitch: 0,
                windowSize: .1,
                delayTime: 0,
                feedback: 0
            })
        }
        get pitch() {
            return this._pitch
        }
        set pitch(e) {
            this._pitch = e;
            let n = 0;
            e < 0 ? (this._lfoA.min = 0, this._lfoA.max = this._windowSize, this._lfoB.min = 0, this._lfoB.max = this._windowSize, n = Oa(e - 1) + 1) : (this._lfoA.min = this._windowSize, this._lfoA.max = 0, this._lfoB.min = this._windowSize, this._lfoB.max = 0, n = Oa(e) - 1), this._frequency.value = n * (1.2 / this._windowSize)
        }
        get windowSize() {
            return this._windowSize
        }
        set windowSize(e) {
            this._windowSize = this.toSeconds(e), this.pitch = this._pitch
        }
        dispose() {
            return super.dispose(), this._frequency.dispose(), this._delayA.dispose(), this._delayB.dispose(), this._lfoA.dispose(), this._lfoB.dispose(), this._crossFade.dispose(), this._crossFadeLFO.dispose(), this._feedbackDelay.dispose(), this
        }
    }
    class mp extends ni {
        constructor() {
            super(J(mp.getDefaults(), arguments, ["frequency", "octaves", "baseFrequency"])), this.name = "Phaser";
            const e = J(mp.getDefaults(), arguments, ["frequency", "octaves", "baseFrequency"]);
            this._lfoL = new dr({
                context: this.context,
                frequency: e.frequency,
                min: 0,
                max: 1
            }), this._lfoR = new dr({
                context: this.context,
                frequency: e.frequency,
                min: 0,
                max: 1,
                phase: 180
            }), this._baseFrequency = this.toFrequency(e.baseFrequency), this._octaves = e.octaves, this.Q = new Ye({
                context: this.context,
                value: e.Q,
                units: "positive"
            }), this._filtersL = this._makeFilters(e.stages, this._lfoL), this._filtersR = this._makeFilters(e.stages, this._lfoR), this.frequency = this._lfoL.frequency, this.frequency.value = e.frequency, this.connectEffectLeft(...this._filtersL), this.connectEffectRight(...this._filtersR), this._lfoL.frequency.connect(this._lfoR.frequency), this.baseFrequency = e.baseFrequency, this.octaves = e.octaves, this._lfoL.start(), this._lfoR.start(), je(this, ["frequency", "Q"])
        }
        static getDefaults() {
            return Object.assign(ni.getDefaults(), {
                frequency: .5,
                octaves: 3,
                stages: 10,
                Q: 10,
                baseFrequency: 350
            })
        }
        _makeFilters(e, n) {
            const r = [];
            for (let s = 0; s < e; s++) {
                const i = this.context.createBiquadFilter();
                i.type = "allpass", this.Q.connect(i.Q), n.connect(i.frequency), r.push(i)
            }
            return r
        }
        get octaves() {
            return this._octaves
        }
        set octaves(e) {
            this._octaves = e;
            const n = this._baseFrequency * Math.pow(2, e);
            this._lfoL.max = n, this._lfoR.max = n
        }
        get baseFrequency() {
            return this._baseFrequency
        }
        set baseFrequency(e) {
            this._baseFrequency = this.toFrequency(e), this._lfoL.min = this._baseFrequency, this._lfoR.min = this._baseFrequency, this.octaves = this._octaves
        }
        dispose() {
            return super.dispose(), this.Q.dispose(), this._lfoL.dispose(), this._lfoR.dispose(), this._filtersL.forEach(e => e.disconnect()), this._filtersR.forEach(e => e.disconnect()), this.frequency.dispose(), this
        }
    }
    class gp extends Rn {
        constructor() {
            super(J(gp.getDefaults(), arguments, ["decay"])), this.name = "Reverb", this._convolver = this.context.createConvolver(), this.ready = Promise.resolve();
            const e = J(gp.getDefaults(), arguments, ["decay"]);
            this._decay = e.decay, this._preDelay = e.preDelay, this.generate(), this.connectEffect(this._convolver)
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                decay: 1.5,
                preDelay: .01
            })
        }
        get decay() {
            return this._decay
        }
        set decay(e) {
            e = this.toSeconds(e), Cs(e, .001), this._decay = e, this.generate()
        }
        get preDelay() {
            return this._preDelay
        }
        set preDelay(e) {
            e = this.toSeconds(e), Cs(e, 0), this._preDelay = e, this.generate()
        }
        generate() {
            return vn(this, void 0, void 0, function*() {
                const e = this.ready,
                    n = new Cm(2, this._decay + this._preDelay, this.context.sampleRate),
                    r = new Co({
                        context: n
                    }),
                    s = new Co({
                        context: n
                    }),
                    i = new Ca({
                        context: n
                    });
                r.connect(i, 0, 0), s.connect(i, 0, 1);
                const a = new Be({
                    context: n
                }).toDestination();
                i.connect(a), r.start(0), s.start(0), a.gain.setValueAtTime(0, 0), a.gain.setValueAtTime(1, this._preDelay), a.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);
                const c = n.render();
                return this.ready = c.then(ft), yield e, this._convolver.buffer = (yield c).get(), this
            })
        }
        dispose() {
            return super.dispose(), this._convolver.disconnect(), this
        }
    }
    class z0 extends Ne {
        constructor() {
            super(J(z0.getDefaults(), arguments)), this.name = "MidSideSplit", this._split = this.input = new Zc({
                channels: 2,
                context: this.context
            }), this._midAdd = new yu({
                context: this.context
            }), this.mid = new on({
                context: this.context,
                value: Math.SQRT1_2
            }), this._sideSubtract = new vu({
                context: this.context
            }), this.side = new on({
                context: this.context,
                value: Math.SQRT1_2
            }), this._split.connect(this._midAdd, 0), this._split.connect(this._midAdd.addend, 1), this._split.connect(this._sideSubtract, 0), this._split.connect(this._sideSubtract.subtrahend, 1), this._midAdd.connect(this.mid), this._sideSubtract.connect(this.side)
        }
        dispose() {
            return super.dispose(), this.mid.dispose(), this.side.dispose(), this._midAdd.dispose(), this._sideSubtract.dispose(), this._split.dispose(), this
        }
    }
    class Z0 extends Ne {
        constructor() {
            super(J(Z0.getDefaults(), arguments)), this.name = "MidSideMerge", this.mid = new Be({
                context: this.context
            }), this.side = new Be({
                context: this.context
            }), this._left = new yu({
                context: this.context
            }), this._leftMult = new on({
                context: this.context,
                value: Math.SQRT1_2
            }), this._right = new vu({
                context: this.context
            }), this._rightMult = new on({
                context: this.context,
                value: Math.SQRT1_2
            }), this._merge = this.output = new Ca({
                context: this.context
            }), this.mid.fan(this._left), this.side.connect(this._left.addend), this.mid.connect(this._right), this.side.connect(this._right.subtrahend), this._left.connect(this._leftMult), this._right.connect(this._rightMult), this._leftMult.connect(this._merge, 0, 0), this._rightMult.connect(this._merge, 0, 1)
        }
        dispose() {
            return super.dispose(), this.mid.dispose(), this.side.dispose(), this._leftMult.dispose(), this._rightMult.dispose(), this._left.dispose(), this._right.dispose(), this
        }
    }
    class X3 extends Rn {
        constructor(e) {
            super(e), this.name = "MidSideEffect", this._midSideMerge = new Z0({
                context: this.context
            }), this._midSideSplit = new z0({
                context: this.context
            }), this._midSend = this._midSideSplit.mid, this._sideSend = this._midSideSplit.side, this._midReturn = this._midSideMerge.mid, this._sideReturn = this._midSideMerge.side, this.effectSend.connect(this._midSideSplit), this._midSideMerge.connect(this.effectReturn)
        }
        connectEffectMid(...e) {
            this._midSend.chain(...e, this._midReturn)
        }
        connectEffectSide(...e) {
            this._sideSend.chain(...e, this._sideReturn)
        }
        dispose() {
            return super.dispose(), this._midSideSplit.dispose(), this._midSideMerge.dispose(), this._midSend.dispose(), this._sideSend.dispose(), this._midReturn.dispose(), this._sideReturn.dispose(), this
        }
    }
    class _p extends X3 {
        constructor() {
            super(J(_p.getDefaults(), arguments, ["width"])), this.name = "StereoWidener";
            const e = J(_p.getDefaults(), arguments, ["width"]);
            this.width = new Ye({
                context: this.context,
                value: e.width,
                units: "normalRange"
            }), je(this, ["width"]), this._twoTimesWidthMid = new on({
                context: this.context,
                value: 2
            }), this._twoTimesWidthSide = new on({
                context: this.context,
                value: 2
            }), this._midMult = new on({
                context: this.context
            }), this._twoTimesWidthMid.connect(this._midMult.factor), this.connectEffectMid(this._midMult), this._oneMinusWidth = new vu({
                context: this.context
            }), this._oneMinusWidth.connect(this._twoTimesWidthMid), os(this.context.getConstant(1), this._oneMinusWidth), this.width.connect(this._oneMinusWidth.subtrahend), this._sideMult = new on({
                context: this.context
            }), this.width.connect(this._twoTimesWidthSide), this._twoTimesWidthSide.connect(this._sideMult.factor), this.connectEffectSide(this._sideMult)
        }
        static getDefaults() {
            return Object.assign(X3.getDefaults(), {
                width: .5
            })
        }
        dispose() {
            return super.dispose(), this.width.dispose(), this._midMult.dispose(), this._sideMult.dispose(), this._twoTimesWidthMid.dispose(), this._twoTimesWidthSide.dispose(), this._oneMinusWidth.dispose(), this
        }
    }
    class Vl extends ni {
        constructor() {
            super(J(Vl.getDefaults(), arguments, ["frequency", "depth"])), this.name = "Tremolo";
            const e = J(Vl.getDefaults(), arguments, ["frequency", "depth"]);
            this._lfoL = new dr({
                context: this.context,
                type: e.type,
                min: 1,
                max: 0
            }), this._lfoR = new dr({
                context: this.context,
                type: e.type,
                min: 1,
                max: 0
            }), this._amplitudeL = new Be({
                context: this.context
            }), this._amplitudeR = new Be({
                context: this.context
            }), this.frequency = new Ye({
                context: this.context,
                value: e.frequency,
                units: "frequency"
            }), this.depth = new Ye({
                context: this.context,
                value: e.depth,
                units: "normalRange"
            }), je(this, ["frequency", "depth"]), this.connectEffectLeft(this._amplitudeL), this.connectEffectRight(this._amplitudeR), this._lfoL.connect(this._amplitudeL.gain), this._lfoR.connect(this._amplitudeR.gain), this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency), this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude), this.spread = e.spread
        }
        static getDefaults() {
            return Object.assign(ni.getDefaults(), {
                frequency: 10,
                type: "sine",
                depth: .5,
                spread: 180
            })
        }
        start(e) {
            return this._lfoL.start(e), this._lfoR.start(e), this
        }
        stop(e) {
            return this._lfoL.stop(e), this._lfoR.stop(e), this
        }
        sync() {
            return this._lfoL.sync(), this._lfoR.sync(), this.context.transport.syncSignal(this.frequency), this
        }
        unsync() {
            return this._lfoL.unsync(), this._lfoR.unsync(), this.context.transport.unsyncSignal(this.frequency), this
        }
        get type() {
            return this._lfoL.type
        }
        set type(e) {
            this._lfoL.type = e, this._lfoR.type = e
        }
        get spread() {
            return this._lfoR.phase - this._lfoL.phase
        }
        set spread(e) {
            this._lfoL.phase = 90 - e / 2, this._lfoR.phase = e / 2 + 90
        }
        dispose() {
            return super.dispose(), this._lfoL.dispose(), this._lfoR.dispose(), this._amplitudeL.dispose(), this._amplitudeR.dispose(), this.frequency.dispose(), this.depth.dispose(), this
        }
    }
    class yp extends Rn {
        constructor() {
            super(J(yp.getDefaults(), arguments, ["frequency", "depth"])), this.name = "Vibrato";
            const e = J(yp.getDefaults(), arguments, ["frequency", "depth"]);
            this._delayNode = new Ur({
                context: this.context,
                delayTime: 0,
                maxDelay: e.maxDelay
            }), this._lfo = new dr({
                context: this.context,
                type: e.type,
                min: 0,
                max: e.maxDelay,
                frequency: e.frequency,
                phase: -90
            }).start().connect(this._delayNode.delayTime), this.frequency = this._lfo.frequency, this.depth = this._lfo.amplitude, this.depth.value = e.depth, je(this, ["frequency", "depth"]), this.effectSend.chain(this._delayNode, this.effectReturn)
        }
        static getDefaults() {
            return Object.assign(Rn.getDefaults(), {
                maxDelay: .005,
                frequency: 5,
                depth: .1,
                type: "sine"
            })
        }
        get type() {
            return this._lfo.type
        }
        set type(e) {
            this._lfo.type = e
        }
        dispose() {
            return super.dispose(), this._delayNode.dispose(), this._lfo.dispose(), this.frequency.dispose(), this.depth.dispose(), this
        }
    }
    class gn extends Ne {
        constructor() {
            super(J(gn.getDefaults(), arguments, ["solo"])), this.name = "Solo";
            const e = J(gn.getDefaults(), arguments, ["solo"]);
            this.input = this.output = new Be({
                context: this.context
            }), gn._allSolos.has(this.context) || gn._allSolos.set(this.context, new Set), gn._allSolos.get(this.context).add(this), this.solo = e.solo
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                solo: !1
            })
        }
        get solo() {
            return this._isSoloed()
        }
        set solo(e) {
            e ? this._addSolo() : this._removeSolo(), gn._allSolos.get(this.context).forEach(n => n._updateSolo())
        }
        get muted() {
            return this.input.gain.value === 0
        }
        _addSolo() {
            gn._soloed.has(this.context) || gn._soloed.set(this.context, new Set), gn._soloed.get(this.context).add(this)
        }
        _removeSolo() {
            gn._soloed.has(this.context) && gn._soloed.get(this.context).delete(this)
        }
        _isSoloed() {
            return gn._soloed.has(this.context) && gn._soloed.get(this.context).has(this)
        }
        _noSolos() {
            return !gn._soloed.has(this.context) || gn._soloed.has(this.context) && gn._soloed.get(this.context).size === 0
        }
        _updateSolo() {
            this._isSoloed() ? this.input.gain.value = 1 : this._noSolos() ? this.input.gain.value = 1 : this.input.gain.value = 0
        }
        dispose() {
            return super.dispose(), gn._allSolos.get(this.context).delete(this), this._removeSolo(), this
        }
    }
    gn._allSolos = new Map;
    gn._soloed = new Map;
    class Xc extends Ne {
        constructor() {
            super(J(Xc.getDefaults(), arguments, ["pan", "volume"])), this.name = "PanVol";
            const e = J(Xc.getDefaults(), arguments, ["pan", "volume"]);
            this._panner = this.input = new zc({
                context: this.context,
                pan: e.pan,
                channelCount: e.channelCount
            }), this.pan = this._panner.pan, this._volume = this.output = new Qs({
                context: this.context,
                volume: e.volume
            }), this.volume = this._volume.volume, this._panner.connect(this._volume), this.mute = e.mute, je(this, ["pan", "volume"])
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                mute: !1,
                pan: 0,
                volume: 0,
                channelCount: 1
            })
        }
        get mute() {
            return this._volume.mute
        }
        set mute(e) {
            this._volume.mute = e
        }
        dispose() {
            return super.dispose(), this._panner.dispose(), this.pan.dispose(), this._volume.dispose(), this.volume.dispose(), this
        }
    }
    class ua extends Ne {
        constructor() {
            super(J(ua.getDefaults(), arguments, ["volume", "pan"])), this.name = "Channel";
            const e = J(ua.getDefaults(), arguments, ["volume", "pan"]);
            this._solo = this.input = new gn({
                solo: e.solo,
                context: this.context
            }), this._panVol = this.output = new Xc({
                context: this.context,
                pan: e.pan,
                volume: e.volume,
                mute: e.mute,
                channelCount: e.channelCount
            }), this.pan = this._panVol.pan, this.volume = this._panVol.volume, this._solo.connect(this._panVol), je(this, ["pan", "volume"])
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                pan: 0,
                volume: 0,
                mute: !1,
                solo: !1,
                channelCount: 1
            })
        }
        get solo() {
            return this._solo.solo
        }
        set solo(e) {
            this._solo.solo = e
        }
        get muted() {
            return this._solo.muted || this.mute
        }
        get mute() {
            return this._panVol.mute
        }
        set mute(e) {
            this._panVol.mute = e
        }
        _getBus(e) {
            return ua.buses.has(e) || ua.buses.set(e, new Be({
                context: this.context
            })), ua.buses.get(e)
        }
        send(e, n = 0) {
            const r = this._getBus(e),
                s = new Be({
                    context: this.context,
                    units: "decibels",
                    gain: n
                });
            return this.connect(s), s.connect(r), s
        }
        receive(e) {
            return this._getBus(e).connect(this), this
        }
        dispose() {
            return super.dispose(), this._panVol.dispose(), this.pan.dispose(), this.volume.dispose(), this._solo.dispose(), this
        }
    }
    ua.buses = new Map;
    class jl extends Ne {
        constructor() {
            super(J(jl.getDefaults(), arguments, ["lowFrequency", "highFrequency"])), this.name = "MultibandSplit", this.input = new Be({
                context: this.context
            }), this.output = void 0, this.low = new wr({
                context: this.context,
                frequency: 0,
                type: "lowpass"
            }), this._lowMidFilter = new wr({
                context: this.context,
                frequency: 0,
                type: "highpass"
            }), this.mid = new wr({
                context: this.context,
                frequency: 0,
                type: "lowpass"
            }), this.high = new wr({
                context: this.context,
                frequency: 0,
                type: "highpass"
            }), this._internalChannels = [this.low, this.mid, this.high];
            const e = J(jl.getDefaults(), arguments, ["lowFrequency", "highFrequency"]);
            this.lowFrequency = new Ye({
                context: this.context,
                units: "frequency",
                value: e.lowFrequency
            }), this.highFrequency = new Ye({
                context: this.context,
                units: "frequency",
                value: e.highFrequency
            }), this.Q = new Ye({
                context: this.context,
                units: "positive",
                value: e.Q
            }), this.input.fan(this.low, this.high), this.input.chain(this._lowMidFilter, this.mid), this.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency), this.highFrequency.fan(this.mid.frequency, this.high.frequency), this.Q.connect(this.low.Q), this.Q.connect(this._lowMidFilter.Q), this.Q.connect(this.mid.Q), this.Q.connect(this.high.Q), je(this, ["high", "mid", "low", "highFrequency", "lowFrequency"])
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                Q: 1,
                highFrequency: 2500,
                lowFrequency: 400
            })
        }
        dispose() {
            return super.dispose(), vh(this, ["high", "mid", "low", "highFrequency", "lowFrequency"]), this.low.dispose(), this._lowMidFilter.dispose(), this.mid.dispose(), this.high.dispose(), this.lowFrequency.dispose(), this.highFrequency.dispose(), this.Q.dispose(), this
        }
    }
    class cve extends Ne {
        constructor() {
            super(...arguments), this.name = "Listener", this.positionX = new at({
                context: this.context,
                param: this.context.rawContext.listener.positionX
            }), this.positionY = new at({
                context: this.context,
                param: this.context.rawContext.listener.positionY
            }), this.positionZ = new at({
                context: this.context,
                param: this.context.rawContext.listener.positionZ
            }), this.forwardX = new at({
                context: this.context,
                param: this.context.rawContext.listener.forwardX
            }), this.forwardY = new at({
                context: this.context,
                param: this.context.rawContext.listener.forwardY
            }), this.forwardZ = new at({
                context: this.context,
                param: this.context.rawContext.listener.forwardZ
            }), this.upX = new at({
                context: this.context,
                param: this.context.rawContext.listener.upX
            }), this.upY = new at({
                context: this.context,
                param: this.context.rawContext.listener.upY
            }), this.upZ = new at({
                context: this.context,
                param: this.context.rawContext.listener.upZ
            })
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                positionX: 0,
                positionY: 0,
                positionZ: 0,
                forwardX: 0,
                forwardY: 0,
                forwardZ: -1,
                upX: 0,
                upY: 1,
                upZ: 0
            })
        }
        dispose() {
            return super.dispose(), this.positionX.dispose(), this.positionY.dispose(), this.positionZ.dispose(), this.forwardX.dispose(), this.forwardY.dispose(), this.forwardZ.dispose(), this.upX.dispose(), this.upY.dispose(), this.upZ.dispose(), this
        }
    }
    Om(t => {
        t.listener = new cve({
            context: t
        })
    });
    Am(t => {
        t.listener.dispose()
    });
    class vo extends Ne {
        constructor() {
            super(J(vo.getDefaults(), arguments, ["threshold", "ratio"])), this.name = "Compressor", this._compressor = this.context.createDynamicsCompressor(), this.input = this._compressor, this.output = this._compressor;
            const e = J(vo.getDefaults(), arguments, ["threshold", "ratio"]);
            this.threshold = new at({
                minValue: this._compressor.threshold.minValue,
                maxValue: this._compressor.threshold.maxValue,
                context: this.context,
                convert: !1,
                param: this._compressor.threshold,
                units: "decibels",
                value: e.threshold
            }), this.attack = new at({
                minValue: this._compressor.attack.minValue,
                maxValue: this._compressor.attack.maxValue,
                context: this.context,
                param: this._compressor.attack,
                units: "time",
                value: e.attack
            }), this.release = new at({
                minValue: this._compressor.release.minValue,
                maxValue: this._compressor.release.maxValue,
                context: this.context,
                param: this._compressor.release,
                units: "time",
                value: e.release
            }), this.knee = new at({
                minValue: this._compressor.knee.minValue,
                maxValue: this._compressor.knee.maxValue,
                context: this.context,
                convert: !1,
                param: this._compressor.knee,
                units: "decibels",
                value: e.knee
            }), this.ratio = new at({
                minValue: this._compressor.ratio.minValue,
                maxValue: this._compressor.ratio.maxValue,
                context: this.context,
                convert: !1,
                param: this._compressor.ratio,
                units: "positive",
                value: e.ratio
            }), je(this, ["knee", "release", "attack", "ratio", "threshold"])
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                attack: .003,
                knee: 30,
                ratio: 12,
                release: .25,
                threshold: -24
            })
        }
        get reduction() {
            return this._compressor.reduction
        }
        dispose() {
            return super.dispose(), this._compressor.disconnect(), this.attack.dispose(), this.release.dispose(), this.threshold.dispose(), this.ratio.dispose(), this.knee.dispose(), this
        }
    }
    class vp extends Ne {
        constructor() {
            super(Object.assign(J(vp.getDefaults(), arguments, ["threshold", "smoothing"]))), this.name = "Gate";
            const e = J(vp.getDefaults(), arguments, ["threshold", "smoothing"]);
            this._follower = new ql({
                context: this.context,
                smoothing: e.smoothing
            }), this._gt = new zd({
                context: this.context,
                value: qd(e.threshold)
            }), this.input = new Be({
                context: this.context
            }), this._gate = this.output = new Be({
                context: this.context
            }), this.input.connect(this._gate), this.input.chain(this._follower, this._gt, this._gate.gain)
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                smoothing: .1,
                threshold: -40
            })
        }
        get threshold() {
            return B0(this._gt.value)
        }
        set threshold(e) {
            this._gt.value = qd(e)
        }
        get smoothing() {
            return this._follower.smoothing
        }
        set smoothing(e) {
            this._follower.smoothing = e
        }
        dispose() {
            return super.dispose(), this.input.dispose(), this._follower.dispose(), this._gt.dispose(), this._gate.dispose(), this
        }
    }
    class bp extends Ne {
        constructor() {
            super(Object.assign(J(bp.getDefaults(), arguments, ["threshold"]))), this.name = "Limiter";
            const e = J(bp.getDefaults(), arguments, ["threshold"]);
            this._compressor = this.input = this.output = new vo({
                context: this.context,
                ratio: 20,
                attack: .003,
                release: .01,
                threshold: e.threshold
            }), this.threshold = this._compressor.threshold, je(this, "threshold")
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                threshold: -12
            })
        }
        get reduction() {
            return this._compressor.reduction
        }
        dispose() {
            return super.dispose(), this._compressor.dispose(), this.threshold.dispose(), this
        }
    }
    class Ep extends Ne {
        constructor() {
            super(Object.assign(J(Ep.getDefaults(), arguments))), this.name = "MultibandCompressor";
            const e = J(Ep.getDefaults(), arguments);
            this._splitter = this.input = new jl({
                context: this.context,
                lowFrequency: e.lowFrequency,
                highFrequency: e.highFrequency
            }), this.lowFrequency = this._splitter.lowFrequency, this.highFrequency = this._splitter.highFrequency, this.output = new Be({
                context: this.context
            }), this.low = new vo(Object.assign(e.low, {
                context: this.context
            })), this.mid = new vo(Object.assign(e.mid, {
                context: this.context
            })), this.high = new vo(Object.assign(e.high, {
                context: this.context
            })), this._splitter.low.chain(this.low, this.output), this._splitter.mid.chain(this.mid, this.output), this._splitter.high.chain(this.high, this.output), je(this, ["high", "mid", "low", "highFrequency", "lowFrequency"])
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                lowFrequency: 250,
                highFrequency: 2e3,
                low: {
                    ratio: 6,
                    threshold: -30,
                    release: .25,
                    attack: .03,
                    knee: 10
                },
                mid: {
                    ratio: 3,
                    threshold: -24,
                    release: .03,
                    attack: .02,
                    knee: 16
                },
                high: {
                    ratio: 3,
                    threshold: -24,
                    release: .03,
                    attack: .02,
                    knee: 16
                }
            })
        }
        dispose() {
            return super.dispose(), this._splitter.dispose(), this.low.dispose(), this.mid.dispose(), this.high.dispose(), this.output.dispose(), this
        }
    }
    class Sp extends Ne {
        constructor() {
            super(J(Sp.getDefaults(), arguments, ["low", "mid", "high"])), this.name = "EQ3", this.output = new Be({
                context: this.context
            }), this._internalChannels = [];
            const e = J(Sp.getDefaults(), arguments, ["low", "mid", "high"]);
            this.input = this._multibandSplit = new jl({
                context: this.context,
                highFrequency: e.highFrequency,
                lowFrequency: e.lowFrequency
            }), this._lowGain = new Be({
                context: this.context,
                gain: e.low,
                units: "decibels"
            }), this._midGain = new Be({
                context: this.context,
                gain: e.mid,
                units: "decibels"
            }), this._highGain = new Be({
                context: this.context,
                gain: e.high,
                units: "decibels"
            }), this.low = this._lowGain.gain, this.mid = this._midGain.gain, this.high = this._highGain.gain, this.Q = this._multibandSplit.Q, this.lowFrequency = this._multibandSplit.lowFrequency, this.highFrequency = this._multibandSplit.highFrequency, this._multibandSplit.low.chain(this._lowGain, this.output), this._multibandSplit.mid.chain(this._midGain, this.output), this._multibandSplit.high.chain(this._highGain, this.output), je(this, ["low", "mid", "high", "lowFrequency", "highFrequency"]), this._internalChannels = [this._multibandSplit]
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                high: 0,
                highFrequency: 2500,
                low: 0,
                lowFrequency: 400,
                mid: 0
            })
        }
        dispose() {
            return super.dispose(), vh(this, ["low", "mid", "high", "lowFrequency", "highFrequency"]), this._multibandSplit.dispose(), this.lowFrequency.dispose(), this.highFrequency.dispose(), this._lowGain.dispose(), this._midGain.dispose(), this._highGain.dispose(), this.low.dispose(), this.mid.dispose(), this.high.dispose(), this.Q.dispose(), this
        }
    }
    es().transport;
    es().destination;
    es().destination;
    es().listener;
    es().draw;
    es();

    function X0() {
        return It.loaded()
    }
    class uve {
        constructor(e) {
            this.isPlayable = !0, this.node = new xm(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class lve {
        constructor(e) {
            this.isPlayable = !1;
            const n = new as(e.frequency || 440, e.type || "sine"),
                r = new Ul(e).start();
            n.connect(r), this.node = r
        }
    }
    class hve {
        constructor(e) {
            this.isPlayable = !1;
            const n = new as(e.frequency || 440, e.type || "sine"),
                r = new Bl(e).start();
            n.connect(r), this.node = r
        }
    }
    class ks extends Ne {
        constructor() {
            super(J(ks.getDefaults(), arguments)), this._scheduledEvents = [], this._synced = !1, this._original_triggerAttack = this.triggerAttack, this._original_triggerRelease = this.triggerRelease;
            const e = J(ks.getDefaults(), arguments);
            this._volume = new Qs({
                context: this.context,
                volume: e.volume
            }), this.output = this._volume, this.volume = this._volume.volume, je(this, "volume")
        }
        static getDefaults() {
            return Object.assign(Ne.getDefaults(), {
                volume: 0
            })
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 0)), this
        }
        _syncState() {
            let e = !1;
            return this._synced || (this._synced = !0, e = !0), e
        }
        _syncMethod(e, n) {
            const r = this[e];
            this[`_original_${e}`] = this[e], this[e] = (...s) => {
                const i = s[n],
                    a = this.context.transport.schedule(c => {
                        s[n] = c, r.apply(this, s)
                    }, i);
                this._scheduledEvents.push(a)
            }
        }
        unsync() {
            return this._scheduledEvents.forEach(e => this.context.transport.clear(e)), this._scheduledEvents = [], this._synced && (this._synced = !1, this.triggerAttack = this._original_triggerAttack, this.triggerRelease = this._original_triggerRelease), this
        }
        triggerAttackRelease(e, n, r, s) {
            const i = this.toSeconds(r),
                a = this.toSeconds(n);
            return this.triggerAttack(e, i, s), this.triggerRelease(i + a), this
        }
        dispose() {
            return super.dispose(), this._volume.dispose(), this.unsync(), this._scheduledEvents = [], this
        }
    }
    var Tp = (t, e) => Array(Math.abs(e) + 1).join(t);

    function ek(t, e, n) {
        return function(...r) {
            return console.warn(`${t} is deprecated. Use ${e}.`), n.apply(this, r)
        }
    }

    function tk(t) {
        return t !== null && typeof t == "object" && typeof t.name == "string"
    }

    function nk(t) {
        return t !== null && typeof t == "object" && typeof t.step == "number" && typeof t.alt == "number"
    }
    var rk = [0, 2, 4, -1, 1, 3, 5],
        sk = rk.map(t => Math.floor(t * 7 / 12));

    function ik(t) {
        const {
            step: e,
            alt: n,
            oct: r,
            dir: s = 1
        } = t, i = rk[e] + 7 * n;
        if (r === void 0) return [s * i];
        const a = r - sk[e] - 4 * n;
        return [s * i, s * a]
    }
    var fve = [3, 0, 4, 1, 5, 2, 6];

    function ok(t) {
        const [e, n, r] = t, s = fve[dve(e)], i = Math.floor((e + 1) / 7);
        if (n === void 0) return {
            step: s,
            alt: i,
            dir: r
        };
        const a = n + 4 * i + sk[s];
        return {
            step: s,
            alt: i,
            oct: a,
            dir: r
        }
    }

    function dve(t) {
        const e = (t + 1) % 7;
        return e < 0 ? 7 + e : e
    }
    var ak = {
            empty: !0,
            name: "",
            pc: "",
            acc: ""
        },
        Q3 = new Map,
        pve = t => "CDEFGAB".charAt(t),
        mve = t => t < 0 ? Tp("b", -t) : Tp("#", t),
        gve = t => t[0] === "b" ? -t.length : t.length;

    function jt(t) {
        const e = JSON.stringify(t),
            n = Q3.get(e);
        if (n) return n;
        const r = typeof t == "string" ? bve(t) : nk(t) ? jt(Eve(t)) : tk(t) ? jt(t.name) : ak;
        return Q3.set(e, r), r
    }
    var _ve = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;

    function ck(t) {
        const e = _ve.exec(t);
        return [e[1].toUpperCase(), e[2].replace(/x/g, "##"), e[3], e[4]]
    }

    function yve(t) {
        return jt(ok(t))
    }
    var vve = (t, e) => (t % e + e) % e,
        K_ = [0, 2, 4, 5, 7, 9, 11];

    function bve(t) {
        const e = ck(t);
        if (e[0] === "" || e[3] !== "") return ak;
        const n = e[0],
            r = e[1],
            s = e[2],
            i = (n.charCodeAt(0) + 3) % 7,
            a = gve(r),
            c = s.length ? +s : void 0,
            l = ik({
                step: i,
                alt: a,
                oct: c
            }),
            h = n + r + s,
            d = n + r,
            p = (K_[i] + a + 120) % 12,
            g = c === void 0 ? vve(K_[i] + a, 12) - 12 * 99 : K_[i] + a + 12 * (c + 1),
            v = g >= 0 && g <= 127 ? g : null,
            b = c === void 0 ? null : Math.pow(2, (g - 69) / 12) * 440;
        return {
            empty: !1,
            acc: r,
            alt: a,
            chroma: p,
            coord: l,
            freq: b,
            height: g,
            letter: n,
            midi: v,
            name: h,
            oct: c,
            pc: d,
            step: i
        }
    }

    function Eve(t) {
        const {
            step: e,
            alt: n,
            oct: r
        } = t, s = pve(e);
        if (!s) return "";
        const i = s + mve(n);
        return r || r === 0 ? i + r : i
    }
    var _y = {
            empty: !0,
            name: "",
            acc: ""
        },
        Sve = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})",
        Tve = "(AA|A|P|M|m|d|dd)([-+]?\\d+)",
        wve = new RegExp("^" + Sve + "|" + Tve + "$");

    function Ove(t) {
        const e = wve.exec(`${t}`);
        return e === null ? ["", ""] : e[1] ? [e[1], e[2]] : [e[4], e[3]]
    }
    var J3 = {};

    function Gl(t) {
        return typeof t == "string" ? J3[t] || (J3[t] = Ave(t)) : nk(t) ? Gl(kve(t)) : tk(t) ? Gl(t.name) : _y
    }
    var e5 = [0, 2, 4, 5, 7, 9, 11],
        uk = "PMMPPMM";

    function Ave(t) {
        const e = Ove(t);
        if (e[0] === "") return _y;
        const n = +e[0],
            r = e[1],
            s = (Math.abs(n) - 1) % 7,
            i = uk[s];
        if (i === "M" && r === "P") return _y;
        const a = i === "M" ? "majorable" : "perfectable",
            c = "" + n + r,
            l = n < 0 ? -1 : 1,
            h = n === 8 || n === -8 ? n : l * (s + 1),
            d = Ive(a, r),
            p = Math.floor((Math.abs(n) - 1) / 7),
            g = l * (e5[s] + d + 12 * p),
            v = (l * (e5[s] + d) % 12 + 12) % 12,
            b = ik({
                step: s,
                alt: d,
                oct: p,
                dir: l
            });
        return {
            empty: !1,
            name: c,
            num: n,
            q: r,
            step: s,
            alt: d,
            dir: l,
            type: a,
            simple: h,
            semitones: g,
            chroma: v,
            coord: b,
            oct: p
        }
    }

    function Cve(t, e) {
        const [n, r = 0] = t, s = n * 7 + r * 12 < 0, i = e || s ? [-n, -r, -1] : [n, r, 1];
        return Gl(ok(i))
    }

    function Ive(t, e) {
        return e === "M" && t === "majorable" || e === "P" && t === "perfectable" ? 0 : e === "m" && t === "majorable" ? -1 : /^A+$/.test(e) ? e.length : /^d+$/.test(e) ? -1 * (t === "perfectable" ? e.length : e.length + 1) : 0
    }

    function kve(t) {
        const {
            step: e,
            alt: n,
            oct: r = 0,
            dir: s
        } = t;
        if (!s) return "";
        const i = e + 1 + 7 * r,
            a = i === 0 ? e + 1 : i,
            c = s < 0 ? "-" : "",
            l = uk[e] === "M" ? "majorable" : "perfectable";
        return c + a + Nve(l, n)
    }

    function Nve(t, e) {
        return e === 0 ? t === "majorable" ? "M" : "P" : e === -1 && t === "majorable" ? "m" : e > 0 ? Tp("A", e) : Tp("d", t === "perfectable" ? e : e + 1)
    }

    function Io(t, e) {
        const n = jt(t),
            r = Array.isArray(e) ? e : Gl(e).coord;
        if (n.empty || !r || r.length < 2) return "";
        const s = n.coord,
            i = s.length === 1 ? [s[0] + r[0]] : [s[0] + r[0], s[1] + r[1]];
        return yve(i).name
    }

    function Pm(t, e) {
        const n = t.length;
        return r => {
            if (!e) return "";
            const s = r < 0 ? (n - -r % n) % n : r % n,
                i = Math.floor(r / n),
                a = Io(e, [0, i]);
            return Io(a, t[s])
        }
    }

    function xve(t, e) {
        const n = jt(t),
            r = jt(e);
        if (n.empty || r.empty) return "";
        const s = n.coord,
            i = r.coord,
            a = i[0] - s[0],
            c = s.length === 2 && i.length === 2 ? i[1] - s[1] : -Math.floor(a * 7 / 12),
            l = r.height === n.height && r.midi !== null && n.midi !== null && n.step > r.step;
        return Cve([a, c], l).name
    }

    function Pve(t, e) {
        const n = [];
        for (; e--; n[e] = e + t);
        return n
    }

    function Rve(t, e) {
        const n = [];
        for (; e--; n[e] = t - e);
        return n
    }

    function Mve(t, e) {
        return t < e ? Pve(t, e - t + 1) : Rve(t, t - e + 1)
    }

    function Sh(t, e) {
        const n = e.length,
            r = (t % n + n) % n;
        return e.slice(r, n).concat(e.slice(0, r))
    }

    function Dve(t) {
        return t.filter(e => e === 0 || e)
    }
    var Ia = {
            empty: !0,
            name: "",
            setNum: 0,
            chroma: "000000000000",
            normalized: "000000000000",
            intervals: []
        },
        lk = t => Number(t).toString(2),
        t5 = t => parseInt(t, 2),
        $ve = /^[01]{12}$/;

    function Q0(t) {
        return $ve.test(t)
    }
    var Lve = t => typeof t == "number" && t >= 0 && t <= 4095,
        Fve = t => t && Q0(t.chroma),
        n5 = {
            [Ia.chroma]: Ia
        };

    function ko(t) {
        const e = Q0(t) ? t : Lve(t) ? lk(t) : Array.isArray(t) ? Gve(t) : Fve(t) ? t.chroma : Ia.chroma;
        return n5[e] = n5[e] || jve(e)
    }
    var Uve = t => ko(t).chroma,
        Bve = ["1P", "2m", "2M", "3m", "3M", "4P", "5d", "5P", "6m", "6M", "7m", "7M"];

    function qve(t) {
        const e = [];
        for (let n = 0; n < 12; n++) t.charAt(n) === "1" && e.push(Bve[n]);
        return e
    }

    function hk(t, e = !0) {
        const r = ko(t).chroma.split("");
        return Dve(r.map((s, i) => {
            const a = Sh(i, r);
            return e && a[0] === "0" ? null : a.join("")
        }))
    }

    function J0(t) {
        const e = ko(t).setNum;
        return n => {
            const r = ko(n).setNum;
            return e && e !== r && (r & e) === r
        }
    }

    function e2(t) {
        const e = ko(t).setNum;
        return n => {
            const r = ko(n).setNum;
            return e && e !== r && (r | e) === r
        }
    }

    function Vve(t) {
        const e = t.split("");
        return e.map((n, r) => Sh(r, e).join(""))
    }

    function jve(t) {
        const e = t5(t),
            n = Vve(t).map(t5).filter(i => i >= 2048).sort()[0],
            r = lk(n),
            s = qve(t);
        return {
            empty: !1,
            name: "",
            setNum: e,
            chroma: t,
            normalized: r,
            intervals: s
        }
    }

    function Gve(t) {
        if (t.length === 0) return Ia.chroma;
        let e;
        const n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (let r = 0; r < t.length; r++) e = jt(t[r]), e.empty && (e = Gl(t[r])), e.empty || (n[e.chroma] = 1);
        return n.join("")
    }
    var Wve = [
            ["1P 3M 5P", "major", "M ^  maj"],
            ["1P 3M 5P 7M", "major seventh", "maj7  ma7 M7 Maj7 ^7"],
            ["1P 3M 5P 7M 9M", "major ninth", "maj9 9 ^9"],
            ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
            ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
            ["1P 3M 5P 6M 9M", "sixth/ninth", "6/9 69 M69"],
            ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
            ["1P 3M 5P 7M 11A", "major seventh sharp eleventh", "maj#4 #4 #11 M7#11 ^7#11 maj7#11"],
            ["1P 3m 5P", "minor", "m min -"],
            ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
            ["1P 3m 5P 7M", "minor/major seventh", "m/ma7 m/maj7 mM7 mMaj7 m/M7 -7 m -^7"],
            ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
            ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
            ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
            ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
            ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
            ["1P 3m 5d", "diminished", "dim  o"],
            ["1P 3m 5d 7d", "diminished seventh", "dim7 7 o7"],
            ["1P 3m 5d 7m", "half-diminished", "m7b5  -7b5 h7 h"],
            ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
            ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
            ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
            ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
            ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
            ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
            ["1P 3M 7m 9m", "altered", "alt7"],
            ["1P 4P 5P", "suspended fourth", "sus4 sus"],
            ["1P 2M 5P", "suspended second", "sus2"],
            ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
            ["1P 5P 7m 9M 11P", "eleventh", "11"],
            ["1P 4P 5P 7m 9m", "suspended fourth flat ninth", "b9sus phryg 7b9sus 7b9sus4"],
            ["1P 5P", "fifth", "5"],
            ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
            ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
            ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
            ["1P 3M 5P 7M 9M 11A", "major sharp eleventh (lydian)", "maj9#11 9#11 ^9#11"],
            ["1P 2M 4P 5P", "", "sus24 sus4add9"],
            ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
            ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
            ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
            ["1P 3M 5A 7m 9M", "", "9#5 9+"],
            ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
            ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
            ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
            ["1P 3M 5A 9A", "", "+add#9"],
            ["1P 3M 5A 9M", "", "M#5add9 +add9"],
            ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
            ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
            ["1P 3M 5P 6M 9M 11A", "", "69#11"],
            ["1P 3m 5P 6M 9M", "", "m69 -69"],
            ["1P 3M 5P 6m 7m", "", "7b6"],
            ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
            ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
            ["1P 3M 5P 7M 9m", "", "M7b9"],
            ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
            ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
            ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
            ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
            ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
            ["1P 3M 5P 7m 9A 13M", "", "13#9"],
            ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
            ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
            ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
            ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
            ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
            ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
            ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
            ["1P 3M 5P 7m 9m 13M", "", "13b9"],
            ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
            ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
            ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
            ["1P 3M 5P 9m", "", "Maddb9"],
            ["1P 3M 5d", "", "Mb5"],
            ["1P 3M 5d 6M 7m 9M", "", "13b5"],
            ["1P 3M 5d 7M", "", "M7b5"],
            ["1P 3M 5d 7M 9M", "", "M9b5"],
            ["1P 3M 5d 7m", "", "7b5"],
            ["1P 3M 5d 7m 9M", "", "9b5"],
            ["1P 3M 7m", "", "7no5"],
            ["1P 3M 7m 13m", "", "7b13"],
            ["1P 3M 7m 9M", "", "9no5"],
            ["1P 3M 7m 9M 13M", "", "13no5"],
            ["1P 3M 7m 9M 13m", "", "9b13"],
            ["1P 3m 4P 5P", "", "madd4"],
            ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
            ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
            ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
            ["1P 3m 5P 9M", "", "madd9"],
            ["1P 3m 5d 6M 7M", "", "o7M7"],
            ["1P 3m 5d 7M", "", "oM7"],
            ["1P 3m 6m 7M", "", "mb6M7"],
            ["1P 3m 6m 7m", "", "m7#5"],
            ["1P 3m 6m 7m 9M", "", "m9#5"],
            ["1P 3m 5A 7m 9M 11P", "", "m11A"],
            ["1P 3m 6m 9m", "", "mb6b9"],
            ["1P 2M 3m 5d 7m", "", "m9b5"],
            ["1P 4P 5A 7M", "", "M7#5sus4"],
            ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
            ["1P 4P 5A 7m", "", "7#5sus4"],
            ["1P 4P 5P 7M", "", "M7sus4"],
            ["1P 4P 5P 7M 9M", "", "M9sus4"],
            ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
            ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
            ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
            ["1P 4P 7m 10m", "", "4 quartal"],
            ["1P 5P 7m 9m 11P", "", "11b9"]
        ],
        Hve = Wve,
        Kve = {
            ...Ia,
            name: "",
            quality: "Unknown",
            intervals: [],
            aliases: []
        },
        t2 = [],
        ol = {};

    function Yve(t) {
        return ol[t] || Kve
    }

    function Rm() {
        return t2.slice()
    }

    function zve(t, e, n) {
        const r = Xve(t),
            s = {
                ...ko(t),
                name: n || "",
                quality: r,
                intervals: t,
                aliases: e
            };
        t2.push(s), s.name && (ol[s.name] = s), ol[s.setNum] = s, ol[s.chroma] = s, s.aliases.forEach(i => Zve(s, i))
    }

    function Zve(t, e) {
        ol[e] = t
    }

    function Xve(t) {
        const e = n => t.indexOf(n) !== -1;
        return e("5A") ? "Augmented" : e("3M") ? "Major" : e("5d") ? "Diminished" : e("3m") ? "Minor" : "Unknown"
    }
    Hve.forEach(([t, e, n]) => zve(t.split(" "), n.split(" "), e));
    t2.sort((t, e) => t.setNum - e.setNum);
    var Qve = t => {
        const e = t.reduce((n, r) => {
            const s = jt(r).chroma;
            return s !== void 0 && (n[s] = n[s] || jt(r).name), n
        }, {});
        return n => e[n]
    };

    function Jve(t, e = {}) {
        const n = t.map(s => jt(s).pc).filter(s => s);
        return jt.length === 0 ? [] : o0e(n, 1, e).filter(s => s.weight).sort((s, i) => i.weight - s.weight).map(s => s.name)
    }
    var Mm = {
            anyThirds: 384,
            perfectFifth: 16,
            nonPerfectFifths: 40,
            anySeventh: 3
        },
        Dm = t => e => !!(e & t),
        e0e = Dm(Mm.anyThirds),
        t0e = Dm(Mm.perfectFifth),
        n0e = Dm(Mm.anySeventh),
        r0e = Dm(Mm.nonPerfectFifths);

    function s0e(t) {
        const e = parseInt(t.chroma, 2);
        return e0e(e) && t0e(e) && n0e(e)
    }

    function i0e(t) {
        const e = parseInt(t, 2);
        return r0e(e) ? t : (e | 16).toString(2)
    }

    function o0e(t, e, n) {
        const r = t[0],
            s = jt(r).chroma,
            i = Qve(t),
            a = hk(t, !1),
            c = [];
        return a.forEach((l, h) => {
            const d = n.assumePerfectFifth && i0e(l);
            Rm().filter(g => n.assumePerfectFifth && s0e(g) ? g.chroma === d : g.chroma === l).forEach(g => {
                const v = g.aliases[0],
                    b = i(h);
                h !== s ? c.push({
                    weight: .5 * e,
                    name: `${b}${v}/${r}`
                }) : c.push({
                    weight: 1 * e,
                    name: `${b}${v}`
                })
            })
        }), c
    }
    var a0e = [
            ["1P 2M 3M 5P 6M", "major pentatonic", "pentatonic"],
            ["1P 2M 3M 4P 5P 6M 7M", "major", "ionian"],
            ["1P 2M 3m 4P 5P 6m 7m", "minor", "aeolian"],
            ["1P 2M 3m 3M 5P 6M", "major blues"],
            ["1P 3m 4P 5d 5P 7m", "minor blues", "blues"],
            ["1P 2M 3m 4P 5P 6M 7M", "melodic minor"],
            ["1P 2M 3m 4P 5P 6m 7M", "harmonic minor"],
            ["1P 2M 3M 4P 5P 6M 7m 7M", "bebop"],
            ["1P 2M 3m 4P 5d 6m 6M 7M", "diminished", "whole-half diminished"],
            ["1P 2M 3m 4P 5P 6M 7m", "dorian"],
            ["1P 2M 3M 4A 5P 6M 7M", "lydian"],
            ["1P 2M 3M 4P 5P 6M 7m", "mixolydian", "dominant"],
            ["1P 2m 3m 4P 5P 6m 7m", "phrygian"],
            ["1P 2m 3m 4P 5d 6m 7m", "locrian"],
            ["1P 3M 4P 5P 7M", "ionian pentatonic"],
            ["1P 3M 4P 5P 7m", "mixolydian pentatonic", "indian"],
            ["1P 2M 4P 5P 6M", "ritusen"],
            ["1P 2M 4P 5P 7m", "egyptian"],
            ["1P 3M 4P 5d 7m", "neopolitan major pentatonic"],
            ["1P 3m 4P 5P 6m", "vietnamese 1"],
            ["1P 2m 3m 5P 6m", "pelog"],
            ["1P 2m 4P 5P 6m", "kumoijoshi"],
            ["1P 2M 3m 5P 6m", "hirajoshi"],
            ["1P 2m 4P 5d 7m", "iwato"],
            ["1P 2m 4P 5P 7m", "in-sen"],
            ["1P 3M 4A 5P 7M", "lydian pentatonic", "chinese"],
            ["1P 3m 4P 6m 7m", "malkos raga"],
            ["1P 3m 4P 5d 7m", "locrian pentatonic", "minor seven flat five pentatonic"],
            ["1P 3m 4P 5P 7m", "minor pentatonic", "vietnamese 2"],
            ["1P 3m 4P 5P 6M", "minor six pentatonic"],
            ["1P 2M 3m 5P 6M", "flat three pentatonic", "kumoi"],
            ["1P 2M 3M 5P 6m", "flat six pentatonic"],
            ["1P 2m 3M 5P 6M", "scriabin"],
            ["1P 3M 5d 6m 7m", "whole tone pentatonic"],
            ["1P 3M 4A 5A 7M", "lydian #5P pentatonic"],
            ["1P 3M 4A 5P 7m", "lydian dominant pentatonic"],
            ["1P 3m 4P 5P 7M", "minor #7M pentatonic"],
            ["1P 3m 4d 5d 7m", "super locrian pentatonic"],
            ["1P 2M 3m 4P 5P 7M", "minor hexatonic"],
            ["1P 2A 3M 5P 5A 7M", "augmented"],
            ["1P 2M 4P 5P 6M 7m", "piongio"],
            ["1P 2m 3M 4A 6M 7m", "prometheus neopolitan"],
            ["1P 2M 3M 4A 6M 7m", "prometheus"],
            ["1P 2m 3M 5d 6m 7m", "mystery #1"],
            ["1P 2m 3M 4P 5A 6M", "six tone symmetric"],
            ["1P 2M 3M 4A 5A 6A", "whole tone", "messiaen's mode #1"],
            ["1P 2m 4P 4A 5P 7M", "messiaen's mode #5"],
            ["1P 2M 3M 4P 5d 6m 7m", "locrian major", "arabian"],
            ["1P 2m 3M 4A 5P 6m 7M", "double harmonic lydian"],
            ["1P 2m 2A 3M 4A 6m 7m", "altered", "super locrian", "diminished whole tone", "pomeroy"],
            ["1P 2M 3m 4P 5d 6m 7m", "locrian #2", "half-diminished", "aeolian b5"],
            ["1P 2M 3M 4P 5P 6m 7m", "mixolydian b6", "melodic minor fifth mode", "hindu"],
            ["1P 2M 3M 4A 5P 6M 7m", "lydian dominant", "lydian b7", "overtone"],
            ["1P 2M 3M 4A 5A 6M 7M", "lydian augmented"],
            ["1P 2m 3m 4P 5P 6M 7m", "dorian b2", "phrygian #6", "melodic minor second mode"],
            ["1P 2m 3m 4d 5d 6m 7d", "ultralocrian", "superlocrian bb7", "superlocrian diminished"],
            ["1P 2m 3m 4P 5d 6M 7m", "locrian 6", "locrian natural 6", "locrian sharp 6"],
            ["1P 2A 3M 4P 5P 5A 7M", "augmented heptatonic"],
            ["1P 2M 3m 4A 5P 6M 7m", "dorian #4", "ukrainian dorian", "romanian minor", "altered dorian"],
            ["1P 2M 3m 4A 5P 6M 7M", "lydian diminished"],
            ["1P 2M 3M 4A 5A 7m 7M", "leading whole tone"],
            ["1P 2M 3M 4A 5P 6m 7m", "lydian minor"],
            ["1P 2m 3M 4P 5P 6m 7m", "phrygian dominant", "spanish", "phrygian major"],
            ["1P 2m 3m 4P 5P 6m 7M", "balinese"],
            ["1P 2m 3m 4P 5P 6M 7M", "neopolitan major"],
            ["1P 2M 3M 4P 5P 6m 7M", "harmonic major"],
            ["1P 2m 3M 4P 5P 6m 7M", "double harmonic major", "gypsy"],
            ["1P 2M 3m 4A 5P 6m 7M", "hungarian minor"],
            ["1P 2A 3M 4A 5P 6M 7m", "hungarian major"],
            ["1P 2m 3M 4P 5d 6M 7m", "oriental"],
            ["1P 2m 3m 3M 4A 5P 7m", "flamenco"],
            ["1P 2m 3m 4A 5P 6m 7M", "todi raga"],
            ["1P 2m 3M 4P 5d 6m 7M", "persian"],
            ["1P 2m 3M 5d 6m 7m 7M", "enigmatic"],
            ["1P 2M 3M 4P 5A 6M 7M", "major augmented", "major #5", "ionian augmented", "ionian #5"],
            ["1P 2A 3M 4A 5P 6M 7M", "lydian #9"],
            ["1P 2m 2M 4P 4A 5P 6m 7M", "messiaen's mode #4"],
            ["1P 2m 3M 4P 4A 5P 6m 7M", "purvi raga"],
            ["1P 2m 3m 3M 4P 5P 6m 7m", "spanish heptatonic"],
            ["1P 2M 3m 3M 4P 5P 6M 7m", "bebop minor"],
            ["1P 2M 3M 4P 5P 5A 6M 7M", "bebop major"],
            ["1P 2m 3m 4P 5d 5P 6m 7m", "bebop locrian"],
            ["1P 2M 3m 4P 5P 6m 7m 7M", "minor bebop"],
            ["1P 2M 3M 4P 5d 5P 6M 7M", "ichikosucho"],
            ["1P 2M 3m 4P 5P 6m 6M 7M", "minor six diminished"],
            ["1P 2m 3m 3M 4A 5P 6M 7m", "half-whole diminished", "dominant diminished", "messiaen's mode #2"],
            ["1P 3m 3M 4P 5P 6M 7m 7M", "kafi raga"],
            ["1P 2M 3M 4P 4A 5A 6A 7M", "messiaen's mode #6"],
            ["1P 2M 3m 3M 4P 5d 5P 6M 7m", "composite blues"],
            ["1P 2M 3m 3M 4A 5P 6m 7m 7M", "messiaen's mode #3"],
            ["1P 2m 2M 3m 4P 4A 5P 6m 6M 7M", "messiaen's mode #7"],
            ["1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M", "chromatic"]
        ],
        c0e = a0e,
        u0e = {
            ...Ia,
            intervals: [],
            aliases: []
        },
        n2 = [],
        al = {};

    function l0e() {
        return n2.map(t => t.name)
    }

    function fk(t) {
        return al[t] || u0e
    }

    function $m() {
        return n2.slice()
    }

    function h0e(t, e, n = []) {
        const r = {
            ...ko(t),
            name: e,
            intervals: t,
            aliases: n
        };
        return n2.push(r), al[r.name] = r, al[r.setNum] = r, al[r.chroma] = r, r.aliases.forEach(s => f0e(r, s)), r
    }

    function f0e(t, e) {
        al[e] = t
    }
    c0e.forEach(([t, e, ...n]) => h0e(t.split(" "), e, n));
    var yy = {
            empty: !0,
            name: "",
            symbol: "",
            root: "",
            rootDegree: 0,
            type: "",
            tonic: null,
            setNum: NaN,
            quality: "Unknown",
            chroma: "",
            normalized: "",
            aliases: [],
            notes: [],
            intervals: []
        },
        d0e = /^(6|64|7|9|11|13)$/;

    function r2(t) {
        const [e, n, r, s] = ck(t);
        return e === "" ? ["", t] : e === "A" && s === "ug" ? ["", "aug"] : !s && (r === "4" || r === "5") ? [e + n, r] : d0e.test(r) ? [e + n, r + s] : [e + n + r, s]
    }

    function $a(t) {
        if (t === "") return yy;
        if (Array.isArray(t) && t.length === 2) return td(t[1], t[0]); {
            const [e, n] = r2(t), r = td(n, e);
            return r.empty ? td(t) : r
        }
    }

    function td(t, e, n) {
        const r = Yve(t),
            s = jt(e || ""),
            i = jt(n || "");
        if (r.empty || e && s.empty || n && i.empty) return yy;
        const a = xve(s.pc, i.pc),
            c = r.intervals.indexOf(a) + 1;
        if (!i.empty && !c) return yy;
        const l = Array.from(r.intervals);
        for (let g = 1; g < c; g++) {
            const v = l[0][0],
                b = l[0][1],
                T = parseInt(v, 10) + 7;
            l.push(`${T}${b}`), l.shift()
        }
        const h = s.empty ? [] : l.map(g => Io(s, g));
        t = r.aliases.indexOf(t) !== -1 ? t : r.aliases[0];
        const d = `${s.empty?"":s.pc}${t}${i.empty||c<=1?"":"/"+i.pc}`,
            p = `${e?s.pc+" ":""}${r.name}${c>1&&n?" over "+i.pc:""}`;
        return {
            ...r,
            name: p,
            symbol: d,
            type: r.name,
            root: i.name,
            intervals: l,
            rootDegree: c,
            tonic: s.name,
            notes: h
        }
    }
    var p0e = ek("Chord.chord", "Chord.get", $a);

    function m0e(t, e) {
        const [n, r] = r2(t);
        return n ? Io(n, e) + r : t
    }

    function g0e(t) {
        const e = $a(t),
            n = e2(e.chroma);
        return $m().filter(r => n(r.chroma)).map(r => r.name)
    }

    function _0e(t) {
        const e = $a(t),
            n = e2(e.chroma);
        return Rm().filter(r => n(r.chroma)).map(r => e.tonic + r.aliases[0])
    }

    function y0e(t) {
        const e = $a(t),
            n = J0(e.chroma);
        return Rm().filter(r => n(r.chroma)).map(r => e.tonic + r.aliases[0])
    }

    function v0e(t) {
        const {
            intervals: e,
            tonic: n
        } = $a(t), r = Pm(e, n);
        return s => s ? r(s > 0 ? s - 1 : s) : ""
    }

    function b0e(t) {
        const {
            intervals: e,
            tonic: n
        } = $a(t);
        return Pm(e, n)
    }
    var vy = {
        getChord: td,
        get: $a,
        detect: Jve,
        chordScales: g0e,
        extended: _0e,
        reduced: y0e,
        tokenize: r2,
        transpose: m0e,
        degrees: v0e,
        steps: b0e,
        chord: p0e
    };

    function dk(t) {
        return +t >= 0 && +t <= 127
    }

    function E0e(t) {
        if (dk(t)) return +t;
        const e = jt(t);
        return e.empty ? null : e.midi
    }

    function S0e(t, e = 440) {
        return Math.pow(2, (t - 69) / 12) * e
    }
    var T0e = Math.log(2),
        w0e = Math.log(440);

    function s2(t) {
        const e = 12 * (Math.log(t) - w0e) / T0e + 69;
        return Math.round(e * 100) / 100
    }
    var O0e = "C C# D D# E F F# G G# A A# B".split(" "),
        A0e = "C Db D Eb E F Gb G Ab A Bb B".split(" ");

    function La(t, e = {}) {
        if (isNaN(t) || t === -1 / 0 || t === 1 / 0) return "";
        t = Math.round(t);
        const r = (e.sharps === !0 ? O0e : A0e)[t % 12];
        if (e.pitchClass) return r;
        const s = Math.floor(t / 12) - 1;
        return r + s
    }

    function i2(t) {
        return t % 12
    }

    function C0e(t) {
        return t.split("").reduce((e, n, r) => (r < 12 && n === "1" && e.push(r), e), [])
    }

    function I0e(t) {
        return t.map(i2).sort((e, n) => e - n).filter((e, n, r) => n === 0 || e !== r[n - 1])
    }

    function o2(t) {
        return Array.isArray(t) ? I0e(t) : C0e(t)
    }

    function k0e(t) {
        const e = o2(t);
        return n => {
            const r = i2(n);
            for (let s = 0; s < 12; s++) {
                if (e.includes(r + s)) return n + s;
                if (e.includes(r - s)) return n - s
            }
        }
    }

    function pk(t, e) {
        const n = o2(t),
            r = n.length;
        return s => {
            const i = s < 0 ? (r - -s % r) % r : s % r,
                a = Math.floor(s / r);
            return n[i] + a * 12 + e
        }
    }

    function N0e(t, e) {
        const n = pk(t, e);
        return r => {
            if (r !== 0) return n(r > 0 ? r - 1 : r)
        }
    }
    var x0e = {
            chroma: i2,
            freqToMidi: s2,
            isMidi: dk,
            midiToFreq: S0e,
            midiToNoteName: La,
            pcsetNearest: k0e,
            pcset: o2,
            pcsetDegrees: N0e,
            pcsetSteps: pk,
            toMidi: E0e
        },
        P0e = ["C", "D", "E", "F", "G", "A", "B"],
        mk = t => t.name,
        gk = t => t.map(jt).filter(e => !e.empty);

    function R0e(t) {
        return t === void 0 ? P0e.slice() : Array.isArray(t) ? gk(t).map(mk) : []
    }
    var Ns = jt,
        M0e = t => Ns(t).name,
        D0e = t => Ns(t).pc,
        $0e = t => Ns(t).acc,
        L0e = t => Ns(t).oct,
        F0e = t => Ns(t).midi,
        U0e = t => Ns(t).freq,
        B0e = t => Ns(t).chroma;

    function _k(t) {
        return La(t)
    }

    function q0e(t) {
        return La(s2(t))
    }

    function V0e(t) {
        return La(s2(t), {
            sharps: !0
        })
    }

    function j0e(t) {
        return La(t, {
            sharps: !0
        })
    }
    var Th = Io,
        G0e = Io,
        yk = t => e => Th(e, t),
        W0e = yk,
        vk = t => e => Th(t, e),
        H0e = vk;

    function bk(t, e) {
        return Th(t, [e, 0])
    }
    var K0e = bk;

    function Y0e(t, e) {
        return Th(t, [0, e])
    }
    var a2 = (t, e) => t.height - e.height,
        z0e = (t, e) => e.height - t.height;

    function Ek(t, e) {
        return e = e || a2, gk(t).sort(e).map(mk)
    }

    function Sk(t) {
        return Ek(t, a2).filter((e, n, r) => n === 0 || e !== r[n - 1])
    }
    var Z0e = t => {
        const e = Ns(t);
        return e.empty ? "" : La(e.midi || e.chroma, {
            sharps: e.alt > 0,
            pitchClass: e.midi === null
        })
    };

    function Tk(t, e) {
        const n = Ns(t);
        if (n.empty) return "";
        const r = Ns(e || La(n.midi || n.chroma, {
            sharps: n.alt < 0,
            pitchClass: !0
        }));
        if (r.empty || r.chroma !== n.chroma) return "";
        if (n.oct === void 0) return r.pc;
        const s = n.chroma - n.alt,
            i = r.chroma - r.alt,
            a = s > 11 || i < 0 ? -1 : s < 0 || i > 11 ? 1 : 0,
            c = n.oct + a;
        return r.pc + c
    }
    var by = {
            names: R0e,
            get: Ns,
            name: M0e,
            pitchClass: D0e,
            accidentals: $0e,
            octave: L0e,
            midi: F0e,
            ascending: a2,
            descending: z0e,
            sortedNames: Ek,
            sortedUniqNames: Sk,
            fromMidi: _k,
            fromMidiSharps: j0e,
            freq: U0e,
            fromFreq: q0e,
            fromFreqSharps: V0e,
            chroma: B0e,
            transpose: Th,
            tr: G0e,
            transposeBy: yk,
            trBy: W0e,
            transposeFrom: vk,
            trFrom: H0e,
            transposeFifths: bk,
            transposeOctaves: Y0e,
            trFifths: K0e,
            simplify: Z0e,
            enharmonic: Tk
        },
        c2 = [
            [0, 2773, 0, "ionian", "", "Maj7", "major"],
            [1, 2902, 2, "dorian", "m", "m7"],
            [2, 3418, 4, "phrygian", "m", "m7"],
            [3, 2741, -1, "lydian", "", "Maj7"],
            [4, 2774, 1, "mixolydian", "", "7"],
            [5, 2906, 3, "aeolian", "m", "m7", "minor"],
            [6, 3434, 5, "locrian", "dim", "m7b5"]
        ],
        r5 = {
            ...Ia,
            name: "",
            alt: 0,
            modeNum: NaN,
            triad: "",
            seventh: "",
            aliases: []
        },
        X0e = c2.map(Q0e),
        Ey = {};
    X0e.forEach(t => {
        Ey[t.name] = t, t.aliases.forEach(e => {
            Ey[e] = t
        })
    });

    function wk(t) {
        return typeof t == "string" ? Ey[t.toLowerCase()] || r5 : t && t.name ? wk(t.name) : r5
    }

    function Q0e(t) {
        const [e, n, r, s, i, a, c] = t, l = c ? [c] : [], h = Number(n).toString(2);
        return {
            empty: !1,
            intervals: fk(s).intervals,
            modeNum: e,
            chroma: h,
            normalized: h,
            name: s,
            setNum: n,
            alt: r,
            triad: i,
            seventh: a,
            aliases: l
        }
    }

    function Ok(t) {
        return (e, n) => {
            const r = wk(e);
            if (r.empty) return [];
            const s = Sh(r.modeNum, t),
                i = r.intervals.map(a => Io(n, a));
            return s.map((a, c) => i[c] + a)
        }
    }
    Ok(c2.map(t => t[4]));
    Ok(c2.map(t => t[5]));
    var J0e = {
        empty: !0,
        name: "",
        type: "",
        tonic: null,
        setNum: NaN,
        chroma: "",
        normalized: "",
        aliases: [],
        notes: [],
        intervals: []
    };

    function Ak(t) {
        if (typeof t != "string") return ["", ""];
        const e = t.indexOf(" "),
            n = jt(t.substring(0, e));
        if (n.empty) {
            const s = jt(t);
            return s.empty ? ["", t] : [s.name, ""]
        }
        const r = t.substring(n.name.length + 1);
        return [n.name, r.length ? r : ""]
    }
    var e2e = l0e;

    function ri(t) {
        const e = Array.isArray(t) ? t : Ak(t),
            n = jt(e[0]).name,
            r = fk(e[1]);
        if (r.empty) return J0e;
        const s = r.name,
            i = n ? r.intervals.map(c => Io(n, c)) : [],
            a = n ? n + " " + s : s;
        return {
            ...r,
            name: a,
            type: s,
            tonic: n,
            notes: i
        }
    }
    var t2e = ek("Scale.scale", "Scale.get", ri);

    function n2e(t, e = {}) {
        const n = Uve(t),
            r = jt(e.tonic ?? t[0] ?? ""),
            s = r.chroma;
        if (s === void 0) return [];
        const i = n.split("");
        i[s] = "1";
        const a = Sh(s, i).join(""),
            c = $m().find(h => h.chroma === a),
            l = [];
        return c && l.push(r.name + " " + c.name), e.match === "exact" || Ck(a).forEach(h => {
            l.push(r.name + " " + h)
        }), l
    }

    function r2e(t) {
        const e = ri(t),
            n = J0(e.chroma);
        return Rm().filter(r => n(r.chroma)).map(r => r.aliases[0])
    }

    function Ck(t) {
        const e = Q0(t) ? t : ri(t).chroma,
            n = e2(e);
        return $m().filter(r => n(r.chroma)).map(r => r.name)
    }

    function s2e(t) {
        const e = J0(ri(t).chroma);
        return $m().filter(n => e(n.chroma)).map(n => n.name)
    }

    function Ik(t) {
        const e = t.map(s => jt(s).pc).filter(s => s),
            n = e[0],
            r = Sk(e);
        return Sh(r.indexOf(n), r)
    }

    function i2e(t) {
        const e = ri(t);
        if (e.empty) return [];
        const n = e.tonic ? e.notes : e.intervals;
        return hk(e.chroma).map((r, s) => {
            const i = ri(r).name;
            return i ? [n[s], i] : ["", ""]
        }).filter(r => r[0])
    }

    function o2e(t) {
        const e = Array.isArray(t) ? Ik(t) : ri(t).notes,
            n = e.map(r => jt(r).chroma);
        return r => {
            const s = jt(typeof r == "number" ? _k(r) : r),
                i = s.height;
            if (i === void 0) return;
            const a = i % 12,
                c = n.indexOf(a);
            if (c !== -1) return Tk(s.name, e[c])
        }
    }

    function a2e(t) {
        const e = o2e(t);
        return (n, r) => {
            const s = jt(n).height,
                i = jt(r).height;
            return s === void 0 || i === void 0 ? [] : Mve(s, i).map(e).filter(a => a)
        }
    }

    function c2e(t) {
        const {
            intervals: e,
            tonic: n
        } = ri(t), r = Pm(e, n);
        return s => s ? r(s > 0 ? s - 1 : s) : ""
    }

    function u2e(t) {
        const {
            intervals: e,
            tonic: n
        } = ri(t);
        return Pm(e, n)
    }
    var s5 = {
        degrees: c2e,
        detect: n2e,
        extended: Ck,
        get: ri,
        modeNames: i2e,
        names: e2e,
        rangeOf: a2e,
        reduced: s2e,
        scaleChords: r2e,
        scaleNotes: Ik,
        steps: u2e,
        tokenize: Ak,
        scale: t2e
    };
    class Sy {
        static getChordNameFromMidi(e) {
            const n = e.sort().map(r => by.fromMidi(r));
            return this.getChordNameFromNotes(n)
        }
        static getChordNameFromFrequencies(e) {
            const n = e.sort().map(r => by.fromFreq(r));
            return this.getChordNameFromNotes(n)
        }
        static getChordNameFromNotes(e, n = "Unknown") {
            const r = [],
                s = vy.detect(e);
            if (!s.length) return [e.join("").replace(/[0-9]/g, "").toLowerCase()];
            r.push(s[0]);
            let i = s[0];
            const a = s[0].split("/");
            a.length > 1 && (i = a[0], r.push(i));
            const c = vy.get(i);
            if (c.quality === "Major") r.push(`${c.tonic}`);
            else if (c.quality === "Minor") r.push(`${c.tonic}m`);
            else if (c.quality === "Diminished") {
                r.push(`${c.tonic}m`);
                const h = c.intervals.findIndex(d => d.includes("3"));
                h !== -1 && r.push(`${c.notes[h]}m`)
            } else if (c.type === "fifth") r.push(`${c.tonic}m`);
            else if (c.type === "minor augmented") {
                const h = c.intervals.findIndex(d => d.includes("5A"));
                h !== -1 && r.push(`${c.notes[h]}`)
            } else if (c.type === "augmented") {
                const h = c.intervals.findIndex(d => d.includes("3"));
                h !== -1 && r.push(`${c.notes[h]}`)
            }
            return n === "Major" ? r.push(`${c.tonic}`) : n === "Minor" && r.push(`${c.tonic}m`), r.map(h => (h = h.replace(/M/g, "").replace(/\//g, "|").toLowerCase(), this.desharp(h)))
        }
        static desharp(e) {
            const n = e.indexOf("#");
            if (n === -1) return e;
            if (e.indexOf("##") !== -1) switch (e[n - 1]) {
                case "a":
                    return e.replace("a##", "b");
                case "b":
                    return e.replace("b##", "db");
                case "c":
                    return e.replace("c##", "d");
                case "d":
                    return e.replace("d##", "e");
                case "e":
                    return e.replace("e##", "gb");
                case "f":
                    return e.replace("f##", "g");
                case "g":
                    return e.replace("g##", "a")
            }
            switch (e[n - 1]) {
                case "a":
                    return e.replace("a#", "bb");
                case "b":
                    return e.replace("b#", "c");
                case "c":
                    return e.replace("c#", "db");
                case "d":
                    return e.replace("d#", "eb");
                case "e":
                    return e.replace("e#", "f");
                case "f":
                    return e.replace("f#", "gb");
                case "g":
                    return e.replace("g#", "gb")
            }
            return e
        }
        static getRandomNumber(e, n) {
            return Math.floor(Math.random() * (n - e + 1) + e)
        }
        static getNotesInScale(e, n) {
            const r = s5.get(e);
            return n.map(s => {
                const i = s === 8 ? s5.degrees(r.name)(8) : r.notes[s - 1];
                return x0e.toMidi(i) ?? 60
            })
        }
    }
    class Ls {
        constructor(e, n) {
            this.notes = new Set, this.isMidiKeyed = !0, this.rotationType = n.rotationType ?? "serial", n.isHarmonic && (this.isMidiKeyed = !1);
            let r;
            Array.isArray(e) ? (this.isMidiKeyed = !1, r = {
                samples: e
            }) : r = e;
            const s = new Map,
                i = {};
            Object.keys(r).forEach(a => {
                const c = [];
                let l;
                if (this.isMidiKeyed) {
                    const h = Vd(a).toMidi();
                    this.notes.add(h), l = `${h}`
                } else l = a.toLowerCase();
                r[a].forEach((h, d) => {
                    i[`${l}:${d}`] = h, i[`${l}:${d}`] = h, c.push(`${l}:${d}`)
                }), s.set(l, {
                    nextIndex: this.rotationType === "serial" ? 0 : Sy.getRandomNumber(0, c.length - 1),
                    bufferKeys: c
                })
            }), this.groupMap = s, this.buffers = new bh({
                urls: i,
                onload: n.onload,
                baseUrl: n.baseUrl,
                onerror: n.onerror
            })
        }
        get loaded() {
            return this.buffers.loaded
        }
        findClosest(e) {
            if (!this.isMidiKeyed) return e;
            const n = 96;
            let r = 0;
            for (; r < n;) {
                if (this.notes.has(e + r)) return -r;
                if (this.notes.has(e - r)) return r;
                r += 1
            }
            return e
        }
        get(e) {
            e === void 0 && (e = "samples"), typeof e == "number" && (e = `${e}`);
            const n = this.groupMap.get(e);
            if (!n) return;
            const r = n.bufferKeys[n.nextIndex];
            return r ? (this.rotationType === "random" ? n.nextIndex = Sy.getRandomNumber(0, n.bufferKeys.length - 1) : n.nextIndex = n.nextIndex === n.bufferKeys.length - 1 ? 0 : n.nextIndex + 1, this.buffers.get(r)) : void 0
        }
        keys() {
            return Array.from(this.groupMap.keys())
        }
        has(e) {
            return !this.isMidiKeyed || e === void 0 ? !0 : (typeof e == "number" && (e = `${e}`), this.groupMap.has(e))
        }
        dispose() {
            this.buffers.dispose()
        }
        static transformSampleMap(e) {
            const n = {};
            return Object.keys(e.urls).forEach(r => {
                var s, i;
                (s = e.notes) != null && s.length && !e.notes.includes(r) || (i = e.chords) != null && i.length && !e.chords.includes(r) || (n[r] = e.urls[r].map(a => this.transformUrl(a, e.baseUrl, e.ext)))
            }), n
        }
        static transformSampleObject(e) {
            const n = {};
            return Object.keys(e.urls).forEach(r => {
                e.notes && !e.notes.includes(r) || e.chords && !e.chords.includes(r) || (n[r] = this.transformUrl(e.urls[r], e.baseUrl, e.ext))
            }), n
        }
        static transformSampleArray(e) {
            return e.urls.map(n => this.transformUrl(n, e.baseUrl, e.ext))
        }
        static transformUrl(e, n, r) {
            return r || (r = It.supportsType("ogg") ? "ogg" : "mp3"), e.includes(`.${r}`) ? `${n}/${e}` : `${n}/${e}.${r}`
        }
    }
    class Wl extends ks {
        constructor() {
            super(J(Wl.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "OneShotSampler", this.activeSources = new Map;
            const e = J(Wl.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
            this.buffers = new Ls(e.urls, {
                rotationType: e.rotationType,
                baseUrl: e.baseUrl,
                onload: e.onload,
                onerror: e.onerror
            }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this.isPitchLocked = e.pitchLocked ?? !1, this.restrictToSingleNotes = e.restrictToSingleNotes ?? !1, this.buffers.loaded && Promise.resolve().then(e.onload)
        }
        get loaded() {
            return this.buffers.loaded
        }
        static getDefaults() {
            return Object.assign(ks.getDefaults(), {
                attack: 0,
                baseUrl: "",
                curve: "exponential",
                onload: ft,
                onerror: ft,
                release: .1,
                pitchLocked: !1,
                restrictToSingleNotes: !1,
                rotationType: "serial",
                urls: {}
            })
        }
        triggerAttack(e, n) {
            return Array.isArray(e) || (e = [e]), this.restrictToSingleNotes && e.length > 1 ? this : (e.forEach(r => {
                const s = km(new Gn(this.context, r).toFrequency()),
                    i = Math.round(s),
                    a = s - i,
                    c = this.buffers.findClosest(i);
                if (c === null) return;
                const l = i - c,
                    h = Oa(c + a),
                    d = this.buffers.get(l);
                if (!d) return;
                const p = new Js({
                    url: d,
                    context: this.context,
                    curve: this.curve,
                    playbackRate: this.isPitchLocked ? 1 : h,
                    fadeIn: this.attack,
                    fadeOut: this.release,
                    onended: () => {
                        this.onSourceEnded(i)
                    },
                    loop: !1
                }).connect(this.output);
                p.start(n, 0), this.activeSources.set(i, p)
            }), this)
        }
        triggerAttackRelease(e, n, r) {
            const s = this.toSeconds(r);
            return this.triggerAttack(e, s), this.triggerRelease(s + this.toSeconds(n)), this
        }
        triggerRelease(e, n) {
            return Array.isArray(e) || (e = [e]), this.restrictToSingleNotes && e.length > 1 ? this : (e.forEach(r => {
                const s = new Gn(this.context, r).toMidi(),
                    i = this.activeSources.get(s);
                i && (n ? i.stop(this.toSeconds(n)) : i.stop(this.now()), this.activeSources.delete(s))
            }), this)
        }
        onSourceEnded(e) {
            const n = this.activeSources.get(e);
            n && (n.stop(this.now()), this.activeSources.delete(e))
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
        }
        dispose() {
            return super.dispose(), this.buffers.dispose(), this.activeSources.forEach(e => e.dispose()), this.activeSources.clear(), this
        }
    }
    const dc = class dc {
        constructor(e, n) {
            this.isPlayable = !0, e.urls = this.convertDrumRackKeys(e.urls), n.baseUrl && (e.urls = Ls.transformSampleMap({
                urls: e.urls,
                baseUrl: n.baseUrl,
                ext: n.ext
            })), this.node = new Wl(e)
        }
        attack(e) {
            this.node.triggerAttack(e)
        }
        oneShot(e, n) {
            n ? this.node.triggerAttackRelease(e, n) : this.node.triggerAttack(e)
        }
        release(e) {
            this.node.triggerRelease(e)
        }
        convertDrumRackKeys(e) {
            const n = {};
            return Object.keys(e).forEach(r => {
                dc.keyToNoteMap[r] ? n[dc.keyToNoteMap[r]] = e[r] : n[r] = e[r]
            }), n
        }
    };
    dc.keys = ["kick", "rim", "snare", "sidestick", "rimshot", "pedalhh", "closedhh", "floortom", "mediumhh", "lowtom", "openhh", "midtom", "hitom", "crash", "ride", "click"], dc.keyToNoteMap = {
        kick: "c2",
        rim: "db2",
        snare: "d2",
        sidestick: "eb2",
        rimshot: "e2",
        pedalhh: "f2",
        closedhh: "gb2",
        floortom: "g2",
        mediumhh: "ab2",
        lowtom: "a2",
        openhh: "bb2",
        midtom: "b2",
        hitom: "c3",
        crash: "d3",
        ride: "eb3",
        click: "g3"
    };
    let Ty = dc;
    class l2e {
        constructor(e) {
            this.isPlayable = !0, this.node = new Xd(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class wp extends ks {
        constructor() {
            super(J(wp.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "FlubSampler", this.activeSources = new Set;
            const e = J(wp.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
            this.buffers = new Ls(e.urls, {
                rotationType: e.rotationType,
                baseUrl: e.baseUrl,
                onload: e.onload,
                onerror: e.onerror
            }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this.buffers.loaded && Promise.resolve().then(e.onload)
        }
        get loaded() {
            return this.buffers.loaded
        }
        static getDefaults() {
            return Object.assign(ks.getDefaults(), {
                attack: 0,
                baseUrl: "",
                curve: "exponential",
                onload: ft,
                onerror: ft,
                release: .1,
                rotationType: "serial",
                urls: []
            })
        }
        triggerAttack(e) {
            const n = this.buffers.get();
            if (!n) return this;
            const r = new Js({
                url: n,
                context: this.context,
                curve: this.curve,
                fadeIn: this.attack,
                fadeOut: this.release,
                onended: s => this.activeSources.delete(s)
            }).connect(this.output);
            return r.start(e, 0), this.activeSources.add(r), this
        }
        triggerAttackRelease() {
            return this
        }
        triggerRelease() {
            return this
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
        }
        dispose() {
            return super.dispose(), this.buffers.dispose(), this.activeSources.forEach(e => e.dispose()), this.activeSources.clear(), this
        }
    }
    class h2e {
        constructor(e, n) {
            this.isPlayable = !0, n.baseUrl && (e.urls = Ls.transformSampleArray({
                urls: e.urls,
                baseUrl: n.baseUrl,
                ext: n.ext
            })), this.node = new wp(e)
        }
        attack() {
            this.node.triggerAttack()
        }
        oneShot() {
            this.node.triggerAttack()
        }
        release() {
            this.node.triggerRelease()
        }
    }
    class f2e {
        constructor(e) {
            this.isPlayable = !0, this.node = new Dl(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class Op extends ks {
        constructor() {
            super(J(Op.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "HarmonicSampler";
            const e = J(Op.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
            this.buffers = new Ls(e.urls, {
                isHarmonic: !0,
                rotationType: e.rotationType,
                baseUrl: e.baseUrl,
                onload: e.onload,
                onerror: e.onerror
            }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this.buffers.loaded && Promise.resolve().then(e.onload)
        }
        get loaded() {
            return this.buffers.loaded
        }
        static getDefaults() {
            return Object.assign(ks.getDefaults(), {
                attack: 0,
                baseUrl: "",
                curve: "exponential",
                onload: ft,
                onerror: ft,
                release: .1,
                rotationType: "serial",
                urls: {}
            })
        }
        triggerAttack(e, n) {
            if (!Array.isArray(e)) return this;
            let r;
            const s = Sy.getChordNameFromFrequencies(e);
            for (let i = 0; i < s.length && (r = this.buffers.get(s[i]), !r); i++);
            if (!r) {
                const i = e.sort().map(a => by.fromFreq(a));
                return console.warn("Buffer not found", s, vy.detect(i), i), this
            }
            return this.activeSource && (this.activeSource.stop(), this.disposeActiveSource()), this.activeSource = new Js({
                url: r,
                context: this.context,
                curve: this.curve,
                fadeIn: this.attack,
                fadeOut: this.release,
                loop: !1
            }).connect(this.output), this.activeSource.start(n, 0), this
        }
        triggerAttackRelease(e, n, r) {
            const s = this.toSeconds(r);
            return this.triggerAttack(e, s), this.triggerRelease(s + this.toSeconds(n)), this
        }
        triggerRelease(e, n) {
            return Array.isArray(e) ? this.activeSource ? (n ? this.activeSource.stop(this.toSeconds(n)) : this.activeSource.stop(this.now()), delete this.activeSource, this) : this : this
        }
        disposeActiveSource() {
            this.activeSource && (this.activeSource.dispose(), delete this.activeSource)
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
        }
        dispose() {
            return super.dispose(), this.buffers.dispose(), this.disposeActiveSource(), this
        }
    }
    class d2e {
        constructor(e, n) {
            this.isPlayable = !0, n.baseUrl && (e.urls = Ls.transformSampleMap({
                urls: e.urls,
                baseUrl: n.baseUrl,
                ext: n.ext
            })), this.node = new Op(e)
        }
        attack(e) {
            this.node.triggerAttack(e)
        }
        oneShot(e, n = .25) {
            this.node.triggerAttackRelease(e, n)
        }
        release(e) {
            this.node.triggerRelease(e)
        }
    }
    class p2e {
        constructor(e) {
            this.isPlayable = !0, this.node = new Hc(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class m2e {
        constructor(e) {
            this.isPlayable = !0, this.node = new Qd(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class g2e {
        constructor(e) {
            this.isPlayable = !0, this.node = new Ci(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class _2e {
        constructor(e) {
            this.isPlayable = !0, this.node = new Jd(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class y2e {
        constructor(e, n) {
            this.isPlayable = !0;
            let r;
            n.notes && (r = n.notes.map(s => Vd(s, "midi").toNote())), n.baseUrl && (e.urls = Ls.transformSampleMap({
                urls: e.urls,
                baseUrl: n.baseUrl,
                ext: n.ext,
                notes: r
            })), this.node = new Wl(e)
        }
        attack(e) {
            this.node.triggerAttack(e)
        }
        oneShot(e, n) {
            n ? this.node.triggerAttackRelease(e, n) : this.node.triggerAttack(e)
        }
        release(e) {
            this.node.triggerRelease(e)
        }
    }
    class v2e {
        constructor(e, n) {
            this.isPlayable = !0, n.baseUrl && (e.url = Ls.transformUrl(e.url, n.baseUrl, n.ext)), this.node = new Aa(e)
        }
        attack(e) {
            this.node.start()
        }
        oneShot(e, n = .25) {
            this.node.start(), window.setTimeout(() => {
                this.node.stop()
            }, n * 1e3)
        }
        release(e) {
            this.node.stop()
        }
    }
    class b2e {
        constructor(e) {
            this.isPlayable = !0, this.node = new ep(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class E2e {
        constructor(e) {
            this.isPlayable = !0, this.node = this.getNode(e)
        }
        getNode(e) {
            return e.voice.type === "amSynth" ? new fa({
                voice: xm,
                maxPolyphony: e.maxPolyphony ?? 12,
                options: e.voice.options
            }) : e.voice.type === "fmSynth" ? new fa({
                voice: Dl,
                maxPolyphony: e.maxPolyphony ?? 12,
                options: e.voice.options
            }) : e.voice.type === "monoSynth" ? new fa({
                voice: Ci,
                maxPolyphony: e.maxPolyphony ?? 12,
                options: e.voice.options
            }) : new fa({
                voice: ti,
                maxPolyphony: e.maxPolyphony ?? 12,
                options: e.voice.options
            })
        }
        attack(e) {
            this.node.triggerAttack(e)
        }
        oneShot(e, n = .25) {
            this.node.triggerAttackRelease(e, n)
        }
        release(e) {
            this.node.triggerRelease(e)
        }
    }
    class S2e {
        constructor(e, n) {
            this.isPlayable = !0, n.baseUrl && (e.urls = Ls.transformSampleObject({
                urls: e.urls,
                baseUrl: n.baseUrl,
                ext: n.ext
            })), this.node = new Kc(e)
        }
        attack(e) {
            this.node.triggerAttack(e)
        }
        oneShot(e, n = .25) {
            this.node.triggerAttackRelease(e, n)
        }
        release(e) {
            this.node.triggerRelease(e)
        }
    }
    class T2e {
        constructor(e) {
            this.isPlayable = !1, this.node = this.getNode(e)
        }
        getNode(e) {
            switch (e.type) {
                case "compressor":
                    return new vo(e.options);
                case "eq3":
                    return new Sp(e.options);
                case "filter":
                    return new wr(e.options);
                case "gate":
                    return new vp(e.options);
                case "limiter":
                    return new bp(e.options);
                case "multibandCompressor":
                    return new Ep(e.options);
                case "panVol":
                    return new Xc(e.options);
                case "panner":
                    return new zc(e.options);
                case "volume":
                    return new Qs(e.options);
                case "autoFilter":
                    return new Ul(e.options);
                case "autoPanner":
                    return new Bl(e.options);
                case "autoWah":
                    return new np(e.options);
                case "bitCrusher":
                    return new rp(e.options);
                case "chebyshev":
                    return new ip(e.options);
                case "chorus":
                    return new op(e.options);
                case "distortion":
                    return new ap(e.options);
                case "feedbackDelay":
                    return new up(e.options);
                case "freeverb":
                    return new hp(e.options);
                case "frequencyShifter":
                    return new lp(e.options);
                case "jcReverb":
                    return new fp(e.options);
                case "phaser":
                    return new mp(e.options);
                case "pingPongDelay":
                    return new dp(e.options);
                case "pitchShift":
                    return new pp(e.options);
                case "reverb":
                    return new gp(e.options);
                case "stereoWidener":
                    return new _p(e.options);
                case "tremolo":
                    return new Vl(e.options);
                case "vibrato":
                    return new yp(e.options);
                default:
                    throw new Error(`Unknown static node type ${e.type}`)
            }
        }
    }
    class Ap extends ks {
        constructor() {
            super(J(Ap.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls")), this.name = "SustainSampler";
            const e = J(Ap.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
            this.buffers = new Ls(e.urls, {
                rotationType: e.rotationType,
                baseUrl: e.baseUrl,
                onload: e.onload,
                onerror: e.onerror
            }), this.attack = e.attack, this.release = e.release, this.curve = e.curve, this.legato = e.legato, this.buffers.loaded && Promise.resolve().then(e.onload)
        }
        static getDefaults() {
            return Object.assign(ks.getDefaults(), {
                attack: 0,
                baseUrl: "",
                curve: "exponential",
                legato: !1,
                onload: ft,
                onerror: ft,
                release: .1,
                rotationType: "serial",
                urls: {}
            })
        }
        triggerAttack(e, n) {
            var p;
            const r = km(new Gn(this.context, e).toFrequency());
            if (this.activeSource && this.activeNote && !this.legato) {
                const g = r - this.activeNote,
                    v = this.buffers.findClosest(this.activeNote);
                if (v === null) return this;
                const b = Oa(v + g);
                return this.activeSource.playbackRate.value = b, this
            }
            const s = Math.round(r),
                i = r - s,
                a = this.buffers.findClosest(s);
            if (a === null) return this;
            const c = Oa(a + i),
                l = s - a;
            if (this.legato) {
                if (l === this.activeNote) return this;
                (p = this.activeSource) == null || p.stop(this.now())
            }
            const h = this.buffers.get(l);
            if (!h) return this;
            const d = new Js({
                url: h,
                context: this.context,
                curve: this.curve,
                fadeIn: this.attack,
                fadeOut: this.release,
                loop: !1,
                playbackRate: c
            }).connect(this.output);
            return d.start(n, 0), this.activeSource = d, this.activeNote = l, this
        }
        triggerAttackRelease(e, n, r) {
            return this
        }
        triggerUpdate(e, n) {
            return this.triggerAttack(e, n), this
        }
        triggerRelease(e) {
            return this.activeSource ? (e ? this.activeSource.stop(this.toSeconds(e)) : this.activeSource.stop(this.now()), delete this.activeSource, delete this.activeNote, this) : this
        }
        sync() {
            return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this
        }
        dispose() {
            var e;
            return super.dispose(), this.buffers.dispose(), (e = this.activeSource) == null || e.dispose(), this
        }
    }
    class w2e {
        constructor(e, n) {
            this.isPlayable = !0, n.baseUrl && (e.urls = Ls.transformSampleMap({
                urls: e.urls,
                baseUrl: n.baseUrl,
                ext: n.ext
            })), this.node = new Ap(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class O2e {
        constructor(e) {
            this.isPlayable = !0, this.node = new ti(e)
        }
        attack(e) {
            e.length && this.node.triggerAttack(e[0])
        }
        oneShot(e, n = .25) {
            e.length && this.node.triggerAttackRelease(e[0], n)
        }
        update(e) {
            e.length && (this.node.frequency.value = e[0])
        }
        release(e) {
            this.node.triggerRelease()
        }
    }
    class A2e {
        constructor(e) {
            this.isPlayable = !1;
            const n = new as(e.frequency || 440, e.type || "sine"),
                r = new Vl(e).start();
            n.connect(r), this.node = r
        }
    }
    class Vu {
        constructor(e, n) {
            this.nodes = [], this.duration = n.duration ?? .25, e.forEach(r => {
                if (r.isDisabled) return;
                const s = this.getNode(r, n);
                this.nodes.push(s), this.isPlayableNode(s) && (this.playable = s)
            }), this.connectNodes()
        }
        get inNode() {
            return this.nodes[0]
        }
        get outNode() {
            return this.nodes[this.nodes.length - 1]
        }
        isPlayableNode(e) {
            return e.attack !== void 0
        }
        getNode(e, n) {
            switch (e.type) {
                case "amSynth":
                    return new uve(e.options);
                case "autoFilter":
                    return new lve(e.options);
                case "autoPanner":
                    return new hve(e.options);
                case "drumRackSampler":
                    return new Ty(e.options, n);
                case "duoSynth":
                    return new l2e(e.options);
                case "flubSampler":
                    return new h2e(e.options, n);
                case "fmSynth":
                    return new f2e(e.options);
                case "harmonicSampler":
                    return new d2e(e.options, n);
                case "membraneSynth":
                    return new p2e(e.options);
                case "metalSynth":
                    return new m2e(e.options);
                case "monoSynth":
                    return new g2e(e.options);
                case "noiseSynth":
                    return new _2e(e.options);
                case "oneShotSampler":
                    return new y2e(e.options, n);
                case "player":
                    return new v2e(e.options, n);
                case "pluckSynth":
                    return new b2e(e.options);
                case "polySynth":
                    return new E2e(e.options);
                case "sampler":
                    return new S2e(e.options, n);
                case "sustainSampler":
                    return new w2e(e.options, n);
                case "synth":
                    return new O2e(e.options);
                case "tremolo":
                    return new A2e(e.options);
                default:
                    return new T2e(e)
            }
        }
        connectNodes() {
            this.nodes.forEach((e, n) => {
                n !== this.nodes.length - 1 && e.node.connect(this.nodes[n + 1].node)
            })
        }
        attack(e) {
            var n;
            (n = this.playable) != null && n.attack && this.playable.attack(e)
        }
        oneShot(e, n) {
            var r;
            (r = this.playable) != null && r.oneShot && this.playable.oneShot(e, n)
        }
        update(e) {
            var n;
            (n = this.playable) != null && n.update && this.playable.update(e)
        }
        release(e) {
            var n;
            (n = this.playable) != null && n.release && this.playable.release(e)
        }
    }
    class u2 {
        constructor(e = {}) {
            this.attackChains = [], this.mainChains = [], this.releaseChains = [], this.flubChains = [], this.activeFrequency = null, this.activeInputs = new Map, this.outNode = new Xc, this.settings = {
                baseUrl: null,
                ext: null,
                chords: [],
                config: null,
                notes: [],
                isOneShot: !1,
                noFlubs: !1
            }, this.continuous = {
                attack: (n, r = 48, s = 60) => {
                    this.activeFrequency === null && (n = this.normalizeSignal(n), this.activeFrequency = this.signalToFrequency(n, r, s), this.attackChains.forEach(i => i.oneShot([this.activeFrequency], i.duration)), this.mainChains.forEach(i => i.attack([this.activeFrequency])))
                },
                update: (n, r = 48, s = 60) => {
                    this.activeFrequency !== null && (n = this.normalizeSignal(n), this.activeFrequency = this.signalToFrequency(n, r, s), this.mainChains.forEach(i => i.update([this.activeFrequency])))
                },
                release: () => {
                    this.activeFrequency !== null && (this.releaseChains.forEach(n => n.oneShot([this.activeFrequency], n.duration)), this.mainChains.forEach(n => n.release([this.activeFrequency])), this.activeFrequency = null)
                }
            }, this.discrete = {
                attack: (n, r) => {
                    if (Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]), n = this.transposeNotesIntoRange(n), r.some(a => this.activeInputs.has(a))) return;
                    const i = n.map(a => Vd(a, "midi").toFrequency());
                    r.forEach(a => this.activeInputs.set(a, i)), this.attackChains.forEach(a => a.oneShot(i, a.duration)), this.mainChains.forEach(a => {
                        this.isOneShot ? a.oneShot(i) : a.attack(i)
                    })
                },
                release: n => {
                    Array.isArray(n) || (n = [n]), n.forEach(r => {
                        const s = this.activeInputs.get(r);
                        s !== void 0 && (this.releaseChains.forEach(i => i.oneShot(s, i.duration)), this.mainChains.forEach(i => {
                            this.isOneShot || i.release(s)
                        }), this.activeInputs.delete(r))
                    })
                }
            }, this.flub = {
                attack: () => {
                    this.flubChains.forEach(n => n.oneShot([60], n.duration))
                }
            }, this.outNode.toDestination(), this.update(e)
        }
        update(e = {}) {
            this.releaseAll();
            const n = JSON.parse(JSON.stringify(e));
            n.baseUrl !== void 0 && (this.settings.baseUrl = n.baseUrl), n.ext !== void 0 && (this.settings.ext = n.ext), n.chords !== void 0 && (this.settings.chords = n.chords), n.notes !== void 0 && (this.settings.notes = this.transposeNotesIntoRange(n.notes.sort())), n.noFlubs !== void 0 && (this.settings.noFlubs = n.noFlubs), n.config !== void 0 && (this.settings.config = n.config), this.settings.config && (this.settings.isOneShot = this.settings.config.capabilities.includes("OneShot"), this.resetChains())
        }
        get baseUrl() {
            return this.settings.baseUrl
        }
        get ext() {
            return this.settings.ext
        }
        get chords() {
            return this.settings.chords
        }
        get notes() {
            return this.settings.notes
        }
        get isOneShot() {
            return this.settings.isOneShot
        }
        get noFlubs() {
            return this.settings.noFlubs
        }
        get config() {
            return this.settings.config
        }
        resetChains() {
            this.clearChains(), this.config && (this.buildChains(), this.connectChains())
        }
        clearChains() {
            const e = [];
            this.attackChains.forEach(n => {
                e.push(...n.nodes)
            }), this.mainChains.forEach(n => {
                e.push(...n.nodes)
            }), this.releaseChains.forEach(n => {
                e.push(...n.nodes)
            }), this.flubChains.forEach(n => {
                e.push(...n.nodes)
            }), this.effectChain && e.push(...this.effectChain.nodes), this.attackChains = [], this.mainChains = [], this.releaseChains = [], this.flubChains = [], delete this.effectChain, e.forEach(n => {
                n.node.disconnect(), n.node.dispose()
            })
        }
        buildChains() {
            this.config && this.config.chains.forEach(e => {
                var r;
                if (this.settings.noFlubs && e.type === "flub" || !e.nodes.length || (r = e.nodes[0]) != null && r.isDisabled && e.type !== "effect") return;
                const n = {};
                this.baseUrl && (n.baseUrl = this.baseUrl), this.chords && (n.chords = this.chords), this.ext && (n.ext = this.ext), this.notes && (n.notes = this.notes), e.type === "effect" ? this.effectChain = new Vu(e.nodes, n) : e.type === "main" ? this.mainChains.push(new Vu(e.nodes, n)) : (n.duration = e.duration, e.type === "attack" ? this.attackChains.push(new Vu(e.nodes, n)) : e.type === "release" ? this.releaseChains.push(new Vu(e.nodes, n)) : this.flubChains.push(new Vu(e.nodes, n)))
            })
        }
        connectChains() {
            this.effectChain && this.effectChain.outNode.node.connect(this.outNode), [...this.attackChains, ...this.mainChains, ...this.releaseChains, ...this.flubChains].forEach(n => {
                this.effectChain ? n.outNode.node.connect(this.effectChain.inNode.node) : n.outNode.node.connect(this.outNode)
            })
        }
        normalizeSignal(e) {
            return e < 0 ? 0 : e > 1 ? 1 : e
        }
        signalToFrequency(e, n, r) {
            const s = (r - n) * e + n;
            return Vd(s, "midi").toFrequency()
        }
        transposeNotesIntoRange(e) {
            return e.map(this.transposeNoteIntoRange.bind(this))
        }
        transposeNoteIntoRange(e) {
            if (!this.config || !this.config.preferredRange) return e;
            if (e < this.config.preferredRange[0]) {
                for (let n = e; n <= 127; n += 12)
                    if (n >= this.config.preferredRange[0]) return n;
                return console.warn(`Unable to transpose note ${e} into range ${this.config.preferredRange}`), e
            }
            if (e > this.config.preferredRange[1]) {
                for (let n = e; n >= 0; n -= 12)
                    if (n <= this.config.preferredRange[1]) return n;
                console.warn(`Unable to transpose note ${e} into range ${this.config.preferredRange}`)
            }
            return e
        }
        releaseAll() {
            this.activeInputs.forEach((e, n) => this.discrete.release(n)), this.continuous.release()
        }
    }
    const C2e = yt({
            props: {
                beatmap: {
                    type: Object,
                    required: !0
                },
                instrument: {
                    type: Object,
                    required: !0
                }
            },
            setup() {
                return {
                    instraface: new u2({
                        noFlubs: !0
                    })
                }
            },
            data() {
                return {
                    isLoading: !0,
                    isDown: !1,
                    signal: 0
                }
            },
            watch: {
                instrument: {
                    handler(t, e) {
                        e && t.config.slug === e.config.slug || (this.instraface.update({
                            baseUrl: `https://cdn.jackboxgames.com/nopus-opus/instruments/${this.instrument.config.slug}`,
                            config: this.instrument.config
                        }), this.instraface.outNode.volume.value = 8, this.waitForLoading())
                    },
                    immediate: !0
                }
            },
            beforeUnmount() {
                this.instraface.releaseAll(), this.instraface.update({
                    config: null
                })
            },
            methods: {
                normalizeSignal(t) {
                    return t < 0 ? 0 : t > 1 ? 1 : t
                },
                onPointerBoxStart(t) {
                    if (!this.isLoading) {
                        this.isDown = !0, this.signal = this.normalizeSignal(t.detail.percentX);
                        try {
                            this.instraface.continuous.attack(this.signal, 48, 72)
                        } catch {
                            t.detail.cancel(), console.warn("not loaded")
                        }
                    }
                },
                onPointerBoxMove(t) {
                    if (!this.isLoading) {
                        this.signal = this.normalizeSignal(t.detail.percentX);
                        try {
                            this.instraface.continuous.update(this.signal, 48, 72)
                        } catch {
                            console.warn("not loaded")
                        }
                    }
                },
                onPointerBoxEnd() {
                    if (!this.isLoading) {
                        this.isDown = !1;
                        try {
                            this.instraface.continuous.release()
                        } catch {
                            console.warn("not loaded")
                        }
                    }
                },
                async waitForLoading() {
                    this.isLoading = !0, await X0(), this.isLoading = !1
                }
            }
        }),
        I2e = {
            class: "slider-wrapper"
        },
        k2e = ["disabled"],
        N2e = {
            key: 0,
            class: "test-it"
        },
        x2e = {
            key: 1,
            class: "test-it"
        };

    function P2e(t, e, n, r, s, i) {
        const a = fn("pointerbox"),
            c = fn("t");
        return Y(), X("div", {
            class: mt(["tester", {
                loading: t.isLoading
            }])
        }, [W("div", I2e, [Ge((Y(), X("div", {
            class: "slider",
            disabled: t.isLoading,
            "onPointerbox:start": e[0] || (e[0] = (...l) => t.onPointerBoxStart && t.onPointerBoxStart(...l)),
            "onPointerbox:move": e[1] || (e[1] = (...l) => t.onPointerBoxMove && t.onPointerBoxMove(...l)),
            "onPointerbox:end": e[2] || (e[2] = (...l) => t.onPointerBoxEnd && t.onPointerBoxEnd(...l))
        }, [W("div", {
            class: mt(["indicator", {
                visible: t.isDown
            }]),
            style: Jn({
                left: `${t.signal*100}%`
            })
        }, null, 6)], 40, k2e)), [
            [a, void 0, void 0, {
                restrict: !0
            }]
        ])]), t.isLoading ? Ge((Y(), X("p", N2e, null, 512)), [
            [c, "MENU.LOADING"]
        ]) : Ge((Y(), X("p", x2e, null, 512)), [
            [c, "MENU.TEST_IT"]
        ])], 2)
    }
    const R2e = ct(C2e, [
            ["render", P2e],
            ["__scopeId", "data-v-d4d4738c"]
        ]),
        M2e = [{
            hotKeys: [],
            degrees: [],
            lanes: [],
            hit: 0
        }, {
            hotKeys: ["space"],
            degrees: [1],
            lanes: [0, .5, 1],
            hit: .15
        }, {
            hotKeys: ["g", "h"],
            degrees: [1, 5],
            lanes: [0, .25, .5, .75, 1],
            hit: .15
        }, {
            hotKeys: ["f", "g", "h"],
            degrees: [1, 3, 5],
            lanes: [0, .166, .333, .5, .666, .833, 1],
            hit: .15
        }, {
            hotKeys: ["f", "g", "h", "j"],
            degrees: [1, 3, 5, 8],
            lanes: [0, .125, .25, .375, .5, .625, .75, .875, 1],
            hit: .14
        }, {
            hotKeys: ["d", "f", "g", "h", "j"],
            degrees: [1, 3, 4, 5, 8],
            lanes: [0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1],
            hit: .13
        }, {
            hotKeys: ["d", "f", "g", "h", "j", "k"],
            degrees: [1, 3, 4, 5, 6, 8],
            lanes: [0, .083, .166, .25, .333, .415, .5, .585, .666, .75, .833, .917, 1],
            hit: .12
        }];

    function l2(t) {
        const e = M2e[t];
        if (!e) return null;
        const n = [];
        for (let r = 1; r < e.lanes.length; r += 2) n.push({
            left: e.lanes[r - 1],
            center: e.lanes[r],
            right: e.lanes[r + 1]
        });
        return {
            hotKeys: e.hotKeys,
            degrees: e.degrees,
            lanes: n,
            hit: e.hit
        }
    }
    const D2e = yt({
            props: {
                beatmap: {
                    type: Object,
                    required: !0
                },
                instrument: {
                    type: Object,
                    required: !0
                }
            },
            setup() {
                return {
                    instraface: new u2({
                        noFlubs: !0
                    })
                }
            },
            data() {
                return {
                    isLoading: !0,
                    isDesktop: !1,
                    down: []
                }
            },
            computed: {
                layout() {
                    return l2(this.beatmap.config.laneCount)
                },
                isPercussion() {
                    for (let t = 0; t < this.instrument.config.capabilities.length; t++)
                        if (this.instrument.config.capabilities[t] === "DrumRack" || this.instrument.config.capabilities[t] === "PercSingle" || this.instrument.config.capabilities[t] === "PercRep") return !0;
                    return !1
                },
                notes() {
                    if (this.isPercussion) switch (this.beatmap.config.laneCount) {
                        case 1:
                            return [36];
                        case 2:
                            return [36, 38];
                        case 3:
                            return [36, 38, 42];
                        case 4:
                            return [36, 38, 42, 50];
                        case 5:
                            return [36, 38, 42, 45, 50];
                        default:
                            return [36, 38, 42, 45, 48, 50]
                    }
                    switch (this.beatmap.config.laneCount) {
                        case 1:
                            return [53];
                        case 2:
                            return [53, 60];
                        case 3:
                            return [53, 57, 60];
                        case 4:
                            return [53, 55, 57, 60];
                        case 5:
                            return [53, 55, 57, 60, 64];
                        default:
                            return [53, 55, 57, 60, 64, 65]
                    }
                },
                hitIndicators() {
                    return this.layout.lanes.map((t, e) => ({
                        text: this.layout.hotKeys[e],
                        classes: this.down[e] ? ["down"] : [],
                        styles: {
                            left: `${t.center*100}%`
                        }
                    }))
                }
            },
            watch: {
                instrument: {
                    handler(t, e) {
                        if (!(e && t.config.slug === e.config.slug)) {
                            this.instraface.update({
                                baseUrl: `https://cdn.jackboxgames.com/nopus-opus/instruments/${this.instrument.config.slug}`,
                                config: this.instrument.config
                            }), this.instraface.outNode.volume.value = 8, this.down = [];
                            for (let n = 0; n < this.beatmap.config.laneCount; n++) this.down.push(!1);
                            this.waitForLoading()
                        }
                    },
                    immediate: !0
                }
            },
            mounted() {
                window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp)
            },
            beforeUnmount() {
                window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp), this.instraface.releaseAll(), this.instraface.update({
                    config: null
                })
            },
            methods: {
                onPointerDown(t, e) {
                    t.pointerType === "mouse" && (this.isDesktop = !0), this.onDown(e)
                },
                onPointerUp(t, e) {
                    this.onUp(e)
                },
                onKeyDown(t) {
                    this.isDesktop = !0;
                    const e = t.key.toLowerCase(),
                        n = this.layout.hotKeys.indexOf(e);
                    n !== -1 && this.onDown(n)
                },
                onKeyUp(t) {
                    const e = t.key.toLowerCase(),
                        n = this.layout.hotKeys.indexOf(e);
                    n !== -1 && this.onUp(n)
                },
                onDown(t) {
                    if (this.isLoading) return;
                    const e = this.notes[t];
                    this.down[t] = !0;
                    try {
                        this.instraface.discrete.attack(e, t)
                    } catch {
                        console.warn("not loaded")
                    }
                },
                onUp(t) {
                    if (!this.isLoading && this.down[t]) {
                        this.down[t] = !1;
                        try {
                            this.instraface.discrete.release(t)
                        } catch {
                            console.warn("not loaded")
                        }
                    }
                },
                async waitForLoading() {
                    this.isLoading = !0, await X0(), this.isLoading = !1
                }
            }
        }),
        $2e = {
            class: "notes"
        },
        L2e = ["onPointerdown", "onPointerleave", "onPointerup"],
        F2e = {
            class: "hotkey"
        },
        U2e = {
            key: 0,
            class: "test-it"
        },
        B2e = {
            key: 1,
            class: "test-it"
        };

    function q2e(t, e, n, r, s, i) {
        const a = fn("t");
        return Y(), X("div", {
            class: mt(["tester", {
                loading: t.isLoading,
                desktop: t.isDesktop
            }])
        }, [W("div", $2e, [(Y(!0), X(St, null, In(t.hitIndicators, (c, l) => (Y(), X("div", {
            key: l,
            class: "cell"
        }, [W("button", {
            class: mt(["note", c.classes]),
            onPointerdown: h => t.onPointerDown(h, l),
            onPointerleave: h => t.onPointerUp(h, l),
            onPointerup: h => t.onPointerUp(h, l)
        }, [W("span", F2e, _t(c.text), 1)], 42, L2e)]))), 128))]), t.isLoading ? Ge((Y(), X("p", U2e, null, 512)), [
            [a, "MENU.LOADING"]
        ]) : Ge((Y(), X("p", B2e, null, 512)), [
            [a, "MENU.TEST_IT"]
        ])], 2)
    }
    const V2e = ct(D2e, [
            ["render", q2e],
            ["__scopeId", "data-v-7c880d33"]
        ]),
        j2e = yt({
            props: {
                category: {
                    type: String,
                    required: !0
                },
                classes: {
                    type: Array,
                    required: !1
                }
            }
        }),
        G2e = {
            key: 0,
            class: "aux",
            d: "m29.25,8.63l-2.29-5.43-5.14-2.5-14,.59-5.07,1.91L.25,8.77l.21,32.38,2.5,5.07,4.5,2.72c3.63.05,11.05.22,14.64.37,0,0,5.29-2.57,5.29-2.57l2.36-5.36-.5-32.75m-20.21-1.4l1.14-.73,5.86,3.23-5.57,2.86-3.57-.88-3-2.13,5.14-2.35m5.29,9.84l5.64-2.86,5.93,2.86-5.57,3.74c-1.36-1.12-4.41-2.97-6-3.74m5.64,18.94l-5.86-3.45,5.93-2.57,5.43,2.72-5.5,3.3m-3.93-10.72l-5.71,3.3-6.57-3.52,6.5-3.3,5.79,3.52m-11.79,15.57l5.57-2.94,5.29,3.01-4.71,3.6-6.14-3.67Z"
        },
        W2e = {
            key: 1,
            class: "bass",
            d: "m29.68,8.48l-2.64-5.51-4.86-2.28-2.64.07.29,37.08-.57,2.79-4.21,1.91-2.14-.44-2.21-1.69L10.39.84h-2.5L3.32,3.27l-2.21,4.77L.32,41.59l2.57,4.99,5.57,2.57,7.29.15h6.21l5.21-2.28,2.21-5.58.29-32.97Z"
        },
        H2e = {
            key: 2,
            class: "counter",
            d: "m30,24.67c-.25-4.29-.77-17.9-2.14-21.81C24.2,2.19,12.09.65,8.21.15L2.93,3.67,0,8.66c.46,3.96-.7,36.11,2.79,38.55l5.5,2.35,13.79.29,5.21-3.3c2.33-2.9,2.39-18.28,2.71-21.88m-4.29-14.83l.43,2.94-2.57,2.79-3.5-1.54-.21-4.04,2.86-1.62,3,1.47m-7.43,7.71l-5.07-4.99.86-1.32,11.64,9.99-16.21,19.46-1.21-.88,9.14-12.78,5.86-5.58-5-3.89m-12.93,14.83v-3.89l3.64-1.03,2.5,2.28-.64,3.01-2.86,1.84-2.64-2.2m12.29-13l.43,2.79-1.79,2.28-3.57-.29-1-3.16,2.71-3.3,3.21,1.69m-1.21,16.96l1.86,2.42.36,3.16-4,1.25-1.79-1.69.14-3.08,3.43-2.06Z"
        },
        K2e = {
            key: 3,
            class: "drums",
            d: "m29.89,9.18l-2-6.46L21.89.22l-13.43.29L2.61,3.23.11,9.1c.35,4.39-1.14,34.72,2.21,37.81l6,2.28c.89.07,6.71.44,7.43.59,0,0,11.43-2.94,11.43-2.94,2.67-3.14,2.36-33.38,2.71-37.67m-5.57-2.35l-.21,5.14h-8.21l.36-4.99c2.06.56,6,.26,8.07-.15M6.61,17.18l7.43-.07c.14.15.1,1.81-.14,4.99l-8.07.15,1-2.79-.21-2.28m-.79,15.86l-.21-4.77,8.5-.37.14,5.58-4.64-1.25-3.79.81m8.29,5.95l-.64,2.72.79,2.72-7.79-.44.14-3.96,7.5-1.03Z"
        },
        Y2e = {
            key: 4,
            class: "harmony",
            d: "m28.86,8.33l-2-5.21-1.57-.81-.43,18.58-1.21,1.98-2.43.29-.79-2.42c.09-1.68-.06-19.16.71-20.19h-4.21l.07,22.47-2.79-.37-1.36-2.13L13.21.48C7.52.2,7.54.35,2.57,2.97-.28,5.94.98,37.56.71,41.74c0,0,2.21,4.48,2.21,4.48l3.21,1.47-.71-18.87.93-1.32,2.43.66.43,20.56,3.86.37c.27-1.82-.44-21.07,1.57-21.88l1.86.59,1,3.01-.64,11.16.5,7.42,4.43.22,5.57-2.72c3.16-3.36,1.28-34.01,1.5-38.55Z"
        },
        z2e = {
            key: 5,
            class: "melody",
            d: "m28.96,8.33l-1.79-5.36-4.64-2.2L7.68.4,2.89,3.34.39,9.07l.07,32.01,2.21,4.48,5.57,3.16,6.57.88c6.65-.26,6.68.12,12.5-3.45l2.29-5.43-.64-32.38m-7.79,14.9l-.14.44-3.36,3.74.93,1.84-.21,2.64-3.57,1.54-.93-.66-3.14,4.41.64,3.82-2.43,1.47-3.29-.59-1.79-2.86,2.29-3.08,2.5.07,3.5-4.48-.86-.66.57-3.23,3.79-.59c.23-.32,4.05-5.21,4.07-5.43l-.79-.81.79-2.35-.21-.15-3.43-3.82-1.71.15-2.5-1.54-.29-4.26,3.5-1.47c-.14.22,1.47,1.2,1.86,1.4,0,0,1.57,2.35,1.57,2.35l-.57,2.35,3.86,3.82,2.57-.37,2.07,3.45-2.29,3.16-1.93.81-1.07-1.1Z"
        },
        Z2e = {
            key: 6,
            class: "signature",
            d: "m29.89,8.74l-2.64-5.51-5.14-3.23-13.93.73L2.32,2.79.11,9.18l.07,32.38,2.57,5.51,5.43,2.94c5.73-.06,13.81-1.07,19.29-2.79,3.22-2.49,2.05-34.59,2.43-38.47m-3.21,13c-1.55.8-3.89,4.5-4.79,5.95l.21,7.49-6.64-2.5-7.64,2.5,1.07-5.58-2.21-4.7-2.86-3.16,3-1.47,4.43-.81,4.07-6.61c.1.24,1.48,2.37,4.14,6.39l7.21,2.5Z"
        };

    function X2e(t, e, n, r, s, i) {
        return Y(), X("svg", {
            viewBox: "0 0 30 50",
            class: mt(t.classes)
        }, [t.category === "AuxPercussion" ? (Y(), X("path", G2e)) : t.category === "Bass" ? (Y(), X("path", W2e)) : t.category === "CounterMelody" ? (Y(), X("path", H2e)) : t.category === "Drums" ? (Y(), X("path", K2e)) : t.category === "Harmony" ? (Y(), X("path", Y2e)) : t.category === "Melody" ? (Y(), X("path", z2e)) : t.category === "Signature" ? (Y(), X("path", Z2e)) : Ve("", !0)], 2)
    }
    const kk = ct(j2e, [
            ["render", X2e],
            ["__scopeId", "data-v-d2174d82"]
        ]),
        Q2e = yt({
            props: {
                category: {
                    type: String,
                    required: !0
                },
                slug: {
                    type: String,
                    required: !0
                }
            },
            computed: {
                categoryClass() {
                    return Ii.categorySlugByKey(this.category)
                },
                icon() {
                    return Ii.instrumentIconBySlug(this.slug)
                }
            }
        }),
        J2e = {
            key: 0,
            d: "m133.26,90.5v-6.5l-3.48,3,3.48,3.5ZM31.33,45l2.48,10,21.38-3,1.83,10.32-15.25,2.68v7l16.25-4.09,1.76,9.96-15.03,6.13,2.99,5.5,13.08-5.8,2.05,11.59-13.15,5.21v6.5l14.56-3.75,1.59,8.93-14.65,5.32,3.97,4.5,11.83-3.34,2.1,11.84-19.4,2.5v11.5l35.8-5.5-16.4-101-37.79,7Zm97.95,61.5l-4.97,1,3.48,5,1.49-6Zm-5.47,15l1-4.5h-4.98l3.98,4.5Zm-17.9-78.5l-6.96-5.5-6.96,7.5-6.46-7.5-3.49,10.5-8.95-10.5,14.92,100h10.94l15.41-100-8.45,5.5Zm18.4,51l3.48,5.5.99-7-4.47,1.5Zm12.93-24v-6.5l-3.98,3,3.98,3.5Zm-19.4-33l-16.4,100,28.34,6,1.99-14.5-13.93-3-1.98-5.5,11.93-63,15.91,2.5,2.49-16-28.35-6.5Zm13.93,36l-3.98,1.5,1.99,4.5,1.99-6Z"
        },
        ebe = {
            key: 1,
            d: "m50.02,96.74c-9.78,14.26-8.34,12.27-11.63,28.91l8.67,14.46c19.13,9.82,13.79,7.23,34.67,6.38,12.67-17.79,9.85-12.43,11.71-33.8l-8.09-11.34,37.99-54.99,20.35-10.35-2.38-7.09-21.07,4.93c1.61,2.1-39.98,58.25-41.69,61.16l-13.11-2.51-15.43,4.25Zm5.15,22.49l14.43,9.49-1.26,2.02-14.63-9.97,1.46-1.54Z"
        },
        tbe = {
            key: 2,
            d: "m75.08,94.5l7.46,27-3.98,20,4.48,5.5c29.34-4.44,22.28-1.44,45.81-19.43l-5.36-3.05c-16.08,14.36-11,11.24-31.87,15.48l-4.11-1.5c6.34-7.33,31.58-25.87,40.03-31.25l.07.02,11.62-3.27-3.31,5.66,4.44,1.27,4.33-8.93-5.46-7c-24.07-3.71-19.08-2.07-38.79-16l-9.94,3-20.89-37-11.93-10-5.97,4,5.97,15,24.36,33-6.96,7.5Zm43.51,22.75l8.52,7.63h9.32l3.73-6-4.97-6.88-7.9-2.01-8.7,7.25Z"
        },
        nbe = {
            key: 3,
            d: "m132.57,76.01l-25.44-2.48-16.94,6.13-.28,6.44,3.78,2.72,2.43,29.39,10.85,6.26,19.77.04,10.59-4.49,5.25-27.93,3.81-2.39.28-6.44-14.1-7.27Zm1.14,14.03l-29.64-2.07-12.34-4.55,2.47-3.31,17.28-4.14,22.23,2.48,9.46,4.97,1.24,2.9-10.7,3.72Zm-41.67-.83l-5.15.62-.62,20.18,6.9.21-1.13-21Zm-3.56-17.17l-16.66-4.23-27.99,2.48-14.82,8.64.5,5.36,3.88,1.71,11.24,34.64,25.34,1.36,13.94-5.06,2.54-35.56,3.91-2.45-1.88-6.89Zm-11.57,8.89l-23.87,1.66-19.76-1.66,1.24-3.31,11.93-5.38,21.41-2.07,16.87,2.07,1.23,3.31-9.05,5.38Z"
        },
        rbe = {
            key: 4,
            d: "m29.59,66.75l11.43-16.25,9.7,1.5,4.39,5.04,72.21,14.49,17.97,10.05,5.27,15.65,6.41-.69,1.39,9.29-4.78,7.08-5.14-3.87-12.31,14.71-.62-.04c3.83-22.49,4.86-17.09-2.31-39l-17.63-9.29-19.05,6.97-10.35,20.74-.54,5.03-36.01-16.86-6.8,2.83-10.25-3.12-2.98-24.25Zm6.06,3.21l5.02-8.27,5.74.89,1.81,10.41-5.1,10.33-6.63-1.65-.84-11.71Zm79.4,9.62l-16.94,6.2-9.21,18.44-1.93,18.18,6.42,19.46,17.11,5.35,12.56-6.99c11.21-17.73,9.44-15.71,12.82-35.87,0,0-5.15-16.52-5.15-16.52l-15.68-8.26Zm1.2,27.17l5.5,4.5-.5,5.12-6,3.75-3.38-3.12.38-7.12,4-3.12Zm-55.75,12.25l2.33-19.27,20.61,10.96.06,10.45,2.17,9.57-8.17,8.79-11.5-2.5-5.5-18Z"
        },
        sbe = {
            key: 5,
            d: "m14.42,68l29.84,16.5,40.27-18,3.98-5,8.45,1.5v5c-6.73-.76-44.79,14.24-51.71,16.5l46.24,20.5,75.08-37c-98.08-29.69-54.24-29.58-152.15,0Zm38.79,48.5v-25.5l38.28,17.5,37.79-17.5-.5,25.5-12.92,10-26.36,4-26.35-4-9.94-10Zm-8.95-6.5l.99-17.5,1.49,17.5,2.98,6.5c0,4.48,0,13.52,0,18l-2.98,2.5-4.47-2.5v-15.5l1.99-9Z"
        },
        ibe = {
            key: 6,
            d: "m30.83,94l2.98,17.5s31.33,9,31.33,9c13.04-1.38,71.3-7.16,83.04-9-3.24-11.77-13.91-43.99-17.9-56l-55.2,1-13.67,33-30.58,4.5Zm36.8-4.75l10.44-27.5,15.91.25.99,29-27.34-1.75Zm31.57-26.75l1.49,28.25,16.41-.75-4.97-28.25-12.93.75Zm-62.9,45l-1.24-7.75,7.46.25,1.49,8.75-7.71-1.25Zm19.39-3.75l-.25,8,8.46,2.25.99-9-9.2-1.25Zm23.5,27.25l-8.08-7.47,24.24-2.28-3.88,8.77-12.28.98Zm45.59-5.75l-10.59-6.47,24.21-2.28-5.29,8.75h-8.33Zm-73.53-2l-7-6.75,16.25,4.5-.75,2.25h-8.5Zm8.75-85.75l10.62,11.25,3.38-3.88-7.62-13.25-6.38,5.88Zm23-6.25l-.5,13.75,5,1.75,5-15-9.5-.5Zm-35.12,22.38l13.62,4.25-1.25,5.38h-13.5l1.13-9.62Z"
        },
        obe = {
            key: 7,
            d: "m82.99,54.23l21.42,11.23,22.46-.56-9.98,20.99,12.22,25.6-15.17,25.32-28.93,2.12-22.78-23.59,4.42-26.34,19.74-12.76-3.39-22Zm-5.89,3.17l-6.19-5.03,4.28,21.41-21.01,9.99-5.87,29.42,15.32,19.83,8.34.35-15.61-19.83,4.57-24.97,19.74-12.76-3.57-18.41Zm35.67,16.35l-15.31-3.69-1.32,6.07,13.2,2.64,3.43-5.01Zm6.07-23.23l-7.13,12.93,6.6-.79,6.07-13.46-7.13-12.4-15.57-2.38-2.11-2.64,3.17-2.64v-7.39l-9.24,7.92,4.22,9.24,15.31,1.85,5.81,9.77Z"
        },
        abe = {
            key: 8,
            d: "m64.14,43.5l-3.73-.07-6.59,28.61c-4.93,9.4-12.05,29.78-14.79,40.09l21.38,20.5,22.87,9.25,28.59-5c18.42-13.39,16.58-9.78,28.09-30l-16.21-31.86-7.16-30.76-4.24.92-15.4,27.08-15.66-.05-17.15-28.7Zm1.74,54l-7.23-4.51,5.85,6.11,11.67.72,6.82-5.87c-8.8,4.39-7.3,4.13-17.12,3.55Zm38.78.62l-8.74-3.93,7.49,5.05,10.58-.71,3.83-5.43c-6.01,4.93-5.87,3.92-13.17,5.01Zm24.33,23.38l-17,13.5-28,4-24-10-16-16.5,1.5-12.5,24,5,10-1.5,1.5,2.77,4-.77,7-16,7,16,4,1.5,16-3.5,14-5.5,3.5,11-7.5,12.5Zm-44.02-14.13l6.12,5.12,5.58-5.64-6.69-1.38-5.01,1.9Zm4.52-.87l-.5,1.5.5,1.5,2-2.5-2-.5Zm3.27,10.99l-11.26,5.15,1.73,6.99,12.94.5,7.7-7.36-4.07-1.93-1.67,5.08-2-6.82-3.37-1.6Zm46.01-71.99l19.35,6.14-.89,8.23-16.37-6.43-1.19,23.94-11.16-1.65-1.34-6.58,5.06-2.24,4.76,2.69,1.79-24.09Z"
        },
        cbe = {
            key: 9,
            d: "m54.42,82l17.09-8.36,4.31-28.79-6.41.37.49-5.37,6.31,2.45.82-5.49-6.91-1.07v-3.04l7.27,1.7.7-4.7-3.54-5.13,7.35-5.81,4.95,9.54-3.28,1.94-.13,2.1,7.24-1.44-.65,5.61-6.75-1.57-.35,5.58,6.71,1.08-.12,2.14-6.73-.94-2.07,32.76,11.21,5.89c-.03,5.83.22,19.51,1.68,25.06l-7.61,1-2.21,7.95,2.17,8.39,5.3,2.04,2.52,18.1-15.5,13.55-29.83-3.22-7.57-15.34,4.11-17.95,8.09-.45,4.25-7.62-.56-6.84-6.82-3.19,3.03-6.74,1.44-14.19Zm51.26-62.46l24.53,126.48,1.73,7-2.29.74-1.35-6.59-3.23.52c-5.27-32.39-18.1-98.27-25.05-130.53l5.66,2.38Z"
        },
        ube = {
            key: 10,
            d: "m106.06,119.81l9.01,1.85V32.23h-5.41l-3.6,87.58Zm-42.78-.41h5.63l3.38-87.17h-5.07l-3.94,87.17Zm12.79,24.27l3.04,9.82,10.96,5.53,10.35-3.68,2.44-9.82-6.09-9.82-6.7-3.68-7.31,3.68-6.69,7.98Zm7.48-110.31h-5.41l-3.6,84.91,6.6-4.31,2.41-80.6Zm10.85-14.71l.26-8.73-1.9-.51-.29,8.8-.47-.11-26.79,2.46-3.04,4.3v2.46l29.96,1.23-.23,7.08h-1.36l-3.61,83.54,2.17,1.64-.33,9.98,1.31,1.23v-.53s1,.53,1,.53l.28-9.5.38.29,4.2-87.17h-2.03l.21-6.99,27.72,1.14v-4.91l-27.42-6.21Zm6.36,102.2l4.18-88.62h-5.37l-4.77,91.7,5.96-3.08Z"
        },
        lbe = {
            key: 11,
            d: "m93.05,35.53l-26.08,4.92-24.45,21.86-5.98,10.38v44.26l17.93,24.04-4.34,11.47-1.63,12.57h5.97l9.78-18.58,14.13,6.01,23.91,1.09,18.47-7.1,11.96,18.58h4.89l-3.26-17.48-3.8-6.56,16.3-22.95,2.71-8.74-1.08-31.69-21.74-30.6-33.69-11.47Zm0,9.29l-22.82,2.73-22.28,23.5-2.72,41.53,16.85,22.95,16.84,8.2h22.83l20.64-8.2,17.94-25.68v-27.87l-17.94-27.32-29.34-9.84Zm-43.06-.95l-18.1,14.83-4.39-8.79,9.32-21.42,13.17-5.49,15.91,5.49-15.91,15.38Zm75.7-19.22l-6.59,5.49,14.81,15.38,20.3,13.18,3.29-16.48-8.23-13.73-11.52-5.49-12.06,1.65Zm-26.62,71.6l.43,1.75h-4.57l-3.43-4.31,2.26-.97-7.57-31.82,2.74-8.24,3.3,8.79,2,31.07,3.56-1.52,1.06,4.36,28.48-.95,1.65,6.59-29.91-4.75Z"
        },
        hbe = {
            key: 12,
            d: "m69.49,164.56l-2.31-27.52-2.31-11.71,20.24,14.05,8.09-2.34-3.47-11.71,25.44,5.27v-11.71h7.52l-7.52,48.6-35.85,3.51-9.83-6.44Zm36.42-51.53h16.77l5.2-38.65-18.5,4.68-30.06,1.76-18.5-4.1,2.89,37.48,22.55,20.49-5.2-17.57,28.33,8.2-3.47-12.3Zm-4.05-96.03l-8.09,2.34-6.36,48.6,5.2,1.17,6.94-2.93,2.31-49.19Zm-34.69,44.5l20.24-2.93-2.31,9.96,8.09,2.93,8.67-2.93v-9.96h7.52l18.5,4.68,2.89,5.27-27.17,8.2h-30.64l-16.77-5.27v-4.68l10.98-5.27Z"
        },
        fbe = {
            key: 13,
            d: "m103.54,79.14c3.75,3.75,11.61,11.66,15.29,15.38l11.94.36,9.82,13.88,9.57,5-5.34,5.75-20.01-1.12-6.72-5.88,5.58,10.88-32.68,16.37c-1.75-8.83-25.23-46.98-29.95-55.38l.3-2.46,3.06,1.23,3.1-2.64-.35,3.56,8.26,4.61-9.79-17.22,3.67-14.45,26.91,23.37,7.34-1.23Zm29.36,51.05l-5.51-6.77-39.9,20.76,2.6,7.07,42.81-21.06Zm-35.1-37.51l-3.61-7.63,1.75,9.66,8.79,1.81-6.94-3.84ZM49.28,25.5l19.34,6.14-.89,8.23-16.37-6.43-1.19,23.94-11.16-1.65-1.34-6.58,5.06-2.24,4.76,2.69,1.79-24.09Z"
        },
        dbe = {
            key: 14,
            d: "m113.21,105.67l-4.54-.06,5.71,9.53-5.6,23.65-17.92,11.54-22.84-.93-16.36-9.49-5.6-21.68,11.21-21.12,3.47-1.71-2.96-29.46-37.82,3.08,24.42-8.18,12.03-8.52-.44-4.41,3.05-.51.51,4.37,10.79,4.97,24.92,6.14-34.09,2.78,3.25,27.93,7.19-3.54h17.81l14.36,7.33,1.94,3.23-.1-20.53,8.51-2.69,19.61-1.13,12.57,2.28v26.08l-33.07,1.02Zm-4.47,10.31l-8.87-14.8c-15.87-6.89-12.89-5.43-29.73-4.94-14.28,9.12-10.25,6.71-18.14,21.11l4.41,19.31,11.92,6.75,19.69,1.3,15.81-10.16,4.92-18.56Zm2.14,28.49l5.08-1.02,9.16-13.3,13.74,13.3,6.1-1.02-16.79-15.86-1.01-18.92h-3.56l1.01,16.37-13.73,20.46Zm4.91-65.65l20.44-.28,6.99,2.82-11.76,2.82h-14.56l-8.95-2.53,7.84-2.82Zm-25.77-47.02l.56-3.38,3.09.56c-1.83,1.31,33.13,29.7,33.88,30.69l-.56,2.53c-4.8.07-32.55-30.02-36.96-30.41Zm-11.19,91.5l-1.4,14.08,9.8-18.3-5.05-.28,5.33-11.26h-11.49l-3.36,16.05,6.16-.28Z"
        },
        pbe = {
            key: 15,
            d: "m59.98,48.46l-21.27-4.71,3.62,10.7-7.02-3.42,4.89,14.33,13.25,21.15,9.7,26c.76-3.14,2.82-11.61,3.98-14.5,3.09,1.02,24.47,12.74,27.87,14.52,0,0,25.33,8.98,25.33,8.98l1.26,15.83,2.98,11.98,5.96-23.32,22.12-5.99c-5.01-1.18-19.81-4.72-24.68-5.35l-14.25-26.53-14.25-16.26,5.53-4.07,12.76-5.56-32.33-.43-11.59-8.32-13.86-5.04Zm-3.82,5.6l-5.11.43,1.91,4.49,4.68-.21-1.48-4.71Z"
        },
        mbe = {
            key: 16,
            d: "m142.26,31l-9.2,7.2-3.58-2.6-15.31,15.45,3.08,2.55-12.78,11.3.7,8.75-7.86-.5-7.16,6.65.45,7.95-8.1-.75-6.66,7.2.15,8.05-9.35-.85-7.66,7.7.2,8.2-7.36-.5-21.48,23.15,9.2,8.2L124.41,60.8l4.57,2.05,20.93-26.2-7.66-5.65Z"
        },
        gbe = {
            key: 17,
            d: "m146.68,31.5v-4.5l-37.79,7-35.8,15.5,3.48,3.5,13.92,2,15.91,13.5,8.45,19,.99,31.5-9.45,15,2.49-18.5-10.44-1.5-1.99,24h-9.45l9.45-42-10.94-2.5-10.94,44.5-4.97-4,6.96-31h-8.95l-5.97,23.5-5.97-6,5.97-24.5,11.44-8.5h23.37l12.43,8.5v-10l-4.47-6-25.85-4.5-26.35,14.5-5.97,32,21.38,28.5,28.84,2.5,9.94-4.5,21.88-29.5v-50.5l3.98-23.5,14.42-13.5Zm-102.43,96.5l-13.92-9c-5.15,5.43-4.51,4.8-5.97,12l27.84,8.5-7.96-11.5Z"
        },
        _be = {
            key: 18,
            d: "m28.16,121.11c1.64-.98,38.97-20.47,39.27-21.24l.78-4.99,4.57-3.14,5.66,3.02,1.33,6.05h0s-6.01,4.69-6.01,4.69l-4.97-3.16c-3.33,1.67-35.28,19.04-39.4,21.24l-1.22-2.46Zm15.95-3.22l-.76,24.99h8.08l.77-29.36-8.09,4.37Zm97.84-67.95h-8.07l5.06,93.16-7.69.39-5.84-93.93-12.24.09-1.7,23.42,8.11,4.18,5.47,23.75-7.45,23.25-24.87,11.5-24.86-6.75-10.13-18.48c1.6-.86,9.49-5.15,10.95-5.88l5.19,3.3,8.11-6.34-1.81-8.17-7.54-4.03-6.27,4.3-.78,4.97c-1.38,1.04-6.45,3.67-8.05,4.52l.88-15.45,10.19-15.25,3.34-1.03-.55-21.5-17.54.13-1.47,55.84-8.05,4.29,1.83-59.74h-7.69l-6.15-11.22,113.87.23-4.24,10.44Zm-30.79-.28l-37.75.29.54,20.9,14.07-4.35h10.69l10.84,5.58,1.63-22.41Z"
        },
        ybe = {
            key: 19,
            d: "m138.73,54.23c5.47-6.87,7.69-10.3,6.66-10.3l-12.78-10.75-33.21,37-23.02-6.7-12.29,19.55-32.66,14.9-2.59,23.1,23.02,23.15,25.01,1.55,15.86-32.9,20.44-16.45-5.12-19.55,25.06-28.75,5.62,6.15Zm-54.55,30.45c3.58-.17,5.59-.03,6.02.4l2.04,10.25-7.16,5.65-8.21-6.15,2.04-9.75c1.73-.17,3.48-.3,5.27-.4Z"
        },
        vbe = {
            key: 20,
            d: "m96.84,137.12l.5,10.62,26.23-9.42c-.41-5.47,1.42-19.51,2.24-25.07,0,0-3.98-19.97-3.98-19.97,0,0-9.94-22.52-9.94-22.52l-3.48.21c1.23,4.98,5.29,19.7,6.71,24.86-2.89-7.91-10.06-23.22-14.17-30.59l-4.48,1.27,10.19,31.87-13.67-27.83-4.47.64.5,11.47,5.47,15.72c.94,4,1.99,13.09,2.36,17.23l-4.23-8.62-5.84-6.91-5.97,1.06c2.05,5,4.12,17.79,4.85,23.22l11.19,12.75Zm-38.91-36.19l2.98,7.22c1.38-7.94,3.17-24.29,2.98-32.29l4.72-.43c1.66,5.98,1.63,21.33,1.49,27.62l2.98-29.32,4.72.85.5,22.52,1.99-16.99,3.73,1.06-.25,17.63-6.46,1.91,3.23,8.07,1.49,18.06,3.73,2.97-1.24,11.05h-22.62c4.07-15.03,2.83-8.51-8.45-21.67l-1.49-14.45-3.48-5.52,4.47-2.55,4.97,4.25Zm1.24-55.44l9.7,12.25,2.74-3.5-5.97-12-6.46,3.25Zm21.88-11.25l1.99,15,5.47-.75.25-14.25h-7.71Zm23.12,7.5l-2.98,8,3.23,1.5,3.98-7.25-4.23-2.25Zm-18.15,48.12l-.87,8.5,2.11.38,2.24,2-.25-10.12-3.23-.75Z"
        },
        bbe = {
            key: 21,
            d: "m33.69,105.38l2.49-12,25.35-9.25.13-5.38-4.1-4.25,2.98-3.75,19.02-4.62,16.53.88,4.1,4.38-2.48,2.38v2.62l42.39-8.12,7.45,3.75,2.61,7.75c-12.02,4.91-87.41,37.74-98.07,40.12l-13.93-6.5-4.47-8Zm60.43-33.09l-3.13-2.41-12.68-.51-10.94,2.43-2.74,2.08,6.82,3.21,18.07-1.8,4.6-3Zm-55.71,24.09l12.68,4.25,3.98,7-3.23,8.75-12.43-5-1.99-6.75.99-8.25Z"
        },
        Ebe = {
            key: 22,
            d: "m109.89,63.5l-22.87,9-24.86-9-30.83,19.15,16.93,28.14,18.38,8.21,40.28,2.5,22.37-9.35,20.09-25.87v-6.78l-39.48-16Zm-49.67,31.06l-3.16.68-4.29-9.08,8.8,1.59-1.35,6.81Zm13.77,4.31l-4.97.91-3.84-2.27-1.35-9.76,10.38,2.95-.22,8.17Zm14.07,3.4l-10.24-2.48-1.46-9.09,13.65.28-1.95,11.3Zm17.97-4.9l-4.2,4.9-10.01-.52.46-10.32,13.98-2.32-.23,8.26Zm12.31-1.35l-3.88,2.85-6.39-1.22v-9.38l10.83-1.43-.56,9.17Zm5.98-3.16h-2.71l-.9-6.13,7.22-1.82-3.61,7.94Z"
        },
        Sbe = {
            key: 23,
            d: "m12.46,108.65l9.4-14.49.8-18.31,21.32-17.01c26-8.68,80.89-27.99,108.45-26.26l-1.35,11.87-41.55,44.71c-5.94,13.24-17.78,39.97-23.55,53.25l-18.5-6.22-3.41-13.39-10.67-5.49-16.66.99-24.28-9.66Zm72.27-52.61l6.52-4.42,6.06,6.67-7.93,3.14-4.65-5.39Zm-12.94.59l-9.73,2.5,5.7,11.7,11.27-2.9.35-7.22-7.59-4.08Zm-21.32,17.01l5.6-8.03,8.51,9.88-9.57,7.4-4.54-9.26Zm-18.52,12.99l2.13-8.78,9.5.85,2.75,10.81-8.71,2.24-5.67-5.13Zm66.24-7.71l-2.65,6.72,7.17-1.84-4.52-4.87Zm17.75-13.89l-4.97,6.22,5.27,1.39-.3-7.6Zm7.54-4.68l7.79-5.84-3.03,9.56-4.76-3.71Z"
        },
        Tbe = {
            key: 24,
            d: "m23.56,131.42l18.51-91.04,29.67-25.74,33.96,4.31,11.76,8.16,10.73,28.54-3.15,22.92,8.43,15.77,14.53,15.7-9.31,48.94-12.75-.76,5.82-24.58-13.6-3.26-3.08,19.12-8.64-2.07,4.45-18.79-12.23-2.93-3.94,16.62-8.43.27,4.45-18.79-12.95-3.1-4.45,18.79-7.92-1.9,4.45-18.79-15.11-3.62-4.45,18.79-5.96-3.72,3.94-16.62-7.92-1.9-5.82,24.58-9.15.1-1.85-5.03Z"
        },
        wbe = {
            key: 25,
            d: "m60.17,144l-22.87-13-1.49-16.5,10.94-13,22.38,6.5,66.63,8.5,13.92,12.5-20.39,11.5-69.11,3.5Zm-9.45-61l3.48,12.5,10.94,3,60.66,7,6.96-15-10.44-18.5-17.4-.5-38.78-5-15.41,16.5Zm26.35-35.5l3.48,13.5,28.84,5,8.95-7-11.44-15-17.9-16-11.93,19.5Z"
        },
        Obe = {
            key: 26,
            d: "m77.74,100l-34.1-3.25-17.28-13,.46-1.86,13.08-7.43,29.43-4.18,24.29,5.11,12.15,8.82,1.4,4.64-29.43,11.14Zm26.63-29.71l6.07,4.18,1.87,5.11.93-8.36,44.38-30.64v-3.71l-6.54-1.86-46.71,35.29Zm-84.51,10.29l3.28-7.07,16.87-9.42,30.93-2.83,26.71,6.12,12.18,8.48c.89,1.78,2.19,5.68,2.69,7.62l.12-.08c0,.08-.05.4,0,.47l-.04.03-4.18,50.86-6.56,11.78-34.67,8.95-43.11-11.78-4.69-8.95c0-.65,0-50.72,0-51.36h.07l.4-2.83Zm3.89,4l19.54,14.85c37.75,2.97,29.57,5.77,65.13-8.95.02-2.45-.02-7.41,0-9.9,0,0-1.4-2.83-1.4-2.83l-11.25-8.48-25.77-5.65-29.99,3.77s-14.52,8.48-14.52,8.48l-1.74,8.71Z"
        },
        Abe = {
            key: 27,
            d: "m90.8,24.7l5.32,11.1-53.85,92.05,3.83,18.7,23.52,10.35,21.13-7.5,14.02-27.6,9.35-4.95,11.73,8.2,11.24-9c-1.15-31.16,2.45-23.17-14.52-49.8l-7.96,3.4-3.13,12.75-15.86,7.25-23.77,35.6-11.34,4.25,27.74-54,10.54-5.2-1.29-9.2,9.35-4.9-3.18-7.55,8.05-9.9-10.79-22.75-33.07,4.7c.4.27,1.97,1.85,4.72,4.75l18.2-.75Zm41.82,65.7l-.35,21-5.62,5.65-12.68-21.05c.99-.63,3.88-7.57,8.65-20.8l9.99,15.2Z"
        },
        Cbe = {
            key: 28,
            d: "m77.17,127.37l10.11-14.39,5.21,6.77-5.22,12.75-8.47,3.82-1.63-8.95Zm-14.83-68.54l14.88,4.82-.36-13.78-5.26-5.38-17.4-.25-13,9.1-5.4,18.9,8.54,14.31.52-13.82,14.97,3.57,2.51-17.48Zm49.89,60.82l-33.7-30.5,7.99-12.39-1.24-18.25-3.28-3.36.41,15.46-15.96-5.18-2.45,17.02-14.37-3.43-.39,10.21-.69-.03,9.88,5.06,15.33-1.18,31.53,37.05,8.2.38-1.26-10.85Zm18.54-71.4l-15.66-5.5-15.94,5.11-2.85,4.6c6.07,4.35,29.16,20.99,43.68,31.45l.22-.16,1.74-20.25-11.19-15.25Zm-40.52,14l.89,16.27,9.98,12.33-5.77,9.97,6.3,4.91,6.63-11.93,16.93.76,10.52-7.58c-14.36-10.35-35.84-25.82-42.05-30.27l-3.43,5.53Z"
        },
        Ibe = {
            key: 29,
            d: "m49.2,140.64l21.41,9.36h12.43l-17.02-41.39-16.82,32.03Zm47.98-40.37l-23.49-.78-6.39,6.43-.25-.05,17.45,42.44,16.8-43.3-4.12-4.74Zm11.35-22.26c-2.55.06-25.98-.64-27.72.27l-33.53-21.44-2.66,1.53-.73,3.63,28.78,17.45-19.98,2.87-7.75,9.73,3.76,4.16-.93,42.89,17.74-33.78-4.99-6.7-8.75-2.01-4.2-4.64,6.19-7.77,21.61-3.1c3.2,2.03,17.7,10.16,19.72,13.17h5.58l-3.22-5.74c-2.72-1.2-11.42-6.9-14.06-8.58,10.06-.62,30.68.23,40.47,2.03l11.2,10.8-1.37,3.38-13.36,47.75,10.44-3.38c.85-5.61,2.7-44.42,6.65-48.25l-12.66-12.2-16.24-2.04Zm-22.53,71.99h15.45l16.03-5.19-15.26-36.63-16.22,41.82Zm45.33-55.42l-20.36,5.25-7.82,5.38,15.51,37.25,13.13-46.9-.46-.97Zm-39.55-31.98l47.58-28.86-.73-3.63-2.66-1.53-46.12,29.49-3.9,1.04-4.75,5.88h6.86l3.72-2.4Z"
        },
        kbe = {
            key: 30,
            d: "m96.91,94.69l-40.1,37.2-.35,4.43,9.54,1.24c17.83-19.69,56.26-57.76,76.9-74.14,0,0,6.12-12.02,6.12-12.02l-2.75-2.93-6.32,10.76-35.43,26.56,1.61-16.48-4.16.51-5.06,24.87Zm-12.39,57.75l-4-1.61-3.54-19.79,4.74-5.18,7.61,21.75-4.81,4.83Zm-10.82-105.44l-.79,26.1,4.8,32.62-5.6,6.04-5.21-40.27,1.6-24.97-4-14.9,2.8-2.01,6.22,16.42,1.39-1.92.8-8.05,8.81-7.25,7.21-2.82-5.61,12.89c-2.48,1.51-10.41,6.21-12.42,8.13Z"
        },
        Nbe = {
            key: 31,
            d: "m89.92,93.77h-7.46v5.42l11.55,14.47h6l1.55-5.81-11.65-14.09Zm-15.79,4.34h-7.09v4.87l11.14,19.02,6.59-2.28v-4.68l-10.64-16.94Zm-28.52,28.55l-6.86-23.14-6.92,1.72c-1.41,3.01,6.49,23.58,7.33,26.75l6.46-1.74v-3.59Zm6.94-20.63h-7.34c-1.63,2.3,8.39,23.48,9.14,25.94l6.41-1.72v-5.07l-8.21-19.15Zm-22.09,16.38l-5.73-22.79-6.29,1.81c-1.07,3.36,4.56,23.76,5.29,27.39l6.73-1.79v-4.62Zm78.94-23.38v5l16.22,13.17,6.68-1.84v-5l-16.93-11.32h-5.96Zm34.44,18.21l-17.38-14.53.79-4.56,5.31.71,18.93,12.3-.6,5.44-7.04.65Zm13.74.48l-12.4-13.95,2.15-2.63c4.21.95,15.12,11.41,18.37,14.22l-1.91,4.21-6.2-1.84Zm-75.07-34.29c-.48.14-10.17,4.68-10.83,4.73-.25,0-12.45,0-12.7,0-.34-.12-10.49-4.72-10.57-4.7l.07-.72s2.83-28.51,2.83-28.51c.03-.3.09-.95.12-1.24l9.43,2.91,16.24-4.03c.05.31.14.84.2,1.15l5.08,29.64.13.77Zm-5.69-33.16l-15.68,3.79-9.55-2.73c.04-.39.15-1.47.18-1.85.18-.08,9.22-4.03,9.57-4.18l.26.03,4.78.5-2.84,3.86,1.41.42,3.16-4.11c1.34.14,6.75.7,8.12.84l.13.75.46,2.68Zm24.78-1.54v-3.06c.3-.13,10.2-4.54,10.64-4.74.32.09,15.27,4.33,15.61,4.42,0,0,.59.17.59.17.08.41.37,1.91.46,2.35l-5.92,3.51h-10.02l.56-4.24h-1.84l-.56,4.09-9.52-2.51Zm33.12,28.89c-.34.08-12.12,6.23-12.69,6.21-.27,0-12.49,0-12.75,0-.38-.2-7.44-4.13-7.68-4.25v-28.25l9.24,2.03h12.56l5.84-3.74s.11.56.11.56c.08.43.2,1.04.29,1.47l4.93,25.23.15.75Z"
        },
        xbe = {
            key: 32,
            d: "m99.3,92.93l-3.61-1.98-1.17-28.88-23.92,16.44-2.38-2.24,12.43-25.72-9.09,9.53c-5.64,10.97-13.99,55.75-16.64,68.36l14.94,10.64,18.39,5.15c3.65-5.69,34.94-47.4,35.23-53.27l-4.51-19.67-19.67,21.63Zm22.41-38.01l-18.14-9.48-13.49-2.39c-.45.28-5.25,2.72-5.32,3.2,0,0-12.1,27.46-12.1,27.46l20.66-13.18,2.82,1.61,2.35,26.05,18.26-17.25,3.72-.31,4.28,17.4c2.08-1.2,2.17-23.76,2.49-26.04l-5.53-7.08Zm-26.79-1.35l-6.24-8.3,13.37,1.49,17.02,8.82,6.21,6.62-2.43,1.04-2.8,6.41-3.56-.06.35-6.49-15.43-6.38-4.61,4.43-2.92-1.97,1.04-5.61Z"
        },
        Pbe = {
            key: 33,
            d: "m87.02,41l-13.93,2-20.88,12.5-11.93,23,4.47,34,20.39,20,23.37,5,22.37-6,19.39-21,4.98-24-4.98-18.5-14.41-18-28.84-9Zm0,3l-13.43,2.5-17.9,11-10.94,22,5.97,31,15.41,16.5,22.38,5.5,20.38-6,16.41-17.5,5.47-22.5-3.98-17-12.92-17-26.85-8.5Zm-13.43,7l13.43-3,24.86,7.5,12.93,15.5,3.48,15.5-4.98,21.5-14.42,16.5-20.38,6-21.38-6-14.42-15-5.47-29.5,11.44-19.5,14.91-9.5Zm4.91-16l-2.5,5.5,11.5-2,12.5,3.5-2.5-7-10-4-9,4Zm39,9l-5,3,5,1.5,13,15,2-4.5-3-10.5-12-4.5Zm24.5,36l-6.5-2.5,2.5,8.5-3,14.5,7-2,3.5-8-3.5-10.5Zm-9.5,38l-2-3-5,5.5-1,5.5h-5.5l-5,5.5,10.5,2,6.5-6,1.5-9.5Zm-78,6l6.5,7.5-8,2-8-5-1.5-9,1.5-4,9.5,8.5Zm-14-34.5l.5,11.5-8.5-4-2.5-8.5,4-8.5,5-2.5,1.5,12Zm11-35.5l-5.5,9.5-2.5-6.5,1-5.5,6-5.5,8.5-1,4,2-11.5,7Z"
        },
        Rbe = {
            key: 34,
            d: "m161.04,93.27l-12.38-4.03-14.35,4.42,5.02-3.18-5.13-28.91-27.91-35.21-8.65,2.32-8,30.66-58.69,33.9-10.32,22.53,14.12,15.36,61.71-19-2.62,16.91-16.49,5.87-6.37-4.58,2.61,13.99,4.22,1.59,1.53-4.63,77.83-25.44,7.25-12.75-3.38-9.83Zm-54.39-54.96l2.24-1.75c19.2,24.13,17.77,14.98,22.62,46.25l-16.41-10.06-9.7-24.75,1.24-9.69ZM39.76,122.81l-6.22-11.33,4.93-8.66,19.83-7.11,11.47,17.85-30.01,9.25Zm35.26-10.87l-12.18-17.86,39.04-14c4.09,1.56,24.23,12.54,28.52,14.79l-55.38,17.07Zm23.41,15.48l2.58-16.68,46.26-14.24,6.98,2.44,1.17,8.2-56.98,20.28Z"
        },
        Mbe = {
            key: 35,
            d: "m47.24,133.05l-1-12.8-17.9,15.9,7.66,12.35c2.48-3.18,11.04-14.26,11.24-15.45ZM111.13,19l-5.62,3.6,6.12,19.5.5,11.85-15.81,17.95-16.86,1.55,3.58,11.3-12.78-3.05.5,16.45-12.78-1.55,2.54,11.8-7.16,7.2,3.08,20.55,15.32,14.9,21.48-5.15,42.41-53.45-16.36-22.05-6.12,9.75,8.7,14.4-31.72,40.6-22.47,2.05-1.54-24.15c10.99-10.41,51.89-49.15,54.69-50.9,0,0,17.4-1.05,17.4-1.05l11.24,6.2,5.62-5.15-16.36-31.35-27.6-11.8Z"
        },
        Dbe = {
            key: 36,
            d: "m104.6,33.79l-19.23-4.32,6.34-4.1,21.95-1.14,16.97,2.96-.9,4.32-25.11,2.28Zm-6.22,47.78l-1.58,1.71,2.15,38.23v22.18l-8.82,8.65-14.82-1.82-9.05-5.23-1.47-54.49-1.02-25.48,5.43-10.92,10.3-.23,9.28,8.3,1.13,17.07,4.64-4.89-2.38-23.55-7.81-9.21-16.74-.11-11.88,11.95-1.47,27.99,2.83,55.52,7.01,17.52,14.48,8.53,19.91-1.82,13.69-16.5,3.17-33.56,3.05-30.6-9.62,1.48-10.41-.68Zm23.87-60.07l-28.74.11-15.84,6.26,2.94,5.01,8.26,4.89,4.98,10.47,2.49,24,13.35,1.14,9.16-2.73,4.07-26.62,13.12-11.83,2.49-5.23-16.29-5.46Zm6.22,46.53l-.43,1.67-.37-1.1-6.69,4.76-11.79,2.18-13.46-.61-5.4,6.9.91,53.29-6.74,9.3-8.63-1.86-3.28-5.8-.11-13.54-.9-34.58,4.19-3.3,6.34,2.42.23,19.6.4,21.34,3.23,5.77,4.07-1.47-.23-4.89-2.04-.23-.11-20.36-.11-24h.11s-.23-6.37-.23-6.37l-2.72-5.8-3.85,5.23-3.85-5.01-3.73,4.55-5.43-4.89-1.92,4.09.68,8.65,1.95-.04-2.2,1.84.93,38.29.24,16.97,6.25,7.26,14.55.98,7.47-10.24.45-18.43-1.02-37.54,2.64-3.48,11.65.53,12.87-2.38,7.45-2.64-.2-.6,1.44.94-2.6-7.4Z"
        },
        $be = {
            key: 37,
            d: "m48.73,122.5L124.81,49l-3.48-7,1.99-8.5,8.45-6,10.94,1.5,5.97,11-1.49,9-7.96,6-12.43-3L47.74,127.5l-6.46-3-4.97-25.5-5.47-3-4.47,8,6.46,44.5,62.15-30.5v-8.5l36.8-28c10.93.14,9.2-1.4,18.89,4.5l3.98,15v8.5l-51.71,18-5.97-5-66.13,30.5c-.41-5.83-9.79-52.57-5.97-57l7.95-5,6.46,5,4.97,25,4.48,1.5Z"
        },
        Lbe = {
            key: 38,
            d: "m19.41,121.34l94.13-60.35,7.87.88,12.68-6.59.53-6.74,11.34-8.03,9.04,4.57,2.51,5.12-.43,7.28-9.91,6.67-8.41-.79-11.52,6.95-.97,7.38-80.27,57.45-12.17-3.48-3.59-4.94-6.17-3.94-4.3.73-.36-2.16Zm22.7-9.4l5.19,4.66.71-5.67-5.9,1Z"
        },
        Fbe = {
            key: 39,
            d: "m45.06,63.28l42.73-12.28,46.65,11.84-.12.5-43.48,15.28-45.21-13.47-.57-1.88Zm.65,3.12l18.97,62.33,27.91,8.77,26.16-9.21,15.53-63.77-43.87,20.36-44.7-18.48Z"
        },
        Ube = {
            key: 40,
            d: "m40.27,92.25l-16.16,39.25,9.08,3,11.31-3,9.45-38.51c-6.91-2.1-6.54-2.31-13.68-.74Zm6.71,38.51l9.95-37.02,5.59-1.61,6.59,1.8-6.71,36.83-8.33,3-7.09-3Zm25.36-35.72l6.34-1.54,5.84,2.28-2.48,33.97-8.7,3.24-7.71-2.69,6.71-35.27Zm12.68,34.79l2.74-33.32c5.79-1.83,5.65-1.57,11.43-.17l3.48,33.48c-9.59,2.74-8.17,2.3-17.65,0Zm18.4-32.18l5.22-1.16,5.22,1.34,7.71,30.51-7.46,2.12-7.96-2.12-2.73-30.69Zm14.92,1.86l5.71-1.38,5.72,1.19,8.45,27.53-6.21,1.65-7.46-2.21-6.21-26.79Zm23.37,25.3l-7.46-24.55,4.35-1.12,5.34,1.12,10.44,24.18-5.59,1.94-7.08-1.57Zm-35.31-49.8l42.52-30.25,2.23,3.25-42.01,31.5-1.99,8.25-8.95,1.75-5.97-5.25,1.49-7.25,7.21-4,5.47,2Zm-32.81-5.5l-18.15-34.75-3.73,1.5,17.65,35-3.23,7.5,5.47,6.75,7.95-2.5,3.48-7-2.98-5.75-6.46-.75Z"
        };

    function Bbe(t, e, n, r, s, i) {
        return Y(), X("svg", {
            viewBox: "0 0 180 180",
            class: mt(["instrument", `type-${t.categoryClass}`])
        }, [t.icon === "accordion" ? (Y(), X("path", J2e)) : t.icon === "banjo" ? (Y(), X("path", ebe)) : t.icon === "bell" ? (Y(), X("path", tbe)) : t.icon === "bongos" ? (Y(), X("path", nbe)) : t.icon === "canon" ? (Y(), X("path", rbe)) : t.icon === "cap" ? (Y(), X("path", sbe)) : t.icon === "car" ? (Y(), X("path", ibe)) : t.icon === "castanets" ? (Y(), X("path", obe)) : t.icon === "cat" ? (Y(), X("path", abe)) : t.icon === "cello" ? (Y(), X("path", cbe)) : t.icon === "chimes" ? (Y(), X("path", ube)) : t.icon === "clock" ? (Y(), X("path", lbe)) : t.icon === "cup" ? (Y(), X("path", hbe)) : t.icon === "dog" ? (Y(), X("path", fbe)) : t.icon === "drumKit" ? (Y(), X("path", dbe)) : t.icon === "fish" ? (Y(), X("path", pbe)) : t.icon === "flute" ? (Y(), X("path", mbe)) : t.icon === "frenchHorn" ? (Y(), X("path", gbe)) : t.icon === "gong" ? (Y(), X("path", _be)) : t.icon === "guitar" ? (Y(), X("path", ybe)) : t.icon === "hands" ? (Y(), X("path", vbe)) : t.icon === "kazoo" ? (Y(), X("path", bbe)) : t.icon === "mouth" ? (Y(), X("path", Ebe)) : t.icon === "ocarina" ? (Y(), X("path", Sbe)) : t.icon === "piano" ? (Y(), X("path", Tbe)) : t.icon === "poop" ? (Y(), X("path", wbe)) : t.icon === "pots" ? (Y(), X("path", Obe)) : t.icon === "sax" ? (Y(), X("path", Abe)) : t.icon === "shaker" ? (Y(), X("path", Cbe)) : t.icon === "snare" ? (Y(), X("path", Ibe)) : t.icon === "sticks" ? (Y(), X("path", kbe)) : t.icon === "synth" ? (Y(), X("path", Nbe)) : t.icon === "tallBongo" ? (Y(), X("path", xbe)) : t.icon === "tamborine" ? (Y(), X("path", Pbe)) : t.icon === "trombone" ? (Y(), X("path", Rbe)) : t.icon === "trumpet" ? (Y(), X("path", Mbe)) : t.icon === "tuba" ? (Y(), X("path", Dbe)) : t.icon === "vibraslap" ? (Y(), X("path", $be)) : t.icon === "whistle" ? (Y(), X("path", Lbe)) : t.icon === "woodblock" ? (Y(), X("path", Fbe)) : t.icon === "xylophone" ? (Y(), X("path", Ube)) : Ve("", !0)], 2)
    }
    const qbe = ct(Q2e, [
            ["render", Bbe],
            ["__scopeId", "data-v-74251a63"]
        ]),
        Vbe = yt({
            props: {
                lanes: {
                    type: Number,
                    required: !1
                }
            },
            computed: {
                viewbox() {
                    return this.lanes === 1 ? "0 0 30 150" : this.lanes === 2 ? "0 0 80 150" : this.lanes === 3 ? "0 0 130 150" : this.lanes === 5 ? "0 0 230 150" : this.lanes === 6 ? "0 0 280 150" : "0 0 180 150"
                }
            }
        }),
        jbe = ["viewBox"],
        Gbe = {
            key: 0,
            width: "30",
            height: "150",
            rx: "8",
            ry: "8"
        },
        Wbe = {
            key: 1,
            x: "50",
            width: "30",
            height: "150",
            rx: "8",
            ry: "8"
        },
        Hbe = {
            key: 2,
            x: "100",
            width: "30",
            height: "150",
            rx: "8",
            ry: "8"
        },
        Kbe = {
            key: 3,
            x: "150",
            width: "30",
            height: "150",
            rx: "8",
            ry: "8"
        },
        Ybe = {
            key: 4,
            x: "200",
            width: "30",
            height: "150",
            rx: "8",
            ry: "8"
        },
        zbe = {
            key: 5,
            x: "250",
            width: "30",
            height: "150",
            rx: "8",
            ry: "8"
        },
        Zbe = {
            key: 6,
            y: "66",
            width: "180",
            height: "18",
            rx: "9",
            ry: "9"
        },
        Xbe = {
            key: 7,
            cx: "40",
            cy: "75",
            r: "25"
        };

    function Qbe(t, e, n, r, s, i) {
        return Y(), X("svg", {
            viewBox: t.viewbox
        }, [t.lanes ? (Y(), X("rect", Gbe)) : Ve("", !0), t.lanes && t.lanes > 1 ? (Y(), X("rect", Wbe)) : Ve("", !0), t.lanes && t.lanes > 2 ? (Y(), X("rect", Hbe)) : Ve("", !0), t.lanes && t.lanes > 3 ? (Y(), X("rect", Kbe)) : Ve("", !0), t.lanes && t.lanes > 4 ? (Y(), X("rect", Ybe)) : Ve("", !0), t.lanes && t.lanes > 5 ? (Y(), X("rect", zbe)) : Ve("", !0), t.lanes ? Ve("", !0) : (Y(), X("rect", Zbe)), t.lanes ? Ve("", !0) : (Y(), X("circle", Xbe))], 8, jbe)
    }
    const Jbe = ct(Vbe, [
            ["render", Qbe],
            ["__scopeId", "data-v-8ddc6f95"]
        ]),
        eEe = {},
        tEe = {
            viewBox: "0 0 65 100"
        },
        nEe = W("path", {
            d: "m65,5.22v89.56c0,4.32-4.68,6.76-7.91,4.13L1.84,53.88c-2.45-2-2.45-5.76,0-7.76L57.09,1.09c3.23-2.63,7.91-.19,7.91,4.13Z"
        }, null, -1),
        rEe = [nEe];

    function sEe(t, e) {
        return Y(), X("svg", tEe, rEe)
    }
    const iEe = ct(eEe, [
            ["render", sEe]
        ]),
        oEe = yt({
            components: {
                ChangeVIP: ym,
                PlayerHeader: fu,
                ContinuousTester: R2e,
                DiscreteTester: V2e,
                AvatarSVG: v0,
                CategorySVG: kk,
                InstrumentSVG: qbe,
                LanesSVG: Jbe,
                LeftArrowSVG: iEe
            },
            props: {
                beatmaps: {
                    type: Object,
                    required: !0
                },
                info: {
                    type: Object,
                    required: !0
                },
                instruments: {
                    type: Object,
                    required: !0
                },
                players: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                }
            },
            data() {
                return {
                    audienceIndex: 0,
                    showChangeVIP: !1,
                    showUnlocked: !1
                }
            },
            computed: {
                selectedChoice() {
                    return this.instrumentChoices.find(t => t.isSelected)
                },
                selectedBeatmap() {
                    return this.beatmaps[this.selectedChoice.beatmapSlug]
                },
                selectedInstrument() {
                    return this.instruments[this.selectedChoice.instrumentSlug]
                },
                mappedPlayers() {
                    const t = {};
                    return Object.values(this.players).forEach(e => {
                        if (!e.beatmapSlug || !e.instrumentSlug) return;
                        const n = `${e.beatmapSlug}:${e.instrumentSlug}`;
                        t[n] || (t[n] = []), t[n].push(e)
                    }), t
                },
                instrumentChoices() {
                    const t = [];
                    return this.player.instruments.instruments.forEach((e, n) => {
                        let r = !1;
                        this.info.isAudience && n === this.audienceIndex && (r = !0), e.beatmapSlug === this.info.beatmapSlug && e.instrumentSlug === this.info.instrumentSlug && (r = !0);
                        const s = Ii.difficultyI18ByNumber(this.beatmaps[e.beatmapSlug].config.difficulty);
                        t.push({
                            isSelected: r,
                            index: n,
                            label: e.instrumentName,
                            category: e.beatmapCategory,
                            beatmapSlug: e.beatmapSlug,
                            instrumentSlug: e.instrumentSlug,
                            difficulty: this.beatmaps[e.beatmapSlug].config.difficulty,
                            difficultyName: this.$t(s),
                            players: this.mappedPlayers[`${e.beatmapSlug}:${e.instrumentSlug}`] ?? []
                        })
                    }), t.sort((e, n) => e.difficulty === n.difficulty ? e.category === n.category ? e.index - n.index : e.category < n.category ? -1 : 1 : e.difficulty - n.difficulty), t
                },
                categoryName() {
                    return this.selectedBeatmap ? this.$t(Ii.categoryI18ByKey(this.selectedBeatmap.config.category)) : ""
                },
                categoryClass() {
                    return this.selectedBeatmap ? Ii.categorySlugByKey(this.selectedBeatmap.config.category) : ""
                }
            },
            mounted() {
                this.info.isAudience && this.setAudienceChoice(0)
            },
            methods: {
                onDidRequestChangeVIP() {
                    this.showChangeVIP = !0
                },
                onDidRequestModalClose() {
                    this.showChangeVIP = !1, this.showUnlocked = !1
                },
                async onBackClick() {
                    if (this.player.responseKey) try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            backToSongSelect: !0
                        })
                    } catch (t) {
                        this.$handleEcastError(t)
                    }
                },
                async onInstrumentClick(t) {
                    if (!this.player.responseKey) {
                        this.setAudienceChoice(t);
                        return
                    }
                    const e = this.instrumentChoices[t];
                    try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            selectInstrument: {
                                beatmapSlug: e.beatmapSlug,
                                instrumentSlug: e.instrumentSlug
                            }
                        })
                    } catch (n) {
                        this.$handleEcastError(n)
                    }
                },
                setAudienceChoice(t) {
                    this.audienceIndex = t, un.set("beatmap", this.instrumentChoices[t].beatmapSlug, "code"), un.set("instrument", this.instrumentChoices[t].instrumentSlug, "code")
                },
                async onStartClick() {
                    if (this.player.responseKey) try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            startSong: !0
                        })
                    } catch (t) {
                        this.$handleEcastError(t)
                    }
                }
            }
        }),
        aEe = {
            class: "instrument-select"
        },
        cEe = {
            class: "constrain menu has-header"
        },
        uEe = {
            class: "title-wrapper"
        },
        lEe = {
            class: "title"
        },
        hEe = ["aria-label"],
        fEe = {
            class: "choices-wrapper"
        },
        dEe = {
            class: "choices"
        },
        pEe = ["onClick"],
        mEe = {
            class: "sub"
        },
        gEe = {
            class: "avatars"
        },
        _Ee = {
            class: "details"
        },
        yEe = {
            class: "info"
        },
        vEe = {
            class: "name"
        },
        bEe = {
            class: "label"
        },
        EEe = {
            class: "value"
        },
        SEe = {
            class: "box difficulty"
        },
        TEe = {
            class: "label"
        },
        wEe = {
            class: "value"
        },
        OEe = {
            class: "box lanes"
        },
        AEe = {
            class: "label"
        },
        CEe = {
            class: "value"
        };

    function IEe(t, e, n, r, s, i) {
        const a = ot("LeftArrowSVG"),
            c = ot("InstrumentSVG"),
            l = ot("AvatarSVG"),
            h = ot("CategorySVG"),
            d = ot("LanesSVG"),
            p = ot("ContinuousTester"),
            g = ot("DiscreteTester"),
            v = ot("PlayerHeader"),
            b = ot("ChangeVIP"),
            T = fn("t");
        return Y(), X("div", aEe, [W("div", cEe, [W("div", uEe, [Ge(W("h3", lEe, null, 512), [
            [T, "MENU.CHOOSE_INSTRUMENT"]
        ]), t.info.isVip ? (Y(), X("button", {
            key: 0,
            "aria-label": t.$t("ACTION.BACK"),
            class: "back",
            onClick: e[0] || (e[0] = (...m) => t.onBackClick && t.onBackClick(...m))
        }, [Qe(a)], 8, hEe)) : Ve("", !0)]), W("div", fEe, [W("div", dEe, [(Y(!0), X(St, null, In(t.instrumentChoices, (m, w) => (Y(), X("button", {
            key: w,
            class: mt([{
                selected: m.isSelected
            }, "choice has-icon has-sub"]),
            onClick: xi(P => t.onInstrumentClick(w), ["prevent"])
        }, [Qe(c, {
            category: m.category,
            slug: m.instrumentSlug,
            class: "icon"
        }, null, 8, ["category", "slug"]), Nn(" " + _t(m.label) + " ", 1), W("span", mEe, _t(m.difficultyName), 1), W("div", gEe, [(Y(!0), X(St, null, In(m.players, P => (Y(), X("div", {
            key: P.name,
            focusable: "false",
            class: "avatar-wrapper"
        }, [Qe(l, {
            avatar: P.avatar
        }, null, 8, ["avatar"])]))), 128))])], 10, pEe))), 128))])]), W("div", _Ee, [W("div", yEe, [W("p", vEe, _t(t.selectedChoice.label), 1), W("div", {
            class: mt(["box part", t.categoryClass])
        }, [Qe(h, {
            category: t.selectedBeatmap.config.category,
            class: "icon"
        }, null, 8, ["category"]), Ge(W("p", bEe, null, 512), [
            [T, "MENU.SONG_PART"]
        ]), W("p", EEe, _t(t.categoryName), 1)], 2), W("div", SEe, [Ge(W("p", TEe, null, 512), [
            [T, "MENU.DIFFICULTY"]
        ]), W("p", wEe, _t(t.selectedChoice.difficultyName), 1)]), W("div", OEe, [Ge(W("p", AEe, null, 512), [
            [T, "MENU.LANES"]
        ]), W("p", CEe, [Qe(d, {
            lanes: t.selectedBeatmap.config.laneCount ?? null,
            class: "icon"
        }, null, 8, ["lanes"]), Nn(" " + _t(t.selectedBeatmap.config.laneCount ?? ""), 1)])])]), t.selectedBeatmap.config.type === "Continuous" ? (Y(), Vt(p, {
            key: 0,
            beatmap: t.selectedBeatmap,
            instrument: t.selectedInstrument
        }, null, 8, ["beatmap", "instrument"])) : (Y(), Vt(g, {
            key: 1,
            beatmap: t.selectedBeatmap,
            instrument: t.selectedInstrument
        }, null, 8, ["beatmap", "instrument"]))]), t.info.isVip ? Ge((Y(), X("button", {
            key: 0,
            class: "commit",
            onClick: e[1] || (e[1] = (...m) => t.onStartClick && t.onStartClick(...m))
        }, null, 512)), [
            [T, "MENU.START_SONG"]
        ]) : Ve("", !0)]), Qe(v, {
            info: t.info,
            players: t.players,
            "is-vip": t.info.isVip && !t.info.isSolo,
            "response-key": t.player.responseKey,
            onDidRequestChangeVip: t.onDidRequestChangeVIP
        }, null, 8, ["info", "players", "is-vip", "response-key", "onDidRequestChangeVip"]), Qe(xs, {
            name: "modal"
        }, {
            default: cs(() => [t.showChangeVIP && t.player.responseKey ? (Y(), Vt(b, {
                key: 0,
                info: t.info,
                players: t.players,
                "response-key": t.player.responseKey,
                onDidRequestClose: t.onDidRequestModalClose
            }, null, 8, ["info", "players", "response-key", "onDidRequestClose"])) : Ve("", !0)]),
            _: 1
        })])
    }
    const kEe = ct(oEe, [
            ["render", IEe],
            ["__scopeId", "data-v-b2441b28"]
        ]),
        NEe = yt({
            components: {
                PlayerHeader: fu
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                }
            },
            data() {
                return {
                    isOn: !1
                }
            },
            methods: {
                onClick() {
                    this.isOn = !this.isOn
                }
            }
        }),
        xEe = {
            class: "constrain"
        },
        PEe = e4('<circle class="glow glow-2" cx="100" cy="100" r="100" data-v-6bf0f020></circle><circle class="glow glow-1" cx="100" cy="100" r="50" data-v-6bf0f020></circle><circle class="glow glow-0" cx="100" cy="100" r="30" data-v-6bf0f020></circle><path class="body" d="m111.81,34.5c2.73-.71,4.59,3.41,6.88,1.97.59-.59.59-1.54,0-2.12-5.3-5.69-15.7-2.2-16.51,5.52-1.04-.1-2.12-.14-3.17-.09-.87-7.67-11.22-11.09-16.49-5.43-.59.59-.59,1.54,0,2.12.59.59,1.54.59,2.12,0,3.62-3.88,10.72-1.6,11.39,3.66-24.46,2.26-11.41,69.01,3.97,68.2,15.07.8,28.11-63.97,5.13-67.94.34-3.28,3.37-5.96,6.67-5.89Z" data-v-6bf0f020></path><path class="bottom-wing left" d="m98.71,50.9c8.7,7.81-21.59,50.03-31.91,39.49-8.7-7.81,21.59-50.03,31.91-39.49Z" data-v-6bf0f020></path><path class="bottom-wing right" d="m101.29,50.9c10.33-10.54,40.62,31.68,31.91,39.49-10.33,10.54-40.62-31.68-31.91-39.49Z" data-v-6bf0f020></path><path class="top-wing left" d="m98.58,48.04c9.59,9.1-26.11,44.79-35.2,35.2-9.59-9.1,26.11-44.79,35.2-35.2Z" data-v-6bf0f020></path><path class="top-wing right" d="m101.42,48.04c9.1-9.59,44.79,26.11,35.2,35.2-9.1,9.59-44.79-26.11-35.2-35.2Z" data-v-6bf0f020></path>', 8),
        REe = [PEe];

    function MEe(t, e, n, r, s, i) {
        const a = ot("PlayerHeader");
        return Y(), X("div", {
            class: mt(["playback", {
                on: t.isOn
            }])
        }, [W("div", xEe, [(Y(), X("svg", {
            class: "fly",
            viewBox: "0 0 200 200",
            onClick: e[0] || (e[0] = (...c) => t.onClick && t.onClick(...c))
        }, REe))]), Qe(a, {
            info: t.info
        }, null, 8, ["info"])], 2)
    }
    const DEe = ct(NEe, [
        ["render", MEe],
        ["__scopeId", "data-v-6bf0f020"]
    ]);
    class $Ee {
        constructor() {
            Ce(this, "idCounter", 1);
            Ce(this, "idMap", new Map);
            Ce(this, "fnMap", new Map);
            Ce(this, "times", [])
        }
        schedule(e, n) {
            const r = this.idCounter,
                s = this.idMap.get(n);
            return s ? s.push(this.idCounter) : (this.idMap.set(n, [r]), this.times.push(n), this.times.sort((i, a) => i - a)), this.fnMap.set(r, e), this.idCounter += 1, r
        }
        cancel(e) {
            this.fnMap.delete(e)
        }
        call(e) {
            const n = this.fnMap.get(e);
            this.fnMap.delete(e), n && n()
        }
        check(e) {
            let n = 0;
            for (let r = 0; r < this.times.length && !(this.times[r] > e); r++) {
                n += 1;
                const s = this.idMap.get(this.times[r]);
                s && s.forEach(i => this.call(i))
            }
            this.times.splice(0, n)
        }
    }
    class Nk {
        constructor(e) {
            Ce(this, "criteria");
            Ce(this, "difficulty");
            Ce(this, "duration");
            Ce(this, "guide");
            Ce(this, "instraface");
            Ce(this, "isAudience");
            Ce(this, "isLoaded", Qr(!1));
            Ce(this, "missThreshold");
            Ce(this, "audienceReportAt", 0);
            Ce(this, "inputs", new Map);
            Ce(this, "manifest", new Map);
            Ce(this, "callbackMap", new Map);
            Ce(this, "scheduler", new $Ee);
            Ce(this, "accuracy", 0);
            Ce(this, "currentCombo", 0);
            Ce(this, "longestCombo", 0);
            Ce(this, "pastNotes", 0);
            Ce(this, "noteQualityScoreFactors");
            Ce(this, "scorePerHighestCombo");
            Ce(this, "scorePoolPerDifficulty");
            Ce(this, "successPercentage");
            Ce(this, "appearThreshold", 3e3);
            Ce(this, "baseTime");
            Ce(this, "disappearThreshold", 1e3);
            Ce(this, "hasStarted", !1);
            Ce(this, "isComplete", !1);
            Ce(this, "isRunning", !1);
            Ce(this, "lastTime", 0);
            Ce(this, "currentTime", 0);
            Ce(this, "progress", 0);
            Ce(this, "pendingInputs", []);
            Ce(this, "reportInterval");
            Ce(this, "responseKey");
            Ce(this, "wsClient");
            this.criteria = e.criteria, this.difficulty = e.beatmap.difficulty, this.duration = e.duration, this.guide = e.guide, this.isAudience = e.isAudience, this.missThreshold = e.criteria.time[e.criteria.time.length - 1], this.noteQualityScoreFactors = e.noteQualityScoreFactors, this.scorePerHighestCombo = e.scorePerHighestCombo, this.scorePoolPerDifficulty = e.scorePoolPerDifficulty, this.successPercentage = e.successPercentage, this.currentTime = e.offset ?? 0, this.responseKey = e.responseKey, this.wsClient = e.wsClient;
            const n = `https://cdn.jackboxgames.com/nopus-opus/instruments/${e.instrument.slug}`;
            this.instraface = new u2({
                baseUrl: n,
                config: e.instrument
            }), this.instraface.outNode.volume.value = 8, this.isAudience || (this.reportInterval = window.setInterval(() => {
                this.onReportInterval()
            }, 2e3)), this.parseInputs(e.beatmap), this.awaitForLoaded()
        }
        get now() {
            return this.baseTime ? Math.round(window.performance.now() - this.baseTime) : 0
        }
        get scorePool() {
            return this.scorePoolPerDifficulty[this.difficulty - 1]
        }
        millisecondsToY(e) {
            return e / this.duration
        }
        durationToHeight(e) {
            return e / this.duration
        }
        async awaitForLoaded() {
            await X0(), this.isLoaded.value = !0
        }
        start(e) {
            this.baseTime = Math.round(window.performance.now()), e !== void 0 && (this.currentTime = e, this.baseTime -= e), this.hasStarted = !0, this.isRunning = !0, window.requestAnimationFrame(this.onRequestAnimationFrame.bind(this))
        }
        stop() {
            this.isRunning = !1
        }
        destroy() {
            var e;
            this.stop(), this.callbackMap.clear(), (e = this.instraface) == null || e.update({
                config: null
            }), delete this.instraface, this.reportInterval && (window.clearInterval(this.reportInterval), delete this.reportInterval)
        }
        schedule(e, n) {
            return this.scheduler.schedule(e, n + this.now)
        }
        on(e, n) {
            const r = this.callbackMap.get(e) ?? new Set;
            r.size || this.callbackMap.set(e, r), r.add(n)
        }
        off(e, n) {
            const r = this.callbackMap.get(e);
            r && r.delete(n)
        }
        emit(e) {
            var n;
            (n = this.callbackMap.get(e.type)) == null || n.forEach(r => r(e))
        }
        scoreInput(e) {
            if (this.pastNotes += 1, e === null) {
                this.currentCombo = 0;
                return
            }
            this.accuracy += this.noteQualityScoreFactors[e], this.currentCombo += 1, this.currentCombo > this.longestCombo && (this.longestCombo = this.currentCombo)
        }
        onRequestAnimationFrame() {
            this.isRunning && (this.onFrame(), window.requestAnimationFrame(this.onRequestAnimationFrame.bind(this)))
        }
        onFrame() {
            const e = this.now;
            this.emit({
                type: "frame",
                now: e,
                debug: e
            }), e >= this.duration ? this.onEnd() : (this.currentTime = this.now, this.progress = this.millisecondsToY(this.currentTime));
            for (let n = this.lastTime; n < this.currentTime; n++) this.scheduler.check(n), this.processMillisecond(n);
            this.lastTime = this.currentTime
        }
        addInput(e, n) {
            Object.keys(n).forEach(i => {
                const a = n[i];
                this.manifest.get(a) || this.manifest.set(a, new Map), this.manifest.get(a).get(i) || this.manifest.get(a).set(i, new Set), this.manifest.get(a).get(i).add(e)
            });
            const s = this.inputs.get(n.start) ?? new Set;
            s.add(e), this.inputs.set(n.start, s)
        }
        processMillisecond(e) {
            var r, s, i, a, c;
            e === this.audienceReportAt && this.reportAudience();
            const n = this.manifest.get(e);
            n && ((r = n.get("appear")) == null || r.forEach(this.inputDidAppear.bind(this)), (s = n.get("disappear")) == null || s.forEach(this.inputDidDisappear.bind(this)), (i = n.get("end")) == null || i.forEach(this.inputDidEnd.bind(this)), (a = n.get("miss")) == null || a.forEach(this.inputWasMissed.bind(this)), (c = n.get("start")) == null || c.forEach(this.inputDidStart.bind(this)))
        }
        onEnd() {
            this.isRunning = !1, this.isComplete = !0, this.currentTime = this.duration, this.progress = 1, this.stop()
        }
        inputDidAppear(e) {
            e.isVisible = !0
        }
        inputDidDisappear(e) {
            e.isVisible = !1
        }
        inputDidEnd(e) {
            e.isCurrent = !1
        }
        inputWasMissed(e) {
            e.isHolding || e.isMissed || e.isTaken || (this.scoreInput(null), e.isMissed = !0)
        }
        inputDidStart(e) {
            e.isCurrent = !0
        }
        reportInput(e) {
            this.isAudience || this.reportInterval && this.pendingInputs.push(e)
        }
        async onReportInterval() {
            if (this.isAudience) return;
            if (!this.pendingInputs.length) {
                console.log("[reporter] Did not send because there is nothing pending");
                return
            }
            const e = this.pendingInputs.sort((n, r) => n.start - r.start);
            this.pendingInputs = [];
            try {
                console.log(`[reporter] Sending ${e.length} inputs`, e.map(n => n.start)), await this.wsClient.updateObject(this.responseKey, {
                    input: e
                })
            } catch (n) {
                console.error(n)
            }
        }
        async reportAudience() {
            if (!this.isAudience) return;
            const e = Math.round(this.accuracy / this.pastNotes * 100);
            if (e !== 0) try {
                await this.wsClient.incrementCountGroupCounter(this.responseKey, `${e}`)
            } catch (n) {
                console.error(n)
            }
        }
    }
    class LEe extends Nk {
        constructor(n) {
            super(n);
            Ce(this, "activeAt");
            Ce(this, "activeQuality");
            Ce(this, "activePlayed");
            Ce(this, "currentInput");
            Ce(this, "currentLimits");
            Ce(this, "currentPerfect", null);
            Ce(this, "currentSignal", null);
            Ce(this, "currentQuality", null);
            Ce(this, "isActive", !1);
            Ce(this, "isFlubbing", !1);
            Ce(this, "pointerId");
            Ce(this, "trackedSignals");
            Ce(this, "feedback", []);
            Ce(this, "limitsIndex", new Map);
            Ce(this, "perfectIndex", new Map);
            if (this.parseLimits(n.beatmap), this.parsePerfects(n.beatmap), this.currentLimits = this.limitsIndex.get(0), n.isAudience) {
                const r = n.beatmap.inputs[n.beatmap.inputs.length - 1];
                this.audienceReportAt = r.start + r.duration + 50
            }
        }
        roundSignal(n) {
            return Math.round(n * 1e3) / 1e3
        }
        getPathForInput(n) {
            let r = "";
            return n.signal.forEach((s, i) => {
                const a = 1 - s.start / n.duration;
                r += `${i?"L":"M"} ${s.signal} ${a} `
            }), r
        }
        getQuality(n) {
            const r = this.criteria.signal.findIndex(s => n < s);
            return r === -1 ? null : r
        }
        parseInputs(n) {
            n.inputs.forEach(s => {
                const i = {
                    duration: s.duration,
                    height: this.durationToHeight(s.duration),
                    isAudible: !1,
                    isCurrent: !1,
                    isHolding: !1,
                    isMissed: !1,
                    isTaken: !1,
                    isVisible: !1,
                    path: this.getPathForInput(s),
                    signal: s.signal,
                    start: s.start,
                    y: this.millisecondsToY(s.start)
                };
                this.addInput(i, {
                    appear: i.start - this.appearThreshold,
                    disappear: i.start + i.duration + this.disappearThreshold,
                    end: i.start + i.duration,
                    miss: i.start + i.duration,
                    start: i.start
                })
            })
        }
        parseLimits(n) {
            n.limits && n.limits.forEach(r => {
                this.limitsIndex.set(r[0], [r[1], r[2]])
            })
        }
        parsePerfects(n) {
            n.inputs.forEach(s => {
                s.signal.forEach(i => {
                    this.perfectIndex.set(s.start + i.start, i.signal)
                }), this.perfectIndex.set(s.start + s.duration, null)
            })
        }
        onDown(n, r) {
            if (this.instraface && this.isRunning) {
                if (this.pointerId === r) {
                    this.onMove(n, r);
                    return
                }
                this.pointerId === void 0 && (n = this.roundSignal(n), this.instraface.continuous.attack(n, this.currentLimits[0], this.currentLimits[1]), this.trackedSignals = [{
                    start: 0,
                    signal: n
                }], this.currentInput && (this.currentInput.isHolding = !0), this.activeAt = this.now, this.isActive = !0, this.pointerId = r, this.currentSignal = n)
            }
        }
        onMove(n, r) {
            if (!this.instraface || !this.isRunning || this.pointerId !== r || !this.trackedSignals) return;
            n = this.roundSignal(n), this.instraface.continuous.update(n, this.currentLimits[0], this.currentLimits[1]), this.currentInput && (this.currentInput.isHolding = !0);
            const s = this.now - this.activeAt;
            this.trackedSignals[this.trackedSignals.length - 1].start + 150 > s || (this.trackedSignals.push({
                start: s,
                signal: n
            }), this.currentSignal = n)
        }
        onUp(n) {
            this.instraface && (n && this.pointerId !== n || this.trackedSignals && (this.instraface.continuous.release(), this.currentInput && (this.currentInput.isHolding = !1, this.currentInput.isTaken = !0), this.trackedSignals && this.activeAt && this.reportInput({
                start: this.activeAt,
                duration: this.now - this.activeAt,
                signal: this.trackedSignals
            }), this.isActive = !1, this.currentSignal = null, delete this.trackedSignals, delete this.pointerId, delete this.activeAt))
        }
        processMillisecond(n) {
            super.processMillisecond(n);
            const r = this.limitsIndex.get(n);
            r && (this.currentLimits = r);
            const s = this.perfectIndex.get(n);
            s !== void 0 && (this.currentPerfect = s), this.processSignal()
        }
        inputDidEnd(n) {
            super.inputDidEnd(n);
            const r = this.activePlayed / this.currentInput.duration * 100,
                s = this.criteria.percentage.findIndex(c => r <= c),
                i = this.criteria.factors[s] ?? 0,
                a = this.activeQuality / this.currentInput.duration * i;
            this.scoreInput(a), delete this.activeQuality, delete this.activePlayed, delete this.currentInput
        }
        onEnd() {
            super.onEnd(), this.pointerId && this.onUp(this.pointerId)
        }
        inputDidStart(n) {
            super.inputDidStart(n), this.activeQuality = 0, this.activePlayed = 0, this.currentInput = n
        }
        processSignal() {
            if (!this.currentInput || this.currentPerfect === null || this.currentSignal === null) return;
            const n = Math.abs(this.currentSignal - this.currentPerfect),
                r = this.getQuality(n);
            this.currentQuality = r, this.activePlayed += 1, r !== null && (this.activeQuality += this.criteria.factors[r])
        }
    }
    const FEe = yt({
            props: {
                manager: {
                    type: Object,
                    required: !0
                }
            },
            methods: {
                normalizeSignal(t) {
                    return t < .25 ? 0 : t > .75 ? 1 : (t - .25) * 2
                },
                onPointerBoxStart(t) {
                    this.manager.isRunning && this.manager.onDown(this.normalizeSignal(t.detail.percentX), t.detail.id)
                },
                onPointerBoxMove(t) {
                    this.manager.isRunning && this.manager.onMove(this.normalizeSignal(t.detail.percentX), t.detail.id)
                },
                onPointerBoxEnd(t) {
                    this.manager.onUp(t.detail.id)
                },
                onReleaserUp(t) {
                    this.manager.onUp(t.pointerId)
                },
                onContextMenu() {
                    this.manager.onUp()
                }
            }
        }),
        UEe = {
            class: "constrainer controls"
        };

    function BEe(t, e, n, r, s, i) {
        const a = fn("pointerbox");
        return Y(), X(St, null, [W("div", {
            class: "releaser",
            onPointerup: e[0] || (e[0] = (...c) => t.onReleaserUp && t.onReleaserUp(...c))
        }, null, 32), W("div", UEe, [Ge(W("div", {
            class: "hitbox",
            onContextmenu: e[1] || (e[1] = (...c) => t.onContextMenu && t.onContextMenu(...c)),
            "onPointerbox:start": e[2] || (e[2] = (...c) => t.onPointerBoxStart && t.onPointerBoxStart(...c)),
            "onPointerbox:move": e[3] || (e[3] = (...c) => t.onPointerBoxMove && t.onPointerBoxMove(...c)),
            "onPointerbox:end": e[4] || (e[4] = (...c) => t.onPointerBoxEnd && t.onPointerBoxEnd(...c))
        }, null, 544), [
            [a, void 0, void 0, {
                restrict: !0
            }]
        ])])], 64)
    }
    const qEe = ct(FEe, [
            ["render", BEe],
            ["__scopeId", "data-v-3f3f6133"]
        ]),
        VEe = yt({
            props: {
                duration: {
                    type: Number,
                    required: !0
                },
                guide: {
                    type: Array,
                    required: !0
                }
            },
            computed: {
                beatLines() {
                    const t = this.guide.flat(),
                        e = [];
                    for (let n = 0; n < t.length; n += 2) {
                        const r = t[n],
                            s = t[n + 1] ?? this.duration,
                            i = s - r;
                        e.push({
                            debug: [r, s],
                            styles: {
                                bottom: `${r/this.duration*100}%`,
                                height: `${i/this.duration*100}%`
                            }
                        })
                    }
                    return e
                }
            }
        }),
        jEe = {
            class: "beat-lines"
        },
        GEe = {
            class: "debug"
        },
        WEe = {
            class: "debug"
        };

    function HEe(t, e, n, r, s, i) {
        return Y(), X("div", jEe, [(Y(!0), X(St, null, In(t.beatLines, (a, c) => (Y(), X("div", {
            key: c,
            class: "beat-line",
            style: Jn(a.styles)
        }, [W("p", GEe, _t(Math.round(a.debug[0])), 1), W("p", WEe, _t(Math.round(a.debug[1])), 1)], 4))), 128))])
    }
    const xk = ct(VEe, [
            ["render", HEe],
            ["__scopeId", "data-v-ea04da8a"]
        ]),
        KEe = yt({
            components: {
                Beatlines: xk
            },
            props: {
                manager: {
                    type: Object,
                    required: !0
                },
                isDesktop: {
                    type: Boolean,
                    required: !0
                },
                showCta: {
                    type: Boolean,
                    required: !0
                }
            },
            computed: {
                scrollStyles() {
                    return {
                        transform: `translateY(${this.manager.progress*100}%)`
                    }
                },
                hitIndicator() {
                    const t = [];
                    return this.manager.isActive && t.push("active"), this.manager.isFlubbing && t.push("flubbing"), {
                        debug: "",
                        classes: t,
                        styles: {
                            left: `${(this.manager.currentSignal??0)*100}%`
                        }
                    }
                },
                inputs() {
                    const t = [];
                    return this.manager.inputs.forEach(e => {
                        e.forEach(n => {
                            if (!n.isVisible) return;
                            const r = {
                                classes: [],
                                debug: n.start,
                                path: n.path,
                                indicator: {
                                    classes: [],
                                    styles: {
                                        left: `${n.signal[0].signal*100}%`
                                    }
                                },
                                key: n.start,
                                line: {
                                    classes: [],
                                    styles: {}
                                },
                                styles: {
                                    height: `${n.height*100}%`,
                                    bottom: `${n.y*100}%`
                                }
                            };
                            n.isHolding && r.classes.push("holding"), n.isMissed && r.classes.push("missed"), t.push(r)
                        })
                    }), t
                },
                scoring() {
                    var s;
                    const t = this.manager.longestCombo * this.manager.scorePerHighestCombo,
                        e = Math.round(this.manager.accuracy / this.manager.pastNotes * 100),
                        n = Math.round(this.manager.scorePool * (this.manager.accuracy / this.manager.pastNotes));
                    let r = 0;
                    return this.manager.activeQuality !== void 0 && this.manager.currentInput && (r = this.manager.activeQuality / this.manager.currentInput.duration), {
                        currentDuration: (s = this.manager.currentInput) == null ? void 0 : s.duration,
                        currentLimits: this.manager.currentLimits,
                        currentPerfect: this.manager.currentPerfect,
                        currentQuality: this.manager.currentQuality,
                        currentSignal: this.manager.currentSignal,
                        activeQualityTotal: this.manager.activeQuality,
                        activeQuality: r,
                        activePlayed: this.manager.activePlayed,
                        accuracyPercentage: `${e}%`,
                        accuracyScore: n,
                        scorePool: this.manager.scorePool,
                        currentCombo: this.manager.currentCombo,
                        longestCombo: this.manager.longestCombo,
                        comboBonus: t,
                        totalInputs: this.manager.inputs.size,
                        score: n + t
                    }
                }
            }
        }),
        YEe = t => (Di("data-v-ccf5ffa7"), t = t(), $i(), t),
        zEe = {
            class: "visuals"
        },
        ZEe = {
            class: "scroll-wrapper"
        },
        XEe = YEe(() => W("div", {
            class: "touch-line"
        }, null, -1)),
        QEe = {
            class: "scroll-wrapper"
        },
        JEe = {
            class: "constrainer"
        },
        eSe = ["d"],
        tSe = ["d"],
        nSe = {
            class: "constrainer foreground"
        },
        rSe = {
            key: 0,
            class: "cta-container"
        },
        sSe = {
            class: "cta"
        },
        iSe = {
            class: "debug scoring"
        };

    function oSe(t, e, n, r, s, i) {
        const a = ot("Beatlines"),
            c = fn("t");
        return Y(), X("div", zEe, [W("div", ZEe, [Qe(a, {
            class: "scroll-container",
            guide: t.manager.guide,
            duration: t.manager.duration,
            style: Jn(t.scrollStyles)
        }, null, 8, ["guide", "duration", "style"])]), XEe, W("div", QEe, [W("div", {
            class: "inputs scroll-container",
            style: Jn(t.scrollStyles)
        }, [W("div", JEe, [(Y(!0), X(St, null, In(t.inputs, l => (Y(), X("div", {
            key: l.key,
            class: mt(["input", l.classes]),
            style: Jn(l.styles)
        }, [(Y(), X("svg", {
            viewBox: "0 0 1 1",
            preserveAspectRatio: "none",
            class: mt(l.line.classes),
            style: Jn(l.line.styles)
        }, [W("path", {
            class: "background",
            d: l.path
        }, null, 8, eSe), W("path", {
            class: "foreground",
            d: l.path
        }, null, 8, tSe)], 6))], 6))), 128))])], 4)]), W("div", nSe, [W("div", {
            class: mt(["hit-house", {
                alert: t.showCta
            }])
        }, null, 2), Qe(xs, {
            name: "cta"
        }, {
            default: cs(() => [t.showCta ? (Y(), X("div", rSe, [Ge(W("p", sSe, null, 512), [
                [c, "INFO.CONTINUOUS"]
            ])])) : Ve("", !0)]),
            _: 1
        })]), W("div", iSe, [(Y(!0), X(St, null, In(t.scoring, (l, h) => (Y(), X("p", {
            key: h
        }, _t(h) + ": " + _t(l), 1))), 128))])])
    }
    const aSe = ct(KEe, [
        ["render", oSe],
        ["__scopeId", "data-v-ccf5ffa7"]
    ]);
    class cSe extends Nk {
        constructor(n) {
            super(n);
            Ce(this, "lanes", []);
            if (this.parseLanes(n.beatmap.laneCount), n.isAudience) {
                const r = n.beatmap.inputs[n.beatmap.inputs.length - 1];
                this.audienceReportAt = r.start + (r.duration ?? this.missThreshold)
            }
        }
        laneWithPointerId(n) {
            return this.lanes.find(r => r.pointerId === n) ?? null
        }
        getDurationOfNotes(n) {
            return Math.max(...n.map(r => r.start + r.duration))
        }
        getNextInputOnLane(n) {
            const r = this.now;
            for (let s = r - this.missThreshold; s < r + this.missThreshold; s++) {
                const i = n.inputIndex.get(s);
                if (i && !i.isTaken) return i
            }
            return null
        }
        parseInputs(n) {
            n.inputs.forEach(s => {
                const i = this.getDurationOfNotes(s.notes),
                    [a, c] = this.parseNoteIndexes(s.notes),
                    l = s.lanes.map(p => ({
                        isDown: !1,
                        key: `${s.start}:${p}`,
                        lane: p
                    })),
                    h = {
                        attackIds: [],
                        attackIndex: a,
                        audioDuration: i,
                        audioHeight: this.durationToHeight(i),
                        indicators: l,
                        isAudible: !1,
                        isCurrent: !1,
                        isHold: s.duration !== void 0,
                        isHolding: !1,
                        isMissed: !1,
                        isTaken: !1,
                        isVisible: !1,
                        lanes: s.lanes,
                        notes: s.notes,
                        releaseIds: [],
                        releaseIndex: c,
                        start: s.start,
                        y: this.millisecondsToY(s.start)
                    };
                s.duration && (h.duration = s.duration, h.height = this.durationToHeight(h.duration));
                const d = s.duration ?? 0;
                this.addInput(h, {
                    appear: h.start - this.appearThreshold,
                    disappear: h.start + d + this.disappearThreshold,
                    end: h.start + d,
                    miss: h.start + this.missThreshold,
                    start: h.start
                })
            })
        }
        parseNoteIndexes(n) {
            const r = new Map,
                s = new Map;
            return n.forEach(i => {
                const a = i.start,
                    c = r.get(a) ?? [];
                c.push(i.note), r.set(a, c);
                const l = i.start + i.duration,
                    h = s.get(l) ?? [];
                h.push(i.note), s.set(l, h)
            }), [r, s]
        }
        parseLanes(n) {
            for (let r = 0; r < n; r++) {
                const s = {
                    feedback: [],
                    index: r,
                    isActive: !1,
                    isAudible: !1,
                    isFlubbing: !1,
                    inputIndex: new Map
                };
                this.inputs.forEach((i, a) => {
                    i.forEach(c => {
                        c.lanes.includes(r) && s.inputIndex.set(a, c)
                    })
                }), this.lanes.push(s)
            }
        }
        onEnd() {
            super.onEnd(), this.lanes.forEach(n => {
                n.pointerId && this.onUp(n.pointerId)
            })
        }
        onDown(n, r) {
            if (!this.isRunning) return;
            const s = this.lanes[n];
            if (s.isActive || this.laneWithPointerId(r)) return;
            s.activeAt = this.now, s.isActive = !0, s.pointerId = r;
            const a = this.getNextInputOnLane(s);
            if (!a) {
                this.flubOnLane(s);
                return
            }
            if (!a.lanes.every(g => this.lanes[g].isActive)) return;
            const h = a.lanes.reduce((g, v) => this.lanes[v].activeAt + g, 0) / a.lanes.length,
                d = Math.abs(h - a.start),
                p = this.criteria.time.findIndex(g => d < g);
            p === void 0 && console.warn("unexpected quality"), a.isHold ? (a.isHolding = !0, a.pendingQuality = p, a.lanes.forEach(g => {
                this.lanes[g].activeInput = a
            })) : (a.isTaken = !0, this.scoreInput(p), a.lanes.forEach(g => {
                this.lanes[g].feedback.push(p)
            })), this.attackWithInput(a)
        }
        onUp(n) {
            const r = this.laneWithPointerId(n);
            if (!r) return;
            this.reportInput({
                start: r.activeAt,
                duration: this.now - r.activeAt,
                lane: r.index
            });
            const s = r.activeInput;
            s != null && s.isHold && (s.isTaken = !0, s.isHolding = !1, this.scoreInput(s.pendingQuality), s.lanes.forEach(i => {
                this.lanes[i].feedback.push(s.pendingQuality), delete this.lanes[i].activeInput
            }), this.releaseWithInput(s)), delete r.activeAt, r.isActive = !1, delete r.pointerId
        }
        flubOnLane(n) {
            this.instraface && (n.flubEndId && this.scheduler.cancel(n.flubEndId), n.isFlubbing = !0, this.instraface.flub.attack(), n.flubEndId = this.schedule(() => {
                n.isFlubbing = !1, delete n.flubEndId
            }, 250))
        }
        attackWithInput(n) {
            this.instraface && (n.attackIndex.forEach((r, s) => {
                if (s) {
                    const i = this.schedule(() => {
                        this.instraface.discrete.attack(r, r)
                    }, s);
                    n.attackIds.push(i);
                    return
                }
                this.instraface.discrete.attack(r, r)
            }), n.releaseIndex.forEach((r, s) => {
                const i = this.schedule(() => {
                    this.instraface.discrete.release(r)
                }, s);
                n.releaseIds.push(i)
            }))
        }
        releaseWithInput(n) {
            n.attackIds.forEach(r => this.scheduler.cancel(r)), n.releaseIds.forEach(r => this.scheduler.call(r))
        }
        async onReportInterval() {
            if (this.lanes.some(r => {
                    const s = r.activeInput;
                    return s == null ? void 0 : s.isHold
                })) {
                console.log(`[reporter] Did not send ${this.pendingInputs.length} because an input is being held`);
                return
            }
            await super.onReportInterval()
        }
    }
    const uSe = yt({
            components: {
                Beatlines: xk
            },
            props: {
                manager: {
                    type: Object,
                    required: !0
                },
                isDesktop: {
                    type: Boolean,
                    required: !0
                },
                showCta: {
                    type: Boolean,
                    required: !0
                }
            },
            computed: {
                layout() {
                    return l2(this.manager.lanes.length)
                },
                scrollStyles() {
                    return {
                        transform: `translateY(${this.manager.progress*100}%)`
                    }
                },
                laneLines() {
                    return this.layout.lanes.map(t => ({
                        classes: [],
                        styles: {
                            left: `${t.center*100}%`
                        }
                    }))
                },
                hitIndicators() {
                    return this.manager.lanes.map((t, e) => {
                        const n = [];
                        return this.manager.lanes[e].isActive && n.push("active"), this.manager.lanes[e].isFlubbing && n.push("flubbing"), this.showCta && n.push("alert"), {
                            classes: n,
                            text: this.layout.hotKeys[e],
                            styles: {
                                width: `${this.layout.hit*100}%`,
                                left: `${this.layout.lanes[e].center*100}%`
                            },
                            items: t.feedback.map(r => r === 0 ? {
                                textKey: "QUALITY.PERFECT",
                                classes: ["perfect"]
                            } : r === 1 ? {
                                textKey: "QUALITY.GOOD",
                                classes: ["good"]
                            } : {
                                textKey: "QUALITY.OKAY",
                                classes: ["okay"]
                            })
                        }
                    })
                },
                inputs() {
                    const t = [];
                    return this.manager.inputs.forEach(e => {
                        e.forEach(n => {
                            n.isVisible && n.indicators.forEach(r => {
                                const s = this.layout.lanes[r.lane];
                                if (s === void 0) {
                                    console.warn("unrenderable lane", r.lane);
                                    return
                                }
                                const i = {
                                    classes: [],
                                    debug: n.start,
                                    isHold: n.isHold,
                                    key: r.key,
                                    styles: {
                                        left: `${s.center*100}%`,
                                        width: `${this.layout.hit*100}%`,
                                        bottom: `${n.y*100}%`
                                    }
                                };
                                n.isHolding && i.classes.push("holding"), n.isMissed && i.classes.push("missed"), n.isTaken && i.classes.push("taken"), n.isHold && n.height && (i.styles.height = `${n.height*100}%`), t.push(i)
                            })
                        })
                    }), t
                },
                scoring() {
                    const t = this.manager.longestCombo * this.manager.scorePerHighestCombo,
                        e = Math.round(this.manager.accuracy / this.manager.pastNotes * 100),
                        n = Math.round(this.manager.scorePool * (this.manager.accuracy / this.manager.pastNotes));
                    return {
                        accuracy: this.manager.accuracy,
                        accuracyPercentage: `${e}%`,
                        accuracyScore: n,
                        scorePool: this.manager.scorePool,
                        currentCombo: this.manager.currentCombo,
                        longestCombo: this.manager.longestCombo,
                        comboBonus: t,
                        totalInputs: this.manager.inputs.size,
                        score: n + t
                    }
                }
            }
        }),
        lSe = {
            class: "visuals"
        },
        hSe = {
            class: "scroll-wrapper"
        },
        fSe = {
            class: "constrainer"
        },
        dSe = {
            class: "lane-lines"
        },
        pSe = {
            class: "hit-indicators behind"
        },
        mSe = {
            class: "scroll-wrapper"
        },
        gSe = {
            class: "constrainer"
        },
        _Se = {
            key: 0,
            class: "hold-indicator"
        },
        ySe = {
            class: "tap-indicator"
        },
        vSe = {
            class: "debug"
        },
        bSe = {
            class: "constrainer foreground"
        },
        ESe = {
            key: 0,
            class: "hotkey"
        },
        SSe = {
            key: 0,
            class: "cta-container"
        },
        TSe = {
            class: "cta"
        },
        wSe = {
            class: "debug scoring"
        };

    function OSe(t, e, n, r, s, i) {
        const a = ot("Beatlines"),
            c = fn("t");
        return Y(), X("div", lSe, [W("div", hSe, [Qe(a, {
            class: "scroll-container",
            guide: t.manager.guide,
            duration: t.manager.duration,
            style: Jn(t.scrollStyles)
        }, null, 8, ["guide", "duration", "style"])]), W("div", fSe, [W("div", dSe, [(Y(!0), X(St, null, In(t.laneLines, (l, h) => (Y(), X("div", {
            key: h,
            class: mt(["lane-line", l.classes]),
            style: Jn(l.styles)
        }, null, 6))), 128))]), W("div", pSe, [(Y(!0), X(St, null, In(t.hitIndicators, (l, h) => (Y(), X("div", {
            key: h,
            class: mt(["hit-indicator", l.classes]),
            style: Jn(l.styles)
        }, null, 6))), 128))])]), W("div", mSe, [W("div", {
            class: "scroll-container",
            style: Jn(t.scrollStyles)
        }, [W("div", gSe, [(Y(!0), X(St, null, In(t.inputs, l => (Y(), X("div", {
            key: l.key,
            class: mt(["input", l.classes]),
            style: Jn(l.styles)
        }, [l.isHold ? (Y(), X("div", _Se)) : Ve("", !0), W("div", ySe, [W("p", vSe, _t(l.debug), 1)])], 6))), 128))])], 4)]), W("div", bSe, [(Y(!0), X(St, null, In(t.hitIndicators, (l, h) => (Y(), X("div", {
            key: h,
            class: mt(["hit-indicator", l.classes]),
            style: Jn(l.styles)
        }, [(Y(!0), X(St, null, In(l.items, (d, p) => Ge((Y(), X("span", {
            key: p,
            class: mt(["feedback-item", d.classes])
        }, null, 2)), [
            [c, d.textKey]
        ])), 128)), t.isDesktop ? (Y(), X("span", ESe, _t(l.text), 1)) : Ve("", !0)], 6))), 128)), Qe(xs, {
            name: "cta"
        }, {
            default: cs(() => [t.showCta ? (Y(), X("div", SSe, [Ge(W("p", TSe, null, 512), [
                [c, "INFO.DISCRETE"]
            ])])) : Ve("", !0)]),
            _: 1
        })]), W("div", wSe, [(Y(!0), X(St, null, In(t.scoring, (l, h) => (Y(), X("p", {
            key: h
        }, _t(h) + ": " + _t(l), 1))), 128))])])
    }
    const ASe = ct(uSe, [
            ["render", OSe],
            ["__scopeId", "data-v-5073f3a5"]
        ]),
        CSe = yt({
            props: {
                manager: {
                    type: Object,
                    required: !0
                }
            },
            emits: {
                didProveAsDesktop: () => !0
            },
            computed: {
                layout() {
                    return l2(this.manager.lanes.length)
                }
            },
            mounted() {
                window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp)
            },
            beforeUnmount() {
                window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp)
            },
            methods: {
                onPointerBoxStart(t) {
                    if (t.detail.type === "mouse" && this.$emit("didProveAsDesktop"), !this.manager.isRunning) return;
                    const e = t.detail.percentX;
                    if (e < 0 || e > 1) return;
                    const n = this.layout.lanes.findIndex(r => e >= r.left && e <= r.right);
                    n !== -1 && this.manager.onDown(n, t.detail.id)
                },
                onPointerBoxEnd(t) {
                    this.manager.onUp(t.detail.id)
                },
                onKeyDown(t) {
                    if (this.$emit("didProveAsDesktop"), !this.manager.isRunning) return;
                    let e = t.key.toLowerCase();
                    e === " " && (e = "space");
                    const n = this.layout.hotKeys.indexOf(e);
                    n !== -1 && this.manager.onDown(n, e)
                },
                onKeyUp(t) {
                    const e = t.key.toLowerCase();
                    this.manager.onUp(e)
                }
            }
        });

    function ISe(t, e, n, r, s, i) {
        const a = fn("pointerbox");
        return Ge((Y(), X("div", {
            class: "constrainer controls",
            "onPointerbox:start": e[0] || (e[0] = (...c) => t.onPointerBoxStart && t.onPointerBoxStart(...c)),
            "onPointerbox:end": e[1] || (e[1] = (...c) => t.onPointerBoxEnd && t.onPointerBoxEnd(...c))
        }, null, 544)), [
            [a, void 0, void 0, {
                multi: !0,
                restrict: !0
            }]
        ])
    }
    const kSe = ct(CSe, [
            ["render", ISe]
        ]),
        NSe = yt({
            components: {
                ContinuousControls: qEe,
                ContinuousVisuals: aSe,
                DiscreteControls: kSe,
                DiscreteVisuals: ASe
            },
            props: {
                beatmap: {
                    type: Object,
                    required: !0
                },
                countInOffset: {
                    type: Number,
                    required: !0
                },
                instrument: {
                    type: Object,
                    required: !0
                },
                isAudience: {
                    type: Boolean,
                    required: !0
                },
                isDesktop: {
                    type: Boolean,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                },
                shouldRun: {
                    type: Boolean,
                    required: !0
                }
            },
            data({
                beatmap: t,
                instrument: e,
                player: n,
                isDesktop: r
            }) {
                const s = {
                    beatmap: t.config,
                    criteria: {
                        time: n.recordingInfo.discreteCriteria,
                        factors: n.recordingInfo.continuousCriteriaFactors,
                        percentage: n.recordingInfo.continuousPercentageCriteria,
                        signal: n.recordingInfo.continuousSignalCriteria
                    },
                    duration: n.recordingInfo.duration,
                    guide: n.guide.guide,
                    instrument: e.config,
                    isAudience: this.isAudience,
                    noteQualityScoreFactors: n.recordingInfo.noteQualityScoreFactors,
                    offset: n.recordingInfo.position,
                    responseKey: n.responseEntity,
                    scorePerHighestCombo: n.recordingInfo.scorePerHighestCombo,
                    scorePoolPerDifficulty: n.recordingInfo.scorePoolPerDifficulty,
                    successPercentage: n.recordingInfo.successPercentage,
                    wsClient: this.$ecast
                };
                return {
                    manager: t.config.type === "Continuous" ? new LEe(s) : new cSe(s),
                    isDesktopLocal: r,
                    showCTA: !1
                }
            },
            computed: {
                classes() {
                    return this.beatmap.config.type === "Continuous" ? ["continuous"] : ["discrete"]
                }
            },
            watch: {
                shouldRun: {
                    immediate: !0,
                    handler: "onShouldRunChange"
                }
            },
            beforeUnmount() {
                var t;
                (t = this.manager) == null || t.destroy(), this.manager = null
            },
            methods: {
                onDesktopProof() {
                    this.isDesktopLocal = !0
                },
                onShouldRunChange(t, e) {
                    var n;
                    if (t && !e) {
                        let r = this.countInOffset;
                        this.player.recordingInfo.position ? r += this.player.recordingInfo.timeAfterCountInBeforeSong : (r += this.player.recordingInfo.timeAfterCountInBeforeSong, this.showCTA = !0, window.setTimeout(() => {
                            this.showCTA = !1
                        }, r + 1e3)), window.setTimeout(() => {
                            var s;
                            (s = this.manager) == null || s.start(this.player.recordingInfo.position)
                        }, r)
                    }!t && e && ((n = this.manager) == null || n.stop())
                }
            }
        });

    function xSe(t, e, n, r, s, i) {
        const a = ot("ContinuousVisuals"),
            c = ot("ContinuousControls"),
            l = ot("DiscreteVisuals"),
            h = ot("DiscreteControls");
        return t.manager ? (Y(), X("div", {
            key: 0,
            class: mt([t.classes, "beatmap"])
        }, [t.beatmap.config.type === "Continuous" ? (Y(), X(St, {
            key: 0
        }, [Qe(a, {
            manager: t.manager,
            "is-desktop": t.isDesktopLocal,
            "show-cta": t.showCTA
        }, null, 8, ["manager", "is-desktop", "show-cta"]), t.manager.isLoaded ? (Y(), Vt(c, {
            key: 0,
            manager: t.manager
        }, null, 8, ["manager"])) : Ve("", !0)], 64)) : (Y(), X(St, {
            key: 1
        }, [Qe(l, {
            manager: t.manager,
            "is-desktop": t.isDesktopLocal,
            "show-cta": t.showCTA
        }, null, 8, ["manager", "is-desktop", "show-cta"]), t.manager.isLoaded ? (Y(), Vt(h, {
            key: 0,
            manager: t.manager,
            onDidProveAsDesktop: t.onDesktopProof
        }, null, 8, ["manager", "onDidProveAsDesktop"])) : Ve("", !0)], 64))], 2)) : Ve("", !0)
    }
    const PSe = ct(NSe, [
            ["render", xSe]
        ]),
        RSe = "main/pp10/nopus-opus/assets/50849cf6.mp3",
        MSe = "main/pp10/nopus-opus/assets/9431923a.ogg",
        DSe = "main/pp10/nopus-opus/assets/2188b01d.mp3",
        $Se = "main/pp10/nopus-opus/assets/9f40765c.ogg",
        LSe = "main/pp10/nopus-opus/assets/20141192.mp3",
        FSe = "main/pp10/nopus-opus/assets/8e80ea3f.ogg",
        USe = yt({
            props: {
                state: {
                    type: String,
                    required: !0
                }
            },
            emits: {
                didCountIn: (t, e) => !0
            },
            setup() {
                const t = It.supportsType("ogg") ? "ogg" : "mp3";
                return {
                    players: new xl({
                        one: new URL(Object.assign({
                            "../../assets/tap1.mp3": RSe,
                            "../../assets/tap1.ogg": MSe
                        })[`../../assets/tap1.${t}`], self.location).href,
                        two: new URL(Object.assign({
                            "../../assets/tap2.mp3": DSe,
                            "../../assets/tap2.ogg": $Se
                        })[`../../assets/tap2.${t}`], self.location).href,
                        three: new URL(Object.assign({
                            "../../assets/tap3.mp3": LSe,
                            "../../assets/tap3.ogg": FSe
                        })[`../../assets/tap3.${t}`], self.location).href
                    }).toDestination()
                }
            },
            data() {
                return {
                    taps: 3,
                    count: 0,
                    timeoutDuration: 2500,
                    timeout: null,
                    desktopDetected: !1
                }
            },
            computed: {
                titleKey() {
                    return this.state === "Inactive" ? "COUNT_IN.WHEN" : this.count === 0 ? "COUNT_IN.GET_READY" : "COUNT_IN.SYNCING"
                },
                buttonKey() {
                    return this.state === "Inactive" ? "COUNT_IN.TAP_HERE" : this.count === this.taps ? "COUNT_IN.SYNCED" : "COUNT_IN.TAP"
                },
                classes() {
                    const t = [];
                    return this.state !== "Inactive" && this.state !== "CountIn" && t.push("resync"), this.state === "Inactive" ? t.push("inactive") : (t.push("tap-0"), this.count >= 1 && t.push("tap-1"), this.count >= 2 && t.push("tap-2"), this.count >= 3 && t.push("tap-3", "synced")), t
                }
            },
            mounted() {
                window.addEventListener("keydown", this.onKeyDown)
            },
            beforeUnmount() {
                window.removeEventListener("keydown", this.onKeyDown)
            },
            methods: {
                onKeyDown(t) {
                    t.key === " " && this.state !== "Inactive" && (this.desktopDetected = !0, this.onCount())
                },
                onPointerDown(t) {
                    this.state !== "Inactive" && (t.pointerType === "mouse" && (this.desktopDetected = !0), this.onCount())
                },
                onTimeout() {
                    this.count = this.taps, this.$emit("didCountIn", this.timeoutDuration, this.desktopDetected)
                },
                async onCount() {
                    this.count += 1, this.$vibrate(), this.timeout && (window.clearTimeout(this.timeout), this.timeout = null);
                    try {
                        await HI(), this.count === 1 && this.players.player("one").start(0, .01), this.count === 2 && this.players.player("two").start(0, .01), this.count === 3 && this.players.player("three").start(0, .01)
                    } catch (t) {
                        console.warn(t)
                    }
                    if (this.count === this.taps) {
                        this.$emit("didCountIn", 0, this.desktopDetected);
                        return
                    }
                    this.timeout = window.setTimeout(() => {
                        this.onTimeout()
                    }, this.timeoutDuration)
                }
            }
        }),
        BSe = {
            class: "constrain"
        },
        qSe = {
            class: "title-box"
        },
        VSe = {
            class: "title"
        },
        jSe = {
            class: "button-box"
        },
        GSe = ["disabled"],
        WSe = {
            class: "pip-box"
        };

    function HSe(t, e, n, r, s, i) {
        const a = fn("t"),
            c = fn("bb");
        return Y(), X("div", {
            class: mt(["count-in", t.classes])
        }, [W("div", BSe, [W("div", qSe, [Ge(W("p", VSe, null, 512), [
            [a, t.titleKey]
        ])]), W("div", jSe, [Ge(W("button", {
            class: "tap",
            disabled: t.state === "Inactive",
            onPointerdown: e[0] || (e[0] = (...l) => t.onPointerDown && t.onPointerDown(...l))
        }, null, 40, GSe), [
            [c, t.$t(t.buttonKey)]
        ])]), W("div", WSe, [Ge(W("span", null, null, 512), [
            [a, "COUNT_IN.TAP"]
        ]), Nn(" "), Ge(W("span", null, null, 512), [
            [a, "COUNT_IN.TAP"]
        ]), Nn(" "), Ge(W("span", null, null, 512), [
            [a, "COUNT_IN.TAP"]
        ])])])], 2)
    }
    const KSe = ct(USe, [
            ["render", HSe],
            ["__scopeId", "data-v-e35b3ee4"]
        ]),
        YSe = yt({}),
        zSe = {
            class: "progress"
        },
        ZSe = {
            class: "constrain"
        };

    function XSe(t, e, n, r, s, i) {
        const a = fn("t");
        return Y(), X("div", zSe, [W("div", ZSe, [Ge(W("p", null, null, 512), [
            [a, "INFO.IN_PROGRESS"]
        ])])])
    }
    const QSe = ct(YSe, [
            ["render", XSe],
            ["__scopeId", "data-v-df2aee3c"]
        ]),
        JSe = yt({}),
        eTe = {
            class: "paused"
        },
        tTe = {
            class: "constrain"
        };

    function nTe(t, e, n, r, s, i) {
        const a = fn("t");
        return Y(), X("div", eTe, [W("div", tTe, [Ge(W("p", null, null, 512), [
            [a, "INFO.RESYNC"]
        ])])])
    }
    const rTe = ct(JSe, [
            ["render", nTe],
            ["__scopeId", "data-v-c133f2a1"]
        ]),
        sTe = yt({
            components: {
                Beatmap: PSe,
                CountIn: KSe,
                InProgress: QSe,
                Paused: rTe
            },
            props: {
                beatmap: {
                    type: Object,
                    required: !0
                },
                hostIsPaused: {
                    type: Boolean,
                    required: !0
                },
                info: {
                    type: Object,
                    required: !0
                },
                instrument: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                }
            },
            data({
                player: t
            }) {
                const e = !t.recordingInfo.isTesting && t.recordingInfo.recordingState === "Playing",
                    n = t.recordingInfo.isTesting ?? !1,
                    r = !t.recordingInfo.isTesting;
                return {
                    runBeatmap: n,
                    showCountIn: r,
                    countInOffset: 0,
                    wasJoinedInProgress: e,
                    isDesktop: !1,
                    isDebug: un.get("nopus:debug") === "true",
                    isExploring: un.get("nopus:exploring") === "true"
                }
            },
            computed: {
                classes() {
                    const t = [Ii.categorySlugByKey(this.beatmap.config.category)];
                    return this.isDebug && t.push("is-debug"), this.isExploring && t.push("is-exploring"), t
                },
                drawDistance() {
                    return `${this.player.recordingInfo.duration*.05}%`
                }
            },
            watch: {
                hostIsPaused: {
                    handler: "onPauseChanged",
                    immediate: !0
                }
            },
            methods: {
                onPauseChanged(t) {
                    t && (this.runBeatmap = !1, this.showCountIn = !0, this.wasJoinedInProgress = !1)
                },
                onDidCountIn(t, e) {
                    this.isDesktop = e, this.countInOffset = t, this.runBeatmap = !0, window.setTimeout(() => {
                        this.showCountIn = !1
                    }, 1e3)
                },
                onDebugToggle() {
                    this.isDebug = !this.isDebug, un.set("nopus:debug", `${this.isDebug}`)
                },
                onExplorerToggle() {
                    this.isExploring = !this.isExploring, un.set("nopus:exploring", `${this.isExploring}`)
                }
            }
        }),
        Pk = t => (Di("data-v-49e79124"), t = t(), $i(), t),
        iTe = {
            class: "instrument"
        },
        oTe = Pk(() => W("br", null, null, -1)),
        aTe = Pk(() => W("br", null, null, -1));

    function cTe(t, e, n, r, s, i) {
        const a = ot("Beatmap"),
            c = ot("CountIn"),
            l = ot("Paused"),
            h = ot("InProgress");
        return Y(), X("div", {
            class: mt(["recording", t.classes]),
            style: Jn({
                "--draw-distance": t.drawDistance
            })
        }, [(Y(), Vt(a, {
            key: t.instrument.name,
            beatmap: t.beatmap,
            "count-in-offset": t.countInOffset,
            instrument: t.instrument,
            "is-audience": t.info.isAudience ?? !1,
            "is-desktop": t.isDesktop,
            player: t.player,
            "should-run": t.runBeatmap
        }, null, 8, ["beatmap", "count-in-offset", "instrument", "is-audience", "is-desktop", "player", "should-run"])), W("p", iTe, _t(t.instrument.name), 1), t.showCountIn ? (Y(), Vt(c, {
            key: 0,
            state: t.player.recordingInfo.recordingState,
            onDidCountIn: t.onDidCountIn
        }, null, 8, ["state", "onDidCountIn"])) : Ve("", !0), t.hostIsPaused ? (Y(), Vt(l, {
            key: 1
        })) : t.wasJoinedInProgress ? (Y(), Vt(h, {
            key: 2
        })) : Ve("", !0), W("button", {
            class: "debug-toggle toggle",
            onClick: e[0] || (e[0] = (...d) => t.onDebugToggle && t.onDebugToggle(...d))
        }, [Nn("DEBUG"), oTe, Nn(_t(t.isDebug ? "ON" : "OFF"), 1)]), W("button", {
            class: "exploring-toggle toggle",
            onClick: e[1] || (e[1] = (...d) => t.onExplorerToggle && t.onExplorerToggle(...d))
        }, [Nn("EXPLORER"), aTe, Nn(_t(t.isExploring ? "ON" : "OFF"), 1)])], 6)
    }
    const uTe = ct(sTe, [
            ["render", cTe],
            ["__scopeId", "data-v-49e79124"]
        ]),
        lTe = yt({
            components: {
                ChangeVIP: ym,
                PlayerHeader: fu
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                },
                players: {
                    type: Object,
                    required: !0
                },
                render: {
                    type: Object,
                    required: !1
                }
            },
            data() {
                return {
                    showChangeVIP: !1
                }
            },
            computed: {
                vipName() {
                    const t = Object.keys(this.players).find(e => this.players[e].isVip);
                    return t !== void 0 ? this.players[t].name : ""
                }
            },
            methods: {
                onDidRequestChangeVIP() {
                    this.showChangeVIP = !0
                },
                onDidRequestModalClose() {
                    this.showChangeVIP = !1
                },
                async onChoiceClick(t) {
                    if (this.player.responseKey) try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            [t]: !0
                        })
                    } catch (e) {
                        this.$handleEcastError(e)
                    }
                }
            }
        }),
        Rk = t => (Di("data-v-d11e6827"), t = t(), $i(), t),
        hTe = {
            class: "scoreboard"
        },
        fTe = {
            key: 0,
            class: "bite",
            viewBox: "0 0 200 100"
        },
        dTe = Rk(() => W("polygon", {
            class: "screen",
            points: "176.48 45.33 163.58 4.46 132.15 0 102.19 13.39 102.19 48.88 75.96 33.48 39.75 39.96 28.1 75.22 48.49 95.31 9.57 87.05 0 100 200 100 200 15.85 196.05 16.29 176.48 45.33"
        }, null, -1)),
        pTe = Rk(() => W("path", {
            class: "shadow",
            d: "m163.58,4.46l-31.43-4.46-29.97,13.39v25.61l14.57,3.74-3.95-18.42,18.11-12.28,26.43,3.79,4.79,26.9,11.26-7.23-9.8-31.05Zm-85.12,30.49l-2.5-1.47-36.21,6.47-11.65,35.27,10.75,10.58,18.36-.99-18.49-15.18,6.02-21.21,33.74-13.49Z"
        }, null, -1)),
        mTe = [dTe, pTe],
        gTe = {
            class: "constrain menu has-header"
        },
        _Te = {
            key: 0,
            class: "survived"
        },
        yTe = {
            key: 1,
            class: "eaten"
        },
        vTe = {
            class: "title-wrapper"
        },
        bTe = {
            key: 0,
            class: "title"
        },
        ETe = {
            key: 1,
            class: "title"
        },
        STe = {
            key: 2,
            class: "choices-wrapper"
        },
        TTe = {
            class: "choices"
        };

    function wTe(t, e, n, r, s, i) {
        var h;
        const a = ot("PlayerHeader"),
            c = ot("ChangeVIP"),
            l = fn("t");
        return Y(), X("div", hTe, [t.render && !t.render.survived ? (Y(), X("svg", fTe, mTe)) : Ve("", !0), W("div", gTe, [(h = t.render) != null && h.survived ? Ge((Y(), X("h1", _Te, null, 512)), [
            [l, "RESULTS.SURVIVED"]
        ]) : t.render && !t.render.survived ? Ge((Y(), X("h1", yTe, null, 512)), [
            [l, "RESULTS.EATEN"]
        ]) : Ve("", !0), W("div", vTe, [t.info.isVip ? Ge((Y(), X("h3", bTe, null, 512)), [
            [l, "MENU.WHAT_NEXT"]
        ]) : t.vipName ? (Y(), X("h3", ETe, _t(t.$t("MENU.WAITING_FOR", {
            vipName: t.vipName
        })), 1)) : Ve("", !0)]), t.info.isVip ? (Y(), X("div", STe, [W("div", TTe, [Ge(W("button", {
            onClick: e[0] || (e[0] = d => t.onChoiceClick("retry"))
        }, null, 512), [
            [l, "MENU.RETRY_SONG"]
        ]), Ge(W("button", {
            onClick: e[1] || (e[1] = d => t.onChoiceClick("newSong"))
        }, null, 512), [
            [l, "MENU.NEW_SONG"]
        ]), Ge(W("button", {
            onClick: e[2] || (e[2] = d => t.onChoiceClick("endSession"))
        }, null, 512), [
            [l, "MENU.END_SESSION"]
        ])])])) : Ve("", !0)]), Qe(a, {
            info: t.info,
            "is-vip": t.info.isVip && !t.info.isSolo,
            players: t.players,
            "response-key": t.player.responseKey,
            onDidRequestChangeVip: t.onDidRequestChangeVIP
        }, null, 8, ["info", "is-vip", "players", "response-key", "onDidRequestChangeVip"]), Qe(xs, {
            name: "modal"
        }, {
            default: cs(() => [t.showChangeVIP ? (Y(), Vt(c, {
                key: 0,
                info: t.info,
                players: t.players,
                "response-key": t.player.responseKey,
                onDidRequestClose: t.onDidRequestModalClose
            }, null, 8, ["info", "players", "response-key", "onDidRequestClose"])) : Ve("", !0)]),
            _: 1
        })])
    }
    const OTe = ct(lTe, [
            ["render", wTe],
            ["__scopeId", "data-v-d11e6827"]
        ]),
        ATe = yt({
            props: {
                rating: {
                    type: Number,
                    required: !0
                }
            },
            computed: {
                classes() {
                    const t = [];
                    return this.rating === 8 ? t.push("gold") : this.rating === 7 ? t.push("silver") : this.rating === 6 ? t.push("bronze") : this.rating === 5 && t.push("full"), this.rating === 0 ? t.push("rating-0") : this.rating === 1 ? t.push("rating-1") : this.rating === 2 ? t.push("rating-2") : this.rating === 3 ? t.push("rating-3") : this.rating === 4 ? t.push("rating-4") : t.push("rating-5"), t
                }
            }
        }),
        CTe = {
            key: 0,
            class: "bg-stroke",
            points: "64.76 11.33 49.22 0 35.24 12.09 31.16 28.2 13.35 26.73 0 38.26 5.39 56.27 19.81 64.16 13.23 80.33 18.75 96.75 27.77 99.87 41 95.61 49.34 86.31 60.59 96.27 73.35 100 81.19 96.31 86.58 79.82 79.87 64.16 93.73 55.82 100 37.81 84.95 26.16 67.65 27.94 64.76 11.33"
        },
        ITe = e4('<polygon class="bg" points="64.76 11.33 49.22 0 35.24 12.09 31.16 28.2 13.35 26.73 0 38.26 5.39 56.27 19.81 64.16 13.23 80.33 18.75 96.75 27.77 99.87 41 95.61 49.34 86.31 60.59 96.27 73.35 100 81.19 96.31 86.58 79.82 79.87 64.16 93.73 55.82 100 37.81 84.95 26.16 67.65 27.94 64.76 11.33" data-v-bc6516f8></polygon><polygon class="petal p5" points="6.02 40.04 9.72 51.11 20.82 59.07 33.04 59.07 44.64 52.45 38.75 41.82 29.84 33.99 16.18 32.08 6.02 40.04" data-v-bc6516f8></polygon><polygon class="petal p4" points="33.35 61.62 23.51 69.7 19.37 80.97 23.7 92.74 27.65 93.7 37.81 89.69 44.26 82.75 47.77 72.44 46.02 59.96 33.35 61.62" data-v-bc6516f8></polygon><polygon class="petal p3" points="75.24 67.92 64.2 60.6 52.98 59.83 52.73 71.8 55.61 83.51 62.76 90.83 72.23 93.83 77.49 91.28 80.5 79.19 75.24 67.92" data-v-bc6516f8></polygon><polygon class="petal p2" points="69.59 33.99 60.69 42.27 55.42 52.9 64.33 57.48 76.24 59.2 89.09 51.75 93.04 39.72 82.95 32.59 69.59 33.99" data-v-bc6516f8></polygon><polygon class="petal p1" points="62.45 29.41 60 15.47 49.34 7.57 39.56 15.47 36.68 28.2 41 38.89 49.53 47.87 57.62 40.04 62.45 29.41" data-v-bc6516f8></polygon>', 6);

    function kTe(t, e, n, r, s, i) {
        return Y(), X("svg", {
            viewBox: "0 0 100 100",
            class: mt(t.classes)
        }, [t.rating > 5 ? (Y(), X("polygon", CTe)) : Ve("", !0), ITe], 2)
    }
    const NTe = ct(ATe, [
            ["render", kTe],
            ["__scopeId", "data-v-bc6516f8"]
        ]),
        xTe = {},
        PTe = {
            viewBox: "0 0 75 100"
        },
        RTe = W("path", {
            d: "m22,21l13-10,20,11v19l17,1-2-26L31,0,11,15,3,40h18l1-19Zm51,24L1,47l-1,46,40,7,35-5-2-50Zm-31,36h-9l-1-17,6-4,5,6-1,15Z"
        }, null, -1),
        MTe = [RTe];

    function DTe(t, e) {
        return Y(), X("svg", PTe, MTe)
    }
    const $Te = ct(xTe, [
            ["render", DTe]
        ]),
        LTe = {},
        FTe = {
            viewBox: "0 0 80 100"
        },
        UTe = W("path", {
            d: "m9.69,100c-22.03-2.79-1.78-29.92,14.06-21.33V13.83L79.68,0c-1.07,7.9,2.83,79.11-2.84,84.29-3.99,7.74-16.19,13.35-23.78,7.78-9.11-11.56,9.48-25.36,21.08-19.16V11.05l-44.86,11.98v56.07c.3,10.79-8.3,20.84-19.59,20.89Z"
        }, null, -1),
        BTe = [UTe];

    function qTe(t, e) {
        return Y(), X("svg", FTe, BTe)
    }
    const VTe = ct(LTe, [
            ["render", qTe]
        ]),
        jTe = {},
        GTe = {
            viewBox: "0 0 100 65"
        },
        WTe = W("path", {
            d: "m94.78,65H5.22c-4.32,0-6.76-4.68-4.13-7.91L46.12,1.84c2-2.45,5.76-2.45,7.76,0l45.03,55.25c2.63,3.23.19,7.91-4.13,7.91Z"
        }, null, -1),
        HTe = [WTe];

    function KTe(t, e) {
        return Y(), X("svg", GTe, HTe)
    }
    const YTe = ct(jTe, [
            ["render", KTe]
        ]),
        zTe = yt({
            components: {
                ChangeVIP: ym,
                PlayerHeader: fu,
                CategorySVG: kk,
                FlowerSVG: NTe,
                LockSVG: $Te,
                NoteSVG: VTe,
                UpArrowSVG: YTe
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                players: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !0
                }
            },
            data() {
                return {
                    showChangeVIP: !1,
                    localSelectedIndex: null
                }
            },
            computed: {
                selectedIndex() {
                    return this.choices.findIndex(t => t.isSelected) ?? null
                },
                selectedChoice() {
                    return this.selectedIndex === null ? null : this.choices[this.selectedIndex] ?? null
                },
                upChoice() {
                    return this.selectedIndex === null ? null : this.selectedIndex === 0 ? this.choices[this.choices.length - 1] : this.choices[this.selectedIndex - 1]
                },
                downChoice() {
                    return this.selectedIndex === null ? null : this.selectedIndex === this.choices.length - 1 ? this.choices[0] : this.choices[this.selectedIndex + 1]
                },
                choices() {
                    const t = [];
                    return this.player.songs.songs.forEach((e, n) => {
                        if (!this.info.isVip && e.isLocked) return;
                        const r = [];
                        e.isSelected && r.push("on-screen"), n === this.localSelectedIndex && r.push("nominated"), t.push({
                            classes: r,
                            name: e.name,
                            slug: e.slug,
                            highestRating: e.highestRating,
                            categories: e.beatmapProgress,
                            isSelected: e.isSelected,
                            isLocked: e.isLocked
                        })
                    }), t
                }
            },
            mounted() {
                document.addEventListener("keydown", this.onKeyDown.bind(this))
            },
            beforeUnmount() {
                document.removeEventListener("keydown", this.onKeyDown.bind(this))
            },
            methods: {
                onDidRequestChangeVIP() {
                    this.showChangeVIP = !0
                },
                onDidRequestModalClose() {
                    this.showChangeVIP = !1
                },
                onKeyDown(t) {
                    t.key === "ArrowDown" && this.onDirectionClick("down"), t.key === "ArrowUp" && this.onDirectionClick("up")
                },
                async onDirectionClick(t) {
                    if (this.info.isVip) try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            scrollSong: t
                        })
                    } catch (e) {
                        this.$handleEcastError(e)
                    }
                },
                async onSelectClick() {
                    if (this.selectedChoice) try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            selectSong: !0
                        })
                    } catch (t) {
                        this.$handleEcastError(t)
                    }
                },
                async onVoteClick(t) {
                    this.localSelectedIndex = null, window.setTimeout(() => {
                        this.localSelectedIndex = t
                    }, 50);
                    try {
                        await this.$ecast.updateObject(this.player.responseKey, {
                            voteSong: this.choices[t].slug
                        })
                    } catch (e) {
                        this.$handleEcastError(e)
                    }
                }
            }
        }),
        ZTe = {
            class: "song-select"
        },
        XTe = {
            class: "constrain menu has-header"
        },
        QTe = {
            class: "title-wrapper"
        },
        JTe = {
            key: 0,
            class: "title"
        },
        ewe = {
            key: 1,
            class: "title"
        },
        twe = {
            key: 0,
            class: "choices"
        },
        nwe = ["aria-label"],
        rwe = ["aria-label"],
        swe = {
            key: 1,
            class: "choices"
        },
        iwe = ["onClick"],
        owe = {
            key: 0,
            class: "details"
        },
        awe = {
            class: "info"
        },
        cwe = {
            class: "name"
        },
        uwe = {
            class: "box score"
        },
        lwe = {
            class: "box parts"
        },
        hwe = {
            class: "label"
        },
        fwe = {
            class: "value indicators"
        },
        dwe = ["aria-label", "disabled"];

    function pwe(t, e, n, r, s, i) {
        var b, T, m, w;
        const a = ot("UpArrowSVG"),
            c = ot("NoteSVG"),
            l = ot("LockSVG"),
            h = ot("FlowerSVG"),
            d = ot("CategorySVG"),
            p = ot("PlayerHeader"),
            g = ot("ChangeVIP"),
            v = fn("t");
        return Y(), X("div", ZTe, [W("div", XTe, [W("div", QTe, [t.info.isVip ? Ge((Y(), X("h3", JTe, null, 512)), [
            [v, "MENU.CHOOSE_SONG"]
        ]) : Ge((Y(), X("h3", ewe, null, 512)), [
            [v, "MENU.VOTE_SONG"]
        ])]), W("div", {
            class: mt(["choices-wrapper", {
                "is-choosing": t.info.isVip
            }])
        }, [t.info.isVip ? (Y(), X("div", twe, [W("button", {
            class: "direction",
            "aria-label": t.$t("ARIA.SONG_UP", {
                songName: ((b = t.upChoice) == null ? void 0 : b.name) ?? ""
            }),
            onClick: e[0] || (e[0] = P => t.onDirectionClick("up"))
        }, [Qe(a)], 8, nwe), W("button", {
            class: "direction",
            "aria-label": t.$t("ARIA.SONG_DOWN", {
                songName: ((T = t.downChoice) == null ? void 0 : T.name) ?? ""
            }),
            onClick: e[1] || (e[1] = P => t.onDirectionClick("down"))
        }, [Qe(a)], 8, rwe)])) : (Y(), X("div", swe, [(Y(!0), X(St, null, In(t.choices, (P, V) => (Y(), X("button", {
            key: V,
            class: mt([P.classes, "choice has-icon"]),
            onClick: xi(M => t.onVoteClick(V), ["prevent"])
        }, [P === t.selectedChoice ? (Y(), Vt(c, {
            key: 0,
            class: "icon note"
        })) : Ve("", !0), Nn(" " + _t(P.name), 1)], 10, iwe))), 128))]))], 2), t.info.isVip && t.selectedChoice ? (Y(), X("div", owe, [W("div", awe, [W("p", cwe, [t.selectedChoice.isLocked ? (Y(), Vt(l, {
            key: 0,
            class: "icon"
        })) : (Y(), Vt(c, {
            key: 1,
            class: "icon"
        })), Nn(" " + _t(t.selectedChoice.name), 1)]), W("div", uwe, [Qe(h, {
            class: "flower",
            rating: t.selectedChoice.highestRating
        }, null, 8, ["rating"])]), W("div", lwe, [Ge(W("p", hwe, null, 512), [
            [v, "MENU.COMPLETED_PARTS"]
        ]), W("div", fwe, [(Y(!0), X(St, null, In(t.selectedChoice.categories, (P, V) => (Y(), Vt(d, {
            key: V,
            category: P.category,
            class: mt(["indicator", {
                perfected: P.isPerfected,
                incomplete: !P.isSurvived
            }])
        }, null, 8, ["category", "class"]))), 128))])])])])) : Ve("", !0), t.info.isVip ? Ge((Y(), X("button", {
            key: 1,
            "aria-label": t.$t("ARIA.SELECT_SONG", {
                songName: ((m = t.selectedChoice) == null ? void 0 : m.name) ?? ""
            }),
            class: "commit",
            disabled: (w = t.selectedChoice) == null ? void 0 : w.isLocked,
            onClick: e[2] || (e[2] = (...P) => t.onSelectClick && t.onSelectClick(...P))
        }, null, 8, dwe)), [
            [v, "MENU.SELECT_SONG"]
        ]) : Ve("", !0)]), Qe(p, {
            info: t.info,
            players: t.players,
            "is-vip": t.info.isVip && !t.info.isSolo,
            "response-key": t.player.responseKey,
            onDidRequestChangeVip: t.onDidRequestChangeVIP
        }, null, 8, ["info", "players", "is-vip", "response-key", "onDidRequestChangeVip"]), Qe(xs, {
            name: "modal"
        }, {
            default: cs(() => [t.showChangeVIP ? (Y(), Vt(g, {
                key: 0,
                info: t.info,
                players: t.players,
                "response-key": t.player.responseKey,
                onDidRequestClose: t.onDidRequestModalClose
            }, null, 8, ["info", "players", "response-key", "onDidRequestClose"])) : Ve("", !0)]),
            _: 1
        })])
    }
    const mwe = ct(zTe, [
            ["render", pwe],
            ["__scopeId", "data-v-e84d3f28"]
        ]),
        gwe = yt({
            components: {
                PlayerHeader: fu
            },
            props: {
                info: {
                    type: Object,
                    required: !0
                },
                player: {
                    type: Object,
                    required: !1
                }
            }
        }),
        _we = t => (Di("data-v-33c50df1"), t = t(), $i(), t),
        ywe = {
            class: "waiting"
        },
        vwe = _we(() => W("div", {
            class: "constrain menu has-header"
        }, [W("div", {
            class: "bg"
        })], -1));

    function bwe(t, e, n, r, s, i) {
        const a = ot("PlayerHeader");
        return Y(), X("div", ywe, [vwe, Qe(a, {
            info: t.info
        }, null, 8, ["info"])])
    }
    const Ewe = ct(gwe, [
            ["render", bwe],
            ["__scopeId", "data-v-33c50df1"]
        ]),
        Swe = "main/pp10/nopus-opus/assets/0523d60f.mp3",
        Twe = "main/pp10/nopus-opus/assets/6048b084.ogg",
        wwe = "main/pp10/nopus-opus/assets/a4c32d49.mp3",
        Owe = "main/pp10/nopus-opus/assets/7a6eefbc.ogg",
        Awe = "main/pp10/nopus-opus/assets/23af5ef9.mp3",
        Cwe = "main/pp10/nopus-opus/assets/47782f89.ogg";
    var wy = {
        exports: {}
    };
    (function(t, e) {
        (function() {
            var n = this,
                r = n._,
                s = Array.prototype,
                i = Object.prototype,
                a = Function.prototype,
                c = s.push,
                l = s.slice,
                h = i.toString,
                d = i.hasOwnProperty,
                p = Array.isArray,
                g = Object.keys,
                v = a.bind,
                b = Object.create,
                T = function() {},
                m = function(S) {
                    if (S instanceof m) return S;
                    if (!(this instanceof m)) return new m(S);
                    this._wrapped = S
                };
            t.exports && (e = t.exports = m), e._ = m, m.VERSION = "1.8.3";
            var w = function(S, k, H) {
                    if (k === void 0) return S;
                    switch (H ?? 3) {
                        case 1:
                            return function(K) {
                                return S.call(k, K)
                            };
                        case 2:
                            return function(K, A) {
                                return S.call(k, K, A)
                            };
                        case 3:
                            return function(K, A, y) {
                                return S.call(k, K, A, y)
                            };
                        case 4:
                            return function(K, A, y, E) {
                                return S.call(k, K, A, y, E)
                            }
                    }
                    return function() {
                        return S.apply(k, arguments)
                    }
                },
                P = function(S, k, H) {
                    return S == null ? m.identity : m.isFunction(S) ? w(S, k, H) : m.isObject(S) ? m.matcher(S) : m.property(S)
                };
            m.iteratee = function(S, k) {
                return P(S, k, 1 / 0)
            };
            var V = function(S, k) {
                    return function(H) {
                        var K = arguments.length;
                        if (K < 2 || H == null) return H;
                        for (var A = 1; A < K; A++)
                            for (var y = arguments[A], E = S(y), C = E.length, D = 0; D < C; D++) {
                                var Z = E[D];
                                (!k || H[Z] === void 0) && (H[Z] = y[Z])
                            }
                        return H
                    }
                },
                M = function(S) {
                    if (!m.isObject(S)) return {};
                    if (b) return b(S);
                    T.prototype = S;
                    var k = new T;
                    return T.prototype = null, k
                },
                I = function(S) {
                    return function(k) {
                        return k == null ? void 0 : k[S]
                    }
                },
                L = Math.pow(2, 53) - 1,
                B = I("length"),
                q = function(S) {
                    var k = B(S);
                    return typeof k == "number" && k >= 0 && k <= L
                };
            m.each = m.forEach = function(S, k, H) {
                k = w(k, H);
                var K, A;
                if (q(S))
                    for (K = 0, A = S.length; K < A; K++) k(S[K], K, S);
                else {
                    var y = m.keys(S);
                    for (K = 0, A = y.length; K < A; K++) k(S[y[K]], y[K], S)
                }
                return S
            }, m.map = m.collect = function(S, k, H) {
                k = P(k, H);
                for (var K = !q(S) && m.keys(S), A = (K || S).length, y = Array(A), E = 0; E < A; E++) {
                    var C = K ? K[E] : E;
                    y[E] = k(S[C], C, S)
                }
                return y
            };

            function se(S) {
                function k(H, K, A, y, E, C) {
                    for (; E >= 0 && E < C; E += S) {
                        var D = y ? y[E] : E;
                        A = K(A, H[D], D, H)
                    }
                    return A
                }
                return function(H, K, A, y) {
                    K = w(K, y, 4);
                    var E = !q(H) && m.keys(H),
                        C = (E || H).length,
                        D = S > 0 ? 0 : C - 1;
                    return arguments.length < 3 && (A = H[E ? E[D] : D], D += S), k(H, K, A, E, D, C)
                }
            }
            m.reduce = m.foldl = m.inject = se(1), m.reduceRight = m.foldr = se(-1), m.find = m.detect = function(S, k, H) {
                var K;
                if (q(S) ? K = m.findIndex(S, k, H) : K = m.findKey(S, k, H), K !== void 0 && K !== -1) return S[K]
            }, m.filter = m.select = function(S, k, H) {
                var K = [];
                return k = P(k, H), m.each(S, function(A, y, E) {
                    k(A, y, E) && K.push(A)
                }), K
            }, m.reject = function(S, k, H) {
                return m.filter(S, m.negate(P(k)), H)
            }, m.every = m.all = function(S, k, H) {
                k = P(k, H);
                for (var K = !q(S) && m.keys(S), A = (K || S).length, y = 0; y < A; y++) {
                    var E = K ? K[y] : y;
                    if (!k(S[E], E, S)) return !1
                }
                return !0
            }, m.some = m.any = function(S, k, H) {
                k = P(k, H);
                for (var K = !q(S) && m.keys(S), A = (K || S).length, y = 0; y < A; y++) {
                    var E = K ? K[y] : y;
                    if (k(S[E], E, S)) return !0
                }
                return !1
            }, m.contains = m.includes = m.include = function(S, k, H, K) {
                return q(S) || (S = m.values(S)), (typeof H != "number" || K) && (H = 0), m.indexOf(S, k, H) >= 0
            }, m.invoke = function(S, k) {
                var H = l.call(arguments, 2),
                    K = m.isFunction(k);
                return m.map(S, function(A) {
                    var y = K ? k : A[k];
                    return y == null ? y : y.apply(A, H)
                })
            }, m.pluck = function(S, k) {
                return m.map(S, m.property(k))
            }, m.where = function(S, k) {
                return m.filter(S, m.matcher(k))
            }, m.findWhere = function(S, k) {
                return m.find(S, m.matcher(k))
            }, m.max = function(S, k, H) {
                var K = -1 / 0,
                    A = -1 / 0,
                    y, E;
                if (k == null && S != null) {
                    S = q(S) ? S : m.values(S);
                    for (var C = 0, D = S.length; C < D; C++) y = S[C], y > K && (K = y)
                } else k = P(k, H), m.each(S, function(Z, oe, pe) {
                    E = k(Z, oe, pe), (E > A || E === -1 / 0 && K === -1 / 0) && (K = Z, A = E)
                });
                return K
            }, m.min = function(S, k, H) {
                var K = 1 / 0,
                    A = 1 / 0,
                    y, E;
                if (k == null && S != null) {
                    S = q(S) ? S : m.values(S);
                    for (var C = 0, D = S.length; C < D; C++) y = S[C], y < K && (K = y)
                } else k = P(k, H), m.each(S, function(Z, oe, pe) {
                    E = k(Z, oe, pe), (E < A || E === 1 / 0 && K === 1 / 0) && (K = Z, A = E)
                });
                return K
            }, m.shuffle = function(S) {
                for (var k = q(S) ? S : m.values(S), H = k.length, K = Array(H), A = 0, y; A < H; A++) y = m.random(0, A), y !== A && (K[A] = K[y]), K[y] = k[A];
                return K
            }, m.sample = function(S, k, H) {
                return k == null || H ? (q(S) || (S = m.values(S)), S[m.random(S.length - 1)]) : m.shuffle(S).slice(0, Math.max(0, k))
            }, m.sortBy = function(S, k, H) {
                return k = P(k, H), m.pluck(m.map(S, function(K, A, y) {
                    return {
                        value: K,
                        index: A,
                        criteria: k(K, A, y)
                    }
                }).sort(function(K, A) {
                    var y = K.criteria,
                        E = A.criteria;
                    if (y !== E) {
                        if (y > E || y === void 0) return 1;
                        if (y < E || E === void 0) return -1
                    }
                    return K.index - A.index
                }), "value")
            };
            var ce = function(S) {
                return function(k, H, K) {
                    var A = {};
                    return H = P(H, K), m.each(k, function(y, E) {
                        var C = H(y, E, k);
                        S(A, y, C)
                    }), A
                }
            };
            m.groupBy = ce(function(S, k, H) {
                m.has(S, H) ? S[H].push(k) : S[H] = [k]
            }), m.indexBy = ce(function(S, k, H) {
                S[H] = k
            }), m.countBy = ce(function(S, k, H) {
                m.has(S, H) ? S[H]++ : S[H] = 1
            }), m.toArray = function(S) {
                return S ? m.isArray(S) ? l.call(S) : q(S) ? m.map(S, m.identity) : m.values(S) : []
            }, m.size = function(S) {
                return S == null ? 0 : q(S) ? S.length : m.keys(S).length
            }, m.partition = function(S, k, H) {
                k = P(k, H);
                var K = [],
                    A = [];
                return m.each(S, function(y, E, C) {
                    (k(y, E, C) ? K : A).push(y)
                }), [K, A]
            }, m.first = m.head = m.take = function(S, k, H) {
                if (S != null) return k == null || H ? S[0] : m.initial(S, S.length - k)
            }, m.initial = function(S, k, H) {
                return l.call(S, 0, Math.max(0, S.length - (k == null || H ? 1 : k)))
            }, m.last = function(S, k, H) {
                if (S != null) return k == null || H ? S[S.length - 1] : m.rest(S, Math.max(0, S.length - k))
            }, m.rest = m.tail = m.drop = function(S, k, H) {
                return l.call(S, k == null || H ? 1 : k)
            }, m.compact = function(S) {
                return m.filter(S, m.identity)
            };
            var ue = function(S, k, H, K) {
                for (var A = [], y = 0, E = K || 0, C = B(S); E < C; E++) {
                    var D = S[E];
                    if (q(D) && (m.isArray(D) || m.isArguments(D))) {
                        k || (D = ue(D, k, H));
                        var Z = 0,
                            oe = D.length;
                        for (A.length += oe; Z < oe;) A[y++] = D[Z++]
                    } else H || (A[y++] = D)
                }
                return A
            };
            m.flatten = function(S, k) {
                return ue(S, k, !1)
            }, m.without = function(S) {
                return m.difference(S, l.call(arguments, 1))
            }, m.uniq = m.unique = function(S, k, H, K) {
                m.isBoolean(k) || (K = H, H = k, k = !1), H != null && (H = P(H, K));
                for (var A = [], y = [], E = 0, C = B(S); E < C; E++) {
                    var D = S[E],
                        Z = H ? H(D, E, S) : D;
                    k ? ((!E || y !== Z) && A.push(D), y = Z) : H ? m.contains(y, Z) || (y.push(Z), A.push(D)) : m.contains(A, D) || A.push(D)
                }
                return A
            }, m.union = function() {
                return m.uniq(ue(arguments, !0, !0))
            }, m.intersection = function(S) {
                for (var k = [], H = arguments.length, K = 0, A = B(S); K < A; K++) {
                    var y = S[K];
                    if (!m.contains(k, y)) {
                        for (var E = 1; E < H && m.contains(arguments[E], y); E++);
                        E === H && k.push(y)
                    }
                }
                return k
            }, m.difference = function(S) {
                var k = ue(arguments, !0, !0, 1);
                return m.filter(S, function(H) {
                    return !m.contains(k, H)
                })
            }, m.zip = function() {
                return m.unzip(arguments)
            }, m.unzip = function(S) {
                for (var k = S && m.max(S, B).length || 0, H = Array(k), K = 0; K < k; K++) H[K] = m.pluck(S, K);
                return H
            }, m.object = function(S, k) {
                for (var H = {}, K = 0, A = B(S); K < A; K++) k ? H[S[K]] = k[K] : H[S[K][0]] = S[K][1];
                return H
            };

            function ee(S) {
                return function(k, H, K) {
                    H = P(H, K);
                    for (var A = B(k), y = S > 0 ? 0 : A - 1; y >= 0 && y < A; y += S)
                        if (H(k[y], y, k)) return y;
                    return -1
                }
            }
            m.findIndex = ee(1), m.findLastIndex = ee(-1), m.sortedIndex = function(S, k, H, K) {
                H = P(H, K, 1);
                for (var A = H(k), y = 0, E = B(S); y < E;) {
                    var C = Math.floor((y + E) / 2);
                    H(S[C]) < A ? y = C + 1 : E = C
                }
                return y
            };

            function ge(S, k, H) {
                return function(K, A, y) {
                    var E = 0,
                        C = B(K);
                    if (typeof y == "number") S > 0 ? E = y >= 0 ? y : Math.max(y + C, E) : C = y >= 0 ? Math.min(y + 1, C) : y + C + 1;
                    else if (H && y && C) return y = H(K, A), K[y] === A ? y : -1;
                    if (A !== A) return y = k(l.call(K, E, C), m.isNaN), y >= 0 ? y + E : -1;
                    for (y = S > 0 ? E : C - 1; y >= 0 && y < C; y += S)
                        if (K[y] === A) return y;
                    return -1
                }
            }
            m.indexOf = ge(1, m.findIndex, m.sortedIndex), m.lastIndexOf = ge(-1, m.findLastIndex), m.range = function(S, k, H) {
                k == null && (k = S || 0, S = 0), H = H || 1;
                for (var K = Math.max(Math.ceil((k - S) / H), 0), A = Array(K), y = 0; y < K; y++, S += H) A[y] = S;
                return A
            };
            var G = function(S, k, H, K, A) {
                if (!(K instanceof k)) return S.apply(H, A);
                var y = M(S.prototype),
                    E = S.apply(y, A);
                return m.isObject(E) ? E : y
            };
            m.bind = function(S, k) {
                if (v && S.bind === v) return v.apply(S, l.call(arguments, 1));
                if (!m.isFunction(S)) throw new TypeError("Bind must be called on a function");
                var H = l.call(arguments, 2),
                    K = function() {
                        return G(S, K, k, this, H.concat(l.call(arguments)))
                    };
                return K
            }, m.partial = function(S) {
                var k = l.call(arguments, 1),
                    H = function() {
                        for (var K = 0, A = k.length, y = Array(A), E = 0; E < A; E++) y[E] = k[E] === m ? arguments[K++] : k[E];
                        for (; K < arguments.length;) y.push(arguments[K++]);
                        return G(S, H, this, this, y)
                    };
                return H
            }, m.bindAll = function(S) {
                var k, H = arguments.length,
                    K;
                if (H <= 1) throw new Error("bindAll must be passed function names");
                for (k = 1; k < H; k++) K = arguments[k], S[K] = m.bind(S[K], S);
                return S
            }, m.memoize = function(S, k) {
                var H = function(K) {
                    var A = H.cache,
                        y = "" + (k ? k.apply(this, arguments) : K);
                    return m.has(A, y) || (A[y] = S.apply(this, arguments)), A[y]
                };
                return H.cache = {}, H
            }, m.delay = function(S, k) {
                var H = l.call(arguments, 2);
                return setTimeout(function() {
                    return S.apply(null, H)
                }, k)
            }, m.defer = m.partial(m.delay, m, 1), m.throttle = function(S, k, H) {
                var K, A, y, E = null,
                    C = 0;
                H || (H = {});
                var D = function() {
                    C = H.leading === !1 ? 0 : m.now(), E = null, y = S.apply(K, A), E || (K = A = null)
                };
                return function() {
                    var Z = m.now();
                    !C && H.leading === !1 && (C = Z);
                    var oe = k - (Z - C);
                    return K = this, A = arguments, oe <= 0 || oe > k ? (E && (clearTimeout(E), E = null), C = Z, y = S.apply(K, A), E || (K = A = null)) : !E && H.trailing !== !1 && (E = setTimeout(D, oe)), y
                }
            }, m.debounce = function(S, k, H) {
                var K, A, y, E, C, D = function() {
                    var Z = m.now() - E;
                    Z < k && Z >= 0 ? K = setTimeout(D, k - Z) : (K = null, H || (C = S.apply(y, A), K || (y = A = null)))
                };
                return function() {
                    y = this, A = arguments, E = m.now();
                    var Z = H && !K;
                    return K || (K = setTimeout(D, k)), Z && (C = S.apply(y, A), y = A = null), C
                }
            }, m.wrap = function(S, k) {
                return m.partial(k, S)
            }, m.negate = function(S) {
                return function() {
                    return !S.apply(this, arguments)
                }
            }, m.compose = function() {
                var S = arguments,
                    k = S.length - 1;
                return function() {
                    for (var H = k, K = S[k].apply(this, arguments); H--;) K = S[H].call(this, K);
                    return K
                }
            }, m.after = function(S, k) {
                return function() {
                    if (--S < 1) return k.apply(this, arguments)
                }
            }, m.before = function(S, k) {
                var H;
                return function() {
                    return --S > 0 && (H = k.apply(this, arguments)), S <= 1 && (k = null), H
                }
            }, m.once = m.partial(m.before, 2);
            var le = !{
                    toString: null
                }.propertyIsEnumerable("toString"),
                fe = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];

            function me(S, k) {
                var H = fe.length,
                    K = S.constructor,
                    A = m.isFunction(K) && K.prototype || i,
                    y = "constructor";
                for (m.has(S, y) && !m.contains(k, y) && k.push(y); H--;) y = fe[H], y in S && S[y] !== A[y] && !m.contains(k, y) && k.push(y)
            }
            m.keys = function(S) {
                if (!m.isObject(S)) return [];
                if (g) return g(S);
                var k = [];
                for (var H in S) m.has(S, H) && k.push(H);
                return le && me(S, k), k
            }, m.allKeys = function(S) {
                if (!m.isObject(S)) return [];
                var k = [];
                for (var H in S) k.push(H);
                return le && me(S, k), k
            }, m.values = function(S) {
                for (var k = m.keys(S), H = k.length, K = Array(H), A = 0; A < H; A++) K[A] = S[k[A]];
                return K
            }, m.mapObject = function(S, k, H) {
                k = P(k, H);
                for (var K = m.keys(S), A = K.length, y = {}, E, C = 0; C < A; C++) E = K[C], y[E] = k(S[E], E, S);
                return y
            }, m.pairs = function(S) {
                for (var k = m.keys(S), H = k.length, K = Array(H), A = 0; A < H; A++) K[A] = [k[A], S[k[A]]];
                return K
            }, m.invert = function(S) {
                for (var k = {}, H = m.keys(S), K = 0, A = H.length; K < A; K++) k[S[H[K]]] = H[K];
                return k
            }, m.functions = m.methods = function(S) {
                var k = [];
                for (var H in S) m.isFunction(S[H]) && k.push(H);
                return k.sort()
            }, m.extend = V(m.allKeys), m.extendOwn = m.assign = V(m.keys), m.findKey = function(S, k, H) {
                k = P(k, H);
                for (var K = m.keys(S), A, y = 0, E = K.length; y < E; y++)
                    if (A = K[y], k(S[A], A, S)) return A
            }, m.pick = function(S, k, H) {
                var K = {},
                    A = S,
                    y, E;
                if (A == null) return K;
                m.isFunction(k) ? (E = m.allKeys(A), y = w(k, H)) : (E = ue(arguments, !1, !1, 1), y = function(pe, _e, he) {
                    return _e in he
                }, A = Object(A));
                for (var C = 0, D = E.length; C < D; C++) {
                    var Z = E[C],
                        oe = A[Z];
                    y(oe, Z, A) && (K[Z] = oe)
                }
                return K
            }, m.omit = function(S, k, H) {
                if (m.isFunction(k)) k = m.negate(k);
                else {
                    var K = m.map(ue(arguments, !1, !1, 1), String);
                    k = function(A, y) {
                        return !m.contains(K, y)
                    }
                }
                return m.pick(S, k, H)
            }, m.defaults = V(m.allKeys, !0), m.create = function(S, k) {
                var H = M(S);
                return k && m.extendOwn(H, k), H
            }, m.clone = function(S) {
                return m.isObject(S) ? m.isArray(S) ? S.slice() : m.extend({}, S) : S
            }, m.tap = function(S, k) {
                return k(S), S
            }, m.isMatch = function(S, k) {
                var H = m.keys(k),
                    K = H.length;
                if (S == null) return !K;
                for (var A = Object(S), y = 0; y < K; y++) {
                    var E = H[y];
                    if (k[E] !== A[E] || !(E in A)) return !1
                }
                return !0
            };
            var Te = function(S, k, H, K) {
                if (S === k) return S !== 0 || 1 / S === 1 / k;
                if (S == null || k == null) return S === k;
                S instanceof m && (S = S._wrapped), k instanceof m && (k = k._wrapped);
                var A = h.call(S);
                if (A !== h.call(k)) return !1;
                switch (A) {
                    case "[object RegExp]":
                    case "[object String]":
                        return "" + S == "" + k;
                    case "[object Number]":
                        return +S != +S ? +k != +k : +S == 0 ? 1 / +S === 1 / k : +S == +k;
                    case "[object Date]":
                    case "[object Boolean]":
                        return +S == +k
                }
                var y = A === "[object Array]";
                if (!y) {
                    if (typeof S != "object" || typeof k != "object") return !1;
                    var E = S.constructor,
                        C = k.constructor;
                    if (E !== C && !(m.isFunction(E) && E instanceof E && m.isFunction(C) && C instanceof C) && "constructor" in S && "constructor" in k) return !1
                }
                H = H || [], K = K || [];
                for (var D = H.length; D--;)
                    if (H[D] === S) return K[D] === k;
                if (H.push(S), K.push(k), y) {
                    if (D = S.length, D !== k.length) return !1;
                    for (; D--;)
                        if (!Te(S[D], k[D], H, K)) return !1
                } else {
                    var Z = m.keys(S),
                        oe;
                    if (D = Z.length, m.keys(k).length !== D) return !1;
                    for (; D--;)
                        if (oe = Z[D], !(m.has(k, oe) && Te(S[oe], k[oe], H, K))) return !1
                }
                return H.pop(), K.pop(), !0
            };
            m.isEqual = function(S, k) {
                return Te(S, k)
            }, m.isEmpty = function(S) {
                return S == null ? !0 : q(S) && (m.isArray(S) || m.isString(S) || m.isArguments(S)) ? S.length === 0 : m.keys(S).length === 0
            }, m.isElement = function(S) {
                return !!(S && S.nodeType === 1)
            }, m.isArray = p || function(S) {
                return h.call(S) === "[object Array]"
            }, m.isObject = function(S) {
                var k = typeof S;
                return k === "function" || k === "object" && !!S
            }, m.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error"], function(S) {
                m["is" + S] = function(k) {
                    return h.call(k) === "[object " + S + "]"
                }
            }), m.isArguments(arguments) || (m.isArguments = function(S) {
                return m.has(S, "callee")
            }), typeof /./ != "function" && typeof Int8Array != "object" && (m.isFunction = function(S) {
                return typeof S == "function" || !1
            }), m.isFinite = function(S) {
                return isFinite(S) && !isNaN(parseFloat(S))
            }, m.isNaN = function(S) {
                return m.isNumber(S) && S !== +S
            }, m.isBoolean = function(S) {
                return S === !0 || S === !1 || h.call(S) === "[object Boolean]"
            }, m.isNull = function(S) {
                return S === null
            }, m.isUndefined = function(S) {
                return S === void 0
            }, m.has = function(S, k) {
                return S != null && d.call(S, k)
            }, m.noConflict = function() {
                return n._ = r, this
            }, m.identity = function(S) {
                return S
            }, m.constant = function(S) {
                return function() {
                    return S
                }
            }, m.noop = function() {}, m.property = I, m.propertyOf = function(S) {
                return S == null ? function() {} : function(k) {
                    return S[k]
                }
            }, m.matcher = m.matches = function(S) {
                return S = m.extendOwn({}, S),
                    function(k) {
                        return m.isMatch(k, S)
                    }
            }, m.times = function(S, k, H) {
                var K = Array(Math.max(0, S));
                k = w(k, H, 1);
                for (var A = 0; A < S; A++) K[A] = k(A);
                return K
            }, m.random = function(S, k) {
                return k == null && (k = S, S = 0), S + Math.floor(Math.random() * (k - S + 1))
            }, m.now = Date.now || function() {
                return new Date().getTime()
            };
            var we = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#x27;",
                    "`": "&#x60;"
                },
                ke = m.invert(we),
                Ie = function(S) {
                    var k = function(y) {
                            return S[y]
                        },
                        H = "(?:" + m.keys(S).join("|") + ")",
                        K = RegExp(H),
                        A = RegExp(H, "g");
                    return function(y) {
                        return y = y == null ? "" : "" + y, K.test(y) ? y.replace(A, k) : y
                    }
                };
            m.escape = Ie(we), m.unescape = Ie(ke), m.result = function(S, k, H) {
                var K = S == null ? void 0 : S[k];
                return K === void 0 && (K = H), m.isFunction(K) ? K.call(S) : K
            };
            var $e = 0;
            m.uniqueId = function(S) {
                var k = ++$e + "";
                return S ? S + k : k
            }, m.templateSettings = {
                evaluate: /<%([\s\S]+?)%>/g,
                interpolate: /<%=([\s\S]+?)%>/g,
                escape: /<%-([\s\S]+?)%>/g
            };
            var At = /(.)^/,
                $t = {
                    "'": "'",
                    "\\": "\\",
                    "\r": "r",
                    "\n": "n",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                },
                qe = /\\|'|\r|\n|\u2028|\u2029/g,
                Xe = function(S) {
                    return "\\" + $t[S]
                };
            m.template = function(S, k, H) {
                !k && H && (k = H), k = m.defaults({}, k, m.templateSettings);
                var K = RegExp([(k.escape || At).source, (k.interpolate || At).source, (k.evaluate || At).source].join("|") + "|$", "g"),
                    A = 0,
                    y = "__p+='";
                S.replace(K, function(Z, oe, pe, _e, he) {
                    return y += S.slice(A, he).replace(qe, Xe), A = he + Z.length, oe ? y += `'+
((__t=(` + oe + `))==null?'':_.escape(__t))+
'` : pe ? y += `'+
((__t=(` + pe + `))==null?'':__t)+
'` : _e && (y += `';
` + _e + `
__p+='`), Z
                }), y += `';
`, k.variable || (y = `with(obj||{}){
` + y + `}
`), y = `var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
` + y + `return __p;
`;
                try {
                    var E = new Function(k.variable || "obj", "_", y)
                } catch (Z) {
                    throw Z.source = y, Z
                }
                var C = function(Z) {
                        return E.call(this, Z, m)
                    },
                    D = k.variable || "obj";
                return C.source = "function(" + D + `){
` + y + "}", C
            }, m.chain = function(S) {
                var k = m(S);
                return k._chain = !0, k
            };
            var tt = function(S, k) {
                return S._chain ? m(k).chain() : k
            };
            m.mixin = function(S) {
                m.each(m.functions(S), function(k) {
                    var H = m[k] = S[k];
                    m.prototype[k] = function() {
                        var K = [this._wrapped];
                        return c.apply(K, arguments), tt(this, H.apply(m, K))
                    }
                })
            }, m.mixin(m), m.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(S) {
                var k = s[S];
                m.prototype[S] = function() {
                    var H = this._wrapped;
                    return k.apply(H, arguments), (S === "shift" || S === "splice") && H.length === 0 && delete H[0], tt(this, H)
                }
            }), m.each(["concat", "join", "slice"], function(S) {
                var k = s[S];
                m.prototype[S] = function() {
                    return tt(this, k.apply(this._wrapped, arguments))
                }
            }), m.prototype.value = function() {
                return this._wrapped
            }, m.prototype.valueOf = m.prototype.toJSON = m.prototype.value, m.prototype.toString = function() {
                return "" + this._wrapped
            }
        }).call(hn)
    })(wy, wy.exports);
    var Iwe = wy.exports;
    const kwe = yt({
        components: {
            BaseModal: WC
        },
        setup() {
            const t = It.supportsType("ogg") ? "ogg" : "mp3",
                e = new xl({
                    welcome1: new URL(Object.assign({
                        "../../assets/welcome1.mp3": Swe,
                        "../../assets/welcome1.ogg": Twe
                    })[`../../assets/welcome1.${t}`], self.location).href,
                    welcome2: new URL(Object.assign({
                        "../../assets/welcome2.mp3": wwe,
                        "../../assets/welcome2.ogg": Owe
                    })[`../../assets/welcome2.${t}`], self.location).href,
                    welcome3: new URL(Object.assign({
                        "../../assets/welcome3.mp3": Awe,
                        "../../assets/welcome3.ogg": Cwe
                    })[`../../assets/welcome3.${t}`], self.location).href
                }).toDestination();
            return e.volume.value = -3, {
                players: e
            }
        },
        methods: {
            onCloseClick() {
                this.$emit("didRequestClose")
            },
            async onTestClick() {
                const t = ["welcome1", "welcome2", "welcome3"];
                try {
                    await HI(), this.players.player(Iwe.sample(t)).start(0, .01)
                } catch (e) {
                    console.warn(e)
                }
            }
        }
    });

    function Nwe(t, e, n, r, s, i) {
        const a = ot("BaseModal"),
            c = fn("t");
        return Y(), Vt(a, {
            "title-key": "WELCOME.WELCOME"
        }, {
            default: cs(() => [W("ul", null, [Ge(W("li", null, null, 512), [
                [c, "WELCOME.SILENT"]
            ]), Ge(W("li", null, null, 512), [
                [c, "WELCOME.VOLUME"]
            ]), Ge(W("li", null, null, 512), [
                [c, "WELCOME.POWER_SAVER"]
            ])]), Ge(W("button", {
                class: "choice",
                onClick: e[0] || (e[0] = (...l) => t.onTestClick && t.onTestClick(...l))
            }, null, 512), [
                [c, "WELCOME.TEST"]
            ]), Ge(W("button", {
                class: "secondary close",
                onClick: e[1] || (e[1] = (...l) => t.onCloseClick && t.onCloseClick(...l))
            }, null, 512), [
                [c, "WELCOME.GO"]
            ])]),
            _: 1
        }, 8, ["title-key"])
    }
    const xwe = ct(kwe, [
            ["render", Nwe]
        ]),
        Pwe = yt({
            components: {
                Credits: vpe,
                InstrumentSelect: kEe,
                Playback: DEe,
                Recording: uTe,
                Scoreboard: OTe,
                SongSelect: mwe,
                Waiting: Ewe,
                Welcome: xwe
            },
            bb: {
                break: () => "<br />",
                info: (t, e) => `<span class="sub">${e}</span>`
            },
            ecastKeys: {
                audience: "audiencePlayer",
                player: ({
                    id: t
                }) => `player:${t}`,
                players: "connectedPlayers"
            },
            ecastProviders: {
                beatmaps: t => {
                    const e = {};
                    return Object.keys(t).forEach(n => {
                        const [r, s] = n.split(":");
                        r === "beatmap" && (e[s] = t[n])
                    }), e
                },
                hostIsPaused: t => {
                    var e;
                    return ((e = t.hostIsPaused) == null ? void 0 : e.hostIsPaused) ?? !1
                },
                info: (t, {
                    id: e
                }) => {
                    const n = t.connectedPlayers[e];
                    return t.audiencePlayer || !n ? {
                        name: "",
                        id: e,
                        avatar: 99,
                        isAudience: !0
                    } : t.connectedPlayers ? (Object.keys(t.connectedPlayers).length === 1 && (n.isSolo = !0), n) : void 0
                },
                instruments: t => {
                    const e = {};
                    return Object.keys(t).forEach(n => {
                        const [r, s] = n.split(":");
                        r === "instrument" && (e[s] = t[n])
                    }), e
                },
                renders: t => t.songData ? t.songData.songs : []
            },
            props: {
                audience: Object,
                beatmaps: Object,
                hostIsPaused: Boolean,
                info: Object,
                instruments: Object,
                player: Object,
                players: Object,
                renders: Array
            },
            themeColor: "#000",
            data() {
                return {
                    showWelcome: !1,
                    themeClass: "bg-default"
                }
            },
            computed: {
                isReady() {
                    return !(!this.player && !this.audience || this.player && !this.info)
                },
                lastRender() {
                    var t;
                    return (t = this.renders) != null && t.length ? this.renders[this.renders.length - 1] : null
                },
                screen() {
                    var n, r;
                    const t = ((n = this.player) == null ? void 0 : n.kind) ?? ((r = this.audience) == null ? void 0 : r.kind),
                        e = {
                            info: this.info,
                            player: this.player ?? this.audience
                        };
                    switch (t) {
                        case "credits":
                            return e.renders = this.renders, e.players = this.players, ["Credits", e];
                        case "playback":
                            return ["Playback", e];
                        case "audienceRecording":
                        case "recording":
                            const s = this.getBeatmapAndInstrument();
                            return s ? (e.hostIsPaused = this.hostIsPaused, e.beatmap = s[0], e.instrument = s[1], ["Recording", e]) : ["Waiting", e];
                        case "instrumentSelect":
                            return e.beatmaps = this.beatmaps, e.instruments = this.instruments, e.players = this.players, ["InstrumentSelect", e];
                        case "scoreboard":
                            return e.players = this.players, e.render = this.lastRender, ["Scoreboard", e];
                        case "songSelect":
                            return e.players = this.players, ["SongSelect", e]
                    }
                    return ["Waiting", e]
                }
            },
            watch: {
                "player.kind": "updateColors",
                "audience.kind": "updateColors"
            },
            mounted() {
                var t, e;
                this.updateColors(((t = this.player) == null ? void 0 : t.kind) ?? ((e = this.audience) == null ? void 0 : e.kind) ?? "", !0), document.body.classList.add("disabled-debug"), setTimeout(() => {
                    var r;
                    !un.get("welcome", "code") && ((r = this.info) == null ? void 0 : r.name) !== "CARTOGRAPHER" && (this.showWelcome = !0, un.set("welcome", "true", "code"))
                }, 500)
            },
            methods: {
                onDidRequestModalClose() {
                    this.showWelcome = !1
                },
                getBeatmapAndInstrument() {
                    if (!this.info || !this.beatmaps || !this.instruments) return null;
                    const t = this.info.isAudience ? un.get("beatmap", "code") : this.info.beatmapSlug,
                        e = this.info.isAudience ? un.get("instrument", "code") : this.info.instrumentSlug;
                    if (!t || !e) return null;
                    const n = this.beatmaps[t],
                        r = this.instruments[e];
                    return !n || !r ? null : [n, r]
                },
                updateColors(t, e = !1) {
                    var n;
                    if (t === "audienceRecording") {
                        this.themeClass = "theme-blue", this.$setThemeColor("#3a3d75");
                        return
                    }
                    if (t === "credits") {
                        this.themeClass = "theme-purple", this.$setThemeColor("#000000");
                        return
                    }
                    if (t === "instrumentSelect") {
                        this.themeClass = "theme-purple", this.$setThemeColor("#000000");
                        return
                    }
                    if (t === "playback") {
                        this.themeClass = "theme-purple", this.$setThemeColor("#300f4a");
                        return
                    }
                    if (t === "recording") {
                        this.themeClass = "theme-purple", this.$setThemeColor("#300f4a");
                        return
                    }
                    if (t === "scoreboard") {
                        this.themeClass = (n = this.lastRender) != null && n.survived ? "theme-yellow" : "theme-purple", this.$setThemeColor("#000000");
                        return
                    }
                    if (t === "songSelect") {
                        this.themeClass = "theme-green", this.$setThemeColor("#000000");
                        return
                    }
                    e === !0 && (this.themeClass = "theme-green", this.$setThemeColor("#000000"))
                }
            }
        });

    function Rwe(t, e, n, r, s, i) {
        const a = ot("Welcome");
        return t.isReady ? (Y(), X("div", {
            key: 0,
            class: mt(["nopus", t.themeClass])
        }, [t.screen ? (Y(), Vt(qy(t.screen[0]), Up({
            key: 0,
            role: "main"
        }, t.screen[1]), null, 16)) : Ve("", !0), Qe(xs, {
            name: "modal"
        }, {
            default: cs(() => [t.showWelcome ? (Y(), Vt(a, {
                key: 0,
                onDidRequestClose: t.onDidRequestModalClose
            }, null, 8, ["onDidRequestClose"])) : Ve("", !0)]),
            _: 1
        })], 2)) : Ve("", !0)
    }
    const Mwe = ct(Pwe, [
        ["render", Rwe]
    ]);
    vhe({
        MainView: Mwe,
        messages: Ife,
        plugins: [Aue]
    })
});
export default Dwe();
//# sourceMappingURL=990c7cf3.js.map